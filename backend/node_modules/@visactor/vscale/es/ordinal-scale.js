import { ScaleEnum } from "./type";

import { BaseScale } from "./base-scale";

import { isValid } from "@visactor/vutils";

export const implicit = Symbol("implicit");

export class OrdinalScale extends BaseScale {
    specified(_) {
        var _a;
        return _ ? (this._specified = Object.assign(null !== (_a = this._specified) && void 0 !== _a ? _a : {}, _), 
        this) : Object.assign({}, this._specified);
    }
    _getSpecifiedValue(input) {
        if (this._specified) return this._specified[input];
    }
    constructor() {
        super(), this.type = ScaleEnum.Ordinal, this._index = new Map, this._domain = [], 
        this._ordinalRange = [], this._unknown = implicit;
    }
    clone() {
        const s = (new OrdinalScale).domain(this._domain).range(this._ordinalRange).unknown(this._unknown);
        return this._specified && s.specified(this._specified), s;
    }
    calculateVisibleDomain(range) {
        if (isValid(this._rangeFactorStart) && isValid(this._rangeFactorEnd) && 2 === range.length) {
            return [ this.invert(range[0]), this.invert(range[1]) ];
        }
        return this._domain;
    }
    scale(d) {
        const key = `${d}`, special = this._getSpecifiedValue(key);
        if (void 0 !== special) return special;
        let i = this._index.get(key);
        if (!i) {
            if (this._unknown !== implicit) return this._unknown;
            i = this._domain.push(d), this._index.set(key, i);
        }
        const output = this._ordinalRange[(i - 1) % this._ordinalRange.length];
        return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
    }
    invert(d) {
        let i = 0;
        for (;i < this._ordinalRange.length && this._ordinalRange[i] !== d; ) i++;
        return this._domain[(i - 1) % this._domain.length];
    }
    domain(_) {
        if (!_) return this._domain.slice();
        this._domain = [], this._index = new Map;
        for (const value of _) {
            const key = `${value}`;
            this._index.has(key) || this._index.set(key, this._domain.push(value));
        }
        return this;
    }
    range(_) {
        if (!_) return this._ordinalRange.slice();
        const nextRange = Array.from(_);
        return this._ordinalRange = nextRange, this;
    }
    index(x) {
        var _a;
        return this._index && null !== (_a = this._index.get(`${x}`)) && void 0 !== _a ? _a : -1;
    }
}
//# sourceMappingURL=ordinal-scale.js.map