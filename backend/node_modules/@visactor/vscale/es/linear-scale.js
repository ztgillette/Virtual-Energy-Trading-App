import { ScaleEnum } from "./type";

import { d3Ticks, forceTicks, niceLinear, parseNiceOptions, stepTicks, ticks } from "./utils/tick-sample";

import { ContinuousScale } from "./continuous-scale";

import { isFunction, isValid } from "@visactor/vutils";

export class LinearScale extends ContinuousScale {
    constructor() {
        super(...arguments), this.type = ScaleEnum.Linear;
    }
    clone() {
        var _a;
        const scale = new LinearScale;
        return scale.domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate), 
        this._niceType && (scale._niceType = this._niceType, scale._domainValidator = this._domainValidator, 
        scale._niceDomain = null === (_a = this._niceDomain) || void 0 === _a ? void 0 : _a.slice()), 
        scale;
    }
    tickFormat() {
        return () => {};
    }
    d3Ticks(count = 10, options) {
        const d = this.calculateVisibleDomain(this._range);
        return d3Ticks(d[0], d[d.length - 1], count, options);
    }
    ticks(count = 10, options) {
        var _a;
        if (isFunction(null == options ? void 0 : options.customTicks)) return options.customTicks(this, count);
        if (isValid(this._rangeFactorStart) && isValid(this._rangeFactorEnd) && (this._rangeFactorStart > 0 || this._rangeFactorEnd < 1) && 2 === this._range.length || !this._niceType) return this.d3Ticks(count, options);
        const curNiceDomain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, originalDomain = this._domain, start = curNiceDomain[0], stop = curNiceDomain[curNiceDomain.length - 1];
        let ticksResult = ticks(originalDomain[0], originalDomain[originalDomain.length - 1], count, options);
        if (!ticksResult.length) return ticksResult;
        if (this._domainValidator) ticksResult = ticksResult.filter(this._domainValidator); else if ((ticksResult[0] !== start || ticksResult[ticksResult.length - 1] !== stop) && this._niceType) {
            const newNiceDomain = curNiceDomain.slice();
            if ("all" === this._niceType ? (newNiceDomain[0] = ticksResult[0], newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], 
            this._niceDomain = newNiceDomain, this.rescale()) : "min" === this._niceType && ticksResult[0] !== start ? (newNiceDomain[0] = ticksResult[0], 
            this._niceDomain = newNiceDomain, this.rescale()) : "max" === this._niceType && ticksResult[ticksResult.length - 1] !== stop && (newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], 
            this._niceDomain = newNiceDomain, this.rescale()), "all" !== this._niceType) {
                const min = Math.min(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]), max = Math.max(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]);
                ticksResult = ticksResult.filter((entry => entry >= min && entry <= max));
            }
        }
        return ticksResult;
    }
    forceTicks(count = 10) {
        const d = this.calculateVisibleDomain(this._range);
        return forceTicks(d[0], d[d.length - 1], count);
    }
    stepTicks(step) {
        const d = this.calculateVisibleDomain(this._range);
        return stepTicks(d[0], d[d.length - 1], step);
    }
    nice(count = 10, option) {
        var _a, _b;
        const originalDomain = this._domain;
        let niceMinMax = [];
        if (option) {
            const res = parseNiceOptions(originalDomain, option);
            if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, this._niceType = res.niceType, 
            res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
        } else this._niceType = "all";
        if (this._niceType) {
            const niceDomain = niceLinear(originalDomain.slice(), count);
            "min" === this._niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === this._niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), 
            this._niceDomain = niceDomain, this.rescale();
        }
        return this;
    }
    niceMin(count = 10) {
        this._niceType = "min";
        const maxD = this._domain[this._domain.length - 1], niceDomain = niceLinear(this.domain(), count);
        return niceDomain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, 
        this.rescale()), this;
    }
    niceMax(count = 10) {
        this._niceType = "max";
        const minD = this._domain[0], niceDomain = niceLinear(this._domain.slice(), count);
        return niceDomain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), 
        this;
    }
}
//# sourceMappingURL=linear-scale.js.map