{"version":3,"sources":["../src/axis/tick-data/continuous.ts"],"names":[],"mappings":"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","file":"continuous.js","sourcesContent":["import type { LinearScale, ContinuousScale } from '@visactor/vscale';\n// eslint-disable-next-line no-duplicate-imports\nimport { isContinuous } from '@visactor/vscale';\nimport { isFunction, isValid, last } from '@visactor/vutils';\nimport type { ICartesianTickDataOpt, ILabelItem, ITickData, ITickDataOpt } from '../type';\n// eslint-disable-next-line no-duplicate-imports\nimport { convertDomainToTickData, getCartesianLabelBounds } from './util';\nimport { textIntersect as intersect, hasOverlap } from '../util';\n\nconst filterTicksByBreak = (ticks: number[], breakDomains: [number, number][]) => {\n  return breakDomains && breakDomains.length\n    ? ticks.filter(tick => {\n        return breakDomains.every(breakDomain => {\n          return tick < breakDomain[0] || tick > breakDomain[1];\n        });\n      })\n    : ticks;\n};\nfunction getScaleTicks(\n  op: ITickDataOpt,\n  scale: ContinuousScale,\n  count: number,\n  getTicks: (count: number, domain?: [number, number]) => number[]\n) {\n  let scaleTicks: number[];\n  const { breakData } = op;\n\n  // Todo: @zwx 将截断的逻辑挪到 scale 中\n  if (breakData && breakData()) {\n    const { breakDomains } = breakData();\n    const domain = scale.domain();\n    scaleTicks = [];\n    for (let i = 0; i < domain.length - 1; i++) {\n      const subDomain: [number, number] = [domain[i], domain[i + 1]];\n      const ticks = getTicks(count, subDomain); // 暂时不对个数进行分段\n      ticks.forEach(tick => {\n        if (!breakDomains.some(breakDomain => tick >= breakDomain[0] && tick <= breakDomain[1])) {\n          scaleTicks.push(tick);\n        }\n      });\n    }\n    // reset\n    (scale as LinearScale).domain(domain);\n  } else {\n    scaleTicks = getTicks(count);\n  }\n\n  return scaleTicks;\n}\n\nfunction forceItemVisible(\n  sourceItem: ILabelItem<number>,\n  items: ILabelItem<number>[],\n  check: boolean,\n  comparator: any,\n  inverse = false\n) {\n  if (check && !items.includes(sourceItem)) {\n    let remainLength = items.length;\n    if (remainLength > 1) {\n      if (inverse) {\n        items.push(sourceItem);\n      } else {\n        items.unshift(sourceItem);\n      }\n      for (let i = 0; i < remainLength; i++) {\n        const index = inverse ? remainLength - 1 - i : i;\n        if (comparator(items[index])) {\n          items.splice(index, 1);\n          i--;\n          remainLength--;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n}\n/** 连续轴默认 tick 数量 */\nexport const DEFAULT_CONTINUOUS_TICK_COUNT = 5;\n/**\n * 对于连续轴：\n * - 如果spec配了tickCount、forceTickCount、tickStep，则直接输出LinearScale的ticks()、forceTicks()、stepTicks()结果；\n * - 默认输出tickCount为10的ticks()结果。\n *\n * @param scale\n * @param op\n * @returns\n */\nexport const continuousTicks = (scale: ContinuousScale, op: ITickDataOpt): ITickData[] => {\n  if (!isContinuous(scale.type)) {\n    return convertDomainToTickData(scale.domain());\n  }\n  // if range is so small\n  const range = scale.range();\n  const rangeSize = Math.abs(range[range.length - 1] - range[0]);\n  if (rangeSize < 2) {\n    return convertDomainToTickData([scale.domain()[0]]);\n  }\n\n  const { tickCount, forceTickCount, tickStep, noDecimals = false, labelStyle, breakData } = op;\n\n  let scaleTicks: number[];\n  if (isValid(tickStep)) {\n    scaleTicks = filterTicksByBreak(\n      (scale as LinearScale).stepTicks(tickStep),\n      breakData && breakData() ? breakData().breakDomains : null\n    );\n  } else if (isValid(forceTickCount)) {\n    scaleTicks = getScaleTicks(op, scale, forceTickCount, (count: number, subDomain?: [number, number]) => {\n      if (subDomain && subDomain.length) {\n        return (scale as LinearScale).domain(subDomain, true).forceTicks(count);\n      }\n      return (scale as LinearScale).forceTicks(count);\n    });\n  } else if (op.tickMode === 'd3') {\n    const count =\n      (isFunction(tickCount) ? tickCount({ axisLength: rangeSize, labelStyle }) : tickCount) ??\n      DEFAULT_CONTINUOUS_TICK_COUNT;\n\n    scaleTicks = getScaleTicks(op, scale, count, (count: number, subDomain?: [number, number]) => {\n      if (subDomain && subDomain.length) {\n        return (scale as LinearScale).domain(subDomain, true).d3Ticks(count, { noDecimals });\n      }\n      return (scale as LinearScale).d3Ticks(count, { noDecimals });\n    });\n  } else {\n    const count =\n      (isFunction(tickCount) ? tickCount({ axisLength: rangeSize, labelStyle }) : tickCount) ??\n      DEFAULT_CONTINUOUS_TICK_COUNT;\n    const customTicks = isFunction(op.tickMode) ? op.tickMode : undefined;\n\n    scaleTicks = getScaleTicks(op, scale, count, (count: number, subDomain?: [number, number]) => {\n      if (subDomain && subDomain.length) {\n        return (scale as LinearScale).domain(subDomain, true).ticks(count, { noDecimals, customTicks });\n      }\n      return (scale as LinearScale).ticks(count, { noDecimals, customTicks });\n    });\n  }\n\n  const domain = scale.domain();\n\n  if (op.labelFirstVisible && domain[0] !== scaleTicks[0] && !scaleTicks.includes(domain[0])) {\n    scaleTicks.unshift(domain[0]);\n  }\n\n  if (\n    op.labelLastVisible &&\n    domain[domain.length - 1] !== scaleTicks[scaleTicks.length - 1] &&\n    !scaleTicks.includes(domain[domain.length - 1])\n  ) {\n    scaleTicks.push(domain[domain.length - 1]);\n  }\n  if (op.sampling && scaleTicks.length > 1) {\n    // 判断重叠\n    if (op.coordinateType === 'cartesian' || (op.coordinateType === 'polar' && op.axisOrientType === 'radius')) {\n      const { labelGap = 4, labelFlush } = op as ICartesianTickDataOpt;\n      const MIN_FONT_SIZE = 6;\n      let items: ILabelItem<number>[];\n      // 刻度个数 > 像素个数的情况，先做一层预估，减少计算，避免卡死的情况\n      if (scaleTicks.length * MIN_FONT_SIZE > rangeSize) {\n        const samplingScaleTicks: number[] = [];\n        const step = Math.floor((scaleTicks.length * MIN_FONT_SIZE) / rangeSize);\n        scaleTicks.forEach((tick, index) => {\n          if (index % step === 0 || index === scaleTicks.length - 1) {\n            samplingScaleTicks.push(tick);\n          }\n        });\n        items = getCartesianLabelBounds(scale, samplingScaleTicks, op as ICartesianTickDataOpt)?.map(\n          (bounds, i) =>\n            ({\n              AABBBounds: bounds,\n              value: samplingScaleTicks[i]\n            } as ILabelItem<number>)\n        );\n      } else {\n        items = getCartesianLabelBounds(scale, scaleTicks, op as ICartesianTickDataOpt)?.map(\n          (bounds, i) =>\n            ({\n              AABBBounds: bounds,\n              value: scaleTicks[i]\n            } as ILabelItem<number>)\n        );\n      }\n\n      if (items) {\n        const firstSourceItem = items[0];\n        const lastSourceItem = last(items);\n\n        const samplingMethod = breakData && breakData() ? methods.greedy : methods.parity; // 由于轴截断后刻度会存在不均匀的情况，所以不能使用 parity 算法\n        while (items.length >= 3 && hasOverlap(items as any, labelGap)) {\n          items = samplingMethod(items, labelGap);\n        }\n\n        const checkFirst = op.labelFirstVisible;\n        let checkLast = op.labelLastVisible; // 这里和 auto-hide 里的逻辑有差异，不根据 length 自动强制显示最后一个（会引起 vtable 较多 badcase）。\n\n        if (intersect(firstSourceItem as any, lastSourceItem as any, labelGap)) {\n          if (items.includes(lastSourceItem) && items.length > 1 && checkFirst && checkLast) {\n            items.splice(items.indexOf(lastSourceItem), 1);\n            checkLast = false;\n          }\n        }\n\n        forceItemVisible(firstSourceItem, items, checkFirst, (item: ILabelItem<number>) =>\n          intersect(item as any, firstSourceItem as any, labelGap)\n        );\n        forceItemVisible(\n          lastSourceItem,\n          items,\n          checkLast,\n          (item: ILabelItem<number>) =>\n            intersect(item as any, lastSourceItem as any, labelGap) ||\n            (checkFirst && item !== firstSourceItem ? intersect(item as any, firstSourceItem as any, labelGap) : false),\n          true\n        );\n\n        const ticks = items.map(item => item.value);\n\n        if (ticks.length < 3 && labelFlush) {\n          if (ticks.length > 1) {\n            ticks.pop();\n          }\n          if (last(ticks) !== last(scaleTicks)) {\n            ticks.push(last(scaleTicks));\n          }\n        }\n\n        scaleTicks = ticks;\n      }\n    }\n  }\n  return convertDomainToTickData(scaleTicks);\n};\n\nconst methods = {\n  parity: function <T>(items: ILabelItem<T>[]) {\n    return items.filter((item, i) => i % 2 === 0);\n  },\n  greedy: function <T>(items: ILabelItem<T>[], sep: number) {\n    let a: ILabelItem<T>;\n    return items.filter((b, i) => {\n      if (!i || !intersect(a as any, b as any, sep)) {\n        a = b;\n        return true;\n      }\n      return false;\n    });\n  }\n};\n"]}