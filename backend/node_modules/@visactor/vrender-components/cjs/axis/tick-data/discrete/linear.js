"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.linearDiscreteTicks = exports.boundsDistance = void 0;

const vutils_1 = require("@visactor/vutils"), util_1 = require("../util"), getOneDimensionalLabelBounds = (scale, domain, op, isHorizontal) => {
    const labelBoundsList = (0, util_1.getCartesianLabelBounds)(scale, domain, op);
    return labelBoundsList && labelBoundsList.map((bounds => isHorizontal ? [ bounds.x1, bounds.x2, bounds.width() ] : [ bounds.y1, bounds.y2, bounds.height() ]));
}, boundsOverlap = (prevBounds, nextBounds, gap = 0) => Math.max(prevBounds[0], nextBounds[0]) - gap / 2 <= Math.min(prevBounds[1], nextBounds[1]) + gap / 2, boundsDistance = (prevBounds, nextBounds) => prevBounds[1] < nextBounds[0] ? nextBounds[0] - prevBounds[1] : nextBounds[1] < prevBounds[0] ? prevBounds[0] - nextBounds[1] : 0;

exports.boundsDistance = boundsDistance;

const linearDiscreteTicks = (scale, op) => {
    var _a;
    const domain = scale.domain();
    if (!domain.length) return [];
    const {tickCount: tickCount, forceTickCount: forceTickCount, tickStep: tickStep, labelGap: labelGap = 4, axisOrientType: axisOrientType, labelStyle: labelStyle} = op, isHorizontal = (0, 
    util_1.isAxisHorizontal)(axisOrientType), range = scale.range(), rangeSize = scale.calculateWholeRangeSize();
    if (rangeSize < 2) return op.labelLastVisible ? (0, util_1.convertDomainToTickData)([ domain[domain.length - 1] ]) : (0, 
    util_1.convertDomainToTickData)([ domain[0] ]);
    let scaleTicks;
    if ((0, vutils_1.isValid)(tickStep)) scaleTicks = scale.stepTicks(tickStep); else if ((0, 
    vutils_1.isValid)(forceTickCount)) scaleTicks = scale.forceTicks(forceTickCount); else if ((0, 
    vutils_1.isValid)(tickCount)) {
        const count = (0, vutils_1.isFunction)(tickCount) ? tickCount({
            axisLength: rangeSize,
            labelStyle: labelStyle
        }) : tickCount;
        scaleTicks = scale.ticks(count);
    } else if (op.sampling) {
        const fontSize = (null !== (_a = op.labelStyle.fontSize) && void 0 !== _a ? _a : 12) + 2, rangeStart = (0, 
        vutils_1.minInArray)(range), rangeEnd = (0, vutils_1.maxInArray)(range);
        if (domain.length <= rangeSize / fontSize) {
            const labelBoundsList = getOneDimensionalLabelBounds(scale, domain, op, isHorizontal);
            if (labelBoundsList) {
                const minBoundsLength = Math.min(...labelBoundsList.map((bounds => bounds[2]))), incrementUnit = (rangeEnd - rangeStart) / domain.length, stepResult = getStep(domain, labelBoundsList, labelGap, op.labelLastVisible, Math.floor(minBoundsLength / incrementUnit), !1);
                scaleTicks = scale.stepTicks(stepResult.step), op.labelLastVisible && (stepResult.delCount && (scaleTicks = scaleTicks.slice(0, scaleTicks.length - stepResult.delCount)), 
                scaleTicks.push(domain[domain.length - 1]));
            }
        } else {
            const tempDomain = [ domain[0], domain[Math.floor(domain.length / 2)], domain[domain.length - 1] ], tempList = getOneDimensionalLabelBounds(scale, tempDomain, op, isHorizontal);
            if (tempList) {
                let maxBounds = null;
                tempList.forEach((current => {
                    maxBounds ? maxBounds[2] < current[2] && (maxBounds = current) : maxBounds = current;
                }));
                const step = rangeEnd - rangeStart - labelGap > 0 ? Math.ceil(domain.length * (labelGap + maxBounds[2]) / (rangeEnd - rangeStart - labelGap)) : domain.length - 1;
                scaleTicks = scale.stepTicks(step), !op.labelLastVisible || scaleTicks.length && scaleTicks[scaleTicks.length - 1] === domain[domain.length - 1] || (scaleTicks.length && Math.abs(scale.scale(scaleTicks[scaleTicks.length - 1]) - scale.scale(domain[domain.length - 1])) < maxBounds[2] && (scaleTicks = scaleTicks.slice(0, -1)), 
                scaleTicks.push(domain[domain.length - 1]));
            }
        }
    }
    return (0, vutils_1.isNil)(scaleTicks) && (scaleTicks = scale.domain()), (0, util_1.convertDomainToTickData)(scaleTicks);
};

exports.linearDiscreteTicks = linearDiscreteTicks;

const getStep = (domain, labelBoundsList, labelGap, labelLastVisible, defaultStep, areAllBoundsSame) => {
    let resultDelCount = 0, resultStep = 0, resultTickCount = -1, minDiff = Number.MAX_VALUE;
    const validateStep = step => {
        let success = !0, ptr = 0;
        do {
            ptr + step < domain.length && boundsOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap) && (success = !1), 
            ptr += step;
        } while (success && ptr < domain.length);
        return success;
    }, minValidStep = (0, vutils_1.binaryFuzzySearchInNumberRange)(defaultStep, domain.length, (step => validateStep(step) ? 1 : -1));
    let step = minValidStep;
    do {
        if (step > minValidStep && !areAllBoundsSame && !validateStep(step)) step++; else {
            if (!labelLastVisible) {
                resultStep = step;
                break;
            }
            {
                const lastIndex = domain.length - 1;
                let ptr, delCount = 0;
                ptr = domain.length % step > 0 ? domain.length - domain.length % step + step : domain.length;
                do {
                    if (ptr -= step, ptr !== lastIndex && !boundsOverlap(labelBoundsList[ptr], labelBoundsList[lastIndex], labelGap)) break;
                    delCount++;
                } while (ptr > 0);
                if (ptr === lastIndex) {
                    resultStep = step, resultDelCount = delCount;
                    break;
                }
                {
                    const tickCount = Math.floor(domain.length / step) - delCount + 1;
                    if (tickCount < resultTickCount) break;
                    {
                        resultTickCount = tickCount;
                        const distance1 = (0, exports.boundsDistance)(labelBoundsList[ptr], labelBoundsList[lastIndex]), distance2 = ptr - step >= 0 ? (0, 
                        exports.boundsDistance)(labelBoundsList[ptr - step], labelBoundsList[ptr]) : distance1, diff = Math.abs(distance1 - distance2);
                        if (diff < minDiff && (minDiff = diff, resultStep = step, resultDelCount = delCount), 
                        distance1 <= distance2) break;
                    }
                }
            }
            step++;
        }
    } while (step <= domain.length);
    return {
        step: resultStep,
        delCount: resultDelCount
    };
};
//# sourceMappingURL=linear.js.map
