{"version":3,"sources":["../src/axis/mixin/circle.ts"],"names":[],"mappings":";;;AAAA,6CAAoD;AACpD,6CAAoE;AAEpE,kCAAkD;AA+BlD,MAAa,eAAe;IAC1B,cAAc,CAAC,KAAa;QAC1B,MAAM,EAAE,UAAU,GAAG,4BAAiB,EAAE,QAAQ,GAAG,0BAAe,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC;QACtF,IAAI,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;YACzD,OAAO,KAAK,GAAG,CAAC,CAAC;SAClB;QAED,OAAO,KAAK,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,CAAC;IAChC,CAAC;IAED,YAAY,CAAC,SAAiB;QAC5B,MAAM,EACJ,UAAU,GAAG,4BAAiB,EAC9B,QAAQ,GAAG,0BAAe,EAC1B,MAAM,EACN,MAAM,EACN,MAAM,GAAG,KAAK,EACd,WAAW,GAAG,CAAC,EAChB,GAAG,IAAI,CAAC,SAAS,CAAC;QACnB,MAAM,KAAK,GAAG,UAAU,GAAG,CAAC,QAAQ,GAAG,UAAU,CAAC,GAAG,SAAS,CAAC;QAC/D,OAAO,IAAA,yBAAgB,EAAC,MAAM,EAAE,MAAM,IAAI,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IAC3F,CAAC;IAED,iBAAiB,CAAC,MAAc,EAAE,MAAM,GAAG,KAAK,EAAE,KAAY;QAC5D,OAAO,IAAA,8BAAuB,EAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IACtG,CAAC;IAED,iBAAiB,CAAC,KAAa;QAC7B,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC;QAClC,OAAO,CAAC,KAAK,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACzD,CAAC;CACF;AA/BD,0CA+BC","file":"circle.js","sourcesContent":["import { polarToCartesian } from '@visactor/vutils';\nimport { POLAR_START_ANGLE, POLAR_END_ANGLE } from '../../constant';\nimport type { Point } from '../../core/type';\nimport { getCircleVerticalVector } from '../util';\n\nexport interface CircleAxisMixin {\n  attribute: {\n    /**\n     * 当配置了 innerRadius 时，可以通过设置 inside: true，将坐标轴战士在内圆半径上。\n     * @default false\n     */\n    inside?: boolean;\n    /**\n     * 圆心坐标\n     */\n    center: Point;\n    /**\n     * **弧度值**，起始弧度，默认 -0.5 * Math.PI\n     *\n     */\n    startAngle?: number;\n    /**\n     * **弧度值**，结束弧度，默认 1.5 * Math.PI\n     */\n    endAngle?: number;\n    /**\n     * 半径\n     */\n    radius: number;\n    /** 内半径 */\n    innerRadius?: number;\n  };\n}\n\nexport class CircleAxisMixin {\n  isInValidValue(value: number) {\n    const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute;\n    if (Math.abs(endAngle - startAngle) % (Math.PI * 2) === 0) {\n      return value > 1;\n    }\n\n    return value < 0 || value > 1;\n  }\n\n  getTickCoord(tickValue: number): Point {\n    const {\n      startAngle = POLAR_START_ANGLE,\n      endAngle = POLAR_END_ANGLE,\n      center,\n      radius,\n      inside = false,\n      innerRadius = 0\n    } = this.attribute;\n    const angle = startAngle + (endAngle - startAngle) * tickValue;\n    return polarToCartesian(center, inside && innerRadius > 0 ? innerRadius : radius, angle);\n  }\n\n  getVerticalVector(offset: number, inside = false, point: Point): [number, number] {\n    return getCircleVerticalVector(offset, point, this.attribute.center, inside, this.attribute.inside);\n  }\n\n  getRelativeVector(point?: Point): [number, number] {\n    const { center } = this.attribute;\n    return [point.y - center.y, -1 * (point.x - center.x)];\n  }\n}\n"]}