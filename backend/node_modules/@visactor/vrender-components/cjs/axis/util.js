"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.hasOverlap = exports.textIntersect = exports.getPolygonPath = exports.getCirclePoints = exports.getPolarAngleLabelPosition = exports.angleLabelOrientAttribute = exports.getCircleVerticalVector = exports.getVerticalCoord = exports.getElMap = exports.getAxisBreakSymbolAttrs = exports.getCircleLabelPosition = exports.isInRange = exports.clampRadian = void 0;

const vutils_1 = require("@visactor/vutils"), common_1 = require("../util/common"), util_1 = require("../util"), config_1 = require("./config"), util_2 = require("./overlap/util"), clampRadian = (angle = 0) => {
    if (angle < 0) for (;angle < 0; ) angle += vutils_1.tau; else if (angle > 0) for (;angle > vutils_1.tau; ) angle -= vutils_1.tau;
    return angle;
};

function isInRange(a, min, max) {
    return !(0, vutils_1.isLess)(a, min, 0, 1e-6) && !(0, vutils_1.isGreater)(a, max, 0, 1e-6);
}

function getCircleLabelPosition(tickPosition, tickVector) {
    return {
        x: tickPosition.x + tickVector[0],
        y: tickPosition.y + tickVector[1]
    };
}

function getAxisBreakSymbolAttrs(props = {}) {
    var _a, _b;
    const {style: style = {}, angle: angle = .5 * Math.PI} = props, symbolStyle = (0, 
    vutils_1.merge)({}, config_1.DEFAULT_AXIS_BREAK_SYMBOL_STYLE, style), symbolSize = null !== (_a = symbolStyle.size) && void 0 !== _a ? _a : config_1.DEFAULT_AXIS_BREAK_SYMBOL_STYLE.size;
    return Object.assign(Object.assign({}, symbolStyle), {
        symbolType: null !== (_b = symbolStyle.symbolType) && void 0 !== _b ? _b : `M ${-symbolSize / 2} ${symbolSize * Math.sin(angle)} L ${symbolSize / 2} ${-symbolSize * Math.sin(angle)}`,
        symbolSize: symbolSize
    });
}

function getElMap(g) {
    const elMap = {};
    return (0, common_1.traverseGroup)(g, (el => {
        "group" !== el.type && el.id && (elMap[el.id] = el);
    })), elMap;
}

function getVerticalCoord(point, vector) {
    return {
        x: point.x + vector[0],
        y: point.y + vector[1]
    };
}

function getCircleVerticalVector(offset, point, center, inside = !1, axisInside = !1) {
    const vector = [ point.x - center.x, point.y - center.y ];
    return (0, util_1.scale)(vector, (inside ? -1 : 1) * (axisInside ? -1 : 1) * offset / (0, 
    util_1.length)(vector));
}

function angleLabelOrientAttribute(angle) {
    let align = "center", baseline = "middle";
    return align = (angle = (0, vutils_1.normalizeAngle)(angle)) >= Math.PI * (5 / 3) || angle <= Math.PI * (1 / 3) ? "left" : angle >= Math.PI * (2 / 3) && angle <= Math.PI * (4 / 3) ? "right" : "center", 
    baseline = angle >= Math.PI * (7 / 6) && angle <= Math.PI * (11 / 6) ? "bottom" : angle >= Math.PI * (1 / 6) && angle <= Math.PI * (5 / 6) ? "top" : "middle", 
    {
        align: align,
        baseline: baseline
    };
}

function getPolarAngleLabelPosition(angle, center, radius, labelOffset, inside) {
    const point = (0, vutils_1.polarToCartesian)({
        x: 0,
        y: 0
    }, radius, angle), labelPoint = getVerticalCoord(point, getCircleVerticalVector(labelOffset, point, center, inside));
    return getCircleLabelPosition(labelPoint, getCircleVerticalVector(labelOffset || 1, labelPoint, center, inside));
}

function getCirclePoints(center, count, radius, startAngle, endAngle) {
    const points = [], range = endAngle - startAngle;
    for (let i = 0; i < count; i++) {
        const angle = startAngle + i * range / count;
        points.push((0, vutils_1.polarToCartesian)(center, radius, angle));
    }
    return points;
}

function getPolygonPath(points, closed) {
    let path = "";
    return 0 === points.length || (points.forEach(((point, index) => {
        0 === index ? path = `M${point.x},${point.y}` : path += `L${point.x},${point.y}`;
    })), closed && (path += "Z")), path;
}

function textIntersect(textA, textB, sep) {
    var _a;
    const angle = null === (_a = textA.attribute) || void 0 === _a ? void 0 : _a.angle;
    if ((0, util_2.isAngleHorizontal)(angle, Number.EPSILON)) return sep > (0, vutils_1.aabbSeparation)(textA.AABBBounds, textB.AABBBounds);
    const a = textA.OBBBounds, b = textB.OBBBounds;
    return !a || !b || a.empty() || b.empty() ? sep > (0, vutils_1.aabbSeparation)(textA.AABBBounds, textB.AABBBounds) : a.intersects(b) || sep > (0, 
    vutils_1.obbSeparation)(a, b);
}

function hasOverlap(items, pad) {
    for (let b, i = 1, n = items.length, a = items[0]; i < n; a = b, ++i) if (b = items[i], 
    textIntersect(a, b, pad)) return !0;
    return !1;
}

exports.clampRadian = clampRadian, exports.isInRange = isInRange, exports.getCircleLabelPosition = getCircleLabelPosition, 
exports.getAxisBreakSymbolAttrs = getAxisBreakSymbolAttrs, exports.getElMap = getElMap, 
exports.getVerticalCoord = getVerticalCoord, exports.getCircleVerticalVector = getCircleVerticalVector, 
exports.angleLabelOrientAttribute = angleLabelOrientAttribute, exports.getPolarAngleLabelPosition = getPolarAngleLabelPosition, 
exports.getCirclePoints = getCirclePoints, exports.getPolygonPath = getPolygonPath, 
exports.textIntersect = textIntersect, exports.hasOverlap = hasOverlap;
//# sourceMappingURL=util.js.map