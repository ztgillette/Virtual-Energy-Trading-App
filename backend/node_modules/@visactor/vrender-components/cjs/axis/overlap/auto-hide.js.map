{"version":3,"sources":["../src/axis/overlap/auto-hide.ts"],"names":[],"mappings":"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","file":"auto-hide.js","sourcesContent":["/**\n * @description 自动隐藏\n */\n\nimport { createRect, type IText } from '@visactor/vrender-core';\n// eslint-disable-next-line no-duplicate-imports\nimport { isEmpty, isFunction, last } from '@visactor/vutils';\nimport type { CustomMethod } from '../type';\nimport { textIntersect as intersect, hasOverlap } from '../util';\n\nconst methods = {\n  parity: function (items: IText[]) {\n    return items.filter((item, i) => (i % 2 ? item.setAttribute('opacity', 0) : 1));\n  },\n  greedy: function (items: IText[], sep: number) {\n    let a: IText;\n    return items.filter((b, i) => {\n      if (!i || !intersect(a, b, sep)) {\n        a = b;\n        return 1;\n      }\n      return b.setAttribute('opacity', 0);\n    });\n  }\n};\n\nfunction hasBounds(item: IText) {\n  let bounds;\n  if (!item.OBBBounds.empty()) {\n    bounds = item.OBBBounds;\n  } else {\n    bounds = item.AABBBounds;\n  }\n  return bounds.width() > 1 && bounds.height() > 1;\n}\n\n// reset all items to be fully opaque\nfunction reset(items: IText[]) {\n  items.forEach(item => item.setAttribute('opacity', 1));\n  return items;\n}\n\nfunction forceItemVisible(sourceItem: IText, items: IText[], check: boolean, comparator: any, inverse = false) {\n  if (check && !sourceItem.attribute.opacity) {\n    const remainLength = items.length;\n    if (remainLength > 1) {\n      sourceItem.setAttribute('opacity', 1);\n      for (let i = 0; i < remainLength; i++) {\n        const item = inverse ? items[remainLength - 1 - i] : items[i];\n        if (comparator(item)) {\n          item.setAttribute('opacity', 0);\n        } else {\n          break;\n        }\n      }\n    }\n  }\n}\n\ntype HideConfig = {\n  /**\n   * 轴的方向\n   */\n  orient: string;\n  /**\n   * 防重叠策略。\n   * - 'parity': 奇偶校验，使用删除所有其他标签的策略（这对于标准线性轴非常有效）。\n   * - 'greedy': 将执行标签的线性扫描，并删除与最后一个可见标签重叠的所有标签。\n   * - 也可以传入函数用于自定义策略\n   */\n  method?: 'parity' | 'greedy' | CustomMethod;\n  /**\n   * 设置文本之间的间隔距离，单位 px\n   */\n  separation?: number;\n  /**\n   * 保证最后的label展示\n   */\n  lastVisible?: boolean;\n  /**\n   * 保证第一个的label展示\n   */\n  firstVisible?: boolean;\n};\n\nexport function autoHide(labels: IText[], config: HideConfig) {\n  if (isEmpty(labels)) {\n    return;\n  }\n\n  const source = labels.filter(hasBounds);\n  if (isEmpty(source)) {\n    return;\n  }\n\n  let items: IText[];\n\n  items = reset(source);\n\n  const { method = 'parity', separation: sep = 0 } = config;\n\n  const reduce = isFunction(method) ? method : methods[method] || methods.parity;\n\n  if (items.length >= 3 && hasOverlap(items, sep)) {\n    do {\n      items = reduce(items, sep);\n    } while (items.length >= 3 && hasOverlap(items, sep));\n\n    const shouldCheck = (length: number, visibility: boolean, checkLength: boolean = true) => {\n      return checkLength ? length < 3 || visibility : visibility;\n    };\n\n    const checkFirst = shouldCheck(items.length, config.firstVisible, false);\n    /**\n     * 0.17.10 之前，当最后 label 个数小于 3 的时候，才做最后的label强制显示的策略\n     */\n    let checkLast = shouldCheck(items.length, config.lastVisible);\n\n    const firstSourceItem = source[0];\n    const lastSourceItem = last(source);\n\n    if (intersect(firstSourceItem, lastSourceItem, sep) && checkFirst && checkLast) {\n      lastSourceItem.setAttribute('opacity', 0); // Or firstSourceItem, depending on preference\n      checkLast = false;\n    }\n\n    forceItemVisible(firstSourceItem, items, checkFirst, (item: IText) => intersect(item, firstSourceItem, sep));\n\n    forceItemVisible(\n      lastSourceItem,\n      items,\n      checkLast,\n      (item: IText) =>\n        intersect(item, lastSourceItem, sep) ||\n        (checkFirst && item !== firstSourceItem ? intersect(item, firstSourceItem, sep) : false),\n      true\n    );\n  }\n\n  source.forEach(item => {\n    item.setAttribute('visible', !!item.attribute.opacity);\n  });\n}\n"]}