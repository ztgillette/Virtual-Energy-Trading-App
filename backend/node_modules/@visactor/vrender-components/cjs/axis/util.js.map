{"version":3,"sources":["../src/axis/util.ts"],"names":[],"mappings":"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","file":"util.js","sourcesContent":["// eslint-disable-next-line no-duplicate-imports\nimport type { IGraphic, IGroup, IText, TextAlignType, TextBaselineType } from '@visactor/vrender-core';\nimport type { Dict, IBounds, IOBBBounds } from '@visactor/vutils';\n// eslint-disable-next-line no-duplicate-imports\nimport {\n  isGreater,\n  isLess,\n  tau,\n  normalizeAngle,\n  polarToCartesian,\n  merge,\n  obbSeparation,\n  aabbSeparation\n} from '@visactor/vutils';\nimport { traverseGroup } from '../util/common';\nimport type { Vector2 } from '../util';\n// eslint-disable-next-line no-duplicate-imports\nimport { scale, length } from '../util';\nimport type { BreakSymbol } from './type';\nimport { DEFAULT_AXIS_BREAK_SYMBOL_STYLE } from './config';\nimport type { Point } from '../core/type';\nimport { isAngleHorizontal } from './overlap/util';\n\n// 和 vutils 版本不同\nexport const clampRadian = (angle: number = 0) => {\n  if (angle < 0) {\n    while (angle < 0) {\n      angle += tau;\n    }\n  } else if (angle > 0) {\n    while (angle > tau) {\n      angle -= tau;\n    }\n  }\n  return angle;\n};\n\n// 判断数值是否在制定范围内，包含误差\nexport function isInRange(a: number, min: number, max: number) {\n  return !isLess(a, min, 0, 1e-6) && !isGreater(a, max, 0, 1e-6);\n}\n\nexport function getCircleLabelPosition(tickPosition: Point, tickVector: [number, number]) {\n  return {\n    x: tickPosition.x + tickVector[0],\n    y: tickPosition.y + tickVector[1]\n  };\n}\n\nexport function getAxisBreakSymbolAttrs(props: BreakSymbol = {}) {\n  const { style = {}, angle = Math.PI * 0.5 } = props;\n  const symbolStyle = merge({}, DEFAULT_AXIS_BREAK_SYMBOL_STYLE, style);\n  const symbolSize = symbolStyle.size ?? DEFAULT_AXIS_BREAK_SYMBOL_STYLE.size;\n  return {\n    ...symbolStyle,\n    symbolType:\n      symbolStyle.symbolType ??\n      `M ${-symbolSize / 2} ${symbolSize * Math.sin(angle)} L ${symbolSize / 2} ${-symbolSize * Math.sin(angle)}`,\n    symbolSize\n  };\n}\nexport function getElMap(g: IGroup) {\n  const elMap: Dict<IGraphic> = {};\n  traverseGroup(g, (el: IGraphic) => {\n    if ((el as IGraphic).type !== 'group' && el.id) {\n      elMap[el.id] = el;\n    }\n  });\n  return elMap;\n}\n\nexport function getVerticalCoord(point: Point, vector: Vector2): Point {\n  return {\n    x: point.x + vector[0],\n    y: point.y + vector[1]\n  };\n}\n\nexport function getCircleVerticalVector(\n  offset: number,\n  point: Point,\n  center: Point,\n  inside = false,\n  axisInside = false\n): Vector2 {\n  const vector: [number, number] = [point.x - center.x, point.y - center.y];\n  return scale(vector, ((inside ? -1 : 1) * (axisInside ? -1 : 1) * offset) / length(vector));\n}\n\n/**\n * 计算对应角度下的角度轴标签定位属性\n * @param angle 弧度角，需要注意是逆时针计算的\n * @returns\n */\nexport function angleLabelOrientAttribute(angle: number) {\n  let align: TextAlignType = 'center';\n  let baseline: TextBaselineType = 'middle';\n\n  angle = normalizeAngle(angle);\n\n  // left: 5/3 - 1/3; right: 2/3 - 4/3; center: 5/3 - 1/3 & 2/3 - 4/3\n  if (angle >= Math.PI * (5 / 3) || angle <= Math.PI * (1 / 3)) {\n    align = 'left';\n  } else if (angle >= Math.PI * (2 / 3) && angle <= Math.PI * (4 / 3)) {\n    align = 'right';\n  } else {\n    align = 'center';\n  }\n\n  // bottom: 7/6 - 11/6; top: 1/6 - 5/6; middle: 11/6 - 1/6 & 5/6 - 7/6\n  if (angle >= Math.PI * (7 / 6) && angle <= Math.PI * (11 / 6)) {\n    baseline = 'bottom';\n  } else if (angle >= Math.PI * (1 / 6) && angle <= Math.PI * (5 / 6)) {\n    baseline = 'top';\n  } else {\n    baseline = 'middle';\n  }\n\n  return { align, baseline };\n}\n\nexport function getPolarAngleLabelPosition(\n  angle: number,\n  center: { x: number; y: number },\n  radius: number,\n  labelOffset: number,\n  inside: boolean\n) {\n  const point = polarToCartesian({ x: 0, y: 0 }, radius, angle);\n  const labelPoint = getVerticalCoord(point, getCircleVerticalVector(labelOffset, point, center, inside));\n  const vector = getCircleVerticalVector(labelOffset || 1, labelPoint, center, inside);\n  return getCircleLabelPosition(labelPoint, vector);\n}\n\nexport function getCirclePoints(center: Point, count: number, radius: number, startAngle: number, endAngle: number) {\n  const points: Point[] = [];\n  const range = endAngle - startAngle;\n  for (let i = 0; i < count; i++) {\n    const angle = startAngle + (i * range) / count;\n    points.push(polarToCartesian(center, radius, angle));\n  }\n  return points;\n}\n\nexport function getPolygonPath(points: Point[], closed: boolean) {\n  let path = '';\n  if (points.length === 0) {\n    return path;\n  }\n  points.forEach((point, index) => {\n    if (index === 0) {\n      path = `M${point.x},${point.y}`;\n    } else {\n      path += `L${point.x},${point.y}`;\n    }\n  });\n  if (closed) {\n    path += 'Z';\n  }\n\n  return path;\n}\n\nexport function textIntersect(textA: IText, textB: IText, sep: number) {\n  // 注意：默认旋转角度一样\n  const angle = textA.attribute?.angle;\n  const isHorizontal = isAngleHorizontal(angle, Number.EPSILON);\n\n  // 水平文字可以直接用 AABB 包围盒计算\n  if (isHorizontal) {\n    return sep > aabbSeparation(textA.AABBBounds, textB.AABBBounds);\n  }\n\n  const a = textA.OBBBounds;\n  const b = textB.OBBBounds;\n\n  // 没有 OBB bounds 则用 AABB 包围盒计算\n  if (!a || !b || a.empty() || b.empty()) {\n    return sep > aabbSeparation(textA.AABBBounds, textB.AABBBounds);\n  }\n  // 非水平文字且有 OBB 包围盒\n  return a.intersects(b) || sep > obbSeparation(a as IOBBBounds, b as IOBBBounds);\n  //   const expandedTextA = textA.clone();\n  //   const boundsPaddingA = textA.attribute.boundsPadding ?? 0;\n  //   expandedTextA.setAttributes({\n  //     boundsPadding: isNumber(boundsPaddingA) ? boundsPaddingA + sep / 2 : boundsPaddingA.map(v => v + sep / 2)\n  //   });\n  //   const expandTextB = textB.clone();\n  //   const boundsPaddingB = textB.attribute.boundsPadding ?? 0;\n\n  //   expandTextB.setAttributes({\n  //     boundsPadding: isNumber(boundsPaddingB) ? boundsPaddingB + sep / 2 : boundsPaddingB.map(v => v + sep / 2)\n  //   });\n\n  //   return expandedTextA.OBBBounds.intersects(expandTextB.OBBBounds);\n}\n\nexport function hasOverlap<T>(items: IText[], pad: number): boolean {\n  for (let i = 1, n = items.length, a = items[0], b; i < n; a = b, ++i) {\n    b = items[i];\n    if (textIntersect(a, b, pad)) {\n      return true;\n    }\n  }\n  return false;\n}\n"]}