"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.MarkLine = exports.registerMarkLineAnimate = void 0;

const vutils_1 = require("@visactor/vutils"), register_1 = require("./register"), common_line_1 = require("./common-line"), segment_1 = require("../segment"), constant_1 = require("../constant"), config_1 = require("./config"), animate_1 = require("./animate/animate"), util_1 = require("../util");

function registerMarkLineAnimate() {
    MarkLine._animate = animate_1.markCommonLineAnimate;
}

(0, register_1.loadMarkLineComponent)(), exports.registerMarkLineAnimate = registerMarkLineAnimate;

class MarkLine extends common_line_1.MarkCommonLine {
    markerAnimate(state) {
        MarkLine._animate && this._animationConfig && MarkLine._animate(this._line, this._label, this._animationConfig, state);
    }
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : (0, vutils_1.merge)({}, MarkLine.defaultAttributes, attributes)), 
        this.name = "markLine";
    }
    getPointAttrByPosition(position, labelAttrs) {
        var _a;
        const {refX: refX = 0, refY: refY = 0} = labelAttrs, points = this._line.getMainSegmentPoints(), lineEndAngle = null !== (_a = this._line.getEndAngle()) && void 0 !== _a ? _a : 0, labelAngle = ((0, 
        util_1.isPostiveXAxis)(lineEndAngle), lineEndAngle), labelOffsetX = refX * Math.cos(labelAngle) + refY * Math.cos(labelAngle - Math.PI / 2), labelOffsetY = refX * Math.sin(labelAngle) + refY * Math.sin(labelAngle - Math.PI / 2);
        return position.includes("start") || position.includes("Start") ? {
            position: {
                x: points[0].x + labelOffsetX,
                y: points[0].y + labelOffsetY
            },
            angle: labelAngle
        } : position.includes("middle") || position.includes("Middle") ? {
            position: {
                x: (points[0].x + points[points.length - 1].x) / 2 + labelOffsetX,
                y: (points[0].y + points[points.length - 1].y) / 2 + labelOffsetY
            },
            angle: labelAngle
        } : {
            position: {
                x: points[points.length - 1].x + labelOffsetX,
                y: points[points.length - 1].y + labelOffsetY
            },
            angle: labelAngle
        };
    }
    getRotateByAngle(angle, labelAttrs) {
        var _a;
        return ((0, util_1.isPostiveXAxis)(angle) ? angle : angle - Math.PI) + (null !== (_a = labelAttrs.refAngle) && void 0 !== _a ? _a : 0);
    }
    getTextStyle(position, labelAngle, autoRotate) {
        return (0, util_1.fuzzyEqualNumber)(Math.abs(labelAngle), Math.PI / 2, config_1.FUZZY_EQUAL_DELTA) || (0, 
        util_1.fuzzyEqualNumber)(Math.abs(labelAngle), 3 * Math.PI / 2, config_1.FUZZY_EQUAL_DELTA) ? (0, 
        util_1.getTextAlignAttrOfVerticalDir)(autoRotate, labelAngle, position) : (0, util_1.isPostiveXAxis)(labelAngle) ? config_1.DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP.postiveXAxis[position] : config_1.DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP.negativeXAxis[position];
    }
    createSegment() {
        const {points: points, startSymbol: startSymbol, endSymbol: endSymbol, lineStyle: lineStyle, mainSegmentIndex: mainSegmentIndex, multiSegment: multiSegment, state: state} = this.attribute;
        return new segment_1.Segment({
            points: points,
            startSymbol: startSymbol,
            endSymbol: endSymbol,
            lineStyle: lineStyle,
            mainSegmentIndex: mainSegmentIndex,
            multiSegment: multiSegment,
            pickable: !1,
            state: {
                line: (0, vutils_1.merge)({}, constant_1.DEFAULT_STATES, null == state ? void 0 : state.line),
                startSymbol: (0, vutils_1.merge)({}, constant_1.DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
                endSymbol: (0, vutils_1.merge)({}, constant_1.DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
            }
        });
    }
    setLineAttributes() {
        const {points: points, startSymbol: startSymbol, endSymbol: endSymbol, lineStyle: lineStyle, mainSegmentIndex: mainSegmentIndex, multiSegment: multiSegment, state: state} = this.attribute;
        this._line && this._line.setAttributes({
            points: points,
            startSymbol: startSymbol,
            endSymbol: endSymbol,
            lineStyle: lineStyle,
            mainSegmentIndex: mainSegmentIndex,
            multiSegment: multiSegment,
            state: {
                line: (0, vutils_1.merge)({}, constant_1.DEFAULT_STATES, null == state ? void 0 : state.line),
                startSymbol: (0, vutils_1.merge)({}, constant_1.DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
                endSymbol: (0, vutils_1.merge)({}, constant_1.DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
            }
        });
    }
    isValidPoints() {
        const {points: points} = this.attribute;
        if (!points || points.length < 2) return !1;
        let validFlag = !0;
        return points.forEach((point => {
            if (point.length) point.forEach((p => {
                (0, vutils_1.isValidNumber)(p.x) && (0, vutils_1.isValidNumber)(p.y) || (validFlag = !1);
            })); else if (!(0, vutils_1.isValidNumber)(point.x) || !(0, vutils_1.isValidNumber)(point.y)) return void (validFlag = !1);
        })), validFlag;
    }
    addMarkLineLabels(container) {
        this._addMarkLabels(container, "mark-common-line-label", MarkLine.defaultAttributes.label);
    }
    updateMarkLineLabels() {
        this._updateMarkLabels(MarkLine.defaultAttributes.label);
    }
}

exports.MarkLine = MarkLine, MarkLine.defaultAttributes = config_1.DEFAULT_MARK_LINE_THEME;
//# sourceMappingURL=line.js.map
