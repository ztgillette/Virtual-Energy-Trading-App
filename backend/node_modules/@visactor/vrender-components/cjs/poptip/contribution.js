"use strict";

var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.PopTipRenderContribution = void 0;

const vrender_core_1 = require("@visactor/vrender-core"), poptip_1 = require("./poptip"), vutils_1 = require("@visactor/vutils"), theme_1 = require("./theme");

function wrapPoptip(target, source) {
    return (0, vutils_1.merge)(target, theme_1.theme.poptip, source), target;
}

let PopTipRenderContribution = class {
    render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        var _a, _b;
        if (1 === graphic._showPoptip) {
            const {visible: visible, visibleCb: visibleCb} = graphic.attribute.poptip || {};
            if (!1 === visible || visibleCb && !1 === visibleCb(graphic)) return;
            const attribute = {};
            (0, vutils_1.merge)(attribute, poptip_1.PopTip.defaultAttributes, graphic.attribute.poptip ? graphic.attribute.poptip : {}), 
            this.poptipComponent ? this.poptipComponent.initAttributes(attribute) : this.poptipComponent = new poptip_1.PopTip(attribute);
            let poptip = graphic.attribute.poptip || {};
            if ("text" === graphic.type && null == poptip.title && null == poptip.content) {
                const out = {};
                wrapPoptip(out, poptip), poptip = out, poptip.content = null !== (_a = poptip.content) && void 0 !== _a ? _a : graphic.attribute.text;
            }
            const matrix = graphic.globalTransMatrix;
            this.poptipComponent.setAttributes(Object.assign(Object.assign({
                visibleAll: !0,
                pickable: !1,
                childrenPickable: !1,
                poptipAnchor: "bounds"
            }, poptip), {
                x: matrix.e,
                y: matrix.f,
                positionBounds: graphic.globalAABBBounds
            })), drawContext.stage.tryInitInteractiveLayer();
            const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
            interactiveLayer && interactiveLayer.add(this.poptipComponent);
        } else 2 === graphic._showPoptip && (graphic._showPoptip = 0, this.poptipComponent && (this.poptipComponent.setAttributes({
            visibleAll: !1
        }), null === (_b = this.poptipComponent.parent) || void 0 === _b || _b.removeChild(this.poptipComponent), 
        this.poptipComponent = null));
    }
};

PopTipRenderContribution = __decorate([ (0, vrender_core_1.injectable)() ], PopTipRenderContribution), 
exports.PopTipRenderContribution = PopTipRenderContribution;
//# sourceMappingURL=contribution.js.map
