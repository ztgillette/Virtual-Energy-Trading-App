"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerLabelAnimate = exports.LabelEnter = exports.LabelUpdate = void 0;

const vrender_animate_1 = require("@visactor/vrender-animate");

class LabelUpdate extends vrender_animate_1.AComponentAnimate {
    onBind() {
        const animator = (0, vrender_animate_1.createComponentAnimator)(this.target);
        this._animator = animator;
        const duration = this.duration, easing = this.easing, {prevText: prevText, curText: curText, prevLabelLine: prevLabelLine, curLabelLine: curLabelLine, increaseEffect: increaseEffect = !0} = this.params, diff = {};
        for (const key in curText.attribute) prevText.attribute[key] !== curText.attribute[key] && (diff[key] = curText.attribute[key]);
        const {text: text} = diff, rest = __rest(diff, [ "text" ]);
        animator.animate(prevText, {
            type: "to",
            to: rest,
            duration: duration,
            easing: easing
        }), !1 !== increaseEffect && animator.animate(prevText, {
            type: "increaseCount",
            to: {
                text: curText.attribute.text
            },
            duration: duration,
            easing: easing
        }), prevLabelLine && animator.animate(prevLabelLine, {
            type: "to",
            to: curLabelLine.attribute,
            duration: duration,
            easing: easing
        }), this.completeBind(animator);
    }
    tryPreventConflict() {}
}

exports.LabelUpdate = LabelUpdate;

class LabelEnter extends vrender_animate_1.AComponentAnimate {
    onBind() {
        const animator = (0, vrender_animate_1.createComponentAnimator)(this.target);
        this._animator = animator;
        const duration = this.duration, easing = this.easing, {relatedGraphic: relatedGraphic, relatedGraphics: relatedGraphics, config: config} = this.params, {mode: mode, type: type = "fadeIn"} = config, target = this.target;
        let startTime = 0;
        "after" === mode ? relatedGraphic.animates && relatedGraphic.animates.forEach((animate => {
            startTime = Math.max(startTime, animate.getStartTime() + animate.getTotalDuration());
        })) : "after-all" === mode ? relatedGraphics && relatedGraphics.forEach((graphic => {
            graphic.animates && graphic.animates.forEach((animate => {
                startTime = Math.max(startTime, animate.getStartTime() + animate.getTotalDuration());
            }));
        })) : relatedGraphic.animates && relatedGraphic.animates.forEach((animate => {
            startTime = Math.max(startTime, animate.getStartTime());
        })), animator.animate(target, Object.assign(Object.assign({}, config), {
            duration: duration,
            easing: easing,
            startTime: startTime,
            type: type
        })), this.completeBind(animator);
    }
    tryPreventConflict() {}
}

function registerLabelAnimate() {
    vrender_animate_1.AnimateExecutor.registerBuiltInAnimate("increaseCount", vrender_animate_1.IncreaseCount), 
    vrender_animate_1.AnimateExecutor.registerBuiltInAnimate("labelUpdate", LabelUpdate), 
    vrender_animate_1.AnimateExecutor.registerBuiltInAnimate("labelEnter", LabelEnter);
}

exports.LabelEnter = LabelEnter, exports.registerLabelAnimate = registerLabelAnimate;
//# sourceMappingURL=label-animate.js.map