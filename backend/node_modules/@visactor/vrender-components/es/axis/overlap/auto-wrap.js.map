{"version":3,"sources":["../src/axis/overlap/auto-wrap.ts"],"names":[],"mappings":"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","file":"auto-wrap.js","sourcesContent":["import type { IText } from '@visactor/vrender-core';\nimport { isEmpty, isValidNumber, min } from '@visactor/vutils';\nimport { isAngleHorizontal, isAngleVertical } from './util';\n\ntype WrapConfig = {\n  orient: string;\n  limitLength: number;\n  axisLength: number;\n  ellipsis?: string;\n};\n\nexport function autoWrap(labels: IText[], config: WrapConfig) {\n  const { limitLength, axisLength, ellipsis = '...', orient } = config;\n  if (isEmpty(labels) || !isValidNumber(limitLength)) {\n    return;\n  }\n\n  // 注意：自动换行算法暂时只考虑所有标签角度都一致的情况\n  const firstLabel = labels[0];\n  const angle = firstLabel.attribute.angle;\n  const isHorizontal = isAngleHorizontal(angle);\n  const isVertical = isAngleVertical(angle);\n  const isX = orient === 'top' || orient === 'bottom';\n\n  let verticalLimitLength = axisLength / labels.length;\n\n  labels.forEach((label, index) => {\n    if (isX) {\n      if (isVertical && Math.floor(label.AABBBounds.height()) <= limitLength) {\n        return;\n      }\n      if (isHorizontal) {\n        const curLabelX = label.attribute.x;\n        const nextLabelX = labels[index + 1]?.attribute.x;\n        const lastLabelX = labels[index - 1]?.attribute.x;\n        const minGap = getLabelMinGap(curLabelX, nextLabelX, lastLabelX);\n        if (isValidNumber(minGap)) {\n          verticalLimitLength = min(verticalLimitLength, minGap);\n        }\n      }\n    } else {\n      if (isVertical) {\n        const curLabelY = label.attribute.y;\n        const nextLabelY = labels[index + 1]?.attribute.y;\n        const lastLabelY = labels[index - 1]?.attribute.y;\n        const minGap = getLabelMinGap(curLabelY, nextLabelY, lastLabelY);\n        if (isValidNumber(minGap)) {\n          verticalLimitLength = min(verticalLimitLength, minGap);\n        }\n      }\n      if (isHorizontal && Math.floor(label.AABBBounds.width()) <= limitLength) {\n        return;\n      }\n    }\n\n    let limitLabelLength = null;\n    let heightLimit = null;\n\n    if (isX) {\n      if (isVertical) {\n        limitLabelLength = limitLength;\n        heightLimit = verticalLimitLength;\n      } else {\n        limitLabelLength = verticalLimitLength;\n        heightLimit = limitLength;\n      }\n    } else {\n      if (isVertical) {\n        limitLabelLength = verticalLimitLength;\n        heightLimit = limitLength;\n      } else {\n        limitLabelLength = limitLength;\n        heightLimit = verticalLimitLength;\n      }\n    }\n    label.setAttributes({\n      maxLineWidth: limitLabelLength,\n      ellipsis: label.attribute.ellipsis ?? ellipsis,\n      whiteSpace: 'normal',\n      heightLimit\n    });\n  });\n}\n\nfunction getLabelMinGap(current: number, next?: number, prev?: number) {\n  let minGap;\n  if (isValidNumber(next)) {\n    minGap = Math.abs(next - current);\n  }\n\n  if (isValidNumber(prev)) {\n    if (isValidNumber(minGap)) {\n      minGap = Math.min(Math.abs(current - prev), minGap);\n    } else {\n      minGap = Math.abs(current - prev);\n    }\n  }\n\n  return minGap;\n}\n"]}