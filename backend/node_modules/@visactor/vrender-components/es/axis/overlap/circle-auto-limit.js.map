{"version":3,"sources":["../src/axis/overlap/circle-auto-limit.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AAWjD,SAAS,iBAAiB,CAAC,MAAe,EAAE,SAAiB;IAC3D,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC;IAC1B,MAAM,SAAS,GAAG,SAAS,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;IAC3E,MAAM,SAAS,GAAG,SAAS,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAE1E,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,CAAC;AAClC,CAAC;AAED,SAAS,kBAAkB,CAAC,KAAY,EAAE,YAAoB,EAAE,QAAgB;;IAC9E,KAAK,CAAC,aAAa,CAAC;QAClB,YAAY;QACZ,QAAQ,EAAE,MAAA,KAAK,CAAC,SAAS,CAAC,QAAQ,mCAAI,QAAQ;KAC/C,CAAC,CAAC;AACL,CAAC;AAED,SAAS,eAAe,CACtB,MAAe,EACf,SAAiB,EACjB,MAA0D;IAE1D,MAAM,QAAQ,GAAG,EAAE,CAAC;IACpB,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC,EAAE;QACtB,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,iBAAiB,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;QAEtE,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;KACrC;SAAM,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;QAC9B,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;KAChD;IACD,MAAM,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC;IAEhC,IAAI,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,GAAG,MAAM,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;IAE7G,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;QACzB,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IACzF,CAAC,CAAC,CAAC;IAEH,IAAI,WAAW,GAAG,CAAC,EAAE;QACnB,KAAK,CAAC,aAAa,CAAC,EAAE,UAAU,EAAE,QAAQ,EAAE,WAAW,EAAE,CAAC,CAAC;KAC5D;AACH,CAAC;AAOD,MAAM,UAAU,eAAe,CAAC,MAAe,EAAE,MAAkB;IACjE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,MAAM,CAAC;IAE9D,IAAI,CAAC,MAAM,EAAE;QAEX,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE;YAC9B,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,KAAK,CAAC,SAAS,CAAC;YACjC,MAAM,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC;YAE3B,IAAI,aAAa,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE;gBAC9B,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE,EAAE;oBAClC,kBAAkB,CAAC,KAAK,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;oBACvC,OAAO;iBACR;gBAED,MAAM,QAAQ,GAAG,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC;gBAEvC,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC,EAAE;oBAEtB,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,iBAAiB,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;oBAClE,IAAI,KAAK,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC;oBAClC,IAAI,MAAM,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC;oBAEnC,IAAI,KAAK,GAAG,MAAM,EAAE;wBAClB,KAAK,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC;wBAC9B,MAAM,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC;qBAChC;oBAED,MAAM,QAAQ,GACZ,KAAK,KAAK,MAAM;wBACd,CAAC,CAAC,QAAQ;wBACV,CAAC,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,MAAM;4BAC3B,CAAC,CAAC,MAAM,GAAG,KAAK;4BAChB,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBAC1D,IAAI,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,GAAG,QAAQ,EAAE;wBACvC,kBAAkB,CAAC,KAAK,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;qBAC/C;iBACF;qBAAM,IAAI,KAAK,CAAC,UAAU,CAAC,KAAK,EAAE,GAAG,QAAQ,EAAE;oBAC9C,kBAAkB,CAAC,KAAK,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;iBAC/C;aACF;iBAAM,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,EAAE;gBAC3C,kBAAkB,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE,GAAG,CAAC,EAAE,QAAQ,CAAC,CAAC;gBACnD,QAAQ,IAAI,eAAe,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;aACpD;iBAAM,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,EAAE;gBAC3C,kBAAkB,CAAC,KAAK,EAAE,CAAC,GAAG,MAAM,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;gBACnD,QAAQ,IAAI,eAAe,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;aACpD;QACH,CAAC,CAAC,CAAC;KACJ;AACH,CAAC","file":"circle-auto-limit.js","sourcesContent":["import type { IText } from '@visactor/vrender-core';\nimport { isNumberClose } from '@visactor/vutils';\nimport type { Point } from '../../core/type';\n\ntype WrapConfig = {\n  center: Point;\n  inside?: boolean;\n  ellipsis?: string;\n  bounds: { x1: number; x2: number; y1: number; y2: number };\n  autoWrap?: boolean;\n};\n\nfunction findSiblingLabels(labels: IText[], selfIndex: number) {\n  const len = labels.length;\n  const prevLabel = selfIndex >= 1 ? labels[selfIndex - 1] : labels[len - 1];\n  const nextLabel = selfIndex < len - 1 ? labels[selfIndex + 1] : labels[0];\n\n  return { prevLabel, nextLabel };\n}\n\nfunction adjustMaxLineWidth(label: IText, maxLineWidth: number, ellipsis: string) {\n  label.setAttributes({\n    maxLineWidth,\n    ellipsis: label.attribute.ellipsis ?? ellipsis\n  });\n}\n\nfunction adjustMaxHeight(\n  labels: IText[],\n  selfIndex: number,\n  bounds: { x1: number; x2: number; y1: number; y2: number }\n) {\n  const siblings = [];\n  if (labels.length >= 3) {\n    const { prevLabel, nextLabel } = findSiblingLabels(labels, selfIndex);\n\n    siblings.push(prevLabel, nextLabel);\n  } else if (labels.length === 2) {\n    siblings.push(labels[selfIndex === 0 ? 1 : 0]);\n  }\n  const label = labels[selfIndex];\n\n  let heightLimit = Math.min(Math.abs(label.attribute.y - bounds.y1), Math.abs(label.attribute.y - bounds.y2));\n\n  siblings.forEach(sibling => {\n    heightLimit = Math.min(heightLimit, Math.abs(sibling.attribute.y - label.attribute.y));\n  });\n\n  if (heightLimit > 0) {\n    label.setAttributes({ whiteSpace: 'normal', heightLimit });\n  }\n}\n/**\n * 基于所有的标签初始化未知已经布局在圆的边缘\n * @param labels\n * @param labelPoints\n * @param config\n */\nexport function circleAutoLimit(labels: IText[], config: WrapConfig) {\n  const { ellipsis, inside, bounds, autoWrap, center } = config;\n\n  if (!inside) {\n    // TODO inside label暂不处理，现在应该没有类似的需求\n    labels.forEach((label, index) => {\n      const { x, y } = label.attribute;\n      const b = label.AABBBounds;\n\n      if (isNumberClose(x, center.x)) {\n        if (y > bounds.y2 || y < bounds.y1) {\n          adjustMaxLineWidth(label, 0, ellipsis);\n          return;\n        }\n\n        const boxWidth = bounds.x2 - bounds.x1;\n        // 12点和6点钟方向对应的label\n        if (labels.length >= 3) {\n          // 这里其实有一个前提：所有的label都是按照顺时针或者逆时针排序好的\n          const { prevLabel, nextLabel } = findSiblingLabels(labels, index);\n          let leftX = prevLabel.attribute.x;\n          let rightX = nextLabel.attribute.x;\n\n          if (leftX > rightX) {\n            leftX = nextLabel.attribute.x;\n            rightX = prevLabel.attribute.x;\n          }\n\n          const maxWidth =\n            leftX === rightX\n              ? boxWidth\n              : x >= leftX && x <= rightX\n              ? rightX - leftX\n              : Math.min(Math.abs(leftX - x), Math.abs(rightX - x));\n          if (label.AABBBounds.width() > maxWidth) {\n            adjustMaxLineWidth(label, maxWidth, ellipsis);\n          }\n        } else if (label.AABBBounds.width() > boxWidth) {\n          adjustMaxLineWidth(label, boxWidth, ellipsis);\n        }\n      } else if (x > center.x && b.x2 > bounds.x2) {\n        adjustMaxLineWidth(label, bounds.x2 - x, ellipsis);\n        autoWrap && adjustMaxHeight(labels, index, bounds);\n      } else if (x < center.x && b.x1 < bounds.x1) {\n        adjustMaxLineWidth(label, x - bounds.x1, ellipsis);\n        autoWrap && adjustMaxHeight(labels, index, bounds);\n      }\n    });\n  }\n}\n"]}