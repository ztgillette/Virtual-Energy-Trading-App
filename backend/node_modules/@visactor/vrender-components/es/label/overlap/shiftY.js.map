{"version":3,"sources":["../src/label/overlap/shiftY.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AAuCjD,MAAM,WAAW,GAAG,CAAC,GAAW,EAAE,MAAc,EAAE,EAAE;IAClD,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;AAC7C,CAAC,CAAC;AAEF,MAAM,YAAY,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAmB,EAAE,CAAC,CAAC,EAAE,CAAC,CAAmB,EAAE,EAAE;IAC1E,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACxB,CAAC,CAAC;AAEF,SAAS,qBAAqB,CAAC,MAAgB,EAAE,MAAgB;IAC/D,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC;IAC9B,MAAM,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC;IAE9B,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACvC,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IAEjC,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,GAAG,KAAK,CAAC,CAAC;AAClC,CAAC;AAED,MAAM,UAAU,MAAM,CAAC,KAAc,EAAE,MAAqB;IAC1D,MAAM,EACJ,IAAI,GAAG,MAAM,CAAC,SAAS,EACvB,SAAS,EACT,YAAY,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,aAAa,EAAE,EAAE,EAAE,QAAQ,EAAE,GAAG,EAAE,OAAO,EAAE,CAAC,EAAE,EAC9E,GAAG,MAAM,CAAC;IAEX,MAAM,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC;IACvB,IAAI,CAAC,IAAI,CAAC,EAAE;QACV,OAAO,KAAK,CAAC;KACd;IAGD,MAAM,IAAI,GAAG,IAAI,GAAG,EAA2C,CAAC;IAChE,MAAM,eAAe,GAAG,IAAI,GAAG,EAa5B,CAAC;IAEJ,MAAM,YAAY,GAAG,CAAC,IAAW,EAAE,EAAE,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC;IAC1E,MAAM,SAAS,GAAG,CAAC,IAAW,EAAE,EAAE,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC;IACpE,MAAM,KAAK,GAAG,CAAC,IAAW,EAAE,EAAE,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;IAC5D,MAAM,IAAI,GAAG,CAAC,IAAW,EAAE,EAAE,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAC1D,MAAM,IAAI,GAAG,CAAC,IAAW,EAAE,EAAE,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAC1D,MAAM,KAAK,GAAG,CAAC,IAAW,EAAE,EAAE,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;IAC5D,MAAM,KAAK,GAAG,CAAC,IAAW,EAAE,EAAE,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;IAC5D,MAAM,iBAAiB,GAAG,CAAC,IAAW,EAAE,EAAE,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC;IAE9E,MAAM,KAAK,GAAG,CAAC,IAAW,EAAE,CAAS,EAAE,EAAE;QACvC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;IACnC,CAAC,CAAC;IAEF,MAAM,iBAAiB,GAAG,CAAC,IAAW,EAAE,QAAgB,EAAE,EAAE;QAC1D,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAChD,CAAC,CAAC;IAEF,SAAS,wBAAwB,CAAC,KAAc;QAE9C,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YAC1C,MAAM,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACzB,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAC/B,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAE/B,IACE,CAAC,SAAS,IAAI,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,SAAS,CAAC,SAAS,CAAC,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;gBAEnF,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,OAAO,CAAC,UAAU,CAAC,EAC5C;gBACA,MAAM,EAAE,CAAC,EAAE,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC;gBAEjC,IAAI,CAAC,SAAS,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE;oBAC5E,IAAI,CAAC,GAAG,SAAS,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,IAAI,EAAE;wBACtC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;qBACpD;iBACF;aACF;SACF;IACH,CAAC;IAGD,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IACpD,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;QACxB,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC;QAC3C,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC;QAChC,eAAe,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,MAAM,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;QACjG,IAAI,QAAQ,GAAG,KAAK,CAAC;QAErB,KAAK,MAAM,CAAC,KAAK,EAAE,WAAW,CAAC,IAAI,IAAI,EAAE;YACvC,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,KAAK,CAAC;YAE7B,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,IAAI,GAAG,EAAE;gBAC5B,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACvB,QAAQ,GAAG,IAAI,CAAC;aACjB;iBAEI,IAAI,aAAa,CAAC,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,EAAE,SAAS,EAAE,CAAC,CAAC,EAAE;gBAE7D,MAAM,QAAQ,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,CAAC;gBACxE,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACvB,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;gBAChC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACnB,QAAQ,GAAG,IAAI,CAAC;aACjB;iBAEI,IAAI,qBAAqB,CAAC,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,GAAG,EAAE;gBAC5E,MAAM,QAAQ,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,CAAC;gBACxE,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACvB,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;gBAChC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACnB,QAAQ,GAAG,IAAI,CAAC;aACjB;YAED,IAAI,QAAQ,EAAE;gBACZ,MAAM;aACP;SACF;QAED,IAAI,CAAC,QAAQ,EAAE;YACb,IAAI,CAAC,GAAG,CAAC,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;SAC1C;KACF;IAGD,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,MAAM,EAAE,EAAE;QAElC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,YAAY,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;QACzD,wBAAwB,CAAC,MAAM,CAAC,CAAC;KAClC;IAGD,IAAI,YAAY,CAAC,MAAM,KAAK,KAAK,EAAE;QACjC,MAAM,EACJ,aAAa,GAAG,EAAE,EAClB,QAAQ,GAAG,GAAG,EACd,OAAO,GAAG,CAAC,EACX,WAAW,GAAG,IAAI,EAClB,eAAe,GAAG,MAAM,CAAC,SAAS,EACnC,GAAG,YAAY,CAAC;QACjB,KAAK,IAAI,IAAI,GAAG,CAAC,EAAE,IAAI,GAAG,aAAa,EAAE,IAAI,EAAE,EAAE;YAC/C,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,YAAY,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;YACxD,IAAI,KAAK,GAAG,CAAC,CAAC;YACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;gBAC9B,MAAM,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;gBACzB,IAAI,iBAAiB,CAAC,OAAO,CAAC,IAAI,WAAW,EAAE;oBAC7C,SAAS;iBACV;gBACD,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACd,IAAI,QAAQ,CAAC;gBACb,OACE,CAAC,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;oBACrB,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,EACnF;oBACA,CAAC,IAAI,CAAC,CAAC;iBACR;gBACD,IAAI,QAAQ,EAAE;oBACZ,MAAM,EAAE,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC;oBAC1B,MAAM,EAAE,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC;oBAC9B,MAAM,MAAM,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;oBAC/B,MAAM,KAAK,GAAG,MAAM,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;oBACjC,IAAI,KAAK,GAAG,OAAO,EAAE;wBACnB,MAAM,QAAQ,GAAG,CAAC,OAAO,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;wBACvC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;wBAClC,IAAI,EAAE,GAAG,QAAQ,GAAG,SAAS,CAAC,QAAQ,CAAC,GAAG,IAAI,EAAE;4BAC9C,MAAM,KAAK,GAAG,EAAE,GAAG,CAAC,OAAO,GAAG,KAAK,CAAC,CAAC;4BACrC,MAAM,YAAY,GAAG,YAAY,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC;4BACnD,IAAI,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,eAAe,EAAE;gCAC7C,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;gCACtB,iBAAiB,CAAC,OAAO,EAAE,iBAAiB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;6BAC5D;yBACF;6BAAM,IAAI,EAAE,GAAG,QAAQ,GAAG,CAAC,EAAE;4BAC5B,MAAM,KAAK,GAAG,MAAM,GAAG,CAAC,OAAO,GAAG,KAAK,CAAC,CAAC;4BACzC,MAAM,aAAa,GAAG,YAAY,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC;4BACrD,IAAI,IAAI,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,eAAe,EAAE;gCAC9C,KAAK,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;gCACvB,iBAAiB,CAAC,QAAQ,EAAE,iBAAiB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;6BAC9D;yBACF;6BAAM;4BACL,MAAM,QAAQ,GAAG,EAAE,GAAG,QAAQ,CAAC;4BAC/B,MAAM,YAAY,GAAG,YAAY,CAAC,OAAO,CAAC,GAAG,QAAQ,CAAC;4BACtD,MAAM,SAAS,GAAG,MAAM,GAAG,QAAQ,CAAC;4BACpC,MAAM,aAAa,GAAG,YAAY,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC;4BACzD,IAAI,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,eAAe,IAAI,IAAI,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,eAAe,EAAE;gCAC3F,KAAK,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;gCACzB,KAAK,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;gCAC3B,iBAAiB,CAAC,OAAO,EAAE,iBAAiB,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;gCAC3D,iBAAiB,CAAC,QAAQ,EAAE,iBAAiB,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC;6BAC9D;yBACF;qBACF;iBACF;aACF;YACD,IAAI,KAAK,GAAG,QAAQ,EAAE;gBACpB,MAAM;aACP;SACF;KACF;IAED,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;QACxB,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;QACnE,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;KAChC;IAED,MAAM,MAAM,GAAG,EAAE,CAAC;IAGlB,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IACpD,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,IAAI,GAAG,GAAG,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;IAE3B,OAAO,KAAK,IAAI,GAAG,EAAE;QACnB,IAAI,KAAK,KAAK,GAAG,EAAE;YACjB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;SAC3B;aAAM;YACL,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;YAC1B,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;SACzB;QACD,KAAK,EAAE,CAAC;QACR,GAAG,EAAE,CAAC;KACP;IACD,OAAO,MAAM,CAAC;AAChB,CAAC","file":"shiftY.js","sourcesContent":["import type { IText } from '@visactor/vrender-core';\nimport { isNumberClose } from '@visactor/vutils';\n\nexport interface IShiftYOption {\n  labelling: (...args: any[]) => any;\n\n  maxY?: number;\n  globalShiftY?: {\n    /**\n     * 是否开启全局调整，开启后，所有文字会整体调整，否则只会按照 x 分组调整 top/bottom\n     * @default true\n     */\n    enable?: boolean;\n    /**\n     * 最大迭代次数\n     * @default 10\n     */\n    maxIterations?: number;\n    /**\n     * 最大误差\n     * @default 0.1\n     */\n    maxError?: number;\n    /**\n     * 调整后 text 之间的 padding\n     * @default 1\n     */\n    padding?: number;\n    /**\n     * 每个 text 最大被调整的次数\n     * @default 1000\n     */\n    maxAttempts?: number;\n    /**\n     * 每个 text 调整的 y 坐标差值限制\n     */\n    deltaYTolerance?: number;\n  };\n}\n\nconst isIntersect = (top: number, bottom: number) => {\n  return Math.ceil(top) > Math.floor(bottom);\n};\n\nconst isXIntersect = ([a, b]: [number, number], [c, d]: [number, number]) => {\n  return d > a && b > c;\n};\n\nfunction getIntersectionLength(range1: number[], range2: number[]) {\n  const [start1, end1] = range1;\n  const [start2, end2] = range2;\n\n  const start = Math.max(start1, start2);\n  const end = Math.min(end1, end2);\n\n  return Math.max(0, end - start);\n}\n\nexport function shiftY(texts: IText[], option: IShiftYOption) {\n  const {\n    maxY = Number.MAX_VALUE,\n    labelling,\n    globalShiftY = { enable: true, maxIterations: 10, maxError: 0.1, padding: 1 }\n  } = option;\n\n  const n = texts.length;\n  if (n <= 1) {\n    return texts;\n  }\n\n  // 根据 x 坐标给 text 分组，存放信息到 map 中\n  const xMap = new Map<{ start: number; end: number }, IText[]>();\n  const textInformation = new Map<\n    IText,\n    {\n      y1Initial: number;\n      y1: number;\n      y: number;\n      y2: number;\n      height: number;\n      x1: number;\n      x2: number;\n      x: number;\n      attempts: number;\n    }\n  >();\n\n  const getY1Initial = (text: IText) => textInformation.get(text).y1Initial;\n  const getHeight = (text: IText) => textInformation.get(text).height;\n  const getY1 = (text: IText) => textInformation.get(text).y1;\n  const getY = (text: IText) => textInformation.get(text).y;\n  const getX = (text: IText) => textInformation.get(text).x;\n  const getX1 = (text: IText) => textInformation.get(text).x1;\n  const getX2 = (text: IText) => textInformation.get(text).x2;\n  const getAdjustAttempts = (text: IText) => textInformation.get(text).attempts;\n\n  const setY1 = (text: IText, y: number) => {\n    textInformation.get(text).y1 = y;\n  };\n\n  const setAdjustAttempts = (text: IText, attempts: number) => {\n    textInformation.get(text).attempts = attempts;\n  };\n\n  function adjustPositionInOneGroup(texts: IText[]) {\n    // 从最后一个 text 向前遍历，如果与前一个 text 相交，则尝试放到下方（需要判断和前一个 text 是否相交，若相交则不能放到下方）\n    for (let i = texts.length - 1; i >= 0; i--) {\n      const curText = texts[i];\n      const upperText = texts[i - 1];\n      const lowerText = texts[i + 1];\n      // 当前 text 和上面一个 text 相交\n      if (\n        (upperText && isIntersect(getY1(upperText) + getHeight(upperText), getY1(curText))) ||\n        // 如果是最顶上被 clamp 进来的 text，也尝试向下摆放\n        (getY1(curText) === 0 && curText._isClamped)\n      ) {\n        const { y } = labelling(curText);\n        // 挪动当前 text 后， 和下面一个 text 不相交\n        if (!lowerText || !isIntersect(y + getHeight(curText) / 2, getY1(lowerText))) {\n          if (y + getHeight(curText) / 2 <= maxY) {\n            setY1(curText, getY1(curText) + y - getY(curText));\n          }\n        }\n      }\n    }\n  }\n\n  // 根据 x 坐标进行分组\n  texts.sort((a, b) => a.attribute.x - b.attribute.x);\n  for (const text of texts) {\n    const { y1, y2, x1, x2 } = text.AABBBounds;\n    const { x, y } = text.attribute;\n    textInformation.set(text, { y1Initial: y1, y1, y2, y, height: y2 - y1, x1, x2, x, attempts: 0 });\n    let hasRange = false;\n\n    for (const [range, xGroupTexts] of xMap) {\n      const { start, end } = range;\n      // 1. x1,x2 在 start 和 end 范围内\n      if (x1 >= start && x2 <= end) {\n        xGroupTexts.push(text);\n        hasRange = true;\n      }\n      // 2. x 坐标接近，相差在 5px 以内\n      else if (isNumberClose(x, getX(xGroupTexts[0]), undefined, 5)) {\n        // x 坐标相等，也纳入到一个分组中，并且要扩大分组 range\n        const newRange = { start: Math.min(start, x1), end: Math.max(end, x2) };\n        xGroupTexts.push(text);\n        xMap.set(newRange, xGroupTexts);\n        xMap.delete(range);\n        hasRange = true;\n      }\n      // 3. 与区间相交范围 > 50%\n      else if (getIntersectionLength([start, end], [x1, x2]) / (end - start) > 0.5) {\n        const newRange = { start: Math.min(start, x1), end: Math.max(end, x2) };\n        xGroupTexts.push(text);\n        xMap.set(newRange, xGroupTexts);\n        xMap.delete(range);\n        hasRange = true;\n      }\n\n      if (hasRange) {\n        break;\n      }\n    }\n\n    if (!hasRange) {\n      xMap.set({ start: x1, end: x2 }, [text]);\n    }\n  }\n\n  // 对每个 x 坐标的 text 数组进行排序\n  for (const xTexts of xMap.values()) {\n    // 从上到下排序\n    xTexts.sort((a, b) => getY1Initial(a) - getY1Initial(b));\n    adjustPositionInOneGroup(xTexts);\n  }\n\n  // 整体调整一次 Y 坐标，进行散开\n  if (globalShiftY.enable !== false) {\n    const {\n      maxIterations = 10,\n      maxError = 0.1,\n      padding = 1,\n      maxAttempts = 1000,\n      deltaYTolerance = Number.MAX_VALUE\n    } = globalShiftY;\n    for (let iter = 0; iter < maxIterations; iter++) {\n      texts.sort((a, b) => getY1Initial(a) - getY1Initial(b));\n      let error = 0;\n      for (let i = 0; i < n - 1; i++) {\n        const curText = texts[i];\n        if (getAdjustAttempts(curText) >= maxAttempts) {\n          continue;\n        }\n        let j = i + 1;\n        let nextText;\n        while (\n          (nextText = texts[j]) &&\n          !isXIntersect([getX1(curText), getX2(curText)], [getX1(nextText), getX2(nextText)])\n        ) {\n          j += 1;\n        }\n        if (nextText) {\n          const y1 = getY1(curText);\n          const h0 = getHeight(curText);\n          const nextY1 = getY1(nextText);\n          const delta = nextY1 - (y1 + h0);\n          if (delta < padding) {\n            const newDelta = (padding - delta) / 2;\n            error = Math.max(error, newDelta);\n            if (y1 + newDelta + getHeight(nextText) > maxY) {\n              const newY1 = y1 - (padding - delta);\n              const curTextDelta = getY1Initial(curText) - newY1;\n              if (Math.abs(curTextDelta) <= deltaYTolerance) {\n                setY1(curText, newY1);\n                setAdjustAttempts(curText, getAdjustAttempts(curText) + 1);\n              }\n            } else if (y1 - newDelta < 0) {\n              const newY1 = nextY1 + (padding - delta);\n              const nextTextDelta = getY1Initial(nextText) - newY1;\n              if (Math.abs(nextTextDelta) <= deltaYTolerance) {\n                setY1(nextText, newY1);\n                setAdjustAttempts(nextText, getAdjustAttempts(nextText) + 1);\n              }\n            } else {\n              const newCurY1 = y1 - newDelta;\n              const curTextDelta = getY1Initial(curText) - newCurY1;\n              const newNextY1 = nextY1 + newDelta;\n              const nextTextDelta = getY1Initial(nextText) - newNextY1;\n              if (Math.abs(curTextDelta) <= deltaYTolerance && Math.abs(nextTextDelta) <= deltaYTolerance) {\n                setY1(curText, newCurY1);\n                setY1(nextText, newNextY1);\n                setAdjustAttempts(curText, getAdjustAttempts(curText) + 1);\n                setAdjustAttempts(nextText, getAdjustAttempts(nextText) + 1);\n              }\n            }\n          }\n        }\n      }\n      if (error < maxError) {\n        break;\n      }\n    }\n  }\n\n  for (const text of texts) {\n    const finalY = text.attribute.y + getY1(text) - getY1Initial(text);\n    text.setAttribute('y', finalY);\n  }\n\n  const result = [];\n  // 调整文字顺序，越靠前的越优先占据空间\n  // texts 按照 x 进行排序，然后左右交替，保证首尾标签优先展示\n  texts.sort((a, b) => a.attribute.x - b.attribute.x);\n  let start = 0;\n  let end = texts.length - 1;\n\n  while (start <= end) {\n    if (start === end) {\n      result.push(texts[start]);\n    } else {\n      result.push(texts[start]);\n      result.push(texts[end]);\n    }\n    start++;\n    end--;\n  }\n  return result;\n}\n"]}