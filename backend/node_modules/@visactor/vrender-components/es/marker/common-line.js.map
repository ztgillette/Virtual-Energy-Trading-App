{"version":3,"sources":["../src/marker/common-line.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,KAAK,EAAE,MAAM,kBAAkB,CAAC;AAUzC,OAAO,EAAE,kBAAkB,EAAE,MAAM,qBAAqB,CAAC;AACzD,OAAO,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAChC,OAAO,EAAE,0BAA0B,EAAE,8BAA8B,EAAE,MAAM,mBAAmB,CAAC;AAC/F,OAAO,EAAE,cAAc,EAAE,MAAM,eAAe,CAAC;AAS/C,MAAM,OAAgB,cAAwC,SAAQ,MAGrE;IAHD;;QAIE,SAAI,GAAG,gBAAgB,CAAC;QASxB,2BAAsB,GAAG,8BAA8B,CAAC;QACxD,yBAAoB,GAAG,0BAA0B,CAAC;IAyDpD,CAAC;IA7CC,OAAO;QACL,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAES,WAAW,CAAC,SAAiB,EAAE,UAA+C;QACtF,MAAM,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC;QACrC,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,UAAU,EAAE,GAAG,UAAU,CAAC;QACrD,MAAM,UAAU,GAAG,IAAI,CAAC,sBAAsB,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;QACrE,MAAM,UAAU,GAAG,QAAQ,CAAC,QAAQ,EAAE,CAAC,iBAAiB,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC;YAC1E,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,EAAE,IAAI,CAAC;YACjC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;QAClC,SAAS,CAAC,aAAa,iCAClB,UAAU,CAAC,QAAQ,KACtB,KAAK,EAAE,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,EAC3E,SAAS,kCACJ,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,UAAU,EAAE,UAAU,CAAC,GACnD,UAAU,CAAC,SAAS,KAEzB,CAAC;QACH,IAAI,SAAS,IAAI,OAAO,EAAE;YACxB,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,SAAS,CAAC;YAC1C,kBAAkB,CAAC,SAAS,EAAE;gBAC5B,EAAE,EAAE,CAAC;gBACL,EAAE,EAAE,CAAC;gBACL,EAAE,EAAE,CAAC,GAAG,KAAK;gBACb,EAAE,EAAE,CAAC,GAAG,MAAM;aACf,CAAC,CAAC;SACJ;IACH,CAAC;IAES,UAAU,CAAC,SAAiB;QACpC,MAAM,IAAI,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;QAClC,IAAI,CAAC,IAAI,GAAG,uBAAuB,CAAC;QACpC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,SAAS,CAAC,GAAG,CAAC,IAAwB,CAAC,CAAC;QACxC,IAAI,CAAC,iBAAiB,CAAC,SAAS,CAAC,CAAC;IACpC,CAAC;IAES,YAAY;QACpB,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAGzB,IAAI,CAAC,oBAAoB,EAAE,CAAC;IAE9B,CAAC;CACF;AAED,KAAK,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC","file":"common-line.js","sourcesContent":["import type { IGroup, INode } from '@visactor/vrender-core';\nimport { mixin } from '@visactor/vutils';\nimport type { ArcSegment, Segment } from '../segment';\n// eslint-disable-next-line no-duplicate-imports\nimport type { Tag } from '../tag';\nimport type {\n  MarkCommonLineAnimationType,\n  MarkCommonLineAttrs,\n  MarkerAnimationState,\n  MarkerLineLabelAttrs\n} from './type';\nimport { limitShapeInBounds } from '../util/limit-shape';\nimport { Marker } from './base';\nimport { DefaultExitMarkerAnimation, DefaultUpdateMarkLineAnimation } from './animate/animate';\nimport { MarkLabelMixin } from './mixin/label';\n\nexport interface MarkCommonLine<LineAttr, LabelPosition>\n  extends Pick<\n      MarkLabelMixin<MarkCommonLineAttrs<LineAttr, LabelPosition, MarkCommonLineAnimationType>>,\n      '_addMarkLabels' | '_updateMarkLabels' | 'getLabel' | '_label'\n    >,\n    Marker<MarkCommonLineAttrs<LineAttr, LabelPosition, MarkCommonLineAnimationType>, MarkCommonLineAnimationType> {}\n\nexport abstract class MarkCommonLine<LineAttr, LabelPosition> extends Marker<\n  MarkCommonLineAttrs<LineAttr, LabelPosition, MarkCommonLineAnimationType>,\n  MarkCommonLineAnimationType\n> {\n  name = 'markCommonLine';\n\n  /** animate */\n  static _animate?: (\n    line: Segment | ArcSegment,\n    label: Tag | Tag[],\n    animationConfig: any,\n    state: MarkerAnimationState\n  ) => void;\n  defaultUpdateAnimation = DefaultUpdateMarkLineAnimation;\n  defaultExitAnimation = DefaultExitMarkerAnimation;\n\n  protected _line!: Segment | ArcSegment;\n  protected abstract createSegment(): any;\n  protected abstract setLineAttributes(): any;\n  protected abstract getPointAttrByPosition(position: any, labelAttrs: MarkerLineLabelAttrs<LabelPosition>): any;\n  protected abstract getRotateByAngle(angle: number, labelAttrs: MarkerLineLabelAttrs<LabelPosition>): number;\n  protected abstract getTextStyle(position: any, labelAngle: number, autoRotate: boolean): any;\n  protected abstract markerAnimate(state: MarkerAnimationState): void;\n  protected abstract addMarkLineLabels(container: IGroup): any;\n  protected abstract updateMarkLineLabels(): any;\n\n  getLine() {\n    return this._line;\n  }\n\n  protected setLabelPos(labelNode: IGroup, labelAttrs: MarkerLineLabelAttrs<LabelPosition>): void {\n    const { limitRect } = this.attribute;\n    const { position, confine, autoRotate } = labelAttrs;\n    const labelPoint = this.getPointAttrByPosition(position, labelAttrs);\n    const labelAngle = position.toString().toLocaleLowerCase().includes('start')\n      ? this._line.getStartAngle() || 0\n      : this._line.getEndAngle() || 0;\n    labelNode.setAttributes({\n      ...labelPoint.position,\n      angle: autoRotate ? this.getRotateByAngle(labelPoint.angle, labelAttrs) : 0,\n      textStyle: {\n        ...this.getTextStyle(position, labelAngle, autoRotate),\n        ...labelAttrs.textStyle\n      }\n    });\n    if (limitRect && confine) {\n      const { x, y, width, height } = limitRect;\n      limitShapeInBounds(labelNode, {\n        x1: x,\n        y1: y,\n        x2: x + width,\n        y2: y + height\n      });\n    }\n  }\n\n  protected initMarker(container: IGroup) {\n    const line = this.createSegment();\n    line.name = 'mark-common-line-line';\n    this._line = line;\n    container.add(line as unknown as INode);\n    this.addMarkLineLabels(container);\n  }\n\n  protected updateMarker() {\n    this.setLineAttributes();\n\n    // update label\n    this.updateMarkLineLabels();\n    // this._updateMarkLabels();\n  }\n}\n\nmixin(MarkCommonLine, MarkLabelMixin);\n"]}