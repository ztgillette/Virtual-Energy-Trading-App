import { isValidNumber, merge } from "@visactor/vutils";

import { loadMarkLineComponent } from "./register";

import { MarkCommonLine } from "./common-line";

import { Segment } from "../segment";

import { DEFAULT_STATES } from "../constant";

import { DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP, DEFAULT_MARK_LINE_THEME, FUZZY_EQUAL_DELTA } from "./config";

import { markCommonLineAnimate } from "./animate/animate";

import { fuzzyEqualNumber, getTextAlignAttrOfVerticalDir, isPostiveXAxis } from "../util";

loadMarkLineComponent();

export function registerMarkLineAnimate() {
    MarkLine._animate = markCommonLineAnimate;
}

export class MarkLine extends MarkCommonLine {
    markerAnimate(state) {
        MarkLine._animate && this._animationConfig && MarkLine._animate(this._line, this._label, this._animationConfig, state);
    }
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, MarkLine.defaultAttributes, attributes)), 
        this.name = "markLine";
    }
    getPointAttrByPosition(position, labelAttrs) {
        var _a;
        const {refX: refX = 0, refY: refY = 0} = labelAttrs, points = this._line.getMainSegmentPoints(), lineEndAngle = null !== (_a = this._line.getEndAngle()) && void 0 !== _a ? _a : 0, labelAngle = (isPostiveXAxis(lineEndAngle), 
        lineEndAngle), labelOffsetX = refX * Math.cos(labelAngle) + refY * Math.cos(labelAngle - Math.PI / 2), labelOffsetY = refX * Math.sin(labelAngle) + refY * Math.sin(labelAngle - Math.PI / 2);
        return position.includes("start") || position.includes("Start") ? {
            position: {
                x: points[0].x + labelOffsetX,
                y: points[0].y + labelOffsetY
            },
            angle: labelAngle
        } : position.includes("middle") || position.includes("Middle") ? {
            position: {
                x: (points[0].x + points[points.length - 1].x) / 2 + labelOffsetX,
                y: (points[0].y + points[points.length - 1].y) / 2 + labelOffsetY
            },
            angle: labelAngle
        } : {
            position: {
                x: points[points.length - 1].x + labelOffsetX,
                y: points[points.length - 1].y + labelOffsetY
            },
            angle: labelAngle
        };
    }
    getRotateByAngle(angle, labelAttrs) {
        var _a;
        return (isPostiveXAxis(angle) ? angle : angle - Math.PI) + (null !== (_a = labelAttrs.refAngle) && void 0 !== _a ? _a : 0);
    }
    getTextStyle(position, labelAngle, autoRotate) {
        return fuzzyEqualNumber(Math.abs(labelAngle), Math.PI / 2, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(Math.abs(labelAngle), 3 * Math.PI / 2, FUZZY_EQUAL_DELTA) ? getTextAlignAttrOfVerticalDir(autoRotate, labelAngle, position) : isPostiveXAxis(labelAngle) ? DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP.postiveXAxis[position] : DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP.negativeXAxis[position];
    }
    createSegment() {
        const {points: points, startSymbol: startSymbol, endSymbol: endSymbol, lineStyle: lineStyle, mainSegmentIndex: mainSegmentIndex, multiSegment: multiSegment, state: state} = this.attribute;
        return new Segment({
            points: points,
            startSymbol: startSymbol,
            endSymbol: endSymbol,
            lineStyle: lineStyle,
            mainSegmentIndex: mainSegmentIndex,
            multiSegment: multiSegment,
            pickable: !1,
            state: {
                line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
                startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
                endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
            }
        });
    }
    setLineAttributes() {
        const {points: points, startSymbol: startSymbol, endSymbol: endSymbol, lineStyle: lineStyle, mainSegmentIndex: mainSegmentIndex, multiSegment: multiSegment, state: state} = this.attribute;
        this._line && this._line.setAttributes({
            points: points,
            startSymbol: startSymbol,
            endSymbol: endSymbol,
            lineStyle: lineStyle,
            mainSegmentIndex: mainSegmentIndex,
            multiSegment: multiSegment,
            state: {
                line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
                startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
                endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
            }
        });
    }
    isValidPoints() {
        const {points: points} = this.attribute;
        if (!points || points.length < 2) return !1;
        let validFlag = !0;
        return points.forEach((point => {
            if (point.length) point.forEach((p => {
                isValidNumber(p.x) && isValidNumber(p.y) || (validFlag = !1);
            })); else if (!isValidNumber(point.x) || !isValidNumber(point.y)) return void (validFlag = !1);
        })), validFlag;
    }
    addMarkLineLabels(container) {
        this._addMarkLabels(container, "mark-common-line-label", MarkLine.defaultAttributes.label);
    }
    updateMarkLineLabels() {
        this._updateMarkLabels(MarkLine.defaultAttributes.label);
    }
}

MarkLine.defaultAttributes = DEFAULT_MARK_LINE_THEME;
//# sourceMappingURL=line.js.map
