import { merge } from "@visactor/vutils";

import { ArcSegment } from "../segment";

import { loadMarkArcLineComponent } from "./register";

import { DEFAULT_STATES } from "../constant";

import { MarkCommonLine } from "./common-line";

import { IMarkCommonArcLabelPosition } from "./type";

import { DEFAULT_MARK_ARC_LINE_THEME, DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP } from "./config";

import { markCommonLineAnimate } from "./animate/animate";

loadMarkArcLineComponent();

export function registerMarkArcLineAnimate() {
    MarkArcLine._animate = markCommonLineAnimate;
}

export class MarkArcLine extends MarkCommonLine {
    markerAnimate(state) {
        MarkArcLine._animate && this._animationConfig && MarkArcLine._animate(this._line, this._label, this._animationConfig, state);
    }
    constructor(attributes, options) {
        super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, MarkArcLine.defaultAttributes, attributes)), 
        this.name = "markArcLine";
    }
    getPointAttrByPosition(direction, labelAttrs) {
        const {center: center, radius: radius, startAngle: startAngle, endAngle: endAngle} = this.attribute, {refX: refX = 0, refY: refY = 0} = labelAttrs;
        let angle;
        switch (direction) {
          case IMarkCommonArcLabelPosition.arcInnerStart:
            angle = startAngle;

          case IMarkCommonArcLabelPosition.arcOuterStart:
            angle = startAngle;
            break;

          case IMarkCommonArcLabelPosition.arcInnerEnd:
            angle = endAngle;

          case IMarkCommonArcLabelPosition.arcOuterEnd:
            angle = endAngle;
            break;

          case IMarkCommonArcLabelPosition.center:
          case IMarkCommonArcLabelPosition.arcInnerMiddle:
          case IMarkCommonArcLabelPosition.arcOuterMiddle:
          default:
            angle = (startAngle + endAngle) / 2;
        }
        return {
            position: {
                x: center.x + (radius + refY) * Math.cos(angle) + refX * Math.cos(angle - Math.PI / 2),
                y: center.y + (radius + refY) * Math.sin(angle) + refX * Math.sin(angle - Math.PI / 2)
            },
            angle: angle
        };
    }
    getTextStyle(position) {
        return DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP[position];
    }
    getRotateByAngle(angle, labelAttrs) {
        var _a;
        return angle - Math.PI / 2 + (null !== (_a = labelAttrs.refAngle) && void 0 !== _a ? _a : 0);
    }
    createSegment() {
        const {center: center, radius: radius, startAngle: startAngle, endAngle: endAngle, startSymbol: startSymbol, endSymbol: endSymbol, lineStyle: lineStyle, state: state} = this.attribute;
        return new ArcSegment({
            center: center,
            radius: radius,
            startAngle: startAngle,
            endAngle: endAngle,
            startSymbol: startSymbol,
            endSymbol: endSymbol,
            lineStyle: lineStyle,
            state: {
                line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
                startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
                endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
            }
        });
    }
    setLineAttributes() {
        const {center: center, radius: radius, startAngle: startAngle, endAngle: endAngle, startSymbol: startSymbol, endSymbol: endSymbol, lineStyle: lineStyle, state: state} = this.attribute;
        this._line && this._line.setAttributes({
            center: center,
            radius: radius,
            startAngle: startAngle,
            endAngle: endAngle,
            startSymbol: startSymbol,
            endSymbol: endSymbol,
            lineStyle: lineStyle,
            state: {
                line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
                startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
                endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
            }
        });
    }
    isValidPoints() {
        return !0;
    }
    addMarkLineLabels(container) {
        this._addMarkLabels(container, "mark-common-line-label", MarkArcLine.defaultAttributes.label);
    }
    updateMarkLineLabels() {
        this._updateMarkLabels(MarkArcLine.defaultAttributes.label);
    }
}

MarkArcLine.defaultAttributes = DEFAULT_MARK_ARC_LINE_THEME;
//# sourceMappingURL=arc-line.js.map
