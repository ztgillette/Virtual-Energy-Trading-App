{"version":3,"sources":["../src/crosshair/polygon.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,KAAK,EAAE,gBAAgB,EAAE,YAAY,EAAE,MAAM,kBAAkB,CAAC;AAEzE,OAAO,EAAE,aAAa,EAAE,MAAM,QAAQ,CAAC;AAGvC,OAAO,EAAE,6BAA6B,EAAE,MAAM,YAAY,CAAC;AAE3D,6BAA6B,EAAE,CAAC;AAChC,MAAM,OAAO,gBAAiB,SAAQ,aAAoC;IASxE,YAAY,UAAiC,EAAE,OAA0B;QACvE,KAAK,CAAC,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,EAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,EAAE,gBAAgB,CAAC,iBAAiB,EAAE,UAAU,CAAC,CAAC,CAAC;IACvG,CAAC;IAES,eAAe,CAAC,SAAiB;QACzC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,GAAG,CAAC,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,SAAkC,CAAC;QACzF,MAAM,EAAE,UAAU,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,SAAS,CAAC;QAEhD,MAAM,OAAO,GAAG,CAAC,QAAQ,GAAG,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC;QAC9D,MAAM,SAAS,GAAG,CAAC,QAAQ,GAAG,UAAU,CAAC,GAAG,KAAK,CAAC;QAClD,IAAI,IAAI,CAAC;QACT,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,IAAI,KAAK,EAAE,KAAK,EAAE,EAAE;YAC3C,MAAM,KAAK,GAAG,UAAU,GAAG,SAAS,GAAG,KAAK,CAAC;YAC7C,MAAM,KAAK,GAAG,gBAAgB,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;YACtD,IAAI,KAAK,KAAK,CAAC,EAAE;gBACf,IAAI,GAAG,IAAI,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,EAAE,CAAC;aACjC;iBAAM;gBACL,IAAI,IAAI,IAAI,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,EAAE,CAAC;aAClC;YACD,IAAI,KAAK,KAAK,KAAK,IAAI,OAAO,EAAE;gBAC9B,IAAI,IAAI,GAAG,CAAC;aACb;SACF;QAED,MAAM,OAAO,GAAG,SAAS,CAAC,mBAAmB,CAC3C,mBAAmB,kBAEjB,IAAI,IACD,SAAS,GAEd,MAAM,CACP,CAAC;QACF,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,WAAW,CAAC,KAAuB;QACjC,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,SAAkC,CAAC;QAC3D,MAAM,MAAM,GAAG,YAAY,CAAC,UAAU,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;QAEtD,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;IACtC,CAAC;;AAhDM,kCAAiB,GAAG;IACzB,SAAS,EAAE;QACT,MAAM,EAAE,SAAS;QACjB,SAAS,EAAE,CAAC;QACZ,QAAQ,EAAE,CAAC,CAAC,CAAC;KACd;CACF,CAAC","file":"polygon.js","sourcesContent":["/**\n * @description polygon 类型 crosshair，用于极坐标系下\n */\nimport type { IGroup } from '@visactor/vrender-core';\nimport { merge, polarToCartesian, PointService } from '@visactor/vutils';\nimport type { PointLocationCfg } from '../core/type';\nimport { CrosshairBase } from './base';\nimport type { PolygonCrosshairAttrs } from './type';\nimport type { ComponentOptions } from '../interface';\nimport { loadPolygonCrosshairComponent } from './register';\n\nloadPolygonCrosshairComponent();\nexport class PolygonCrosshair extends CrosshairBase<PolygonCrosshairAttrs> {\n  static defaultAttributes = {\n    lineStyle: {\n      stroke: '#b2bacf',\n      lineWidth: 1,\n      lineDash: [2]\n    }\n  };\n\n  constructor(attributes: PolygonCrosshairAttrs, options?: ComponentOptions) {\n    super(options?.skipDefault ? attributes : merge({}, PolygonCrosshair.defaultAttributes, attributes));\n  }\n\n  protected renderCrosshair(container: IGroup) {\n    const { center, radius, sides = 6, lineStyle } = this.attribute as PolygonCrosshairAttrs;\n    const { startAngle, endAngle } = this.attribute;\n\n    const isClose = (endAngle - startAngle) % (Math.PI * 2) === 0;\n    const eachAngle = (endAngle - startAngle) / sides;\n    let path;\n    for (let index = 0; index <= sides; index++) {\n      const angle = startAngle + eachAngle * index;\n      const point = polarToCartesian(center, radius, angle);\n      if (index === 0) {\n        path = `M${point.x},${point.y}`;\n      } else {\n        path += `L${point.x},${point.y}`;\n      }\n      if (index === sides && isClose) {\n        path += 'Z';\n      }\n    }\n\n    const polygon = container.createOrUpdateChild(\n      'crosshair-polygon',\n      {\n        path,\n        ...lineStyle\n      },\n      'path'\n    );\n    return polygon;\n  }\n\n  setLocation(point: PointLocationCfg) {\n    const { center } = this.attribute as PolygonCrosshairAttrs;\n    const radius = PointService.distancePP(point, center);\n\n    this.setAttribute('radius', radius);\n  }\n}\n"]}