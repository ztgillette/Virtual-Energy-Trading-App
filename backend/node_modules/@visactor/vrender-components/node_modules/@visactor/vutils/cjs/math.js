"use strict";

function acos(x) {
    return x > 1 ? 0 : x < -1 ? exports.pi : Math.acos(x);
}

function asin(x) {
    return x >= 1 ? exports.halfPi : x <= -1 ? -exports.halfPi : Math.asin(x);
}

function pointAt(x1, y1, x2, y2, t) {
    let x = x2, y = y2;
    return "number" == typeof x1 && "number" == typeof x2 && (x = (1 - t) * x1 + t * x2), 
    "number" == typeof y1 && "number" == typeof y2 && (y = (1 - t) * y1 + t * y2), {
        x: x,
        y: y
    };
}

function lengthFromPointToLine(point, point1, point2) {
    const dir1X = point2.x - point1.x, dir1Y = point2.y - point1.y, dir2X = point.x - point1.x, dir2Y = point.y - point1.y;
    return Math.abs(dir1X * dir2Y - dir2X * dir1Y) / Math.sqrt(dir1X * dir1X + dir1Y * dir1Y);
}

function crossProduct(dir1, dir2) {
    return dir1[0] * dir2[1] - dir1[1] * dir2[0];
}

function crossProductPoint(dir1, dir2) {
    return dir1.x * dir2.y - dir1.y * dir2.x;
}

function dotProduct(a, b) {
    let ret = 0;
    for (let i = 0; i < a.length; ++i) ret += a[i] * b[i];
    return ret;
}

function fuzzyEqualNumber(a, b) {
    return (0, exports.abs)(a - b) < exports.epsilon;
}

function fuzzyEqualVec(a, b) {
    return (0, exports.abs)(a[0] - b[0]) + (0, exports.abs)(a[1] - b[1]) < exports.epsilon;
}

function fixPrecision(num, precision = 10) {
    return Math.round(num * precision) / precision;
}

function getDecimalPlaces(n) {
    const dStr = n.toString().split(/[eE]/), s = (dStr[0].split(".")[1] || "").length - (+dStr[1] || 0);
    return s > 0 ? s : 0;
}

function precisionAdd(a, b) {
    return fixPrecision(a + b, 10 ** Math.max(getDecimalPlaces(a), getDecimalPlaces(b)));
}

function precisionSub(a, b) {
    return fixPrecision(a - b, 10 ** Math.max(getDecimalPlaces(a), getDecimalPlaces(b)));
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.precisionSub = exports.precisionAdd = exports.getDecimalPlaces = exports.fixPrecision = exports.fuzzyEqualVec = exports.fuzzyEqualNumber = exports.dotProduct = exports.crossProductPoint = exports.crossProduct = exports.lengthFromPointToLine = exports.pointAt = exports.asin = exports.acos = exports.pow = exports.sqrt = exports.sin = exports.min = exports.max = exports.cos = exports.atan2 = exports.abs = exports.pi2 = exports.SUBDIVISION_MAX_ITERATIONS = exports.SUBDIVISION_PRECISION = exports.NEWTON_MIN_SLOPE = exports.NEWTON_ITERATIONS = exports.tau = exports.halfPi = exports.pi = exports.epsilon = void 0, 
exports.epsilon = 1e-12, exports.pi = Math.PI, exports.halfPi = exports.pi / 2, 
exports.tau = 2 * exports.pi, exports.NEWTON_ITERATIONS = 4, exports.NEWTON_MIN_SLOPE = .001, 
exports.SUBDIVISION_PRECISION = 1e-7, exports.SUBDIVISION_MAX_ITERATIONS = 10, exports.pi2 = 2 * Math.PI, 
exports.abs = Math.abs, exports.atan2 = Math.atan2, exports.cos = Math.cos, exports.max = Math.max, 
exports.min = Math.min, exports.sin = Math.sin, exports.sqrt = Math.sqrt, exports.pow = Math.pow, 
exports.acos = acos, exports.asin = asin, exports.pointAt = pointAt, exports.lengthFromPointToLine = lengthFromPointToLine, 
exports.crossProduct = crossProduct, exports.crossProductPoint = crossProductPoint, 
exports.dotProduct = dotProduct, exports.fuzzyEqualNumber = fuzzyEqualNumber, exports.fuzzyEqualVec = fuzzyEqualVec, 
exports.fixPrecision = fixPrecision, exports.getDecimalPlaces = getDecimalPlaces, 
exports.precisionAdd = precisionAdd, exports.precisionSub = precisionSub;
//# sourceMappingURL=math.js.map