import { isArray, isNil, isString, isValid } from "../../../common";

import { eastAsianCharacterInfo } from "../stringWidth";

import { getContextFont } from "./util";

export class TextMeasure {
    constructor(option, textSpec) {
        this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, 
        this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = !1, 
        this._notSupportCanvas = !1, this._notSupportVRender = !1, this._userSpec = {}, 
        this.specialCharSet = "-/: .,@%'\"~", this._option = option, this._userSpec = null != textSpec ? textSpec : {}, 
        this.textSpec = this._initSpec(), isValid(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), 
        this._standardMethod = isValid(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
    }
    initContext() {
        if (this._notSupportCanvas) return !1;
        if (isNil(this._canvas) && (isValid(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), 
        isNil(this._canvas) && "undefined" != typeof window && void 0 !== window.document && globalThis && isValid(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), 
        isNil(this._context) && isValid(this._canvas)) {
            const context = this._canvas.getContext("2d");
            isValid(context) && (context.save(), context.font = getContextFont(this.textSpec), 
            this._contextSaved = !0, this._context = context);
        }
        return !isNil(this._context) || (this._notSupportCanvas = !0, !1);
    }
    _initSpec() {
        var _a, _b, _c;
        const {defaultFontParams: defaultFontParams = {}} = this._option, {fontStyle: fontStyle = defaultFontParams.fontStyle, fontVariant: fontVariant = defaultFontParams.fontVariant, fontWeight: fontWeight = (null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal"), fontSize: fontSize = (null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12), fontFamily: fontFamily = (null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif"), align: align, textAlign: textAlign = (null != align ? align : "center"), baseline: baseline, textBaseline: textBaseline = (null != baseline ? baseline : "middle"), ellipsis: ellipsis, limit: limit} = this._userSpec;
        let {lineHeight: lineHeight = fontSize} = this._userSpec;
        if (isString(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
            const scale = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
            lineHeight = fontSize * scale;
        }
        return {
            fontStyle: fontStyle,
            fontVariant: fontVariant,
            fontFamily: fontFamily,
            fontSize: fontSize,
            fontWeight: fontWeight,
            textAlign: textAlign,
            textBaseline: textBaseline,
            ellipsis: ellipsis,
            limit: limit,
            lineHeight: lineHeight
        };
    }
    measure(text, method) {
        switch (method) {
          case "vrender":
          case "canopus":
            return this.fullMeasure(text);

          case "canvas":
            return this.measureWithNaiveCanvas(text);

          case "simple":
            return this.quickMeasureWithoutCanvas(text);

          default:
            return this.quickMeasure(text);
        }
    }
    fullMeasure(text) {
        if (isNil(text)) return {
            width: 0,
            height: 0
        };
        if (isNil(this._option.getTextBounds) || !this._notSupportVRender) return this.measureWithNaiveCanvas(text);
        const {fontFamily: fontFamily, fontSize: fontSize, fontWeight: fontWeight, textAlign: textAlign, textBaseline: textBaseline, ellipsis: ellipsis, limit: limit, lineHeight: lineHeight} = this.textSpec;
        let size;
        try {
            const bounds = this._option.getTextBounds({
                text: text,
                fontFamily: fontFamily,
                fontSize: fontSize,
                fontWeight: fontWeight,
                textAlign: textAlign,
                textBaseline: textBaseline,
                ellipsis: !!ellipsis,
                maxLineWidth: limit || 1 / 0,
                lineHeight: lineHeight
            });
            size = {
                width: bounds.width(),
                height: bounds.height()
            };
        } catch (e) {
            this._notSupportVRender = !0, size = this.measureWithNaiveCanvas(text);
        }
        return size;
    }
    measureWithNaiveCanvas(text) {
        return this._measureReduce(text, this._measureWithNaiveCanvas.bind(this));
    }
    _measureWithNaiveCanvas(text) {
        var _a;
        if (!this.initContext()) return this._quickMeasureWithoutCanvas(text);
        const metrics = this._context.measureText(text), {fontSize: fontSize, lineHeight: lineHeight} = this.textSpec;
        return {
            width: metrics.width,
            height: null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize,
            fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
            fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
        };
    }
    quickMeasure(text) {
        return this._measureReduce(text, this._quickMeasure.bind(this));
    }
    _quickMeasure(text) {
        const totalSize = {
            width: 0,
            height: 0
        };
        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            let size = this._measureSpecialChar(char);
            isNil(size) && TextMeasure.NUMBERS_CHAR_SET.includes(char) && (size = this._measureNumberChar()), 
            isNil(size) && [ "F", "W" ].includes(eastAsianCharacterInfo(char)) && (size = this._measureFullSizeChar()), 
            isNil(size) && (size = this._measureLetterChar()), totalSize.width += size.width, 
            totalSize.height = Math.max(totalSize.height, size.height), !isNil(size.fontBoundingBoxAscent) && (totalSize.fontBoundingBoxAscent = size.fontBoundingBoxAscent), 
            !isNil(size.fontBoundingBoxDescent) && (totalSize.fontBoundingBoxDescent = size.fontBoundingBoxDescent);
        }
        return totalSize;
    }
    quickMeasureWithoutCanvas(text) {
        return this._measureReduce(text, this._quickMeasureWithoutCanvas.bind(this));
    }
    _quickMeasureWithoutCanvas(text) {
        var _a;
        const totalSize = {
            width: 0,
            height: 0
        }, {fontSize: fontSize, lineHeight: lineHeight} = this.textSpec;
        for (let i = 0; i < text.length; i++) {
            const char = text[i], size = [ "F", "W" ].includes(eastAsianCharacterInfo(char)) ? 1 : .53;
            totalSize.width += size * fontSize;
        }
        return totalSize.height = null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize, 
        totalSize;
    }
    _measureReduce(text, processor) {
        var _a;
        const {fontSize: fontSize, lineHeight: lineHeight} = this.textSpec, defaultResult = {
            width: 0,
            height: 0
        };
        if (isNil(text)) return defaultResult;
        if (isArray(text)) {
            const textArr = text.filter(isValid).map((s => s.toString()));
            return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
                width: textArr.reduce(((maxWidth, cur) => Math.max(maxWidth, processor(cur).width)), 0),
                height: textArr.length * ((null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize) + 1) + 1
            };
        }
        return processor(text.toString());
    }
    _measureNumberChar() {
        if (isNil(this._numberCharSize)) {
            const numberBounds = this._standardMethod(TextMeasure.NUMBERS_CHAR_SET);
            this._numberCharSize = {
                width: numberBounds.width / TextMeasure.NUMBERS_CHAR_SET.length,
                height: numberBounds.height,
                fontBoundingBoxAscent: numberBounds.fontBoundingBoxAscent,
                fontBoundingBoxDescent: numberBounds.fontBoundingBoxDescent
            };
        }
        return this._numberCharSize;
    }
    _measureFullSizeChar() {
        return isNil(this._fullCharSize) && (this._fullCharSize = this._standardMethod(TextMeasure.FULL_SIZE_CHAR)), 
        this._fullCharSize;
    }
    _measureLetterChar() {
        if (isNil(this._letterCharSize)) {
            const alphabetBounds = this._standardMethod(TextMeasure.ALPHABET_CHAR_SET);
            this._letterCharSize = {
                width: alphabetBounds.width / TextMeasure.ALPHABET_CHAR_SET.length,
                height: alphabetBounds.height,
                fontBoundingBoxAscent: alphabetBounds.fontBoundingBoxAscent,
                fontBoundingBoxDescent: alphabetBounds.fontBoundingBoxDescent
            };
        }
        return this._letterCharSize;
    }
    _measureSpecialChar(char) {
        return isValid(this._specialCharSizeMap[char]) ? this._specialCharSizeMap[char] : this.specialCharSet.includes(char) ? (this._specialCharSizeMap[char] = this._standardMethod(char), 
        this._specialCharSizeMap[char]) : null;
    }
    release() {
        isValid(this._canvas) && (this._canvas = null), isValid(this._context) && (this._contextSaved && (this._context.restore(), 
        this._contextSaved = !1), this._context = null);
    }
}

TextMeasure.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure.NUMBERS_CHAR_SET = "0123456789", 
TextMeasure.FULL_SIZE_CHAR = "å­—";
//# sourceMappingURL=textMeasure.js.map
