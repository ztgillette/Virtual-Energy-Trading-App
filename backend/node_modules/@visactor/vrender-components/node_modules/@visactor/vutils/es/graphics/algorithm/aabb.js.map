{"version":3,"sources":["../src/graphics/algorithm/aabb.ts"],"names":[],"mappings":"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","file":"aabb.js","sourcesContent":["import type { IBoundsLike } from '../../data-structure';\nimport type { Point } from './interface';\nimport { pointInRect } from './intersect';\n\nlet x1: number;\nlet y1: number;\nlet x2: number;\nlet y2: number;\nexport function getAABBFromPoints(points: Point[]): IBoundsLike {\n  (x1 = Infinity), (y1 = Infinity), (x2 = -Infinity), (y2 = -Infinity);\n  // todo 有优化空间\n  points.forEach(point => {\n    if (x1 > point.x) {\n      x1 = point.x;\n    }\n    if (x2 < point.x) {\n      x2 = point.x;\n    }\n    if (y1 > point.y) {\n      y1 = point.y;\n    }\n    if (y2 < point.y) {\n      y2 = point.y;\n    }\n  });\n\n  return { x1, y1, x2, y2 };\n}\n\nexport function pointInAABB(point: Point, aabb: IBoundsLike): boolean {\n  return pointInRect(point, aabb, false);\n}\n\nexport function unionAABB(\n  bounds1: IBoundsLike,\n  bounds2: IBoundsLike,\n  buffer = 3,\n  format = false\n): [IBoundsLike, IBoundsLike?] {\n  let x11 = bounds1.x1;\n  let x12 = bounds1.x2;\n  let y11 = bounds1.y1;\n  let y12 = bounds1.y2;\n  let x21 = bounds2.x1;\n  let x22 = bounds2.x2;\n  let y21 = bounds2.y1;\n  let y22 = bounds2.y2;\n  if (format) {\n    let temp;\n    if (x11 > x12) {\n      temp = x11;\n      x11 = x12;\n      x12 = temp;\n    }\n    if (y11 > y12) {\n      temp = y11;\n      y11 = y12;\n      y12 = temp;\n    }\n    if (x21 > x22) {\n      temp = x21;\n      x21 = x22;\n      x22 = temp;\n    }\n    if (y21 > y22) {\n      temp = y21;\n      y21 = y22;\n      y22 = temp;\n    }\n  }\n  // 不相交直接跳过\n  if (x11 >= x22 || x12 <= x21 || y11 >= y22 || y12 <= y21) {\n    return [bounds1, bounds2];\n  }\n\n  const area1 = (x12 - x11 + buffer * 2) * (y12 - y11 + buffer * 2);\n  const area2 = (x22 - x21 + buffer * 2) * (y22 - y21 + buffer * 2);\n  const x1 = Math.min(x11, x21);\n  const y1 = Math.min(y11, y21);\n  const x2 = Math.max(x12, x22);\n  const y2 = Math.max(y12, y22);\n  const unionArea = (x2 - x1) * (y2 - y1);\n  if (area1 + area2 > unionArea) {\n    return [{ x1, x2, y1, y2 }];\n  }\n  return [bounds1, bounds2];\n}\n\nexport function mergeAABB(boundsList: IBoundsLike[]) {\n  const nextList: IBoundsLike[] = [];\n  function _merge(baseBound: IBoundsLike, list: IBoundsLike[]) {\n    const l: IBoundsLike[] = [];\n    list.forEach(b => {\n      let arr: [IBoundsLike, IBoundsLike?];\n      // 相交\n      if ((arr = unionAABB(baseBound, b)).length > 1) {\n        l.push(b);\n        return;\n      }\n      baseBound = arr[0];\n    });\n    nextList.push(baseBound);\n    l.length && _merge(l[0], l.slice(1));\n  }\n  _merge(boundsList[0], boundsList.slice(1));\n  return nextList;\n}\n"]}