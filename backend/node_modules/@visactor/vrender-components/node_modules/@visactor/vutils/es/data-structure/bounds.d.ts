import type { IMatrix } from './matrix';
import type { IPointLike } from './point';
export type IBoundsLike = Pick<IBounds, 'x1' | 'y1' | 'x2' | 'y2'>;
export type IAABBBoundsLike = IBoundsLike;
export type IOBBBoundsLike = Pick<IOBBBounds, 'x1' | 'y1' | 'x2' | 'y2' | 'angle'>;
export interface IBounds {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
    clone: () => IBounds;
    clear: () => IBounds;
    empty: () => boolean;
    equals: (b: IBounds) => boolean;
    set: (x1: number, y1: number, x2: number, y2: number) => IBounds;
    setValue: (x1: number, y1: number, x2: number, y2: number) => IBounds;
    add: (x: number, y: number) => IBounds;
    expand: (d: number) => IBounds;
    round: () => IBounds;
    translate: (dx: number, dy: number) => IBounds;
    rotate: (angle: number, x: number, y: number) => IBounds;
    scale: (sx: number, sy: number, x: number, y: number) => IBounds;
    union: (b: IBoundsLike) => IBounds;
    intersect: (b: IBoundsLike) => IBounds;
    encloses: (b: IBoundsLike) => boolean;
    alignsWith: (b: IBoundsLike) => boolean;
    intersects: (b: IBoundsLike) => boolean;
    contains: (x: number, y: number) => boolean;
    containsPoint: (p: IPointLike) => boolean;
    width: () => number;
    height: () => number;
    scaleX: (s: number) => IBounds;
    scaleY: (s: number) => IBounds;
    copy: (b: IBoundsLike) => IBounds;
    transformWithMatrix: (matrix: IMatrix) => IBounds;
}
export type IAABBBounds = IBounds;
export interface IOBBBounds extends IBounds {
    angle: number;
    getRotatedCorners: () => IPointLike[];
}
export declare function transformBoundsWithMatrix(out: IBounds, bounds: IBounds, matrix: IMatrix): IBounds;
export declare function transformBounds(bounds: IBounds, x: number, y: number, scaleX: number, scaleY: number, angle: number, rotateCenter?: [number, number]): void;
export declare class Bounds implements IBounds {
    x1: number;
    y1: number;
    x2: number;
    y2: number;
    constructor(bounds?: Bounds);
    clone(): Bounds;
    clear(): Bounds;
    empty(): boolean;
    equals(b: IBoundsLike): boolean;
    setValue(x1?: number, y1?: number, x2?: number, y2?: number): Bounds;
    set(x1?: number, y1?: number, x2?: number, y2?: number): Bounds;
    add(x?: number, y?: number): Bounds;
    expand(d?: number | [number, number, number, number]): Bounds;
    round(): Bounds;
    translate(dx?: number, dy?: number): Bounds;
    rotate(angle?: number, x?: number, y?: number): Bounds;
    scale(sx?: number, sy?: number, x?: number, y?: number): Bounds;
    union(b: IBoundsLike): Bounds;
    intersect(b: IBoundsLike): Bounds;
    encloses(b: IBoundsLike): boolean;
    alignsWith(b: IBoundsLike): boolean;
    intersects(b: IBoundsLike): boolean;
    contains(x?: number, y?: number): boolean;
    containsPoint(p: IPointLike): boolean;
    width(): number;
    height(): number;
    scaleX(s?: number): Bounds;
    scaleY(s?: number): Bounds;
    transformWithMatrix(matrix: IMatrix): Bounds;
    copy(b: IBoundsLike): this;
    private rotatedPoints;
    private scalePoints;
}
export declare class AABBBounds extends Bounds {
}
export declare class OBBBounds extends Bounds {
    angle: number;
    constructor(bounds?: Bounds, angle?: number);
    intersects(b: OBBBounds): boolean;
    setValue(x1?: number, y1?: number, x2?: number, y2?: number, angle?: number): Bounds;
    clone(): OBBBounds;
    getRotatedCorners(): IPointLike[];
}
