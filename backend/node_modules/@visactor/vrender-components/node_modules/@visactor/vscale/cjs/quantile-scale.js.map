{"version":3,"sources":["../src/quantile-scale.ts"],"names":[],"mappings":"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","file":"quantile-scale.js","sourcesContent":["import { isNil, isValidNumber, bisect, quantileSorted, ascending, arrayEqual } from '@visactor/vutils';\nimport type { DiscretizingScaleType, IBaseScale } from './interface';\nimport { ScaleEnum } from './type';\n\nexport class QuantileScale implements IBaseScale {\n  readonly type: DiscretizingScaleType = ScaleEnum.Quantile;\n\n  protected _range: any[] = [];\n  protected _domain: number[] = [];\n  protected _thresholds: number[] = [];\n\n  protected _unknown: any;\n\n  unknown(): any[];\n  unknown(_: any): this;\n  unknown(_?: any): this | any {\n    if (!arguments.length) {\n      return this._unknown;\n    }\n    this._unknown = _;\n    return this;\n  }\n\n  rescale(slience?: boolean) {\n    if (slience) {\n      return this;\n    }\n    let i = 0;\n    const n = Math.max(1, this._range.length);\n    this._thresholds = new Array(n - 1);\n    while (++i < n) {\n      this._thresholds[i - 1] = quantileSorted(this._domain, i / n);\n    }\n    return this;\n  }\n\n  scale(x: any) {\n    return isValidNumber(x) ? this._range[bisect(this._thresholds, x)] : this._unknown;\n  }\n\n  invertExtent(y: any) {\n    const i = this._range.indexOf(y);\n    return i < 0\n      ? [NaN, NaN]\n      : [\n          i > 0 ? this._thresholds[i - 1] : this._domain[0],\n          i < this._thresholds.length ? this._thresholds[i] : this._domain[this._domain.length - 1]\n        ];\n  }\n\n  quantiles() {\n    return this._thresholds.slice();\n  }\n\n  domain(): any[];\n  domain(_: any[], slience?: boolean): this;\n  domain(_?: any[], slience?: boolean): this | any {\n    if (!_) {\n      return this._domain.slice();\n    }\n    this._domain = [];\n    for (const value of _) {\n      if (!isNil(value) && !Number.isNaN(+value)) {\n        this._domain.push(+value);\n      }\n    }\n\n    this._domain.sort(ascending);\n    return this.rescale(slience);\n  }\n\n  range(): any[];\n  range(_: any[], slience?: boolean): this;\n  range(_?: any[], slience?: boolean): this | any {\n    if (!_) {\n      return this._range.slice();\n    }\n    const nextRange = Array.from(_);\n    if (arrayEqual(this._range, nextRange)) {\n      return this;\n    }\n    this._range = nextRange;\n    return this.rescale(slience);\n  }\n\n  clone(): QuantileScale {\n    return new QuantileScale().domain(this._domain, true).range(this._range).unknown(this._unknown) as QuantileScale;\n  }\n}\n"]}