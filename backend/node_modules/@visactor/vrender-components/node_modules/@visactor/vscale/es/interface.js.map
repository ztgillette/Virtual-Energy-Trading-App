{"version":3,"sources":["../src/interface.ts"],"names":[],"mappings":"","file":"interface.js","sourcesContent":["import type { ScaleEnum } from './type';\n\nexport type Tuple<TItem, TLength extends number> = [TItem, ...TItem[]] & { length: TLength };\n\nexport type InterpolateType<T> = (a: T, b: T) => (x: number) => T;\n\nexport type TransformType = (v: number) => number;\n\nexport type BimapType<T> = (\n  domain: [number, number],\n  range: [T, T],\n  interpolate: InterpolateType<T>\n) => (x: number) => T;\n\nexport type PolymapType<T> = (domain: number[], range: T[], interpolate: InterpolateType<T>) => (x: number) => T;\n\nexport interface FloorCeilType<T> {\n  floor: (x: T) => T;\n  ceil: (x: T) => T;\n  offset?: (x: T, step: number) => T;\n}\n\nexport type DateLikeType = number | string | Date;\n\nexport type TickData = {\n  // data index\n  index: number;\n  // tick ratio of axis range\n  value: number;\n  // tick value\n  tick: any;\n};\n\nexport type DiscreteScaleType = `${ScaleEnum.Ordinal}` | `${ScaleEnum.Band}` | `${ScaleEnum.Point}`;\nexport type ContinuousScaleType =\n  | `${ScaleEnum.Linear}`\n  | `${ScaleEnum.Log}`\n  | `${ScaleEnum.Pow}`\n  | `${ScaleEnum.Sqrt}`\n  | `${ScaleEnum.Symlog}`\n  | `${ScaleEnum.Time}`;\nexport type DiscretizingScaleType = `${ScaleEnum.Quantile}` | `${ScaleEnum.Quantize}` | `${ScaleEnum.Threshold}`;\nexport type ScaleType = DiscreteScaleType | ContinuousScaleType | DiscretizingScaleType | `${ScaleEnum.Identity}`;\n\nexport interface IRangeFactor {\n  calculateVisibleDomain: (range: any[]) => any;\n  rangeFactor: (_?: [number, number], slience?: boolean, clear?: boolean) => this | any;\n  rangeFactorStart: (_?: number, slience?: boolean) => this | any;\n  rangeFactorEnd: (_?: number, slience?: boolean) => this | any;\n  unknown: (_?: any) => this | any;\n}\n\nexport interface IContinuesScaleTicks {\n  ticks: (count?: number, options?: { noDecimals?: boolean }) => any[];\n  d3Ticks: (count?: number, options?: { noDecimals?: boolean }) => any[];\n  forceTicks: (count?: number) => any[];\n  stepTicks: (step: number) => any[];\n  nice: (count?: number) => this;\n  niceMin: (count?: number) => this;\n  niceMax: (count?: number) => this;\n}\n\nexport interface IBaseScale {\n  readonly type: string;\n  unknown: (_?: any) => this | any;\n  scale: (x: any) => any;\n  domain: (_?: any[], slience?: boolean) => this | any;\n  range: (_?: any[], slience?: boolean) => this | any;\n  invert?: (y: any) => any;\n  clone?: () => IBaseScale;\n  rescale?: (slience?: boolean) => this;\n  tickData?: (count?: number) => TickData[];\n}\n\nexport interface IOrdinalScale extends IBaseScale {\n  specified: (_?: Record<string, unknown>) => this | Record<string, unknown>;\n  /**\n   * 获取domain中值的序号, 历史原因序号从 1 开始\n   * @param x 输入值\n   * @returns 序号，如果不存在，返回 -1\n   */\n  index: (x: any) => number;\n}\n\nexport interface IBandLikeScale extends IOrdinalScale, IRangeFactor {\n  readonly type: DiscreteScaleType;\n  domain: (_?: any[], slience?: boolean) => this | any;\n  range: (_?: any[], slience?: boolean) => this | any;\n  rescale: (slience?: boolean) => this;\n  rangeRound: (_: any[], slience?: boolean) => this;\n  ticks?: (count?: number) => any[];\n  /**\n   * 生成tick数组，这个tick数组的长度就是count的长度\n   */\n  forceTicks: (count: number) => any[];\n  /**\n   * 基于给定step的ticks数组生成\n   */\n  stepTicks: (step: number) => any[];\n  padding: (p?: number | [number, number], slience?: boolean) => this | number;\n  paddingInner: (_?: number, slience?: boolean) => any;\n  paddingOuter: (_?: number, slience?: boolean) => any;\n  bandwidth: (_?: number | 'auto', slience?: boolean) => number;\n  maxBandwidth: (_?: number | 'auto', slience?: boolean) => number;\n  minBandwidth: (_?: number | 'auto', slience?: boolean) => number;\n  /** 当前 bandwidth 是否被固定 */\n  isBandwidthFixed: () => boolean;\n  step: () => number;\n  round: (_?: boolean, slience?: boolean) => this | boolean;\n  align: (_?: number, slience?: boolean) => this | number;\n  clone: () => IBandLikeScale;\n  fishEye: (options?: ScaleFishEyeOptions, slience?: boolean, clear?: boolean) => this | ScaleFishEyeOptions;\n}\n\nexport interface IContinuousScale extends IBaseScale, IRangeFactor {\n  readonly type: ContinuousScaleType;\n  invert: (y: number) => any;\n  rangeRound: (_: any[], slience?: boolean) => this;\n  clamp: (_?: boolean, f?: (x: number) => number, slience?: boolean) => this | boolean;\n  interpolate: (_?: InterpolateType<any>, slience?: boolean) => this | InterpolateType<any>;\n  clone?: () => IContinuousScale;\n  rescale: () => this;\n  fishEye: (options?: ScaleFishEyeOptions, slience?: boolean, clear?: boolean) => this | ScaleFishEyeOptions;\n}\n\nexport type ILinearScale = IContinuousScale & IContinuesScaleTicks;\n\nexport interface IPowScale extends IContinuousScale, IContinuesScaleTicks {\n  exponent: (_?: number, slience?: boolean) => this | number;\n}\n\nexport interface ILogScale extends IContinuousScale, IContinuesScaleTicks {\n  base: (_?: number, slience?: boolean) => this | number;\n}\n\nexport interface ISymlogScale extends IContinuousScale, IContinuesScaleTicks {\n  constant: (_?: number, slience?: boolean) => this | number;\n}\n\nexport interface IQuantileScale extends Omit<IBaseScale, 'clone' | 'invert' | 'ticks' | 'tickData'> {\n  unknown: (_?: any) => this | any;\n  invertExtent: (y: any) => any[];\n  quantiles: () => number[];\n  clone: () => IQuantileScale;\n}\n\nexport interface IQuantizeScale\n  extends Omit<IBaseScale, 'clone' | 'invert' | 'ticks' | 'tickData'>,\n    IContinuesScaleTicks {\n  unknown: (_?: any) => this | any;\n  invertExtent: (y: any) => any[];\n  thresholds: () => any[];\n  clone: () => IQuantizeScale;\n}\n\nexport interface IThresholdScale\n  extends Omit<IBaseScale, 'clone' | 'invert' | 'ticks' | 'tickData'>,\n    IContinuesScaleTicks {\n  unknown: (_?: any) => this | any;\n  invertExtent: (y: any) => any[];\n  clone: () => IQuantizeScale;\n}\n\nexport type ContinuousTicksFunc = (\n  start: number,\n  stop: number,\n  count: number,\n  options?: {\n    noDecimals?: boolean;\n  }\n) => number[];\n\n/** wilkinson 生成ticks */\nexport type WilkinsonExtendedTicksFunc = (\n  start: number,\n  stop: number,\n  count?: number,\n  options?: {\n    /** 是否允许扩展min、max，不绝对强制，例如[3, 97] */\n    onlyLoose?: boolean;\n    /** nice numbers集合 */\n    Q?: number[];\n    /** 四个优化组件的权重 */\n    w?: [number, number, number, number];\n  }\n) => number[];\n\n/** 自定义ticks方法 */\nexport type CustomTicksFunc<T extends IBaseScale> = (scale: T, count: number) => number[];\n\nexport interface NiceOptions {\n  forceMin?: number;\n  forceMax?: number;\n  min?: number;\n  max?: number;\n}\n\nexport type NiceType = 'all' | 'min' | 'max';\n\nexport interface ScaleFishEyeOptions {\n  distortion?: number;\n  focus?: number;\n  radius?: number;\n  radiusRatio?: number;\n}\n"]}