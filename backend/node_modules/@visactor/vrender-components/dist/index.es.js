import { tau, halfPi as halfPi$1, AABBBounds, degreeToRadian, Point, PointService, abs, max, min, atan2, epsilon, Matrix, pi2, Logger, pi, isArray, isPointInLine, isNumberClose, TextMeasure, EventEmitter, isBoolean, isObject, isFunction, cos, sin, isString, pointAt, isNumber, sqrt, Color, OBBBounds, isNil, normalTransform, isValidUrl, isBase64, acos, transformBoundsWithMatrix, getContextFont, rotatePoint, clampAngleByRadian, asin, arrayEqual, Bounds, getRectIntersect, isRectIntersect, isEqual, isPlainObject, merge, isValid, clamp, clampRange, normalizePadding, debounce, throttle, hexToRgb, crossProduct, isEmpty, array, rectInsideAnotherRect, radianToDegree, getAngleByPoint, polarToCartesian, normalizeAngle, isValidNumber, flattenArray, isRotateAABBIntersect, isLess, isGreater, aabbSeparation, obbSeparation, cloneDeep, get, last, mixin, interpolateString, minInArray, maxInArray, binaryFuzzySearchInNumberRange, pointInRect, calculateAnchorOfBounds, computeQuadrant, polygonContainPoint } from '@visactor/vutils';
import { isContinuous, isDiscrete, LinearScale } from '@visactor/vscale';

class Generator {
  static GenAutoIncrementId() {
    return Generator.auto_increment_id++;
  }
}
Generator.auto_increment_id = 0;

class ContainerModule {
  constructor(registry) {
    this.id = Generator.GenAutoIncrementId(), this.registry = registry;
  }
}

const NAMED_TAG = "named";
const INJECT_TAG = "inject";
const MULTI_INJECT_TAG = "multi_inject";
const TAGGED = "inversify:tagged";
const PARAM_TYPES = "inversify:paramtypes";

class Metadata {
  constructor(key, value) {
    this.key = key, this.value = value;
  }
  toString() {
    return this.key === NAMED_TAG ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
  }
}

var Reflect$1 = (function (Reflect) {
  var target;
  return function (exporter) {
    const supportsSymbol = "function" == typeof Symbol,
      toPrimitiveSymbol = supportsSymbol && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive",
      functionPrototype = (Object.getPrototypeOf(Function)),
      _Map = ("object" == typeof process && process.env && process.env.REFLECT_METADATA_USE_MAP_POLYFILL, Map),
      Metadata = (new WeakMap());
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    function GetOrCreateMetadataMap(O, P, Create) {
      let targetMetadata = Metadata.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create) return;
        targetMetadata = new _Map(), Metadata.set(O, targetMetadata);
      }
      let metadataMap = targetMetadata.get(P);
      if (IsUndefined(metadataMap)) {
        if (!Create) return;
        metadataMap = new _Map(), targetMetadata.set(P, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return !0;
      const parent = OrdinaryGetPrototypeOf(O);
      return !IsNull(parent) && OrdinaryHasMetadata(MetadataKey, parent, P);
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      const metadataMap = GetOrCreateMetadataMap(O, P, !1);
      return !IsUndefined(metadataMap) && ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      const parent = OrdinaryGetPrototypeOf(O);
      return IsNull(parent) ? void 0 : OrdinaryGetMetadata(MetadataKey, parent, P);
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      const metadataMap = GetOrCreateMetadataMap(O, P, !1);
      if (!IsUndefined(metadataMap)) return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      GetOrCreateMetadataMap(O, P, !0).set(MetadataKey, MetadataValue);
    }
    function Type(x) {
      if (null === x) return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return null === x ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return void 0 === x;
    }
    function IsNull(x) {
      return null === x;
    }
    function IsSymbol(x) {
      return "symbol" == typeof x;
    }
    function IsObject(x) {
      return "object" == typeof x ? null !== x : "function" == typeof x;
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          return input;
      }
      const hint = 3 === PreferredType ? "string" : 5 === PreferredType ? "number" : "default",
        exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (void 0 !== exoticToPrim) {
        const result = exoticToPrim.call(input, hint);
        if (IsObject(result)) throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, "default" === hint ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if ("string" === hint) {
        const toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          const result = toString_1.call(O);
          if (!IsObject(result)) return result;
        }
        const valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          const result = valueOf.call(O);
          if (!IsObject(result)) return result;
        }
      } else {
        const valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          const result = valueOf.call(O);
          if (!IsObject(result)) return result;
        }
        const toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          const result = toString_2.call(O);
          if (!IsObject(result)) return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      const key = ToPrimitive(argument, 3);
      return IsSymbol(key) ? key : ToString(key);
    }
    function IsCallable(argument) {
      return "function" == typeof argument;
    }
    function GetMethod(V, P) {
      const func = V[P];
      if (null != func) {
        if (!IsCallable(func)) throw new TypeError();
        return func;
      }
    }
    function OrdinaryGetPrototypeOf(O) {
      const proto = Object.getPrototypeOf(O);
      if ("function" != typeof O || O === functionPrototype) return proto;
      if (proto !== functionPrototype) return proto;
      const prototype = O.prototype,
        prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (null == prototypeProto || prototypeProto === Object.prototype) return proto;
      const constructor = prototypeProto.constructor;
      return "function" != typeof constructor || constructor === O ? proto : constructor;
    }
    exporter("defineMetadata", defineMetadata), exporter("hasMetadata", hasMetadata), exporter("hasOwnMetadata", hasOwnMetadata), exporter("getMetadata", getMetadata);
  }((target = Reflect, function (key, value) {
    "function" != typeof target[key] && Object.defineProperty(target, key, {
      configurable: !0,
      writable: !0,
      value: value
    });
  })), Reflect;
})({});

function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
  const metadatas = [metadata];
  let paramsOrPropertiesMetadata = {};
  Reflect$1.hasOwnMetadata(metadataKey, annotationTarget) && (paramsOrPropertiesMetadata = Reflect$1.getMetadata(metadataKey, annotationTarget));
  let paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
  void 0 === paramOrPropertyMetadata && (paramOrPropertyMetadata = []), paramOrPropertyMetadata.push(...metadatas), paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata, Reflect$1.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
  _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
}
function createTaggedDecorator(metadata) {
  return (target, targetKey, indexOrPropertyDescriptor) => {
    tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
  };
}
function injectBase(metadataKey) {
  return serviceIdentifier => (target, targetKey, indexOrPropertyDescriptor) => createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
}

const inject = injectBase(INJECT_TAG);

const multiInject = injectBase(MULTI_INJECT_TAG);

function injectable() {
  return function (target) {
    return Reflect$1.defineMetadata(PARAM_TYPES, null, target), target;
  };
}

function named(name) {
  return createTaggedDecorator(new Metadata(NAMED_TAG, name));
}

const BindingScopeEnum = {
    Singleton: "Singleton",
    Transient: "Transient"
  },
  BindingTypeEnum = {
    ConstantValue: "ConstantValue",
    Constructor: "Constructor",
    DynamicValue: "DynamicValue",
    Factory: "Factory",
    Function: "Function",
    Instance: "Instance",
    Invalid: "Invalid",
    Provider: "Provider"
  };

class Binding {
  constructor(serviceIdentifier, scope) {
    this.id = Generator.GenAutoIncrementId(), this.activated = !1, this.serviceIdentifier = serviceIdentifier, this.scope = scope, this.type = BindingTypeEnum.Invalid, this.constraint = request => !0, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.dynamicValue = null;
  }
  clone() {
    const clone = new Binding(this.serviceIdentifier, this.scope);
    return clone.activated = clone.scope === BindingScopeEnum.Singleton && this.activated, clone.implementationType = this.implementationType, clone.dynamicValue = this.dynamicValue, clone.scope = this.scope, clone.type = this.type, clone.provider = this.provider, clone.constraint = this.constraint, clone.cache = this.cache, clone;
  }
}

class MetadataReader {
  getConstructorMetadata(constructorFunc) {
    return {
      compilerGeneratedMetadata: Reflect$1.getMetadata(PARAM_TYPES, constructorFunc),
      userGeneratedMetadata: Reflect$1.getMetadata(TAGGED, constructorFunc) || {}
    };
  }
  getPropertiesMetadata(constructorFunc) {
    throw new Error("暂未实现");
  }
}

const taggedConstraint = key => value => {
  const constraint = request => {
    if (null == request) return !1;
    if (request.key === key && request.value === value) return !0;
    if (null == request.constructorArgsMetadata) return !1;
    const constructorArgsMetadata = request.constructorArgsMetadata;
    for (let i = 0; i < constructorArgsMetadata.length; i++) if (constructorArgsMetadata[i].key === key && constructorArgsMetadata[i].value === value) return !0;
    return !1;
  };
  return constraint.metaData = new Metadata(key, value), constraint;
};
const namedConstraint = taggedConstraint(NAMED_TAG);

class BindingInSyntax {
  constructor(binding) {
    this._binding = binding;
  }
  inRequestScope() {
    throw new Error("暂未实现");
  }
  inSingletonScope() {
    return this._binding.scope = BindingScopeEnum.Singleton, this;
  }
  inTransientScope() {
    return this._binding.scope = BindingScopeEnum.Transient, this;
  }
  whenTargetNamed(name) {
    return this._binding.constraint = namedConstraint(name), this;
  }
}

class BindingToSyntax {
  constructor(binding) {
    this._binding = binding;
  }
  to(constructor) {
    return this._binding.type = BindingTypeEnum.Instance, this._binding.implementationType = constructor, new BindingInSyntax(this._binding);
  }
  toSelf() {
    const self = this._binding.serviceIdentifier;
    return this.to(self);
  }
  toDynamicValue(func) {
    return this._binding.type = BindingTypeEnum.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = func, this._binding.implementationType = null, new BindingInSyntax(this._binding);
  }
  toConstantValue(value) {
    return this._binding.type = BindingTypeEnum.ConstantValue, this._binding.cache = value, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
  }
  toFactory(factory) {
    return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = factory, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
  }
  toService(service) {
    this.toDynamicValue(context => context.container.get(service));
  }
}

class Container {
  constructor(containerOptions) {
    const options = containerOptions || {};
    options.defaultScope = options.defaultScope || BindingScopeEnum.Transient, this.options = options, this.id = Generator.GenAutoIncrementId(), this._bindingDictionary = new Map(), this._metadataReader = new MetadataReader();
  }
  load(module) {
    const containerModuleHelpers = this._getContainerModuleHelpersFactory()(module.id);
    module.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
  }
  get(serviceIdentifier) {
    const getArgs = this._getNotAllArgs(serviceIdentifier, !1);
    return this._get(getArgs);
  }
  getAll(serviceIdentifier) {
    const getArgs = this._getAllArgs(serviceIdentifier);
    return this._get(getArgs);
  }
  getTagged(serviceIdentifier, key, value) {
    const getArgs = this._getNotAllArgs(serviceIdentifier, !1, key, value);
    return this._get(getArgs);
  }
  getNamed(serviceIdentifier, named) {
    return this.getTagged(serviceIdentifier, NAMED_TAG, named);
  }
  isBound(serviceIdentifier) {
    return this._bindingDictionary.has(serviceIdentifier);
  }
  bind(serviceIdentifier) {
    const scope = this.options.defaultScope,
      binding = new Binding(serviceIdentifier, scope),
      list = this._bindingDictionary.get(serviceIdentifier) || [];
    return list.push(binding), this._bindingDictionary.set(serviceIdentifier, list), new BindingToSyntax(binding);
  }
  unbind(serviceIdentifier) {
    this._bindingDictionary.delete(serviceIdentifier);
  }
  rebind(serviceIdentifier) {
    return this.unbind(serviceIdentifier), this.bind(serviceIdentifier);
  }
  _getContainerModuleHelpersFactory() {
    const setModuleId = (bindingToSyntax, moduleId) => {
        bindingToSyntax._binding.moduleId = moduleId;
      },
      getBindFunction = moduleId => serviceIdentifier => {
        const bindingToSyntax = this.bind(serviceIdentifier);
        return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
      },
      getUnbindFunction = () => serviceIdentifier => this.unbind(serviceIdentifier),
      getIsboundFunction = () => serviceIdentifier => this.isBound(serviceIdentifier),
      getRebindFunction = moduleId => serviceIdentifier => {
        const bindingToSyntax = this.rebind(serviceIdentifier);
        return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
      };
    return mId => ({
      bindFunction: getBindFunction(mId),
      isboundFunction: getIsboundFunction(),
      rebindFunction: getRebindFunction(mId),
      unbindFunction: getUnbindFunction(),
      unbindAsyncFunction: serviceIdentifier => null
    });
  }
  _getNotAllArgs(serviceIdentifier, isMultiInject, key, value) {
    return {
      avoidConstraints: !1,
      isMultiInject: isMultiInject,
      serviceIdentifier: serviceIdentifier,
      key: key,
      value: value
    };
  }
  _getAllArgs(serviceIdentifier) {
    return {
      avoidConstraints: !0,
      isMultiInject: !0,
      serviceIdentifier: serviceIdentifier
    };
  }
  _get(getArgs) {
    const result = [];
    return this._bindingDictionary.get(getArgs.serviceIdentifier).filter(b => b.constraint(getArgs)).forEach(binding => {
      result.push(this._resolveFromBinding(binding));
    }), getArgs.isMultiInject || 1 !== result.length ? result : result[0];
  }
  _getChildRequest(binding) {
    const constr = binding.implementationType,
      {
        userGeneratedMetadata: userGeneratedMetadata
      } = this._metadataReader.getConstructorMetadata(constr),
      keys = Object.keys(userGeneratedMetadata),
      arr = [];
    for (let i = 0; i < keys.length; i++) {
      const constructorArgsMetadata = userGeneratedMetadata[i],
        targetMetadataMap = {};
      constructorArgsMetadata.forEach(md => {
        targetMetadataMap[md.key] = md.value;
      });
      const metadata = {
          inject: targetMetadataMap[INJECT_TAG],
          multiInject: targetMetadataMap[MULTI_INJECT_TAG]
        },
        injectIdentifier = metadata.inject || metadata.multiInject,
        target = {
          serviceIdentifier: injectIdentifier,
          constructorArgsMetadata: constructorArgsMetadata
        },
        bindings = (this._bindingDictionary.get(injectIdentifier) || []).filter(b => b.constraint(target));
      if (bindings.length) {
        const request = {
          injectIdentifier: injectIdentifier,
          metadata: constructorArgsMetadata,
          bindings: bindings
        };
        arr.push(request);
      }
    }
    return arr;
  }
  _resolveFromBinding(binding) {
    const result = this._getResolvedFromBinding(binding);
    return this._saveToScope(binding, result), result;
  }
  _getResolvedFromBinding(binding) {
    let result;
    switch (binding.type) {
      case BindingTypeEnum.ConstantValue:
      case BindingTypeEnum.Function:
        result = binding.cache;
        break;
      case BindingTypeEnum.Instance:
        result = this._resolveInstance(binding, binding.implementationType);
        break;
      default:
        result = binding.dynamicValue({
          container: this
        });
    }
    return result;
  }
  _resolveInstance(binding, constr) {
    if (binding.activated) return binding.cache;
    const childRequests = this._getChildRequest(binding);
    return this._createInstance(constr, childRequests);
  }
  _createInstance(constr, childRequests) {
    if (childRequests.length) {
      return new constr(...this._resolveRequests(childRequests));
    }
    return new constr();
  }
  _resolveRequests(childRequests) {
    return childRequests.map(request => request.bindings.length > 1 ? request.bindings.map(binding => this._resolveFromBinding(binding)) : this._resolveFromBinding(request.bindings[0]));
  }
  _saveToScope(binding, result) {
    binding.scope === BindingScopeEnum.Singleton && (binding.cache = result, binding.activated = !0);
  }
}

const ContributionProvider = Symbol("ContributionProvider");
class ContributionProviderCache {
  constructor(serviceIdentifier, container) {
    this.serviceIdentifier = serviceIdentifier, this.container = container, ContributionStore.setStore(this.serviceIdentifier, this);
  }
  getContributions() {
    return this.caches || (this.caches = [], this.container && this.container.isBound(this.serviceIdentifier) && this.caches.push(...this.container.getAll(this.serviceIdentifier))), this.caches;
  }
  refresh() {
    this.caches && (this.caches.length = 0, this.container && this.container.isBound(this.serviceIdentifier) && this.caches.push(...this.container.getAll(this.serviceIdentifier)));
  }
}
function bindContributionProvider(bind, id) {
  bind(ContributionProvider).toDynamicValue(({
    container: container
  }) => new ContributionProviderCache(id, container)).inSingletonScope().whenTargetNamed(id);
}
function bindContributionProviderNoSingletonScope(bind, id) {
  bind(ContributionProvider).toDynamicValue(({
    container: container
  }) => new ContributionProviderCache(id, container)).whenTargetNamed(id);
}
class ContributionStore {
  static getStore(id) {
    return this.store.get(id);
  }
  static setStore(id, cache) {
    this.store.set(id, cache);
  }
  static refreshAllContributions() {
    this.store.forEach(cache => {
      cache.refresh();
    });
  }
}
ContributionStore.store = new Map();

class Hook {
  constructor(args, name) {
    this._args = args, this.name = name, this.taps = [];
  }
  tap(options, fn) {
    this._tap("sync", options, fn);
  }
  unTap(options, fn) {
    const name = "string" == typeof options ? options.trim() : options.name;
    name && (this.taps = this.taps.filter(tap => !(tap.name === name && (!fn || tap.fn === fn))));
  }
  _parseOptions(type, options, fn) {
    let _options;
    if ("string" == typeof options) _options = {
      name: options.trim()
    };else if ("object" != typeof options || null === options) throw new Error("Invalid tap options");
    if ("string" != typeof _options.name || "" === _options.name) throw new Error("Missing name for tap");
    return _options = Object.assign({
      type: type,
      fn: fn
    }, _options), _options;
  }
  _tap(type, options, fn) {
    this._insert(this._parseOptions(type, options, fn));
  }
  _insert(item) {
    let before;
    "string" == typeof item.before ? before = new Set([item.before]) : Array.isArray(item.before) && (before = new Set(item.before));
    let stage = 0;
    "number" == typeof item.stage && (stage = item.stage);
    let i = this.taps.length;
    for (; i > 0;) {
      i--;
      const x = this.taps[i];
      this.taps[i + 1] = x;
      const xStage = x.stage || 0;
      if (before) {
        if (before.has(x.name)) {
          before.delete(x.name);
          continue;
        }
        if (before.size > 0) continue;
      }
      if (!(xStage > stage)) {
        i++;
        break;
      }
    }
    this.taps[i] = item;
  }
}

class SyncHook extends Hook {
  call(...args) {
    this.taps.map(t => t.fn).forEach(cb => cb(...args));
  }
}

const EnvContribution = Symbol.for("EnvContribution");
const VGlobal = Symbol.for("VGlobal");
const DEFAULT_TEXT_FONT_FAMILY$1 = "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol";

class Application {}
const application = new Application();

let idx = 0;
class PerformanceRAF {
  constructor() {
    this.nextAnimationFrameCbs = new Map(), this._rafHandle = null, this.runAnimationFrame = time => {
      this._rafHandle = null;
      const cbs = this.nextAnimationFrameCbs;
      this.nextAnimationFrameCbs = new Map(), cbs.forEach(cb => cb(time));
    }, this.tryRunAnimationFrameNextFrame = () => {
      null === this._rafHandle && 0 !== this.nextAnimationFrameCbs.size && (this._rafHandle = application.global.getRequestAnimationFrame()(this.runAnimationFrame));
    };
  }
  addAnimationFrameCb(callback) {
    return this.nextAnimationFrameCbs.set(++idx, callback), this.tryRunAnimationFrameNextFrame(), idx;
  }
  removeAnimationFrameCb(index) {
    return !!this.nextAnimationFrameCbs.has(index) && (this.nextAnimationFrameCbs.delete(index), !0);
  }
}

class EventListenerManager {
  constructor() {
    this._listenerMap = new Map(), this._eventListenerTransformer = event => event;
  }
  setEventListenerTransformer(transformer) {
    this._eventListenerTransformer = transformer || (event => event);
  }
  addEventListener(type, listener, options) {
    if (!listener) return;
    const wrappedListener = event => {
      const transformedEvent = this._eventListenerTransformer(event);
      "function" == typeof listener ? listener(transformedEvent) : listener.handleEvent && listener.handleEvent(transformedEvent);
    };
    this._listenerMap.has(type) || this._listenerMap.set(type, new Map()), this._listenerMap.get(type).set(listener, wrappedListener), this._nativeAddEventListener(type, wrappedListener, options);
  }
  removeEventListener(type, listener, options) {
    var _a;
    if (!listener) return;
    const wrappedListener = null === (_a = this._listenerMap.get(type)) || void 0 === _a ? void 0 : _a.get(listener);
    wrappedListener && (this._nativeRemoveEventListener(type, wrappedListener, options), this._listenerMap.get(type).delete(listener), 0 === this._listenerMap.get(type).size && this._listenerMap.delete(type));
  }
  dispatchEvent(event) {
    return this._nativeDispatchEvent(event);
  }
  clearAllEventListeners() {
    this._listenerMap.forEach((listenersMap, type) => {
      listenersMap.forEach((wrappedListener, originalListener) => {
        this._nativeRemoveEventListener(type, wrappedListener, void 0);
      });
    }), this._listenerMap.clear();
  }
  _nativeAddEventListener(type, listener, options) {
    throw new Error("_nativeAddEventListener must be implemented by derived classes");
  }
  _nativeRemoveEventListener(type, listener, options) {
    throw new Error("_nativeRemoveEventListener must be implemented by derived classes");
  }
  _nativeDispatchEvent(event) {
    throw new Error("_nativeDispatchEvent must be implemented by derived classes");
  }
}

var __decorate$Q = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$G = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$A = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  },
  __awaiter$4 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        var value;
        result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        })).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
let DefaultGlobal = class extends EventListenerManager {
  get env() {
    return this._env;
  }
  get isImageAnonymous() {
    return this._isImageAnonymous;
  }
  set isImageAnonymous(isImageAnonymous) {
    this._isImageAnonymous = isImageAnonymous;
  }
  get devicePixelRatio() {
    return this._env || this.setEnv("browser"), this.envContribution.getDevicePixelRatio();
  }
  get supportEvent() {
    return this._env || this.setEnv("browser"), this.envContribution.supportEvent;
  }
  set supportEvent(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportEvent = support;
  }
  get supportsTouchEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents;
  }
  set supportsTouchEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents = support;
  }
  get supportsPointerEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents;
  }
  set supportsPointerEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents = support;
  }
  get supportsMouseEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents;
  }
  set supportsMouseEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents = support;
  }
  get applyStyles() {
    return this._env || this.setEnv("browser"), this.envContribution.applyStyles;
  }
  set applyStyles(support) {
    this._env || this.setEnv("browser"), this.envContribution.applyStyles = support;
  }
  constructor(contributions) {
    super(), this.contributions = contributions, this._isImageAnonymous = !0, this._performanceRAFList = [], this.eventListenerTransformer = event => event, this.id = Generator.GenAutoIncrementId(), this.hooks = {
      onSetEnv: new SyncHook(["lastEnv", "env", "global"])
    }, this.measureTextMethod = "native", this.optimizeVisible = !1;
  }
  _nativeAddEventListener(type, listener, options) {
    return this._env || this.setEnv("browser"), this.envContribution.addEventListener(type, listener, options);
  }
  _nativeRemoveEventListener(type, listener, options) {
    return this._env || this.setEnv("browser"), this.envContribution.removeEventListener(type, listener, options);
  }
  _nativeDispatchEvent(event) {
    return this._env || this.setEnv("browser"), this.envContribution.dispatchEvent(event);
  }
  bindContribution(params) {
    const promiseArr = [];
    if (this.contributions.getContributions().forEach(contribution => {
      const data = contribution.configure(this, params);
      data && data.then && promiseArr.push(data);
    }), promiseArr.length) return Promise.all(promiseArr);
  }
  getDynamicCanvasCount() {
    return this._env || this.setEnv("browser"), this.envContribution.getDynamicCanvasCount();
  }
  getStaticCanvasCount() {
    return this._env || this.setEnv("browser"), this.envContribution.getStaticCanvasCount();
  }
  setEnv(env, params) {
    if (params && !0 === params.force || this._env !== env) return this.deactiveCurrentEnv(), this.activeEnv(env, params);
  }
  deactiveCurrentEnv() {
    this.envContribution && this.envContribution.release();
  }
  activeEnv(env, params) {
    const lastEnv = this._env;
    this._env = env;
    const data = this.bindContribution(params);
    if (data && data.then) return data.then(() => {
      this.envParams = params, this.hooks.onSetEnv.call(lastEnv, env, this);
    });
    this.envParams = params, this.hooks.onSetEnv.call(lastEnv, env, this);
  }
  setActiveEnvContribution(contribution) {
    this.envContribution = contribution;
  }
  createCanvas(params) {
    return this._env || this.setEnv("browser"), this.envContribution.createCanvas(params);
  }
  createOffscreenCanvas(params) {
    return this._env || this.setEnv("browser"), this.envContribution.createOffscreenCanvas(params);
  }
  releaseCanvas(canvas) {
    return this._env || this.setEnv("browser"), this.envContribution.releaseCanvas(canvas);
  }
  getRequestAnimationFrame() {
    return this._env || this.setEnv("browser"), this.envContribution.getRequestAnimationFrame();
  }
  getSpecifiedRequestAnimationFrame(id) {
    this._env || this.setEnv("browser"), this._performanceRAFList[id] || (this._performanceRAFList[id] = new PerformanceRAF());
    const performanceRAF = this._performanceRAFList[id];
    return callback => performanceRAF.addAnimationFrameCb(callback);
  }
  getSpecifiedCancelAnimationFrame(id) {
    if (this._env || this.setEnv("browser"), !this._performanceRAFList[id]) return () => !1;
    const performanceRAF = this._performanceRAFList[id];
    return handle => performanceRAF.removeAnimationFrameCb(handle);
  }
  getCancelAnimationFrame() {
    return this._env || this.setEnv("browser"), this.envContribution.getCancelAnimationFrame();
  }
  getElementById(str) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementById ? this.envContribution.getElementById(str) : null;
  }
  getRootElement() {
    return this._env || this.setEnv("browser"), this.envContribution.getRootElement ? this.envContribution.getRootElement() : null;
  }
  getDocument() {
    return this._env || this.setEnv("browser"), this.envContribution.getDocument ? this.envContribution.getDocument() : null;
  }
  mapToCanvasPoint(event, domElement) {
    return this._env || this.setEnv("browser"), this.envContribution.mapToCanvasPoint ? this.envContribution.mapToCanvasPoint(event, domElement) : null;
  }
  loadImage(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadImage(url);
  }
  loadSvg(str) {
    return this._env || this.setEnv("browser"), this.envContribution.loadSvg(str);
  }
  loadJson(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadJson(url);
  }
  loadArrayBuffer(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadArrayBuffer(url);
  }
  loadBlob(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadBlob(url);
  }
  loadFont(name, source, descriptors) {
    return __awaiter$4(this, void 0, void 0, function* () {
      return this._env || this.setEnv("browser"), this.envContribution.loadFont(name, source, descriptors);
    });
  }
  isChrome() {
    return null != this._isChrome || (this._env || this.setEnv("browser"), this._isChrome = "browser" === this._env && navigator.userAgent.indexOf("Chrome") > -1), this._isChrome;
  }
  isSafari() {
    return null != this._isSafari || (this._env || this.setEnv("browser"), this._isSafari = "browser" === this._env && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)), this._isSafari;
  }
  getNativeAABBBounds(dom) {
    return this._env || this.setEnv("browser"), this.envContribution.getNativeAABBBounds(dom);
  }
  removeDom(dom) {
    return this._env || this.setEnv("browser"), this.envContribution.removeDom(dom);
  }
  createDom(params) {
    return this._env || this.setEnv("browser"), this.envContribution.createDom(params);
  }
  updateDom(dom, params) {
    return this._env || this.setEnv("browser"), this.envContribution.updateDom(dom, params);
  }
  getElementTop(dom, baseWindow = !1) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementTop(dom, baseWindow);
  }
  getElementLeft(dom, baseWindow = !1) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementLeft(dom, baseWindow);
  }
  getElementTopLeft(dom, baseWindow = !1) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementTopLeft(dom, baseWindow);
  }
  isMacOS() {
    return this._env || this.setEnv("browser"), this.envContribution.isMacOS();
  }
  copyToClipBoard(text) {
    return this._env || this.setEnv("browser"), this.envContribution.copyToClipBoard(text);
  }
};
DefaultGlobal = __decorate$Q([injectable(), __param$A(0, inject(ContributionProvider)), __param$A(0, named(EnvContribution)), __metadata$G("design:paramtypes", [Object])], DefaultGlobal);

var MeasureModeEnum;
!function (MeasureModeEnum) {
  MeasureModeEnum[MeasureModeEnum.estimate = 0] = "estimate", MeasureModeEnum[MeasureModeEnum.actualBounding = 1] = "actualBounding", MeasureModeEnum[MeasureModeEnum.fontBounding = 2] = "fontBounding";
}(MeasureModeEnum || (MeasureModeEnum = {}));

var AnimateMode;
!function (AnimateMode) {
  AnimateMode[AnimateMode.NORMAL = 0] = "NORMAL", AnimateMode[AnimateMode.SET_ATTR_IMMEDIATELY = 1] = "SET_ATTR_IMMEDIATELY";
}(AnimateMode || (AnimateMode = {}));

var STATUS$1;
!function (STATUS) {
  STATUS[STATUS.INITIAL = 0] = "INITIAL", STATUS[STATUS.RUNNING = 1] = "RUNNING", STATUS[STATUS.PAUSE = 2] = "PAUSE";
}(STATUS$1 || (STATUS$1 = {}));

var AnimateStepType;
!function (AnimateStepType) {
  AnimateStepType.wait = "wait", AnimateStepType.from = "from", AnimateStepType.to = "to", AnimateStepType.customAnimate = "customAnimate";
}(AnimateStepType || (AnimateStepType = {}));
var AnimateStatus;
!function (AnimateStatus) {
  AnimateStatus[AnimateStatus.INITIAL = 0] = "INITIAL", AnimateStatus[AnimateStatus.RUNNING = 1] = "RUNNING", AnimateStatus[AnimateStatus.PAUSED = 2] = "PAUSED", AnimateStatus[AnimateStatus.END = 3] = "END";
}(AnimateStatus || (AnimateStatus = {}));

const circleThreshold = tau - 1e-8;
class BoundsContext {
  constructor(bounds) {
    this.init(bounds);
  }
  init(bounds) {
    this.bounds = bounds;
  }
  arc(cx, cy, r, sa, ea, ccw) {
    if (Math.abs(ea - sa) > circleThreshold) return this.bounds.add(cx - r, cy - r), void this.bounds.add(cx + r, cy + r);
    let s,
      i,
      x,
      y,
      xmin = 1 / 0,
      xmax = -1 / 0,
      ymin = 1 / 0,
      ymax = -1 / 0;
    function update(a) {
      x = r * Math.cos(a), y = r * Math.sin(a), x < xmin && (xmin = x), x > xmax && (xmax = x), y < ymin && (ymin = y), y > ymax && (ymax = y);
    }
    if (update(sa), update(ea), ea !== sa) if ((sa %= tau) < 0 && (sa += tau), (ea %= tau) < 0 && (ea += tau), ea < sa && (ccw = !ccw, s = sa, sa = ea, ea = s), ccw) for (ea -= tau, s = sa - sa % halfPi$1, i = 0; i < 4 && s > ea; ++i, s -= halfPi$1) update(s);else for (s = sa - sa % halfPi$1 + halfPi$1, i = 0; i < 4 && s < ea; ++i, s += halfPi$1) update(s);
    this.bounds.add(cx + xmin, cy + ymin), this.bounds.add(cx + xmax, cy + ymax);
  }
  arcTo(x1, y1, x2, y2, radius) {
    this.bounds.add(x1, y1);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.bounds.add(cp1x, cp1y), this.bounds.add(cp2x, cp2y), this.bounds.add(x, y);
  }
  closePath() {}
  ellipse() {
    throw new Error("不支持ellipse");
  }
  lineTo(x, y) {
    this.bounds.add(x, y);
  }
  moveTo(x, y) {
    this.bounds.add(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this.bounds.add(cpx, cpy), this.bounds.add(x, y);
  }
  rect(x, y, w, h) {
    this.bounds.add(x, y), this.bounds.add(x + w, y + h);
  }
  clear() {
    this.bounds.clear();
  }
  release(...params) {}
}

class CurvePath {
  constructor() {
    this._curves = [], this.bounds = new AABBBounds();
  }
  get curves() {
    return this._curves;
  }
  getCurveLengths() {
    return this._curves.map(curve => curve.getLength());
  }
  getPointAt(t) {
    return {
      x: 0,
      y: 0
    };
  }
  getLength() {
    return 0;
  }
  getBounds() {
    return this.bounds;
  }
}

const rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi,
  commandLengths = {
    m: 2,
    l: 2,
    h: 1,
    v: 1,
    c: 6,
    s: 4,
    q: 4,
    t: 2,
    a: 7,
    M: 2,
    L: 2,
    H: 1,
    V: 1,
    C: 6,
    S: 4,
    Q: 4,
    T: 2,
    A: 7
  };
const enumCommandMap = {
  A: 0,
  AT: 1,
  C: 2,
  Z: 3,
  E: 4,
  L: 5,
  M: 6,
  Q: 7,
  R: 8
};
let currPath, coordsStr, commandChar, coordStr, coordNumber, standardCommandLen;
function parseSvgPath(str) {
  if (!str) return [];
  const paths = str.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
  if (null === paths) return [];
  let currCommandData, coordsStrArr;
  const result = [];
  for (let i = 0, len = paths.length; i < len; i++) if (currPath = paths[i], coordsStr = currPath.slice(1), commandChar = currPath[0], currCommandData = [commandChar], coordsStrArr = coordsStr.match(rePathCommand), null !== coordsStrArr) {
    for (let i = 0, len = coordsStrArr.length; i < len; i++) coordStr = coordsStrArr[i], coordNumber = parseFloat(coordStr), Number.isNaN(coordNumber) || currCommandData.push(coordNumber);
    if (standardCommandLen = commandLengths[commandChar], currCommandData.length - 1 > standardCommandLen) {
      let subCommand,
        bestCommandChar = commandChar;
      for (let i = 1, len = currCommandData.length; i < len; i += standardCommandLen) {
        subCommand = [bestCommandChar];
        for (let j = i, subLen = i + standardCommandLen; j < subLen; j++) subCommand.push(currCommandData[j]);
        result.push(subCommand), "m" === bestCommandChar ? bestCommandChar = "l" : "M" === bestCommandChar && (bestCommandChar = "L");
      }
    } else result.push(currCommandData);
  } else result.push(currCommandData);
  return result;
}

var UpdateTag;
!function (UpdateTag) {
  UpdateTag[UpdateTag.NONE = 0] = "NONE", UpdateTag[UpdateTag.UPDATE_BOUNDS = 1] = "UPDATE_BOUNDS", UpdateTag[UpdateTag.UPDATE_SHAPE = 2] = "UPDATE_SHAPE", UpdateTag[UpdateTag.CLEAR_SHAPE = 253] = "CLEAR_SHAPE", UpdateTag[UpdateTag.UPDATE_SHAPE_AND_BOUNDS = 3] = "UPDATE_SHAPE_AND_BOUNDS", UpdateTag[UpdateTag.INIT = 179] = "INIT", UpdateTag[UpdateTag.CLEAR_BOUNDS = 254] = "CLEAR_BOUNDS", UpdateTag[UpdateTag.UPDATE_GLOBAL_MATRIX = 32] = "UPDATE_GLOBAL_MATRIX", UpdateTag[UpdateTag.CLEAR_GLOBAL_MATRIX = 223] = "CLEAR_GLOBAL_MATRIX", UpdateTag[UpdateTag.UPDATE_LOCAL_MATRIX = 16] = "UPDATE_LOCAL_MATRIX", UpdateTag[UpdateTag.CLEAR_LOCAL_MATRIX = 239] = "CLEAR_LOCAL_MATRIX", UpdateTag[UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX = 48] = "UPDATE_GLOBAL_LOCAL_MATRIX", UpdateTag[UpdateTag.UPDATE_LAYOUT = 128] = "UPDATE_LAYOUT", UpdateTag[UpdateTag.CLEAR_LAYOUT = 127] = "CLEAR_LAYOUT";
}(UpdateTag || (UpdateTag = {}));
var IContainPointMode;
!function (IContainPointMode) {
  IContainPointMode[IContainPointMode.GLOBAL = 1] = "GLOBAL", IContainPointMode[IContainPointMode.LOCAL = 16] = "LOCAL", IContainPointMode[IContainPointMode.GLOBAL_ACCURATE = 3] = "GLOBAL_ACCURATE", IContainPointMode[IContainPointMode.LOCAL_ACCURATE = 48] = "LOCAL_ACCURATE";
}(IContainPointMode || (IContainPointMode = {}));
var AttributeUpdateType;
!function (AttributeUpdateType) {
  AttributeUpdateType[AttributeUpdateType.INIT = 0] = "INIT", AttributeUpdateType[AttributeUpdateType.DEFAULT = 1] = "DEFAULT", AttributeUpdateType[AttributeUpdateType.STATE = 2] = "STATE", AttributeUpdateType[AttributeUpdateType.ANIMATE_BIND = 10] = "ANIMATE_BIND", AttributeUpdateType[AttributeUpdateType.ANIMATE_PLAY = 11] = "ANIMATE_PLAY", AttributeUpdateType[AttributeUpdateType.ANIMATE_START = 12] = "ANIMATE_START", AttributeUpdateType[AttributeUpdateType.ANIMATE_UPDATE = 13] = "ANIMATE_UPDATE", AttributeUpdateType[AttributeUpdateType.ANIMATE_END = 14] = "ANIMATE_END", AttributeUpdateType[AttributeUpdateType.TRANSLATE = 20] = "TRANSLATE", AttributeUpdateType[AttributeUpdateType.TRANSLATE_TO = 21] = "TRANSLATE_TO", AttributeUpdateType[AttributeUpdateType.SCALE = 22] = "SCALE", AttributeUpdateType[AttributeUpdateType.SCALE_TO = 23] = "SCALE_TO", AttributeUpdateType[AttributeUpdateType.ROTATE = 24] = "ROTATE", AttributeUpdateType[AttributeUpdateType.ROTATE_TO = 25] = "ROTATE_TO";
}(AttributeUpdateType || (AttributeUpdateType = {}));
var Direction;
!function (Direction) {
  Direction[Direction.ROW = 1] = "ROW", Direction[Direction.COLUMN = 2] = "COLUMN";
}(Direction || (Direction = {}));
var CurveTypeEnum;
!function (CurveTypeEnum) {
  CurveTypeEnum[CurveTypeEnum.CubicBezierCurve = 0] = "CubicBezierCurve", CurveTypeEnum[CurveTypeEnum.QuadraticBezierCurve = 1] = "QuadraticBezierCurve", CurveTypeEnum[CurveTypeEnum.ArcCurve = 2] = "ArcCurve", CurveTypeEnum[CurveTypeEnum.LineCurve = 3] = "LineCurve", CurveTypeEnum[CurveTypeEnum.EllipseCurve = 4] = "EllipseCurve", CurveTypeEnum[CurveTypeEnum.MoveCurve = 5] = "MoveCurve";
}(CurveTypeEnum || (CurveTypeEnum = {}));
var BaseRenderContributionTime;
!function (BaseRenderContributionTime) {
  BaseRenderContributionTime[BaseRenderContributionTime.beforeFillStroke = 0] = "beforeFillStroke", BaseRenderContributionTime[BaseRenderContributionTime.afterFillStroke = 1] = "afterFillStroke";
}(BaseRenderContributionTime || (BaseRenderContributionTime = {}));

function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
  const th = degreeToRadian(rotateX),
    sin_th = Math.sin(th),
    cos_th = Math.cos(th),
    px = cos_th * (ox - x) * .5 + sin_th * (oy - y) * .5,
    py = cos_th * (oy - y) * .5 - sin_th * (ox - x) * .5;
  let pl = px * px / ((rx = Math.abs(rx)) * rx) + py * py / ((ry = Math.abs(ry)) * ry);
  pl > 1 && (pl = Math.sqrt(pl), rx *= pl, ry *= pl);
  const a00 = cos_th / rx,
    a01 = sin_th / rx,
    a10 = -sin_th / ry,
    a11 = cos_th / ry,
    x0 = a00 * ox + a01 * oy,
    y0 = a10 * ox + a11 * oy,
    x1 = a00 * x + a01 * y,
    y1 = a10 * x + a11 * y;
  let sfactor_sq = 1 / ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) - .25;
  sfactor_sq < 0 && (sfactor_sq = 0);
  let sfactor = Math.sqrt(sfactor_sq);
  sweep === large && (sfactor = -sfactor);
  const xc = .5 * (x0 + x1) - sfactor * (y1 - y0),
    yc = .5 * (y0 + y1) + sfactor * (x1 - x0),
    th0 = Math.atan2(y0 - yc, x0 - xc);
  let th_arc = Math.atan2(y1 - yc, x1 - xc) - th0;
  th_arc < 0 && 1 === sweep ? th_arc += tau : th_arc > 0 && 0 === sweep && (th_arc -= tau);
  const segs = Math.ceil(Math.abs(th_arc / (halfPi$1 + .001))),
    result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs,
      th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return result;
}
function bezier(params) {
  const cx = params[0],
    cy = params[1],
    th0 = params[2],
    th1 = params[3],
    rx = params[4],
    ry = params[5],
    sin_th = params[6],
    cos_th = params[7],
    a00 = cos_th * rx,
    a01 = -sin_th * ry,
    a10 = sin_th * rx,
    a11 = cos_th * ry,
    cos_th0 = Math.cos(th0),
    sin_th0 = Math.sin(th0),
    cos_th1 = Math.cos(th1),
    sin_th1 = Math.sin(th1),
    th_half = .5 * (th1 - th0),
    sin_th_h2 = Math.sin(.5 * th_half),
    t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half),
    x1 = cx + cos_th0 - t * sin_th0,
    y1 = cy + sin_th0 + t * cos_th0,
    x3 = cx + cos_th1,
    y3 = cy + sin_th1,
    x2 = x3 + t * sin_th1,
    y2 = y3 - t * cos_th1;
  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}
function drawArc(context, x, y, coords) {
  const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x, y);
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
const addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry, counterclockwise = !1) => {
  const PI2 = 2 * Math.PI,
    sAngle = (startAngle % PI2 + PI2) % PI2;
  let deltaAngle,
    eAngle = (endAngle % PI2 + PI2) % PI2;
  counterclockwise ? (eAngle >= sAngle && (eAngle -= PI2), deltaAngle = eAngle - sAngle) : (eAngle <= sAngle && (eAngle += PI2), deltaAngle = eAngle - sAngle);
  const count = Math.ceil(Math.abs(deltaAngle) / (.5 * Math.PI)),
    stepAngle = deltaAngle / count;
  for (let i = 0; i < count; i++) {
    const sa = sAngle + stepAngle * i,
      ea = sAngle + stepAngle * (i + 1),
      len = 4 / 3 * Math.tan(Math.abs(stepAngle) / 4),
      c1 = Math.cos(sa),
      s1 = Math.sin(sa),
      c2 = Math.cos(ea),
      s2 = Math.sin(ea),
      x1 = c1 * rx + cx,
      y1 = s1 * ry + cy,
      x4 = c2 * rx + cx,
      y4 = s2 * ry + cy,
      sign = counterclockwise ? -1 : 1,
      hx = rx * len * sign,
      hy = ry * len * sign;
    bezierPath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
  }
};

const commandFuncs = [(command, context, x, y, sx, sy, z) => context.arc(command[1] * sx + x, command[2] * sy + y, command[3] * (sx + sy) / 2, command[4], command[5], command[6], z), (command, context, x, y, sx, sy, z) => context.arcTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * (sx + sy) / 2, z), (command, context, x, y, sx, sy, z) => context.bezierCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * sx + x, command[6] * sy + y, z), (command, context, x, y) => context.closePath(), (command, context, x, y, sx, sy) => context.ellipse(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]), (command, context, x, y, sx, sy, z) => context.lineTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.moveTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.quadraticCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, z), (command, context, x, y, sx, sy, z) => context.rect(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, z)];
function renderCommandList(commandList, context, x = 0, y = 0, sx = 1, sy = 1, z) {
  for (let i = 0; i < commandList.length; i++) {
    const command = commandList[i];
    commandFuncs[command[0]](command, context, x, y, sx, sy, z);
  }
}

class Curve {
  getLength(direction) {
    return null != direction ? this.calcProjLength(direction) : (Number.isFinite(this.length) || (this.length = this.calcLength()), this.length);
  }
}

function snapLength(xArr, yArr) {
  let totalLength = 0;
  const count = xArr.length;
  for (let i = 0; i < count; i++) {
    const x = xArr[i],
      y = yArr[i],
      nextX = xArr[(i + 1) % count],
      nextY = yArr[(i + 1) % count];
    totalLength += PointService.distanceNN(x, y, nextX, nextY);
  }
  return totalLength / 2;
}
function cubicLength(p0, p1, p2, p3, iterationCount) {
  return snapLength([p0.x, p1.x, p2.x, p3.x], [p0.y, p1.y, p2.y, p3.y]);
}
function cubicCalc(p0, p1, p2, p3, t) {
  const one = 1 - t;
  return one * one * one * p0 + 3 * p1 * t * one * one + 3 * p2 * t * t * one + p3 * t * t * t;
}
function cubicPointAt(p0, p1, p2, p3, t) {
  const x = cubicCalc(p0.x, p1.x, p2.x, p3.x, t),
    y = cubicCalc(p0.y, p1.y, p2.y, p3.y, t);
  return new Point(x, y);
}
function quadCalc(p0, p1, p2, t) {
  const one = 1 - t;
  return one * one * p0 + 2 * one * t * p1 + t * t * p2;
}
function quadPointAt(p0, p1, p2, t) {
  const x = quadCalc(p0.x, p1.x, p2.x, t),
    y = quadCalc(p0.y, p1.y, p2.y, t);
  return new Point(x, y);
}
function quadLength(p0, p1, p2, iterationCount) {
  return snapLength([p0.x, p1.x, p2.x], [p0.y, p1.y, p2.y]);
}

function divideCubic(curve, t) {
  const {
      p0: p0,
      p1: p1,
      p2: p2,
      p3: p3
    } = curve,
    pt = cubicPointAt(p0, p1, p2, p3, t),
    c1 = PointService.pointAtPP(p0, p1, t),
    c2 = PointService.pointAtPP(p1, p2, t),
    c3 = PointService.pointAtPP(p2, p3, t),
    c12 = PointService.pointAtPP(c1, c2, t),
    c23 = PointService.pointAtPP(c2, c3, t);
  return [new CubicBezierCurve(p0, c1, c12, pt), new CubicBezierCurve(pt, c23, c3, p3)];
}
class CubicBezierCurve extends Curve {
  constructor(p0, p1, p2, p3) {
    super(), this.type = CurveTypeEnum.CubicBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2, this.p3 = p3;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
  }
  getPointAt(t) {
    if (!1 !== this.defined) return cubicPointAt(this.p0, this.p1, this.p2, this.p3, t);
    throw new Error("defined为false的点不能getPointAt");
  }
  calcLength() {
    return this._validPoint() ? cubicLength(this.p0, this.p1, this.p2, this.p3) : 60;
  }
  calcProjLength(direction) {
    return direction === Direction.ROW ? abs(this.p0.x - this.p3.x) : direction === Direction.COLUMN ? abs(this.p0.y - this.p3.y) : 0;
  }
  getAngleAt(t) {
    const minT = max(t - .01, 0),
      maxT = min(t + .01, 1),
      minP = this.getPointAt(minT),
      maxP = this.getPointAt(maxT);
    return atan2(maxP.y - minP.y, maxP.x - minP.x);
  }
  draw(path, x, y, sx, sy, percent) {
    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.bezierCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y, this.p3.x * sx + x, this.p3.y * sy + y);else if (percent > 0) {
      const [curve1] = divideCubic(this, percent);
      path.bezierCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y, curve1.p3.x * sx + x, curve1.p3.y * sy + y);
    }
  }
  includeX(x) {
    const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x),
      maxX = max(this.p0.x, this.p1.x, this.p2.x, this.p3.x);
    return x >= minX && x <= maxX;
  }
  getYAt(x) {
    const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x),
      t = (x - minX) / (max(this.p0.x, this.p1.x, this.p2.x, this.p3.x) - minX);
    return this.getPointAt(t).y;
  }
}

function divideLinear(curve, t) {
  const {
      p0: p0,
      p1: p1
    } = curve,
    c1 = PointService.pointAtPP(p0, p1, t);
  return [new LineCurve(p0, c1), new LineCurve(c1, p1)];
}
class LineCurve extends Curve {
  constructor(p0, p1) {
    super(), this.type = CurveTypeEnum.LineCurve, this.p0 = p0, this.p1 = p1;
  }
  getPointAt(t) {
    if (!1 !== this.defined) return PointService.pointAtPP(this.p0, this.p1, t);
    throw new Error("defined为false的点不能getPointAt");
  }
  getAngleAt(t) {
    return null == this.angle && (this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), this.angle;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
  }
  calcLength() {
    return this._validPoint() ? PointService.distancePP(this.p0, this.p1) : 60;
  }
  calcProjLength(direction) {
    return direction === Direction.ROW ? abs(this.p0.x - this.p1.x) : direction === Direction.COLUMN ? abs(this.p0.y - this.p1.y) : 0;
  }
  draw(path, x, y, sx, sy, percent) {
    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.lineTo(this.p1.x * sx + x, this.p1.y * sy + y);else if (percent > 0) {
      const p = this.getPointAt(percent);
      path.lineTo(p.x * sx + x, p.y * sy + y);
    }
  }
  includeX(x) {
    return x >= this.p0.x && x <= this.p1.x || x >= this.p1.x && x <= this.p0.x;
  }
  getYAt(x) {
    if (this.includeX(x)) {
      let minP = this.p0,
        maxP = this.p1;
      this.p0.x > this.p1.x && (minP = this.p1, maxP = this.p0);
      const percent = (x - minP.x) / (maxP.x - minP.x);
      return minP.y + percent * (maxP.y - minP.y);
    }
    return 1 / 0;
  }
}

class SegContext {
  get endX() {
    return this._lastX;
  }
  get endY() {
    return this._lastY;
  }
  constructor(curveType, direction) {
    this.init(curveType, direction);
  }
  init(curveType, direction) {
    this._lastX = this._lastY = this._startX = this._startY = 0, this.curveType = curveType, this.direction = direction, this.curves = [];
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
    const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
    curve.originP1 = this._lastOriginP, curve.originP2 = p, curve.defined = defined, this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
  }
  closePath() {
    if (this.curves.length < 2) return;
    const lastCurve = this.curves[this.curves.length - 1];
    this.lineTo(this._startX, this._startY, lastCurve.defined, this._startOriginP);
  }
  ellipse() {
    throw new Error("SegContext不支持调用ellipse");
  }
  lineTo(x, y, defined, p) {
    const curve = this.addLinearCurve(x, y, defined, this._lastOriginP, p);
    this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
  }
  moveTo(x, y, p) {
    return this._lastX = this._startX = x, this._lastY = this._startY = y, this._lastOriginP = p, this._startOriginP = p, this;
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    throw new Error("SegContext不支持调用quadraticCurveTo");
  }
  clear() {
    this.curves = [], this.length = NaN;
  }
  tryUpdateLength(direction) {
    return this.getLength(direction);
  }
  addLinearCurve(x, y, defined, p1, p2) {
    const curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
    return curve.originP1 = p1, curve.originP2 = p2, curve.defined = defined, curve;
  }
  getPointAt(t) {
    throw new Error("暂未实现");
  }
  getCurveLengths() {
    return [];
  }
  getLength(direction) {
    var _a, _b;
    if (direction === Direction.COLUMN) {
      if (!this.curves.length) return 0;
      const sc = this.curves[0],
        ec = this.curves[this.curves.length - 1],
        endP = null !== (_a = ec.p3) && void 0 !== _a ? _a : ec.p1;
      return abs(sc.p0.y - endP.y);
    }
    if (direction === Direction.ROW) {
      if (!this.curves.length) return 0;
      const sc = this.curves[0],
        ec = this.curves[this.curves.length - 1],
        endP = null !== (_b = ec.p3) && void 0 !== _b ? _b : ec.p1;
      return abs(sc.p0.x - endP.x);
    }
    return Number.isFinite(this.length) || (this.length = this.curves.reduce((l, c) => l + c.getLength(), 0)), this.length;
  }
}
class ReflectSegContext extends SegContext {
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
    return super.bezierCurveTo(cp1y, cp1x, cp2y, cp2x, y, x, defined, p);
  }
  lineTo(x, y, defined, p) {
    return super.lineTo(y, x, defined, p);
  }
  moveTo(x, y, p) {
    return super.moveTo(y, x, p);
  }
  clear() {
    return super.clear();
  }
}

function genCurveSegments(path, points, step = 1) {
  let defined0 = !1;
  for (let i = 0, n = points.length; i <= n; i++) i >= n === defined0 && ((defined0 = !defined0) ? path.lineStart() : path.lineEnd()), defined0 && path.point(points[i]);
}
function genSegContext(curveType, direction, points) {
  const curveDirection = null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN;
  return "monotoneY" === curveType ? new ReflectSegContext(curveType, curveDirection) : new SegContext(curveType, curveDirection);
}

class Linear {
  constructor(context, startPoint) {
    this.context = context, startPoint && (this.startPoint = startPoint);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const x = p.x,
      y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
      default:
        this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p);
    }
    this._lastDefined = p.defined;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function genLinearSegments(points, params = {}) {
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = genSegContext("linear", direction, points);
  return genLinearTypeSegments(new Linear(segContext, startPoint), points), segContext;
}
function genLinearTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}

function point$3(curveClass, x, y, defined, p) {
  curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x) / 6, (curveClass._y0 + 4 * curveClass._y1 + y) / 6, defined, curveClass.lastPoint1);
}
class Basis {
  constructor(context, startPoint) {
    this.context = context, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    if (2 === this._point) point$3(this, 6 * this._x1 - (this._x0 + 4 * this._x1), 6 * this._y1 - (this._y0 + 4 * this._y1), !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const x = p.x,
      y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
        break;
      default:
        point$3(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
    }
    this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function genBasisTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genBasisSegments(points, params = {}) {
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
  const segContext = genSegContext("basis", direction, points);
  return genBasisTypeSegments(new Basis(segContext, startPoint), points), segContext;
}

function sign(x) {
  return x < 0 ? -1 : 1;
}
function slope3(curveClass, x2, y2) {
  const h0 = curveClass._x1 - curveClass._x0,
    h1 = x2 - curveClass._x1,
    s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0)),
    s1 = (y2 - curveClass._y1) / (h1 || Number(h0 < 0 && -0)),
    p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), .5 * Math.abs(p)) || 0;
}
function slope2(curveClass, t) {
  const h = curveClass._x1 - curveClass._x0;
  return h ? (3 * (curveClass._y1 - curveClass._y0) / h - t) / 2 : t;
}
function point$2(curveClass, t0, t1, defined, p) {
  const x0 = curveClass._x0,
    y0 = curveClass._y0,
    x1 = curveClass._x1,
    y1 = curveClass._y1,
    dx = (x1 - x0) / 3;
  curveClass.context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1, defined, curveClass.lastPoint1);
}
class MonotoneX {
  constructor(context, startPoint) {
    this.context = context, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(this._x1, this._y1, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
        break;
      case 3:
        point$2(this, this._t0, slope2(this, this._t0), !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
    }
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    let t1 = NaN;
    const x = p.x,
      y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, point$2(this, slope2(this, t1 = slope3(this, x, y)), t1, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
        break;
      default:
        point$2(this, this._t0, t1 = slope3(this, x, y), !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
    }
    this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._t0 = t1, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = !1 !== p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
class MonotoneY extends MonotoneX {
  constructor(context, startPoint) {
    super(context, startPoint);
  }
  point(p) {
    return super.point({
      y: p.x,
      x: p.y,
      defined: p.defined
    });
  }
}
function genMonotoneXTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genMonotoneXSegments(points, params = {}) {
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
  const segContext = genSegContext("monotoneX", direction, points);
  return genMonotoneXTypeSegments(new MonotoneX(segContext, startPoint), points), segContext;
}
function genMonotoneYTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genMonotoneYSegments(points, params = {}) {
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
  const segContext = genSegContext("monotoneY", direction, points);
  return genMonotoneYTypeSegments(new MonotoneY(segContext, startPoint), points), segContext;
}

let Step$1 = class Step {
  constructor(context, t = .5, startPoint) {
    this.context = context, this._t = t, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, !1 !== this._lastDefined, this.lastPoint), (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  }
  point(p) {
    const x = p.x,
      y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
      default:
        if (this._t <= 0) this.context.lineTo(this._x, y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p);else {
          const x1 = this._x * (1 - this._t) + x * this._t;
          .5 === this._t ? this.context.lineTo(x1, this._y, !1 !== this._lastDefined, this.lastPoint) : this.context.lineTo(x1, this._y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), this.context.lineTo(x1, y, !1 !== this._lastDefined && !1 !== p.defined, p);
        }
    }
    this._lastDefined = p.defined, this._x = x, this._y = y, this.lastPoint = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
class StepClosed extends Step$1 {
  lineEnd() {
    this.context.closePath();
  }
}
function genStepSegments(points, t, params = {}) {
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN);
  return genStepTypeSegments(new Step$1(segContext, t, startPoint), points), segContext;
}
function genStepTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}
function genStepClosedSegments(points, t, params = {}) {
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN);
  return genStepTypeSegments(new StepClosed(segContext, t, startPoint), points), segContext;
}

class LinearClosed extends Linear {
  lineEnd() {
    this.context.closePath();
  }
}
function genLinearClosedSegments(points, params = {}) {
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = genSegContext("linear", direction, points);
  return genLinearClosedTypeSegments(new LinearClosed(segContext, startPoint), points), segContext;
}
function genLinearClosedTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}

function point$1(curveClass, x, y, defined, p) {
  let x1 = curveClass._x1,
    y1 = curveClass._y1,
    x2 = curveClass._x2,
    y2 = curveClass._y2;
  if (curveClass._l01_a > epsilon) {
    const a = 2 * curveClass._l01_2a + 3 * curveClass._l01_a * curveClass._l12_a + curveClass._l12_2a,
      n = 3 * curveClass._l01_a * (curveClass._l01_a + curveClass._l12_a);
    x1 = (x1 * a - curveClass._x0 * curveClass._l12_2a + curveClass._x2 * curveClass._l01_2a) / n, y1 = (y1 * a - curveClass._y0 * curveClass._l12_2a + curveClass._y2 * curveClass._l01_2a) / n;
  }
  if (curveClass._l23_a > epsilon) {
    const b = 2 * curveClass._l23_2a + 3 * curveClass._l23_a * curveClass._l12_a + curveClass._l12_2a,
      m = 3 * curveClass._l23_a * (curveClass._l23_a + curveClass._l12_a);
    x2 = (x2 * b + curveClass._x1 * curveClass._l23_2a - x * curveClass._l12_2a) / m, y2 = (y2 * b + curveClass._y1 * curveClass._l23_2a - y * curveClass._l12_2a) / m;
  }
  curveClass.context.bezierCurveTo(x1, y1, x2, y2, curveClass._x2, curveClass._y2, defined, curveClass.lastPoint1);
}
class CatmullRom {
  constructor(context, alpha = .5, startPoint) {
    this.context = context, this.startPoint = startPoint, this._alpha = alpha;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(this._x2, this._y2, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
        break;
      case 3:
        this.point({
          x: this._x2,
          y: this._y2
        });
    }
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const {
      x: x,
      y: y
    } = p;
    if (this._point) {
      const x23 = this._x2 - x,
        y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2) : this.context.moveTo(x, y);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point$1(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function commonGenCatmullRomSegments(type, cons) {
  return function (points, alpha, params = {}) {
    const {
      direction: direction,
      startPoint: startPoint
    } = params;
    if (points.length < 2 - Number(!!startPoint)) return null;
    if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
    const segContext = genSegContext(type, direction, points),
      gatmullRom = new cons(segContext, alpha, startPoint);
    return genCurveSegments(gatmullRom, points, 2), segContext;
  };
}
const genCatmullRomSegments = commonGenCatmullRomSegments("catmullRom", CatmullRom);

class CatmullRomClosed {
  constructor(context, alpha = .5, startPoint) {
    this.context = context, this.startPoint = startPoint, this._alpha = alpha;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 1:
        this.context.moveTo(this._x3, this._y3, this.lastPoint1), this.context.closePath();
        break;
      case 2:
        this.context.lineTo(this._x3, this._y3, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1), this.context.closePath();
        break;
      case 3:
        this.point({
          x: this._x3,
          y: this._y3
        }), this.point({
          x: this._x4,
          y: this._y4
        }), this.point({
          x: this._x5,
          y: this._y5
        });
    }
  }
  point(p) {
    const {
      x: x,
      y: y
    } = p;
    if (this._point) {
      const x23 = this._x2 - x,
        y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = x, this._y3 = y;
        break;
      case 1:
        this._point = 2, this.context.moveTo(this._x4 = x, this._y4 = y, p);
        break;
      case 2:
        this._point = 3, this._x5 = x, this._y5 = y;
        break;
      default:
        point$1(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
const genCatmullRomClosedSegments = commonGenCatmullRomSegments("catmullRomClosed", CatmullRomClosed);

function divideQuad(curve, t) {
  const {
      p0: p0,
      p1: p1,
      p2: p2
    } = curve,
    pt = quadPointAt(p0, p1, p2, t),
    c1 = PointService.pointAtPP(p0, p1, t),
    c2 = PointService.pointAtPP(p1, p2, t);
  return [new QuadraticBezierCurve(p0, c1, pt), new QuadraticBezierCurve(pt, c2, p2)];
}
class QuadraticBezierCurve extends Curve {
  constructor(p0, p1, p2) {
    super(), this.type = CurveTypeEnum.QuadraticBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y);
  }
  getPointAt(t) {
    if (!1 !== this.defined) return quadPointAt(this.p0, this.p1, this.p2, t);
    throw new Error("defined为false的点不能getPointAt");
  }
  calcLength() {
    return this._validPoint() ? quadLength(this.p0, this.p1, this.p2) : 60;
  }
  calcProjLength(direction) {
    return direction === Direction.ROW ? abs(this.p0.x - this.p2.x) : direction === Direction.COLUMN ? abs(this.p0.y - this.p2.y) : 0;
  }
  getAngleAt(t) {
    const minT = max(t - .01, 0),
      maxT = min(t + .01, 1),
      minP = this.getPointAt(minT),
      maxP = this.getPointAt(maxT);
    return atan2(maxP.y - minP.y, maxP.x - minP.x);
  }
  draw(path, x, y, sx, sy, percent) {
    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.quadraticCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y);else if (percent > 0) {
      const [curve1] = divideQuad(this, percent);
      path.quadraticCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y);
    }
  }
  getYAt(x) {
    throw new Error("QuadraticBezierCurve暂不支持getYAt");
  }
  includeX(x) {
    throw new Error("QuadraticBezierCurve暂不支持includeX");
  }
}

class CurveContext {
  constructor(path) {
    this.path = path, this._lastX = this._lastY = this._startX = this._startY = 0;
  }
  moveTo(x, y) {
    return this._lastX = this._startX = x, this._lastY = this._startY = y, this;
  }
  lineTo(x, y) {
    const curve = this.addLinearCurve(x, y);
    this.path.addCurve(curve), this._lastX = x, this._lastY = y;
  }
  addLinearCurve(x, y) {
    return new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(new Point(this._lastX, this._lastY), new Point(aCPx, aCPy), new Point(aX, aY));
    this.path.addCurve(curve), this._lastX = aX, this._lastY = aY;
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
    this.path.addCurve(curve), this._lastX = x, this._lastY = y;
  }
  arcTo(aX1, aY1, aX2, aY2, aRadius) {
    throw new Error("CurveContext不支持调用arcTo");
  }
  ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
    throw new Error("CurveContext不支持调用ellipse");
  }
  rect(x, y, w, h) {
    throw new Error("CurveContext不支持调用rect");
  }
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    throw new Error("CurveContext不支持调用arc");
  }
  closePath() {
    this.path.curves.length < 2 || this.lineTo(this._startX, this._startY);
  }
}

function calcLineCache(points, curveType, params) {
  var _a, _b;
  switch (curveType) {
    case "linear":
    default:
      return genLinearSegments(points, params);
    case "basis":
      return genBasisSegments(points, params);
    case "monotoneX":
      return genMonotoneXSegments(points, params);
    case "monotoneY":
      return genMonotoneYSegments(points, params);
    case "step":
      return genStepSegments(points, .5, params);
    case "stepClosed":
      return genStepClosedSegments(points, .5, params);
    case "stepBefore":
      return genStepSegments(points, 0, params);
    case "stepAfter":
      return genStepSegments(points, 1, params);
    case "catmullRom":
      return genCatmullRomSegments(points, null !== (_a = null == params ? void 0 : params.curveTension) && void 0 !== _a ? _a : .5, params);
    case "catmullRomClosed":
      return genCatmullRomClosedSegments(points, null !== (_b = null == params ? void 0 : params.curveTension) && void 0 !== _b ? _b : .5, params);
    case "linearClosed":
      return genLinearClosedSegments(points, params);
  }
}

class CustomPath2D extends CurvePath {
  constructor(ctx) {
    super(), this.commandList = [], ctx && (this._ctx = ctx), this._boundsContext = new BoundsContext(this.bounds);
  }
  get curves() {
    return this.tryBuildCurves();
  }
  setCtx(ctx) {
    this._ctx = ctx;
  }
  moveTo(x, y) {
    return this.commandList.push([enumCommandMap.M, x, y]), this._ctx && this._ctx.moveTo(x, y), this;
  }
  lineTo(x, y) {
    return this.commandList.push([enumCommandMap.L, x, y]), this._ctx && this._ctx.lineTo(x, y), this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    return this.commandList.push([enumCommandMap.Q, aCPx, aCPy, aX, aY]), this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY), this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    return this.commandList.push([enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]), this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY), this;
  }
  arcTo(aX1, aY1, aX2, aY2, aRadius) {
    return this.commandList.push([enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius]), this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius), this;
  }
  ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
    return this.commandList.push([enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise]), this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise), this;
  }
  rect(x, y, w, h) {
    return this.commandList.push([enumCommandMap.R, x, y, w, h]), this._ctx && this._ctx.rect(x, y, w, h), this;
  }
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    return this.commandList.push([enumCommandMap.A, x, y, radius, startAngle, endAngle, counterclockwise]), this._ctx && this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise), this;
  }
  closePath() {
    return this.commandList.push([enumCommandMap.Z]), this._ctx && this._ctx.closePath(), this;
  }
  addCurve(curve) {
    this._curves.push(curve);
  }
  clear() {
    this.transformCbList = null, this.commandList.length = 0, this._curves.length = 0;
  }
  beginPath() {
    this.clear();
  }
  tryBuildCurves() {
    if (!this._curves || !this._curves.length) {
      const curveContext = new CurveContext(this);
      renderCommandList(this.commandList, curveContext, 0, 0, 1, 1);
    }
    return this._curves;
  }
  toString() {
    if (!this.toStringCbList) {
      const list = [];
      list[enumCommandMap.M] = cmd => `M${cmd[1]} ${cmd[2]}`, list[enumCommandMap.L] = cmd => `L${cmd[1]} ${cmd[2]}`, list[enumCommandMap.Q] = cmd => `Q${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`, list[enumCommandMap.C] = cmd => `C${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]} ${cmd[5]} ${cmd[6]}`, list[enumCommandMap.A] = cmd => {
        const bezierPathList = [],
          x = cmd[1],
          y = cmd[2],
          radius = cmd[3],
          startAngle = cmd[4],
          endAngle = cmd[5],
          counterclockwise = cmd[6];
        addArcToBezierPath(bezierPathList, startAngle, endAngle, x, y, radius, radius, counterclockwise);
        let path = "";
        for (let i = 0; i < bezierPathList.length; i += 6) path += `C${bezierPathList[i]} ${bezierPathList[i + 1]} ${bezierPathList[i + 2]} ${bezierPathList[i + 3]} ${bezierPathList[i + 4]} ${bezierPathList[i + 5]}`;
        return path;
      }, list[enumCommandMap.R] = cmd => `M${cmd[1]} ${cmd[2]} h${cmd[3]} v${cmd[4]} H${cmd[1]}Z`, list[enumCommandMap.Z] = cmd => "Z", this.toStringCbList = list;
    }
    const list = this.toStringCbList;
    let path = "";
    return this.commandList.forEach(c => {
      path += list[c[0]](c);
    }), path;
  }
  fromString(str, x, y, sX, sY) {
    this.clear();
    const commandStrList = parseSvgPath(str);
    return this._runCommandStrList(commandStrList, x, y, sX, sY), this._updateBounds(), this;
  }
  fromLine(line) {
    const {
      points: points,
      curveType: curveType,
      clipRangeByDimension: clipRangeByDimension
    } = line.attribute;
    if (!points) return;
    const cache = calcLineCache(points, curveType);
    "x" === clipRangeByDimension ? this.direction = Direction.ROW : "y" === clipRangeByDimension ? this.direction = Direction.COLUMN : "auto" === clipRangeByDimension && (this.direction = cache.direction), this._curves = cache.curves;
  }
  fromCustomPath2D(path, x, y, sX, sY) {
    return this.clear(), this._runCommandList(path.commandList, x, y, sX, sY), this._updateBounds(), this;
  }
  transform(x, y, sx, sy) {
    const commandList = this.commandList;
    if (!this.transformCbList) {
      const list = [];
      list[enumCommandMap.M] = this.moveToTransform, list[enumCommandMap.L] = this.lineToTransform, list[enumCommandMap.Q] = this.quadraticCurveToTransform, list[enumCommandMap.C] = this.bezierCurveToTransform, list[enumCommandMap.AT] = this.arcToTransform, list[enumCommandMap.E] = this.ellipseTransform, list[enumCommandMap.R] = this.rectTransform, list[enumCommandMap.A] = this.arcTransform, list[enumCommandMap.Z] = this.closePathTransform, this.transformCbList = list;
    }
    commandList.forEach(cmd => {
      this.transformCbList[cmd[0]](cmd, x, y, sx, sy);
    }), this._updateBounds();
  }
  moveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
  }
  lineToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
  }
  quadraticCurveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y;
  }
  bezierCurveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * sx + x, cmd[6] = cmd[6] * sy + y;
  }
  arcToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * (sx + sy) / 2;
  }
  ellipseTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
  }
  rectTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
  }
  arcTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * (sx + sy) / 2;
  }
  closePathTransform() {}
  _runCommandStrList(commandStrList, l = 0, t = 0, sX = 1, sY = 1) {
    let current,
      tempX,
      tempY,
      tempControlX,
      tempControlY,
      previous = null,
      x = 0,
      y = 0,
      controlX = 0,
      controlY = 0;
    for (let i = 0, len = commandStrList.length; i < len; ++i) {
      switch (current = commandStrList[i], 1 === sX && 1 === sY || (current = scale$1(current, sX, sY)), current[0]) {
        case "l":
          x += current[1], y += current[2], this.lineTo(x + l, y + t);
          break;
        case "L":
          x = current[1], y = current[2], this.lineTo(x + l, y + t);
          break;
        case "h":
          x += current[1], this.lineTo(x + l, y + t);
          break;
        case "H":
          x = current[1], this.lineTo(x + l, y + t);
          break;
        case "v":
          y += current[1], this.lineTo(x + l, y + t);
          break;
        case "V":
          y = current[1], this.lineTo(x + l, y + t);
          break;
        case "m":
          x += current[1], y += current[2], this.moveTo(x + l, y + t);
          break;
        case "M":
          x = current[1], y = current[2], this.moveTo(x + l, y + t);
          break;
        case "c":
          tempX = x + current[5], tempY = y + current[6], controlX = x + current[3], controlY = y + current[4], this.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "C":
          x = current[5], y = current[6], controlX = current[3], controlY = current[4], this.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
          break;
        case "s":
          tempX = x + current[3], tempY = y + current[4], null === previous[0].match(/[CcSs]/) ? (controlX = x, controlY = y) : (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = x + current[1], tempControlY = y + current[2], this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t), controlX = tempControlX, controlY = tempControlY, x = tempX, y = tempY;
          break;
        case "S":
          tempX = current[3], tempY = current[4], null === previous[0].match(/[CcSs]/) ? (controlX = x, controlY = y) : (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = current[1], tempControlY = current[2], this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t), controlX = tempControlX, controlY = tempControlY, x = tempX, y = tempY;
          break;
        case "q":
          tempX = x + current[3], tempY = y + current[4], controlX = x + current[1], controlY = y + current[2], this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "Q":
          tempX = current[3], tempY = current[4], this.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = current[1], controlY = current[2];
          break;
        case "t":
          tempX = x + current[1], tempY = y + current[2], null === previous[0].match(/[QqTt]/) ? (controlX = x, controlY = y) : "t" === previous[0] ? (controlX = 2 * x - tempControlX, controlY = 2 * y - tempControlY) : "q" === previous[0] && (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = controlX, tempControlY = controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = x + current[1], controlY = y + current[2];
          break;
        case "T":
          tempX = current[1], tempY = current[2], controlX = 2 * x - controlX, controlY = 2 * y - controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "a":
          drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]), x += current[6], y += current[7];
          break;
        case "A":
          drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]), x = current[6], y = current[7];
          break;
        case "z":
        case "Z":
          this.closePath();
      }
      previous = current;
    }
  }
  _runCommandList(commandList, l = 0, t = 0, sX = 1, sY = 1) {
    if (0 !== l || 0 !== t || 1 !== sX || 1 !== sY) for (let i = 0, len = commandList.length; i < len; ++i) {
      const current = commandList[i].slice();
      switch (current[0]) {
        case enumCommandMap.L:
          this.lineToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.M:
          this.moveToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.C:
          this.bezierCurveToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.Q:
          this.quadraticCurveToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.A:
          this.arcToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.E:
          this.ellipseTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.R:
          this.rectTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.AT:
          this.arcToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.Z:
          this.closePath();
      }
    } else this.commandList = commandList.map(entry => entry.slice());
  }
  _updateBounds() {
    this.bounds.clear(), renderCommandList(this.commandList, this._boundsContext);
  }
  release() {
    this.commandList = [], this._boundsContext = null, this._ctx = null;
  }
  getLength() {
    if (this.direction === Direction.COLUMN) {
      if (!this._curves.length) return 0;
      const sc = this._curves[0],
        ec = this._curves[this._curves.length - 1];
      return abs(sc.p0.y - ec.p1.y);
    }
    if (this.direction === Direction.ROW) {
      if (!this._curves.length) return 0;
      const sc = this._curves[0],
        ec = this._curves[this._curves.length - 1];
      return abs(sc.p0.x - ec.p1.x);
    }
    return this._curves.reduce((l, c) => l + c.getLength(), 0);
  }
  getYAt(x) {
    if (!this.curves) return 1 / 0;
    for (let i = 0; i < this.curves.length; i++) {
      const curve = this.curves[i];
      if (curve.includeX(x)) return curve.getYAt(x);
    }
    return 1 / 0;
  }
  getAttrAt(distance) {
    if (!this._curves) return {
      pos: {
        x: 0,
        y: 0
      },
      angle: 0
    };
    let curve,
      _dis = 0;
    for (let i = 0; i < this._curves.length; i++) {
      curve = this._curves[i];
      const cl = curve.getLength(this.direction);
      if (_dis + cl >= distance) break;
      _dis += cl;
    }
    const t = (distance - _dis) / curve.getLength(this.direction);
    return {
      pos: curve.getPointAt(t),
      angle: curve.getAngleAt(t)
    };
  }
  drawWithClipRange(ctx, size, x, y, clipRange) {
    this.tryBuildCurves();
    const totalLen = this.getLength() * clipRange;
    let currLen = 0;
    for (let i = 0; i < this._curves.length; i++) {
      const curve = this._curves[i],
        cl = curve.getLength(this.direction);
      if (!(currLen + cl <= totalLen)) {
        const percent = 1 - (currLen + cl - totalLen) / cl;
        curve.draw(ctx, x, y, size, size, percent);
        break;
      }
      curve.draw(ctx, x, y, size, size, 1), currLen += cl;
    }
  }
}
const temp = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale$1(current, sX, sY) {
  const c = temp[0] = current[0];
  if ("a" === c || "A" === c) temp[1] = sX * current[1], temp[2] = sY * current[2], temp[3] = current[3], temp[4] = current[4], temp[5] = current[5], temp[6] = sX * current[6], temp[7] = sY * current[7];else if ("h" === c || "H" === c) temp[1] = sX * current[1];else if ("v" === c || "V" === c) temp[1] = sY * current[1];else for (let i = 1, n = current.length; i < n; ++i) temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
  return temp;
}

const DefaultLayout = {
  alignSelf: "auto"
};
const DefaultTransform = {
  x: 0,
  y: 0,
  z: 0,
  dx: 0,
  dy: 0,
  dz: 0,
  scrollX: 0,
  scrollY: 0,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  angle: 0,
  alpha: 0,
  beta: 0,
  scaleCenter: [0, 0],
  anchor: [0, 0],
  anchor3d: [0, 0],
  postMatrix: new Matrix()
};
const DefaultFillStyle = {
  fillOpacity: 1,
  fill: !1,
  shadowBlur: 0,
  shadowColor: "black",
  shadowOffsetX: 0,
  shadowOffsetY: 0
};
const commonStroke = {
  strokeOpacity: 1,
  lineDash: [],
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  lineJoin: "miter",
  miterLimit: 10,
  strokeBoundsBuffer: 2,
  stroke: !1
};
const DefaultStrokeStyle = Object.assign({
  outerBorder: Object.assign(Object.assign({}, commonStroke), {
    distance: 0
  }),
  innerBorder: Object.assign(Object.assign({}, commonStroke), {
    distance: 0
  })
}, commonStroke);
const DefaultTextStyle = {
  text: "",
  maxLineWidth: 1 / 0,
  maxWidth: 1 / 0,
  textAlign: "left",
  textBaseline: "alphabetic",
  fontSize: 16,
  fontFamily: "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
  fontWeight: "",
  ellipsis: "…",
  fontVariant: "",
  fontStyle: "",
  lineHeight: void 0,
  underline: 0,
  lineThrough: 0,
  scaleIn3d: !1,
  direction: "horizontal",
  wordBreak: "break-all",
  ignoreBuf: !1,
  verticalMode: 0,
  wrap: !1,
  whiteSpace: "no-wrap",
  heightLimit: 1 / 0,
  lineClamp: 1 / 0,
  suffixPosition: "end",
  underlineDash: [],
  underlineOffset: 0,
  disableAutoClipedPoptip: void 0,
  measureMode: MeasureModeEnum.fontBounding,
  keepCenterInLine: !1
};
const DefaultPickStyle = {
  pickStrokeBuffer: 0
};
const DefaultStyle = Object.assign(Object.assign(Object.assign(Object.assign({
  forceBoundsWidth: void 0,
  forceBoundsHeight: void 0,
  opacity: 1,
  background: null,
  autoAnimateTexture: !1,
  textureRatio: 1,
  textureOptions: null,
  backgroundOpacity: 1,
  backgroundCornerRadius: 0,
  texture: null,
  textureColor: "black",
  textureSize: 10,
  texturePadding: 2,
  backgroundMode: "no-repeat",
  backgroundFit: !0,
  backgroundKeepAspectRatio: !1,
  backgroundClip: !0,
  backgroundScale: 1,
  backgroundOffsetX: 0,
  backgroundOffsetY: 0,
  blur: 0,
  filter: "",
  cursor: null,
  html: null,
  react: null,
  vue: null
}, DefaultFillStyle), DefaultStrokeStyle), DefaultLayout), DefaultPickStyle);
const DefaultConnectAttribute = {
  connectedType: "none",
  connectedStyle: {},
  connectedX: NaN,
  connectedY: NaN
};
const DefaultDebugAttribute = {
  _debug_bounds: !1
};
const DefaultAttribute = Object.assign(Object.assign(Object.assign({
  strokeSeg: null,
  renderable: !0,
  pickable: !0,
  shadowGraphic: void 0,
  childrenPickable: !0,
  fillPickable: !0,
  strokePickable: !0,
  visible: !0,
  zIndex: 0,
  layout: null,
  boundsPadding: 0,
  fillStrokeOrder: 0,
  renderStyle: "default",
  pickMode: "accurate",
  customPickShape: null,
  boundsMode: "accurate",
  keepDirIn3d: !0,
  shadowRootIdx: 1,
  globalZIndex: 1,
  globalCompositeOperation: "",
  overflow: "hidden",
  shadowPickMode: "graphic",
  keepStrokeScale: !1,
  clipConfig: null,
  roughStyle: null
}, DefaultDebugAttribute), DefaultStyle), DefaultTransform);
const DefaultArcAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  startAngle: 0,
  endAngle: pi2,
  innerRadius: 0,
  outerRadius: 1,
  innerPadding: 0,
  outerPadding: 0,
  cornerRadius: 0,
  padRadius: 0,
  padAngle: 0,
  cap: !1,
  forceShowCap: !1
});
const DefaultAreaAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
  points: [],
  segments: [],
  curveType: "linear",
  clipRange: 1,
  closePath: !1,
  curveTension: 1
});
const DefaultCircleAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  radius: 1,
  startAngle: 0,
  endAngle: pi2
});
const DefaultGroupAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  cornerRadius: 0,
  path: [],
  clip: !1,
  visibleAll: !0,
  display: "relative",
  flexDirection: "row",
  flexWrap: "wrap",
  justifyContent: "flex-start",
  alignItems: "flex-start",
  alignContent: "flex-start",
  baseOpacity: 1,
  cornerType: "round"
});
const DefaultGlyphAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  path: "",
  width: 0,
  height: 0,
  cornerRadius: 0,
  clip: !1
});
const DefaultLineAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
  points: [],
  segments: [],
  curveType: "linear",
  clipRange: 1,
  clipRangeByDimension: "default",
  closePath: !1,
  curveTension: 1
});
const DefaultPathAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  path: new CustomPath2D(),
  fillStrokeOrder: 1,
  clipRange: 1,
  customPath: () => {
    Logger.getInstance().warn("空函数");
  }
});
const DefaultPolygonAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  points: [],
  cornerRadius: 0,
  closePath: !0
});
const DefaultStarAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 100,
  height: 100,
  spikes: 5,
  thickness: .5
});
const DefaultRectAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  strokeBoundsBuffer: 0,
  cornerRadius: 0,
  cornerType: "round",
  drawStrokeWhenZeroWH: !1
});
Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  cornerRadius: 0,
  length: 0,
  cornerType: "round",
  drawStrokeWhenZeroWH: !1
});
const DefaultSymbolAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  symbolType: "circle",
  size: 10,
  keepDirIn3d: !0,
  clipRange: 1
});
const DefaultTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
  strokeBoundsBuffer: 0,
  keepDirIn3d: !0
});
const DefaultRichTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
  upgradeAttrs: null,
  editable: !1,
  editOptions: null,
  ascentDescentMode: "actual",
  width: 300,
  height: 300,
  ellipsis: !0,
  wordBreak: "break-word",
  verticalDirection: "top",
  textAlign: "left",
  textBaseline: "top",
  layoutDirection: "horizontal",
  textConfig: [],
  disableAutoWrapLine: !1,
  maxHeight: void 0,
  maxWidth: void 0,
  singleLine: !1
});
const DefaultImageAttribute = Object.assign(Object.assign({
  repeatX: "no-repeat",
  repeatY: "no-repeat",
  image: "",
  width: 0,
  height: 0,
  maxWidth: 500,
  maxHeight: 500
}, DefaultAttribute), {
  fill: !0,
  cornerRadius: 0,
  cornerType: "round"
});
const DefaultRichTextIconAttribute = Object.assign(Object.assign({}, DefaultImageAttribute), {
  backgroundShowMode: "never",
  backgroundWidth: 0,
  backgroundHeight: 0,
  textAlign: "left",
  textBaseline: "middle",
  direction: "horizontal",
  margin: 0,
  id: "",
  width: 20,
  height: 20,
  backgroundFill: "rgba(101, 117, 168, 0.1)",
  backgroundFillOpacity: 1,
  backgroundStroke: !1,
  backgroundStrokeOpacity: 1,
  backgroundRadius: 4,
  opacity: 1
});

const parse = function () {
  const tokens = {
    linearGradient: /^(linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    fromAngleValue: /^from\s*(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /(^\#[0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^(rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))/i,
    rgbaColor: /^(rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*((\d\.\d+)|\d{1,3})\))/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  let input = "";
  function error(msg) {
    const err = new Error(input + ": " + msg);
    throw err.source = input, err;
  }
  function getAST() {
    const ast = matchListing(matchDefinition);
    return input.length > 0 && error("Invalid input not EOF"), ast;
  }
  function matchDefinition() {
    return matchGradient("linear", tokens.linearGradient, matchLinearOrientation) || matchGradient("radial", tokens.radialGradient, matchListRadialOrientations) || matchGradient("conic", tokens.conicGradient, matchConicalOrientation);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return function (pattern, callback) {
      const captures = scan(pattern);
      if (captures) {
        scan(tokens.startCall) || error("Missing (");
        const result = callback(captures);
        return scan(tokens.endCall) || error("Missing )"), result;
      }
    }(pattern, function (captures) {
      const orientation = orientationMatcher();
      return orientation && (scan(tokens.comma) || error("Missing comma before color stops")), {
        type: gradientType,
        orientation: orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchLinearOrientation() {
    return match("directional", tokens.sideOrCorner, 1) || match("angular", tokens.angleValue, 1);
  }
  function matchConicalOrientation() {
    return match("angular", tokens.fromAngleValue, 1);
  }
  function matchListRadialOrientations() {
    let radialOrientations,
      lookaheadCache,
      radialOrientation = matchRadialOrientation();
    return radialOrientation && (radialOrientations = [], radialOrientations.push(radialOrientation), lookaheadCache = input, scan(tokens.comma) && (radialOrientation = matchRadialOrientation(), radialOrientation ? radialOrientations.push(radialOrientation) : input = lookaheadCache)), radialOrientations;
  }
  function matchRadialOrientation() {
    let radialType = function () {
      const circle = match("shape", /^(circle)/i, 0);
      circle && (circle.style = matchLength() || matchExtentKeyword());
      return circle;
    }() || function () {
      const ellipse = match("shape", /^(ellipse)/i, 0);
      ellipse && (ellipse.style = matchDistance() || matchExtentKeyword());
      return ellipse;
    }();
    if (radialType) radialType.at = matchAtPosition();else {
      const extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        const positionAt = matchAtPosition();
        positionAt && (radialType.at = positionAt);
      } else {
        const defaultPosition = matchPositioning();
        defaultPosition && (radialType = {
          type: "default-radial",
          at: defaultPosition
        });
      }
    }
    return radialType;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      const positioning = matchPositioning();
      return positioning || error("Missing positioning value"), positioning;
    }
  }
  function matchPositioning() {
    const location = {
      x: matchDistance(),
      y: matchDistance()
    };
    if (location.x || location.y) return {
      type: "position",
      value: location
    };
  }
  function matchListing(matcher) {
    let captures = matcher();
    const result = [];
    if (captures) for (result.push(captures); scan(tokens.comma);) captures = matcher(), captures ? result.push(captures) : error("One extra comma");
    return result;
  }
  function matchColorStop() {
    const color = match("hex", tokens.hexColor, 1) || match("rgba", tokens.rgbaColor, 1) || match("rgb", tokens.rgbColor, 1) || match("literal", tokens.literalColor, 0);
    return color || error("Expected color definition"), color.length = matchDistance(), color;
  }
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || match("position-keyword", tokens.positionKeywords, 1) || matchLength();
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    const captures = scan(pattern);
    if (captures) return {
      type: type,
      value: captures[captureIndex]
    };
  }
  function scan(regexp) {
    const blankCaptures = /^[\n\r\t\s]+/.exec(input);
    blankCaptures && consume(blankCaptures[0].length);
    const captures = regexp.exec(input);
    return captures && consume(captures[0].length), captures;
  }
  function consume(size) {
    input = input.substr(size);
  }
  return function (code) {
    return input = code.toString(), getAST();
  };
}();
class GradientParser {
  static IsGradient(c) {
    return !("string" == typeof c && !c.includes("gradient"));
  }
  static IsGradientStr(c) {
    return "string" == typeof c && c.includes("gradient");
  }
  static Parse(c) {
    if (GradientParser.IsGradientStr(c)) try {
      const datum = parse(c)[0];
      if (datum) {
        if ("linear" === datum.type) return GradientParser.ParseLinear(datum);
        if ("radial" === datum.type) return GradientParser.ParseRadial(datum);
        if ("conic" === datum.type) return GradientParser.ParseConic(datum);
      }
    } catch (err) {
      return c;
    }
    return c;
  }
  static processColorStops(colorStops) {
    if (!colorStops || 0 === colorStops.length) return [];
    if (colorStops.some(item => item.length)) {
      const stops = colorStops.map(item => ({
        color: item.value,
        offset: item.length ? parseFloat(item.length.value) / 100 : -1
      }));
      stops[0].offset < 0 && (stops[0].offset = 0), stops[stops.length - 1].offset < 0 && (stops[stops.length - 1].offset = 1);
      for (let i = 1; i < stops.length - 1; i++) if (stops[i].offset < 0) {
        const prevWithOffsetIdx = i - 1;
        let nextWithOffsetIdx = i + 1;
        for (; nextWithOffsetIdx < stops.length && stops[nextWithOffsetIdx].offset < 0;) nextWithOffsetIdx++;
        const startOffset = stops[prevWithOffsetIdx].offset,
          endOffset = stops[nextWithOffsetIdx].offset,
          unspecCount = nextWithOffsetIdx - prevWithOffsetIdx;
        for (let j = 1; j < unspecCount; j++) stops[prevWithOffsetIdx + j].offset = startOffset + (endOffset - startOffset) * j / unspecCount;
        i = nextWithOffsetIdx - 1;
      }
      return stops;
    }
    return colorStops.map((item, index) => {
      const offset = colorStops.length > 1 ? index / (colorStops.length - 1) : 0;
      return {
        color: item.value,
        offset: offset
      };
    });
  }
  static ParseConic(datum) {
    const {
        orientation: orientation,
        colorStops = []
      } = datum,
      halfPi = pi / 2,
      sa = parseFloat(orientation.value) / 180 * pi - halfPi;
    return {
      gradient: "conical",
      x: .5,
      y: .5,
      startAngle: sa,
      endAngle: sa + pi2,
      stops: GradientParser.processColorStops(colorStops)
    };
  }
  static ParseRadial(datum) {
    const {
      colorStops = []
    } = datum;
    return {
      gradient: "radial",
      x0: .5,
      y0: .5,
      x1: .5,
      y1: .5,
      r0: 0,
      r1: 1,
      stops: GradientParser.processColorStops(colorStops)
    };
  }
  static ParseLinear(datum) {
    const {
        orientation: orientation,
        colorStops = []
      } = datum,
      halfPi = pi / 2;
    let angle = "angular" === orientation.type ? parseFloat(orientation.value) / 180 * pi : 0;
    for (; angle < 0;) angle += pi2;
    for (; angle >= pi2;) angle -= pi2;
    let x0 = 0,
      y0 = 0,
      x1 = 0,
      y1 = 0;
    return angle < halfPi ? (x0 = 0, y0 = 1, x1 = Math.sin(angle), y1 = y0 - Math.cos(angle)) : angle < pi ? (x0 = 0, y0 = 0, x1 = Math.cos(angle - halfPi), y1 = Math.sin(angle - halfPi)) : angle < pi + halfPi ? (x0 = 1, y0 = 0, x1 = x0 - Math.sin(angle - pi), y1 = Math.cos(angle - pi)) : (x0 = 1, x1 = x0 - Math.cos(angle - halfPi - pi), y1 -= Math.sin(angle - halfPi - pi)), {
      gradient: "linear",
      x0: x0,
      y0: y0,
      x1: x1,
      y1: y1,
      stops: GradientParser.processColorStops(colorStops)
    };
  }
}

function getScaledStroke(context, width, dpr) {
  let strokeWidth = width;
  const {
      a: a,
      b: b,
      c: c,
      d: d
    } = context.currentMatrix,
    scaleX = Math.sign(a) * Math.sqrt(a * a + b * b),
    scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);
  return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, strokeWidth);
}
function createColor(context, c, params, offsetX = 0, offsetY = 0) {
  var _a, _b, _c, _d;
  if (!c || !0 === c) return "black";
  let result, color;
  if (isArray(c)) for (let i = 0; i < c.length && (color = c[i], !color); i++);else color = c;
  if (color = GradientParser.Parse(color), "string" == typeof color) return color;
  if (params.AABBBounds && (!params.attribute || 0 !== params.attribute.scaleX || 0 !== params.attribute.scaleY)) {
    const bounds = params.AABBBounds;
    let w = bounds.x2 - bounds.x1,
      h = bounds.y2 - bounds.y1,
      x = bounds.x1 - offsetX,
      y = bounds.y1 - offsetY;
    if (params.attribute) {
      const {
        scaleX = 1,
        scaleY = 1,
        angle = 0
      } = params.attribute;
      w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY, (angle || 1 !== scaleX || 1 !== scaleY) && (x = null !== (_a = params.x1WithoutTransform) && void 0 !== _a ? _a : 0, y = null !== (_b = params.y1WithoutTransform) && void 0 !== _b ? _b : 0, w = null !== (_c = params.widthWithoutTransform) && void 0 !== _c ? _c : w, h = null !== (_d = params.heightWithoutTransform) && void 0 !== _d ? _d : h);
    }
    "linear" === color.gradient ? result = createLinearGradient(context, color, x, y, w, h) : "conical" === color.gradient ? result = createConicGradient(context, color, x, y, w, h) : "radial" === color.gradient && (result = createRadialGradient(context, color, x, y, w, h));
  }
  return result || "orange";
}
function createLinearGradient(context, color, x, y, w, h) {
  var _a, _b, _c, _d;
  const canvasGradient = context.createLinearGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h, x + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w, y + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h);
  return color.stops.forEach(stop => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient;
}
function createRadialGradient(context, color, x, y, w, h) {
  var _a, _b, _c, _d, _e, _f;
  const canvasGradient = context.createRadialGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : .5) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : .5) * h, Math.max(w, h) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x + (null !== (_d = color.x1) && void 0 !== _d ? _d : .5) * w, y + (null !== (_e = color.y1) && void 0 !== _e ? _e : .5) * h, Math.max(w, h) * (null !== (_f = color.r1) && void 0 !== _f ? _f : .5));
  return color.stops.forEach(stop => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient;
}
function createConicGradient(context, color, x, y, w, h) {
  var _a, _b;
  const canvasGradient = context.createConicGradient(x + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h, color.startAngle, color.endAngle);
  return color.stops.forEach(stop => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient.GetPattern ? canvasGradient.GetPattern(w + x, h + y, undefined) : canvasGradient;
}

const DIRECTION_KEY = {
  horizontal: {
    width: "width",
    height: "height",
    left: "left",
    top: "top",
    x: "x",
    y: "y",
    bottom: "bottom"
  },
  vertical: {
    width: "height",
    height: "width",
    left: "top",
    top: "left",
    x: "y",
    y: "x",
    bottom: "right"
  }
};
const defaultFormatting = {
    fontSize: 16,
    fontFamily: DEFAULT_TEXT_FONT_FAMILY$1,
    fill: !0,
    stroke: !1,
    fontWeight: "normal",
    lineHeight: "normal",
    fontStyle: "normal",
    textDecoration: "none",
    textAlign: "left",
    script: "normal"
  };
const regLetter = /\w|\(|\)|-/;
const regPunctuation = /[.?!,;:/，。？！、；：]/;
const regFirstSpace = /\S/;
const setTextStyle = (ctx, character) => {
  let fontSize = character.fontSize || 16;
  switch (character.script) {
    case "super":
    case "sub":
      fontSize *= .8;
  }
  ctx.setTextStyle({
    textAlign: "left",
    textBaseline: character.textBaseline || "alphabetic",
    fontStyle: character.fontStyle || "",
    fontWeight: character.fontWeight || "",
    fontSize: fontSize,
    fontFamily: character.fontFamily
  });
};
function applyFillStyle(ctx, character, b) {
  const fillStyle = character && character.fill || defaultFormatting.fill;
  if (!fillStyle) return void (ctx.globalAlpha = 0);
  const {
    fillOpacity = 1,
    opacity = 1
  } = character;
  ctx.globalAlpha = fillOpacity * opacity, ctx.fillStyle = b ? createColor(ctx, fillStyle, {
    AABBBounds: b
  }) : fillStyle, setTextStyle(ctx, character);
}
function applyStrokeStyle(ctx, character) {
  const strokeStyle = character && character.stroke || defaultFormatting.stroke;
  if (!strokeStyle) return void (ctx.globalAlpha = 0);
  const {
    strokeOpacity = 1,
    opacity = 1
  } = character;
  ctx.globalAlpha = strokeOpacity * opacity, ctx.lineWidth = character && "number" == typeof character.lineWidth ? character.lineWidth : 1, ctx.strokeStyle = strokeStyle, setTextStyle(ctx, character);
}
function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
  if (desc.length <= 1) return 0;
  if (!width || width <= 0) return 0;
  const textMeasure = application.graphicUtil.textMeasure;
  let index = guessIndex,
    temp = desc.slice(0, index),
    tempWidth = Math.floor(textMeasure.measureText(temp, character).width),
    tempNext = desc.slice(0, index + 1),
    tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
  for (; tempWidth > width || tempWidthNext <= width;) {
    if (tempWidth > width ? index-- : index++, index > desc.length) {
      index = desc.length;
      break;
    }
    if (index < 0) {
      index = 0;
      break;
    }
    temp = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
  }
  return needTestLetter && (index = testLetter(desc, index)), index;
}
function testLetter(string, index, negativeWrongMatch = !1) {
  let i = index;
  for (; regLetter.test(string[i - 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]);) if (i--, i <= 0) return negativeWrongMatch ? testLetter2(string, index) : index;
  return i;
}
function testLetter2(string, index) {
  let i = index;
  for (; regLetter.test(string[i + 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]);) if (i++, i >= string.length) return i;
  return i + 1;
}
function measureTextCanvas(text, character, mode = "actual") {
  var _a;
  if ("" === text) return {
    ascent: 0,
    height: 0,
    descent: 0,
    width: 0
  };
  const measurement = application.graphicUtil.textMeasure.measureText(text, character),
    result = {
      ascent: 0,
      height: 0,
      descent: 0,
      width: 0
    },
    ascent = "actual" === mode ? measurement.actualBoundingBoxAscent : measurement.fontBoundingBoxAscent,
    descent = "actual" === mode ? measurement.actualBoundingBoxDescent : measurement.fontBoundingBoxDescent;
  "number" != typeof ascent || "number" != typeof descent ? (result.width = Math.floor(measurement.width), result.height = character.fontSize || 0, result.ascent = result.height, result.descent = 0) : (result.width = Math.floor(measurement.width), result.height = Math.floor(ascent + descent), result.ascent = Math.floor(ascent), result.descent = result.height - result.ascent);
  const space = null !== (_a = character.space) && void 0 !== _a ? _a : 0;
  return result.width += space, result;
}

var __decorate$P = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ATextMeasure = class {
  configure(service, env) {
    this.canvas = service.canvas, this.context = service.context, service.bindTextMeasure(this);
  }
  _measureTextWithoutAlignBaseline(text, options, compatible) {
    this.context.setTextStyleWithoutAlignBaseline(options);
    const metrics = this.context.measureText(text);
    return compatible ? this.compatibleMetrics(metrics, options) : metrics;
  }
  _measureTextWithAlignBaseline(text, options, compatible) {
    this.context.setTextStyle(options);
    const metrics = this.context.measureText(text);
    return compatible ? this.compatibleMetrics(metrics, options) : metrics;
  }
  compatibleMetrics(metrics, options) {
    if (null == metrics.actualBoundingBoxAscent || null == metrics.actualBoundingBoxDescent || null == metrics.fontBoundingBoxAscent || null == metrics.fontBoundingBoxDescent) {
      metrics = {
        width: metrics.width
      };
      const {
        ascent: ascent,
        descent: descent
      } = this.measureTextBoundADscentEstimate(options);
      metrics.actualBoundingBoxAscent = ascent, metrics.actualBoundingBoxDescent = descent, metrics.fontBoundingBoxAscent = ascent, metrics.fontBoundingBoxDescent = descent;
    }
    if (null == metrics.actualBoundingBoxLeft || null == metrics.actualBoundingBoxRight) {
      metrics = {
        width: metrics.width,
        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
        fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
        fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
      };
      const {
        left: left,
        right: right
      } = this.measureTextBoundLeftRightEstimate(options);
      metrics.actualBoundingBoxLeft = left, metrics.actualBoundingBoxRight = right;
    }
    return metrics;
  }
  estimate(text, {
    fontSize = DefaultTextAttribute.fontSize
  }) {
    let eCharLen = 0,
      cCharLen = 0;
    for (let i = 0; i < text.length; i++) text.charCodeAt(i) < 128 ? eCharLen++ : cCharLen++;
    return {
      width: ~~(.8 * eCharLen * fontSize + cCharLen * fontSize),
      height: fontSize
    };
  }
  measureTextWidth(text, options, textMeasure) {
    return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text, options)).width : this.estimate(text, options).width;
  }
  measureTextBoundsWidth(text, options, textMeasure) {
    return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text, options)).width : this.estimate(text, options).width;
  }
  measureTextBoundsLeftRight(text, options, textMeasure) {
    return this.context ? {
      left: (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithAlignBaseline(text, options, !0)).actualBoundingBoxLeft,
      right: textMeasure.actualBoundingBoxRight
    } : this.measureTextBoundLeftRightEstimate(options);
  }
  measureTextPixelHeight(text, options, textMeasure) {
    var _a;
    return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text, options, !0), Math.abs(textMeasure.actualBoundingBoxAscent - textMeasure.actualBoundingBoxDescent)) : null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
  }
  measureTextPixelADscent(text, options, textMeasure) {
    return this.context ? {
      ascent: (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithAlignBaseline(text, options, !0)).actualBoundingBoxAscent,
      descent: textMeasure.actualBoundingBoxDescent
    } : this.measureTextBoundADscentEstimate(options);
  }
  measureTextBoundHieght(text, options, textMeasure) {
    var _a;
    return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text, options, !0), Math.abs(textMeasure.fontBoundingBoxAscent - textMeasure.fontBoundingBoxDescent)) : null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
  }
  measureTextBoundADscent(text, options, textMeasure) {
    return this.context ? {
      ascent: (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithAlignBaseline(text, options, !0)).fontBoundingBoxAscent,
      descent: textMeasure.fontBoundingBoxDescent
    } : this.measureTextBoundADscentEstimate(options);
  }
  measureTextBoundADscentEstimate(options) {
    var _a;
    const fontSize = null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
    return {
      ascent: .79 * fontSize,
      descent: .21 * fontSize
    };
  }
  measureTextBoundLeftRightEstimate(options) {
    var _a;
    const fontSize = null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize,
      {
        textAlign: textAlign
      } = options;
    return "center" === textAlign ? {
      left: fontSize / 2,
      right: fontSize / 2
    } : "right" === textAlign || "end" === textAlign ? {
      left: fontSize,
      right: 0
    } : {
      left: 0,
      right: fontSize
    };
  }
  measureTextPixelADscentAndWidth(text, options, mode) {
    if (!this.context) return Object.assign(Object.assign({}, this.measureTextBoundADscentEstimate(options)), {
      width: this.estimate(text, options).width
    });
    const out = this._measureTextWithoutAlignBaseline(text, options, !0);
    if (mode === MeasureModeEnum.actualBounding) return {
      ascent: out.actualBoundingBoxAscent,
      descent: out.actualBoundingBoxDescent,
      width: out.width
    };
    if (mode === MeasureModeEnum.estimate) return Object.assign(Object.assign({}, this.measureTextBoundADscentEstimate(options)), {
      width: out.width
    });
    if (mode === MeasureModeEnum.fontBounding) {
      let ascent = out.fontBoundingBoxAscent,
        descent = out.fontBoundingBoxDescent;
      if (out.actualBoundingBoxDescent && descent < out.actualBoundingBoxDescent) {
        const delta = out.actualBoundingBoxDescent - descent;
        descent += delta, ascent -= delta;
      } else if (out.actualBoundingBoxAscent && ascent < out.actualBoundingBoxAscent) {
        const delta = out.actualBoundingBoxAscent - ascent;
        ascent += delta, descent -= delta;
      }
      return {
        ascent: ascent,
        descent: descent,
        width: out.width
      };
    }
    return {
      ascent: out.actualBoundingBoxAscent,
      descent: out.actualBoundingBoxDescent,
      width: out.width
    };
  }
  measureText(text, options) {
    return this.context ? (this.context.setTextStyleWithoutAlignBaseline(options), this.context.measureText(text)) : this.estimate(text, options);
  }
  clipTextVertical(verticalList, options, width, wordBreak) {
    if (0 === verticalList.length) return {
      verticalList: verticalList,
      width: 0
    };
    const {
      fontSize = 12
    } = options;
    verticalList.forEach(item => {
      item.width = 0 === item.direction ? fontSize : this.measureTextWidth(item.text, options);
    });
    const out = [];
    let length = 0,
      i = 0;
    for (; i < verticalList.length && length + verticalList[i].width < width; i++) length += verticalList[i].width, out.push(verticalList[i]);
    if (verticalList[i] && verticalList[i].text.length > 1) {
      const clipedData = this._clipText(verticalList[i].text, options, width - length, 0, verticalList[i].text.length - 1, "end", !1);
      if (wordBreak && clipedData.str !== verticalList[i].text) {
        let text = "",
          length = 0;
        for (let j = 0; j < i; j++) {
          const item = verticalList[j];
          text += item.text, length += item.text.length;
        }
        text += verticalList[i].text;
        const totalLength = length + clipedData.str.length;
        let index = testLetter(text, totalLength);
        index -= length, index !== clipedData.str.length - 1 && (clipedData.str = clipedData.str.substring(0, index), clipedData.width = this.measureTextWidth(clipedData.str, options));
      }
      out.push(Object.assign(Object.assign({}, verticalList[i]), {
        text: clipedData.str,
        width: clipedData.width
      })), length += clipedData.width;
    }
    return {
      verticalList: out,
      width: length
    };
  }
  clipText(text, options, width, wordBreak, keepAllBreak) {
    if (0 === text.length) return {
      str: "",
      width: 0
    };
    let length = this.measureTextWidth(text, options);
    if (length <= width) return {
      str: text,
      width: length
    };
    if (length = this.measureTextWidth(text[0], options), length > width) return {
      str: "",
      width: 0
    };
    const data = this._clipText(text, options, width, 0, text.length - 1, "end", !1);
    if (wordBreak && data.str !== text) {
      let index = testLetter(text, data.str.length, keepAllBreak);
      index !== data.str.length && (index > data.str.length && (data.wordBreaked = index, index = data.str.length), data.str = text.substring(0, index), data.width = this.measureTextWidth(data.str, options));
    }
    return data;
  }
  _clipText(text, options, width, leftIdx, rightIdx, position, suffix) {
    let data;
    if ("start" === position) data = this._clipTextStart(text, options, width, leftIdx, rightIdx), suffix && (data.result = suffix + data.str);else if ("middle" === position) {
      const d = this._clipTextMiddle(text, options, width, "", "", 0, 0, 1);
      data = {
        str: "none",
        width: d.width,
        result: d.left + suffix + d.right
      };
    } else data = this._clipTextEnd(text, options, width, leftIdx, rightIdx), suffix && (data.result = data.str + suffix);
    return data;
  }
  _clipTextEnd(text, options, width, leftIdx, rightIdx) {
    if (leftIdx === rightIdx) {
      Logger.getInstance().warn(`【_clipTextEnd】不应该走到这里${text}, ${leftIdx}, ${rightIdx}`);
      const subText = text.substring(0, rightIdx + 1);
      return {
        str: subText,
        width: this.measureTextWidth(subText, options)
      };
    }
    const middleIdx = Math.floor((leftIdx + rightIdx) / 2),
      subText = text.substring(0, middleIdx + 1),
      strWidth = this.measureTextWidth(subText, options);
    let length;
    if (strWidth > width) {
      if (subText.length <= 1) return {
        str: "",
        width: 0
      };
      const str = text.substring(0, middleIdx);
      return length = this.measureTextWidth(str, options), length <= width ? {
        str: str,
        width: length
      } : this._clipTextEnd(text, options, width, leftIdx, middleIdx);
    }
    if (strWidth < width) {
      if (middleIdx >= text.length - 1) return {
        str: text,
        width: this.measureTextWidth(text, options)
      };
      const str = text.substring(0, middleIdx + 2);
      return length = this.measureTextWidth(str, options), length >= width ? {
        str: subText,
        width: strWidth
      } : this._clipTextEnd(text, options, width, middleIdx, rightIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  _clipTextStart(text, options, width, leftIdx, rightIdx) {
    const middleIdx = Math.ceil((leftIdx + rightIdx) / 2),
      subText = text.substring(middleIdx - 1, text.length),
      strWidth = this.measureTextWidth(subText, options);
    let length;
    if (strWidth > width) {
      if (subText.length <= 1) return {
        str: "",
        width: 0
      };
      const str = text.substring(middleIdx, text.length);
      return length = this.measureTextWidth(str, options), length <= width ? {
        str: str,
        width: length
      } : this._clipTextStart(text, options, width, middleIdx, text.length);
    }
    if (strWidth < width) {
      if (middleIdx <= 0) return {
        str: text,
        width: this.measureTextWidth(text, options)
      };
      const str = text.substring(middleIdx - 2, text.length);
      return length = this.measureTextWidth(str, options), length >= width ? {
        str: subText,
        width: strWidth
      } : this._clipTextStart(text, options, width, leftIdx, middleIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  _clipTextMiddle(text, options, width, left, right, leftW, rightW, buffer) {
    const subLeftText = text.substring(0, buffer),
      strLeftWidth = this.measureTextWidth(subLeftText, options);
    if (strLeftWidth + rightW > width) return {
      left: left,
      right: right,
      width: leftW + rightW
    };
    const subRightText = text.substring(text.length - buffer, text.length),
      strRightWidth = this.measureTextWidth(subRightText, options);
    return strLeftWidth + strRightWidth > width ? {
      left: subLeftText,
      right: right,
      width: strLeftWidth + rightW
    } : this._clipTextMiddle(text, options, width, subLeftText, subRightText, strLeftWidth, strRightWidth, buffer + 1);
  }
  clipTextWithSuffixVertical(verticalList, options, width, suffix, wordBreak, suffixPosition) {
    if ("" === suffix) return this.clipTextVertical(verticalList, options, width, wordBreak);
    if (0 === verticalList.length) return {
      verticalList: verticalList,
      width: 0
    };
    const output = this.clipTextVertical(verticalList, options, width, wordBreak);
    if (output.verticalList.length === verticalList.length && output.verticalList[output.verticalList.length - 1].width === verticalList[verticalList.length - 1].width) return output;
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width) return output;
    let out;
    if (width -= suffixWidth, "start" === suffixPosition) {
      const nextVerticalList = this.revertVerticalList(verticalList);
      out = this.clipTextVertical(nextVerticalList, options, width, wordBreak);
      const v = this.revertVerticalList(out.verticalList);
      v.unshift({
        text: suffix,
        direction: 1,
        width: suffixWidth
      }), out.verticalList = v;
    } else if ("middle" === suffixPosition) {
      const leftOut = this.clipTextVertical(verticalList, options, width / 2, wordBreak),
        nextVerticalList = this.revertVerticalList(verticalList),
        rightOut = this.clipTextVertical(nextVerticalList, options, width / 2, wordBreak);
      leftOut.verticalList.push({
        text: suffix,
        direction: 1,
        width: suffixWidth
      }), this.revertVerticalList(rightOut.verticalList).forEach(v => leftOut.verticalList.push(v)), out = {
        verticalList: leftOut.verticalList,
        width: leftOut.width + rightOut.width
      };
    } else out = this.clipTextVertical(verticalList, options, width, wordBreak), out.verticalList.push({
      text: suffix,
      direction: 1,
      width: suffixWidth
    });
    return out.width += suffixWidth, out;
  }
  revertVerticalList(verticalList) {
    return verticalList.reverse().map(l => {
      const t = l.text.split("").reverse().join("");
      return Object.assign(Object.assign({}, l), {
        text: t
      });
    });
  }
  clipTextWithSuffix(text, options, width, suffix, wordBreak, position, forceSuffix = !1) {
    if ("" === suffix) return this.clipText(text, options, width, wordBreak);
    if (0 === text.length) return {
      str: "",
      width: 0
    };
    const length = this.measureTextWidth(text, options);
    if (!forceSuffix && length <= width) return {
      str: text,
      width: length
    };
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width) return {
      str: "",
      width: 0
    };
    if (forceSuffix && length + suffixWidth <= width) return {
      str: text + suffix,
      width: length + suffixWidth
    };
    width -= suffixWidth;
    const data = this._clipText(text, options, width, 0, text.length - 1, position, suffix);
    if (wordBreak && data.str !== text) {
      const index = testLetter(text, data.str.length);
      index !== data.str.length && (data.result = text.substring(0, index), data.width = this.measureTextWidth(data.str, options));
    } else forceSuffix && data.str === text && (data.result = text + suffix);
    return data.str = data.result, data.width += suffixWidth, data;
  }
};
ATextMeasure = __decorate$P([injectable()], ATextMeasure);

var __decorate$O = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const TextMeasureContribution = Symbol.for("TextMeasureContribution");
let DefaultTextMeasureContribution = class extends ATextMeasure {};
DefaultTextMeasureContribution = __decorate$O([injectable()], DefaultTextMeasureContribution);

const container = new Container();

const CanvasFactory = Symbol.for("CanvasFactory");

function wrapCanvas(params) {
  return container.getNamed(CanvasFactory, application.global.env)(params);
}
const EPSILON_NUMERIC = 1e-4,
  THREE_SQRT = Math.sqrt(3),
  ONE_THIRD = 1 / 3;
function isAroundZero(val) {
  return val > -EPSILON && val < EPSILON;
}
function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
const _v0 = [0, 0],
  _v1 = [0, 0],
  _v2 = [0, 0];
function distanceSquare(v1, v2) {
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
function quadraticAt(p0, p1, p2, t) {
  const onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
function cubicAt(p0, p1, p2, p3, t) {
  const onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
function quadraticRootAt(p0, p1, p2, val, roots) {
  const a = p0 - 2 * p1 + p2,
    b = 2 * (p1 - p0),
    c = p0 - val;
  let n = 0;
  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      const t1 = -c / b;
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
    }
  } else {
    const disc = b * b - 4 * a * c;
    if (isAroundZero(disc)) {
      const t1 = -b / (2 * a);
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
    } else if (disc > 0) {
      const discSqrt = Math.sqrt(disc),
        t1 = (-b + discSqrt) / (2 * a),
        t2 = (-b - discSqrt) / (2 * a);
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);
    }
  }
  return n;
}
function quadraticExtremum(p0, p1, p2) {
  const divider = p0 + p2 - 2 * p1;
  return 0 === divider ? .5 : (p0 - p1) / divider;
}
function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
  let t = 0,
    interval = .005,
    d = 1 / 0;
  _v0[0] = x, _v0[1] = y;
  for (let _t = 0; _t < 1; _t += .05) {
    _v1[0] = quadraticAt(x0, x1, x2, _t), _v1[1] = quadraticAt(y0, y1, y2, _t);
    const d1 = distanceSquare(_v0, _v1);
    d1 < d && (t = _t, d = d1);
  }
  d = 1 / 0;
  for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) {
    const prev = t - interval,
      next = t + interval;
    _v1[0] = quadraticAt(x0, x1, x2, prev), _v1[1] = quadraticAt(y0, y1, y2, prev);
    const d1 = distanceSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) t = prev, d = d1;else {
      _v2[0] = quadraticAt(x0, x1, x2, next), _v2[1] = quadraticAt(y0, y1, y2, next);
      const d2 = distanceSquare(_v2, _v0);
      next <= 1 && d2 < d ? (t = next, d = d2) : interval *= .5;
    }
  }
  return out && (out[0] = quadraticAt(x0, x1, x2, t), out[1] = quadraticAt(y0, y1, y2, t)), Math.sqrt(d);
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
  let prev,
    next,
    d1,
    d2,
    t = 0,
    interval = .005,
    d = 1 / 0;
  _v0[0] = x, _v0[1] = y;
  for (let _t = 0; _t < 1; _t += .05) _v1[0] = cubicAt(x0, x1, x2, x3, _t), _v1[1] = cubicAt(y0, y1, y2, y3, _t), d1 = distanceSquare(_v0, _v1), d1 < d && (t = _t, d = d1);
  d = 1 / 0;
  for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) prev = t - interval, next = t + interval, _v1[0] = cubicAt(x0, x1, x2, x3, prev), _v1[1] = cubicAt(y0, y1, y2, y3, prev), d1 = distanceSquare(_v1, _v0), prev >= 0 && d1 < d ? (t = prev, d = d1) : (_v2[0] = cubicAt(x0, x1, x2, x3, next), _v2[1] = cubicAt(y0, y1, y2, y3, next), d2 = distanceSquare(_v2, _v0), next <= 1 && d2 < d ? (t = next, d = d2) : interval *= .5);
  return out && (out[0] = cubicAt(x0, x1, x2, x3, t), out[1] = cubicAt(y0, y1, y2, y3, t)), Math.sqrt(d);
}
function normalizeRadian(angle) {
  return (angle %= pi2) < 0 && (angle += pi2), angle;
}
function containQuadStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
  if (0 === lineWidth) return !1;
  const _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) return !1;
  return quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null) <= _l / 2;
}
function containCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
  if (0 === lineWidth) return !1;
  const _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) return !1;
  return cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null) <= _l / 2;
}
function containArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (0 === lineWidth) return !1;
  const _l = lineWidth;
  x -= cx, y -= cy;
  const d = Math.sqrt(x * x + y * y);
  if (d - _l > r || d + _l < r) return !1;
  if (Math.abs(startAngle - endAngle) % pi2 < 1e-4) return !0;
  if (anticlockwise) {
    const tmp = startAngle;
    startAngle = normalizeRadian(endAngle), endAngle = normalizeRadian(tmp);
  } else startAngle = normalizeRadian(startAngle), endAngle = normalizeRadian(endAngle);
  startAngle > endAngle && (endAngle += pi2);
  let angle = Math.atan2(y, x);
  return angle < 0 && (angle += pi2), angle >= startAngle && angle <= endAngle || angle + pi2 >= startAngle && angle + pi2 <= endAngle;
}
function containLineStroke(x0, y0, x1, y1, lineWidth, x, y) {
  if (0 === lineWidth) return !1;
  const _l = lineWidth,
    _halfL = lineWidth / 2;
  let _a = 0,
    _b = x0;
  if (y > y0 + _halfL && y > y1 + _halfL || y < y0 - _halfL && y < y1 - _halfL || x > x0 + _halfL && x > x1 + _halfL || x < x0 - _halfL && x < x1 - _halfL) return !1;
  if (x0 === x1) return Math.abs(x - x0) <= _l / 2;
  _a = (y0 - y1) / (x0 - x1), _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  const tmp = _a * x - y + _b;
  return tmp * tmp / (_a * _a + 1) <= _l / 2 * _l / 2;
}
const EPSILON = 1e-4;
function cubicRootAt(p0, p1, p2, p3, val, roots) {
  const a = p3 + 3 * (p1 - p2) - p0,
    b = 3 * (p2 - 2 * p1 + p0),
    c = 3 * (p1 - p0),
    d = p0 - val,
    A = b * b - 3 * a * c,
    B = b * c - 9 * a * d,
    C = c * c - 3 * b * d;
  let n = 0;
  if (isAroundZero(A) && isAroundZero(B)) {
    if (isAroundZero(b)) roots[0] = 0;else {
      const t1 = -c / b;
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
    }
  } else {
    const disc = B * B - 4 * A * C;
    if (isAroundZero(disc)) {
      const K = B / A,
        t1 = -b / a + K,
        t2 = -K / 2;
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);
    } else if (disc > 0) {
      const discSqrt = Math.sqrt(disc);
      let Y1 = A * b + 1.5 * a * (-B + discSqrt),
        Y2 = A * b + 1.5 * a * (-B - discSqrt);
      Y1 = Y1 < 0 ? -Math.pow(-Y1, ONE_THIRD) : Math.pow(Y1, ONE_THIRD), Y2 = Y2 < 0 ? -Math.pow(-Y2, ONE_THIRD) : Math.pow(Y2, ONE_THIRD);
      const t1 = (-b - (Y1 + Y2)) / (3 * a);
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
    } else {
      const T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A)),
        theta = Math.acos(T) / 3,
        ASqrt = Math.sqrt(A),
        tmp = Math.cos(theta),
        t1 = (-b - 2 * ASqrt * tmp) / (3 * a),
        t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a),
        t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2), t3 >= 0 && t3 <= 1 && (roots[n++] = t3);
    }
  }
  return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema) {
  const b = 6 * p2 - 12 * p1 + 6 * p0,
    a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2,
    c = 3 * p1 - 3 * p0;
  let n = 0;
  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      const t1 = -c / b;
      t1 >= 0 && t1 <= 1 && (extrema[n++] = t1);
    }
  } else {
    const disc = b * b - 4 * a * c;
    if (isAroundZero(disc)) extrema[0] = -b / (2 * a);else if (disc > 0) {
      const discSqrt = Math.sqrt(disc),
        t1 = (-b + discSqrt) / (2 * a),
        t2 = (-b - discSqrt) / (2 * a);
      t1 >= 0 && t1 <= 1 && (extrema[n++] = t1), t2 >= 0 && t2 <= 1 && (extrema[n++] = t2);
    }
  }
  return n;
}
function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
}
const roots = [-1, -1, -1],
  extrema = [-1, -1];
function swapExtrema() {
  const tmp = extrema[0];
  extrema[0] = extrema[1], extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) return 0;
  const nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
  if (0 === nRoots) return 0;
  let w = 0,
    nExtrema = -1,
    y0_ = 0,
    y1_ = 0;
  for (let i = 0; i < nRoots; i++) {
    const t = roots[i],
      unit = 0 === t || 1 === t ? .5 : 1;
    cubicAt(x0, x1, x2, x3, t) < x || (nExtrema < 0 && (nExtrema = cubicExtrema(y0, y1, y2, y3, extrema), extrema[1] < extrema[0] && nExtrema > 1 && swapExtrema(), y0_ = cubicAt(y0, y1, y2, y3, extrema[0]), nExtrema > 1 && (y1_ = cubicAt(y0, y1, y2, y3, extrema[1]))), 2 === nExtrema ? t < extrema[0] ? w += y0_ < y0 ? unit : -unit : t < extrema[1] ? w += y1_ < y0_ ? unit : -unit : w += y3 < y1_ ? unit : -unit : t < extrema[0] ? w += y0_ < y0 ? unit : -unit : w += y3 < y0_ ? unit : -unit);
  }
  return w;
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) return 0;
  const nRoots = quadraticRootAt(y0, y1, y2, y, roots);
  if (0 === nRoots) return 0;
  const t = quadraticExtremum(y0, y1, y2);
  if (t >= 0 && t <= 1) {
    let w = 0;
    const y_ = quadraticAt(y0, y1, y2, t);
    for (let i = 0; i < nRoots; i++) {
      const unit = 0 === roots[i] || 1 === roots[i] ? .5 : 1;
      quadraticAt(x0, x1, x2, roots[i]) < x || (roots[i] < t ? w += y_ < y0 ? unit : -unit : w += y2 < y_ ? unit : -unit);
    }
    return w;
  }
  const unit = 0 === roots[0] || 1 === roots[0] ? .5 : 1;
  return quadraticAt(x0, x1, x2, roots[0]) < x ? 0 : y2 < y0 ? unit : -unit;
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  if ((y -= cy) > r || y < -r) return 0;
  const tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp, roots[1] = tmp;
  const dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 1e-4) return 0;
  if (dTheta >= pi2 - 1e-4) {
    startAngle = 0, endAngle = pi2;
    const dir = anticlockwise ? 1 : -1;
    return x >= roots[0] + cx && x <= roots[1] + cx ? dir : 0;
  }
  if (startAngle > endAngle) {
    const tmp = startAngle;
    startAngle = endAngle, endAngle = tmp;
  }
  startAngle < 0 && (startAngle += pi2, endAngle += pi2);
  let w = 0;
  for (let i = 0; i < 2; i++) {
    const x_ = roots[i];
    if (x_ + cx > x) {
      let angle = Math.atan2(y, x_),
        dir = anticlockwise ? 1 : -1;
      angle < 0 && (angle = pi2 + angle), (angle >= startAngle && angle <= endAngle || angle + pi2 >= startAngle && angle + pi2 <= endAngle) && (angle > pi / 2 && angle < 1.5 * pi && (dir = -dir), w += dir);
    }
  }
  return w;
}
function modpi2(radian) {
  return Math.round(radian / pi * 1e8) / 1e8 % 2 * pi;
}
function normalizeArcAngles(angles, anticlockwise) {
  let newStartAngle = modpi2(angles[0]);
  newStartAngle < 0 && (newStartAngle += pi2);
  const delta = newStartAngle - angles[0];
  let newEndAngle = angles[1];
  newEndAngle += delta, !anticlockwise && newEndAngle - newStartAngle >= pi2 ? newEndAngle = newStartAngle + pi2 : anticlockwise && newStartAngle - newEndAngle >= pi2 ? newEndAngle = newStartAngle - pi2 : !anticlockwise && newStartAngle > newEndAngle ? newEndAngle = newStartAngle + (pi2 - modpi2(newStartAngle - newEndAngle)) : anticlockwise && newStartAngle < newEndAngle && (newEndAngle = newStartAngle - (pi2 - modpi2(newEndAngle - newStartAngle))), angles[0] = newStartAngle, angles[1] = newEndAngle;
}
const tmpAngles = [0, 0];
function containPath(commands, lineWidth, isStroke, x, y) {
  const data = commands,
    len = commands.length;
  let x1,
    y1,
    w = 0,
    xi = 0,
    yi = 0,
    x0 = 0,
    y0 = 0;
  for (let i = 0; i < len; i++) {
    const command = data[i],
      isFirst = 0 === i;
    command[0] === enumCommandMap.M && i > 1 && (isStroke || (w += isPointInLine(xi, yi, x0, y0, x, y))), isFirst && (xi = command[1], yi = command[2], x0 = xi, y0 = yi);
    const c0 = command[0],
      c1 = command[1],
      c2 = command[2],
      c3 = command[3],
      c4 = command[4],
      c5 = command[5],
      c6 = command[6];
    let startAngle = c4,
      endAngle = c5;
    tmpAngles[0] = startAngle, tmpAngles[1] = endAngle, normalizeArcAngles(tmpAngles, Boolean(command[6])), startAngle = tmpAngles[0], endAngle = tmpAngles[1];
    const theta = startAngle,
      dTheta = endAngle - startAngle,
      anticlockwise = !!(1 - (command[6] ? 0 : 1)),
      _x = (x - c1) * c3 / c3 + c1;
    switch (c0) {
      case enumCommandMap.M:
        x0 = c1, y0 = c2, xi = x0, yi = y0;
        break;
      case enumCommandMap.L:
        if (isStroke) {
          if (containLineStroke(xi, yi, c1, c2, lineWidth, x, y)) return !0;
        } else w += isPointInLine(xi, yi, c1, c2, x, y) || 0;
        xi = c1, yi = c2;
        break;
      case enumCommandMap.C:
        if (isStroke) {
          if (containCubicStroke(xi, yi, c1, c2, c3, c4, c5, c6, lineWidth, x, y)) return !0;
        } else w += windingCubic(xi, yi, c1, c2, c3, c4, c5, c6, x, y) || 0;
        xi = c5, yi = c6;
        break;
      case enumCommandMap.Q:
        if (isStroke) {
          if (containQuadStroke(xi, yi, c1, c2, c3, c4, lineWidth, x, y)) return !0;
        } else w += windingQuadratic(xi, yi, c1, c2, c3, c4, x, y) || 0;
        xi = c3, yi = c4;
        break;
      case enumCommandMap.A:
        if (x1 = Math.cos(theta) * c3 + c1, y1 = Math.sin(theta) * c3 + c2, isFirst ? (x0 = x1, y0 = y1) : w += isPointInLine(xi, yi, x1, y1, x, y), isStroke) {
          if (containArcStroke(c1, c2, c3, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) return !0;
        } else w += windingArc(c1, c2, c3, theta, theta + dTheta, anticlockwise, _x, y);
        xi = Math.cos(theta + dTheta) * c3 + c1, yi = Math.sin(theta + dTheta) * c3 + c2;
        break;
      case enumCommandMap.R:
        if (x0 = xi = c1, y0 = yi = c2, x1 = x0 + c3, y1 = y0 + c4, isStroke) {
          if (containLineStroke(x0, y0, x1, y0, lineWidth, x, y) || containLineStroke(x1, y0, x1, y1, lineWidth, x, y) || containLineStroke(x1, y1, x0, y1, lineWidth, x, y) || containLineStroke(x0, y1, x0, y0, lineWidth, x, y)) return !0;
        } else w += isPointInLine(x1, y0, x1, y1, x, y), w += isPointInLine(x0, y1, x0, y0, x, y);
        break;
      case enumCommandMap.Z:
        if (isStroke) {
          if (containLineStroke(xi, yi, x0, y0, lineWidth, x, y)) return !0;
        } else w += isPointInLine(xi, yi, x0, y0, x, y);
        xi = x0, yi = y0;
    }
  }
  return isStroke || isAroundEqual(yi, y0) || (w += isPointInLine(xi, yi, x0, y0, x, y) || 0), 0 !== w;
}
function contain(commands, x, y) {
  return containPath(commands, 0, !1, x, y);
}
function containStroke(commands, lineWidth, x, y) {
  return containPath(commands, lineWidth, !0, x, y);
}

class DefaultCanvasAllocate {
  constructor() {
    this.pools = [], this.allocatedCanvas = [];
  }
  shareCanvas() {
    return this.allocatedCanvas.length ? this.allocatedCanvas[0] : this.getCommonCanvas();
  }
  getCommonCanvas() {
    return this._commonCanvas || (this._commonCanvas = this.allocate({
      width: 100,
      height: 100,
      dpr: 2
    })), this._commonCanvas;
  }
  allocate(data) {
    if (!this.pools.length) {
      const c = wrapCanvas(Object.assign({
        nativeCanvas: application.global.createCanvas(data)
      }, data));
      return this.allocatedCanvas.push(c), c;
    }
    const m = this.pools.pop();
    return m.resize(data.width, data.height), m.dpr = data.dpr, m;
  }
  allocateByObj(canvas) {
    if (!this.pools.length) {
      const data = {
          width: canvas.width / canvas.dpr,
          height: canvas.height / canvas.dpr,
          dpr: canvas.dpr
        },
        c = wrapCanvas(Object.assign({
          nativeCanvas: application.global.createCanvas(data)
        }, data));
      return this.allocatedCanvas.push(c), c;
    }
    const m = this.pools.pop();
    return m.width = canvas.width, m.height = canvas.height, m;
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release(...params) {
    this.pools = [];
  }
}
const canvasAllocate = new DefaultCanvasAllocate();

var __decorate$N = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$F = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
const VWindow = Symbol.for("VWindow");
const WindowHandlerContribution = Symbol.for("WindowHandlerContribution");
let DefaultWindow = class extends EventListenerManager {
  get width() {
    if (this._handler) {
      const wh = this._handler.getWH();
      return this._width = wh.width;
    }
    return this._width;
  }
  get height() {
    if (this._handler) {
      const wh = this._handler.getWH();
      return this._height = wh.height;
    }
    return this._height;
  }
  get dpr() {
    return this._handler.getDpr();
  }
  constructor() {
    super(), this.hooks = {
      onChange: new SyncHook(["x", "y", "width", "height"])
    }, this.active = () => {
      const global = this.global;
      if (!global.env || this.actived) return;
      container.getNamed(WindowHandlerContribution, global.env).configure(this, global), this.actived = !0;
    }, this._uid = Generator.GenAutoIncrementId(), this.global = application.global, this.postInit();
  }
  _nativeAddEventListener(type, listener, options) {
    return this._handler.addEventListener(type, listener, options);
  }
  _nativeRemoveEventListener(type, listener, options) {
    return this._handler.removeEventListener(type, listener, options);
  }
  _nativeDispatchEvent(event) {
    return this._handler.dispatchEvent(event);
  }
  postInit() {
    this.global.hooks.onSetEnv.tap("window", this.active), this.active();
  }
  get style() {
    var _a;
    return null !== (_a = this._handler.getStyle()) && void 0 !== _a ? _a : {};
  }
  set style(style) {
    this._handler.setStyle(style);
  }
  create(params) {
    var _a, _b;
    this._handler.createWindow(params);
    const windowWH = this._handler.getWH();
    this._width = windowWH.width, this._height = windowWH.height, params.viewBox ? this.setViewBox(params.viewBox) : !1 !== params.canvasControled ? this.setViewBox({
      x1: 0,
      y1: 0,
      x2: this._width,
      y2: this._height
    }) : this.setViewBox({
      x1: 0,
      y1: 0,
      x2: null !== (_a = params.width) && void 0 !== _a ? _a : this._width,
      y2: null !== (_b = params.height) && void 0 !== _b ? _b : this._height
    }), this.title = this._handler.getTitle(), this.resizable = !0;
  }
  setWindowHandler(handler) {
    this._handler = handler;
  }
  setDpr(dpr) {
    return this._handler.setDpr(dpr);
  }
  resize(w, h) {
    return this._handler.resizeWindow(w, h);
  }
  configure() {
    throw new Error("暂不支持");
  }
  release() {
    return this.global.hooks.onSetEnv.unTap("window", this.active), this.clearAllEventListeners(), this._handler.releaseWindow();
  }
  getContext() {
    return this._handler.getContext();
  }
  getNativeHandler() {
    return this._handler.getNativeHandler();
  }
  getImageBuffer(type) {
    return this._handler.getImageBuffer ? this._handler.getImageBuffer(type) : null;
  }
  getBoundingClientRect() {
    return this._handler.getBoundingClientRect();
  }
  getContainer() {
    return this._handler.container;
  }
  clearViewBox(color) {
    this._handler.clearViewBox(color);
  }
  setViewBox(viewBox) {
    this._handler.setViewBox(viewBox);
  }
  setViewBoxTransform(a, b, c, d, e, f) {
    this._handler.setViewBoxTransform(a, b, c, d, e, f);
  }
  getViewBox() {
    return this._handler.getViewBox();
  }
  getViewBoxTransform() {
    return this._handler.getViewBoxTransform();
  }
  pointTransform(x, y) {
    const vb = this._handler.getViewBox(),
      nextP = {
        x: x,
        y: y
      };
    return this._handler.getViewBoxTransform().transformPoint({
      x: x,
      y: y
    }, nextP), nextP.x -= vb.x1, nextP.y -= vb.y1, nextP;
  }
  hasSubView() {
    const viewBox = this._handler.getViewBox();
    return !(0 === viewBox.x1 && 0 === viewBox.y1 && isNumberClose(this.width, viewBox.width()) && isNumberClose(this.height, viewBox.height()));
  }
  isVisible(bbox) {
    return this._handler.isVisible(bbox);
  }
  onVisibleChange(cb) {
    return this._handler.onVisibleChange(cb);
  }
  getTopLeft(baseWindow) {
    return this._handler.getTopLeft(baseWindow);
  }
};
DefaultWindow = __decorate$N([injectable(), __metadata$F("design:paramtypes", [])], DefaultWindow);

var __decorate$M = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$E = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$z = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultGraphicUtil = class {
  get canvas() {
    return this.tryInitCanvas(), this._canvas;
  }
  get context() {
    return this.tryInitCanvas(), this._context;
  }
  constructor(contributions) {
    this.contributions = contributions, this.configured = !1, this.global = application.global, this.global.hooks.onSetEnv.tap("graphic-util", (lastEnv, env, global) => {
      this.configured = !1, this.configure(global, env);
    });
  }
  get textMeasure() {
    return this._textMeasure || this.configure(this.global, this.global.env), this._textMeasure;
  }
  configure(global, env) {
    this.configured || (this.contributions.getContributions().forEach(contribution => {
      contribution.configure(this, env);
    }), this.configured = !0);
  }
  tryInitCanvas() {
    if (!this._canvas) {
      const canvas = canvasAllocate.shareCanvas();
      this._canvas = canvas, this._context = canvas.getContext("2d");
    }
  }
  bindTextMeasure(tm) {
    this._textMeasure = tm;
  }
  measureText(text, tc, method = "native") {
    var _a;
    this.configure(this.global, this.global.env);
    const m = this.global.measureTextMethod;
    this.global.measureTextMethod = method;
    const data = {
      width: this._textMeasure.measureTextWidth(text, tc),
      height: null !== (_a = tc.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize
    };
    return this.global.measureTextMethod = m, data;
  }
  createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {
    return this.configure(this.global, this.global.env), new TextMeasure(Object.assign({
      defaultFontParams: {
        fontFamily: DefaultTextStyle.fontFamily,
        fontSize: DefaultTextStyle.fontSize
      },
      getCanvasForMeasure: getCanvasForMeasure || (() => this.canvas),
      getTextBounds: void 0,
      specialCharSet: "-/: .,@%'\"~" + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
    }, null != option ? option : {}), textSpec);
  }
  drawGraphicToCanvas(graphic, stage, canvas) {
    if (!stage.defaultLayer) return null;
    const window = container.get(VWindow),
      bounds = graphic.AABBBounds,
      width = bounds.width(),
      height = bounds.height(),
      x1 = -bounds.x1,
      y1 = -bounds.y1;
    window.create({
      viewBox: {
        x1: x1,
        y1: y1,
        x2: bounds.x2,
        y2: bounds.y2
      },
      width: width,
      height: height,
      canvas: canvas,
      dpr: stage.window.dpr,
      canvasControled: !0,
      offscreen: !0,
      title: ""
    });
    const disableCheckGraphicWidthOutRange = stage.params.optimize.disableCheckGraphicWidthOutRange;
    stage.params.optimize.disableCheckGraphicWidthOutRange = !0, stage.defaultLayer.getNativeHandler().drawTo(window, [graphic], {
      transMatrix: window.getViewBoxTransform(),
      viewBox: window.getViewBox(),
      stage: stage,
      layer: stage.defaultLayer,
      renderService: stage.renderService,
      background: "transparent",
      clear: !0,
      updateBounds: !1
    }), stage.params.optimize.disableCheckGraphicWidthOutRange = disableCheckGraphicWidthOutRange;
    const c = window.getNativeHandler();
    return c.nativeCanvas ? c.nativeCanvas : null;
  }
};
DefaultGraphicUtil = __decorate$M([injectable(), __param$z(0, inject(ContributionProvider)), __param$z(0, named(TextMeasureContribution)), __metadata$E("design:paramtypes", [Object])], DefaultGraphicUtil);
var TransformMode;
!function (TransformMode) {
  TransformMode[TransformMode.transform = 0] = "transform", TransformMode[TransformMode.matrix = 1] = "matrix";
}(TransformMode || (TransformMode = {}));
const _matrix = new Matrix();
let DefaultTransformUtil = class {
  constructor() {
    this.matrix = new Matrix();
  }
  init(origin) {
    return this.mode = TransformMode.transform, this.originTransform = origin, this.matrix.reset(), this;
  }
  fromMatrix(source, target) {
    return this.mode = TransformMode.matrix, this.outSourceMatrix = source, this.outTargetMatrix = target, this;
  }
  scaleMatrix(sx, sy, center) {
    const sMatrix = this.outSourceMatrix;
    if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center) {
      const {
        x: x,
        y: y
      } = center;
      this.outTargetMatrix.translate(x, y), this.outTargetMatrix.scale(sx, sy), this.outTargetMatrix.translate(-x, -y);
    } else this.outTargetMatrix.scale(sx, sy);
    return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  rotateMatrix(angle, center) {
    const sMatrix = this.outSourceMatrix;
    if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center) {
      const {
        x: x,
        y: y
      } = center;
      this.outTargetMatrix.translate(x, y), this.outTargetMatrix.rotate(angle), this.outTargetMatrix.translate(-x, -y);
    } else this.outTargetMatrix.rotate(angle);
    return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  scale(sx, sy, center) {
    return this.mode === TransformMode.matrix ? this.scaleMatrix(sx, sy, center) : this;
  }
  rotate(angle, center) {
    return this.mode === TransformMode.matrix ? this.rotateMatrix(angle, center) : this;
  }
  translateMatrix(dx, dy) {
    const sMatrix = this.outSourceMatrix;
    return _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), this.outTargetMatrix.translate(dx, dy), this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  translate(dx, dy) {
    return this.mode === TransformMode.matrix ? this.translateMatrix(dx, dy) : this;
  }
  simplify(target) {
    return this.mode === TransformMode.matrix ? this.simplifyMatrix(target) : this;
  }
  simplifyMatrix(target) {
    return this;
  }
};
DefaultTransformUtil = __decorate$M([injectable(), __metadata$E("design:paramtypes", [])], DefaultTransformUtil);

const defaultThemeObj = {
    arc: DefaultArcAttribute,
    area: DefaultAreaAttribute,
    circle: DefaultCircleAttribute,
    line: DefaultLineAttribute,
    path: DefaultPathAttribute,
    symbol: DefaultSymbolAttribute,
    text: DefaultTextAttribute,
    rect: DefaultRectAttribute,
    polygon: DefaultPolygonAttribute,
    star: DefaultStarAttribute,
    richtext: DefaultRichTextAttribute,
    richtextIcon: DefaultRichTextIconAttribute,
    image: DefaultImageAttribute,
    group: DefaultGroupAttribute,
    glyph: DefaultGlyphAttribute
  },
  themeKeys = Object.keys(defaultThemeObj);
function newThemeObj() {
  return {
    arc: Object.assign({}, defaultThemeObj.arc),
    area: Object.assign({}, defaultThemeObj.area),
    circle: Object.assign({}, defaultThemeObj.circle),
    line: Object.assign({}, defaultThemeObj.line),
    path: Object.assign({}, defaultThemeObj.path),
    symbol: Object.assign({}, defaultThemeObj.symbol),
    text: Object.assign({}, defaultThemeObj.text),
    rect: Object.assign({}, defaultThemeObj.rect),
    polygon: Object.assign({}, defaultThemeObj.polygon),
    star: Object.assign({}, defaultThemeObj.star),
    richtext: Object.assign({}, defaultThemeObj.richtext),
    richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
    image: Object.assign({}, defaultThemeObj.image),
    group: Object.assign({}, defaultThemeObj.group),
    glyph: Object.assign({}, defaultThemeObj.glyph)
  };
}
function combine(out, t) {
  Object.keys(t).forEach(k => {
    out[k] = t[k];
  });
}
const globalThemeObj = newThemeObj();
class Theme {
  constructor() {
    this.initTheme(), this.dirty = !1;
  }
  initTheme() {
    this._defaultTheme = {}, themeKeys.forEach(key => {
      this._defaultTheme[key] = Object.create(globalThemeObj[key]);
    }), this.combinedTheme = this._defaultTheme;
  }
  getTheme(group) {
    if (!group) return this.combinedTheme;
    if (!this.dirty) return this.combinedTheme;
    let parentTheme = {};
    const parentGroup = this.getParentWithTheme(group);
    return parentGroup && (parentTheme = parentGroup.theme), this.applyTheme(group, parentTheme), this.combinedTheme;
  }
  getParentWithTheme(group) {
    for (; group.parent;) if ((group = group.parent).theme) return group;
    return null;
  }
  applyTheme(group, pt, force = !1) {
    if (this.dirty) {
      const parentGroup = this.getParentWithTheme(group);
      if (parentGroup) {
        const parentTheme = parentGroup.theme;
        (parentTheme.dirty || force) && parentTheme.applyTheme(parentGroup, pt, !0);
      }
      this.userTheme ? this.doCombine(parentGroup && parentGroup.theme.combinedTheme) : (parentGroup ? this.combinedTheme = parentGroup.theme.combinedTheme : (this.combinedTheme = this._defaultTheme, Logger.getInstance().warn("未知错误，走到不应该走的区域里")), this.dirty = !1);
    }
    return this.combinedTheme;
  }
  doCombine(parentCombinedTheme) {
    const userTheme = this.userTheme,
      combinedTheme = this.combinedTheme;
    themeKeys.forEach(k => {
      const obj = Object.create(globalThemeObj[k]);
      parentCombinedTheme && parentCombinedTheme[k] && combine(obj, parentCombinedTheme[k]), combinedTheme[k] && combine(obj, combinedTheme[k]), userTheme[k] && combine(obj, userTheme[k]), this.combinedTheme[k] = obj;
    }), userTheme.common && themeKeys.forEach(k => {
      combine(this.combinedTheme[k], userTheme.common);
    }), this.dirty = !1;
  }
  setTheme(t, g) {
    let userTheme = this.userTheme;
    userTheme ? Object.keys(t).forEach(k => {
      userTheme[k] ? Object.assign(userTheme[k], t[k]) : userTheme[k] = Object.assign({}, t[k]);
    }) : userTheme = t, this.userTheme = userTheme, this.dirty = !0, this.dirtyChildren(g);
  }
  resetTheme(t, g) {
    this.userTheme = t, this.dirty = !0, this.dirtyChildren(g);
  }
  dirtyChildren(g) {
    g.forEachChildren(item => {
      item.isContainer && (item.theme && (item.theme.dirty = !0), this.dirtyChildren(item));
    });
  }
}
const globalTheme = new Theme();
function getTheme(graphic, theme) {
  return graphic.glyphHost ? getTheme(graphic.glyphHost) : theme ? (graphic.isContainer, theme) : getThemeFromGroup(graphic) || graphic.attachedThemeGraphic && getTheme(graphic.attachedThemeGraphic) || globalTheme.getTheme();
}
function getThemeFromGroup(graphic) {
  let g;
  if (g = graphic.isContainer ? graphic : graphic.parent, g) {
    for (; g && !g.theme;) g = g.parent;
    return g ? (g.theme || g.createTheme(), g.theme.getTheme(g)) : globalTheme.getTheme();
  }
  return null;
}

var __awaiter$3 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class Node extends EventEmitter {
  get previousSibling() {
    return this._prev;
  }
  get nextSibling() {
    return this._next;
  }
  get children() {
    return this.getChildren();
  }
  get firstChild() {
    return this._firstChild;
  }
  get lastChild() {
    return this._lastChild;
  }
  get count() {
    return this._count;
  }
  get childrenCount() {
    return this._idMap ? this._idMap.size : 0;
  }
  constructor() {
    super(), this._uid = Generator.GenAutoIncrementId(), this._firstChild = null, this._lastChild = null, this.parent = null, this._count = 1;
  }
  forEachChildren(cb, reverse = !1) {
    if (reverse) {
      let child = this._lastChild,
        i = 0;
      for (; child;) {
        if (cb(child, i++)) return;
        child = child._prev;
      }
    } else {
      let child = this._firstChild,
        i = 0;
      for (; child;) {
        if (cb(child, i++)) return;
        child = child._next;
      }
    }
  }
  forEachChildrenAsync(cb, reverse = !1) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (reverse) {
        let child = this._lastChild,
          i = 0;
        for (; child;) {
          let breakTag = cb(child, i++);
          if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
          child = child._prev;
        }
      } else {
        let child = this._firstChild,
          i = 0;
        for (; child;) {
          let breakTag = cb(child, i++);
          if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
          child = child._next;
        }
      }
    });
  }
  forEach(cb) {
    return this.forEachChildren(cb);
  }
  appendChild(node, highPerformance = !0) {
    if (this._uid === node._uid) return null;
    if (!highPerformance && node.isAncestorsOf(this)) throw new Error("【Node::appendChild】不能将父辈元素append为子元素");
    return node.parent && node.parent.removeChild(node), node.parent = this, this._lastChild ? (this._lastChild._next = node, node._prev = this._lastChild, this._lastChild = node) : (this._firstChild = this._lastChild = node, node._prev = node._next = null), this._idMap || (this._idMap = new Map()), this._idMap.set(node._uid, node), this.setCount(node.count), this._structEdit = !0, node;
  }
  appendChildArrHighPerformance(nodes, replace = !1) {
    return console.error("暂不支持该函数"), nodes;
  }
  insertBefore(newNode, referenceNode) {
    if (!referenceNode) return this.appendChild(newNode);
    if (this === newNode || newNode === referenceNode) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, newNode._prev = referenceNode._prev, referenceNode._prev ? referenceNode._prev._next = newNode : this._firstChild = newNode, referenceNode._prev = newNode, newNode._next = referenceNode, this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode);
  }
  insertAfter(newNode, referenceNode) {
    if (!referenceNode) return this.appendChild(newNode);
    if (this === newNode || newNode === referenceNode) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertAfter】不能将父辈元素insert为子元素");
    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, referenceNode._next ? (referenceNode._next._prev = newNode, newNode._next = referenceNode._next) : this._lastChild = newNode, referenceNode._next = newNode, newNode._prev = referenceNode, this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode);
  }
  insertInto(newNode, idx) {
    if (!this._ignoreWarn && this._nodeList && Logger.getInstance().warn("insertIntoKeepIdx和insertInto混用可能会存在错误"), idx >= this.childrenCount) return this.appendChild(newNode);
    if (this === newNode) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
    if (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, 0 === idx) newNode._next = this._firstChild, this._firstChild && (this._firstChild._prev = newNode), newNode._prev = null, this._firstChild = newNode;else {
      let child = this._firstChild;
      for (let i = 0; i < idx; i++) {
        if (!child) return null;
        i > 0 && (child = child._next);
      }
      if (!child) return null;
      newNode._next = child._next, newNode._prev = child, child._next = newNode, newNode._next && (newNode._next._prev = newNode);
    }
    return this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode;
  }
  insertIntoKeepIdx(newNode, idx) {
    if (this._nodeList || (this._nodeList = this.children), this._nodeList[idx]) {
      const node = this._nodeList[idx];
      return this._nodeList.splice(idx, 0, newNode), this.insertBefore(newNode, node);
    }
    let node;
    this._nodeList[idx] = newNode;
    for (let i = idx - 1; i >= 0 && (node = this._nodeList[i], !node); i--);
    if (node) return node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode);
    this._ignoreWarn = !0;
    const data = this.insertInto(newNode, 0);
    return this._ignoreWarn = !1, data;
  }
  removeChild(child) {
    if (!this._idMap) return null;
    if (!this._idMap.has(child._uid)) return null;
    if (this._idMap.delete(child._uid), this._nodeList) {
      const idx = this._nodeList.findIndex(n => n === child);
      idx >= 0 && this._nodeList.splice(idx, 1);
    }
    return child._prev ? child._prev._next = child._next : this._firstChild = child._next, child._next ? child._next._prev = child._prev : this._lastChild = child._prev, child.parent = null, child._prev = null, child._next = null, this._structEdit = !0, this.setCount(-child.count), child;
  }
  delete() {
    this.parent && this.parent.removeChild(this);
  }
  removeAllChild(deep) {
    if (!this._idMap) return;
    this._nodeList && (this._nodeList.length = 0);
    let child = this._firstChild;
    for (; child;) {
      const next = child._next;
      child.parent = null, child._prev = null, child._next = null, child = child._next, child = next;
    }
    this._firstChild = null, this._lastChild = null, this._idMap.clear(), this._structEdit = !0, this.setCount(1 - this._count);
  }
  replaceChild(newChild, oldChild) {
    throw new Error("暂不支持");
  }
  find(callback, deep = !1) {
    let target = null;
    return this.forEachChildren((node, index) => !(node === this || !callback(node, index)) && (target = node, !0)), deep && this.forEachChildren(child => {
      if (child.isContainer) {
        const node = child.find(callback, !0);
        if (node) return target = node, !0;
      }
      return !1;
    }), target;
  }
  findAll(callback, deep = !1) {
    let nodes = [];
    return this.forEachChildren((node, index) => {
      node !== this && callback(node, index) && nodes.push(node);
    }), deep && this.forEachChildren(child => {
      if (child.isContainer) {
        const targets = child.findAll(callback, !0);
        targets.length && (nodes = nodes.concat(targets));
      }
    }), nodes;
  }
  getElementById(id) {
    return this.find(node => node.id === id, !0);
  }
  findChildById(id) {
    return this.getElementById(id);
  }
  findChildByUid(uid) {
    return this._idMap && this._idMap.get(uid) || null;
  }
  getElementsByName(name) {
    return this.findAll(node => node.name === name, !0);
  }
  findChildrenByName(name) {
    return this.getElementsByName(name);
  }
  getElementsByType(type) {
    return this.findAll(node => node.type === type, !0);
  }
  getChildByName(name, deep = !1) {
    return this.find(node => node.name === name, deep);
  }
  getChildAt(idx) {
    let c = this._firstChild;
    if (!c) return null;
    for (let i = 0; i < idx; i++) {
      if (!c._next) return null;
      c = c._next;
    }
    return c;
  }
  at(idx) {
    return this.getChildAt(idx);
  }
  containNode(node) {
    if (!this._idMap) return !1;
    if (this._idMap.has(node._uid)) return !0;
    let child = this._firstChild;
    for (; child;) {
      if (child.containNode(node)) return !0;
      child = child._next;
    }
    return !1;
  }
  getRootNode() {
    let parent = this.parent;
    for (; null == parent ? void 0 : parent.parent;) parent = parent.parent;
    return parent || this;
  }
  hasChildNodes() {
    return null !== this._firstChild;
  }
  addChild(node) {
    return this.appendChild(node);
  }
  add(node) {
    return this.appendChild(node);
  }
  getChildren() {
    const nodes = [];
    let child = this._firstChild;
    for (; child;) nodes.push(child), child = child._next;
    return nodes;
  }
  isChildOf(node) {
    return !!this.parent && this.parent._uid === node._uid;
  }
  isParentOf(node) {
    return node.isChildOf(this);
  }
  isDescendantsOf(node) {
    let parent = this.parent;
    if (!parent) return !1;
    do {
      if (parent._uid === node._uid) return !0;
      parent = parent.parent;
    } while (null !== parent);
    return !1;
  }
  isAncestorsOf(node) {
    return node.isDescendantsOf(this);
  }
  getAncestor(idx) {
    throw new Error("暂不支持");
  }
  setAllDescendantsProps(propsName, propsValue) {
    let child = this._firstChild;
    for (; child;) child[propsName] = propsValue, child.setAllDescendantsProps(propsName, propsValue), child = child._next;
  }
  setCount(deltaCount) {
    this._count += deltaCount;
    let parent = this.parent;
    if (parent) do {
      parent._count += deltaCount, parent = parent.parent;
    } while (null !== parent);
  }
  clone() {
    throw new Error("暂不支持");
  }
  cloneTo(node) {
    throw new Error("暂不支持");
  }
  getParent() {
    return this.parent;
  }
  del(child) {
    return this.removeChild(child);
  }
  addEventListener(type, listener, options) {
    const capture = isBoolean(options, !0) && options || isObject(options) && options.capture,
      once = isObject(options) && options.once,
      context = isFunction(listener) ? void 0 : listener;
    return type = capture ? `${type}capture` : type, listener = isFunction(listener) ? listener : listener.handleEvent, once ? super.once(type, listener, context) : super.on(type, listener, context), this;
  }
  on(type, listener, options) {
    return this.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    const capture = isBoolean(options, !0) && options || isObject(options) && options.capture,
      context = isFunction(listener) ? void 0 : listener;
    type = capture ? `${type}capture` : type, listener = isFunction(listener) ? listener : listener.handleEvent;
    const once = isObject(options) && options.once;
    return super.off(type, listener, context, once), this;
  }
  off(type, listener, options) {
    return this.removeEventListener(type, listener, options);
  }
  once(type, listener, options) {
    return isObject(options) ? (options.once = !0, this.addEventListener(type, listener, options)) : this.addEventListener(type, listener, {
      once: !0
    });
  }
  removeAllEventListeners() {
    return super.removeAllListeners(), this;
  }
  removeAllListeners() {
    return this.removeAllEventListeners();
  }
  dispatchEvent(event, ...args) {
    return super.emit(event.type, event, ...args), !event.defaultPrevented;
  }
  emit(event, data) {
    return this.dispatchEvent(event, data);
  }
  release() {
    this.removeAllListeners();
  }
}

class FederatedEvent {
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get x() {
    return this.canvas.x;
  }
  get y() {
    return this.canvas.y;
  }
  get canvasX() {
    return this.canvas.x;
  }
  get canvasY() {
    return this.canvas.y;
  }
  get viewX() {
    return this.viewport.x;
  }
  get viewY() {
    return this.viewport.y;
  }
  constructor(manager) {
    this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = FederatedEvent.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = {
      x: 0,
      y: 0
    }, this.page = {
      x: 0,
      y: 0
    }, this.canvas = {
      x: 0,
      y: 0
    }, this.viewport = {
      x: 0,
      y: 0
    }, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
  }
  composedPath() {
    return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.composedDetailPath(), this.path;
  }
  composedDetailPath() {
    return this.pickParams && this.pickParams.graphic ? (this.detailPath = this.path.slice(), this._composedDetailPath(this.pickParams)) : this.detailPath = this.path.slice(), this.detailPath;
  }
  _composedDetailPath(params) {
    if (params && params.graphic) {
      const g = params.graphic;
      if (g.stage) {
        const path = g.stage.eventSystem.manager.propagationPath(g);
        this.detailPath.push(path), this._composedDetailPath(params.params);
      }
    }
  }
  preventDefault() {
    try {
      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault();
    } catch (err) {
      this.nativeEvent.preventDefault && isFunction(this.nativeEvent.preventDefault) && this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = !0;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = !0;
  }
  stopPropagation() {
    try {
      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.stopPropagation();
    } catch (err) {
      this.nativeEvent.stopPropagation && isFunction(this.nativeEvent.stopPropagation) && this.nativeEvent.stopPropagation();
    }
    this.propagationStopped = !0;
  }
  initEvent() {}
  initUIEvent() {}
  clone() {
    throw new Error("Method not implemented.");
  }
}

class CustomEvent extends FederatedEvent {
  constructor(eventName, object) {
    super(), this.type = eventName, this.detail = object;
  }
}

const EventTarget = {
  dispatchEvent(e) {
    var _a;
    if (!(e instanceof FederatedEvent)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    return e.defaultPrevented = !1, e.path = [], e.detailPath && (e.detailPath = []), e.target = this, null === (_a = null == e ? void 0 : e.manager) || void 0 === _a || _a.dispatchEvent(e), !e.defaultPrevented;
  },
  emit(eventName, object) {
    return this.dispatchEvent(new CustomEvent(eventName, object));
  }
};

class ResourceLoader {
  static GetImage(url, mark) {
    var _a;
    const data = ResourceLoader.cache.get(url);
    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadFail(url);
    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(url, data.data) : ResourceLoader.loadImage(url, mark);
  }
  static GetSvg(svgStr, mark) {
    var _a;
    let data = ResourceLoader.cache.get(svgStr);
    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadFail(svgStr);
    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(svgStr, data.data) : (data = {
      type: "image",
      loadState: "init"
    }, ResourceLoader.cache.set(svgStr, data), data.dataPromise = application.global.loadSvg(svgStr), data.dataPromise ? (data.waitingMark = [mark], data.dataPromise.then(res => {
      var _a;
      data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map((mark, index) => {
        (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(svgStr, res.data)) : (data.loadState = "fail", mark.imageLoadFail(svgStr));
      }), data.waitingMark && (data.waitingMark = []);
    })) : (data.loadState = "fail", mark.imageLoadFail(svgStr)));
  }
  static GetFile(url, type) {
    let data = ResourceLoader.cache.get(url);
    return data ? "fail" === data.loadState ? Promise.reject() : "init" === data.loadState || "loading" === data.loadState ? data.dataPromise.then(data => data.data) : Promise.resolve(data.data) : (data = {
      type: type,
      loadState: "init"
    }, ResourceLoader.cache.set(url, data), "arrayBuffer" === type ? data.dataPromise = application.global.loadArrayBuffer(url) : "blob" === type ? data.dataPromise = application.global.loadBlob(url) : "json" === type && (data.dataPromise = application.global.loadJson(url)), data.dataPromise.then(data => data.data));
  }
  static loading() {
    setTimeout(() => {
      if (!ResourceLoader.isLoading && ResourceLoader.toLoadAueue.length) {
        ResourceLoader.isLoading = !0;
        const tasks = ResourceLoader.toLoadAueue.splice(0, 10),
          promises = [];
        tasks.forEach(task => {
          const {
              url: url,
              marks: marks
            } = task,
            data = {
              type: "image",
              loadState: "init"
            };
          if (ResourceLoader.cache.set(url, data), data.dataPromise = application.global.loadImage(url), data.dataPromise) {
            data.waitingMark = marks;
            const end = data.dataPromise.then(res => {
              var _a;
              data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map((mark, index) => {
                (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(url, res.data)) : (data.loadState = "fail", mark.imageLoadFail(url));
              }), data.waitingMark && (data.waitingMark = []);
            });
            promises.push(end);
          } else data.loadState = "fail", marks.forEach(mark => mark.imageLoadFail(url));
        }), Promise.all(promises).then(() => {
          ResourceLoader.isLoading = !1, this.onLoadSuccessCb.forEach(cb => cb()), ResourceLoader.loading();
        }).catch(error => {
          console.error(error), ResourceLoader.isLoading = !1, this.onLoadSuccessCb.forEach(cb => cb()), ResourceLoader.loading();
        });
      }
    }, 0);
  }
  static loadImage(url, mark) {
    const index = getIndex(url, ResourceLoader.toLoadAueue);
    if (-1 !== index) return ResourceLoader.toLoadAueue[index].marks.push(mark), void ResourceLoader.loading();
    ResourceLoader.toLoadAueue.push({
      url: url,
      marks: [mark]
    }), ResourceLoader.loading();
  }
  static improveImageLoading(url) {
    const index = getIndex(url, ResourceLoader.toLoadAueue);
    if (-1 !== index) {
      const elememt = ResourceLoader.toLoadAueue.splice(index, 1);
      ResourceLoader.toLoadAueue.unshift(elememt[0]);
    }
  }
  static onLoadSuccess(cb) {
    this.onLoadSuccessCb.push(cb);
  }
}
function getIndex(url, arr) {
  for (let i = 0; i < arr.length; i++) if (arr[i].url === url) return i;
  return -1;
}
ResourceLoader.cache = new Map(), ResourceLoader.isLoading = !1, ResourceLoader.toLoadAueue = [], ResourceLoader.onLoadSuccessCb = [];

var Edge;
!function (Edge) {
  Edge[Edge.Top = 1] = "Top", Edge[Edge.Right = 2] = "Right", Edge[Edge.Bottom = 4] = "Bottom", Edge[Edge.Left = 8] = "Left", Edge[Edge.ALL = 15] = "ALL";
}(Edge || (Edge = {}));
const _strokeVec4 = [!1, !1, !1, !1];
const parseStroke = stroke => {
  var _a;
  let isFullStroke = !0;
  if (isBoolean(stroke, !0)) {
    for (let i = 0; i < 4; i++) _strokeVec4[i] = stroke, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i]) && void 0 !== _a && !_a));
    isFullStroke = stroke;
  } else if (Array.isArray(stroke)) for (let i = 0; i < 4; i++) _strokeVec4[i] = !!stroke[i], isFullStroke && (isFullStroke = !!_strokeVec4[i]);else _strokeVec4[0] = !1, _strokeVec4[1] = !1, _strokeVec4[2] = !1, _strokeVec4[3] = !1;
  return {
    isFullStroke: isFullStroke,
    stroke: _strokeVec4
  };
};
const _paddingVec4 = [0, 0, 0, 0];
const parsePadding = padding => padding ? isArray(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], _paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], _paddingVec4) : padding : padding : 0;
const _coords = [{
    x: 0,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 0,
    y: 0
  }],
  indexList = [1, 2, 3, 0, 1, 2, 3, 0];
function circleBounds(startAngle, endAngle, radius, bounds) {
  for (; startAngle >= pi2;) startAngle -= pi2;
  for (; startAngle < 0;) startAngle += pi2;
  for (; startAngle > endAngle;) endAngle += pi2;
  _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;
  const startIdx = Math.ceil(startAngle / halfPi$1) % 4,
    endIdx = Math.ceil(endAngle / halfPi$1) % 4;
  if (bounds.add(cos(startAngle) * radius, sin(startAngle) * radius), bounds.add(cos(endAngle) * radius, sin(endAngle) * radius), startIdx !== endIdx || endAngle - startAngle > pi) {
    let match = !1;
    for (let i = 0; i < indexList.length; i++) if (match || startIdx !== indexList[i]) {
      if (match && endIdx === indexList[i]) break;
      if (match) {
        const p = _coords[indexList[i]];
        bounds.add(p.x, p.y);
      }
    } else {
      match = !0;
      const p = _coords[startIdx];
      bounds.add(p.x, p.y);
    }
  }
}
function pointInterpolation(pointA, pointB, ratio) {
  const {
      x: x,
      y: y
    } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio),
    {
      x: x1,
      y: y1
    } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio),
    point = new Point(x, y, x1, y1);
  return point.defined = pointB.defined, point;
}
function pointsInterpolation(pointsA, pointsB, ratio) {
  if (!pointsA || !pointsB) return [];
  Array.isArray(pointsA) || (pointsA = [pointsA]), Array.isArray(pointsB) || (pointsB = [pointsB]);
  let points = [];
  if (pointsA.length > pointsB.length) {
    points = pointsB.map(point => {
      const p = new Point(point.x, point.y, point.x1, point.y1);
      return p.defined = point.defined, p;
    });
    for (let i = 0; i < pointsB.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
  } else {
    points = pointsB.map(point => {
      const p = new Point(point.x, point.y, point.x1, point.y1);
      return p.defined = point.defined, p;
    });
    for (let i = 0; i < pointsA.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
  }
  return points;
}
function getAttributeFromDefaultAttrList(attr, key) {
  if (isArray(attr)) {
    let val;
    for (let i = 0; i < attr.length && void 0 === val; i++) val = attr[i][key];
    return val;
  }
  return attr[key];
}
const _calculateLineHeight = (lineHeight, fontSize) => {
  if (isString(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
    return fontSize * (Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100);
  }
  return lineHeight;
};
const calculateLineHeight = (lineHeight, fontSize) => {
  const _lh = _calculateLineHeight(lineHeight, fontSize);
  return isNaN(_lh) ? _lh : Math.max(fontSize, _lh);
};

class BaseSymbol {
  bounds(size, bounds) {
    if (isNumber(size)) {
      const halfS = size / 2;
      bounds.x1 = -halfS, bounds.x2 = halfS, bounds.y1 = -halfS, bounds.y2 = halfS;
    } else bounds.x1 = -size[0] / 2, bounds.x2 = size[0] / 2, bounds.y1 = -size[1] / 2, bounds.y2 = size[1] / 2;
  }
  parseSize(size) {
    return isNumber(size) ? size : Math.min(size[0], size[1]);
  }
}

function circle(ctx, r, x, y, z) {
  return z ? ctx.arc(x, y, r, 0, tau, !1, z) : ctx.arc(x, y, r, 0, tau), !1;
}
class CircleSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "circle", this.pathStr = "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0";
  }
  draw(ctx, size, x, y, z) {
    return circle(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return circle(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x - r}, ${y} a ${r},${r} 0 1,0 ${2 * r},0 a ${r},${r} 0 1,0 -${2 * r},0`;
  }
}
var circle$1 = new CircleSymbol();

function cross(ctx, r, x, y, z) {
  return ctx.moveTo(-3 * r + x, -r + y, z), ctx.lineTo(-r + x, -r + y, z), ctx.lineTo(-r + x, -3 * r + y, z), ctx.lineTo(r + x, -3 * r + y, z), ctx.lineTo(r + x, -r + y, z), ctx.lineTo(3 * r + x, -r + y, z), ctx.lineTo(3 * r + x, r + y, z), ctx.lineTo(r + x, r + y, z), ctx.lineTo(r + x, 3 * r + y, z), ctx.lineTo(-r + x, 3 * r + y, z), ctx.lineTo(-r + x, r + y, z), ctx.lineTo(-3 * r + x, r + y, z), ctx.closePath(), !0;
}
function crossOffset(ctx, r, x, y, offset, z) {
  return ctx.moveTo(-3 * r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, r + y + offset, z), ctx.lineTo(-3 * r + x - offset, r + y + offset, z), ctx.closePath(), !0;
}
class CrossSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "cross", this.pathStr = "M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z";
  }
  draw(ctx, size, x, y, z) {
    return cross(ctx, this.parseSize(size) / 6, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return crossOffset(ctx, this.parseSize(size) / 6, x, y, offset, z);
  }
}
var cross$1 = new CrossSymbol();

function diamond(ctx, r, x, y, z) {
  return ctx.moveTo(x, y - r, z), ctx.lineTo(r + x, y, z), ctx.lineTo(x, y + r, z), ctx.lineTo(x - r, y, z), ctx.closePath(), !0;
}
class DiamondSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "diamond", this.pathStr = "M-0.5,0L0,-0.5L0.5,0L0,0.5Z";
  }
  draw(ctx, size, x, y, z) {
    return diamond(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawFitDir(ctx, size, x, y, z) {
    return diamond(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return diamond(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
}
var diamond$1 = new DiamondSymbol();

function square(ctx, r, x, y) {
  const wh = 2 * r;
  return ctx.rect(x - r, y - r, wh, wh), !1;
}
class SquareSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "square", this.pathStr = "M-0.5,-0.5h1v1h-1Z";
  }
  draw(ctx, size, x, y) {
    return square(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return square(ctx, this.parseSize(size) / 2 + offset, x, y);
  }
}
var square$1 = new SquareSymbol();

function trianglUpOffset(ctx, r, x, y, offset = 0) {
  return ctx.moveTo(x + r + 2 * offset, r + y + offset), ctx.lineTo(x - r - 2 * offset, r + y + offset), ctx.lineTo(x, y - r - 2 * offset), ctx.closePath(), !0;
}
class TriangleUpSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleUp", this.pathStr = "M0.5,0.5 L-0.5,0.5 L0,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglUpOffset(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglUpOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
}
var triangleUp = new TriangleUpSymbol();

class TriangleSymbol extends TriangleUpSymbol {
  constructor() {
    super(...arguments), this.type = "triangle";
  }
}
var triangle = new TriangleSymbol();

const kr = Math.sin(Math.PI / 10) / Math.sin(7 * Math.PI / 10),
  kx = Math.sin(tau / 10) * kr,
  ky = -Math.cos(tau / 10) * kr;
function star(ctx, r, transX, transY) {
  const x = kx * r,
    y = ky * r;
  ctx.moveTo(transX, -r + transY), ctx.lineTo(x + transX, y + transY);
  for (let i = 1; i < 5; ++i) {
    const a = tau * i / 5,
      c = Math.cos(a),
      s = Math.sin(a);
    ctx.lineTo(s * r + transX, -c * r + transY), ctx.lineTo(c * x - s * y + transX, s * x + c * y + transY);
  }
  return ctx.closePath(), !0;
}
class StarSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "star", this.pathStr = "M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z";
  }
  draw(ctx, size, transX, transY) {
    return star(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return star(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
}
var star$1 = new StarSymbol();

const sqrt3$1 = sqrt(3);
function arrow(ctx, r, transX, transY) {
  const triangleH = r,
    trangleBottomSide = triangleH / sqrt3$1,
    rectW = trangleBottomSide / 5,
    rectH = r;
  return ctx.moveTo(0 + transX, -triangleH + transY), ctx.lineTo(trangleBottomSide / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, transY), ctx.lineTo(-trangleBottomSide / 2 + transX, transY), ctx.closePath(), !0;
}
class ArrowSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow", this.pathStr = "M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z";
  }
  draw(ctx, size, transX, transY) {
    return arrow(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
}
var arrow$1 = new ArrowSymbol();

function wedge(ctx, r, transX, transY) {
  const h = 2 * r;
  return ctx.moveTo(transX, -r + transY), ctx.lineTo(h / 3 / 2 + transX, r + transY), ctx.lineTo(-h / 3 / 2 + transX, r + transY), ctx.closePath(), !0;
}
class WedgeSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "wedge", this.pathStr = "M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z";
  }
  draw(ctx, size, transX, transY) {
    return wedge(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return wedge(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
}
var wedge$1 = new WedgeSymbol();

function stroke(ctx, r, transX, transY) {
  return ctx.moveTo(-r + transX, transY), ctx.lineTo(transX, r + transY), !1;
}
class StrokeSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "stroke", this.pathStr = "";
  }
  draw(ctx, size, transX, transY) {
    return stroke(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return stroke(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
}
var stroke$1 = new StrokeSymbol();

const c = -.5,
  s = sqrt(3) / 2,
  k = 1 / sqrt(12);
function wye(ctx, r, transX, transY) {
  const x0 = r / 2,
    y0 = r * k,
    x1 = x0,
    y1 = r * k + r,
    x2 = -x1,
    y2 = y1;
  return ctx.moveTo(x0 + transX, y0 + transY), ctx.lineTo(x1 + transX, y1 + transY), ctx.lineTo(x2 + transX, y2 + transY), ctx.lineTo(c * x0 - s * y0 + transX, s * x0 + c * y0 + transY), ctx.lineTo(c * x1 - s * y1 + transX, s * x1 + c * y1 + transY), ctx.lineTo(c * x2 - s * y2 + transX, s * x2 + c * y2 + transY), ctx.lineTo(c * x0 + s * y0 + transX, c * y0 - s * x0 + transY), ctx.lineTo(c * x1 + s * y1 + transX, c * y1 - s * x1 + transY), ctx.lineTo(c * x2 + s * y2 + transX, c * y2 - s * x2 + transY), ctx.closePath(), !1;
}
class WyeSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "wye", this.pathStr = "M0.25 0.14433756729740646L0.25 0.6443375672974064L-0.25 0.6443375672974064L-0.25 0.14433756729740643L-0.6830127018922193 -0.10566243270259357L-0.4330127018922193 -0.5386751345948129L0 -0.28867513459481287L0.4330127018922193 -0.5386751345948129L0.6830127018922193 -0.10566243270259357Z";
  }
  draw(ctx, size, transX, transY) {
    return wye(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return wye(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
}
var wye$1 = new WyeSymbol();

function trianglLeftOffset(ctx, r, x, y, offset) {
  return ctx.moveTo(-r + x - 2 * offset, y), ctx.lineTo(r + x + offset, r + y + 2 * offset), ctx.lineTo(r + x + offset, y - r - 2 * offset), ctx.closePath(), !0;
}
class TriangleLeftSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleLeft", this.pathStr = "M-0.5,0 L0.5,0.5 L0.5,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglLeftOffset(ctx, this.parseSize(size) / 2, x, y, 0);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglLeftOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
}
var triangleLeft = new TriangleLeftSymbol();

function trianglRightOffset(ctx, r, x, y, offset = 0) {
  return ctx.moveTo(x - r - offset, r + y + 2 * offset), ctx.lineTo(r + x + 2 * offset, y), ctx.lineTo(x - r - offset, y - r - 2 * offset), ctx.closePath(), !0;
}
class TriangleRightSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleRight", this.pathStr = "M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglRightOffset(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglRightOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
}
var triangleRight = new TriangleRightSymbol();

function trianglDownOffset(ctx, r, x, y, offset = 0) {
  return ctx.moveTo(x - r - 2 * offset, y - r - offset), ctx.lineTo(x + r + 2 * offset, y - r - offset), ctx.lineTo(x, y + r + 2 * offset), ctx.closePath(), !0;
}
class TriangleDownSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleDown", this.pathStr = "M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglDownOffset(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglDownOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
}
var triangleDown = new TriangleDownSymbol();

const sqrt3 = sqrt(3);
function thinTriangle(ctx, r, x, y) {
  const h = r * sqrt3;
  return ctx.moveTo(x, y + -h / 3 * 2), ctx.lineTo(r + x, y + h), ctx.lineTo(x - r, y + h), ctx.closePath(), !0;
}
class ThinTriangleSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "thinTriangle", this.pathStr = "M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z";
  }
  draw(ctx, size, x, y) {
    return thinTriangle(ctx, this.parseSize(size) / 2 / sqrt3, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return thinTriangle(ctx, this.parseSize(size) / 2 / sqrt3 + offset, x, y);
  }
}
var thinTriangle$1 = new ThinTriangleSymbol();

function arrow2Left(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(r + transX, transY - r2), ctx.lineTo(transX - r, transY), ctx.lineTo(r + transX, r2 + transY), !0;
}
class Arrow2LeftSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Left", this.pathStr = "M 0.25 -0.5 L -0.25 0 l 0.25 0.5";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Left(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Left(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
}
var arrow2Left$1 = new Arrow2LeftSymbol();

function arrow2Right(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r, transY - r2), ctx.lineTo(transX + r, transY), ctx.lineTo(transX - r, r2 + transY), !0;
}
class Arrow2RightSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Right", this.pathStr = "M -0.25 -0.5 l 0.25 0 l -0.25 0.5";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Right(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Right(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
}
var arrow2Right$1 = new Arrow2RightSymbol();

function arrow2Up(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r2, transY + r), ctx.lineTo(transX, transY - r), ctx.lineTo(transX + r2, transY + r), !0;
}
class Arrow2UpSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Up", this.pathStr = "M -0.5 0.25 L 0 -0.25 l 0.5 0.25";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Up(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Up(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
}
var arrow2Up$1 = new Arrow2UpSymbol();

function arrow2Down(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r2, transY - r), ctx.lineTo(transX, transY + r), ctx.lineTo(transX + r2, transY - r), !0;
}
class Arrow2DownSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Down", this.pathStr = "M -0.5 -0.25 L 0 0.25 l 0.5 -0.25";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Down(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Down(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
}
var arrow2Down$1 = new Arrow2DownSymbol();

function lineV(ctx, r, x, y, z) {
  return ctx.moveTo(x, y - r), ctx.lineTo(x, y + r), !0;
}
class LineVSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "lineV", this.pathStr = "M0,-0.5L0,0.5";
  }
  draw(ctx, size, x, y, z) {
    return lineV(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return lineV(ctx, this.parseSize(size) / 2 + offset, x, y);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x}, ${y - r} L ${x},${y + r}`;
  }
}
var lineV$1 = new LineVSymbol();

function lineH(ctx, r, x, y, z) {
  return ctx.moveTo(x - r, y), ctx.lineTo(x + r, y), !0;
}
class LineHSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "lineH", this.pathStr = "M-0.5,0L0.5,0";
  }
  draw(ctx, size, x, y, z) {
    return lineH(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return lineH(ctx, this.parseSize(size) / 2 + offset, x, y);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x - r}, ${y} L ${x + r},${y}`;
  }
}
var lineH$1 = new LineHSymbol();

function close(ctx, r, x, y, z) {
  return ctx.moveTo(x - r, y - r), ctx.lineTo(x + r, y + r), ctx.moveTo(x + r, y - r), ctx.lineTo(x - r, y + r), !0;
}
class CloseSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "close", this.pathStr = "M-0.5,-0.5L0.5,0.5,M0.5,-0.5L-0.5,0.5";
  }
  draw(ctx, size, x, y, z) {
    return close(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return close(ctx, this.parseSize(size) / 2 + offset, x, y);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x - r}, ${y - r} L ${x + r},${y + r} M ${x + r}, ${y - r} L ${x - r},${y + r}`;
  }
}
var close$1 = new CloseSymbol();

function rectSizeArray(ctx, size, x, y) {
  return ctx.rect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]), !1;
}
function rectSize(ctx, size, x, y) {
  const w = size,
    h = size / 2;
  return ctx.rect(x - w / 2, y - h / 2, w, h), !1;
}
class RectSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "rect", this.pathStr = "M -0.5,0.25 L 0.5,0.25 L 0.5,-0.25,L -0.5,-0.25 Z";
  }
  draw(ctx, size, x, y) {
    return isNumber(size) ? rectSize(ctx, size, x, y) : rectSizeArray(ctx, size, x, y);
  }
  drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
    isNumber(size) && (size = [size, size / 2]);
    const drawLength = 2 * (size[0] + size[1]) * clipRange,
      points = [{
        x: x + size[0] / 2,
        y: y - size[1] / 2
      }, {
        x: x + size[0] / 2,
        y: y + size[1] / 2
      }, {
        x: x - size[0] / 2,
        y: y + size[1] / 2
      }, {
        x: x - size[0] / 2,
        y: y - size[1] / 2
      }];
    let currLength = 0,
      lastP = points[3];
    ctx.moveTo(lastP.x, lastP.y);
    for (let i = 0; i < points.length; i++) {
      const p = points[i],
        len = Math.sqrt((p.x - lastP.x) * (p.x - lastP.x) + (p.y - lastP.y) * (p.y - lastP.y));
      if (currLength + len > drawLength) {
        const dx = (p.x - lastP.x) * (drawLength - currLength) / len,
          dy = (p.y - lastP.y) * (drawLength - currLength) / len;
        ctx.lineTo(lastP.x + dx, lastP.y + dy);
        break;
      }
      ctx.lineTo(p.x, p.y), lastP = p, currLength += len;
    }
    return !1;
  }
  drawOffset(ctx, size, x, y, offset) {
    return isNumber(size) ? rectSize(ctx, size + 2 * offset, x, y) : rectSizeArray(ctx, [size[0] + 2 * offset, size[1] + 2 * offset], x, y);
  }
}
var rect = new RectSymbol();

const tempBounds = new AABBBounds();
class CustomSymbolClass {
  constructor(type, path, isSvg = !1) {
    this.pathStr = "", this.type = type, isArray(path) ? this.svgCache = path : this.path = path, this.isSvg = isSvg;
  }
  drawOffset(ctx, size, x, y, offset, z, cb) {
    return size = this.parseSize(size), this.isSvg ? !!this.svgCache && (this.svgCache.forEach(item => {
      ctx.beginPath(), renderCommandList(item.path.commandList, ctx, x, y, size, size), cb && cb(item.path, item.attribute);
    }), !1) : (renderCommandList(this.path.commandList, ctx, x, y, size + offset, size + offset), !1);
  }
  draw(ctx, size, x, y, z, cb) {
    return size = this.parseSize(size), this.drawOffset(ctx, size, x, y, 0, z, cb);
  }
  parseSize(size) {
    return isNumber(size) ? size : Math.min(size[0], size[1]);
  }
  drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
    return size = this.parseSize(size), this.isSvg ? !!this.svgCache && (this.svgCache.forEach(item => {
      item.path.drawWithClipRange(ctx, size, x, y, clipRange), cb && cb(item.path, item.attribute);
    }), !1) : (this.path.drawWithClipRange(ctx, size, x, y, clipRange), !1);
  }
  bounds(size, bounds) {
    if (size = this.parseSize(size), this.isSvg) {
      if (!this.svgCache) return;
      return bounds.clear(), void this.svgCache.forEach(({
        path: path
      }) => {
        tempBounds.x1 = path.bounds.x1 * size, tempBounds.y1 = path.bounds.y1 * size, tempBounds.x2 = path.bounds.x2 * size, tempBounds.y2 = path.bounds.y2 * size, bounds.union(tempBounds);
      });
    }
    this.path.bounds && (bounds.x1 = this.path.bounds.x1 * size, bounds.y1 = this.path.bounds.y1 * size, bounds.x2 = this.path.bounds.x2 * size, bounds.y2 = this.path.bounds.y2 * size);
  }
}

const builtinSymbols = [circle$1, cross$1, diamond$1, square$1, thinTriangle$1, triangle, star$1, arrow$1, wedge$1, stroke$1, wye$1, triangleLeft, triangleRight, triangleUp, triangleDown, arrow2Left$1, arrow2Right$1, arrow2Up$1, arrow2Down$1, rect, lineV$1, lineH$1, close$1];
const builtinSymbolsMap = {};
builtinSymbols.forEach(symbol => {
  builtinSymbolsMap[symbol.type] = symbol;
});
const builtInSymbolStrMap = {
  arrowLeft: "M 0.25 -0.5 L -0.25 0 l 0.5 0.5",
  arrowRight: "M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5",
  rectRound: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
  roundLine: "M 1.2392 -0.258 L -1.3432 -0.258 C -1.4784 -0.258 -1.588 -0.1436 -1.588 -0.002 c 0 0.1416 0.1096 0.256 0.2448 0.256 l 2.5824 0 c 0.1352 0 0.2448 -0.1144 0.2448 -0.256 C 1.484 -0.1436 1.3744 -0.258 1.2392 -0.258 z"
};

function getAllMatches(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  for (; match;) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) allmatches.push(match[index]);
    matches.push(allmatches), match = regex.exec(string);
  }
  return matches;
}

class XmlNode {
  constructor(tagname) {
    this.tagname = tagname, this.child = [], this[":@"] = {};
  }
  add(key, val) {
    "__proto__" === key && (key = "#__proto__"), this.child.push({
      [key]: val
    });
  }
  addChild(node) {
    "__proto__" === node.tagname && (node.tagname = "#__proto__"), node[":@"] && Object.keys(node[":@"]).length > 0 ? this.child.push({
      [node.tagname]: node.child,
      ":@": node[":@"]
    }) : this.child.push({
      [node.tagname]: node.child
    });
  }
}
function findClosingIndex(xmlData, str, i, errMsg) {
  const closingIndex = xmlData.indexOf(str, i);
  if (-1 === closingIndex) throw new Error(errMsg);
  return closingIndex + str.length - 1;
}
function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
  let attrBoundary,
    tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) ch === attrBoundary && (attrBoundary = "");else if ('"' === ch || "'" === ch) attrBoundary = ch;else if (ch === closingChar[0]) {
      if (!closingChar[1]) return {
        data: tagExp,
        index: index
      };
      if (xmlData[index + 1] === closingChar[1]) return {
        data: tagExp,
        index: index
      };
    } else "\t" === ch && (ch = " ");
    tagExp += ch;
  }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result) return;
  let tagExp = result.data;
  const closeIndex = result.index,
    separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp,
    attrExpPresent = !0;
  -1 !== separatorIndex && (tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, ""), tagExp = tagExp.substr(separatorIndex + 1));
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    -1 !== colonIndex && (tagName = tagName.substr(colonIndex + 1), attrExpPresent = tagName !== result.data.substr(colonIndex + 1));
  }
  return {
    tagName: tagName,
    tagExp: tagExp,
    closeIndex: closeIndex,
    attrExpPresent: attrExpPresent,
    rawTagName: rawTagName
  };
}
const attrsRegx = new RegExp("([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?", "gm");
class OrderedObjParser {
  constructor(options) {
    this.currentNode = null, this.options = options, this.tagsNodeStack = [], this.docTypeEntities = {};
  }
  addChild(currentNode, childNode, jPath) {
    const result = childNode.tagname;
    "string" == typeof result ? (childNode.tagname = result, currentNode.addChild(childNode)) : currentNode.addChild(childNode);
  }
  buildAttributesMap(attrStr, jPath, tagName) {
    const attrs = {};
    if (!attrStr) return;
    const matches = getAllMatches(attrStr, attrsRegx),
      len = matches.length;
    for (let i = 0; i < len; i++) {
      const attrName = matches[i][1],
        oldVal = matches[i][4],
        aName = attrName;
      attrName && (attrs[aName] = void 0 === oldVal || (isNaN(oldVal) ? oldVal : Number(oldVal)));
    }
    return attrs;
  }
  parseXml(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, "\n");
    const xmlObj = new XmlNode("!xml");
    let currentNode = xmlObj,
      textData = "",
      jPath = "";
    for (let i = 0; i < xmlData.length; i++) {
      if ("<" === xmlData[i]) {
        if ("/" === xmlData[i + 1]) {
          const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed."),
            propIndex = jPath.lastIndexOf(".");
          jPath = jPath.substring(0, propIndex), currentNode = this.tagsNodeStack.pop(), currentNode && currentNode.child && textData && currentNode.child[currentNode.child.length - 1][":@"] && (currentNode.child[currentNode.child.length - 1][":@"].text = textData), textData = "", i = closeIndex;
        } else if ("?" === xmlData[i + 1]) {
          i = readTagExp(xmlData, i, !1, "?>").closeIndex + 1;
        } else if ("!--" === xmlData.substr(i + 1, 3)) {
          i = findClosingIndex(xmlData, "--\x3e", i + 4, "Comment is not closed.");
        } else {
          const result = readTagExp(xmlData, i, !1);
          let tagName = result.tagName,
            tagExp = result.tagExp;
          const attrExpPresent = result.attrExpPresent,
            closeIndex = result.closeIndex;
          if (tagName !== xmlObj.tagname && (jPath += jPath ? "." + tagName : tagName), tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            "/" === tagName[tagName.length - 1] ? (tagName = tagName.substr(0, tagName.length - 1), jPath = jPath.substr(0, jPath.length - 1), tagExp = tagName) : tagExp = tagExp.substr(0, tagExp.length - 1);
            const childNode = new XmlNode(tagName);
            tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), jPath = jPath.substr(0, jPath.lastIndexOf("."));
          } else {
            const childNode = new XmlNode(tagName);
            this.tagsNodeStack.push(currentNode), tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), currentNode = childNode;
          }
          textData = "", i = closeIndex;
        }
      } else textData += xmlData[i];
    }
    return xmlObj.child;
  }
}

function prettify(node, options) {
  return compress(node);
}
function compress(arr, jPath) {
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i],
      property = propName(tagObj);
    if (void 0 !== property && tagObj[property]) {
      const val = compress(tagObj[property]);
      isLeafTag(val);
      tagObj[":@"] && assignAttributes(val, tagObj[":@"]), void 0 !== compressedObj[property] && compressedObj.hasOwnProperty(property) ? (Array.isArray(compressedObj[property]) || (compressedObj[property] = [compressedObj[property]]), compressedObj[property].push(val)) : compressedObj[property] = val;
    }
  }
  return compressedObj;
}
function propName(obj) {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (":@" !== key) return key;
  }
}
function assignAttributes(obj, attrMap, jpath) {
  if (attrMap) {
    const keys = Object.keys(attrMap),
      len = keys.length;
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      obj[atrrName] = attrMap[atrrName];
    }
  }
}
function isLeafTag(obj) {
  return 0 === Object.keys(obj).length;
}

class XMLParser {
  constructor(options) {
    this.options = Object.assign({}, XMLParser.defaultOptions, options);
  }
  valid(xml) {
    return xml.startsWith("<");
  }
  parse(xmlData) {
    if (!this.valid) return !1;
    const orderedResult = new OrderedObjParser(this.options).parseXml(xmlData);
    return prettify(orderedResult, this.options);
  }
}
XMLParser.defaultOptions = {};
function isSvg(str) {
  return str.startsWith("<svg") || str.startsWith("<?xml");
}

undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function boundStroke(bounds, halfW, miter, pad = 0) {
  return bounds.expand(halfW + (pad / 2 + (miter ? miterAdjustment(miter, halfW) : 0))), bounds;
}
function miterAdjustment(miter, strokeWidth) {
  return miter ? strokeWidth : 0;
}
let NUMBER_TYPE = 0;
function genNumberType() {
  return NUMBER_TYPE++;
}
var TextDirection;
!function (TextDirection) {
  TextDirection[TextDirection.HORIZONTAL = 0] = "HORIZONTAL", TextDirection[TextDirection.VERTICAL = 1] = "VERTICAL";
}(TextDirection || (TextDirection = {}));
function verticalLayout(text) {
  const nextCharacter = [];
  let flag = 0,
    currStr = "";
  for (let i = 0; i < text.length; i++) rotateText(text[i]) ? flag ? currStr += text[i] : (flag = 1, currStr = text[i]) : (flag && (nextCharacter.push({
    text: currStr,
    direction: TextDirection.VERTICAL
  }), currStr = "", flag = 0), nextCharacter.push({
    text: text[i],
    direction: TextDirection.HORIZONTAL
  }));
  return currStr && nextCharacter.push({
    text: currStr,
    direction: TextDirection.VERTICAL
  }), nextCharacter;
}
const rotateCharList = ["…", "（", "）", "—", "【", "】", "「", "」", "《", "》"],
  rotateCharMap = new Map();
rotateCharList.forEach(c => rotateCharMap.set(c, !0));
const noRotateCharList = [""],
  noRotateCharMap = new Map();
function rotateText(c) {
  if (rotateCharMap.has(c)) return !0;
  if (noRotateCharMap.has(c)) return !1;
  let rotate = !1;
  return c.codePointAt(0) < 256 && (rotate = !0), rotate;
}
noRotateCharList.forEach(c => noRotateCharMap.set(c, !0));

const ARC_NUMBER_TYPE = genNumberType();
const ARC3D_NUMBER_TYPE = genNumberType();
const AREA_NUMBER_TYPE = genNumberType();
const CIRCLE_NUMBER_TYPE = genNumberType();
genNumberType();
const GROUP_NUMBER_TYPE = genNumberType();
const IMAGE_NUMBER_TYPE = genNumberType();
const LINE_NUMBER_TYPE = genNumberType();
const PATH_NUMBER_TYPE = genNumberType();
const POLYGON_NUMBER_TYPE = genNumberType();
genNumberType();
const RECT_NUMBER_TYPE = genNumberType();
genNumberType();
const RICHTEXT_NUMBER_TYPE = genNumberType();
genNumberType();
const SYMBOL_NUMBER_TYPE = genNumberType();
const TEXT_NUMBER_TYPE = genNumberType();
const GraphicService = Symbol.for("GraphicService");
const GraphicCreator$1 = Symbol.for("GraphicCreator");
const SVG_PARSE_ATTRIBUTE_MAP = {
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-width": "lineWidth",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  stroke: "stroke",
  fill: "fill"
};
const SVG_PARSE_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_PARSE_ATTRIBUTE_MAP);

const DefaultStateAnimateConfig = {
  duration: 200,
  easing: "cubicOut"
};

function identityMat4(out) {
  return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, out[14] = 0, out[15] = 1, out;
}
function rotateX(out, a, rad) {
  const s = Math.sin(rad),
    c = Math.cos(rad),
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  return a !== out && (out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[4] = a10 * c + a20 * s, out[5] = a11 * c + a21 * s, out[6] = a12 * c + a22 * s, out[7] = a13 * c + a23 * s, out[8] = a20 * c - a10 * s, out[9] = a21 * c - a11 * s, out[10] = a22 * c - a12 * s, out[11] = a23 * c - a13 * s, out;
}
function rotateY(out, a, rad) {
  const s = Math.sin(rad),
    c = Math.cos(rad),
    a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  return a !== out && (out[4] = a[4], out[5] = a[5], out[6] = a[6], out[7] = a[7], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c - a20 * s, out[1] = a01 * c - a21 * s, out[2] = a02 * c - a22 * s, out[3] = a03 * c - a23 * s, out[8] = a00 * s + a20 * c, out[9] = a01 * s + a21 * c, out[10] = a02 * s + a22 * c, out[11] = a03 * s + a23 * c, out;
}
function rotateZ(out, a, rad) {
  const s = Math.sin(rad),
    c = Math.cos(rad),
    a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  return a !== out && (out[8] = a[8], out[9] = a[9], out[10] = a[10], out[11] = a[11], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c + a10 * s, out[1] = a01 * c + a11 * s, out[2] = a02 * c + a12 * s, out[3] = a03 * c + a13 * s, out[4] = a10 * c - a00 * s, out[5] = a11 * c - a01 * s, out[6] = a12 * c - a02 * s, out[7] = a13 * c - a03 * s, out;
}
function translate(out, a, v) {
  const x = v[0],
    y = v[1],
    z = v[2];
  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
  return a === out ? (out[12] = a[0] * x + a[4] * y + a[8] * z + a[12], out[13] = a[1] * x + a[5] * y + a[9] * z + a[13], out[14] = a[2] * x + a[6] * y + a[10] * z + a[14], out[15] = a[3] * x + a[7] * y + a[11] * z + a[15]) : (a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], out[0] = a00, out[1] = a01, out[2] = a02, out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x + a10 * y + a20 * z + a[12], out[13] = a01 * x + a11 * y + a21 * z + a[13], out[14] = a02 * x + a12 * y + a22 * z + a[14], out[15] = a03 * x + a13 * y + a23 * z + a[15]), out;
}
function mat3Tomat4(out, b) {
  out[0] = b.a, out[1] = b.b, out[2] = 0, out[3] = 0, out[4] = b.c, out[5] = b.d, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = b.e, out[13] = b.f, out[14] = 0, out[15] = 1;
}
function scaleMat4(out, a, v) {
  const x = v[0],
    y = v[1],
    z = v[2];
  return out[0] = a[0] * x, out[1] = a[1] * x, out[2] = a[2] * x, out[3] = a[3] * x, out[4] = a[4] * y, out[5] = a[5] * y, out[6] = a[6] * y, out[7] = a[7] * y, out[8] = a[8] * z, out[9] = a[9] * z, out[10] = a[10] * z, out[11] = a[11] * z, out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15], out;
}
function multiplyMat4Mat4(out, a, b) {
  const a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11],
    a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  let b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
}

function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
class DefaultMatrixAllocate {
  constructor() {
    this.pools = [];
  }
  allocate(a, b, c, d, e, f) {
    if (!this.pools.length) return new Matrix(a, b, c, d, e, f);
    const m = this.pools.pop();
    return m.a = a, m.b = b, m.c = c, m.d = d, m.e = e, m.f = f, m;
  }
  allocateByObj(matrix) {
    if (!this.pools.length) return new Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
    const m = this.pools.pop();
    return m.a = matrix.a, m.b = matrix.b, m.c = matrix.c, m.d = matrix.d, m.e = matrix.e, m.f = matrix.f, m;
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release(...params) {
    this.pools = [];
  }
}
class DefaultMat4Allocate {
  constructor() {
    this.pools = [];
  }
  static identity(out) {
    return identityMat4(out);
  }
  allocate() {
    if (!this.pools.length) return createMat4();
    const m = this.pools.pop();
    return DefaultMat4Allocate.identity(m), m;
  }
  allocateByObj(d) {
    let m;
    m = this.pools.length ? this.pools.pop() : createMat4();
    for (let i = 0; i < m.length; i++) m[i] = d[i];
    return m;
  }
  free(m) {
    m && this.pools.push(m);
  }
  get length() {
    return this.pools.length;
  }
  release(...params) {
    this.pools = [];
  }
}
const matrixAllocate = new DefaultMatrixAllocate();
const mat4Allocate = new DefaultMat4Allocate();

var __decorate$L = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$D = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
const initMatrix = new Matrix(1, 0, 0, 1, 0, 0),
  globalPoint = {
    x: 0,
    y: 0
  };
let EmptyContext2d = class {
  get nativeContext() {
    return this.path;
  }
  constructor(canvas, dpr) {
    this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.path = new CustomPath2D(), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  getCanvas() {
    throw new Error("不支持getCanvas");
  }
  getContext() {
    throw new Error("不支持getContext");
  }
  setTransformForCurrent(force = !1) {
    !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix = this.cloneMatrix(this.matrix));
  }
  get currentMatrix() {
    return this.matrix;
  }
  cloneMatrix(m) {
    return matrixAllocate.allocateByObj(m);
  }
  clear() {
    this.save(), this.resetTransform(), this.restore();
  }
  reset() {
    this.matrix.setValue(1, 0, 0, 1, 0, 0), this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack.length = 0;
  }
  restore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent());
  }
  highPerformanceRestore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
  }
  rotate(rad, setTransform = !0) {
    this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
  }
  save() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  highPerformanceSave() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  scale(sx, sy, setTransform = !0) {
    this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  setScale(sx, sy, setTransform = !0) {
    this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  scalePoint(sx, sy, px, py, setTransform = !0) {
    this.translate(px, py, !1), this.scale(sx, sy, !1), this.translate(-px, -py, !1), setTransform && this.setTransformForCurrent();
  }
  setTransform(a, b, c, d, e, f, setTransform = !0, dpr = this.dpr) {
    this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
  }
  setTransformFromMatrix(matrix, setTransform = !0, dpr = this.dpr) {
    this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
  }
  resetTransform(setTransform = !0, dpr = this.dpr) {
    this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
  }
  transform(a, b, c, d, e, f, setTransform = !0) {
    this.matrix.multiply(a, b, c, d, e, f), setTransform && this.setTransformForCurrent();
  }
  transformFromMatrix(matrix, setTransform) {
    this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
  }
  translate(x, y, setTransform = !0) {
    this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
  }
  rotateDegrees(deg, setTransform = !0) {
    const rad = deg * Math.PI / 180;
    this.rotate(rad, setTransform);
  }
  rotateAbout(rad, x, y, setTransform = !0) {
    this.translate(x, y, !1), this.rotate(rad, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
  }
  rotateDegreesAbout(deg, x, y, setTransform = !0) {
    this.translate(x, y, !1), this.rotateDegrees(deg, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
  }
  beginPath() {
    this.path.clear();
  }
  clip(path, fillRule) {}
  arc(x, y, radius, startAngle, endAngle, anticlockwise) {
    this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
  }
  arcTo(x1, y1, x2, y2, radiusX) {
    this.path.arcTo(x1, y1, x2, y2, radiusX);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  closePath() {
    this.path.closePath();
  }
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {}
  lineTo(x, y) {
    this.path.lineTo(x, y);
  }
  moveTo(x, y) {
    this.path.moveTo(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this.path.quadraticCurveTo(cpx, cpy, x, y);
  }
  rect(x, y, w, h) {
    this.path.rect(x, y, w, h);
  }
  createImageData(imageDataOrSw, sh) {
    return null;
  }
  createLinearGradient(x0, y0, x1, y1) {
    throw new Error("不支持createLinearGradient");
  }
  createPattern(image, repetition) {
    throw new Error("不支持createPattern");
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    throw new Error("不支持createRadialGradient");
  }
  createConicGradient(x, y, startAngle, endAngle) {
    return null;
  }
  fill(path, fillRule) {}
  fillRect(x, y, width, height) {
    this.path.rect(x, y, width, height);
  }
  clearRect(x, y, w, h) {}
  fillText(text, x, y) {}
  getImageData(sx, sy, sw, sh) {
    return null;
  }
  getLineDash() {
    return [];
  }
  isPointInPath(x, y) {
    return this.matrix.transformPoint({
      x: x,
      y: y
    }, globalPoint), contain(this.path.commandList, globalPoint.x, globalPoint.y);
  }
  isPointInStroke(x, y) {
    if (!this.lineWidth) return !1;
    this.matrix.transformPoint({
      x: x,
      y: y
    }, globalPoint);
    const lineWidth = getScaledStroke(this, this.lineWidth, this.dpr);
    return containStroke(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);
  }
  measureText(text) {
    throw new Error("不支持measureText");
  }
  putImageData(imagedata, dx, dy) {
    throw new Error("不支持measureText");
  }
  setLineDash(segments) {}
  stroke(path) {}
  strokeRect(x, y, width, height) {
    this.path.rect(x, y, width, height);
  }
  strokeText(text, x, y) {}
  drawImage() {}
  setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {}
  _setCommonStyle(params, offsetX, offsetY, defaultParams) {}
  setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {}
  _setStrokeStyle(params, offsetX, offsetY, defaultParams) {}
  setTextStyleWithoutAlignBaseline(params, defaultParams) {}
  setTextStyle(params, defaultParams) {}
  draw() {}
  clearMatrix(setTransform = !0, dpr = this.dpr) {
    this.setTransformFromMatrix(initMatrix, setTransform, dpr);
  }
  setClearMatrix(a, b, c, d, e, f) {
    this._clearMatrix.setValue(a, b, c, d, e, f);
  }
  onlyTranslate(dpr = this.dpr) {
    return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
  }
  release(...params) {
    this.stack.forEach(m => matrixAllocate.free(m)), this.stack.length = 0;
  }
};
EmptyContext2d = __decorate$L([injectable(), __metadata$D("design:paramtypes", [Object, Number])], EmptyContext2d);

var ColorType;
!function (ColorType) {
  ColorType[ColorType.Color255 = 0] = "Color255", ColorType[ColorType.Color1 = 1] = "Color1";
}(ColorType || (ColorType = {}));
class ColorStore {
  static Get(str, size = ColorType.Color1, arr = [0, 0, 0, 1]) {
    if (size === ColorType.Color1) {
      const color = ColorStore.store1[str];
      if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
      const c = Color.parseColorString(str);
      if (c) {
        const data = [c.r / 255, c.g / 255, c.b / 255, c.opacity];
        ColorStore.store1[str] = data, ColorStore.store255[str] = [c.r, c.g, c.b, c.opacity], arr[0] = data[0], arr[1] = data[1], arr[2] = data[2], arr[3] = data[3];
      }
      return arr;
    }
    const color = ColorStore.store255[str];
    if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
    const c = Color.parseColorString(str);
    return c && (ColorStore.store1[str] = [c.r / 255, c.g / 255, c.b / 255, c.opacity], ColorStore.store255[str] = [c.r, c.g, c.b, c.opacity], arr[0] = c.r, arr[1] = c.g, arr[2] = c.b, arr[3] = c.opacity), arr;
  }
  static Set(str, size, arr) {
    if (size === ColorType.Color1) {
      if (ColorStore.store1[str]) return;
      ColorStore.store1[str] = arr, ColorStore.store255[str] = [Math.floor(255 * arr[0]), Math.floor(255 * arr[1]), Math.floor(255 * arr[2]), Math.floor(255 * arr[3])];
    } else {
      if (ColorStore.store255[str]) return;
      ColorStore.store255[str] = arr, ColorStore.store1[str] = [arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3]];
    }
  }
}
ColorStore.store255 = {}, ColorStore.store1 = {};

function colorArrayToString(color, alphaChannel = !1) {
  return Array.isArray(color) && isNumber(color[0]) ? alphaChannel ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})` : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})` : color;
}
function interpolateColor(from, to, ratio, alphaChannel, cb) {
  if (Array.isArray(from) && !isNumber(from[0]) || Array.isArray(to) && !isNumber(to[0])) {
    return new Array(4).fill(0).map((_, index) => {
      var _a, _b;
      return _interpolateColor(isArray(from) ? null !== (_a = from[index]) && void 0 !== _a ? _a : from[0] : from, isArray(to) ? null !== (_b = to[index]) && void 0 !== _b ? _b : to[0] : to, ratio, alphaChannel);
    });
  }
  return _interpolateColor(from, to, ratio, alphaChannel, cb);
}
function _interpolateColor(from, to, ratio, alphaChannel, cb) {
  if (!from || !to) return from && colorArrayToString(from) || to && colorArrayToString(to) || !1;
  let fromArray,
    toArray,
    fromGradient = !1,
    toGradient = !1;
  if (Array.isArray(from) ? fromArray = from : "string" == typeof from ? fromArray = ColorStore.Get(from, ColorType.Color255) : fromGradient = !0, Array.isArray(to) ? toArray = to : "string" == typeof to ? toArray = ColorStore.Get(to, ColorType.Color255) : toGradient = !0, fromGradient !== toGradient) {
    const gradient = fromGradient ? from : to,
      pure = fromGradient ? to : from,
      gradientFromPure = Object.assign(Object.assign({}, gradient), {
        stops: gradient.stops.map(v => Object.assign(Object.assign({}, v), {
          color: colorArrayToString(pure)
        }))
      });
    return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
  }
  if (fromGradient) {
    if (from.gradient === to.gradient) {
      const fc = from,
        tc = to,
        fromStops = fc.stops,
        toStops = tc.stops;
      if (fromStops.length !== toStops.length) return !1;
      if ("linear" === fc.gradient) return interpolateGradientLinearColor(fc, tc, ratio);
      if ("radial" === fc.gradient) return interpolateGradientRadialColor(fc, tc, ratio);
      if ("conical" === fc.gradient) return interpolateGradientConicalColor(fc, tc, ratio);
    }
    return !1;
  }
  cb && cb(fromArray, toArray);
  return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);
}
function interpolateGradientLinearColor(fc, tc, ratio) {
  const fStops = fc.stops,
    tStops = tc.stops;
  return {
    gradient: "linear",
    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolateGradientRadialColor(fc, tc, ratio) {
  const fStops = fc.stops,
    tStops = tc.stops;
  return {
    gradient: "radial",
    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
    r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
    r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolateGradientConicalColor(fc, tc, ratio) {
  const fStops = fc.stops,
    tStops = tc.stops;
  return {
    gradient: "conical",
    startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
    endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
    x: fc.x + (tc.x - fc.x) * ratio,
    y: fc.y + (tc.y - fc.y) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolatePureColorArray(from, to, ratio) {
  return [from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio];
}
function interpolatePureColorArrayToStr(from, to, ratio) {
  return `rgba(${from[0] + (to[0] - from[0]) * ratio},${from[1] + (to[1] - from[1]) * ratio},${from[2] + (to[2] - from[2]) * ratio},${from[3] + (to[3] - from[3]) * ratio})`;
}
const _fromColorRGB = [0, 0, 0, 0],
  _toColorRGB = [0, 0, 0, 0];
function colorStringInterpolationToStr(fromColor, toColor, ratio) {
  return ColorStore.Get(fromColor, ColorType.Color255, _fromColorRGB), ColorStore.Get(toColor, ColorType.Color255, _toColorRGB), `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
}

function getConicGradientAt(x, y, angle, color) {
  const {
    stops: stops,
    startAngle: startAngle,
    endAngle: endAngle
  } = color;
  for (; angle < 0;) angle += pi2;
  for (; angle > pi2;) angle -= pi2;
  if (angle < startAngle) return stops[0].color;
  if (angle > endAngle) return stops[0].color;
  let startStop,
    endStop,
    percent = (angle - startAngle) / (endAngle - startAngle);
  for (let i = 0; i < stops.length; i++) if (stops[i].offset >= percent) {
    startStop = stops[i - 1], endStop = stops[i];
    break;
  }
  return percent = (percent - startStop.offset) / (endStop.offset - startStop.offset), interpolateColor(startStop.color, endStop.color, percent, !1);
}

const _tempBounds = new AABBBounds(),
  tempMatrix = new Matrix();
  new AABBBounds();
const GRAPHIC_UPDATE_TAG_KEY = ["lineWidth", "scaleX", "scaleY", "angle", "anchor", "visible"];
const tempConstantXYKey = ["x", "y"],
  tempConstantScaleXYKey = ["scaleX", "scaleY"],
  tempConstantAngleKey = ["angle"],
  point = new Point();
const NOWORK_ANIMATE_ATTR = {
  strokeSeg: 1,
  boundsPadding: 2,
  pickMode: 1,
  boundsMode: 1,
  customPickShape: 1,
  pickable: 1,
  childrenPickable: 1,
  visible: 1,
  zIndex: 1,
  layout: 1,
  keepDirIn3d: 1,
  globalZIndex: 1,
  outerBorder: 1,
  innerBorder: 1,
  lineDash: 1,
  lineCap: 1,
  lineJoin: 1,
  miterLimit: 2,
  strokeBoundsBuffer: 2,
  scaleCenter: 1,
  anchor: 1,
  anchor3d: 1,
  postMatrix: 1,
  backgroundMode: 2,
  background: 1,
  texture: 1,
  cursor: 1,
  html: 1
};
class Graphic extends Node {
  static mixin(source) {
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; ++i) {
      const propertyName = keys[i];
      Object.defineProperty(Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get AABBBounds() {
    return this.tryUpdateAABBBounds();
  }
  get OBBBounds() {
    return this.tryUpdateOBBBounds();
  }
  get globalAABBBounds() {
    return this.tryUpdateGlobalAABBBounds();
  }
  get transMatrix() {
    return this.tryUpdateLocalTransMatrix(!0);
  }
  get globalTransMatrix() {
    return this.tryUpdateGlobalTransMatrix(!0);
  }
  constructor(params = {}) {
    var _a;
    super(), this._AABBBounds = new AABBBounds(), this._updateTag = UpdateTag.INIT, this.attribute = params, this.valid = this.isValid(), this.updateAABBBoundsStamp = 0, params.background ? this.loadImage(null !== (_a = params.background.background) && void 0 !== _a ? _a : params.background, !0) : params.shadowGraphic && this.setShadowGraphic(params.shadowGraphic);
  }
  getGraphicService() {
    var _a, _b;
    return null !== (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.graphicService) && void 0 !== _b ? _b : application.graphicService;
  }
  getAttributes() {
    return this.attribute;
  }
  setMode(mode) {
    "3d" === mode ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = !0;
  }
  set2dMode() {
    this.in3dMode = !1;
  }
  getOffsetXY(attr, includeScroll = !1) {
    var _a, _b;
    const {
      dx = attr.dx,
      dy = attr.dy
    } = this.attribute;
    if (includeScroll && this.parent) {
      const attribute = this.parent.attribute;
      point.x = dx + (null !== (_a = attribute.scrollX) && void 0 !== _a ? _a : 0), point.y = dy + (null !== (_b = attribute.scrollY) && void 0 !== _b ? _b : 0);
    } else point.x = dx, point.y = dy;
    return point;
  }
  onAnimateBind(animate) {
    this._emitCustomEvent("animate-bind", animate);
  }
  tryUpdateAABBBounds() {
    const full = "imprecise" === this.attribute.boundsMode;
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;
    this.getGraphicService().beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
    const bounds = this.doUpdateAABBBounds(full);
    return this.getGraphicService().afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, !0), "empty" === this.attribute.boundsMode && bounds.clear(), bounds;
  }
  tryUpdateOBBBounds() {
    if (this._OBBBounds || (this._OBBBounds = new OBBBounds()), this.tryUpdateAABBBounds(), this.updateOBBBoundsStamp === this.updateAABBBoundsStamp) return this._OBBBounds;
    if (this.updateOBBBoundsStamp = this.updateAABBBoundsStamp, !this.valid) return this._OBBBounds.clear(), this._OBBBounds;
    return this.doUpdateOBBBounds();
  }
  combindShadowAABBBounds(bounds) {
    if (this.shadowRoot) {
      const b = this.shadowRoot.AABBBounds.clone();
      bounds.union(b);
    }
  }
  doUpdateOBBBounds() {
    return this._OBBBounds;
  }
  getClipPath() {
    const {
      clipConfig: clipConfig
    } = this.attribute;
    if (!clipConfig) return null;
    this.clipPathMap || (this.clipPathMap = new Map());
    const {
      shape: shape
    } = clipConfig;
    let path = this.clipPathMap.get(shape) || null;
    return path || (this.clipPathMap.size > 10 && this.clipPathMap.clear(), path = this.parsePath(shape), path && this.clipPathMap.set(shape, path)), path;
  }
  parsePath(symbolType) {
    if (!symbolType) return null;
    let path = builtinSymbolsMap[symbolType];
    if (path) return path;
    if (path = Graphic.userSymbolMap[symbolType], path) return path;
    const _symbolType = builtInSymbolStrMap[symbolType];
    if (!0 === isSvg(symbolType = _symbolType || symbolType)) {
      const parser = new XMLParser(),
        {
          svg: svg
        } = parser.parse(symbolType);
      if (!svg) return null;
      const path = isArray(svg.path) ? svg.path : [svg.path];
      _tempBounds.clear();
      const cacheList = [];
      path.forEach(item => {
        const cache = new CustomPath2D().fromString(item.d),
          attribute = {};
        SVG_PARSE_ATTRIBUTE_MAP_KEYS.forEach(k => {
          item[k] && (attribute[SVG_PARSE_ATTRIBUTE_MAP[k]] = item[k]);
        }), cacheList.push({
          path: cache,
          attribute: attribute
        }), _tempBounds.union(cache.bounds);
      });
      const width = _tempBounds.width(),
        height = _tempBounds.height(),
        scale = 1 / max(width, height);
      cacheList.forEach(cache => cache.path.transform(0, 0, scale, scale));
      const _parsedPath = new CustomSymbolClass(symbolType, cacheList, !0);
      return Graphic.userSymbolMap[symbolType] = _parsedPath, _parsedPath;
    }
    const cache = new CustomPath2D().fromString(symbolType),
      width = cache.bounds.width(),
      height = cache.bounds.height(),
      scale = 1 / max(width, height);
    cache.transform(0, 0, scale, scale);
    const _parsedPath = new CustomSymbolClass(symbolType, cache);
    return Graphic.userSymbolMap[symbolType] = _parsedPath, _parsedPath;
  }
  doUpdateAABBBounds(full) {
    this.updateAABBBoundsStamp++;
    const graphicTheme = this.getGraphicTheme();
    this._AABBBounds.clear();
    const attribute = this.attribute,
      bounds = this.updateAABBBounds(attribute, graphicTheme, this._AABBBounds, full),
      {
        boundsPadding = graphicTheme.boundsPadding
      } = attribute,
      paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  updatePathProxyAABBBounds(aabbBounds) {
    const path = "function" == typeof this.pathProxy ? this.pathProxy(this.attribute) : this.pathProxy;
    if (!path) return !1;
    const boundsContext = new BoundsContext(aabbBounds);
    return renderCommandList(path.commandList, boundsContext, 0, 0), !0;
  }
  tryUpdateGlobalAABBBounds() {
    const b = this.AABBBounds;
    return this._globalAABBBounds ? this._globalAABBBounds.setValue(b.x1, b.y1, b.x2, b.y2) : this._globalAABBBounds = b.clone(), this._globalAABBBounds.empty() || this.parent && this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix), this._globalAABBBounds;
  }
  tryUpdateGlobalTransMatrix(clearTag = !0) {
    if (this._globalTransMatrix) {
      if (this.parent) {
        const m = this.parent.globalTransMatrix;
        this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
      }
    } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
    return this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(), this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return !0;
  }
  tryUpdateLocalTransMatrix(clearTag = !0) {
    return this._transMatrix || (this._transMatrix = new Matrix()), this.shouldUpdateLocalMatrix() && (this.doUpdateLocalMatrix(), clearTag && this.clearUpdateLocalPositionTag()), this._transMatrix;
  }
  shouldUpdateAABBBounds() {
    return this.shadowRoot ? (!!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds()) && this.getGraphicService().validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this) : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) && this.getGraphicService().validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this);
  }
  shouldSelfChangeUpdateAABBBounds() {
    return this.shadowRoot ? !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
  }
  shouldUpdateLocalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_LOCAL_MATRIX);
  }
  isValid() {
    var _a, _b;
    const attribute = this.attribute;
    return Number.isFinite((null !== (_a = attribute.x) && void 0 !== _a ? _a : 0) + (null !== (_b = attribute.y) && void 0 !== _b ? _b : 0));
  }
  _validNumber(num) {
    return null == num || Number.isFinite(num);
  }
  shouldUpdateShape() {
    return !!(this._updateTag & UpdateTag.UPDATE_SHAPE);
  }
  clearUpdateShapeTag() {
    this._updateTag &= UpdateTag.CLEAR_SHAPE;
  }
  containsPoint(x, y, mode, picker) {
    if (!picker) return !1;
    if (mode === IContainPointMode.GLOBAL) {
      const point = new Point(x, y);
      this.parent && this.parent.globalTransMatrix.transformPoint(point, point), x = point.x, y = point.y;
    }
    return picker.containsPoint(this, {
      x: x,
      y: y
    });
  }
  setWidthHeightWithoutTransform(aabbBounds) {
    this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
  }
  setAttributesAndPreventAnimate(params, forceUpdateTag = !1, context, ignorePriority) {
    this.setAttributes(params, forceUpdateTag, context), this.animates && this.animates.forEach(animate => {
      (animate.priority !== 1 / 0 || ignorePriority) && Object.keys(params).forEach(key => {
        animate.preventAttr(key);
      });
    });
  }
  setAttributes(params, forceUpdateTag = !1, context) {
    params && ((params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params).background ? this.loadImage(params.background, !0) : params.shadowGraphic && this.setShadowGraphic(params.shadowGraphic), this._setAttributes(params, forceUpdateTag, context));
  }
  _setAttributes(params, forceUpdateTag = !1, context) {
    const keys = Object.keys(params);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      this.attribute[key] = params[key];
    }
    this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    var _a;
    const params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      [key]: value
    }, this.attribute, key, context);
    params ? this._setAttributes(params, forceUpdateTag, context) : isNil(null === (_a = this.normalAttrs) || void 0 === _a ? void 0 : _a[key]) ? (this.attribute[key] = value, this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context)) : this.normalAttrs[key] = value, "background" === key ? this.loadImage(value, !0) : "shadowGraphic" === key && this.setShadowGraphic(value);
  }
  needUpdateTags(keys, k = GRAPHIC_UPDATE_TAG_KEY) {
    for (let i = 0; i < k.length; i++) {
      const attrKey = k[i];
      if (-1 !== keys.indexOf(attrKey)) return !0;
    }
    return !1;
  }
  needUpdateTag(key, k = GRAPHIC_UPDATE_TAG_KEY) {
    for (let i = 0; i < k.length; i++) {
      if (key === k[i]) return !0;
    }
    return !1;
  }
  initAttributes(params) {
    const context = {
      type: AttributeUpdateType.INIT
    };
    params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params, this.attribute = params, params.background ? this.loadImage(params.background, !0) : params.shadowGraphic && this.setShadowGraphic(params.shadowGraphic), this._updateTag = UpdateTag.INIT, this.valid = this.isValid(), this.onAttributeUpdate(context);
  }
  translate(x, y) {
    var _a, _b;
    if (0 === x && 0 === y) return this;
    const context = {
        type: AttributeUpdateType.TRANSLATE
      },
      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
        x: x,
        y: y
      }, this.attribute, tempConstantXYKey, context);
    params && (x = params.x, y = params.y, delete params.x, delete params.y, this._setAttributes(params));
    const attribute = this.attribute,
      postMatrix = attribute.postMatrix;
    return postMatrix ? application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x, y) : (attribute.x = (null !== (_a = attribute.x) && void 0 !== _a ? _a : DefaultTransform.x) + x, attribute.y = (null !== (_b = attribute.y) && void 0 !== _b ? _b : DefaultTransform.y) + y), this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  translateTo(x, y) {
    const attribute = this.attribute;
    if (attribute.x === x && attribute.y === y) return this;
    const context = {
        type: AttributeUpdateType.TRANSLATE_TO
      },
      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
        x: x,
        y: y
      }, this.attribute, tempConstantXYKey, context);
    return params ? (this._setAttributes(params, !1, context), this) : (attribute.x = x, attribute.y = y, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  scale(scaleX, scaleY, scaleCenter) {
    var _a, _b;
    if (1 === scaleX && 1 === scaleY) return this;
    const context = {
        type: AttributeUpdateType.SCALE
      },
      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
        scaleX: scaleX,
        scaleY: scaleY,
        scaleCenter: scaleCenter
      }, this.attribute, tempConstantScaleXYKey, context);
    params && (scaleX = params.scaleX, scaleY = params.scaleY, delete params.scaleX, delete params.scaleY, this._setAttributes(params));
    const attribute = this.attribute;
    if (scaleCenter) {
      let {
        postMatrix: postMatrix
      } = this.attribute;
      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);
    } else attribute.scaleX = (null !== (_a = attribute.scaleX) && void 0 !== _a ? _a : DefaultTransform.scaleX) * scaleX, attribute.scaleY = (null !== (_b = attribute.scaleY) && void 0 !== _b ? _b : DefaultTransform.scaleY) * scaleY;
    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  scaleTo(scaleX, scaleY) {
    const attribute = this.attribute;
    if (attribute.scaleX === scaleX && attribute.scaleY === scaleY) return this;
    const context = {
        type: AttributeUpdateType.SCALE_TO
      },
      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
        scaleX: scaleX,
        scaleY: scaleY
      }, this.attribute, tempConstantScaleXYKey, context);
    return params ? (this._setAttributes(params, !1, context), this) : (attribute.scaleX = scaleX, attribute.scaleY = scaleY, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  rotate(angle, rotateCenter) {
    var _a;
    if (0 === angle) return this;
    const context = {
        type: AttributeUpdateType.ROTATE
      },
      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
        angle: angle,
        rotateCenter: rotateCenter
      }, this.attribute, tempConstantAngleKey, context);
    params && (delete params.angle, this._setAttributes(params, !1, context));
    const attribute = this.attribute;
    if (rotateCenter) {
      let {
        postMatrix: postMatrix
      } = this.attribute;
      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).rotate(angle, rotateCenter);
    } else attribute.angle = (null !== (_a = attribute.angle) && void 0 !== _a ? _a : DefaultTransform.angle) + angle;
    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  rotateTo(angle) {
    const attribute = this.attribute;
    if (attribute.angle === angle) return this;
    const context = {
        type: AttributeUpdateType.ROTATE_TO
      },
      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle, this.attribute, tempConstantAngleKey, context);
    return params ? (this._setAttributes(params, !1, context), this) : (attribute.angle = angle, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  skewTo(b, c) {
    return this;
  }
  onAttributeUpdate(context) {
    context && context.skipUpdateCallback || (this.getGraphicService().onAttributeUpdate(this), this._emitCustomEvent("afterAttributeUpdate", context));
  }
  update(d) {
    d ? (d.bounds && this.tryUpdateAABBBounds(), d.trans && this.tryUpdateLocalTransMatrix()) : (this.tryUpdateAABBBounds(), this.tryUpdateLocalTransMatrix());
  }
  hasState(stateName) {
    return !(!this.currentStates || !this.currentStates.length) && (!!isNil(stateName) || this.currentStates.includes(stateName));
  }
  getState(stateName) {
    var _a;
    return null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
  }
  applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {
    var _a, _b;
    if (hasAnimation) {
      const keys = Object.keys(attrs),
        noWorkAttrs = this.getNoWorkAnimateAttr(),
        animateAttrs = {};
      let noAnimateAttrs;
      keys.forEach(key => {
        noWorkAttrs[key] ? (noAnimateAttrs || (noAnimateAttrs = {}), noAnimateAttrs[key] = attrs[key]) : animateAttrs[key] = isClear && void 0 === attrs[key] ? this.getDefaultAttribute(key) : attrs[key];
      });
      const stateAnimateConfig = null !== (_b = null !== (_a = this.context && this.context.stateAnimateConfig) && void 0 !== _a ? _a : this.stateAnimateConfig) && void 0 !== _b ? _b : DefaultStateAnimateConfig;
      this.applyAnimationState(["state"], [{
        name: "state",
        animation: {
          type: "state",
          to: animateAttrs,
          duration: stateAnimateConfig.duration,
          easing: stateAnimateConfig.easing
        }
      }]), noAnimateAttrs && this.setAttributesAndPreventAnimate(noAnimateAttrs, !1, {
        type: AttributeUpdateType.STATE
      });
    } else this.stopStateAnimates(), this.setAttributesAndPreventAnimate(attrs, !1, {
      type: AttributeUpdateType.STATE
    }), this.finalAttribute && Object.assign(this.finalAttribute, attrs);
    this._emitCustomEvent("afterStateUpdate", {
      type: AttributeUpdateType.STATE
    });
  }
  updateNormalAttrs(stateAttrs) {
    const newNormalAttrs = {};
    this.normalAttrs ? (Object.keys(stateAttrs).forEach(key => {
      key in this.normalAttrs ? (newNormalAttrs[key] = this.normalAttrs[key], delete this.normalAttrs[key]) : newNormalAttrs[key] = this.getNormalAttribute(key);
    }), Object.keys(this.normalAttrs).forEach(key => {
      stateAttrs[key] = this.normalAttrs[key];
    })) : Object.keys(stateAttrs).forEach(key => {
      newNormalAttrs[key] = this.getNormalAttribute(key);
    }), this.normalAttrs = newNormalAttrs;
  }
  stopStateAnimates(type = "end") {
    this.animates && this.animates.forEach(animate => {
      animate.stateNames && (animate.stop(type), this.animates.delete(animate.id));
    });
  }
  getNormalAttribute(key) {
    var _a, _b;
    const value = this.attribute[key];
    return this.animates ? null === (_a = this.finalAttribute) || void 0 === _a ? void 0 : _a[key] : null != value ? value : null === (_b = this.finalAttribute) || void 0 === _b ? void 0 : _b[key];
  }
  clearStates(hasAnimation) {
    this.hasState() && this.normalAttrs ? (this.currentStates = [], this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0)) : this.currentStates = [], this.normalAttrs = null;
  }
  removeState(stateName, hasAnimation) {
    if (this.currentStates) {
      const filter = isArray(stateName) ? s => !stateName.includes(s) : s => s !== stateName,
        newStates = this.currentStates.filter(filter);
      newStates.length !== this.currentStates.length && this.useStates(newStates, hasAnimation);
    }
  }
  toggleState(stateName, hasAnimation) {
    if (this.hasState(stateName)) this.removeState(stateName, hasAnimation);else {
      if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) < 0) {
        const nextStates = this.currentStates ? this.currentStates.slice() : [];
        nextStates.push(stateName), this.useStates(nextStates, hasAnimation);
      }
    }
  }
  addState(stateName, keepCurrentStates, hasAnimation) {
    var _a;
    if (this.currentStates && this.currentStates.includes(stateName) && (keepCurrentStates || 1 === this.currentStates.length)) return;
    const newStates = keepCurrentStates && (null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) ? this.currentStates.concat([stateName]) : [stateName];
    this.useStates(newStates, hasAnimation);
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!states.length) return void this.clearStates(hasAnimation);
    if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName))) return;
    const stateAttrs = {};
    states.forEach(stateName => {
      var _a;
      const attrs = this.stateProxy ? this.stateProxy(stateName, states) : null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
      attrs && Object.assign(stateAttrs, attrs);
    }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
  }
  addUpdateBoundTag() {
    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  addUpdateShapeTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE;
  }
  addUpdateShapeAndBoundsTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE_AND_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  updateShapeAndBoundsTagSetted() {
    return (this._updateTag & UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  addUpdatePositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;
  }
  addUpdateGlobalPositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_MATRIX;
  }
  clearUpdateLocalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_LOCAL_MATRIX;
  }
  clearUpdateGlobalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_GLOBAL_MATRIX;
  }
  addUpdateLayoutTag() {
    this._updateTag |= UpdateTag.UPDATE_LAYOUT;
  }
  clearUpdateLayoutTag() {
    this._updateTag &= UpdateTag.CLEAR_LAYOUT;
  }
  needUpdateLayout() {
    return !!(this._updateTag & UpdateTag.UPDATE_LAYOUT);
  }
  getAnchor(anchor, params, resetScale) {
    const _anchor = [0, 0],
      getBounds = () => {
        if (params.b) return params.b;
        const graphic = this.clone();
        return graphic.attribute.angle = 0, graphic.attribute.scaleCenter = null, resetScale && (graphic.attribute.scaleX = 1, graphic.attribute.scaleY = 1), params.b = graphic.AABBBounds, params.b;
      };
    if ("string" == typeof anchor[0]) {
      const ratio = parseFloat(anchor[0]) / 100,
        bounds = getBounds();
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[0] = anchor[0];
    if ("string" == typeof anchor[1]) {
      const ratio = parseFloat(anchor[1]) / 100,
        bounds = getBounds();
      _anchor[1] = bounds.y1 + (bounds.y2 - bounds.y1) * ratio;
    } else _anchor[1] = anchor[1];
    return _anchor;
  }
  doUpdateLocalMatrix() {
    const {
      x = DefaultTransform.x,
      y = DefaultTransform.y,
      scaleX = DefaultTransform.scaleX,
      scaleY = DefaultTransform.scaleY,
      angle = DefaultTransform.angle,
      scaleCenter: scaleCenter,
      anchor: anchor,
      postMatrix: postMatrix
    } = this.attribute;
    let _anchor = [0, 0];
    const params = {};
    if (anchor && angle && (_anchor = this.getAnchor(anchor, params)), !scaleCenter || 1 === scaleX && 1 === scaleY) normalTransform(this._transMatrix, this._transMatrix.reset(), x, y, scaleX, scaleY, angle, anchor && _anchor);else {
      const m = this._transMatrix;
      m.reset(), m.translate(_anchor[0], _anchor[1]), m.rotate(angle), m.translate(-_anchor[0], -_anchor[1]), m.translate(x, y), _anchor = this.getAnchor(scaleCenter, params, !0), application.transformUtil.fromMatrix(m, m).scale(scaleX, scaleY, {
        x: _anchor[0],
        y: _anchor[1]
      });
    }
    const p = this.getOffsetXY(DefaultTransform);
    if (this._transMatrix.e += p.x, this._transMatrix.f += p.y, postMatrix) {
      const m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f),
        m2 = this._transMatrix;
      m1.multiply(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f), m2.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);
    }
  }
  doUpdateGlobalMatrix() {
    if (this.parent) {
      this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);
      const {
        scrollX = 0,
        scrollY = 0
      } = this.parent.attribute;
      this._globalTransMatrix.translate(scrollX, scrollY);
    }
  }
  setStage(stage, layer) {
    if (this.stage !== stage) {
      if (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this.animates && this.animates.size) {
        const timeline = stage.getTimeline();
        this.animates.forEach(a => {
          a.timeline.isGlobal && (a.setTimeline(timeline), timeline.addAnimate(a));
        });
      }
      this._onSetStage && this._onSetStage(this, stage, layer), this.getGraphicService().onSetStage(this, stage);
    }
  }
  setStageToShadowRoot(stage, layer) {
    this.shadowRoot && this.shadowRoot.setStage(stage, layer);
  }
  onAddStep(step) {}
  onStop(props) {
    props && this.setAttributes(props, !1, {
      type: AttributeUpdateType.ANIMATE_END
    });
  }
  getDefaultAttribute(name) {
    return this.getGraphicTheme()[name];
  }
  getComputedAttribute(name) {
    var _a;
    return null !== (_a = this.attribute[name]) && void 0 !== _a ? _a : this.getDefaultAttribute(name);
  }
  onSetStage(cb, immediate = !1) {
    this._onSetStage = cb, immediate && this.stage && cb(this, this.stage);
  }
  attachShadow(shadowRoot) {
    return shadowRoot && (shadowRoot.shadowHost = this), this.shadowRoot = null != shadowRoot ? shadowRoot : application.graphicService.creator.shadowRoot(this), this.addUpdateBoundTag(), this.shadowRoot.setStage(this.stage, this.layer), this.shadowRoot;
  }
  detachShadow() {
    this.shadowRoot && (this.addUpdateBoundTag(), this.shadowRoot.release(!0), this.shadowRoot = null);
  }
  toJson() {
    return {
      attribute: this.attribute,
      _uid: this._uid,
      type: this.type,
      name: this.name,
      children: this.children.map(item => item.toJson())
    };
  }
  createPathProxy(path) {
    return isString(path, !0) ? this.pathProxy = new CustomPath2D().fromString(path) : this.pathProxy = new CustomPath2D(), this.pathProxy;
  }
  loadImage(image, background = !1) {
    if (!image || background && backgroundNotImage(image)) return;
    const url = image;
    this.resources || (this.resources = new Map());
    const cache = {
      data: "init",
      state: null
    };
    this.resources.set(url, cache), "string" == typeof image ? (cache.state = "loading", image.startsWith("<svg") ? (ResourceLoader.GetSvg(image, this), this.backgroundImg = this.backgroundImg || background) : (isValidUrl(image) || image.includes("/") || isBase64(image)) && (ResourceLoader.GetImage(image, this), this.backgroundImg = this.backgroundImg || background)) : isObject(image) ? (cache.state = "success", cache.data = image, this.backgroundImg = this.backgroundImg || background) : cache.state = "fail";
  }
  setShadowGraphic(graphic) {
    if (graphic) {
      this.attachShadow().add(graphic);
    } else this.detachShadow();
  }
  imageLoadSuccess(url, image, cb) {
    if (!this.resources) return;
    const res = this.resources.get(url);
    res && (res.state = "success", res.data = image, cb && cb(), this.addUpdateBoundTag(), this.stage && this.stage.renderNextFrame());
  }
  imageLoadFail(url, cb) {
    if (!this.resources) return;
    const res = this.resources.get(url);
    res && (res.state = "fail", cb && cb());
  }
  _stopAnimates(animates) {
    animates && animates.forEach(animate => {
      animate.stop();
    });
  }
  stopAnimates(stopChildren = !1) {
    this._stopAnimates(this.animates), this.shadowRoot && this.shadowRoot.stopAnimates(!0), this.isContainer && stopChildren && this.forEachChildren(c => {
      c.stopAnimates(stopChildren);
    });
  }
  release() {
    this.releaseStatus = "released", this.stopAnimates(), application.graphicService.onRelease(this);
  }
  _emitCustomEvent(type, context) {
    var _a, _b;
    if (this._events && type in this._events) {
      const changeEvent = new CustomEvent(type, context);
      changeEvent.bubbles = !1, changeEvent.manager = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem) || void 0 === _b ? void 0 : _b.manager, this.dispatchEvent(changeEvent);
    }
  }
  toCustomPath() {
    var _a, _b, _c;
    const renderer = null === (_c = null === (_b = (null === (_a = this.stage) || void 0 === _a ? void 0 : _a.renderService) || application.renderService) || void 0 === _b ? void 0 : _b.drawContribution) || void 0 === _c ? void 0 : _c.getRenderContribution(this);
    if (renderer) {
      const context = new EmptyContext2d(null, 1);
      return renderer.drawShape(this, context, 0, 0, {}, {}), context.path;
    }
    return null;
  }
}
function backgroundNotImage(image) {
  return !(!image.fill && !image.stroke);
}
Graphic.userSymbolMap = {}, Graphic.mixin(EventTarget);

var GroupUpdateAABBBoundsMode;
!function (GroupUpdateAABBBoundsMode) {
  GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.LESS_GROUP = 0] = "LESS_GROUP", GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.MORE_GROUP = 1] = "MORE_GROUP";
}(GroupUpdateAABBBoundsMode || (GroupUpdateAABBBoundsMode = {}));
class Group extends Graphic {
  constructor(params) {
    super(params), this.type = "group", this.parent = null, this.isContainer = !0, this.numberType = GROUP_NUMBER_TYPE, this._childUpdateTag = UpdateTag.UPDATE_BOUNDS;
  }
  setMode(mode) {
    "3d" === mode ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = !0;
  }
  set2dMode() {
    this.in3dMode = !1;
  }
  setTheme(t) {
    return this.theme || (this.theme = new Theme()), this.theme.setTheme(t, this);
  }
  createTheme() {
    this.theme || (this.theme = new Theme());
  }
  visibleAll(visible) {
    this.setAttribute("visible", visible), this.forEachChildren(item => {
      item.isContainer && item.visibleAll ? item.visibleAll(visible) : item.setAttribute("visible", visible);
    });
  }
  hideAll() {
    this.visibleAll(!1);
  }
  showAll() {
    this.visibleAll(!0);
  }
  containsPoint(x, y, mode) {
    if (mode === IContainPointMode.GLOBAL) {
      const point = new Point(x, y);
      return this.parent && this.parent.globalTransMatrix.transformPoint(point, point), this.AABBBounds.contains(point.x, point.y);
    }
    return this.AABBBounds.contains(x, y);
  }
  shouldUpdateAABBBounds() {
    return !!super.shouldUpdateAABBBounds() || !!(this._childUpdateTag & UpdateTag.UPDATE_BOUNDS);
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    this.getGraphicService().beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
    const selfChange = this.shouldSelfChangeUpdateAABBBounds(),
      bounds = this.doUpdateAABBBounds();
    return this.addUpdateLayoutTag(), this.getGraphicService().afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange), "empty" === this.attribute.boundsMode && bounds.clear(), bounds;
  }
  doUpdateLocalMatrix() {
    const {
      x = DefaultTransform.x,
      y = DefaultTransform.y,
      dx = DefaultTransform.dx,
      dy = DefaultTransform.dy,
      scaleX = DefaultTransform.scaleX,
      scaleY = DefaultTransform.scaleY,
      angle = DefaultTransform.angle,
      postMatrix: postMatrix
    } = this.attribute;
    if (0 !== x || 0 !== y || 0 !== dx || 0 !== dy || 1 !== scaleX || 1 !== scaleY || 0 !== angle || postMatrix) return super.doUpdateLocalMatrix();
    this._transMatrix.reset();
  }
  getGraphicTheme() {
    return getTheme(this).group;
  }
  updateAABBBounds(attribute, groupTheme, aabbBounds) {
    const originalAABBBounds = aabbBounds;
    aabbBounds = aabbBounds.clone();
    const {
      width: width,
      height: height,
      path: path,
      clip = groupTheme.clip
    } = attribute;
    if (path && path.length ? path.forEach(g => {
      aabbBounds.union(g.AABBBounds);
    }) : null != width && null != height && aabbBounds.set(0, 0, Math.max(0, width), Math.max(0, height)), !clip) {
      this.forEachChildren(node => {
        aabbBounds.union(node.AABBBounds);
      });
      const {
        scrollX = 0,
        scrollY = 0
      } = attribute;
      aabbBounds.translate(scrollX, scrollY);
    }
    return application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, groupTheme, !1, this), originalAABBBounds.copy(aabbBounds), originalAABBBounds;
  }
  doUpdateAABBBounds() {
    this.updateAABBBoundsStamp++;
    const bounds = super.doUpdateAABBBounds();
    return this.parent && this.parent.addChildUpdateBoundTag(), this._emitCustomEvent("AAABBBoundsChange"), bounds;
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS, this._childUpdateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  addUpdateBoundTag() {
    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag();
  }
  addChildUpdateBoundTag() {
    this._childUpdateTag & UpdateTag.UPDATE_BOUNDS || (this._childUpdateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag());
  }
  getTheme() {
    return this.theme.getTheme(this);
  }
  incrementalAppendChild(node) {
    const data = super.appendChild(node);
    return this.stage && data && (data.stage = this.stage, data.layer = this.layer), this.addUpdateBoundTag(), this.getGraphicService().onAddIncremental(node, this, this.stage), data;
  }
  incrementalClearChild() {
    super.removeAllChild(), this.addUpdateBoundTag(), this.getGraphicService().onClearIncremental(this, this.stage);
  }
  _updateChildToStage(child) {
    return this.stage && child && child.setStage(this.stage, this.layer), this.addUpdateBoundTag(), child;
  }
  appendChild(node, addStage = !0) {
    const data = super.appendChild(node);
    return addStage && this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
  }
  insertBefore(newNode, referenceNode) {
    return this._updateChildToStage(super.insertBefore(newNode, referenceNode));
  }
  insertAfter(newNode, referenceNode) {
    return this._updateChildToStage(super.insertAfter(newNode, referenceNode));
  }
  insertInto(newNode, idx) {
    return this._updateChildToStage(super.insertInto(newNode, idx));
  }
  removeChild(child) {
    const data = super.removeChild(child);
    return this.getGraphicService().onRemove(child), child.stage = null, this.addUpdateBoundTag(), data;
  }
  removeAllChild(deep = !1) {
    this.forEachChildren(child => {
      this.getGraphicService().onRemove(child), deep && child.isContainer && child.removeAllChild(deep);
    }), super.removeAllChild(), this.addUpdateBoundTag();
  }
  setStage(stage, layer) {
    this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this._onSetStage && this._onSetStage(this, stage, layer), this.getGraphicService().onSetStage(this, stage), this.forEachChildren(item => {
      item.setStage(stage, this.layer);
    }));
  }
  addUpdatePositionTag() {
    super.addUpdatePositionTag(), this.forEachChildren(g => {
      g.isContainer && g.addUpdateGlobalPositionTag();
    });
  }
  addUpdateGlobalPositionTag() {
    super.addUpdateGlobalPositionTag(), this.forEachChildren(g => {
      g.isContainer && g.addUpdateGlobalPositionTag();
    });
  }
  tryUpdateGlobalTransMatrix(clearTag = !0) {
    if (this.shouldUpdateGlobalMatrix()) {
      if (this._globalTransMatrix) {
        if (this.parent) {
          const m = this.parent.globalTransMatrix;
          this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
        }
      } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
      this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_GLOBAL_MATRIX);
  }
  _getChildByName(name, deep) {
    return this.find(node => node.name === name, deep);
  }
  createOrUpdateChild(graphicName, attributes, graphicType) {
    let graphic = this._getChildByName(graphicName);
    return graphic ? graphic.setAttributes(attributes) : (graphic = application.graphicService.creator[graphicType](attributes), graphic.name = graphicName, this.add(graphic)), graphic;
  }
  clone() {
    return new Group(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Group.NOWORK_ANIMATE_ATTR;
  }
  release(all) {
    all && this.forEachChildren(g => {
      g.release(all);
    }), super.release();
  }
}
Group.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createGroup(attributes) {
  return new Group(attributes);
}

class Layer extends Group {
  get offscreen() {
    return this.layerHandler.offscreen;
  }
  get layerMode() {
    return this.layerHandler.type;
  }
  get width() {
    return this.stage ? this.stage.width : 0;
  }
  get height() {
    return this.stage ? this.stage.height : 0;
  }
  get viewWidth() {
    return this.stage ? this.stage.viewWidth : 0;
  }
  get viewHeight() {
    return this.stage ? this.stage.viewHeight : 0;
  }
  get dirtyBound() {
    throw new Error("暂不支持");
  }
  get dpr() {
    return this._dpr;
  }
  constructor(stage, global, window, params) {
    var _a;
    super({}), this.stage = stage, this.global = global, this.window = window, this.main = params.main, this.layerHandler = params.layerHandler, this.layerHandler.init(this, window, {
      main: params.main,
      canvasId: params.canvasId,
      width: this.viewWidth,
      height: this.viewHeight,
      zIndex: null !== (_a = params.zIndex) && void 0 !== _a ? _a : 0
    }), this.layer = this, this.subLayers = new Map(), this.theme = new Theme(), this.background = "rgba(0, 0, 0, 0)", this.afterDrawCbs = [];
  }
  combineSubLayer(removeIncrementalKey = !0) {
    const subLayers = Array.from(this.subLayers.values()).sort((a, b) => a.zIndex - b.zIndex);
    this.layerHandler.merge(subLayers.map(l => (l.layer.subLayers.size && l.layer.combineSubLayer(removeIncrementalKey), l.layer.getNativeHandler()))), removeIncrementalKey && subLayers.forEach(l => {
      l.group && (l.group.incremental = 0);
    }), subLayers.forEach(l => {
      application.layerService.releaseLayer(this.stage, l.layer);
    }), this.subLayers.clear();
  }
  getNativeHandler() {
    return this.layerHandler;
  }
  setStage(stage, layer) {
    super.setStage(stage, this);
  }
  pick(x, y) {
    throw new Error("暂不支持");
  }
  tryRenderSecondaryLayer(params, userParams) {
    this.layerHandler.secondaryHandlers && this.layerHandler.secondaryHandlers.length && this.layerHandler.secondaryHandlers.forEach(h => {
      h.layer.renderCount = this.renderCount, h.layer.render(params, userParams);
    });
  }
  render(params, userParams) {
    var _a;
    this.layerHandler.render([this], {
      renderService: params.renderService,
      stage: this.stage,
      layer: this,
      viewBox: params.viewBox,
      transMatrix: params.transMatrix,
      background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
      updateBounds: params.updateBounds
    }, userParams), this.afterDrawCbs.forEach(c => c(this)), this.tryRenderSecondaryLayer(params, userParams);
  }
  resize(w, h) {
    this.layerHandler.resize(w, h);
  }
  resizeView(w, h) {
    this.layerHandler.resizeView(w, h);
  }
  setDpr(dpr) {
    this.layerHandler.setDpr(dpr);
  }
  afterDraw(cb) {
    this.afterDrawCbs.push(cb);
  }
  startAnimate(t) {
    throw new Error("暂不支持");
  }
  setToFrame(t) {
    throw new Error("暂不支持");
  }
  prepare(dirtyBounds, params) {}
  release() {
    super.release(), this.layerHandler.release(), this.subLayers && this.subLayers.forEach(l => {
      application.layerService.releaseLayer(this.stage, l.layer);
    });
  }
  drawTo(target, params) {
    var _a;
    this.layerHandler.drawTo(target, [this], Object.assign({
      background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
      renderService: params.renderService,
      viewBox: params.viewBox,
      transMatrix: params.transMatrix,
      stage: this.stage,
      layer: this
    }, params)), this.afterDrawCbs.forEach(c => c(this));
  }
}

const TransformUtil = Symbol.for("TransformUtil");
const GraphicUtil = Symbol.for("GraphicUtil");
const LayerService = Symbol.for("LayerService");
const StaticLayerHandlerContribution = Symbol.for("StaticLayerHandlerContribution");
const DynamicLayerHandlerContribution = Symbol.for("DynamicLayerHandlerContribution");
const VirtualLayerHandlerContribution = Symbol.for("VirtualLayerHandlerContribution");

var DefaultLayerService_1,
  __decorate$K = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$C = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let DefaultLayerService = DefaultLayerService_1 = class {
  static GenerateLayerId() {
    return `${DefaultLayerService_1.idprefix}_${DefaultLayerService_1.prefix_count++}`;
  }
  constructor() {
    this.layerMap = new Map(), this.global = application.global;
  }
  tryInit() {
    this.inited || (this.staticLayerCountInEnv = this.global.getStaticCanvasCount(), this.dynamicLayerCountInEnv = this.global.getDynamicCanvasCount(), this.inited = !0);
  }
  getStageLayer(stage) {
    return this.layerMap.get(stage);
  }
  getRecommendedLayerType(layerMode) {
    return layerMode || (0 !== this.staticLayerCountInEnv ? "static" : 0 !== this.dynamicLayerCountInEnv ? "dynamic" : "virtual");
  }
  getLayerHandler(layerMode) {
    let layerHandler;
    return layerHandler = "static" === layerMode ? container.get(StaticLayerHandlerContribution) : "dynamic" === layerMode ? container.get(DynamicLayerHandlerContribution) : container.get(VirtualLayerHandlerContribution), layerHandler;
  }
  createLayer(stage, options = {
    main: !1
  }) {
    var _a;
    this.tryInit();
    let layerMode = this.getRecommendedLayerType(options.layerMode);
    layerMode = options.main || options.canvasId ? "static" : layerMode;
    const layerHandler = this.getLayerHandler(layerMode),
      layer = new Layer(stage, this.global, stage.window, Object.assign(Object.assign({
        main: !1
      }, options), {
        layerMode: layerMode,
        canvasId: null !== (_a = options.canvasId) && void 0 !== _a ? _a : DefaultLayerService_1.GenerateLayerId(),
        layerHandler: layerHandler
      })),
      stageLayers = this.layerMap.get(stage) || [];
    return stageLayers.push(layer), this.layerMap.set(stage, stageLayers), this.staticLayerCountInEnv--, layer;
  }
  prepareStageLayer(stage) {
    let mainHandler;
    stage.forEachChildren(l => {
      const handler = l.getNativeHandler();
      "virtual" === handler.type ? (handler.mainHandler = mainHandler, mainHandler.secondaryHandlers.push(handler)) : (mainHandler = handler, mainHandler.secondaryHandlers = []);
    });
  }
  releaseLayer(stage, layer) {
    layer.release();
    const stageLayers = this.layerMap.get(stage) || [];
    this.layerMap.set(stage, stageLayers.filter(l => l !== layer));
  }
  layerCount(stage) {
    return (this.layerMap.get(stage) || []).length;
  }
  restLayerCount(stage) {
    return "browser" === this.global.env ? 10 : 0;
  }
  releaseStage(stage) {
    this.layerMap.delete(stage);
  }
};
DefaultLayerService.idprefix = "visactor_layer", DefaultLayerService.prefix_count = 0, DefaultLayerService = DefaultLayerService_1 = __decorate$K([injectable(), __metadata$C("design:paramtypes", [])], DefaultLayerService);

var coreModule = new ContainerModule(bind => {
  bind(VGlobal).to(DefaultGlobal).inSingletonScope(), bind(VWindow).to(DefaultWindow), bind(GraphicUtil).to(DefaultGraphicUtil).inSingletonScope(), bind(TransformUtil).to(DefaultTransformUtil).inSingletonScope(), bind(LayerService).to(DefaultLayerService).inSingletonScope();
});

function runFill(fill, background) {
  return !(!fill && !background);
}
function runStroke(stroke, lineWidth) {
  let s;
  return s = isArray(stroke) ? stroke.some(item => item || void 0 === item) : !!stroke, s && lineWidth > 0;
}
function fillVisible(opacity, fillOpacity, fill) {
  return fill && opacity * fillOpacity > 0;
}
function rectFillVisible(opacity, fillOpacity, width, height, fill) {
  return fill && opacity * fillOpacity > 0 && 0 !== width && 0 !== height;
}
function strokeVisible(opacity, strokeOpacity) {
  return opacity * strokeOpacity > 0;
}
function rectStrokeVisible(opacity, strokeOpacity, width, height, drawStrokeWhenZeroWH) {
  return drawStrokeWhenZeroWH ? opacity * strokeOpacity > 0 : opacity * strokeOpacity > 0 && 0 !== width && 0 !== height;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  const x10 = x1 - x0,
    y10 = y1 - y0,
    x32 = x3 - x2,
    y32 = y3 - y2;
  let t = y32 * x10 - x32 * y10;
  return t * t < epsilon ? [] : (t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, [x0 + t * x10, y0 + t * y10]);
}
function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
  const x01 = x0 - x1,
    y01 = y0 - y1,
    lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
    ox = lo * y01,
    oy = -lo * x01,
    x11 = x0 + ox,
    y11 = y0 + oy,
    x10 = x1 + ox,
    y10 = y1 + oy,
    x00 = (x11 + x10) / 2,
    y00 = (y11 + y10) / 2,
    dx = x10 - x11,
    dy = y10 - y11,
    d2 = dx * dx + dy * dy,
    r = r1 - rc,
    D = x11 * y10 - x10 * y11,
    d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
  let cx0 = (D * dy - dx * d) / d2,
    cy0 = (-D * dx - dy * d) / d2;
  const cx1 = (D * dy + dx * d) / d2,
    cy1 = (-D * dx + dy * d) / d2,
    dx0 = cx0 - x00,
    dy0 = cy0 - y00,
    dx1 = cx1 - x00,
    dy1 = cy1 - y00;
  return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius) {
  const deltaAngle = abs(endAngle - startAngle),
    cornerRadius = arc.getParsedCornerRadius(),
    cornerRadiusIsArray = isArray(cornerRadius),
    {
      outerDeltaAngle: outerDeltaAngle,
      innerDeltaAngle: innerDeltaAngle,
      outerStartAngle: outerStartAngle,
      outerEndAngle: outerEndAngle,
      innerEndAngle: innerEndAngle,
      innerStartAngle: innerStartAngle
    } = arc.getParsePadAngle(startAngle, endAngle),
    outerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[0] : cornerRadius,
    outerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[1] : cornerRadius,
    innerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[2] : cornerRadius,
    innerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[3] : cornerRadius,
    maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart),
    maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
  let limitedOcr = maxOuterCornerRadius,
    limitedIcr = maxInnerCornerRadius;
  const xors = outerRadius * cos(outerStartAngle),
    yors = outerRadius * sin(outerStartAngle),
    xire = innerRadius * cos(innerEndAngle),
    yire = innerRadius * sin(innerEndAngle);
  let xore, yore, xirs, yirs;
  if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
    const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
    if (oc) {
      const ax = xors - oc[0],
        ay = yors - oc[1],
        bx = xore - oc[0],
        by = yore - oc[1],
        kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
        lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
      limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
    }
  }
  return {
    outerDeltaAngle: outerDeltaAngle,
    xors: xors,
    yors: yors,
    xirs: xirs,
    yirs: yirs,
    xore: xore,
    yore: yore,
    xire: xire,
    yire: yire,
    limitedOcr: limitedOcr,
    limitedIcr: limitedIcr,
    outerCornerRadiusStart: outerCornerRadiusStart,
    outerCornerRadiusEnd: outerCornerRadiusEnd,
    maxOuterCornerRadius: maxOuterCornerRadius,
    maxInnerCornerRadius: maxInnerCornerRadius,
    outerStartAngle: outerStartAngle,
    outerEndAngle: outerEndAngle,
    innerDeltaAngle: innerDeltaAngle,
    innerEndAngle: innerEndAngle,
    innerStartAngle: innerStartAngle,
    innerCornerRadiusStart: innerCornerRadiusStart,
    innerCornerRadiusEnd: innerCornerRadiusEnd
  };
}
function drawArcPath(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
  const {
      startAngle: startAngle,
      endAngle: endAngle
    } = arc.getParsedAngle(),
    deltaAngle = abs(endAngle - startAngle),
    clockwise = endAngle > startAngle;
  let collapsedToLine = !1;
  if (outerRadius < innerRadius) {
    const temp = outerRadius;
    outerRadius = innerRadius, innerRadius = temp;
  }
  if (outerRadius <= epsilon) context.moveTo(cx, cy);else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise));else {
    const {
      outerDeltaAngle: outerDeltaAngle,
      xors: xors,
      yors: yors,
      xirs: xirs,
      yirs: yirs,
      limitedOcr: limitedOcr,
      outerCornerRadiusStart: outerCornerRadiusStart,
      outerCornerRadiusEnd: outerCornerRadiusEnd,
      maxOuterCornerRadius: maxOuterCornerRadius,
      xore: xore,
      yore: yore,
      xire: xire,
      yire: yire,
      outerStartAngle: outerStartAngle,
      outerEndAngle: outerEndAngle,
      limitedIcr: limitedIcr,
      innerDeltaAngle: innerDeltaAngle,
      innerEndAngle: innerEndAngle,
      innerStartAngle: innerStartAngle,
      innerCornerRadiusStart: innerCornerRadiusStart,
      innerCornerRadiusEnd: innerCornerRadiusEnd,
      maxInnerCornerRadius: maxInnerCornerRadius
    } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
    if (outerDeltaAngle < .001) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), collapsedToLine = !0;else if (limitedOcr > epsilon) {
      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr),
        cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr),
        t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)),
        t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
      limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * cos(atan2(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * sin(atan2(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, outerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * sin(outerEndAngle));
    } else !partStroke || partStroke[0] ? (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise)) : context.moveTo(cx + outerRadius * cos(outerEndAngle), cy + outerRadius * sin(outerEndAngle));
    if (!(innerRadius > epsilon) || innerDeltaAngle < .001) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), collapsedToLine = !0;else if (limitedIcr > epsilon) {
      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr),
        cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr),
        t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)),
        t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
      if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
        const arcEndAngle = atan2(t1.y01, t1.x01);
        !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + cos(arcEndAngle), cy + t0.cy + sin(arcEndAngle));
      } else !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, innerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);
    } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
  }
  return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)) : context.closePath(), collapsedToLine;
}

const ArcRenderContribution = Symbol.for("ArcRenderContribution");
const AreaRenderContribution = Symbol.for("AreaRenderContribution");
const CircleRenderContribution = Symbol.for("CircleRenderContribution");
const GroupRenderContribution = Symbol.for("GroupRenderContribution");
const ImageRenderContribution = Symbol.for("ImageRenderContribution");
const PathRenderContribution = Symbol.for("PathRenderContribution");
const PolygonRenderContribution = Symbol.for("PolygonRenderContribution");
const RectRenderContribution = Symbol.for("RectRenderContribution");
const SymbolRenderContribution = Symbol.for("SymbolRenderContribution");
const TextRenderContribution = Symbol.for("TextRenderContribution");
const InteractiveSubRenderContribution = Symbol.for("InteractiveSubRenderContribution");

function textDrawOffsetX(textAlign, width) {
  return "end" === textAlign || "right" === textAlign ? -width : "center" === textAlign ? -width / 2 : 0;
}
function textLayoutOffsetY(baseline, lineHeight, fontSize, buf = 0) {
  return "middle" === baseline ? -lineHeight / 2 : "top" === baseline ? 0 : "bottom" === baseline ? buf - lineHeight : baseline && "alphabetic" !== baseline ? 0 : (fontSize || (fontSize = lineHeight), -(lineHeight - fontSize) / 2 - .79 * fontSize);
}

var __decorate$J = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$B = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$y = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
function getModelMatrix(out, graphic, theme) {
  var _a;
  const {
      x = theme.x,
      y = theme.y,
      z = theme.z,
      dx = theme.dx,
      dy = theme.dy,
      dz = theme.dz,
      scaleX = theme.scaleX,
      scaleY = theme.scaleY,
      scaleZ = theme.scaleZ,
      alpha = theme.alpha,
      beta = theme.beta,
      angle = theme.angle,
      anchor3d = graphic.attribute.anchor,
      anchor: anchor
    } = graphic.attribute,
    _anchor = [0, 0, 0];
  if (anchor3d) {
    if ("string" == typeof anchor3d[0]) {
      const ratio = parseFloat(anchor3d[0]) / 100,
        bounds = graphic.AABBBounds;
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[0] = anchor3d[0];
    if ("string" == typeof anchor3d[1]) {
      const ratio = parseFloat(anchor3d[1]) / 100,
        bounds = graphic.AABBBounds;
      _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[1] = anchor3d[1];
    _anchor[2] = null !== (_a = anchor3d[2]) && void 0 !== _a ? _a : 0;
  }
  if (identityMat4(out), translate(out, out, [x + dx, y + dy, z + dz]), translate(out, out, [_anchor[0], _anchor[1], _anchor[2]]), rotateX(out, out, beta), rotateY(out, out, alpha), translate(out, out, [-_anchor[0], -_anchor[1], _anchor[2]]), scaleMat4(out, out, [scaleX, scaleY, scaleZ]), angle) {
    const m = mat4Allocate.allocate(),
      _anchor = [0, 0];
    if (anchor) {
      if ("string" == typeof anchor3d[0]) {
        const ratio = parseFloat(anchor3d[0]) / 100,
          bounds = graphic.AABBBounds;
        _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else _anchor[0] = anchor3d[0];
      if ("string" == typeof anchor3d[1]) {
        const ratio = parseFloat(anchor3d[1]) / 100,
          bounds = graphic.AABBBounds;
        _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else _anchor[1] = anchor3d[1];
    }
    translate(m, m, [_anchor[0], _anchor[1], 0]), rotateZ(m, m, angle), translate(m, m, [-_anchor[0], -_anchor[1], 0]), multiplyMat4Mat4(out, out, m);
  }
}
function shouldUseMat4(graphic) {
  const {
    alpha: alpha,
    beta: beta
  } = graphic.attribute;
  return alpha || beta;
}
let DefaultGraphicService = class {
  constructor(creator) {
    this.creator = creator, this.hooks = {
      onAttributeUpdate: new SyncHook(["graphic"]),
      onSetStage: new SyncHook(["graphic", "stage"]),
      onRemove: new SyncHook(["graphic"]),
      onRelease: new SyncHook(["graphic"]),
      onAddIncremental: new SyncHook(["graphic", "group", "stage"]),
      onClearIncremental: new SyncHook(["graphic", "group", "stage"]),
      beforeUpdateAABBBounds: new SyncHook(["graphic", "stage", "willUpdate", "aabbBounds"]),
      afterUpdateAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds", "globalAABBBounds", "selfChange"]),
      clearAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds"])
    }, this.tempAABBBounds1 = new AABBBounds(), this.tempAABBBounds2 = new AABBBounds();
  }
  onAttributeUpdate(graphic) {
    this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(graphic);
  }
  onSetStage(graphic, stage) {
    this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(graphic, stage);
  }
  onRemove(graphic) {
    this.hooks.onRemove.taps.length && this.hooks.onRemove.call(graphic);
  }
  onRelease(graphic) {
    this.hooks.onRelease.taps.length && this.hooks.onRelease.call(graphic);
  }
  onAddIncremental(graphic, group, stage) {
    this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(graphic, group, stage);
  }
  onClearIncremental(group, stage) {
    this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(group, stage);
  }
  beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
    this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
  }
  afterUpdateAABBBounds(graphic, stage, bounds, params, selfChange) {
    this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params, selfChange);
  }
  clearAABBBounds(graphic, stage, b) {
    this.hooks.clearAABBBounds.taps.length && this.hooks.clearAABBBounds.call(graphic, stage, b);
  }
  updatePathProxyAABBBounds(aabbBounds, graphic) {
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    if (!path) return !1;
    const boundsContext = new BoundsContext(aabbBounds);
    return renderCommandList(path.commandList, boundsContext, 0, 0), !0;
  }
  updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
    const {
      textAlign: textAlign,
      textBaseline: textBaseline
    } = attribute;
    if (null != attribute.forceBoundsHeight) {
      const h = isNumber(attribute.forceBoundsHeight) ? attribute.forceBoundsHeight : attribute.forceBoundsHeight(),
        dy = textLayoutOffsetY(textBaseline, h, h);
      aabbBounds.set(aabbBounds.x1, dy, aabbBounds.x2, dy + h);
    }
    if (null != attribute.forceBoundsWidth) {
      const w = isNumber(attribute.forceBoundsWidth) ? attribute.forceBoundsWidth : attribute.forceBoundsWidth(),
        dx = textDrawOffsetX(textAlign, w);
      aabbBounds.set(dx, aabbBounds.y1, dx + w, aabbBounds.y2);
    }
  }
  combindShadowAABBBounds(bounds, graphic) {
    if (graphic && graphic.shadowRoot) {
      const b = graphic.shadowRoot.AABBBounds;
      bounds.union(b);
    }
  }
  transformAABBBounds(attribute, aabbBounds, theme, miter, graphic) {
    if (!aabbBounds.empty()) {
      const {
          scaleX = theme.scaleX,
          scaleY = theme.scaleY,
          stroke = theme.stroke,
          shadowBlur = theme.shadowBlur,
          lineWidth = theme.lineWidth,
          pickStrokeBuffer = theme.pickStrokeBuffer,
          strokeBoundsBuffer = theme.strokeBoundsBuffer
        } = attribute,
        tb1 = this.tempAABBBounds1,
        tb2 = this.tempAABBBounds2;
      if (stroke && lineWidth) {
        const scaledHalfLineWidth = (lineWidth + pickStrokeBuffer) / Math.abs(scaleX + scaleY);
        boundStroke(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
      }
      if (shadowBlur) {
        const {
            shadowOffsetX = theme.shadowOffsetX,
            shadowOffsetY = theme.shadowOffsetY
          } = attribute,
          shadowBlurWidth = shadowBlur / Math.abs(scaleX + scaleY) * 2;
        boundStroke(tb1, shadowBlurWidth, !1, strokeBoundsBuffer + 1), tb1.translate(shadowOffsetX, shadowOffsetY), aabbBounds.union(tb1);
      }
    }
    if (this.combindShadowAABBBounds(aabbBounds, graphic), aabbBounds.empty()) return;
    let updateMatrix = !0;
    const m = graphic.transMatrix;
    graphic && graphic.isContainer && (updateMatrix = !(1 === m.a && 0 === m.b && 0 === m.c && 1 === m.d && 0 === m.e && 0 === m.f)), updateMatrix && transformBoundsWithMatrix(aabbBounds, aabbBounds, m);
  }
  validCheck(attribute, theme, aabbBounds, graphic) {
    if (!graphic) return !0;
    if (null != attribute.forceBoundsHeight || null != attribute.forceBoundsWidth) return !0;
    if (graphic.shadowRoot || graphic.isContainer) return !0;
    const {
      visible = theme.visible
    } = attribute;
    return !(!graphic.valid || !visible) || (aabbBounds.empty() || (graphic.parent && aabbBounds.transformWithMatrix(graphic.parent.globalTransMatrix), this.clearAABBBounds(graphic, graphic.stage, aabbBounds), aabbBounds.clear()), !1);
  }
  updateTempAABBBounds(aabbBounds) {
    const tb1 = this.tempAABBBounds1,
      tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), {
      tb1: tb1,
      tb2: tb2
    };
  }
};
DefaultGraphicService = __decorate$J([injectable(), __param$y(0, inject(GraphicCreator$1)), __metadata$B("design:paramtypes", [Object])], DefaultGraphicService);

const updateBoundsOfCommonOuterBorder = (attribute, theme, aabbBounds) => {
  const {
    outerBorder: outerBorder,
    shadowBlur = theme.shadowBlur
  } = attribute;
  if (outerBorder) {
    const defaultOuterBorder = theme.outerBorder,
      {
        distance = defaultOuterBorder.distance,
        lineWidth = defaultOuterBorder.lineWidth
      } = outerBorder;
    aabbBounds.expand(distance + (shadowBlur + lineWidth) / 2);
  }
  return aabbBounds;
};

const CIRCLE_UPDATE_TAG_KEY = ["radius", "startAngle", "endAngle", ...GRAPHIC_UPDATE_TAG_KEY];
class Circle extends Graphic {
  constructor(params = {
    radius: 1
  }) {
    super(params), this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      startAngle: startAngle,
      endAngle: endAngle,
      radius: radius
    } = this.attribute;
    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);
  }
  getGraphicTheme() {
    return getTheme(this).circle;
  }
  updateAABBBounds(attribute, circleTheme, aabbBounds, full) {
    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds));
    const {
      tb1: tb1,
      tb2: tb2
    } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return updateBoundsOfCommonOuterBorder(attribute, circleTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, circleTheme, !1, this), aabbBounds;
  }
  updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) {
    const {
      radius = circleTheme.radius
    } = attribute;
    return aabbBounds.set(-radius, -radius, radius, radius), aabbBounds;
  }
  updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds) {
    const {
      startAngle = circleTheme.startAngle,
      endAngle = circleTheme.endAngle,
      radius = circleTheme.radius
    } = attribute;
    return endAngle - startAngle > pi2 - epsilon ? aabbBounds.set(-radius, -radius, radius, radius) : circleBounds(startAngle, endAngle, radius, aabbBounds), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, CIRCLE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, CIRCLE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    var _a, _b, _c;
    let path = super.toCustomPath();
    if (path) return path;
    const attribute = this.attribute,
      radius = null !== (_a = attribute.radius) && void 0 !== _a ? _a : this.getDefaultAttribute("radius"),
      startAngle = null !== (_b = attribute.startAngle) && void 0 !== _b ? _b : this.getDefaultAttribute("startAngle"),
      endAngle = null !== (_c = attribute.endAngle) && void 0 !== _c ? _c : this.getDefaultAttribute("endAngle");
    return path = new CustomPath2D(), path.arc(0, 0, radius, startAngle, endAngle), path;
  }
  clone() {
    return new Circle(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Circle.NOWORK_ANIMATE_ATTR;
  }
}
Circle.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createCircle(attributes) {
  return new Circle(attributes);
}

class CanvasTextLayout {
  constructor(fontFamily, options, textMeasure) {
    this.fontFamily = fontFamily, this.textOptions = options, this.textMeasure = textMeasure;
  }
  LayoutBBox(bbox, textAlign, textBaseline, linesLayout) {
    if (bbox.xOffset = "left" === textAlign || "start" === textAlign ? 0 : "center" === textAlign ? bbox.width / -2 : "right" === textAlign || "end" === textAlign ? -bbox.width : 0, "top" === textBaseline) bbox.yOffset = 0;else if ("middle" === textBaseline) bbox.yOffset = bbox.height / -2;else if ("alphabetic" === textBaseline) {
      let percent = .79;
      if (1 === linesLayout.length) {
        const lineInfo = linesLayout[0];
        percent = lineInfo.ascent / (lineInfo.ascent + lineInfo.descent);
      }
      bbox.yOffset = bbox.height * -percent;
    } else bbox.yOffset = -bbox.height;
    return bbox;
  }
  GetLayoutByLines(lines, textAlign, textBaseline, lineHeight, suffix = "", wordBreak, params) {
    const {
      lineWidth: lineWidth,
      suffixPosition = "end",
      measureMode = MeasureModeEnum.actualBounding,
      keepCenterInLine = !1
    } = null != params ? params : {};
    lines = lines.map(l => l.toString());
    const linesLayout = [],
      bboxWH = [0, 0];
    if ("number" == typeof lineWidth && lineWidth !== 1 / 0) {
      let width;
      for (let i = 0, len = lines.length; i < len; i++) {
        const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
        let str = lines[i].toString();
        if (metrics.width > lineWidth) {
          const data = this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, lineWidth, suffix, wordBreak, suffixPosition);
          str = data.str, width = data.width;
        } else width = metrics.width;
        linesLayout.push({
          str: str,
          width: width,
          ascent: metrics.ascent,
          descent: metrics.descent,
          keepCenterInLine: keepCenterInLine
        });
      }
      bboxWH[0] = lineWidth;
    } else {
      let width,
        text,
        _lineWidth = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        text = lines[i];
        const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
        width = metrics.width, _lineWidth = Math.max(_lineWidth, width), linesLayout.push({
          str: text,
          width: width,
          ascent: metrics.ascent,
          descent: metrics.descent,
          keepCenterInLine: keepCenterInLine
        });
      }
      bboxWH[0] = _lineWidth;
    }
    bboxWH[1] = linesLayout.length * lineHeight, bboxWH[0] = linesLayout.reduce((a, b) => Math.max(a, b.width), 0);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    return this.LayoutBBox(bbox, textAlign, textBaseline, linesLayout), this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
  }
  layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
    const origin = [0, 0],
      totalLineHeight = lines.length * lineHeight;
    "top" === textBaseline || ("middle" === textBaseline ? origin[1] = (bbox.height - totalLineHeight) / 2 : "bottom" === textBaseline && (origin[1] = bbox.height - totalLineHeight));
    for (let i = 0; i < lines.length; i++) this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);
    return {
      bbox: bbox,
      lines: lines,
      fontFamily: this.fontFamily,
      fontSize: this.textOptions.fontSize,
      fontWeight: this.textOptions.fontWeight,
      lineHeight: lineHeight,
      textAlign: textAlign,
      textBaseline: textBaseline
    };
  }
  lineOffset(bbox, line, textAlign, textBaseline, lineHeight, origin) {
    if ("left" === textAlign || "start" === textAlign ? line.leftOffset = 0 : "center" === textAlign ? line.leftOffset = (bbox.width - line.width) / 2 : "right" !== textAlign && "end" !== textAlign || (line.leftOffset = bbox.width - line.width), line.topOffset = lineHeight / 2 + (line.ascent - line.descent) / 2 + origin[1], !line.keepCenterInLine) {
      const buf = 0,
        actualHeightWithBuf = line.ascent + line.descent + buf;
      if (actualHeightWithBuf < lineHeight - buf && ("bottom" === textBaseline ? line.topOffset += (lineHeight - actualHeightWithBuf) / 2 : "top" === textBaseline && (line.topOffset -= (lineHeight - actualHeightWithBuf) / 2)), "alphabetic" === textBaseline) {
        const ratio = lineHeight / (line.ascent + line.descent);
        line.topOffset = lineHeight / 2 + (line.ascent - line.descent) / 2 * ratio + origin[1];
      }
    }
    return origin[1] += lineHeight, line;
  }
}

const TEXT_UPDATE_TAG_KEY = ["text", "maxLineWidth", "maxWidth", "textAlign", "textBaseline", "heightLimit", "lineClamp", "fontSize", "fontFamily", "fontWeight", "ellipsis", "lineHeight", "direction", "wordBreak", "heightLimit", "lineClamp", ...GRAPHIC_UPDATE_TAG_KEY];
class Text extends Graphic {
  get font() {
    const textTheme = this.getGraphicTheme();
    return this._font || (this._font = getContextFont(this.attribute, textTheme)), this._font;
  }
  get clipedText() {
    var _a;
    const attribute = this.attribute,
      textTheme = this.getGraphicTheme(),
      maxWidth = this.getMaxWidth(textTheme);
    return Number.isFinite(maxWidth) ? (this.tryUpdateAABBBounds(), this.cache.clipedText) : (null !== (_a = attribute.text) && void 0 !== _a ? _a : textTheme.text).toString();
  }
  get clipedWidth() {
    return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
  }
  get cliped() {
    var _a, _b;
    const textTheme = this.getGraphicTheme(),
      attribute = this.attribute,
      maxWidth = this.getMaxWidth(textTheme);
    if (!Number.isFinite(maxWidth)) return !1;
    const {
      text: text
    } = this.attribute;
    if (this.tryUpdateAABBBounds(), null === (_b = null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData) || void 0 === _b ? void 0 : _b.lines) {
      let mergedText = "";
      this.cache.layoutData.lines.forEach(item => {
        mergedText += item.str;
      });
      return (Array.isArray(text) ? text.join("") : text) !== mergedText;
    }
    return "vertical" === attribute.direction && this.cache.verticalList && this.cache.verticalList[0] ? this.cache.verticalList[0].map(item => item.text).join("") !== attribute.text.toString() : null != this.clipedText && this.clipedText !== attribute.text.toString();
  }
  get multilineLayout() {
    return this.tryUpdateAABBBounds(), this.cache.layoutData;
  }
  get isMultiLine() {
    return Array.isArray(this.attribute.text) || "normal" === this.attribute.whiteSpace;
  }
  constructor(params = {
    text: "",
    fontSize: 16
  }) {
    super(params), this.type = "text", this.numberType = TEXT_NUMBER_TYPE, this.cache = {};
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      text: text
    } = this.attribute;
    return isArray(text) ? !text.every(t => null == t || "" === t) : null != text && "" !== text;
  }
  getGraphicTheme() {
    return getTheme(this).text;
  }
  doUpdateOBBBounds() {
    const graphicTheme = this.getGraphicTheme();
    this._OBBBounds.clear();
    const attribute = this.attribute,
      {
        angle = graphicTheme.angle
      } = attribute;
    if (!angle) {
      const b = this.AABBBounds;
      return this._OBBBounds.setValue(b.x1, b.y1, b.x2, b.y2), this._OBBBounds;
    }
    this.obbText || (this.obbText = new Text({})), this.obbText.setAttributes(Object.assign(Object.assign({}, attribute), {
      angle: 0
    }));
    const bounds1 = this.obbText.AABBBounds,
      {
        x: x,
        y: y
      } = attribute,
      boundsCenter = {
        x: (bounds1.x1 + bounds1.x2) / 2,
        y: (bounds1.y1 + bounds1.y2) / 2
      },
      center = rotatePoint(boundsCenter, angle, {
        x: x,
        y: y
      });
    return this._OBBBounds.copy(bounds1), this._OBBBounds.translate(center.x - boundsCenter.x, center.y - boundsCenter.y), this._OBBBounds.angle = angle, this._OBBBounds;
  }
  updateAABBBounds(attribute, textTheme, aabbBounds) {
    const {
      text = textTheme.text
    } = this.attribute;
    Array.isArray(text) ? this.updateMultilineAABBBounds(text) : this.updateSingallineAABBBounds(text);
    const {
        tb1: tb1
      } = application.graphicService.updateTempAABBBounds(aabbBounds),
      {
        scaleX = textTheme.scaleX,
        scaleY = textTheme.scaleY,
        shadowBlur = textTheme.shadowBlur,
        strokeBoundsBuffer = textTheme.strokeBoundsBuffer
      } = attribute;
    if (shadowBlur) {
      const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
      boundStroke(tb1, shadowBlurHalfWidth, !0, strokeBoundsBuffer), aabbBounds.union(tb1);
    }
    return application.graphicService.combindShadowAABBBounds(aabbBounds, this), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || application.graphicService.updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, transformBoundsWithMatrix(aabbBounds, aabbBounds, this.transMatrix), aabbBounds;
  }
  updateSingallineAABBBounds(text) {
    this.updateMultilineAABBBounds([text]);
    const layoutData = this.cache.layoutData;
    if (layoutData && layoutData.lines && layoutData.lines.length) {
      const line = layoutData.lines[0];
      this.cache.clipedText = line.str, this.cache.clipedWidth = line.width;
    }
    return this._AABBBounds;
  }
  updateMultilineAABBBounds(text) {
    const textTheme = this.getGraphicTheme(),
      {
        direction = textTheme.direction,
        underlineOffset = textTheme.underlineOffset
      } = this.attribute,
      b = "horizontal" === direction ? this.updateHorizontalMultilineAABBBounds(text) : this.updateVerticalMultilineAABBBounds(text);
    return "horizontal" === direction && underlineOffset && this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + underlineOffset), b;
  }
  guessLineHeightBuf(fontSize) {
    return fontSize ? .1 * fontSize : 0;
  }
  updateHorizontalMultilineAABBBounds(text) {
    var _a;
    const textTheme = this.getGraphicTheme(),
      attribute = this.attribute,
      {
        fontFamily = textTheme.fontFamily,
        textAlign = textTheme.textAlign,
        textBaseline = textTheme.textBaseline,
        fontSize = textTheme.fontSize,
        fontWeight = textTheme.fontWeight,
        ellipsis = textTheme.ellipsis,
        maxLineWidth: maxLineWidth,
        stroke = textTheme.stroke,
        wrap = textTheme.wrap,
        measureMode = textTheme.measureMode,
        lineWidth = textTheme.lineWidth,
        whiteSpace = textTheme.whiteSpace,
        suffixPosition = textTheme.suffixPosition,
        ignoreBuf = textTheme.ignoreBuf,
        keepCenterInLine = textTheme.keepCenterInLine
      } = attribute,
      buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize),
      lineHeight = this.getLineHeight(attribute, textTheme, buf);
    if ("normal" === whiteSpace || wrap) return this.updateWrapAABBBounds(text);
    if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
      const bbox = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure,
      layoutData = new CanvasTextLayout(fontFamily, {
        fontSize: fontSize,
        fontWeight: fontWeight,
        fontFamily: fontFamily,
        lineHeight: lineHeight
      }, textMeasure).GetLayoutByLines(text, textAlign, textBaseline, lineHeight, !0 === ellipsis ? textTheme.ellipsis : ellipsis || void 0, !1, {
        lineWidth: maxLineWidth,
        suffixPosition: suffixPosition,
        measureMode: measureMode,
        keepCenterInLine: keepCenterInLine
      }),
      {
        bbox: bbox
      } = layoutData;
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateWrapAABBBounds(text) {
    var _a, _b, _c;
    const textTheme = this.getGraphicTheme(),
      {
        fontFamily = textTheme.fontFamily,
        textAlign = textTheme.textAlign,
        textBaseline = textTheme.textBaseline,
        fontSize = textTheme.fontSize,
        ellipsis = textTheme.ellipsis,
        maxLineWidth: maxLineWidth,
        stroke = textTheme.stroke,
        lineWidth = textTheme.lineWidth,
        wordBreak = textTheme.wordBreak,
        fontWeight = textTheme.fontWeight,
        ignoreBuf = textTheme.ignoreBuf,
        measureMode = textTheme.measureMode,
        suffixPosition = textTheme.suffixPosition,
        heightLimit = 0,
        lineClamp: lineClamp,
        keepCenterInLine = textTheme.keepCenterInLine
      } = this.attribute,
      buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize),
      lineHeight = this.getLineHeight(this.attribute, textTheme, buf);
    if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
      const bbox = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure,
      textOptions = {
        fontSize: fontSize,
        fontWeight: fontWeight,
        fontFamily: fontFamily,
        lineHeight: lineHeight
      },
      layoutObj = new CanvasTextLayout(fontFamily, textOptions, textMeasure),
      lines = isArray(text) ? text.map(l => l.toString()) : [text.toString()],
      linesLayout = [],
      bboxWH = [0, 0];
    let lineCountLimit = 1 / 0;
    if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
      if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
        const str = lines[i];
        let needCut = !0;
        if (i === lineCountLimit - 1) {
          const clip = textMeasure.clipTextWithSuffix(str, textOptions, maxLineWidth, ellipsis, !1, suffixPosition, i !== lines.length - 1),
            matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
          linesLayout.push({
            str: clip.str,
            width: clip.width,
            ascent: matrics.ascent,
            descent: matrics.descent,
            keepCenterInLine: keepCenterInLine
          });
          break;
        }
        const clip = textMeasure.clipText(str, textOptions, maxLineWidth, "break-all" !== wordBreak, "keep-all" === wordBreak);
        if ("" !== str && "" === clip.str || clip.wordBreaked) {
          if (ellipsis) {
            const clipEllipsis = textMeasure.clipTextWithSuffix(str, textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
            clip.str = null !== (_b = clipEllipsis.str) && void 0 !== _b ? _b : "", clip.width = null !== (_c = clipEllipsis.width) && void 0 !== _c ? _c : 0;
          } else clip.str = "", clip.width = 0;
          needCut = !1;
        }
        const matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
        linesLayout.push({
          str: clip.str,
          width: clip.width,
          ascent: matrics.ascent,
          descent: matrics.descent,
          keepCenterInLine: keepCenterInLine
        });
        let cutLength = clip.str.length;
        if (!clip.wordBreaked || "" !== str && "" === clip.str || (needCut = !0, cutLength = clip.wordBreaked), clip.str.length === str.length) ;else if (needCut) {
          let newStr = str.substring(cutLength);
          "keep-all" === wordBreak && (newStr = newStr.replace(/^\s+/g, "")), lines.splice(i + 1, 0, newStr);
        }
      }
      let maxWidth = 0;
      linesLayout.forEach(layout => {
        maxWidth = Math.max(maxWidth, layout.width);
      }), bboxWH[0] = maxWidth;
    } else {
      let width,
        text,
        lineWidth = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        if (i === lineCountLimit - 1) {
          const clip = textMeasure.clipTextWithSuffix(lines[i], textOptions, maxLineWidth, ellipsis, !1, suffixPosition),
            matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
          linesLayout.push({
            str: clip.str,
            width: clip.width,
            ascent: matrics.ascent,
            descent: matrics.descent,
            keepCenterInLine: keepCenterInLine
          }), lineWidth = Math.max(lineWidth, clip.width);
          break;
        }
        text = lines[i], width = textMeasure.measureTextWidth(text, textOptions), lineWidth = Math.max(lineWidth, width);
        const matrics = textMeasure.measureTextPixelADscentAndWidth(text, textOptions, measureMode);
        linesLayout.push({
          str: text,
          width: width,
          ascent: matrics.ascent,
          descent: matrics.descent,
          keepCenterInLine: keepCenterInLine
        });
      }
      bboxWH[0] = lineWidth;
    }
    bboxWH[1] = linesLayout.length * lineHeight;
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    layoutObj.LayoutBBox(bbox, textAlign, textBaseline, linesLayout);
    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateVerticalMultilineAABBBounds(text) {
    var _a, _b;
    const textTheme = this.getGraphicTheme(),
      textMeasure = application.graphicUtil.textMeasure;
    let width;
    const attribute = this.attribute,
      {
        maxLineWidth = textTheme.maxLineWidth,
        ellipsis = textTheme.ellipsis,
        fontFamily = textTheme.fontFamily,
        fontSize = textTheme.fontSize,
        fontWeight = textTheme.fontWeight,
        stroke = textTheme.stroke,
        lineWidth = textTheme.lineWidth,
        verticalMode = textTheme.verticalMode,
        suffixPosition = textTheme.suffixPosition
      } = attribute,
      lineHeight = this.getLineHeight(attribute, textTheme, 0);
    let {
      textAlign = textTheme.textAlign,
      textBaseline = textTheme.textBaseline
    } = attribute;
    if (!verticalMode) {
      const t = textAlign;
      textAlign = null !== (_a = Text.baselineMapAlign[textBaseline]) && void 0 !== _a ? _a : "left", textBaseline = null !== (_b = Text.alignMapBaseline[t]) && void 0 !== _b ? _b : "top";
    }
    if (width = 0, !this.shouldUpdateShape() && this.cache) {
      this.cache.verticalList.forEach(item => {
        const w = item.reduce((a, b) => a + b.width, 0);
        width = max(w, width);
      });
      const dx = textDrawOffsetX(textAlign, width),
        height = this.cache.verticalList.length * lineHeight,
        dy = textLayoutOffsetY(textBaseline, height, fontSize);
      return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const verticalLists = text.map(str => verticalLayout(str.toString()));
    verticalLists.forEach((verticalData, i) => {
      if (Number.isFinite(maxLineWidth)) {
        if (ellipsis) {
          const strEllipsis = !0 === ellipsis ? textTheme.ellipsis : ellipsis,
            data = textMeasure.clipTextWithSuffixVertical(verticalData, {
              fontSize: fontSize,
              fontWeight: fontWeight,
              fontFamily: fontFamily
            }, maxLineWidth, strEllipsis, !1, suffixPosition);
          verticalLists[i] = data.verticalList, width = data.width;
        } else {
          const data = textMeasure.clipTextVertical(verticalData, {
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontFamily: fontFamily
          }, maxLineWidth, !1);
          verticalLists[i] = data.verticalList, width = data.width;
        }
      } else width = 0, verticalData.forEach(t => {
        const w = t.direction === TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t.text, {
          fontSize: fontSize,
          fontWeight: fontWeight,
          fontFamily: fontFamily
        });
        width += w, t.width = w;
      });
    }), this.cache.verticalList = verticalLists, this.clearUpdateShapeTag(), this.cache.verticalList.forEach(item => {
      const w = item.reduce((a, b) => a + b.width, 0);
      width = max(w, width);
    });
    const dx = textDrawOffsetX(textAlign, width),
      height = this.cache.verticalList.length * lineHeight,
      dy = textLayoutOffsetY(textBaseline, height, fontSize);
    return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  getMaxWidth(theme) {
    var _a, _b;
    const attribute = this.attribute;
    return null !== (_b = null !== (_a = attribute.maxLineWidth) && void 0 !== _a ? _a : attribute.maxWidth) && void 0 !== _b ? _b : theme.maxWidth;
  }
  getLineHeight(attribute, textTheme, buf) {
    var _a;
    return null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
  }
  needUpdateTags(keys, k = TEXT_UPDATE_TAG_KEY) {
    return super.needUpdateTags(keys, k);
  }
  needUpdateTag(key, k = TEXT_UPDATE_TAG_KEY) {
    return super.needUpdateTag(key, k);
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "text" === key && (nextAttributes.text = nextStepVal);
  }
  clone() {
    return new Text(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Text.NOWORK_ANIMATE_ATTR;
  }
  getBaselineMapAlign() {
    return Text.baselineMapAlign;
  }
  getAlignMapBaseline() {
    return Text.alignMapBaseline;
  }
}
Text.NOWORK_ANIMATE_ATTR = Object.assign({
  ellipsis: 1,
  wordBreak: 1,
  direction: 1,
  textAlign: 1,
  textBaseline: 1,
  fontFamily: 1,
  fontWeight: 1
}, NOWORK_ANIMATE_ATTR), Text.baselineMapAlign = {
  top: "left",
  bottom: "right",
  middle: "center"
}, Text.alignMapBaseline = {
  left: "top",
  right: "bottom",
  center: "middle"
};
function createText(attributes) {
  return new Text(attributes);
}

const WRAP_TEXT_UPDATE_TAG_KEY = ["heightLimit", "lineClamp"];
class WrapText extends Text {
  constructor(params) {
    super(Object.assign(Object.assign({}, params), {
      wrap: !0
    }));
  }
  _isValid() {
    const {
      text: text
    } = this.attribute;
    return isArray(text) ? !text.every(t => null == t || "" === t) : null != text && "" !== text;
  }
  updateMultilineAABBBounds(text) {
    var _a, _b, _c, _d;
    const textTheme = this.getGraphicTheme(),
      {
        fontFamily = textTheme.fontFamily,
        textAlign = textTheme.textAlign,
        textBaseline = textTheme.textBaseline,
        fontSize = textTheme.fontSize,
        ellipsis = textTheme.ellipsis,
        maxLineWidth: maxLineWidth,
        stroke = textTheme.stroke,
        lineWidth = textTheme.lineWidth,
        wordBreak = textTheme.wordBreak,
        fontWeight = textTheme.fontWeight,
        ignoreBuf = textTheme.ignoreBuf,
        heightLimit = 0,
        suffixPosition = textTheme.suffixPosition,
        lineClamp: lineClamp
      } = this.attribute,
      lineHeight = null !== (_a = calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : this.attribute.fontSize || textTheme.fontSize,
      buf = ignoreBuf ? 0 : 2;
    if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
      const bbox = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure,
      layoutObj = new CanvasTextLayout(fontFamily, {
        fontSize: fontSize,
        fontWeight: fontWeight,
        fontFamily: fontFamily
      }, textMeasure),
      lines = text.map(l => l.toString()),
      linesLayout = [],
      bboxWH = [0, 0];
    let lineCountLimit = 1 / 0;
    if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
      if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
        const str = lines[i];
        let needCut = !0;
        if (i === lineCountLimit - 1) {
          const clip = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
          linesLayout.push({
            str: clip.str,
            width: clip.width,
            ascent: 0,
            descent: 0,
            keepCenterInLine: !1
          });
          break;
        }
        const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth, "break-word" === wordBreak);
        if ("" !== str && "" === clip.str) {
          if (ellipsis) {
            const clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
            clip.str = null !== (_c = clipEllipsis.str) && void 0 !== _c ? _c : "", clip.width = null !== (_d = clipEllipsis.width) && void 0 !== _d ? _d : 0;
          } else clip.str = "", clip.width = 0;
          needCut = !1;
        }
        if (linesLayout.push({
          str: clip.str,
          width: clip.width,
          ascent: 0,
          descent: 0,
          keepCenterInLine: !1
        }), clip.str.length === str.length) ;else if (needCut) {
          const newStr = str.substring(clip.str.length);
          lines.splice(i + 1, 0, newStr);
        }
      }
      let maxWidth = 0;
      linesLayout.forEach(layout => {
        maxWidth = Math.max(maxWidth, layout.width);
      }), bboxWH[0] = maxWidth;
    } else {
      let width,
        text,
        lineWidth = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        if (i === lineCountLimit - 1) {
          const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i], layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
          linesLayout.push({
            str: clip.str,
            width: clip.width,
            ascent: 0,
            descent: 0,
            keepCenterInLine: !1
          }), lineWidth = Math.max(lineWidth, clip.width);
          break;
        }
        text = lines[i], width = layoutObj.textMeasure.measureTextWidth(text, layoutObj.textOptions, "break-word" === wordBreak), lineWidth = Math.max(lineWidth, width), linesLayout.push({
          str: text,
          width: width,
          ascent: 0,
          descent: 0,
          keepCenterInLine: !1
        });
      }
      bboxWH[0] = lineWidth;
    }
    bboxWH[1] = linesLayout.length * (lineHeight + buf);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  needUpdateTags(keys) {
    for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
      const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];
      if (-1 !== keys.indexOf(attrKey)) return !0;
    }
    return super.needUpdateTags(keys);
  }
  needUpdateTag(key) {
    for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
      if (key === WRAP_TEXT_UPDATE_TAG_KEY[i]) return !0;
    }
    return super.needUpdateTag(key);
  }
  getNoWorkAnimateAttr() {
    return WrapText.NOWORK_ANIMATE_ATTR;
  }
}
function createWrapText(attributes) {
  return new WrapText(attributes);
}

const updateBoundsOfSymbolOuterBorder = (attribute, symbolTheme, aabbBounds) => {
  const {
    outerBorder: outerBorder,
    shadowBlur = symbolTheme.shadowBlur,
    strokeBoundsBuffer = symbolTheme.strokeBoundsBuffer
  } = attribute;
  if (outerBorder) {
    const defaultOuterBorder = symbolTheme.outerBorder,
      {
        distance = defaultOuterBorder.distance,
        lineWidth = defaultOuterBorder.lineWidth
      } = outerBorder;
    boundStroke(aabbBounds, distance + (shadowBlur + lineWidth) / 2, !0, strokeBoundsBuffer);
  }
  return aabbBounds;
};

const SYMBOL_UPDATE_TAG_KEY = ["symbolType", "size", ...GRAPHIC_UPDATE_TAG_KEY];
let Symbol$1 = class Symbol extends Graphic {
  constructor(params = {
    symbolType: "circle"
  }) {
    super(params), this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  getParsedPath() {
    return this.shouldUpdateShape() && (this._parsedPath = this.doUpdateParsedPath(), this.clearUpdateShapeTag()), this._parsedPath;
  }
  getParsedPath2D(x = 0, y = 0, size = 1) {
    let path = null;
    try {
      path = new Path2D();
    } catch (err) {
      return null;
    }
    const parsedPath = this.getParsedPath();
    if (!parsedPath) return null;
    parsedPath.draw(path, size, x, y);
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      size: size
    } = this.attribute;
    return isArray(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);
  }
  doUpdateParsedPath() {
    const {
      symbolType = "circle"
    } = this.attribute;
    return super.parsePath(symbolType);
  }
  getGraphicTheme() {
    return getTheme(this).symbol;
  }
  updateAABBBounds(attribute, symbolTheme, aabbBounds, full) {
    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds));
    const {
      tb1: tb1,
      tb2: tb2
    } = application.graphicService.updateTempAABBBounds(aabbBounds);
    updateBoundsOfSymbolOuterBorder(attribute, symbolTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, this.x1WithoutTransform = aabbBounds.x1, this.y1WithoutTransform = aabbBounds.y1;
    const {
      lineJoin = symbolTheme.lineJoin
    } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, symbolTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) {
    const {
      size = symbolTheme.size
    } = attribute;
    if (isArray(size)) aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2);else {
      const halfWH = size / 2;
      aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
    }
    return aabbBounds;
  }
  updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds) {
    const {
      size = symbolTheme.size
    } = attribute;
    return this.getParsedPath().bounds(size, aabbBounds), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, SYMBOL_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, SYMBOL_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const symbolInstance = this.getParsedPath(),
      size = this.attribute.size,
      formattedSize = isArray(size) ? size : [size, size];
    return symbolInstance.path ? new CustomPath2D().fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : new CustomPath2D().fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);
  }
  clone() {
    return new Symbol(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Symbol.NOWORK_ANIMATE_ATTR;
  }
};
Symbol$1.NOWORK_ANIMATE_ATTR = Object.assign({
  symbolType: 1
}, NOWORK_ANIMATE_ATTR);
function createSymbol(attributes) {
  return new Symbol$1(attributes);
}

const LINE_UPDATE_TAG_KEY = ["segments", "points", "curveType", "curveTension", ...GRAPHIC_UPDATE_TAG_KEY];
let Line$1 = class Line extends Graphic {
  constructor(params = {}) {
    super(params), this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy) return !0;
    const {
      points: points,
      segments: segments
    } = this.attribute;
    return segments ? 0 !== segments.length : !!points && !(points.length <= 1);
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  getGraphicTheme() {
    return getTheme(this).line;
  }
  updateAABBBounds(attribute, lineTheme, aabbBounds) {
    this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds)), application.graphicService.updateTempAABBBounds(aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
    const {
      lineJoin = lineTheme.lineJoin
    } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, lineTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
    const {
        points = lineTheme.points,
        connectedType: connectedType
      } = attribute,
      b = aabbBounds;
    return points.forEach(p => {
      !1 === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
    }), b;
  }
  updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
    const {
        segments = lineTheme.segments,
        connectedType: connectedType
      } = attribute,
      b = aabbBounds;
    return segments.forEach(s => {
      s.points.forEach(p => {
        !1 === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
      });
    }), b;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, LINE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, LINE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    let path = super.toCustomPath();
    if (path) return path;
    const attribute = this.attribute;
    path = new CustomPath2D();
    const segments = attribute.segments,
      parsePoints = points => {
        if (points && points.length) {
          let isFirst = !0;
          points.forEach(point => {
            !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), isFirst = !1);
          });
        }
      };
    return segments && segments.length ? segments.forEach(seg => {
      parsePoints(seg.points);
    }) : attribute.points && parsePoints(attribute.points), path;
  }
  clone() {
    return new Line(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Line.NOWORK_ANIMATE_ATTR;
  }
};
Line$1.NOWORK_ANIMATE_ATTR = Object.assign({
  segments: 1,
  curveType: 1
}, NOWORK_ANIMATE_ATTR);
function createLine(attributes) {
  return new Line$1(attributes);
}

const normalizeRectAttributes = attribute => {
  if (!attribute) return {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  let width = isNil(attribute.width) ? attribute.x1 - attribute.x : attribute.width,
    height = isNil(attribute.height) ? attribute.y1 - attribute.y : attribute.height,
    x = 0,
    y = 0;
  return width < 0 ? (x = width, width = -width) : Number.isNaN(width) && (width = 0), height < 0 ? (y = height, height = -height) : Number.isNaN(height) && (height = 0), {
    x: x,
    y: y,
    width: width,
    height: height
  };
};

const RECT_UPDATE_TAG_KEY = ["width", "x1", "y1", "height", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
class Rect extends Graphic {
  constructor(params) {
    super(params), this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    return !0;
  }
  getGraphicTheme() {
    return getTheme(this).rect;
  }
  updateAABBBounds(attribute, rectTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      let {
        width: width,
        height: height
      } = attribute;
      const {
        x1: x1,
        y1: y1,
        x: x,
        y: y
      } = attribute;
      width = null != width ? width : x1 - x, height = null != height ? height : y1 - y, (isFinite(width) || isFinite(height) || isFinite(x) || isFinite(y)) && aabbBounds.set(0, 0, width || 0, height || 0);
    }
    const {
      tb1: tb1,
      tb2: tb2
    } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return updateBoundsOfCommonOuterBorder(attribute, rectTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, rectTheme, !1, this), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, RECT_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, RECT_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    let path = super.toCustomPath();
    if (path) return path;
    const attribute = this.attribute,
      {
        x: x,
        y: y,
        width: width,
        height: height
      } = normalizeRectAttributes(attribute);
    return path = new CustomPath2D(), path.moveTo(x, y), path.rect(x, y, width, height), path;
  }
  clone() {
    return new Rect(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Rect.NOWORK_ANIMATE_ATTR;
  }
}
Rect.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createRect(attributes) {
  return new Rect(attributes);
}

class Frame {
  constructor(left, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons) {
    this.left = left, this.top = top, this.width = width, this.height = height, this.actualHeight = 0, this.bottom = top + height, this.right = left + width, this.ellipsis = ellipsis, this.wordBreak = wordBreak, this.verticalDirection = verticalDirection, this.lines = [], this.globalAlign = globalAlign, this.globalBaseline = globalBaseline, this.layoutDirection = layoutDirection, this.directionKey = DIRECTION_KEY[this.layoutDirection], this.isWidthMax = isWidthMax, this.isHeightMax = isHeightMax, this.singleLine = singleLine, icons ? (icons.clear(), this.icons = icons) : this.icons = new Map();
  }
  draw(ctx, drawIcon) {
    const {
        width: actualWidth,
        height: actualHeight
      } = this.getActualSize(),
      width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;
    let height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;
    height = Math.min(height, actualHeight);
    let deltaY = 0;
    switch (this.globalBaseline) {
      case "top":
        deltaY = 0;
        break;
      case "middle":
        deltaY = -height / 2;
        break;
      case "bottom":
        deltaY = -height;
    }
    let deltaX = 0;
    "right" === this.globalAlign || "end" === this.globalAlign ? deltaX = -width : "center" === this.globalAlign && (deltaX = -width / 2);
    let frameHeight = this[this.directionKey.height];
    this.singleLine && (frameHeight = this.lines[0].height + 1);
    let lastLineTag = !1;
    if ("middle" === this.verticalDirection) {
      if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
        const {
          top: top,
          height: height
        } = this.lines[i];
        if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) return lastLineTag;
        let lastLine = !1;
        this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
      } else {
        const detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);
        "vertical" === this.layoutDirection ? deltaX += detalHeight : deltaY += detalHeight;
        for (let i = 0; i < this.lines.length; i++) this.lines[i].draw(ctx, !1, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
      }
    } else if ("bottom" === this.verticalDirection && "vertical" !== this.layoutDirection) for (let i = 0; i < this.lines.length; i++) {
      const {
          top: top,
          height: height
        } = this.lines[i],
        y = frameHeight - this.lines[i].top - this.lines[i].height;
      if (0 === frameHeight) this.lines[i].draw(ctx, !1, deltaX, y + deltaY, this.ellipsis, drawIcon);else {
        if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) return lastLineTag;
        {
          let lastLine = !1;
          this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top] && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, deltaX, y + deltaY, this.ellipsis, drawIcon);
        }
      }
    } else {
      "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && this.singleLine && this.isWidthMax && (deltaX += this.lines[0].height + 1);
      for (let i = 0; i < this.lines.length; i++) {
        "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && (deltaX -= this.lines[i].height + this.lines[i].top);
        const {
          top: top,
          height: height
        } = this.lines[i];
        if (0 === frameHeight) this.lines[i].draw(ctx, !1, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);else {
          if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) return lastLineTag;
          {
            let lastLine = !1;
            this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
          }
        }
      }
    }
    return lastLineTag;
  }
  getActualSize() {
    return this.ellipsis ? this.getActualSizeWidthEllipsis() : this.getRawActualSize();
  }
  getRawActualSize() {
    let width = 0,
      height = 0;
    for (let i = 0; i < this.lines.length; i++) {
      const line = this.lines[i];
      line.actualWidth > width && (width = line.actualWidth), height += line.height;
    }
    return {
      width: "vertical" === this.layoutDirection ? height : width,
      height: "vertical" === this.layoutDirection ? width : height
    };
  }
  getActualSizeWidthEllipsis() {
    let widthBound = 0,
      heightBound = 0;
    const {
      width: actualWidth,
      height: actualHeight
    } = this.getRawActualSize();
    this.width;
    this.height || actualHeight || 0;
    let frameHeight = this[this.directionKey.height];
    if (this.singleLine && (frameHeight = this.lines[0].height + 1), "middle" === this.verticalDirection) {
      if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
        const {
          top: top,
          height: height
        } = this.lines[i];
        if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ;else if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
          const ellipsis = !0 === this.ellipsis ? "..." : this.ellipsis || "",
            lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      } else {
        Math.floor((frameHeight - this.actualHeight) / 2);
        for (let i = 0; i < this.lines.length; i++) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      }
    } else if ("bottom" === this.verticalDirection) for (let i = 0; i < this.lines.length; i++) {
      const {
          top: top,
          height: height
        } = this.lines[i],
        y = frameHeight - this.lines[i].top - this.lines[i].height;
      if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;else if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) ;else {
        if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {
          const ellipsis = !0 === this.ellipsis ? "..." : this.ellipsis || "",
            lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      }
    } else for (let i = 0; i < this.lines.length; i++) {
      const {
        top: top,
        height: height
      } = this.lines[i];
      if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;else if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ;else {
        if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
          const ellipsis = !0 === this.ellipsis ? "..." : this.ellipsis || "",
            lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      }
    }
    return {
      width: "vertical" === this.layoutDirection ? heightBound : widthBound,
      height: "vertical" === this.layoutDirection ? widthBound : heightBound
    };
  }
}

function getFixedLRTB(left, right, top, bottom) {
  const leftInt = Math.round(left),
    topInt = Math.round(top),
    rightInt = Math.round(right),
    bottomInt = Math.round(bottom);
  return {
    left: left > leftInt ? leftInt : leftInt - .5,
    top: top > topInt ? topInt : topInt - .5,
    right: rightInt > right ? rightInt : rightInt + .5,
    bottom: bottomInt > bottom ? bottomInt : bottomInt + .5
  };
}
class Paragraph {
  constructor(text, newLine, character, ascentDescentMode) {
    var _a, _b;
    this.fontSize = character.fontSize || 16, this.textBaseline = character.textBaseline || "alphabetic", this.ascentDescentMode = ascentDescentMode;
    const lineHeight = calculateLineHeight(character.lineHeight, this.fontSize);
    this.lineHeight = "number" == typeof lineHeight ? lineHeight > this.fontSize ? lineHeight : this.fontSize : Math.floor(1.2 * this.fontSize), this.height = this.lineHeight;
    const {
      ascent: ascent,
      height: height,
      descent: descent,
      width: width
    } = measureTextCanvas(text, character, this.ascentDescentMode);
    let halfDetaHeight = 0,
      deltaAscent = 0,
      deltaDescent = 0;
    this.height > height && (halfDetaHeight = (this.height - height) / 2, deltaAscent = Math.ceil(halfDetaHeight), deltaDescent = Math.floor(halfDetaHeight)), "top" === this.textBaseline ? (this.ascent = halfDetaHeight, this.descent = height - halfDetaHeight) : "bottom" === this.textBaseline ? (this.ascent = height - halfDetaHeight, this.descent = halfDetaHeight) : "middle" === this.textBaseline ? (this.ascent = this.height / 2, this.descent = this.height / 2) : (this.ascent = ascent + deltaAscent, this.descent = descent + deltaDescent), this.length = text.length, this.width = width || 0, this.text = text || "", this.newLine = newLine || !1, this.character = character, this.left = 0, this.top = 0, this.ellipsis = "normal", this.ellipsisWidth = 0, this.ellipsisOtherParagraphWidth = 0, this.space = character.space, this.dx = null !== (_a = character.dx) && void 0 !== _a ? _a : 0, this.dy = null !== (_b = character.dy) && void 0 !== _b ? _b : 0, "vertical" === character.direction && (this.direction = character.direction, this.widthOrigin = this.width, this.heightOrigin = this.height, this.width = this.heightOrigin, this.height = this.widthOrigin, this.lineHeight = this.height), this.ellipsisStr = "...";
  }
  updateWidth() {
    const {
      width: width
    } = measureTextCanvas(this.text, this.character, this.ascentDescentMode);
    this.width = width, "vertical" === this.direction && (this.widthOrigin = this.width, this.width = this.heightOrigin, this.height = this.widthOrigin);
  }
  drawBackground(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
    if ("" === this.text || "\n" === this.text || !this.character.background || this.character.backgroundOpacity && !(this.character.backgroundOpacity > 0)) return;
    let baseline = top + ascent,
      text = this.text,
      left = this.left + deltaLeft;
    baseline += this.top;
    let direction = this.direction;
    if (this.verticalEllipsis) text = this.ellipsisStr, direction = "vertical", baseline -= this.ellipsisWidth / 2;else {
      if ("hide" === this.ellipsis) return;
      if ("add" === this.ellipsis) text += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left -= this.ellipsisWidth);else if ("replace" === this.ellipsis) {
        const index = getStrByWithCanvas(text, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
        if (text = text.slice(0, index), text += this.ellipsisStr, "right" === textAlign || "end" === textAlign) if ("vertical" === direction) ;else {
          const {
            width: width
          } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
          left -= this.ellipsisWidth - width;
        }
      }
    }
    const lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + lineHeight);
    return Object.assign(Object.assign({}, lrtb), {
      fillStyle: this.character.background,
      globalAlpha: this.character.backgroundOpacity
    });
  }
  draw(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
    var _a;
    let baseline = top + ascent,
      text = this.text,
      left = this.left + deltaLeft + (null !== (_a = this.space) && void 0 !== _a ? _a : 0) / 2;
    baseline += this.top;
    let direction = this.direction;
    if (this.verticalEllipsis) text = this.ellipsisStr, direction = "vertical", baseline -= this.ellipsisWidth / 2;else {
      if ("hide" === this.ellipsis) return;
      if ("add" === this.ellipsis) text += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left -= this.ellipsisWidth);else if ("replace" === this.ellipsis) {
        const index = getStrByWithCanvas(text, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
        if (text = text.slice(0, index), text += this.ellipsisStr, "right" === textAlign || "end" === textAlign) if ("vertical" === direction) ;else {
          const {
            width: width
          } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
          left -= this.ellipsisWidth - width;
        }
      }
    }
    switch (this.character.script) {
      case "super":
        baseline -= this.ascent * (1 / 3);
        break;
      case "sub":
        baseline += this.descent / 2;
    }
    "vertical" === direction && (ctx.save(), ctx.rotateAbout(Math.PI / 2, left, baseline), ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2), ctx.translate(left, baseline), left = 0, baseline = 0);
    const {
      lineWidth = 1
    } = this.character;
    if (this.character.stroke && lineWidth && ctx.strokeText(text, left + this.dx, baseline + this.dy), this.character.fill && ctx.fillText(text, left + this.dx, baseline + this.dy), this.character.fill) if (this.character.lineThrough || this.character.underline) {
      if (this.character.underline) {
        const top = 1 + baseline,
          lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
        ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
      }
      if (this.character.lineThrough) {
        const top = 1 + baseline - this.ascent / 2,
          lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
        ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
      }
    } else if ("underline" === this.character.textDecoration) {
      const top = 1 + baseline,
        lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
      ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
    } else if ("line-through" === this.character.textDecoration) {
      const top = 1 + baseline - this.ascent / 2,
        lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
      ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
    }
    "vertical" === direction && ctx.restore();
  }
  getWidthWithEllips(direction) {
    let text = this.text;
    const width = "vertical" === direction ? this.height : this.width;
    if ("hide" === this.ellipsis) return width;
    if ("add" === this.ellipsis) return width + this.ellipsisWidth;
    if ("replace" === this.ellipsis) {
      const index = getStrByWithCanvas(text, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
      text = text.slice(0, index), text += this.ellipsisStr;
      const {
        width: measureWidth
      } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
      return width + this.ellipsisWidth - measureWidth;
    }
    return width;
  }
}
function seperateParagraph(paragraph, index) {
  const text1 = paragraph.text.slice(0, index),
    text2 = paragraph.text.slice(index);
  return [new Paragraph(text1, paragraph.newLine, paragraph.character, paragraph.ascentDescentMode), new Paragraph(text2, !0, paragraph.character, paragraph.ascentDescentMode)];
}

const IMAGE_UPDATE_TAG_KEY = ["width", "height", "image", ...GRAPHIC_UPDATE_TAG_KEY];
class Image extends Graphic {
  constructor(params) {
    super(params), this.type = "image", this.numberType = IMAGE_NUMBER_TYPE, this.loadImage(this.attribute.image);
  }
  getImageElement() {
    const {
      image: image
    } = this.attribute;
    if (!image || !this.resources) return null;
    const res = this.resources.get(image);
    return "success" !== res.state ? null : res.data;
  }
  get width() {
    return this.tryUpdateAABBBounds(), this._actualWidth;
  }
  get height() {
    return this.tryUpdateAABBBounds(), this._actualHeight;
  }
  get repeatX() {
    var _a;
    return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : "no-repeat";
  }
  set repeatX(repeatX) {
    this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);
  }
  get repeatY() {
    var _a;
    return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : "no-repeat";
  }
  set repeatY(repeatY) {
    this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);
  }
  get image() {
    return this.attribute.image;
  }
  set image(image) {
    image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));
  }
  imageLoadSuccess(url, image, cb) {
    super.imageLoadSuccess(url, image, () => {
      this.successCallback && this.successCallback();
    }), this.addUpdateBoundTag();
  }
  imageLoadFail(url, cb) {
    super.imageLoadFail(url, () => {
      this.failCallback && this.failCallback();
    });
  }
  setAttributes(params, forceUpdateTag, context) {
    return params.image && this.loadImage(params.image), super.setAttributes(params, forceUpdateTag, context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    return "image" === key && this.loadImage(value), super.setAttribute(key, value, forceUpdateTag, context);
  }
  getGraphicTheme() {
    return getTheme(this).image;
  }
  updateAABBBounds(attribute, imageTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      const {
        maxWidth = imageTheme.maxWidth,
        maxHeight = imageTheme.maxHeight
      } = attribute;
      let {
        width: width,
        height: height
      } = attribute;
      if (null == width || null == height) {
        const imageElement = this.getImageElement();
        if (imageElement) {
          const imageWidth = imageElement.width,
            imageHeight = imageElement.height;
          if (null != width) height = width * (imageHeight / imageWidth);else if (null != height) width = height * (imageWidth / imageHeight);else {
            const imageRatio = imageWidth / imageHeight;
            imageRatio > maxWidth / maxHeight ? (width = maxWidth, height = maxWidth / imageRatio) : (height = maxHeight, width = maxHeight * imageRatio);
          }
        } else width = maxWidth, height = maxHeight;
      }
      this._actualWidth = width, this._actualHeight = height, aabbBounds.set(0, 0, width, height);
    }
    const {
      tb1: tb1,
      tb2: tb2
    } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return updateBoundsOfCommonOuterBorder(attribute, imageTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, imageTheme, !1, this), aabbBounds;
  }
  getDefaultAttribute(name) {
    return DefaultImageAttribute[name];
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, IMAGE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, IMAGE_UPDATE_TAG_KEY);
  }
  clone() {
    return new Image(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Image.NOWORK_ANIMATE_ATTR;
  }
}
Image.NOWORK_ANIMATE_ATTR = Object.assign({
  image: 1,
  repeatX: 1,
  repeatY: 1
}, NOWORK_ANIMATE_ATTR);
function createImage(attributes) {
  return new Image(attributes);
}

class RichTextIcon extends Image {
  constructor(params) {
    if (super(params), this._x = 0, this._y = 0, this._hovered = !1, this._marginArray = [0, 0, 0, 0], "always" === params.backgroundShowMode && (this._hovered = !0), params.margin) {
      const marginArray = parsePadding(params.margin);
      this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
    }
    this.onBeforeAttributeUpdate = (val, attributes, key) => {
      if (isArray(key) && -1 !== key.indexOf("margin") || "margin" === key) if (attributes.margin) {
        const marginArray = parsePadding(attributes.margin);
        this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
      } else this._marginArray = [0, 0, 0, 0];
    };
  }
  get width() {
    var _a;
    return (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + this._marginArray[1] + this._marginArray[3];
  }
  get height() {
    var _a;
    return (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + this._marginArray[0] + this._marginArray[2];
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    this.doUpdateAABBBounds();
    const {
        width = DefaultImageAttribute.width,
        height = DefaultImageAttribute.height
      } = this.attribute,
      {
        backgroundWidth = width,
        backgroundHeight = height
      } = this.attribute,
      expandX = (backgroundWidth - width) / 2,
      expandY = (backgroundHeight - height) / 2;
    return this._AABBBounds.expand([0, 2 * expandX, 2 * expandY, 0]), this._AABBBounds;
  }
  setHoverState(hovered) {
    "hover" === this.attribute.backgroundShowMode && this._hovered !== hovered && (this._hovered = hovered);
  }
}

class Line {
  constructor(left, width, baseline, ascent, descent, lineBuffer, direction, isWidthMax) {
    this.left = left, this.width = width, this.baseline = baseline, this.ascent = ascent, this.descent = descent, this.top = baseline - ascent, this.paragraphs = lineBuffer.map(p => p), this.textAlign = (this.paragraphs[0] instanceof RichTextIcon ? this.paragraphs[0].attribute.textAlign : this.paragraphs[0].character.textAlign) || "left", this.direction = direction, this.directionKey = DIRECTION_KEY[this.direction], this.actualWidth = 0;
    let maxHeight = 0;
    this.paragraphs.forEach((word, index) => {
      if (0 === index && word instanceof Paragraph) {
        const result = regFirstSpace.exec(word.text);
        0 !== (null == result ? void 0 : result.index) && (word.text = word.text.slice(null == result ? void 0 : result.index), word.updateWidth());
      }
      this.actualWidth += word[this.directionKey.width], maxHeight = Math.max(word[this.directionKey.height], maxHeight);
    }), this.height = maxHeight, this.blankWidth = isWidthMax ? 0 : this.width - this.actualWidth, this.calcOffset(width, isWidthMax);
  }
  calcOffset(width, isWidthMax) {
    const directionKey = this.directionKey,
      maxHeight = this.height;
    let x = this.left,
      spacing = 0;
    this.actualWidth < width && !isWidthMax && ("right" === this.textAlign || "end" === this.textAlign ? x = width - this.actualWidth : "center" === this.textAlign ? x = (width - this.actualWidth) / 2 : "justify" === this.textAlign && (this.paragraphs.length < 2 ? x = (width - this.actualWidth) / 2 : spacing = (width - this.actualWidth) / (this.paragraphs.length - 1))), this.paragraphs.map(function (paragraph) {
      paragraph instanceof RichTextIcon ? (paragraph["_" + directionKey.x] = x, x += paragraph[directionKey.width] + spacing, paragraph["_" + directionKey.y] = "top" === paragraph.attribute.textBaseline ? 0 : "bottom" === paragraph.attribute.textBaseline ? maxHeight - paragraph.height : (maxHeight - paragraph.height) / 2) : (paragraph[directionKey.left] = x, x += paragraph[directionKey.width] + spacing);
    });
  }
  draw(ctx, lastLine, x, y, drawEllipsis, drawIcon) {
    if (drawEllipsis && (lastLine || this.paragraphs.some(p => p.overflow))) {
      let emptyOverflow = !0,
        skipEllipsis = !1;
      for (let i = this.paragraphs.length - 1; i >= 0; i--) {
        const paragraph = this.paragraphs[i];
        if (paragraph.overflow) emptyOverflow = emptyOverflow && "" === paragraph.text;else if (emptyOverflow) {
          skipEllipsis = !0;
          break;
        }
      }
      let otherParagraphWidth = 0;
      if (!skipEllipsis) for (let i = this.paragraphs.length - 1; i >= 0; i--) {
        const paragraph = this.paragraphs[i];
        if (paragraph.overflow) {
          if ("" === paragraph.text) break;
          continue;
        }
        if (paragraph instanceof RichTextIcon) break;
        if ("vertical" === this.direction && "vertical" !== paragraph.direction) {
          paragraph.verticalEllipsis = !0;
          break;
        }
        const ellipsis = !0 === drawEllipsis ? "..." : drawEllipsis || "";
        paragraph.ellipsisStr = ellipsis;
        const {
            width: width
          } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode),
          ellipsisWidth = width || 0;
        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
          lastLine && (paragraph.ellipsis = "add");
          break;
        }
        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
          paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
          break;
        }
        paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
      }
    }
    let fillStyle = "",
      globalAlpha = -1,
      currBgList = [];
    const bgList = [currBgList];
    this.paragraphs.forEach((paragraph, index) => {
      if (paragraph instanceof RichTextIcon) return;
      const data = paragraph.drawBackground(ctx, y, this.ascent, x, 0 === index, this.textAlign, this.height);
      data && (fillStyle === data.fillStyle && globalAlpha === data.globalAlpha || (currBgList = [], bgList.push(currBgList), fillStyle = data.fillStyle, globalAlpha = data.globalAlpha), currBgList.push(data));
    }), bgList.forEach(bg => {
      if (0 === bg.length) return;
      const data = bg[0],
        end = bg[bg.length - 1];
      ctx.fillStyle = data.fillStyle, ctx.globalAlpha = data.globalAlpha, ctx.fillRect(data.left, data.top, end.right - data.left, end.bottom - data.top);
    }), this.paragraphs.forEach((paragraph, index) => {
      if (paragraph instanceof RichTextIcon) return paragraph.setAttributes({
        x: x + paragraph._x,
        y: y + paragraph._y
      }), void drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, this.ascent);
      const b = {
        x1: this.left,
        y1: this.top,
        x2: this.left + this.actualWidth,
        y2: this.top + this.height
      };
      applyStrokeStyle(ctx, paragraph.character), applyFillStyle(ctx, paragraph.character, b), paragraph.draw(ctx, y, this.ascent, x, 0 === index, this.textAlign, this.height);
    });
  }
  getWidthWithEllips(ellipsis) {
    let otherParagraphWidth = 0;
    for (let i = this.paragraphs.length - 1; i >= 0; i--) {
      const paragraph = this.paragraphs[i];
      if (paragraph instanceof RichTextIcon) break;
      const {
          width: width
        } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode),
        ellipsisWidth = width || 0;
      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
        paragraph.ellipsis = "add", paragraph.ellipsisWidth = ellipsisWidth;
        break;
      }
      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
        paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
        break;
      }
      paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
    }
    let width = 0;
    return this.paragraphs.forEach((paragraph, index) => {
      width += paragraph instanceof RichTextIcon ? paragraph.width : paragraph.getWidthWithEllips(this.direction);
    }), width;
  }
}

class Wrapper {
  constructor(frame) {
    this.frame = frame, this.width = this.frame.width, this.height = this.frame.height, this.lineWidth = 0, this.y = this.frame.top, this.maxAscent = 0, this.maxDescent = 0, this.maxAscentForBlank = 0, this.maxDescentForBlank = 0, this.lineBuffer = [], this.direction = frame.layoutDirection, this.directionKey = DIRECTION_KEY[this.direction];
  }
  store(paragraph) {
    if (paragraph instanceof RichTextIcon) {
      this.frame.icons.set(paragraph.richtextId, paragraph), this.lineBuffer.push(paragraph), this.lineWidth += paragraph[this.directionKey.width];
      let iconAscent = 0,
        iconDescent = 0;
      "top" === paragraph.attribute.textBaseline ? (iconAscent = 0, iconDescent = paragraph.height) : "bottom" === paragraph.attribute.textBaseline ? (iconAscent = paragraph.height, iconDescent = 0) : (iconAscent = paragraph.height / 2, iconDescent = paragraph.height / 2), this.maxAscent = Math.max(this.maxAscent, iconAscent), this.maxDescent = Math.max(this.maxDescent, iconDescent);
    } else this.lineBuffer.push(paragraph), 0 !== paragraph.text.length ? (this.lineWidth += paragraph[this.directionKey.width], this.maxAscent = Math.max(this.maxAscent, paragraph.ascent), this.maxDescent = Math.max(this.maxDescent, paragraph.descent)) : (this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent), this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent));
  }
  send() {
    if (0 === this.lineBuffer.length) return;
    const maxAscent = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent,
      maxDescent = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent,
      line = new Line(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, "horizontal" === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax);
    this.frame.lines.push(line), this.frame.actualHeight += line.height, this.y += line.height, this.lineBuffer.length = 0, this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
  }
  deal(paragraph, singleLine = !1) {
    paragraph instanceof RichTextIcon ? "horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : 0 === this.lineBuffer.length ? (this.store(paragraph), this.send()) : (this.send(), this.deal(paragraph)) : "number" != typeof this.width || this.width < 0 || (paragraph.newLine && this.send(), (0 !== paragraph.text.length || this.newLine) && ("horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : this.lineWidth === this[this.directionKey.width] ? (this.send(), this.deal(paragraph)) : this.cut(paragraph, singleLine)));
  }
  cut(paragraph, singleLine) {
    const availableWidth = this[this.directionKey.width] - this.lineWidth || 0,
      guessIndex = Math.ceil(availableWidth / paragraph[this.directionKey.width] * paragraph.length) || 0,
      index = getStrByWithCanvas(paragraph.text, availableWidth, paragraph.character, guessIndex, "break-word" === this.frame.wordBreak);
    if (0 !== index) {
      const [p1, p2] = seperateParagraph(paragraph, index);
      this.store(p1), singleLine ? this.send() : this.deal(p2);
    } else 0 !== this.lineBuffer.length && (this.send(), this.deal(paragraph));
  }
}

let supportIntl = !1;
try {
  supportIntl = Intl && "function" == typeof Intl.Segmenter;
} catch (e) {
  supportIntl = !1;
}
const RICHTEXT_UPDATE_TAG_KEY = ["width", "height", "ellipsis", "wordBreak", "verticalDirection", "maxHeight", "maxWidth", "textAlign", "textBaseline", "textConfig", "layoutDirection", "fill", "stroke", "fontSize", "fontFamily", "fontStyle", "fontWeight", "lineWidth", "opacity", "fillOpacity", "strokeOpacity", ...GRAPHIC_UPDATE_TAG_KEY];
class RichText extends Graphic {
  constructor(params) {
    super(params), this.type = "richtext", this._currentHoverIcon = null, this.numberType = RICHTEXT_NUMBER_TYPE, this.onBeforeAttributeUpdate = (val, attributes, key) => {
      for (const key in val) if ("hoverIconId" === key) {
        if (val[key] === attributes[key]) continue;
        const icon = this._frameCache.icons.get(val[key]);
        this.updateHoverIconState(icon);
      }
    };
  }
  get width() {
    var _a;
    return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : DefaultRichTextAttribute.width;
  }
  set width(w) {
    this.attribute.width !== w && (this.attribute.width = w, this.addUpdateShapeAndBoundsTag());
  }
  get height() {
    var _a;
    return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : DefaultRichTextAttribute.height;
  }
  set height(h) {
    this.attribute.height !== h && (this.attribute.height = h, this.addUpdateShapeAndBoundsTag());
  }
  get maxWidth() {
    return this.attribute.maxWidth;
  }
  set maxWidth(mw) {
    this.attribute.maxWidth !== mw && (this.attribute.maxWidth = mw, this.addUpdateShapeAndBoundsTag());
  }
  get maxHeight() {
    return this.attribute.maxHeight;
  }
  set maxHeight(mh) {
    this.attribute.maxHeight !== mh && (this.attribute.maxHeight = mh, this.addUpdateShapeAndBoundsTag());
  }
  get ellipsis() {
    var _a;
    return null !== (_a = this.attribute.ellipsis) && void 0 !== _a ? _a : DefaultRichTextAttribute.ellipsis;
  }
  set ellipsis(e) {
    this.attribute.ellipsis !== e && (this.attribute.ellipsis = e, this.addUpdateShapeAndBoundsTag());
  }
  get wordBreak() {
    var _a;
    return null !== (_a = this.attribute.wordBreak) && void 0 !== _a ? _a : DefaultRichTextAttribute.wordBreak;
  }
  set wordBreak(wb) {
    this.attribute.wordBreak !== wb && (this.attribute.wordBreak = wb, this.addUpdateShapeAndBoundsTag());
  }
  get verticalDirection() {
    var _a;
    return null !== (_a = this.attribute.verticalDirection) && void 0 !== _a ? _a : DefaultRichTextAttribute.verticalDirection;
  }
  set verticalDirection(vd) {
    this.attribute.verticalDirection !== vd && (this.attribute.verticalDirection = vd, this.addUpdateShapeAndBoundsTag());
  }
  get textAlign() {
    var _a;
    return null !== (_a = this.attribute.textAlign) && void 0 !== _a ? _a : DefaultRichTextAttribute.textAlign;
  }
  set textAlign(align) {
    this.attribute.textAlign !== align && (this.attribute.textAlign = align, this.addUpdateShapeAndBoundsTag());
  }
  get textBaseline() {
    var _a;
    return null !== (_a = this.attribute.textBaseline) && void 0 !== _a ? _a : DefaultRichTextAttribute.textBaseline;
  }
  set textBaseline(baseline) {
    this.attribute.textBaseline !== baseline && (this.attribute.textBaseline = baseline, this.addUpdateShapeAndBoundsTag());
  }
  get textConfig() {
    var _a;
    return null !== (_a = this.attribute.textConfig) && void 0 !== _a ? _a : DefaultRichTextAttribute.textConfig;
  }
  set textConfig(config) {
    this.attribute.textConfig = config, this.addUpdateShapeAndBoundsTag();
  }
  getGraphicTheme() {
    return getTheme(this).richtext;
  }
  static AllSingleCharacter(cache) {
    if (cache.lines) {
      return cache.lines.every(line => line.paragraphs.every(item => !(item.text && isString(item.text) && RichText.splitText(item.text).length > 1)));
    }
    return cache.every(item => item.isComposing || !(item.text && isString(item.text) && RichText.splitText(item.text).length > 1));
  }
  static splitText(text) {
    if (supportIntl) {
      const segmenter = new Intl.Segmenter(void 0, {
          granularity: "grapheme"
        }),
        segments = [];
      for (const {
        segment: segment
      } of segmenter.segment(text)) segments.push(segment);
      return segments;
    }
    return Array.from(text);
  }
  static TransformTextConfig2SingleCharacter(textConfig) {
    const tc = [];
    return textConfig.forEach(item => {
      const textList = RichText.splitText(item.text.toString());
      if (isString(item.text) && textList.length > 1) for (let i = 0; i < textList.length; i++) {
        const t = textList[i];
        tc.push(Object.assign(Object.assign({}, item), {
          text: t
        }));
      } else tc.push(item);
    }), tc;
  }
  updateAABBBounds(attribute, richtextTheme, aabbBounds) {
    var _a, _b, _c, _d;
    const {
      width = richtextTheme.width,
      height = richtextTheme.height,
      maxWidth = richtextTheme.maxWidth,
      maxHeight = richtextTheme.maxHeight,
      textAlign = richtextTheme.textAlign,
      textBaseline = null !== (_b = null !== (_a = attribute.textBaseline) && void 0 !== _a ? _a : richtextTheme.textBaseline) && void 0 !== _b ? _b : "top",
      editOptions: editOptions
    } = attribute;
    if (width > 0 && height > 0) aabbBounds.set(0, 0, width, height);else {
      const frameCache = this.getFrameCache(),
        {
          width: actualWidth,
          height: actualHeight
        } = frameCache.getActualSize();
      let contentWidth = width || actualWidth || 0,
        contentHeight = height || actualHeight || 0;
      contentHeight = "number" == typeof maxHeight && contentHeight > maxHeight ? maxHeight : contentHeight || 0, contentWidth = "number" == typeof maxWidth && contentWidth > maxWidth ? maxWidth : contentWidth || 0, aabbBounds.set(0, 0, contentWidth, contentHeight);
    }
    editOptions && editOptions.keepHeightWhileEmpty && !aabbBounds.height() && !(null === (_c = attribute.textConfig) || void 0 === _c ? void 0 : _c.length) && (aabbBounds.y2 = aabbBounds.y1 + (null !== (_d = attribute.fontSize) && void 0 !== _d ? _d : 12), aabbBounds.x2 = aabbBounds.x1 + 2);
    let deltaY = 0;
    switch (textBaseline) {
      case "top":
        deltaY = 0;
        break;
      case "middle":
        deltaY = -aabbBounds.height() / 2;
        break;
      case "bottom":
        deltaY = -aabbBounds.height();
    }
    let deltaX = 0;
    switch (textAlign) {
      case "left":
        deltaX = 0;
        break;
      case "center":
        deltaX = -aabbBounds.width() / 2;
        break;
      case "right":
        deltaX = -aabbBounds.width();
    }
    return height || ("middle" === this.verticalDirection ? deltaY -= aabbBounds.height() / 2 : "bottom" === this.verticalDirection && (deltaY -= aabbBounds.height())), aabbBounds.translate(deltaX, deltaY), application.graphicService.updateTempAABBBounds(aabbBounds), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || application.graphicService.updateHTMLTextAABBBounds(attribute, richtextTheme, aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, richtextTheme, !1, this), 0 === aabbBounds.width() && 0 === aabbBounds.height() && aabbBounds.clear(), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, RICHTEXT_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, RICHTEXT_UPDATE_TAG_KEY);
  }
  getFrameCache() {
    return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), this._frameCache;
  }
  get cliped() {
    const frameCache = this.getFrameCache();
    if (frameCache.actualHeight > frameCache.height) return !0;
    const {
      disableAutoWrapLine: disableAutoWrapLine
    } = this.attribute;
    if (disableAutoWrapLine) for (let i = 0; i < frameCache.lines.length; i++) {
      const l = frameCache.lines[i];
      for (let j = 0; j < l.paragraphs.length; j++) {
        const p = l.paragraphs[j];
        if (p.overflow && "" !== p.text) return !0;
      }
    }
    return !1;
  }
  combinedStyleToCharacter(config) {
    const {
        fill: fill,
        stroke: stroke,
        fontSize: fontSize,
        fontFamily: fontFamily,
        fontStyle: fontStyle,
        fontWeight: fontWeight,
        lineWidth: lineWidth,
        opacity: opacity,
        fillOpacity: fillOpacity,
        lineHeight: lineHeight,
        strokeOpacity: strokeOpacity,
        upgradeAttrs: upgradeAttrs
      } = this.attribute,
      out = Object.assign({
        fill: fill,
        stroke: stroke,
        fontSize: fontSize,
        fontFamily: fontFamily,
        fontStyle: fontStyle,
        fontWeight: fontWeight,
        lineWidth: lineWidth,
        opacity: opacity,
        fillOpacity: fillOpacity,
        strokeOpacity: strokeOpacity
      }, config);
    return (null == upgradeAttrs ? void 0 : upgradeAttrs.lineHeight) && (out.lineHeight = lineHeight), out;
  }
  doUpdateFrameCache(tc) {
    var _a;
    const {
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        width: width,
        height: height,
        ellipsis: ellipsis,
        wordBreak: wordBreak,
        verticalDirection: verticalDirection,
        textAlign: textAlign,
        textBaseline: textBaseline,
        layoutDirection: layoutDirection,
        singleLine: singleLine,
        disableAutoWrapLine: disableAutoWrapLine,
        editable: editable,
        ascentDescentMode: ascentDescentMode,
        upgradeAttrs: upgradeAttrs
      } = this.attribute,
      enableMultiBreakLine = upgradeAttrs && upgradeAttrs.multiBreakLine;
    let {
      textConfig: _tc = []
    } = this.attribute;
    editable && _tc.length > 0 && !RichText.AllSingleCharacter(_tc) && (_tc = RichText.TransformTextConfig2SingleCharacter(_tc), this.attribute.textConfig = _tc);
    const paragraphs = [],
      textConfig = null != tc ? tc : _tc;
    for (let i = 0; i < textConfig.length; i++) if ("image" in textConfig[i]) {
      const config = this.combinedStyleToCharacter(textConfig[i]);
      config.lineWidth = void 0;
      const iconCache = config.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config.id);
      if (iconCache) paragraphs.push(iconCache);else {
        const icon = new RichTextIcon(config);
        icon.successCallback = () => {
          var _a;
          this.addUpdateBoundTag(), null === (_a = this.stage) || void 0 === _a || _a.renderNextFrame();
        }, icon.richtextId = config.id, paragraphs.push(icon);
      }
    } else {
      const richTextConfig = this.combinedStyleToCharacter(textConfig[i]);
      if (isNumber(richTextConfig.text) && (richTextConfig.text = `${richTextConfig.text}`), richTextConfig.text && richTextConfig.text.includes("\n")) {
        const textParts = richTextConfig.text.split("\n");
        for (let j = 0; j < textParts.length; j++) if (0 === j) paragraphs.push(new Paragraph(textParts[j], !1, richTextConfig, ascentDescentMode));else if (textParts[j] || i === textConfig.length - 1) paragraphs.push(new Paragraph(textParts[j], !0, richTextConfig, ascentDescentMode));else {
          const nextRichTextConfig = this.combinedStyleToCharacter(textConfig[i + 1]);
          paragraphs.push(new Paragraph(textParts[j], !0, nextRichTextConfig, ascentDescentMode));
        }
      } else richTextConfig.text && paragraphs.push(new Paragraph(richTextConfig.text, !1, richTextConfig, ascentDescentMode));
    }
    const maxWidthFinite = "number" == typeof maxWidth && Number.isFinite(maxWidth) && maxWidth > 0,
      maxHeightFinite = "number" == typeof maxHeight && Number.isFinite(maxHeight) && maxHeight > 0,
      richTextWidthEnable = "number" == typeof width && Number.isFinite(width) && width > 0 && (!maxWidthFinite || width <= maxWidth),
      richTextHeightEnable = "number" == typeof height && Number.isFinite(height) && height > 0 && (!maxHeightFinite || height <= maxHeight),
      frame = new Frame(0, 0, (richTextWidthEnable ? width : maxWidthFinite ? maxWidth : 0) || 0, (richTextHeightEnable ? height : maxHeightFinite ? maxHeight : 0) || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || "horizontal", !richTextWidthEnable && maxWidthFinite, !richTextHeightEnable && maxHeightFinite, singleLine || !1, null === (_a = this._frameCache) || void 0 === _a ? void 0 : _a.icons),
      wrapper = new Wrapper(frame);
    if (wrapper.newLine = enableMultiBreakLine, disableAutoWrapLine) {
      let lineCount = 0,
        skip = !1;
      for (let i = 0; i < paragraphs.length; i++) {
        const p = paragraphs[i];
        skip ? (p.overflow = !0, p.left = 1 / 0, p.top = 1 / 0, !p.newLine && frame.lines[frame.lines.length - 1].paragraphs.push(p)) : wrapper.deal(p, !0), frame.lines.length !== lineCount && (lineCount = frame.lines.length, wrapper.lineBuffer.length = 0, p.overflow = !0, p.left = 1e3, p.top = 1e3, frame.lines[frame.lines.length - 1].paragraphs.push(p), skip = !0), p.newLine && (skip = !1, wrapper.lineWidth = 0), wrapper.send();
      }
    } else for (let i = 0; i < paragraphs.length; i++) wrapper.deal(paragraphs[i]);
    wrapper.send();
    if (!("horizontal" === frame.layoutDirection ? richTextWidthEnable : richTextHeightEnable)) {
      const frameSize = frame.getActualSizeWidthEllipsis();
      let offsetSize = "horizontal" === frame.layoutDirection ? frameSize.width : frameSize.height;
      ("horizontal" === frame.layoutDirection ? maxWidthFinite : maxHeightFinite) && (offsetSize = Math.min(offsetSize, "horizontal" === frame.layoutDirection ? maxWidth : maxHeight)), frame.lines.forEach(function (l) {
        l.calcOffset(offsetSize, !1);
      });
    }
    enableMultiBreakLine && frame.lines.forEach(item => {
      const lastParagraphs = item.paragraphs;
      item.paragraphs = item.paragraphs.filter(p => "" !== p.text), 0 === item.paragraphs.length && lastParagraphs.length && (lastParagraphs[0].text = "\n", item.paragraphs.push(lastParagraphs[0]));
    }), this._frameCache = frame;
  }
  clone() {
    return new RichText(Object.assign({}, this.attribute));
  }
  setStage(stage, layer) {
    super.setStage(stage, layer);
    this.getFrameCache().icons.forEach(icon => {
      icon.setStage(stage, layer);
    });
  }
  bindIconEvent() {
    this.addEventListener("pointermove", e => {
      const pickedIcon = this.pickIcon(e.global);
      pickedIcon && pickedIcon === this._currentHoverIcon || (pickedIcon ? this.setAttribute("hoverIconId", pickedIcon.richtextId) : !pickedIcon && this._currentHoverIcon && this.setAttribute("hoverIconId", void 0));
    }), this.addEventListener("pointerleave", e => {
      this._currentHoverIcon && this.setAttribute("hoverIconId", void 0);
    });
  }
  updateHoverIconState(pickedIcon) {
    var _a, _b, _c, _d, _e;
    pickedIcon ? (null === (_a = this._currentHoverIcon) || void 0 === _a || _a.setHoverState(!1), this._currentHoverIcon = pickedIcon, this._currentHoverIcon.setHoverState(!0), null === (_b = this.stage) || void 0 === _b || _b.setCursor(pickedIcon.attribute.cursor), null === (_c = this.stage) || void 0 === _c || _c.renderNextFrame()) : (this._currentHoverIcon.setHoverState(!1), this._currentHoverIcon = null, null === (_d = this.stage) || void 0 === _d || _d.setCursor(), null === (_e = this.stage) || void 0 === _e || _e.renderNextFrame());
  }
  pickIcon(point) {
    const frameCache = this.getFrameCache(),
      {
        e: x,
        f: y
      } = this.globalTransMatrix;
    let pickIcon;
    return frameCache.icons.forEach((icon, key) => {
      var _a, _b;
      const bounds = icon.AABBBounds.clone();
      bounds.translate(icon._marginArray[3], icon._marginArray[0]), bounds.containsPoint({
        x: point.x - x,
        y: point.y - y
      }) && (pickIcon = icon, pickIcon.globalX = (null !== (_a = pickIcon.attribute.x) && void 0 !== _a ? _a : 0) + x + icon._marginArray[3], pickIcon.globalY = (null !== (_b = pickIcon.attribute.y) && void 0 !== _b ? _b : 0) + y + icon._marginArray[0]);
    }), pickIcon;
  }
  getNoWorkAnimateAttr() {
    return RichText.NOWORK_ANIMATE_ATTR;
  }
}
RichText.NOWORK_ANIMATE_ATTR = Object.assign({
  ellipsis: 1,
  wordBreak: 1,
  verticalDirection: 1,
  textAlign: 1,
  textBaseline: 1,
  textConfig: 1,
  layoutDirection: 1
}, NOWORK_ANIMATE_ATTR);
function createRichText(attributes) {
  return new RichText(attributes);
}

const PATH_UPDATE_TAG_KEY = ["path", "customPath", ...GRAPHIC_UPDATE_TAG_KEY];
class Path extends Graphic {
  constructor(params) {
    super(params), this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  get pathShape() {
    return this.tryUpdateAABBBounds(), this.getParsedPathShape();
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      path: path
    } = this.attribute;
    return null != path && "" !== path;
  }
  getParsedPathShape() {
    const pathTheme = this.getGraphicTheme();
    if (!this.valid) return pathTheme.path;
    const attribute = this.attribute;
    return attribute.path instanceof CustomPath2D ? attribute.path : (isNil(this.cache) && this.doUpdatePathShape(), this.cache instanceof CustomPath2D ? this.cache : pathTheme.path);
  }
  getGraphicTheme() {
    return getTheme(this).path;
  }
  updateAABBBounds(attribute, pathTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      const pathShape = this.getParsedPathShape();
      aabbBounds.union(pathShape.getBounds());
    }
    const {
      tb1: tb1,
      tb2: tb2
    } = application.graphicService.updateTempAABBBounds(aabbBounds);
    updateBoundsOfCommonOuterBorder(attribute, pathTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
    const {
      lineJoin = pathTheme.lineJoin
    } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, pathTheme, "miter" === lineJoin, this), aabbBounds;
  }
  doUpdateAABBBounds(full) {
    return this.doUpdatePathShape(), super.doUpdateAABBBounds(full);
  }
  doUpdatePathShape() {
    const attribute = this.attribute;
    isString(attribute.path, !0) ? this.cache = new CustomPath2D().fromString(attribute.path) : attribute.customPath && (this.cache = new CustomPath2D(), attribute.customPath(this.cache, this));
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, PATH_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, PATH_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    return new CustomPath2D().fromCustomPath2D(this.getParsedPathShape(), 0, 0);
  }
  clone() {
    return new Path(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Path.NOWORK_ANIMATE_ATTR;
  }
}
Path.NOWORK_ANIMATE_ATTR = Object.assign({
  path: 1,
  customPath: 1
}, NOWORK_ANIMATE_ATTR);
function createPath(attributes) {
  return new Path(attributes);
}

const AREA_UPDATE_TAG_KEY = ["segments", "points", "curveType", "curveTension", ...GRAPHIC_UPDATE_TAG_KEY];
class Area extends Graphic {
  constructor(params) {
    super(params), this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy) return !0;
    const {
      points: points,
      segments: segments
    } = this.attribute;
    return segments ? 0 !== segments.length : !!points && 0 !== points.length;
  }
  getGraphicTheme() {
    return getTheme(this).area;
  }
  updateAABBBounds(attribute, areaTheme, aabbBounds) {
    this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds) : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds)), application.graphicService.updateTempAABBBounds(aabbBounds), this.setWidthHeightWithoutTransform(aabbBounds);
    const {
      lineJoin = areaTheme.lineJoin
    } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, areaTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
    const {
        points = areaTheme.points
      } = attribute,
      b = aabbBounds;
    return points.forEach(p => {
      var _a, _b;
      b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
    }), b;
  }
  updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
    const {
        segments = areaTheme.segments
      } = attribute,
      b = aabbBounds;
    return segments.forEach(s => {
      s.points.forEach(p => {
        var _a, _b;
        b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
      });
    }), b;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, AREA_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, AREA_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    let path = super.toCustomPath();
    if (path) return path;
    path = new CustomPath2D();
    const attribute = this.attribute,
      segments = attribute.segments,
      parsePoints = points => {
        if (points && points.length) {
          let isFirst = !0;
          const basePoints = [];
          if (points.forEach(point => {
            var _a, _b;
            !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), basePoints.push({
              x: null !== (_a = point.x1) && void 0 !== _a ? _a : point.x,
              y: null !== (_b = point.y1) && void 0 !== _b ? _b : point.y
            }), isFirst = !1);
          }), basePoints.length) {
            for (let i = basePoints.length - 1; i >= 0; i--) path.lineTo(basePoints[i].x, basePoints[i].y);
            path.closePath();
          }
        }
      };
    return attribute.points ? parsePoints(attribute.points) : segments && segments.length && segments.forEach(seg => {
      parsePoints(seg.points);
    }), path;
  }
  clone() {
    return new Area(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Area.NOWORK_ANIMATE_ATTR;
  }
}
Area.NOWORK_ANIMATE_ATTR = Object.assign({
  segments: 1,
  curveType: 1
}, NOWORK_ANIMATE_ATTR);
function createArea(attributes) {
  return new Area(attributes);
}

const ARC_UPDATE_TAG_KEY = ["innerRadius", "outerRadius", "startAngle", "endAngle", "cornerRadius", "padAngle", "padRadius", "cap", ...GRAPHIC_UPDATE_TAG_KEY];
class Arc extends Graphic {
  constructor(params) {
    super(params), this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      startAngle: startAngle,
      endAngle: endAngle,
      outerRadius: outerRadius,
      innerRadius: innerRadius
    } = this.attribute;
    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(outerRadius) && this._validNumber(innerRadius);
  }
  getParsedCornerRadius() {
    const arcTheme = this.getGraphicTheme(),
      {
        cornerRadius = arcTheme.cornerRadius,
        innerPadding = arcTheme.innerPadding,
        outerPadding = arcTheme.outerPadding
      } = this.attribute;
    let {
      outerRadius = arcTheme.outerRadius,
      innerRadius = arcTheme.innerRadius
    } = this.attribute;
    if (outerRadius += outerPadding, innerRadius -= innerPadding, 0 === cornerRadius || "0%" === cornerRadius) return 0;
    const deltaRadius = Math.abs(outerRadius - innerRadius),
      parseCR = cornerRadius => Math.min(isNumber(cornerRadius, !0) ? cornerRadius : deltaRadius * parseFloat(cornerRadius) / 100, deltaRadius / 2);
    if (isArray(cornerRadius)) {
      const crList = cornerRadius.map(cr => parseCR(cr) || 0);
      return 0 === crList.length ? [crList[0], crList[0], crList[0], crList[0]] : 2 === crList.length ? [crList[0], crList[1], crList[0], crList[1]] : (3 === crList.length && crList.push(0), crList);
    }
    return parseCR(cornerRadius);
  }
  getParsedAngle() {
    const arcTheme = this.getGraphicTheme();
    let {
      startAngle = arcTheme.startAngle,
      endAngle = arcTheme.endAngle
    } = this.attribute;
    const {
        cap = arcTheme.cap
      } = this.attribute,
      sign = endAngle - startAngle >= 0 ? 1 : -1,
      deltaAngle = endAngle - startAngle;
    if (startAngle = clampAngleByRadian(startAngle), endAngle = startAngle + deltaAngle, cap && abs(deltaAngle) < pi2 - epsilon) {
      let startCap = 1,
        endCap = 1;
      cap.length && (startCap = Number(cap[0]), endCap = Number(cap[1]));
      let {
        outerRadius = arcTheme.outerRadius,
        innerRadius = arcTheme.innerRadius
      } = this.attribute;
      const {
        outerPadding = arcTheme.outerPadding,
        innerPadding = arcTheme.innerPadding
      } = this.attribute;
      outerRadius += outerPadding, innerRadius -= innerPadding;
      const capWidth = Math.abs(outerRadius - innerRadius) / 2,
        capAngle = capWidth / outerRadius;
      if (capWidth > epsilon && outerRadius > epsilon) return {
        startAngle: startAngle - sign * capAngle * startCap,
        endAngle: endAngle + sign * capAngle * endCap,
        sc: sign * capAngle * startCap,
        ec: sign * capAngle * endCap
      };
    }
    return {
      startAngle: startAngle,
      endAngle: endAngle
    };
  }
  getParsePadAngle(startAngle, endAngle) {
    const arcTheme = this.getGraphicTheme(),
      {
        innerPadding = arcTheme.innerPadding,
        outerPadding = arcTheme.outerPadding,
        padAngle = arcTheme.padAngle
      } = this.attribute;
    let {
      outerRadius = arcTheme.outerRadius,
      innerRadius = arcTheme.innerRadius
    } = this.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const {
        padRadius = sqrt(outerRadius * outerRadius + innerRadius * innerRadius)
      } = this.attribute,
      deltaAngle = abs(endAngle - startAngle);
    let outerStartAngle = startAngle,
      outerEndAngle = endAngle,
      innerStartAngle = startAngle,
      innerEndAngle = endAngle;
    const halfPadAngle = padAngle / 2;
    let innerDeltaAngle = deltaAngle,
      outerDeltaAngle = deltaAngle;
    if (halfPadAngle > epsilon && padRadius > epsilon) {
      const sign = endAngle > startAngle ? 1 : -1;
      let p0 = asin(Number(padRadius) / innerRadius * sin(halfPadAngle)),
        p1 = asin(Number(padRadius) / outerRadius * sin(halfPadAngle));
      return (innerDeltaAngle -= 2 * p0) > epsilon ? (p0 *= sign, innerStartAngle += p0, innerEndAngle -= p0) : (innerDeltaAngle = 0, innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2), (outerDeltaAngle -= 2 * p1) > epsilon ? (p1 *= sign, outerStartAngle += p1, outerEndAngle -= p1) : (outerDeltaAngle = 0, outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2), {
        outerStartAngle: outerStartAngle,
        outerEndAngle: outerEndAngle,
        innerStartAngle: innerStartAngle,
        innerEndAngle: innerEndAngle,
        innerDeltaAngle: innerDeltaAngle,
        outerDeltaAngle: outerDeltaAngle
      };
    }
    return {
      outerStartAngle: outerStartAngle,
      outerEndAngle: outerEndAngle,
      innerStartAngle: innerStartAngle,
      innerEndAngle: innerEndAngle,
      innerDeltaAngle: innerDeltaAngle,
      outerDeltaAngle: outerDeltaAngle
    };
  }
  getGraphicTheme() {
    return getTheme(this).arc;
  }
  updateAABBBounds(attribute, arcTheme, aabbBounds, full) {
    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds));
    const {
      tb1: tb1,
      tb2: tb2
    } = application.graphicService.updateTempAABBBounds(aabbBounds);
    updateBoundsOfCommonOuterBorder(attribute, arcTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.setWidthHeightWithoutTransform(aabbBounds);
    const {
      lineJoin = arcTheme.lineJoin
    } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, arcTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) {
    let {
      outerRadius = arcTheme.outerRadius,
      innerRadius = arcTheme.innerRadius
    } = attribute;
    const {
      outerPadding = arcTheme.outerPadding,
      innerPadding = arcTheme.innerPadding
    } = attribute;
    return outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius && (outerRadius = innerRadius), aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius), aabbBounds;
  }
  updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds) {
    let {
      outerRadius = arcTheme.outerRadius,
      innerRadius = arcTheme.innerRadius
    } = attribute;
    const {
      outerPadding = arcTheme.outerPadding,
      innerPadding = arcTheme.innerPadding
    } = attribute;
    if (outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius) {
      const temp = outerRadius;
      outerRadius = innerRadius, innerRadius = temp;
    }
    let {
      endAngle = arcTheme.endAngle,
      startAngle = arcTheme.startAngle
    } = attribute;
    if (startAngle > endAngle) {
      const temp = startAngle;
      startAngle = endAngle, endAngle = temp;
    }
    return outerRadius <= epsilon ? aabbBounds.set(0, 0, 0, 0) : Math.abs(endAngle - startAngle) > pi2 - epsilon ? aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius) : (circleBounds(startAngle, endAngle, outerRadius, aabbBounds), circleBounds(startAngle, endAngle, innerRadius, aabbBounds)), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, ARC_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, ARC_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    var _a, _b, _c, _d;
    let path = super.toCustomPath();
    if (path) return path;
    const attribute = this.attribute,
      {
        startAngle: startAngle,
        endAngle: endAngle
      } = this.getParsedAngle();
    let innerRadius = (null !== (_a = attribute.innerRadius) && void 0 !== _a ? _a : 0) - (null !== (_b = attribute.innerPadding) && void 0 !== _b ? _b : 0),
      outerRadius = (null !== (_c = attribute.outerRadius) && void 0 !== _c ? _c : 0) - (null !== (_d = attribute.outerPadding) && void 0 !== _d ? _d : 0);
    const deltaAngle = abs(endAngle - startAngle),
      clockwise = endAngle > startAngle;
    if (outerRadius < innerRadius) {
      const temp = outerRadius;
      outerRadius = innerRadius, innerRadius = temp;
    }
    if (path = new CustomPath2D(), outerRadius <= epsilon) path.moveTo(0, 0);else if (deltaAngle >= pi2 - epsilon) path.moveTo(0 + outerRadius * cos(startAngle), 0 + outerRadius * sin(startAngle)), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (path.moveTo(0 + innerRadius * cos(endAngle), 0 + innerRadius * sin(endAngle)), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise));else {
      const xors = outerRadius * cos(startAngle),
        yors = outerRadius * sin(startAngle),
        xire = innerRadius * cos(endAngle),
        yire = innerRadius * sin(endAngle);
      path.moveTo(0 + xors, 0 + yors), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), path.lineTo(0 + xire, 0 + yire), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise), path.closePath();
    }
    return path;
  }
  clone() {
    return new Arc(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Arc.NOWORK_ANIMATE_ATTR;
  }
}
Arc.NOWORK_ANIMATE_ATTR = Object.assign({
  cap: 1
}, NOWORK_ANIMATE_ATTR);
function createArc(attributes) {
  return new Arc(attributes);
}

const POLYGON_UPDATE_TAG_KEY = ["points", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
class Polygon extends Graphic {
  constructor(params) {
    super(params), this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      points: points
    } = this.attribute;
    return points && points.length >= 2;
  }
  getGraphicTheme() {
    return getTheme(this).polygon;
  }
  updateAABBBounds(attribute, polygonTheme, aabbBounds) {
    this.updatePathProxyAABBBounds(aabbBounds) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds), application.graphicService.updateTempAABBBounds(aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
    const {
      lineJoin = polygonTheme.lineJoin
    } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds) {
    const {
      points = polygonTheme.points
    } = attribute;
    return points.forEach(p => {
      aabbBounds.add(p.x, p.y);
    }), aabbBounds;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, POLYGON_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, POLYGON_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    let path = super.toCustomPath();
    if (path) return path;
    const points = this.attribute.points;
    return path = new CustomPath2D(), points.forEach((point, index) => {
      0 === index ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y);
    }), path.closePath(), path;
  }
  clone() {
    return new Polygon(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Polygon.NOWORK_ANIMATE_ATTR;
  }
}
Polygon.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createPolygon(attributes) {
  return new Polygon(attributes);
}

class GraphicCreator {
  constructor() {
    this.store = new Map();
  }
  RegisterGraphicCreator(name, cb) {
    this.store.set(name, cb), this[name] = cb;
  }
  CreateGraphic(name, params) {
    const cb = this.store.get(name);
    return cb ? cb(params) : null;
  }
}
const graphicCreator = new GraphicCreator();

let text;
function getTextBounds(params) {
  return text || (text = graphicCreator.CreateGraphic("text", {})), text.initAttributes(params), text.AABBBounds;
}

var __decorate$I = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$A = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$x = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
class DefaultBaseBackgroundRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a;
    const {
      background: background,
      backgroundOpacity = null !== (_a = graphic.attribute.fillOpacity) && void 0 !== _a ? _a : graphicAttribute.backgroundOpacity,
      opacity = graphicAttribute.opacity,
      backgroundMode = graphicAttribute.backgroundMode,
      backgroundFit = graphicAttribute.backgroundFit,
      backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio,
      backgroundScale = graphicAttribute.backgroundScale,
      backgroundOffsetX = graphicAttribute.backgroundOffsetX,
      backgroundOffsetY = graphicAttribute.backgroundOffsetY,
      backgroundClip = graphicAttribute.backgroundClip
    } = graphic.attribute;
    if (background) if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return;
      if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
        const groupAttribute = getTheme(graphic.parent).group,
          {
            scrollX = groupAttribute.scrollX,
            scrollY = groupAttribute.scrollY
          } = graphic.parent.attribute;
        context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);
      }
      backgroundClip && context.clip();
      const b = graphic.AABBBounds;
      context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, this.doDrawImage(context, res.data, b, {
        backgroundMode: backgroundMode,
        backgroundFit: backgroundFit,
        backgroundKeepAspectRatio: backgroundKeepAspectRatio,
        backgroundScale: backgroundScale,
        backgroundOffsetX: backgroundOffsetX,
        backgroundOffsetY: backgroundOffsetY
      }), context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
    } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, context.fillStyle = background, context.fill(), context.highPerformanceRestore();
  }
  doDrawImage(context, data, b, params) {
    const {
        backgroundMode: backgroundMode,
        backgroundFit: backgroundFit,
        backgroundKeepAspectRatio: backgroundKeepAspectRatio,
        backgroundScale = 1,
        backgroundOffsetX = 0,
        backgroundOffsetY = 0
      } = params,
      targetW = b.width(),
      targetH = b.height();
    let w = targetW,
      h = targetH;
    if ("no-repeat" === backgroundMode) {
      if (backgroundFit) {
        if (backgroundKeepAspectRatio) {
          const maxScale = Math.max(targetW / data.width, targetH / data.height);
          context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, data.width * maxScale * backgroundScale, data.height * maxScale * backgroundScale);
        } else context.drawImage(data, b.x1, b.y1, b.width(), b.height());
      } else {
        const resW = data.width * backgroundScale,
          resH = data.height * backgroundScale;
        context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, resW, resH);
      }
    } else {
      if (backgroundFit && "repeat" !== backgroundMode && (data.width || data.height)) {
        const resW = data.width,
          resH = data.height;
        if ("repeat-x" === backgroundMode) {
          w = resW * (targetH / resH), h = targetH;
        } else if ("repeat-y" === backgroundMode) {
          h = resH * (targetW / resW), w = targetW;
        }
        const dpr = context.dpr,
          canvas = canvasAllocate.allocate({
            width: w,
            height: h,
            dpr: dpr
          }),
          ctx = canvas.getContext("2d");
        ctx && (ctx.inuse = !0, ctx.clearMatrix(), ctx.setTransformForCurrent(!0), ctx.clearRect(0, 0, w, h), ctx.drawImage(data, 0, 0, w, h), data = canvas.nativeCanvas), canvasAllocate.free(canvas);
      }
      const dpr = context.dpr,
        pattern = context.createPattern(data, backgroundMode);
      pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), context.fillStyle = pattern, context.translate(b.x1, b.y1), context.fillRect(0, 0, targetW, targetH), context.translate(-b.x1, -b.y1);
    }
  }
}
const defaultBaseBackgroundRenderContribution = new DefaultBaseBackgroundRenderContribution();
let DefaultBaseInteractiveRenderContribution = class {
  constructor(subRenderContribitions) {
    this.subRenderContribitions = subRenderContribitions, this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    this._subRenderContribitions || (this._subRenderContribitions = this.subRenderContribitions.getContributions()), this._subRenderContribitions.forEach(c => {
      c.render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options);
    });
  }
};
DefaultBaseInteractiveRenderContribution = __decorate$I([injectable(), __param$x(0, inject(ContributionProvider)), __param$x(0, named(InteractiveSubRenderContribution)), __metadata$A("design:paramtypes", [Object])], DefaultBaseInteractiveRenderContribution);
class DefaultBaseClipRenderBeforeContribution {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a, _b;
    const {
      clipConfig: clipConfig
    } = graphic.attribute;
    if (!clipConfig) return;
    const clipPath = graphic.getClipPath();
    if (!clipPath) return;
    const draw = !(fillCb || strokeCb),
      b = graphic.AABBBounds,
      width = null !== (_a = graphic.attribute.width) && void 0 !== _a ? _a : b.width(),
      height = null !== (_b = graphic.attribute.height) && void 0 !== _b ? _b : b.height();
    draw && context.save(), context.beginPath(), !1 === clipPath.draw(context, [width, height], x + width / 2, y + height / 2, 0) && context.closePath(), fillCb && fillCb(context, graphic.attribute, graphicAttribute, !0), draw && context.clip();
  }
}
const defaultBaseClipRenderBeforeContribution = new DefaultBaseClipRenderBeforeContribution();
class DefaultBaseClipRenderAfterContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    const {
      clipConfig: clipConfig
    } = graphic.attribute;
    if (!clipConfig) return;
    graphic.getClipPath() && (fillCb || strokeCb || context.restore());
  }
}
const defaultBaseClipRenderAfterContribution = new DefaultBaseClipRenderAfterContribution();

function formatRatio(ratio) {
  return ratio <= .5 ? 4 * ratio - 1 : -4 * ratio + 3;
}
function drawWave(ctx, ratio, boundsWidth, boundsHeight, textureOptions, offsetX, offsetY) {
  const {
    fill = "orange",
    percent = .6,
    frequency = 4,
    opacity: opacity,
    phi = 0
  } = textureOptions;
  let {
    amplitude = 10
  } = textureOptions;
  amplitude *= formatRatio(ratio);
  const height = boundsHeight * (1 - percent),
    width = boundsWidth,
    step = Math.max(Math.round(width / 70), 2);
  ctx.beginPath(), ctx.moveTo(0 + offsetX, boundsHeight + offsetY), ctx.lineTo(0 + offsetX, height + offsetY);
  const delta = width / frequency * ratio,
    c = width / Math.PI / (2 * frequency);
  for (let i = 0; i < width; i += step) {
    const y = amplitude * Math.sin((i + delta + phi) / c + phi);
    ctx.lineTo(i + offsetX, height + y + offsetY);
  }
  ctx.lineTo(width + offsetX, boundsHeight + offsetY), ctx.closePath(), ctx.fillStyle = fill, isFinite(opacity) && (ctx.globalAlpha = opacity), ctx.fill();
}
class DefaultBaseTextureRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 10, this._tempSymbolGraphic = null;
  }
  createCommonPattern(size, padding, color, targetContext, cb) {
    const r = (size - 2 * padding) / 2,
      dpr = targetContext.dpr,
      canvas = canvasAllocate.allocate({
        width: size,
        height: size,
        dpr: dpr
      }),
      ctx = canvas.getContext("2d");
    if (!ctx) return null;
    ctx.inuse = !0, ctx.clearMatrix(), ctx.setTransformForCurrent(!0), ctx.clearRect(0, 0, size, size), cb(r, ctx);
    const pattern = targetContext.createPattern(canvas.nativeCanvas, "repeat");
    return pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), canvasAllocate.free(canvas), pattern;
  }
  createCirclePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.fillStyle = color, ctx.arc(r, r, r, 0, pi2), ctx.fill();
    });
  }
  createDiamondPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = size / 2,
        y = x;
      ctx.fillStyle = color, ctx.moveTo(x, y - r), ctx.lineTo(r + x, y), ctx.lineTo(x, y + r), ctx.lineTo(x - r, y), ctx.closePath(), ctx.fill();
    });
  }
  createRectPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding,
        y = x;
      ctx.fillStyle = color, ctx.fillRect(x, y, 2 * r, 2 * r);
    });
  }
  createVerticalLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding;
      ctx.fillStyle = color, ctx.fillRect(x, 0, 2 * r, size);
    });
  }
  createHorizontalLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const y = padding;
      ctx.fillStyle = color, ctx.fillRect(0, y, size, 2 * r);
    });
  }
  createBiasLRLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(0, 0), ctx.lineTo(size, size);
      const dx = size / 2,
        dy = -dx;
      ctx.moveTo(dx, dy), ctx.lineTo(dx + size, dy + size), ctx.moveTo(-dx, -dy), ctx.lineTo(-dx + size, -dy + size), ctx.stroke();
    });
  }
  createBiasRLLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(size, 0), ctx.lineTo(0, size);
      const dx = size / 2,
        dy = dx;
      ctx.moveTo(size + dx, dy), ctx.lineTo(dx, dy + size), ctx.moveTo(size - dx, -dy), ctx.lineTo(-dx, -dy + size), ctx.stroke();
    });
  }
  createGridPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding,
        y = x;
      ctx.fillStyle = color, ctx.fillRect(x, y, r, r), ctx.fillRect(x + r, y + r, r, r);
    });
  }
  initTextureMap(ctx, stage) {
    this.textureMap = new Map();
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    this.textureMap || this.initTextureMap(context, graphic.stage);
    const {
      texture = graphicAttribute.texture,
      textureColor = graphicAttribute.textureColor,
      textureSize = graphicAttribute.textureSize,
      texturePadding = graphicAttribute.texturePadding
    } = graphic.attribute;
    texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
  }
  drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding) {
    var _a;
    const {
      textureRatio = graphicAttribute.textureRatio,
      textureOptions = null
    } = graphic.attribute;
    let pattern = this.textureMap.get(texture);
    if (!pattern) switch (texture) {
      case "circle":
        pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "diamond":
        pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
        break;
      case "rect":
        pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
        break;
      case "vertical-line":
        pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "horizontal-line":
        pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "bias-lr":
        pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "bias-rl":
        pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "grid":
        pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
    }
    if (textureOptions && textureOptions.dynamicTexture) {
      const {
          gridConfig = {},
          useNewCanvas: useNewCanvas
        } = textureOptions,
        b = graphic.AABBBounds;
      x = b.x1, y = b.y1;
      const originalContext = context;
      let newCanvas;
      if (useNewCanvas) {
        newCanvas = canvasAllocate.allocate({
          width: b.width(),
          height: b.height(),
          dpr: context.dpr
        });
        const ctx = newCanvas.getContext("2d");
        ctx.clearRect(0, 0, b.width(), b.height()), x = 0, y = 0, context = ctx;
      }
      if (originalContext.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
        const {
          scrollX = 0,
          scrollY = 0
        } = graphic.parent.attribute;
        originalContext.setTransformFromMatrix(graphic.parent.globalTransMatrix), originalContext.translate(scrollX, scrollY, !0);
      }
      originalContext.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), originalContext.clip();
      const width = b.width(),
        height = b.height(),
        padding = texturePadding,
        cellSize = textureSize,
        gridColumns = gridConfig.columns ? gridConfig.columns : Math.ceil(width / cellSize),
        gridRows = gridConfig.rows ? gridConfig.rows : Math.ceil(height / cellSize),
        gutterColumn = gridConfig.gutterColumn ? gridConfig.gutterColumn : 2 * padding,
        gutterRow = gridConfig.gutterRow ? gridConfig.gutterRow : 2 * padding;
      this._tempSymbolGraphic || (this._tempSymbolGraphic = createSymbol({}));
      const sizeW = gridConfig.columns ? width / gridConfig.columns : cellSize,
        sizeH = gridConfig.rows ? height / gridConfig.rows : cellSize;
      this._tempSymbolGraphic.setAttributes({
        size: [sizeW - gutterColumn, sizeH - gutterRow],
        symbolType: texture
      });
      const parsedPath = this._tempSymbolGraphic.getParsedPath();
      for (let i = 0; i < gridRows; i++) for (let j = 0; j < gridColumns; j++) {
        const _x = x + cellSize / 2 + j * cellSize,
          _y = y + cellSize / 2 + i * cellSize;
        null === (_a = textureOptions.beforeDynamicTexture) || void 0 === _a || _a.call(textureOptions, context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height()), context.beginPath(), !1 === parsedPath.draw(context, Math.min(sizeW - gutterColumn, sizeH - gutterRow), _x, _y, 0) && context.closePath(), context.fillStyle = textureColor, textureOptions.dynamicTexture(context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height());
      }
      useNewCanvas && (originalContext.globalAlpha = 1, originalContext.drawImage(newCanvas.nativeCanvas, 0, 0, newCanvas.nativeCanvas.width, newCanvas.nativeCanvas.height, b.x1, b.y1, b.width() * originalContext.dpr, b.height() * originalContext.dpr)), originalContext.restore();
    } else if (pattern) context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = pattern, context.fill(), context.highPerformanceRestore();else if ("wave" === texture) {
      context.save(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.clip();
      const b = graphic.AABBBounds;
      drawWave(context, textureRatio, b.width(), b.height(), Object.assign(Object.assign({}, textureOptions || {}), {
        fill: textureColor
      }), x + b.x1 - x, y + b.y1 - y), context.restore();
    }
  }
}
const defaultBaseTextureRenderContribution = new DefaultBaseTextureRenderContribution();

class DefaultArcRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb) {
    const {
        outerBorder: outerBorder,
        innerBorder: innerBorder
      } = arc.attribute,
      doOuterBorder = outerBorder && !1 !== outerBorder.visible,
      doInnerBorder = innerBorder && !1 !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const {
      innerPadding = arcAttribute.innerPadding,
      outerPadding = arcAttribute.outerPadding,
      startAngle = arcAttribute.startAngle,
      endAngle = arcAttribute.endAngle,
      opacity = arcAttribute.opacity,
      x: originX = arcAttribute.x,
      y: originY = arcAttribute.y,
      scaleX = arcAttribute.scaleX,
      scaleY = arcAttribute.scaleY,
      keepStrokeScale = arcAttribute.keepStrokeScale
    } = arc.attribute;
    let {
      innerRadius = arcAttribute.innerRadius,
      outerRadius = arcAttribute.outerRadius
    } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const renderBorder = (borderStyle, key) => {
      const doStroke = !(!borderStyle || !borderStyle.stroke),
        {
          distance = arcAttribute[key].distance
        } = borderStyle,
        d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
        deltaAngle = distance / outerRadius,
        sign = "outerBorder" === key ? 1 : -1;
      if (arc.setAttributes({
        outerRadius: outerRadius + sign * d,
        innerRadius: innerRadius - sign * d,
        startAngle: startAngle - sign * deltaAngle,
        endAngle: endAngle + sign * deltaAngle
      }), context.beginPath(), drawArcPath(arc, context, x, y, outerRadius + sign * d, innerRadius - sign * d), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), strokeCb) strokeCb(context, borderStyle, arcAttribute[key]);else if (doStroke) {
        const lastOpacity = arcAttribute[key].opacity;
        arcAttribute[key].opacity = opacity, context.setStrokeStyle(arc, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, arcAttribute[key]), arcAttribute[key].opacity = lastOpacity, context.stroke();
      }
    };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder"), arc.setAttributes({
      outerRadius: outerRadius,
      innerRadius: innerRadius,
      startAngle: startAngle,
      endAngle: endAngle
    });
  }
}
const defaultArcRenderContribution = new DefaultArcRenderContribution();
const defaultArcTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultArcBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultCircleRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb) {
    const {
        outerBorder: outerBorder,
        innerBorder: innerBorder
      } = circle.attribute,
      doOuterBorder = outerBorder && !1 !== outerBorder.visible,
      doInnerBorder = innerBorder && !1 !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const {
        radius = circleAttribute.radius,
        startAngle = circleAttribute.startAngle,
        endAngle = circleAttribute.endAngle,
        opacity = circleAttribute.opacity,
        x: originX = circleAttribute.x,
        y: originY = circleAttribute.y,
        scaleX = circleAttribute.scaleX,
        scaleY = circleAttribute.scaleY,
        keepStrokeScale = circleAttribute.keepStrokeScale
      } = circle.attribute,
      renderBorder = (borderStyle, key) => {
        const doStroke = !(!borderStyle || !borderStyle.stroke),
          {
            distance = circleAttribute[key].distance
          } = borderStyle,
          d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
          sign = "outerBorder" === key ? 1 : -1;
        if (context.beginPath(), context.arc(x, y, radius + sign * d, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle, circle.attribute, circleAttribute), strokeCb) strokeCb(context, borderStyle, circleAttribute[key]);else if (doStroke) {
          const lastOpacity = circleAttribute[key].opacity;
          circleAttribute[key].opacity = opacity, context.setStrokeStyle(circle, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, circleAttribute[key]), circleAttribute[key].opacity = lastOpacity, context.stroke();
        }
      };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
  }
}
const defaultCircleRenderContribution = new DefaultCircleRenderContribution();
const defaultCircleTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultCircleBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultGroupBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    const {
      background: background,
      backgroundMode = graphicAttribute.backgroundMode,
      backgroundFit = graphicAttribute.backgroundFit,
      backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio,
      backgroundScale = graphicAttribute.backgroundScale,
      backgroundOffsetX = graphicAttribute.backgroundOffsetX,
      backgroundOffsetY = graphicAttribute.backgroundOffsetY
    } = graphic.attribute;
    if (background) if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return;
      context.highPerformanceSave(), context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0);
      const b = graphic.AABBBounds;
      this.doDrawImage(context, res.data, b, {
        backgroundMode: backgroundMode,
        backgroundFit: backgroundFit,
        backgroundKeepAspectRatio: backgroundKeepAspectRatio,
        backgroundScale: backgroundScale,
        backgroundOffsetX: backgroundOffsetX,
        backgroundOffsetY: backgroundOffsetY
      }), context.highPerformanceRestore(), context.setTransformForCurrent();
    } else context.highPerformanceSave(), context.fillStyle = background, context.fill(), context.highPerformanceRestore();
  }
}
const defaultGroupBackgroundRenderContribution = new DefaultGroupBackgroundRenderContribution();

const halfPi = pi / 2;
function createRectPath(path, x, y, width, height, rectCornerRadius, roundCorner = !0, edgeCb) {
  let cornerRadius;
  if (Array.isArray(roundCorner) && (edgeCb = roundCorner, roundCorner = !0), width < 0 && (x += width, width = -width), height < 0 && (y += height, height = -height), isNumber(rectCornerRadius, !0)) cornerRadius = [rectCornerRadius = abs(rectCornerRadius), rectCornerRadius, rectCornerRadius, rectCornerRadius];else if (Array.isArray(rectCornerRadius)) {
    const cornerRadiusArr = rectCornerRadius;
    let cr0, cr1;
    switch (cornerRadiusArr.length) {
      case 0:
        cornerRadius = [0, 0, 0, 0];
        break;
      case 1:
        cr0 = abs(cornerRadiusArr[0]), cornerRadius = [cr0, cr0, cr0, cr0];
        break;
      case 2:
      case 3:
        cr0 = abs(cornerRadiusArr[0]), cr1 = abs(cornerRadiusArr[1]), cornerRadius = [cr0, cr1, cr0, cr1];
        break;
      default:
        cornerRadius = cornerRadiusArr, cornerRadius[0] = abs(cornerRadius[0]), cornerRadius[1] = abs(cornerRadius[1]), cornerRadius[2] = abs(cornerRadius[2]), cornerRadius[3] = abs(cornerRadius[3]);
    }
  } else cornerRadius = [0, 0, 0, 0];
  if (width < 0 || cornerRadius[0] + cornerRadius[1] + cornerRadius[2] + cornerRadius[3] < 1e-12) return path.rect(x, y, width, height);
  const [leftTop, rightTop, rightBottom, leftBottom] = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]],
    maxCornerRadius = Math.min(width / 2, height / 2),
    _cornerRadius = [Math.min(maxCornerRadius, cornerRadius[0]), Math.min(maxCornerRadius, cornerRadius[1]), Math.min(maxCornerRadius, cornerRadius[2]), Math.min(maxCornerRadius, cornerRadius[3])],
    leftTopPoint1 = [leftTop[0] + _cornerRadius[0], leftTop[1]],
    leftTopPoint2 = [leftTop[0], leftTop[1] + _cornerRadius[0]],
    rightTopPoint1 = [rightTop[0] - _cornerRadius[1], rightTop[1]],
    rightTopPoint2 = [rightTop[0], rightTop[1] + _cornerRadius[1]],
    rightBottomPoint1 = [rightBottom[0] - _cornerRadius[2], rightBottom[1]],
    rightBottomPoint2 = [rightBottom[0], rightBottom[1] - _cornerRadius[2]],
    leftBottomPoint1 = [leftBottom[0] + _cornerRadius[3], leftBottom[1]],
    leftBottomPoint2 = [leftBottom[0], leftBottom[1] - _cornerRadius[3]];
  if (path.moveTo(leftTopPoint1[0], leftTopPoint1[1]), roundCorner) {
    if (edgeCb && edgeCb[0] ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1]) : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), !arrayEqual(rightTopPoint1, rightTopPoint2)) {
      edgeCb && edgeCb[0] && path.moveTo(rightTopPoint1[0], rightTopPoint1[1]);
      const centerX = rightTopPoint1[0],
        centerY = rightTopPoint1[1] + _cornerRadius[1];
      path.arc(centerX, centerY, _cornerRadius[1], -halfPi, 0, !1);
    }
    if (edgeCb && edgeCb[1] ? edgeCb[1](rightTopPoint2[0], rightTopPoint2[1], rightBottomPoint2[0], rightBottomPoint2[1]) : path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]), !arrayEqual(rightBottomPoint1, rightBottomPoint2)) {
      const centerX = rightBottomPoint2[0] - _cornerRadius[2],
        centerY = rightBottomPoint2[1];
      edgeCb && edgeCb[1] && path.moveTo(rightBottomPoint2[0], rightBottomPoint2[1]), path.arc(centerX, centerY, _cornerRadius[2], 0, halfPi, !1);
    }
    if (edgeCb && edgeCb[2] ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1]) : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), !arrayEqual(leftBottomPoint1, leftBottomPoint2)) {
      const centerX = leftBottomPoint1[0],
        centerY = leftBottomPoint1[1] - _cornerRadius[3];
      edgeCb && edgeCb[2] && path.moveTo(leftBottomPoint1[0], leftBottomPoint1[1]), path.arc(centerX, centerY, _cornerRadius[3], halfPi, pi, !1);
    }
    if (edgeCb && edgeCb[3] ? edgeCb[3](leftBottomPoint2[0], leftBottomPoint2[1], leftTopPoint2[0], leftTopPoint2[1]) : path.lineTo(leftTopPoint2[0], leftTopPoint2[1]), !arrayEqual(leftTopPoint1, leftTopPoint2)) {
      const centerX = leftTopPoint1[0],
        centerY = leftTopPoint1[1] + _cornerRadius[0];
      edgeCb && edgeCb[3] && path.moveTo(leftTopPoint2[0], leftTopPoint2[1]), path.arc(centerX, centerY, _cornerRadius[0], pi, pi + halfPi, !1);
    }
  } else edgeCb && edgeCb[0] ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1]) : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), edgeCb && edgeCb[1] ? edgeCb[1](rightTopPoint1[0], rightTopPoint1[1], rightBottomPoint1[0], rightBottomPoint1[1]) : path.lineTo(rightBottomPoint1[0], rightBottomPoint1[1]), edgeCb && edgeCb[2] ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1]) : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), edgeCb && edgeCb[2] ? edgeCb[2](leftBottomPoint1[0], leftBottomPoint1[1], leftTopPoint1[0], leftTopPoint1[1]) : path.lineTo(leftTopPoint1[0], leftTopPoint1[1]);
  return !edgeCb && path.closePath(), path;
}

var __decorate$H = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class DefaultRectRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    const {
        outerBorder: outerBorder,
        innerBorder: innerBorder
      } = rect.attribute,
      doOuterBorder = outerBorder && !1 !== outerBorder.visible,
      doInnerBorder = innerBorder && !1 !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const {
      cornerRadius = rectAttribute.cornerRadius,
      cornerType = rectAttribute.cornerType,
      opacity = rectAttribute.opacity,
      x: originX = rectAttribute.x,
      y: originY = rectAttribute.y,
      scaleX = rectAttribute.scaleX,
      scaleY = rectAttribute.scaleY,
      x1: x1,
      y1: y1,
      keepStrokeScale = rectAttribute.keepStrokeScale
    } = rect.attribute;
    let {
      width: width,
      height: height
    } = rect.attribute;
    width = (null != width ? width : x1 - x) || 0, height = (null != height ? height : y1 - y) || 0;
    const renderBorder = (borderStyle, key) => {
      const doStroke = !(!borderStyle || !borderStyle.stroke),
        sign = "outerBorder" === key ? -1 : 1,
        {
          distance = rectAttribute[key].distance
        } = borderStyle,
        d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
        nextX = x + sign * d,
        nextY = y + sign * d,
        dw = 2 * d;
      if (0 === cornerRadius || isArray(cornerRadius) && cornerRadius.every(num => 0 === num) ? (context.beginPath(), context.rect(nextX, nextY, width - sign * dw, height - sign * dw)) : (context.beginPath(), createRectPath(context, nextX, nextY, width - sign * dw, height - sign * dw, cornerRadius, "bevel" !== cornerType)), context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), strokeCb) strokeCb(context, borderStyle, rectAttribute[key]);else if (doStroke) {
        const lastOpacity = rectAttribute[key].opacity;
        rectAttribute[key].opacity = opacity, context.setStrokeStyle(rect, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, rectAttribute[key]), rectAttribute[key].opacity = lastOpacity, context.stroke();
      }
    };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
  }
}
let SplitRectBeforeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const {
      stroke = groupAttribute.stroke
    } = group.attribute;
    Array.isArray(stroke) && stroke.some(s => !1 === s) && (doFillOrStroke.doStroke = !1);
  }
};
SplitRectBeforeRenderContribution = __decorate$H([injectable()], SplitRectBeforeRenderContribution);
let SplitRectAfterRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
    const {
      x1: x1,
      y1: y1,
      x: originX = groupAttribute.x,
      y: originY = groupAttribute.y,
      stroke = groupAttribute.stroke,
      cornerRadius = groupAttribute.cornerRadius,
      cornerType = groupAttribute.cornerType
    } = rect.attribute;
    let {
      width: width,
      height: height
    } = rect.attribute;
    if (width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0, Array.isArray(stroke) && stroke.some(s => !1 === s)) {
      if (context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute), !(0 === cornerRadius || isArray(cornerRadius) && cornerRadius.every(num => 0 === num))) {
        let lastStroke,
          lastStrokeI = 0;
        return createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType, new Array(4).fill(0).map((_, i) => (x1, y1, x2, y2) => {
          stroke[i] && (lastStrokeI === i - 1 && stroke[i] === lastStroke || (context.setStrokeStyle(rect, Object.assign(Object.assign({}, rect.attribute), {
            stroke: stroke[i]
          }), x, y, groupAttribute), context.beginPath(), context.moveTo(x1, y1), lastStroke = stroke[i]), lastStrokeI = i, context.lineTo(x2, y2), context.stroke(), 3 === i && context.beginPath());
        })), void context.stroke();
      }
      if (context.beginPath(), context.moveTo(x, y), stroke[0] ? context.lineTo(x + width, y) : context.moveTo(x + width, y), stroke[1] ? context.lineTo(x + width, y + height) : context.moveTo(x + width, y + height), stroke[2] ? context.lineTo(x, y + height) : context.moveTo(x, y + height), stroke[3]) {
        const adjustY = stroke[0] ? y - context.lineWidth / 2 : y;
        context.lineTo(x, adjustY);
      } else context.moveTo(x, y);
      context.stroke();
    }
  }
};
SplitRectAfterRenderContribution = __decorate$H([injectable()], SplitRectAfterRenderContribution);
const defaultRectRenderContribution = new DefaultRectRenderContribution();
const defaultRectTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultRectBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultImageRenderContribution extends DefaultRectRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    return super.drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
  }
}
const defaultImageRenderContribution = new DefaultImageRenderContribution();
const defaultImageBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultSymbolRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb) {
    const parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const {
        outerBorder: outerBorder,
        innerBorder: innerBorder
      } = symbol.attribute,
      doOuterBorder = outerBorder && !1 !== outerBorder.visible,
      doInnerBorder = innerBorder && !1 !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const {
        size = symbolAttribute.size,
        opacity = symbolAttribute.opacity,
        x: originX = symbolAttribute.x,
        y: originY = symbolAttribute.y,
        scaleX = symbolAttribute.scaleX,
        scaleY = symbolAttribute.scaleY,
        keepStrokeScale = symbolAttribute.keepStrokeScale
      } = symbol.attribute,
      renderBorder = (borderStyle, key) => {
        const doStroke = !(!borderStyle || !borderStyle.stroke),
          {
            distance = symbolAttribute[key].distance
          } = borderStyle,
          d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
          sign = "outerBorder" === key ? 1 : -1;
        if (context.beginPath(), !1 === parsedPath.drawOffset(context, size, x, y, sign * d) && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), strokeCb) strokeCb(context, borderStyle, symbolAttribute[key]);else if (doStroke) {
          const lastOpacity = symbolAttribute[key].opacity;
          symbolAttribute[key].opacity = opacity, context.setStrokeStyle(symbol, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute[key]), symbolAttribute[key].opacity = lastOpacity, context.stroke();
        }
      };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
  }
}
class DefaultSymbolClipRangeStrokeRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    const {
        clipRange = graphicAttribute.clipRange,
        x: originX = graphicAttribute.x,
        y: originY = graphicAttribute.y,
        z = graphicAttribute.z,
        size = graphicAttribute.size,
        scaleX = graphicAttribute.scaleX,
        scaleY = graphicAttribute.scaleY
      } = graphic.attribute,
      parsedPath = graphic.getParsedPath();
    if (!(parsedPath && clipRange < 1 && clipRange > 0)) return;
    context.beginPath(), parsedPath.drawWithClipRange && parsedPath.drawWithClipRange(context, size, x, y, clipRange, z, (p, a) => {
      var _a, _b, _c, _d;
      if (graphic._parsedPath.svgCache) {
        const obj = Object.assign({}, a);
        obj.fill = null !== (_a = a.fill) && void 0 !== _a ? _a : graphic.attribute.fill, obj.opacity = null !== (_b = a.opacity) && void 0 !== _b ? _b : graphic.attribute.opacity, obj.fillOpacity = graphic.attribute.fillOpacity, obj.stroke = null !== (_c = a.stroke) && void 0 !== _c ? _c : graphic.attribute.stroke, obj.lineWidth = null !== (_d = a.lineWidth) && void 0 !== _d ? _d : graphic.attribute.lineWidth, a = obj;
      }
      a.stroke && (strokeCb ? strokeCb(context, graphic.attribute, graphicAttribute) : sVisible && (context.setStrokeStyle(graphic, a, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute), context.stroke()));
    }), doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, graphic.attribute, graphicAttribute) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute), context.stroke()));
  }
}
const defaultSymbolRenderContribution = new DefaultSymbolRenderContribution();
const defaultSymbolClipRangeStrokeRenderContribution = new DefaultSymbolClipRangeStrokeRenderContribution();
const defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultSymbolBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultAreaTextureRenderContribution extends DefaultBaseTextureRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a, _b, _c, _d;
    this.textureMap || this.initTextureMap(context, graphic.stage);
    const {
        attribute = graphic.attribute
      } = options || {},
      {
        texture = null !== (_a = graphic.attribute.texture) && void 0 !== _a ? _a : getAttributeFromDefaultAttrList(graphicAttribute, "texture"),
        textureColor = null !== (_b = graphic.attribute.textureColor) && void 0 !== _b ? _b : getAttributeFromDefaultAttrList(graphicAttribute, "textureColor"),
        textureSize = null !== (_c = graphic.attribute.textureSize) && void 0 !== _c ? _c : getAttributeFromDefaultAttrList(graphicAttribute, "textureSize"),
        texturePadding = null !== (_d = graphic.attribute.texturePadding) && void 0 !== _d ? _d : getAttributeFromDefaultAttrList(graphicAttribute, "texturePadding")
      } = attribute;
    texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
  }
}

const result = {
  x: 0,
  y: 0,
  z: 0,
  lastModelMatrix: null
};
class BaseRender {
  init(contributions) {
    contributions && (this._renderContribitions = contributions.getContributions()), this._renderContribitions || (this._renderContribitions = []), this.builtinContributions || (this.builtinContributions = []), this.builtinContributions.push(defaultBaseClipRenderBeforeContribution), this.builtinContributions.push(defaultBaseClipRenderAfterContribution), this.builtinContributions.forEach(item => this._renderContribitions.push(item)), this._renderContribitions.length && (this._renderContribitions.sort((a, b) => b.order - a.order), this._beforeRenderContribitions = this._renderContribitions.filter(c => c.time === BaseRenderContributionTime.beforeFillStroke), this._afterRenderContribitions = this._renderContribitions.filter(c => c.time === BaseRenderContributionTime.afterFillStroke));
  }
  reInit() {
    this.init(this.graphicRenderContributions);
  }
  beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params) {
    this._beforeRenderContribitions && this._beforeRenderContribitions.forEach(c => {
      if (c.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
        if (!(Array.isArray(c.supportedAppName) ? c.supportedAppName : [c.supportedAppName]).includes(graphic.stage.params.context.appName)) return;
      }
      c.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params);
    });
  }
  afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params) {
    this._afterRenderContribitions && this._afterRenderContribitions.forEach(c => {
      if (c.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
        if (!(Array.isArray(c.supportedAppName) ? c.supportedAppName : [c.supportedAppName]).includes(graphic.stage.params.context.appName)) return;
      }
      c.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params);
    });
  }
  drawPathProxy(graphic, context, x, y, drawContext, params, fillCb, strokeCb) {
    if (!graphic.pathProxy) return !1;
    const themeAttributes = getTheme(graphic, null == params ? void 0 : params.theme)[graphic.type.replace("3d", "")],
      {
        fill = themeAttributes.fill,
        stroke = themeAttributes.stroke,
        opacity = themeAttributes.opacity,
        fillOpacity = themeAttributes.fillOpacity,
        lineWidth = themeAttributes.lineWidth,
        strokeOpacity = themeAttributes.strokeOpacity,
        visible = themeAttributes.visible,
        x: originX = themeAttributes.x,
        y: originY = themeAttributes.y
      } = graphic.attribute,
      fVisible = fillVisible(opacity, fillOpacity, fill),
      sVisible = strokeVisible(opacity, strokeOpacity),
      doFill = runFill(fill),
      doStroke = runStroke(stroke, lineWidth);
    if (!visible) return !0;
    if (!doFill && !doStroke) return !0;
    if (!(fVisible || sVisible || fillCb || strokeCb)) return !0;
    context.beginPath();
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    return renderCommandList(path.commandList, context, x, y), context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes), this.beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb), doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.fill())), this.afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb), !0;
  }
  valid(graphic, defaultAttribute, fillCb, strokeCb) {
    const {
        fill = defaultAttribute.fill,
        background: background,
        stroke = defaultAttribute.stroke,
        opacity = defaultAttribute.opacity,
        fillOpacity = defaultAttribute.fillOpacity,
        lineWidth = defaultAttribute.lineWidth,
        strokeOpacity = defaultAttribute.strokeOpacity,
        visible = defaultAttribute.visible
      } = graphic.attribute,
      fVisible = fillVisible(opacity, fillOpacity, fill),
      sVisible = strokeVisible(opacity, strokeOpacity),
      doFill = runFill(fill, background),
      doStroke = runStroke(stroke, lineWidth);
    return !(!graphic.valid || !visible) && !(!doFill && !doStroke) && !!(fVisible || sVisible || fillCb || strokeCb || background) && {
      fVisible: fVisible,
      sVisible: sVisible,
      doFill: doFill,
      doStroke: doStroke
    };
  }
  transform(graphic, graphicAttribute, context, use3dMatrixIn3dMode = !1) {
    const {
        x = graphicAttribute.x,
        y = graphicAttribute.y,
        z = graphicAttribute.z,
        scaleX = graphicAttribute.scaleX,
        scaleY = graphicAttribute.scaleY,
        angle = graphicAttribute.angle,
        postMatrix: postMatrix
      } = graphic.attribute,
      lastModelMatrix = context.modelMatrix,
      camera = context.camera;
    result.x = x, result.y = y, result.z = z, result.lastModelMatrix = lastModelMatrix;
    const shouldTransform3d = camera && (use3dMatrixIn3dMode || shouldUseMat4(graphic)),
      onlyTranslate = shouldTransform3d ? graphic.transMatrix.onlyTranslate() && !postMatrix : 1 === scaleX && 1 === scaleY && 0 === angle && !postMatrix;
    if (shouldTransform3d) {
      const nextModelMatrix = mat4Allocate.allocate(),
        modelMatrix = mat4Allocate.allocate();
      getModelMatrix(modelMatrix, graphic, graphicAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), result.x = 0, result.y = 0, result.z = 0, context.modelMatrix = nextModelMatrix, context.setTransform(1, 0, 0, 1, 0, 0, !0), mat4Allocate.free(modelMatrix);
    }
    if (onlyTranslate && !lastModelMatrix) {
      const point = graphic.getOffsetXY(graphicAttribute);
      result.x += point.x, result.y += point.y, result.z = z, context.setTransformForCurrent();
    } else if (shouldTransform3d) result.x = 0, result.y = 0, result.z = 0, context.setTransform(1, 0, 0, 1, 0, 0, !0);else if (camera && context.project) {
      const point = graphic.getOffsetXY(graphicAttribute);
      result.x += point.x, result.y += point.y, this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle);
    } else context.transformFromMatrix(graphic.transMatrix, !0), result.x = 0, result.y = 0, result.z = 0;
    return result;
  }
  transformUseContext2d(graphic, graphicAttribute, z, context) {
    const camera = context.camera;
    if (this.camera = camera, camera) {
      const bounds = graphic.AABBBounds,
        width = bounds.x2 - bounds.x1,
        height = bounds.y2 - bounds.y1,
        p1 = context.project(0, 0, z),
        p2 = context.project(width, 0, z),
        p3 = context.project(width, height, z),
        _p1 = {
          x: 0,
          y: 0
        },
        _p2 = {
          x: width,
          y: 0
        },
        _p3 = {
          x: width,
          y: height
        };
      context.camera = null;
      const denom = 1 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y),
        m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom,
        m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom,
        m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom,
        m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom,
        dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) + _p1.y * (_p2.x * p3.x - _p3.x * p2.x) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) * denom,
        dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) + _p1.y * (_p2.x * p3.y - _p3.x * p2.y) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) * denom;
      context.setTransform(m11, m12, m21, m22, dx, dy, !0);
    }
  }
  restoreTransformUseContext2d(graphic, graphicAttribute, z, context) {
    this.camera && (context.camera = this.camera);
  }
  transformWithoutTranslate(context, x, y, z, scaleX, scaleY, angle) {
    const p = context.project(x, y, z);
    context.translate(p.x, p.y, !1), context.scale(scaleX, scaleY, !1), context.rotate(angle, !1), context.translate(-p.x, -p.y, !1), context.setTransformForCurrent();
  }
  _draw(graphic, defaultAttr, computed3dMatrix, drawContext, params, themeAttribute) {
    const {
      context: context
    } = drawContext;
    if (!context) return;
    const {
      renderable: renderable
    } = graphic.attribute;
    if (!1 === renderable) return;
    context.highPerformanceSave();
    const data = this.transform(graphic, defaultAttr, context, computed3dMatrix),
      {
        x: x,
        y: y,
        z: z,
        lastModelMatrix: lastModelMatrix
      } = data;
    this.z = z, this.drawPathProxy(graphic, context, x, y, drawContext, params) || (this.drawShape(graphic, context, x, y, drawContext, params, null, null, themeAttribute), this.z = 0, context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();
  }
}

var __decorate$G = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$z = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$w = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasArcRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = ARC_NUMBER_TYPE, this.builtinContributions = [defaultArcRenderContribution, defaultArcBackgroundRenderContribution, defaultArcTextureRenderContribution], this.init(graphicRenderContributions);
  }
  drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {
    const capAngle = _ea - _sa,
      data = arc.getParsedAngle(),
      startAngle = data.startAngle;
    let endAngle = data.endAngle;
    endAngle = _ea;
    abs(endAngle - startAngle);
    const clockwise = endAngle > startAngle;
    let collapsedToLine = !1;
    if (outerRadius < innerRadius) {
      const temp = outerRadius;
      outerRadius = innerRadius, innerRadius = temp;
    }
    const {
      outerDeltaAngle: outerDeltaAngle,
      xors: xors,
      yors: yors,
      xirs: xirs,
      yirs: yirs,
      limitedOcr: limitedOcr,
      outerCornerRadiusStart: outerCornerRadiusStart,
      outerCornerRadiusEnd: outerCornerRadiusEnd,
      maxOuterCornerRadius: maxOuterCornerRadius,
      xore: xore,
      yore: yore,
      xire: xire,
      yire: yire,
      limitedIcr: limitedIcr,
      innerDeltaAngle: innerDeltaAngle,
      innerStartAngle: innerStartAngle,
      innerCornerRadiusStart: innerCornerRadiusStart,
      innerCornerRadiusEnd: innerCornerRadiusEnd,
      maxInnerCornerRadius: maxInnerCornerRadius
    } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
    if (limitedOcr > epsilon) {
      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr),
        cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr),
        t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)),
        t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
      if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);else {
        const a1 = endAngle - capAngle - .03,
          a2 = atan2(t1.y11, t1.x11);
        context.arc(cx, cy, outerRadius, a1, a2, !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
      }
    } else context.moveTo(cx + xors, cy + yors);
    if (!(innerRadius > epsilon) || innerDeltaAngle < .001) context.lineTo(cx + xire, cy + yire), collapsedToLine = !0;else if (limitedIcr > epsilon) {
      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr),
        cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr),
        t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)),
        t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
      if (context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
        const arcEndAngle = atan2(t1.y01, t1.x01);
        context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);
      } else {
        cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
        const a1 = atan2(t0.cy + t0.y11, t0.cx + t0.x11),
          a2 = endAngle - capAngle - .03;
        context.arc(cx, cy, innerRadius, a1, a2, clockwise);
      }
    } else context.lineTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
    return collapsedToLine;
  }
  drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb, arcAttribute) {
    arcAttribute = null != arcAttribute ? arcAttribute : getTheme(arc, null == params ? void 0 : params.theme).arc;
    const {
        fill = arcAttribute.fill,
        stroke = arcAttribute.stroke,
        x: originX = arcAttribute.x,
        y: originY = arcAttribute.y,
        fillStrokeOrder = arcAttribute.fillStrokeOrder
      } = arc.attribute,
      data = this.valid(arc, arcAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
        fVisible: fVisible,
        sVisible: sVisible,
        doFill: doFill,
        doStroke: doStroke
      } = data,
      {
        outerPadding = arcAttribute.outerPadding,
        innerPadding = arcAttribute.innerPadding,
        cap = arcAttribute.cap,
        forceShowCap = arcAttribute.forceShowCap
      } = arc.attribute;
    let {
      outerRadius = arcAttribute.outerRadius,
      innerRadius = arcAttribute.innerRadius
    } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    let conicalOffset = 0;
    const tempChangeConicalColor = (isBoolean(cap) && cap || cap[0]) && "conical" === fill.gradient;
    if (tempChangeConicalColor) {
      const {
        sc: sc,
        startAngle: startAngle,
        endAngle: endAngle
      } = arc.getParsedAngle();
      abs(endAngle - startAngle) < pi2 - epsilon && (conicalOffset = sc || 0, fill.startAngle -= conicalOffset, fill.endAngle -= conicalOffset);
    }
    let beforeRenderContribitionsRuned = !1;
    const {
      isFullStroke: isFullStroke,
      stroke: arrayStroke
    } = parseStroke(stroke);
    if ((doFill || isFullStroke) && (context.beginPath(), drawArcPath(arc, context, x, y, outerRadius, innerRadius), beforeRenderContribitionsRuned = !0, context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), fillStrokeOrder ? (this._runStroke(arc, context, x, y, arcAttribute, doStroke, isFullStroke, sVisible, strokeCb), this._runFill(arc, context, x, y, arcAttribute, doFill, fVisible, originX, originY, fillCb)) : (this._runFill(arc, context, x, y, arcAttribute, doFill, fVisible, originX, originY, fillCb), this._runStroke(arc, context, x, y, arcAttribute, doStroke, isFullStroke, sVisible, strokeCb))), !isFullStroke && doStroke) {
      context.beginPath();
      drawArcPath(arc, context, x, y, outerRadius, innerRadius, arrayStroke);
      beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke());
    }
    if ((isBoolean(cap) && cap || cap[1]) && forceShowCap) {
      const {
        startAngle: sa,
        endAngle: ea
      } = arc.getParsedAngle();
      if (abs(ea - sa) >= pi2 - epsilon) {
        context.beginPath();
        const capAngle = Math.abs(outerRadius - innerRadius) / 2 / outerRadius,
          {
            endAngle = arcAttribute.endAngle,
            fill = arcAttribute.fill
          } = arc.attribute,
          startAngle = endAngle;
        this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, startAngle, startAngle + capAngle), beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
        const _runFill = () => {
            if (doFill) {
              const color = fill;
              if ("conical" === color.gradient) {
                const lastColor = getConicGradientAt(0, 0, endAngle, color);
                fillCb || fillVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = lastColor, context.fill());
              }
            }
          },
          _runStroke = () => {
            doStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()));
          };
        _runFill(), _runStroke();
      }
    }
    this.afterRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), tempChangeConicalColor && (fill.startAngle += conicalOffset, fill.endAngle += conicalOffset);
  }
  _runFill(arc, context, x, y, arcAttribute, doFill, fVisible, originX, originY, fillCb) {
    doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.fill()));
  }
  _runStroke(arc, context, x, y, arcAttribute, doStroke, isFullStroke, sVisible, strokeCb) {
    doStroke && isFullStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()));
  }
  draw(arc, renderService, drawContext, params) {
    const arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc;
    this._draw(arc, arcAttribute, !1, drawContext, params, arcAttribute);
  }
};
DefaultCanvasArcRender = __decorate$G([injectable(), __param$w(0, inject(ContributionProvider)), __param$w(0, named(ArcRenderContribution)), __metadata$z("design:paramtypes", [Object])], DefaultCanvasArcRender);

var __decorate$F = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$y = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$v = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasCircleRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = CIRCLE_NUMBER_TYPE, this.builtinContributions = [defaultCircleRenderContribution, defaultCircleBackgroundRenderContribution, defaultCircleTextureRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(circle, context, x, y, drawContext, params, fillCb, strokeCb) {
    const circleAttribute = getTheme(circle, null == params ? void 0 : params.theme).circle,
      {
        radius = circleAttribute.radius,
        startAngle = circleAttribute.startAngle,
        endAngle = circleAttribute.endAngle,
        x: originX = circleAttribute.x,
        y: originY = circleAttribute.y,
        fillStrokeOrder = circleAttribute.fillStrokeOrder
      } = circle.attribute,
      data = this.valid(circle, circleAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
      fVisible: fVisible,
      sVisible: sVisible,
      doFill: doFill,
      doStroke: doStroke
    } = data;
    context.beginPath(), context.arc(x, y, radius, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle, circle.attribute, circleAttribute), this.beforeRenderStep(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
        doFill && (fillCb ? fillCb(context, circle.attribute, circleAttribute) : fVisible && (context.setCommonStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute), context.fill()));
      },
      _runStroke = () => {
        doStroke && (strokeCb ? strokeCb(context, circle.attribute, circleAttribute) : sVisible && (context.setStrokeStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute), context.stroke()));
      };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
  }
  draw(circle, renderService, drawContext, params) {
    const circleAttribute = getTheme(circle, null == params ? void 0 : params.theme).circle;
    this._draw(circle, circleAttribute, !1, drawContext, params);
  }
};
DefaultCanvasCircleRender = __decorate$F([injectable(), __param$v(0, inject(ContributionProvider)), __param$v(0, named(CircleRenderContribution)), __metadata$y("design:paramtypes", [Object])], DefaultCanvasCircleRender);

function drawSegItem(ctx, curve, endPercent, params) {
  if (!curve.p1) return;
  const {
    offsetX = 0,
    offsetY = 0,
    offsetZ = 0
  } = params || {};
  if (1 === endPercent) curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ);else if (curve.p2 && curve.p3) {
    const [curve1] = divideCubic(curve, endPercent);
    ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
  } else {
    const p = curve.getPointAt(endPercent);
    ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
  }
}

function drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ) {
  var _a;
  let p0 = curve.p0,
    newDefined0 = defined0;
  if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (p0 = lastCurve.p0), curve.defined) defined0 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), newDefined0 = !defined0);else {
    const {
      originP1: originP1,
      originP2: originP2
    } = curve;
    let validP;
    if (originP1 && !1 !== originP1.defined && !lastCurve ? validP = p0 : originP1 && !1 !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), defined0) {
      newDefined0 = !defined0;
      const x = validP ? validP.x : curve.p0.x,
        y = validP ? validP.y : curve.p0.y;
      path.moveTo(x + offsetX, y + offsetY, offsetZ);
    } else validP && (newDefined0 = !defined0, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
  }
  return newDefined0;
}
function drawSegments(path, segPath, percent, clipRangeByDimension, params) {
  const {
    offsetX = 0,
    offsetY = 0,
    offsetZ = 0,
    mode = "none",
    drawConnect = !1
  } = params || {};
  if (drawConnect && "none" === mode) return;
  if (!segPath) return;
  let needMoveTo = !0;
  const {
    curves: curves
  } = segPath;
  if (percent >= 1) {
    if (drawConnect) {
      let lastCurve,
        defined0 = !0;
      curves.forEach((curve, i) => {
        curve.originP1 !== curve.originP2 ? (defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ), lastCurve = curve) : lastCurve = curve;
      });
    } else curves.forEach(curve => {
      curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
    });
    return;
  }
  if (percent <= 0) return;
  let direction;
  "x" === clipRangeByDimension ? direction = Direction.ROW : "y" === clipRangeByDimension ? direction = Direction.COLUMN : "auto" === clipRangeByDimension && (direction = segPath.direction);
  const totalDrawLength = percent * segPath.tryUpdateLength(direction);
  let drawedLengthUntilLast = 0,
    defined0 = !0,
    lastCurve = null;
  for (let i = 0, n = curves.length; i < n; i++) {
    const curve = curves[i],
      curCurveLength = curve.getLength(direction),
      _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
    if (drawedLengthUntilLast += curCurveLength, _p < 0) break;
    if (drawConnect) {
      if (curve.originP1 === curve.originP2) {
        lastCurve = curve;
        continue;
      }
      defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ), lastCurve = curve;
    } else {
      if (!curve.defined) {
        needMoveTo = !0;
        continue;
      }
      needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, min(_p, 1), params), needMoveTo = !1;
    }
  }
}
function drawIncrementalSegments(path, lastSeg, segments, params) {
  const {
      offsetX = 0,
      offsetY = 0
    } = params || {},
    startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];
  path.moveTo(startP.x + offsetX, startP.y + offsetY), segments.points.forEach(p => {
    !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
  });
}
function drawIncrementalAreaSegments(path, lastSeg, segments, params) {
  const {
      offsetX = 0,
      offsetY = 0
    } = params || {},
    {
      points: points
    } = segments,
    definedPointsList = [];
  for (let i = 0; i < points.length; i++) !1 === points[i].defined && (i);
  definedPointsList.push(points), definedPointsList.forEach((points, i) => {
    var _a, _b, _c, _d;
    const startP = lastSeg && 0 === i ? lastSeg.points[lastSeg.points.length - 1] : points[0];
    path.moveTo(startP.x + offsetX, startP.y + offsetY), points.forEach(p => {
      !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
    });
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      path.lineTo(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
    }
    path.lineTo(null !== (_c = startP.x1) && void 0 !== _c ? _c : startP.x, null !== (_d = startP.y1) && void 0 !== _d ? _d : startP.y), path.closePath();
  });
}

var __decorate$E = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultCanvasLineRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
  }
  draw(line, renderService, drawContext, params) {
    const lineAttribute = getTheme(line, null == params ? void 0 : params.theme).line;
    this._draw(line, lineAttribute, !1, drawContext, params);
  }
  drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
    var _a;
    if (!cache) return;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    drawSegments(context, cache, clipRange, clipRangeByDimension, {
      offsetX: offsetX,
      offsetY: offsetY,
      offsetZ: z
    }), line.cache && !isArray(line.cache) && line.cache.curves.every(c => c.defined) && line.attribute.curveType && line.attribute.curveType.includes("Closed") && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute);
    const {
      x: originX = 0,
      x: originY = 0
    } = attribute;
    return !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke())), !1;
  }
  drawLinearLineHighPerformance(line, context, fill, stroke, fillOpacity, strokeOpacity, offsetX, offsetY, lineAttribute, drawContext, params, fillCb, strokeCb) {
    var _a;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
      {
        points: points
      } = line.attribute,
      startP = points[0];
    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
    for (let i = 1; i < points.length; i++) {
      const p = points[i];
      context.lineTo(p.x + offsetX, p.y + offsetY, z);
    }
    context.setShadowBlendStyle && context.setShadowBlendStyle(line, line.attribute, lineAttribute);
    const {
      x: originX = 0,
      x: originY = 0
    } = line.attribute;
    !1 !== fill && (fillCb ? fillCb(context, line.attribute, lineAttribute) : fillOpacity && (context.setCommonStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, line.attribute, lineAttribute) : strokeOpacity && (context.setStrokeStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.stroke()));
  }
  drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
    const lineAttribute = getTheme(line, null == params ? void 0 : params.theme).line,
      {
        fill = lineAttribute.fill,
        stroke = lineAttribute.stroke,
        fillOpacity = lineAttribute.fillOpacity,
        strokeOpacity = lineAttribute.strokeOpacity,
        segments: segments,
        points: points,
        closePath: closePath,
        curveTension = lineAttribute.curveTension,
        connectedType = lineAttribute.connectedType
      } = line.attribute;
    if (!this.valid(line, lineAttribute, fillCb, strokeCb)) return;
    let {
      curveType = lineAttribute.curveType
    } = line.attribute;
    closePath && "linear" === curveType && (curveType = "linearClosed");
    const {
      clipRange = lineAttribute.clipRange,
      clipRangeByDimension = lineAttribute.clipRangeByDimension
    } = line.attribute;
    if (1 === clipRange && !segments && !points.some(p => !1 === p.defined) && "linear" === curveType) return this.drawLinearLineHighPerformance(line, context, !!fill, !!stroke, fillOpacity, strokeOpacity, x, y, lineAttribute, drawContext, params, fillCb, strokeCb);
    function parsePoint(points, connectedType) {
      return "none" === connectedType ? points : points.filter(p => !1 !== p.defined);
    }
    if (line.shouldUpdateShape()) {
      const {
          points: points,
          segments: segments
        } = line.attribute,
        _points = points;
      if (segments && segments.length) {
        let startPoint, lastSeg;
        if (line.cache = segments.map((seg, index) => {
          if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastSeg = {
            endX: seg.points[0].x,
            endY: seg.points[0].y,
            curves: [{
              defined: !1 !== seg.points[0].defined
            }]
          }), null;
          1 === index ? startPoint = {
            x: lastSeg.endX,
            y: lastSeg.endY,
            defined: lastSeg.curves[lastSeg.curves.length - 1].defined
          } : index > 1 && (startPoint.x = lastSeg.endX, startPoint.y = lastSeg.endY, startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined);
          const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
            startPoint: startPoint,
            curveTension: curveTension
          });
          return lastSeg = data, data;
        }).filter(item => !!item), "linearClosed" === curveType) {
          let startP;
          for (let i = 0; i < line.cache.length; i++) {
            const cacheItem = line.cache[i];
            for (let i = 0; i < cacheItem.curves.length; i++) if (cacheItem.curves[i].defined) {
              startP = cacheItem.curves[i].p0;
              break;
            }
            if (startP) break;
          }
          line.cache[line.cache.length - 1] && line.cache[line.cache.length - 1].lineTo(startP.x, startP.y, !0);
        }
      } else {
        if (!points || !points.length) return line.cache = null, void line.clearUpdateShapeTag();
        line.cache = calcLineCache(parsePoint(_points, connectedType), curveType, {
          curveTension: curveTension
        });
      }
      line.clearUpdateShapeTag();
    }
    if (Array.isArray(line.cache)) {
      const segments = line.attribute.segments.filter(item => item.points.length);
      if (1 === segments[0].points.length && segments.shift(), 1 === clipRange) {
        let skip = !1;
        line.cache.forEach((cache, index) => {
          skip || (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, segments[index], [lineAttribute, line.attribute], clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb));
        });
      } else {
        const totalLength = line.cache.reduce((l, c) => l + c.getLength(), 0),
          totalDrawLength = clipRange * totalLength;
        let drawedLengthUntilLast = 0,
          skip = !1;
        line.cache.forEach((cache, index) => {
          if (skip) return;
          const curSegLength = cache.getLength(),
            _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, segments[index], [lineAttribute, line.attribute], min(_cr, 1), clipRangeByDimension, x, y, line, fillCb, strokeCb));
        });
      }
    } else this.drawSegmentItem(context, line.cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);
  }
};
DefaultCanvasLineRender = __decorate$E([injectable()], DefaultCanvasLineRender);

function drawAreaSegments(path, segPath, percent, params) {
  var _a;
  const {
    top: top,
    bottom: bottom
  } = segPath;
  if (top.curves.length !== bottom.curves.length) return;
  if (percent >= 1) {
    const topList = [],
      bottomList = [];
    let lastDefined = !0;
    for (let i = 0, n = top.curves.length; i < n; i++) {
      const topCurve = top.curves[i];
      lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), topList.length = 0, bottomList.length = 0) : (topList.push(topCurve), bottomList.push(bottom.curves[n - i - 1])), lastDefined = !lastDefined) : lastDefined && (topList.push(topCurve), bottomList.push(bottom.curves[n - i - 1]));
    }
    return void drawAreaBlock(path, topList, bottomList, params);
  }
  if (percent <= 0) return;
  let {
    direction: direction
  } = params || {};
  const {
      curves: topCurves
    } = top,
    endP = null !== (_a = topCurves[topCurves.length - 1].p3) && void 0 !== _a ? _a : topCurves[topCurves.length - 1].p1,
    xTotalLength = abs(endP.x - topCurves[0].p0.x),
    yTotalLength = abs(endP.y - topCurves[0].p0.y);
  direction = null != direction ? direction : xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN, Number.isFinite(xTotalLength) || (direction = Direction.COLUMN), Number.isFinite(yTotalLength) || (direction = Direction.ROW);
  const totalDrawLength = percent * (direction === Direction.ROW ? xTotalLength : yTotalLength);
  let drawedLengthUntilLast = 0,
    lastDefined = !0;
  const topList = [],
    bottomList = [];
  for (let i = 0, n = top.curves.length; i < n; i++) {
    const topCurve = top.curves[i],
      curCurveLength = topCurve.getLength(direction),
      percent = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
    if (percent < 0) break;
    drawedLengthUntilLast += curCurveLength;
    let tc = null,
      bc = null;
    lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), topList.length = 0, bottomList.length = 0) : (tc = topCurve, bc = bottom.curves[n - i - 1]), lastDefined = !lastDefined) : lastDefined && (tc = topCurve, bc = bottom.curves[n - i - 1]), tc && bc && (percent < 1 && (tc = tc.p2 && tc.p3 ? divideCubic(tc, percent)[0] : divideLinear(tc, percent)[0], bc = bc.p2 && bc.p3 ? divideCubic(bc, 1 - percent)[1] : divideLinear(bc, 1 - percent)[1]), tc.defined = lastDefined, bc.defined = lastDefined, topList.push(tc), bottomList.push(bc)), tc = null, bc = null;
  }
  drawAreaBlock(path, topList, bottomList, params);
}
function drawAreaBlock(path, topList, bottomList, params) {
  const {
    offsetX = 0,
    offsetY = 0,
    offsetZ = 0
  } = params || {};
  let needMoveTo = !0;
  topList.forEach(curve => {
    curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
  }), needMoveTo = !0;
  for (let i = bottomList.length - 1; i >= 0; i--) {
    const curve = bottomList[i];
    curve.defined ? (needMoveTo && path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
  }
  path.closePath();
}

const defaultAreaTextureRenderContribution = new DefaultAreaTextureRenderContribution();
const defaultAreaBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

var __decorate$D = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$x = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$u = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasAreaRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = AREA_NUMBER_TYPE, this.builtinContributions = [defaultAreaTextureRenderContribution, defaultAreaBackgroundRenderContribution], this.init(graphicRenderContributions);
  }
  drawLinearAreaHighPerformance(area, context, fill, stroke, fillOpacity, strokeOpacity, offsetX, offsetY, areaAttribute, drawContext, params, fillCb, strokeCb) {
    var _a, _b, _c;
    const {
      points: points
    } = area.attribute;
    if (points.length < 2) return;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
      startP = points[0];
    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
    for (let i = 1; i < points.length; i++) {
      const p = points[i];
      context.lineTo(p.x + offsetX, p.y + offsetY, z);
    }
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      context.lineTo((null !== (_b = p.x1) && void 0 !== _b ? _b : p.x) + offsetX, (null !== (_c = p.y1) && void 0 !== _c ? _c : p.y) + offsetY, z);
    }
    context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(area, area.attribute, areaAttribute), this.beforeRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, areaAttribute, drawContext, fillCb, null, {
      attribute: area.attribute
    });
    const {
      x: originX = 0,
      x: originY = 0
    } = area.attribute;
    !1 !== fill && (fillCb ? fillCb(context, area.attribute, areaAttribute) : fillOpacity && (context.setCommonStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.fill())), this.afterRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, areaAttribute, drawContext, fillCb, null, {
      attribute: area.attribute
    }), (() => {
      var _a, _b;
      if (stroke) {
        const {
          stroke = areaAttribute && areaAttribute.stroke
        } = area.attribute;
        if (isArray(stroke) && (stroke[0] || stroke[2]) && !1 === stroke[1]) if (context.beginPath(), stroke[0]) {
          context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
          for (let i = 1; i < points.length; i++) {
            const p = points[i];
            context.lineTo(p.x + offsetX, p.y + offsetY, z);
          }
        } else if (stroke[2]) {
          const endP = points[points.length - 1];
          context.moveTo(endP.x + offsetX, endP.y + offsetY, z);
          for (let i = points.length - 2; i >= 0; i--) {
            const p = points[i];
            context.lineTo((null !== (_a = p.x1) && void 0 !== _a ? _a : p.x) + offsetX, (null !== (_b = p.y1) && void 0 !== _b ? _b : p.y) + offsetY, z);
          }
        }
        strokeCb ? strokeCb(context, area.attribute, areaAttribute) : (context.setStrokeStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.stroke());
      }
    })();
  }
  drawShape(area, context, x, y, drawContext, params, fillCb, strokeCb) {
    var _a, _b, _c, _d, _e, _f;
    const areaAttribute = getTheme(area, null == params ? void 0 : params.theme).area,
      {
        fill = areaAttribute.fill,
        stroke = areaAttribute.stroke,
        fillOpacity = areaAttribute.fillOpacity,
        z = areaAttribute.z,
        strokeOpacity = areaAttribute.strokeOpacity,
        curveTension = areaAttribute.curveTension,
        connectedType = areaAttribute.connectedType
      } = area.attribute,
      data = this.valid(area, areaAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
        doFill: doFill
      } = data,
      doStroke = data.doStroke && data.sVisible,
      {
        clipRange = areaAttribute.clipRange,
        closePath: closePath,
        points: points,
        segments: segments
      } = area.attribute;
    let {
      curveType = areaAttribute.curveType
    } = area.attribute;
    function parsePoint(points, connectedType) {
      return "connect" !== connectedType ? points : points.filter(p => !1 !== p.defined);
    }
    if (closePath && "linear" === curveType && (curveType = "linearClosed"), 1 === clipRange && !segments && !points.some(p => !1 === p.defined) && "linear" === curveType) return this.drawLinearAreaHighPerformance(area, context, !!fill, doStroke, fillOpacity, strokeOpacity, x, y, areaAttribute, drawContext, params, fillCb, strokeCb);
    if (area.shouldUpdateShape()) {
      if (segments && segments.length) {
        let startPoint, lastTopSeg;
        const topCaches = segments.map((seg, index) => {
          if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastTopSeg = {
            endX: seg.points[0].x,
            endY: seg.points[0].y
          }), null;
          1 === index ? startPoint = {
            x: lastTopSeg.endX,
            y: lastTopSeg.endY
          } : index > 1 && (startPoint.x = lastTopSeg.endX, startPoint.y = lastTopSeg.endY);
          const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
            startPoint: startPoint,
            curveTension: curveTension
          });
          return lastTopSeg = data, data;
        }).filter(item => !!item);
        let lastBottomSeg;
        const bottomCaches = [];
        for (let i = segments.length - 1; i >= 0; i--) {
          const points = segments[i].points,
            bottomPoints = [];
          for (let i = points.length - 1; i >= 0; i--) bottomPoints.push({
            x: null !== (_a = points[i].x1) && void 0 !== _a ? _a : points[i].x,
            y: null !== (_b = points[i].y1) && void 0 !== _b ? _b : points[i].y
          });
          if (0 !== i) {
            const lastSegmentPoints = segments[i - 1].points,
              endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];
            endPoint && bottomPoints.push({
              x: null !== (_c = endPoint.x1) && void 0 !== _c ? _c : endPoint.x,
              y: null !== (_d = endPoint.y1) && void 0 !== _d ? _d : endPoint.y
            });
          }
          bottomPoints.length > 1 && (lastBottomSeg = calcLineCache(parsePoint(bottomPoints, connectedType), "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType, {
            curveTension: curveTension
          }), bottomCaches.unshift(lastBottomSeg));
        }
        area.cacheArea = bottomCaches.map((item, index) => ({
          top: topCaches[index],
          bottom: item
        }));
      } else {
        if (!points || !points.length) return area.cacheArea = null, void area.clearUpdateShapeTag();
        {
          const topPoints = parsePoint(points, connectedType),
            bottomPoints = [];
          for (let i = topPoints.length - 1; i >= 0; i--) bottomPoints.push({
            x: null !== (_e = topPoints[i].x1) && void 0 !== _e ? _e : topPoints[i].x,
            y: null !== (_f = topPoints[i].y1) && void 0 !== _f ? _f : topPoints[i].y
          });
          const topCache = calcLineCache(topPoints, curveType, {
              curveTension: curveTension
            }),
            bottomCache = calcLineCache(bottomPoints, "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType, {
              curveTension: curveTension
            });
          area.cacheArea = {
            top: topCache,
            bottom: bottomCache
          };
        }
      }
      area.clearUpdateShapeTag();
    }
    if (Array.isArray(area.cacheArea)) {
      const segments = area.attribute.segments.filter(item => item.points.length);
      if (1 === segments[0].points.length && segments.shift(), 1 === clipRange) {
        let skip = !1;
        area.cacheArea.forEach((cache, index) => {
          skip || (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments[index], [areaAttribute, area.attribute], clipRange, x, y, z, area, drawContext, fillCb, strokeCb));
        });
      } else {
        const totalLength = area.cacheArea.reduce((l, c) => l + c.top.getLength(), 0),
          totalDrawLength = clipRange * totalLength;
        let drawedLengthUntilLast = 0,
          skip = !1;
        area.cacheArea.forEach((cache, index) => {
          if (skip) return;
          const curSegLength = cache.top.getLength(),
            _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments[index], [areaAttribute, area.attribute], min(_cr, 1), x, y, z, area, drawContext, fillCb, strokeCb));
        });
      }
    } else this.drawSegmentItem(context, area.cacheArea, doFill, fillOpacity, doStroke, strokeOpacity, area.attribute, areaAttribute, clipRange, x, y, z, area, drawContext, fillCb, strokeCb);
  }
  draw(area, renderService, drawContext, params) {
    const areaAttribute = getTheme(area, null == params ? void 0 : params.theme).area;
    this._draw(area, areaAttribute, !1, drawContext, params);
  }
  drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb) {
    return this._drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb);
  }
  _drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb) {
    if (!(cache && cache.top && cache.bottom && cache.top.curves && cache.top.curves.length && cache.bottom.curves && cache.bottom.curves.length)) return;
    context.beginPath();
    const {
      points: points,
      segments: segments
    } = area.attribute;
    let endP,
      startP,
      direction = Direction.ROW;
    if (segments) {
      const endSeg = segments[segments.length - 1];
      startP = segments[0].points[0], endP = endSeg.points[endSeg.points.length - 1];
    } else startP = points[0], endP = points[points.length - 1];
    const xTotalLength = abs(endP.x - startP.x),
      yTotalLength = abs(endP.y - startP.y);
    direction = null == endP.x1 ? Direction.ROW : null == endP.y1 ? Direction.COLUMN : Number.isFinite(xTotalLength + yTotalLength) ? xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN : Direction.ROW, drawAreaSegments(context, cache, clipRange, {
      offsetX: offsetX,
      offsetY: offsetY,
      offsetZ: offsetZ,
      direction: direction
    }), this.beforeRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, defaultAttribute, drawContext, fillCb, null, {
      attribute: attribute
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute);
    const {
      x: originX = 0,
      x: originY = 0
    } = attribute;
    return !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), this.afterRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, defaultAttribute, drawContext, fillCb, null, {
      attribute: attribute
    }), (() => {
      if (!1 !== stroke) if (strokeCb) strokeCb(context, attribute, defaultAttribute);else {
        const {
          stroke = defaultAttribute && defaultAttribute[1] && defaultAttribute[1].stroke
        } = attribute;
        isArray(stroke) && (stroke[0] || stroke[2]) && !1 === stroke[1] && (context.beginPath(), drawSegments(context, stroke[0] ? cache.top : cache.bottom, clipRange, direction === Direction.ROW ? "x" : "y", {
          offsetX: offsetX,
          offsetY: offsetY,
          offsetZ: offsetZ
        })), context.setStrokeStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke();
      }
    })(), !1;
  }
};
DefaultCanvasAreaRender = __decorate$D([injectable(), __param$u(0, inject(ContributionProvider)), __param$u(0, named(AreaRenderContribution)), __metadata$x("design:paramtypes", [Object])], DefaultCanvasAreaRender);

const defaultPathTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultPathBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

var __decorate$C = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$w = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$t = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasPathRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = PATH_NUMBER_TYPE, this.builtinContributions = [defaultPathBackgroundRenderContribution, defaultPathTextureRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(path, context, x, y, drawContext, params, fillCb, strokeCb) {
    var _a, _b, _c;
    const pathAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(path, null == params ? void 0 : params.theme).path,
      {
        x: originX = pathAttribute.x,
        y: originY = pathAttribute.y,
        fillStrokeOrder = pathAttribute.fillStrokeOrder
      } = path.attribute,
      z = null !== (_b = this.z) && void 0 !== _b ? _b : 0,
      data = this.valid(path, pathAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
      fVisible: fVisible,
      sVisible: sVisible,
      doFill: doFill,
      doStroke: doStroke
    } = data;
    if (context.beginPath(), path.pathShape) renderCommandList(path.pathShape.commandList, context, x, y, 1, 1, z);else {
      const path2D = null !== (_c = path.attribute.path) && void 0 !== _c ? _c : pathAttribute.path;
      renderCommandList(path2D.commandList, context, x, y, 1, 1, z);
    }
    context.setShadowBlendStyle && context.setShadowBlendStyle(path, path.attribute, pathAttribute), this.beforeRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
    const _runStroke = () => {
        doStroke && (strokeCb ? strokeCb(context, path.attribute, pathAttribute) : sVisible && (context.setStrokeStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.stroke()));
      },
      _runFill = () => {
        doFill && (fillCb ? fillCb(context, path.attribute, pathAttribute) : fVisible && (context.setCommonStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.fill()));
      };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
  }
  draw(path, renderService, drawContext, params) {
    const pathAttribute = getTheme(path, null == params ? void 0 : params.theme).path;
    this.tempTheme = pathAttribute, this._draw(path, pathAttribute, !1, drawContext, params), this.tempTheme = null;
  }
};
DefaultCanvasPathRender = __decorate$C([injectable(), __param$t(0, inject(ContributionProvider)), __param$t(0, named(PathRenderContribution)), __metadata$w("design:paramtypes", [Object])], DefaultCanvasPathRender);

var __decorate$B = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$v = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$s = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasRectRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.type = "rect", this.numberType = RECT_NUMBER_TYPE, this.builtinContributions = [defaultRectRenderContribution, defaultRectBackgroundRenderContribution, defaultRectTextureRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb, rectAttribute) {
    rectAttribute = null != rectAttribute ? rectAttribute : getTheme(rect, null == params ? void 0 : params.theme).rect;
    const {
      fill = rectAttribute.fill,
      background: background,
      stroke = rectAttribute.stroke,
      cornerRadius = rectAttribute.cornerRadius,
      cornerType = rectAttribute.cornerType,
      opacity = rectAttribute.opacity,
      fillOpacity = rectAttribute.fillOpacity,
      lineWidth = rectAttribute.lineWidth,
      strokeOpacity = rectAttribute.strokeOpacity,
      visible = rectAttribute.visible,
      x1: x1,
      y1: y1,
      x: originX = rectAttribute.x,
      y: originY = rectAttribute.y,
      fillStrokeOrder = rectAttribute.fillStrokeOrder,
      drawStrokeWhenZeroWH = rectAttribute.drawStrokeWhenZeroWH
    } = rect.attribute;
    let {
      width: width,
      height: height
    } = rect.attribute;
    width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0;
    const fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill),
      sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height, drawStrokeWhenZeroWH),
      doFill = runFill(fill, background),
      doStroke = runStroke(stroke, lineWidth);
    if (!rect.valid || !visible) return;
    if (!doFill && !doStroke) return;
    if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
    0 === cornerRadius || isArray(cornerRadius) && cornerRadius.every(num => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType));
    const doFillOrStroke = {
      doFill: doFill,
      doStroke: doStroke
    };
    context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), this.beforeRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb, doFillOrStroke), fillStrokeOrder ? (this._runStroke(rect, context, x, y, rectAttribute, doFillOrStroke, sVisible, originX, originY, strokeCb), this._runFill(rect, context, x, y, rectAttribute, doFillOrStroke, fVisible, originX, originY, fillCb)) : (this._runFill(rect, context, x, y, rectAttribute, doFillOrStroke, fVisible, originX, originY, fillCb), this._runStroke(rect, context, x, y, rectAttribute, doFillOrStroke, sVisible, originX, originY, strokeCb)), this.afterRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
  }
  _runFill(rect, context, x, y, rectAttribute, doFillOrStroke, fVisible, originX, originY, fillCb) {
    doFillOrStroke.doFill && (fillCb ? fillCb(context, rect.attribute, rectAttribute) : fVisible && (context.setCommonStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.fill()));
  }
  _runStroke(rect, context, x, y, rectAttribute, doFillOrStroke, sVisible, originX, originY, strokeCb) {
    doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, rect.attribute, rectAttribute) : sVisible && (context.setStrokeStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.stroke()));
  }
  draw(rect, renderService, drawContext, params) {
    const rectAttribute = getTheme(rect, null == params ? void 0 : params.theme).rect;
    this._draw(rect, rectAttribute, !1, drawContext, params, rectAttribute);
  }
};
DefaultCanvasRectRender = __decorate$B([injectable(), __param$s(0, inject(ContributionProvider)), __param$s(0, named(RectRenderContribution)), __metadata$v("design:paramtypes", [Object])], DefaultCanvasRectRender);

var __decorate$A = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$u = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$r = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasSymbolRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = SYMBOL_NUMBER_TYPE, this.builtinContributions = [defaultSymbolRenderContribution, defaultSymbolBackgroundRenderContribution, defaultSymbolTextureRenderContribution, defaultSymbolClipRangeStrokeRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(symbol, context, x, y, drawContext, params, fillCb, strokeCb, symbolAttribute) {
    var _a;
    symbolAttribute = null != symbolAttribute ? symbolAttribute : getTheme(symbol, null == params ? void 0 : params.theme).symbol;
    const {
        size = symbolAttribute.size,
        x: originX = symbolAttribute.x,
        y: originY = symbolAttribute.y,
        scaleX = symbolAttribute.scaleX,
        scaleY = symbolAttribute.scaleY,
        fillStrokeOrder = symbolAttribute.fillStrokeOrder,
        clipRange = symbolAttribute.clipRange
      } = symbol.attribute,
      data = this.valid(symbol, symbolAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
        fVisible: fVisible,
        sVisible: sVisible,
        doFill: doFill,
        doStroke: doStroke
      } = data,
      parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const {
        keepDirIn3d = symbolAttribute.keepDirIn3d
      } = symbol.attribute,
      z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    context.beginPath();
    let _x = x,
      _y = y,
      _z = z;
    const camera = context.camera;
    if (keepDirIn3d && camera && context.project) {
      const p = context.project(x, y, z);
      context.camera = null, isArray(size) ? [size[0] * scaleX, size[1] * scaleY] : size * scaleX, _x = p.x, _y = p.y, _z = void 0;
    }
    !1 === parsedPath.draw(context, size, _x, _y, _z, (p, a) => {
      var _a, _b, _c, _d;
      if (symbol._parsedPath.svgCache) {
        const obj = Object.assign({}, a);
        obj.fill = null !== (_a = a.fill) && void 0 !== _a ? _a : symbol.attribute.fill, obj.opacity = null !== (_b = a.opacity) && void 0 !== _b ? _b : symbol.attribute.opacity, obj.fillOpacity = symbol.attribute.fillOpacity, obj.stroke = null !== (_c = a.stroke) && void 0 !== _c ? _c : symbol.attribute.stroke, obj.lineWidth = null !== (_d = a.lineWidth) && void 0 !== _d ? _d : symbol.attribute.lineWidth, a = obj;
      }
      const _runFill = () => {
          a.fill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : (context.setCommonStyle(symbol, a, originX - x, originY - y, symbolAttribute), context.fill()));
        },
        _runStroke = () => {
          a.stroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && clipRange >= 1 && (context.setStrokeStyle(symbol, a, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
        };
      fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke());
    }) && context.closePath(), context.camera = camera, context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), this.beforeRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb), fillStrokeOrder ? (this._runStroke(symbol, context, x, y, symbolAttribute, doStroke, sVisible, originX, originY, parsedPath, clipRange, scaleX, scaleY, strokeCb), this._runFill(symbol, context, x, y, symbolAttribute, doFill, fVisible, originX, originY, parsedPath, fillCb)) : (this._runFill(symbol, context, x, y, symbolAttribute, doFill, fVisible, originX, originY, parsedPath, fillCb), this._runStroke(symbol, context, x, y, symbolAttribute, doStroke, sVisible, originX, originY, parsedPath, clipRange, scaleX, scaleY, strokeCb)), this.afterRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
  }
  _runFill(symbol, context, x, y, symbolAttribute, doFill, fVisible, originX, originY, parsedPath, fillCb) {
    doFill && !parsedPath.isSvg && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : fVisible && (context.setCommonStyle(symbol, symbol.attribute, originX - x, originY - y, symbolAttribute), context.fill()));
  }
  _runStroke(symbol, context, x, y, symbolAttribute, doStroke, sVisible, originX, originY, parsedPath, clipRange, scaleX, scaleY, strokeCb) {
    doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && clipRange >= 1 && (context.setStrokeStyle(symbol, symbol.attribute, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
  }
  draw(symbol, renderService, drawContext, params) {
    const symbolAttribute = getTheme(symbol, null == params ? void 0 : params.theme).symbol;
    this._draw(symbol, symbolAttribute, !1, drawContext, params);
  }
};
DefaultCanvasSymbolRender = __decorate$A([injectable(), __param$r(0, inject(ContributionProvider)), __param$r(0, named(SymbolRenderContribution)), __metadata$u("design:paramtypes", [Object])], DefaultCanvasSymbolRender);

class DefaultBoundsAllocate {
  constructor() {
    this.pools = [];
    for (let i = 0; i < 10; i++) this.pools.push(new AABBBounds());
  }
  allocate(x1, y1, x2, y2) {
    if (!this.pools.length) return new AABBBounds().setValue(x1, y1, x2, y2);
    const b = this.pools.pop();
    return b.x1 = x1, b.y1 = y1, b.x2 = x2, b.y2 = y2, b;
  }
  allocateByObj(b) {
    if (!this.pools.length) return new AABBBounds(b);
    const _b = this.pools.pop();
    return _b.x1 = b.x1, _b.y1 = b.y1, _b.x2 = b.x2, _b.y2 = b.y2, _b;
  }
  free(b) {
    this.pools.push(b);
  }
  get length() {
    return this.pools.length;
  }
  release(...params) {
    this.pools = [];
  }
}
const boundsAllocate = new DefaultBoundsAllocate();

class DefaultTextBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const {
      backgroundMode = graphicAttribute.backgroundMode,
      backgroundFit = graphicAttribute.backgroundFit,
      backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio
    } = graphic.attribute;
    let matrix,
      {
        background: background
      } = graphic.attribute;
    if (!background) return;
    const restore = () => {
      "richtext" === graphic.type && (context.restore(), context.save(), matrix && context.setTransformFromMatrix(matrix, !0, 1));
    };
    let b;
    "richtext" === graphic.type && (matrix = context.currentMatrix.clone(), context.restore(), context.save(), context.setTransformForCurrent());
    const shouldReCalBounds = isObject(background) && background.background,
      onlyTranslate = graphic.transMatrix.onlyTranslate();
    if (shouldReCalBounds) {
      const _b = graphic.AABBBounds,
        x = (null !== (_a = background.x) && void 0 !== _a ? _a : _b.x1) + (null !== (_c = background.dx) && void 0 !== _c ? _c : 0),
        y = (null !== (_d = background.y) && void 0 !== _d ? _d : _b.y1) + (null !== (_e = background.dy) && void 0 !== _e ? _e : 0),
        w = null !== (_f = background.width) && void 0 !== _f ? _f : _b.width(),
        h = null !== (_g = background.height) && void 0 !== _g ? _g : _b.height();
      if (b = boundsAllocate.allocate(x, y, x + w, y + h), background = background.background, !onlyTranslate) {
        const w = b.width(),
          h = b.height();
        b.set((null !== (_h = background.x) && void 0 !== _h ? _h : 0) + (null !== (_j = background.dx) && void 0 !== _j ? _j : 0), (null !== (_k = background.y) && void 0 !== _k ? _k : 0) + (null !== (_l = background.dy) && void 0 !== _l ? _l : 0), w, h);
      }
    } else b = graphic.AABBBounds, onlyTranslate || (b = getTextBounds(Object.assign(Object.assign({}, graphic.attribute), {
      angle: 0,
      scaleX: 1,
      scaleY: 1,
      x: 0,
      y: 0,
      dx: 0,
      dy: 0
    })).clone());
    if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return void restore();
      context.highPerformanceSave(), onlyTranslate && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), this.doDrawImage(context, res.data, b, {
        backgroundMode: backgroundMode,
        backgroundFit: backgroundFit,
        backgroundKeepAspectRatio: backgroundKeepAspectRatio
      }), context.highPerformanceRestore(), context.setTransformForCurrent();
    } else {
      const {
        backgroundCornerRadius: backgroundCornerRadius
      } = graphic.attribute;
      context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = background, backgroundCornerRadius ? (createRectPath(context, b.x1, b.y1, b.width(), b.height(), backgroundCornerRadius, !0), context.fill()) : context.fillRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore();
    }
    shouldReCalBounds && boundsAllocate.free(b), restore();
  }
}
const defaultTextBackgroundRenderContribution = new DefaultTextBackgroundRenderContribution();

var __decorate$z = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$t = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$q = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasTextRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = TEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(text, context, x, y, drawContext, params, fillCb, strokeCb) {
    var _a, _b, _c;
    const textAttribute = getTheme(text, null == params ? void 0 : params.theme).text,
      {
        text: str,
        underline = textAttribute.underline,
        lineThrough = textAttribute.lineThrough,
        keepDirIn3d = textAttribute.keepDirIn3d,
        direction = textAttribute.direction,
        fontSize = textAttribute.fontSize,
        verticalMode = textAttribute.verticalMode,
        x: originX = textAttribute.x,
        y: originY = textAttribute.y
      } = text.attribute,
      lineHeight = null !== (_a = calculateLineHeight(text.attribute.lineHeight, fontSize)) && void 0 !== _a ? _a : fontSize,
      data = this.valid(text, textAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
        fVisible: fVisible,
        sVisible: sVisible,
        doFill: doFill,
        doStroke: doStroke
      } = data,
      transform3dMatrixToContextMatrix = !keepDirIn3d,
      z = this.z || 0;
    context.beginPath(), context.setShadowBlendStyle && context.setShadowBlendStyle(text, text.attribute, textAttribute), this.beforeRenderStep(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb), transform3dMatrixToContextMatrix && this.transformUseContext2d(text, textAttribute, z, context);
    const drawText = (t, offsetX, offsetY, direction) => {
      let _x = x + offsetX;
      const _y = y + offsetY;
      if (direction) {
        context.highPerformanceSave(), _x += fontSize;
        const matrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0);
        matrix.rotateByCenter(Math.PI / 2, _x, _y), context.transformFromMatrix(matrix, !0), matrixAllocate.free(matrix);
      }
      doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), context.strokeText(t, _x, _y, z))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), context.fillText(t, _x, _y, z))), direction && (context.highPerformanceRestore(), context.setTransformForCurrent());
    };
    if (context.setTextStyleWithoutAlignBaseline(text.attribute, textAttribute, z), "horizontal" === direction) {
      const {
        multilineLayout: multilineLayout
      } = text;
      if (!multilineLayout) return void context.highPerformanceRestore();
      const {
        xOffset: xOffset,
        yOffset: yOffset
      } = multilineLayout.bbox;
      doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), multilineLayout.lines.forEach(line => {
        context.strokeText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z);
      }))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), multilineLayout.lines.forEach(line => {
        context.fillText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z), this.drawUnderLine(underline, lineThrough, text, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, line.descent, (line.descent - line.ascent) / 2, z, textAttribute, context, {
          width: line.width
        });
      })));
    } else {
      let {
        textAlign = textAttribute.textAlign,
        textBaseline = textAttribute.textBaseline
      } = text.attribute;
      if (!verticalMode) {
        const t = textAlign;
        textAlign = null !== (_b = text.getBaselineMapAlign()[textBaseline]) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = text.getAlignMapBaseline()[t]) && void 0 !== _c ? _c : "top";
      }
      text.tryUpdateAABBBounds();
      const cache = text.cache,
        {
          verticalList: verticalList
        } = cache;
      context.textAlign = "left", context.textBaseline = "top";
      const totalHeight = lineHeight * verticalList.length;
      let totalW = 0;
      verticalList.forEach(verticalData => {
        const _w = verticalData.reduce((a, b) => a + (b.width || 0), 0);
        totalW = max(_w, totalW);
      });
      let offsetY = 0,
        offsetX = 0;
      "bottom" === textBaseline ? offsetX = -totalHeight : "middle" === textBaseline && (offsetX = -totalHeight / 2), "center" === textAlign ? offsetY -= totalW / 2 : "right" === textAlign && (offsetY -= totalW), verticalList.forEach((verticalData, i) => {
        const currentW = verticalData.reduce((a, b) => a + (b.width || 0), 0),
          dw = totalW - currentW;
        let currentOffsetY = offsetY;
        "center" === textAlign ? currentOffsetY += dw / 2 : "right" === textAlign && (currentOffsetY += dw), verticalData.forEach(item => {
          const {
            text: text,
            width: width,
            direction: direction
          } = item;
          drawText(text, totalHeight - (i + 1) * lineHeight + offsetX, currentOffsetY, direction), currentOffsetY += width;
        });
      });
    }
    transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text, textAttribute, z, context), this.afterRenderStep(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb);
  }
  draw(text, renderService, drawContext, params) {
    const textAttribute = getTheme(text, null == params ? void 0 : params.theme).text,
      {
        keepDirIn3d = textAttribute.keepDirIn3d
      } = text.attribute,
      computed3dMatrix = !keepDirIn3d;
    this._draw(text, textAttribute, computed3dMatrix, drawContext, params);
  }
  drawUnderLine(underline, lineThrough, text, anchorX, anchorY, offsetUnderLineY, offsetThroughLineY, z, textAttribute, context, multiOption) {
    if (lineThrough + underline <= 0) return;
    const {
        textAlign = textAttribute.textAlign,
        fill = textAttribute.fill,
        opacity = textAttribute.opacity,
        underlineOffset = textAttribute.underlineOffset,
        underlineDash = textAttribute.underlineDash,
        fillOpacity = textAttribute.fillOpacity
      } = text.attribute,
      isMulti = !isNil(multiOption),
      w = isMulti ? multiOption.width : text.clipedWidth,
      offsetX = isMulti ? 0 : textDrawOffsetX(textAlign, w),
      attribute = {
        lineWidth: 0,
        stroke: fill,
        opacity: opacity,
        strokeOpacity: fillOpacity
      };
    if (underline) {
      attribute.lineWidth = underline, context.setStrokeStyle(text, attribute, anchorX, anchorY, textAttribute), underlineDash && context.setLineDash(underlineDash), context.beginPath();
      const dy = anchorY + offsetUnderLineY + underlineOffset;
      context.moveTo(anchorX + offsetX, dy, z), context.lineTo(anchorX + offsetX + w, dy, z), context.stroke();
    }
    if (lineThrough) {
      attribute.lineWidth = lineThrough, context.setStrokeStyle(text, attribute, anchorX, anchorY, textAttribute), context.beginPath();
      const dy = anchorY + offsetThroughLineY;
      context.moveTo(anchorX + offsetX, dy, z), context.lineTo(anchorX + offsetX + w, dy, z), context.stroke();
    }
  }
};
DefaultCanvasTextRender = __decorate$z([injectable(), __param$q(0, inject(ContributionProvider)), __param$q(0, named(TextRenderContribution)), __metadata$t("design:paramtypes", [Object])], DefaultCanvasTextRender);

function drawPolygon(path, points, x, y) {
  if (points && points.length) {
    path.moveTo(points[0].x + x, points[0].y + y);
    for (let i = 1; i < points.length; i++) path.lineTo(points[i].x + x, points[i].y + y);
  }
}
function drawRoundedPolygon(path, points, x, y, cornerRadius, closePath = !0) {
  var _a;
  if (points.length < 3) return void drawPolygon(path, points, x, y);
  let startI = 0,
    endI = points.length - 1;
  closePath || (startI += 1, endI -= 1, path.moveTo(points[0].x + x, points[0].y + y));
  for (let i = startI; i <= endI; i++) {
    const p1 = points[0 === i ? endI : (i - 1) % points.length],
      angularPoint = points[i % points.length],
      p2 = points[(i + 1) % points.length],
      dx1 = angularPoint.x - p1.x,
      dy1 = angularPoint.y - p1.y,
      dx2 = angularPoint.x - p2.x,
      dy2 = angularPoint.y - p2.y,
      angle = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2,
      tan = Math.abs(Math.tan(angle));
    let radius = Array.isArray(cornerRadius) ? null !== (_a = cornerRadius[i % points.length]) && void 0 !== _a ? _a : 0 : cornerRadius,
      segment = radius / tan;
    const length1 = getLength(dx1, dy1),
      length2 = getLength(dx2, dy2),
      length = Math.min(length1, length2);
    segment > length && (segment = length, radius = length * tan);
    const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1),
      p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2),
      dx = 2 * angularPoint.x - p1Cross.x - p2Cross.x,
      dy = 2 * angularPoint.y - p1Cross.y - p2Cross.y,
      L = getLength(dx, dy),
      circlePoint = getProportionPoint(angularPoint, getLength(segment, radius), L, dx, dy);
    let startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);
    const endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);
    let sweepAngle = endAngle - startAngle;
    sweepAngle < 0 && (startAngle = endAngle, sweepAngle = -sweepAngle), sweepAngle > Math.PI && (sweepAngle -= Math.PI), 0 === i ? path.moveTo(p1Cross.x + x, p1Cross.y + y) : path.lineTo(p1Cross.x + x, p1Cross.y + y), sweepAngle && path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius), path.lineTo(p2Cross.x + x, p2Cross.y + y);
  }
  closePath || path.lineTo(points[endI + 1].x + x, points[endI + 1].y + y);
}
function getLength(dx, dy) {
  return Math.sqrt(dx * dx + dy * dy);
}
function getProportionPoint(point, segment, length, dx, dy) {
  const factor = segment / length;
  return {
    x: point.x - dx * factor,
    y: point.y - dy * factor
  };
}

const defaultPolygonTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultPolygonBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

var __decorate$y = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$s = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$p = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasPolygonRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = POLYGON_NUMBER_TYPE, this.builtinContributions = [defaultPolygonBackgroundRenderContribution, defaultPolygonTextureRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(polygon, context, x, y, drawContext, params, fillCb, strokeCb) {
    const polygonAttribute = getTheme(polygon, null == params ? void 0 : params.theme).polygon,
      {
        points = polygonAttribute.points,
        cornerRadius = polygonAttribute.cornerRadius,
        x: originX = polygonAttribute.x,
        y: originY = polygonAttribute.y,
        closePath = polygonAttribute.closePath,
        fillStrokeOrder = polygonAttribute.fillStrokeOrder
      } = polygon.attribute,
      data = this.valid(polygon, polygonAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
      fVisible: fVisible,
      sVisible: sVisible,
      doFill: doFill,
      doStroke: doStroke
    } = data;
    context.beginPath(), cornerRadius <= 0 || isArray(cornerRadius) && cornerRadius.every(num => 0 === num) ? drawPolygon(context.camera ? context : context.nativeContext, points, x, y) : drawRoundedPolygon(context.camera ? context : context.nativeContext, points, x, y, cornerRadius, closePath), closePath && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(polygon, polygon.attribute, polygonAttribute), this.beforeRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
        doFill && (fillCb ? fillCb(context, polygon.attribute, polygonAttribute) : fVisible && (context.setCommonStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.fill()));
      },
      _runStroke = () => {
        doStroke && (strokeCb ? strokeCb(context, polygon.attribute, polygonAttribute) : sVisible && (context.setStrokeStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.stroke()));
      };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
  }
  draw(polygon, renderService, drawContext, params) {
    const polygonAttribute = getTheme(polygon, null == params ? void 0 : params.theme).polygon;
    this._draw(polygon, polygonAttribute, !1, drawContext, params);
  }
};
DefaultCanvasPolygonRender = __decorate$y([injectable(), __param$p(0, inject(ContributionProvider)), __param$p(0, named(PolygonRenderContribution)), __metadata$s("design:paramtypes", [Object])], DefaultCanvasPolygonRender);

var __decorate$x = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$r = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$o = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasGroupRender = class {
  constructor(groupRenderContribitions) {
    this.groupRenderContribitions = groupRenderContribitions, this.numberType = GROUP_NUMBER_TYPE;
  }
  reInit() {
    this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [], this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution);
  }
  drawShape(group, context, x, y, drawContext, params, fillCb, strokeCb, groupAttribute) {
    const {
      clip: clip,
      fill: fill,
      stroke: stroke,
      background: background
    } = group.attribute;
    if (!(clip || fill || stroke || background)) return;
    groupAttribute = null != groupAttribute ? groupAttribute : getTheme(group, null == params ? void 0 : params.theme).group;
    const {
        opacity = groupAttribute.opacity,
        width = groupAttribute.width,
        height = groupAttribute.height,
        fillOpacity = groupAttribute.fillOpacity,
        strokeOpacity = groupAttribute.strokeOpacity,
        cornerRadius = groupAttribute.cornerRadius,
        path = groupAttribute.path,
        lineWidth = groupAttribute.lineWidth,
        visible = groupAttribute.visible,
        fillStrokeOrder = groupAttribute.fillStrokeOrder,
        cornerType = groupAttribute.cornerType,
        x: originX = groupAttribute.x,
        y: originY = groupAttribute.y
      } = group.attribute,
      fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill),
      sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height),
      doFill = runFill(fill, background),
      doStroke = runStroke(stroke, lineWidth);
    if (!group.valid || !visible) return;
    if (!clip) {
      if (!doFill && !doStroke) return;
      if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
    }
    if (path && path.length && drawContext.drawContribution) {
      const disableFill = context.disableFill,
        disableStroke = context.disableStroke,
        disableBeginPath = context.disableBeginPath;
      context.disableFill = !0, context.disableStroke = !0, context.disableBeginPath = !0, path.forEach(g => {
        drawContext.drawContribution.getRenderContribution(g).draw(g, drawContext.renderService, drawContext, params);
      }), context.disableFill = disableFill, context.disableStroke = disableStroke, context.disableBeginPath = disableBeginPath;
    } else 0 === cornerRadius || isArray(cornerRadius) && cornerRadius.every(num => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType));
    this._groupRenderContribitions || (this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [], this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution));
    const doFillOrStroke = {
      doFill: doFill,
      doStroke: doStroke
    };
    context.setShadowBlendStyle && context.setShadowBlendStyle(group, group.attribute, groupAttribute), this._groupRenderContribitions.forEach(c => {
      c.time === BaseRenderContributionTime.beforeFillStroke && c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
    }), clip && context.clip();
    const _runFill = () => {
        doFillOrStroke.doFill && (fillCb ? fillCb(context, group.attribute, groupAttribute) : fVisible && (context.setCommonStyle(group, group.attribute, originX - x, originY - y, groupAttribute), context.fill()));
      },
      _runStroke = () => {
        doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, group.attribute, groupAttribute) : sVisible && (context.setStrokeStyle(group, group.attribute, originX - x, originY - y, groupAttribute), context.stroke()));
      };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this._groupRenderContribitions.forEach(c => {
      c.time === BaseRenderContributionTime.afterFillStroke && c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb);
    });
  }
  draw(group, renderService, drawContext, params) {
    var _a, _b;
    const {
      context: context
    } = drawContext;
    if (!context) return;
    const {
        clip: clip,
        baseOpacity = 1,
        drawMode: drawMode
      } = group.attribute,
      lastNativeContext = context.nativeContext,
      lastNativeCanvas = context.canvas.nativeCanvas;
    if (drawMode > 0) {
      const {
          x: x,
          y: y,
          width: width,
          height: height
        } = group.attribute,
        canvas = context.canvas,
        newCanvas = application.global.createCanvas({
          width: canvas.width,
          height: canvas.height,
          dpr: 1
        }),
        newContext = newCanvas.getContext("2d"),
        transform = context.nativeContext.getTransform();
      newContext.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f), 1 === drawMode && (newContext.save(), newContext.clearRect(0, 0, canvas.width, canvas.height), newContext.beginPath(), newContext.rect(x, y, width, height), newContext.clip(), newContext.drawImage(canvas.nativeCanvas, 0, 0, canvas.width, canvas.height, 0, 0, canvas.displayWidth, canvas.displayHeight), newContext.restore()), context.nativeContext = newContext, canvas.nativeCanvas = newCanvas;
    }
    clip ? context.save() : context.highPerformanceSave();
    const baseGlobalAlpha = context.baseGlobalAlpha;
    context.baseGlobalAlpha *= baseOpacity;
    const lastModelMatrix = context.modelMatrix;
    if (context.camera) {
      const groupAttribute = getTheme(group, null == params ? void 0 : params.theme).group,
        nextModelMatrix = mat4Allocate.allocate(),
        modelMatrix = mat4Allocate.allocate();
      getModelMatrix(modelMatrix, group, groupAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), context.modelMatrix = nextModelMatrix, mat4Allocate.free(modelMatrix), context.setTransform(1, 0, 0, 1, 0, 0, !0);
    } else context.transformFromMatrix(group.transMatrix, !0);
    context.beginPath(), params.skipDraw ? this.drawShape(group, context, 0, 0, drawContext, params, () => !1, () => !1) : this.drawShape(group, context, 0, 0, drawContext, null, null, null);
    const {
      scrollX: scrollX,
      scrollY: scrollY
    } = group.attribute;
    let p;
    if ((scrollX || scrollY) && context.translate(scrollX, scrollY), params && params.renderInGroup && (p = params.renderInGroup(null === (_a = params.renderInGroupParams) || void 0 === _a ? void 0 : _a.skipSort, group, drawContext, null === (_b = params.renderInGroupParams) || void 0 === _b ? void 0 : _b.nextM)), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, context.baseGlobalAlpha = baseGlobalAlpha, drawMode > 0) {
      const {
          x: x,
          y: y,
          width: width,
          height: height
        } = group.attribute,
        newContext = context.nativeContext,
        newCanvas = context.canvas.nativeCanvas;
      lastNativeContext.save(), lastNativeContext.setTransform(context.dpr, 0, 0, context.dpr, 0, 0, !0), 1 === drawMode && newContext.rect(x, y, width, height), lastNativeContext.drawImage(newCanvas, 0, 0, newCanvas.width, newCanvas.height, 0, 0, context.canvas.displayWidth, context.canvas.displayHeight);
      const transform = newContext.getTransform();
      lastNativeContext.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f), context.nativeContext = lastNativeContext, context.canvas.nativeCanvas = lastNativeCanvas, lastNativeContext.restore();
    }
    p && p.then ? p.then(() => {
      clip ? context.restore() : context.highPerformanceRestore();
    }) : clip ? context.restore() : context.highPerformanceRestore();
  }
};
DefaultCanvasGroupRender = __decorate$x([injectable(), __param$o(0, inject(ContributionProvider)), __param$o(0, named(GroupRenderContribution)), __metadata$r("design:paramtypes", [Object])], DefaultCanvasGroupRender);

var __decorate$w = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$q = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$n = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
const repeatStr = ["", "repeat-x", "repeat-y", "repeat"];
let DefaultCanvasImageRender = class extends BaseRender {
  constructor(graphicRenderContributions) {
    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = IMAGE_NUMBER_TYPE, this.builtinContributions = [defaultImageRenderContribution, defaultImageBackgroundRenderContribution], this.init(graphicRenderContributions);
  }
  drawShape(image, context, x, y, drawContext, params, fillCb, strokeCb) {
    const imageAttribute = getTheme(image).image,
      {
        repeatX = imageAttribute.repeatX,
        repeatY = imageAttribute.repeatY,
        x: originX = imageAttribute.x,
        y: originY = imageAttribute.y,
        cornerRadius = imageAttribute.cornerRadius,
        fillStrokeOrder = imageAttribute.fillStrokeOrder,
        cornerType = imageAttribute.cornerType,
        image: url
      } = image.attribute,
      data = this.valid(image, imageAttribute, fillCb);
    if (!data) return;
    const {
      fVisible: fVisible,
      sVisible: sVisible,
      doFill: doFill,
      doStroke: doStroke
    } = data;
    if (!url || !image.resources) return;
    const res = image.resources.get(url);
    if ("success" !== res.state) return;
    const width = image.width,
      height = image.height;
    context.beginPath();
    let needRestore = !1;
    0 === cornerRadius || isArray(cornerRadius) && cornerRadius.every(num => 0 === num) ? context.rect(x, y, width, height) : (createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType), needRestore = !0), context.setShadowBlendStyle && context.setShadowBlendStyle(image, image.attribute, imageAttribute);
    const _runFill = () => {
        if (doFill) if (fillCb) fillCb(context, image.attribute, imageAttribute);else if (fVisible) {
          context.setCommonStyle(image, image.attribute, x, y, imageAttribute);
          let repeat = 0;
          if ("repeat" === repeatX && (repeat |= 1), "repeat" === repeatY && (repeat |= 2), repeat) {
            const pattern = context.createPattern(res.data, repeatStr[repeat]);
            context.fillStyle = pattern, context.translate(x, y, !0), context.fillRect(0, 0, width, height), context.translate(-x, -y, !0);
          } else context.drawImage(res.data, x, y, width, height);
        }
      },
      _runStroke = () => {
        doStroke && (strokeCb ? strokeCb(context, image.attribute, imageAttribute) : sVisible && (context.setStrokeStyle(image, image.attribute, originX - x, originY - y, imageAttribute), context.stroke()));
      };
    fillStrokeOrder ? (_runStroke(), needRestore && (context.save(), context.clip()), this.beforeRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb), _runFill(), needRestore && context.restore()) : (needRestore && (context.save(), context.clip()), this.beforeRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb), _runFill(), needRestore && context.restore(), _runStroke()), this.afterRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb);
  }
  draw(image, renderService, drawContext) {
    const {
      image: url
    } = image.attribute;
    if (!url || !image.resources) return;
    const res = image.resources.get(url);
    if ("loading" === res.state && isString(url)) return void ResourceLoader.improveImageLoading(url);
    if ("success" !== res.state) return;
    const {
      context: context
    } = renderService.drawParams;
    if (!context) return;
    const imageAttribute = getTheme(image).image;
    this._draw(image, imageAttribute, !1, drawContext);
  }
};
DefaultCanvasImageRender = __decorate$w([injectable(), __param$n(0, inject(ContributionProvider)), __param$n(0, named(ImageRenderContribution)), __metadata$q("design:paramtypes", [Object])], DefaultCanvasImageRender);

const IncrementalDrawContribution = Symbol.for("IncrementalDrawContribution");
const ArcRender = Symbol.for("ArcRender");
const AreaRender = Symbol.for("AreaRender");
const CircleRender = Symbol.for("CircleRender");
const GraphicRender = Symbol.for("GraphicRender");
const GroupRender = Symbol.for("GroupRender");
const LineRender = Symbol.for("LineRender");
const PathRender = Symbol.for("PathRender");
const PolygonRender = Symbol.for("PolygonRender");
const RectRender = Symbol.for("RectRender");
const SymbolRender = Symbol.for("SymbolRender");
const TextRender = Symbol.for("TextRender");
const RichTextRender = Symbol.for("RichTextRender");
const ImageRender = Symbol.for("ImageRender");
const DrawContribution = Symbol.for("DrawContribution");

const draw3dItem = (context, graphic, callback, output) => {
  let result,
    isPie = !1,
    is3d = !1;
  if (graphic.forEachChildren(c => (isPie = c.numberType === ARC3D_NUMBER_TYPE, !isPie)), graphic.forEachChildren(c => (is3d = !!c.findFace, !is3d)), isPie) {
    const children = graphic.getChildren(),
      sortedChildren = [...children];
    sortedChildren.sort((a, b) => {
      var _a, _b, _c, _d;
      let angle1 = (null !== (_b = null !== (_a = a.attribute.startAngle) && void 0 !== _a ? _a : 0 + a.attribute.endAngle) && void 0 !== _b ? _b : 0) / 2,
        angle2 = (null !== (_d = null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0 + b.attribute.endAngle) && void 0 !== _d ? _d : 0) / 2;
      for (; angle1 < 0;) angle1 += pi2;
      for (; angle2 < 0;) angle2 += pi2;
      return angle2 - angle1;
    }), sortedChildren.forEach(c => {
      c._next = null, c._prev = null;
    }), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach(c => {
      graphic.appendChild(c);
    }), output.hack_pieFace = "outside", result = callback(isPie, is3d), result && result.graphic || (output.hack_pieFace = "inside", result = callback(isPie, is3d)), result && result.graphic || (output.hack_pieFace = "top", result = callback(isPie, is3d)), graphic.removeAllChild(), children.forEach(c => {
      c._next = null, c._prev = null;
    }), children.forEach(c => {
      graphic.appendChild(c);
    });
  } else if (is3d) {
    const children = graphic.getChildren(),
      zChildren = children.map(g => ({
        ave_z: g.findFace().vertices.map(v => {
          var _a;
          return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
        }).reduce((a, b) => a + b, 0),
        g: g
      }));
    zChildren.sort((a, b) => b.ave_z - a.ave_z), graphic.removeAllChild(), zChildren.forEach(i => {
      i.g._next = null, i.g._prev = null;
    }), graphic.update(), zChildren.forEach(i => {
      graphic.add(i.g);
    }), result = callback(isPie, is3d), graphic.removeAllChild(), children.forEach(g => {
      g._next = null, g._prev = null;
    }), graphic.update(), children.forEach(g => {
      graphic.add(g);
    });
  } else result = callback(isPie, is3d);
  return result;
};

var __decorate$v = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$p = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
const DrawItemInterceptor = Symbol.for("DrawItemInterceptor");
const tempDirtyBounds = new AABBBounds(),
  tempBackupDirtyBounds = new AABBBounds();
class ShadowRootDrawItemInterceptorContribution {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    return null == graphic.attribute.shadowRootIdx && graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx < 0 || (graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx || graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx > 0) && this.drawItem(graphic, renderService, drawContext, drawContribution, params), !1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    return null == graphic.attribute.shadowRootIdx && graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx > 0 || (graphic.attribute.shadowRootIdx < 0 || graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx < 0) && this.drawItem(graphic, renderService, drawContext, drawContribution, params), !1;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params) {
    if (!graphic.shadowRoot) return !1;
    const {
      context: context
    } = drawContext;
    if (context.highPerformanceSave(), context.transformFromMatrix(graphic.transMatrix, !0), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
      tempDirtyBounds.copy(drawContribution.dirtyBounds), tempBackupDirtyBounds.copy(drawContribution.backupDirtyBounds);
      const m = graphic.globalTransMatrix.getInverse();
      drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m), drawContribution.backupDirtyBounds.copy(drawContribution.dirtyBounds);
    }
    return drawContribution.renderGroup(graphic.shadowRoot, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)), context.highPerformanceRestore(), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds && (drawContribution.dirtyBounds.copy(tempDirtyBounds), drawContribution.backupDirtyBounds.copy(tempBackupDirtyBounds)), !0;
  }
}
class DebugDrawItemInterceptorContribution {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    return graphic.attribute._debug_bounds && this.drawItem(graphic, renderService, drawContext, drawContribution, params), !1;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params) {
    if (!graphic.attribute._debug_bounds) return !1;
    const {
      context: context
    } = drawContext;
    context.highPerformanceSave(), graphic.parent && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), graphic.glyphHost && graphic.glyphHost.parent && context.setTransformFromMatrix(graphic.glyphHost.parent.globalTransMatrix, !0);
    const b = graphic.AABBBounds;
    return !0 !== graphic.attribute._debug_bounds && graphic.attribute._debug_bounds(context, graphic), context.strokeRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore(), !0;
  }
}
let CommonDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1, this.interceptors = [new ShadowRootDrawItemInterceptorContribution(), new Canvas3DDrawItemInterceptor(), new InteractiveDrawItemInterceptorContribution(), new DebugDrawItemInterceptorContribution()];
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    if ((!graphic.in3dMode || drawContext.in3dInterceptor) && !graphic.shadowRoot && !graphic.attribute._debug_bounds && !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) return !1;
    for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].afterDrawItem && this.interceptors[i].afterDrawItem(graphic, renderService, drawContext, drawContribution, params)) return !0;
    return !1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    if ((!graphic.in3dMode || drawContext.in3dInterceptor) && !graphic.shadowRoot && !graphic.attribute._debug_bounds && !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) return !1;
    for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].beforeDrawItem && this.interceptors[i].beforeDrawItem(graphic, renderService, drawContext, drawContribution, params)) return !0;
    return !1;
  }
};
CommonDrawItemInterceptorContribution = __decorate$v([injectable(), __metadata$p("design:paramtypes", [])], CommonDrawItemInterceptorContribution);
class InteractiveDrawItemInterceptorContribution {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    return !this.processing && (graphic.baseGraphic ? this.beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params) : this.beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params));
  }
  beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params) {
    let interactiveGraphic = graphic.interactiveGraphic;
    if (graphic.attribute.globalZIndex) {
      interactiveGraphic || (interactiveGraphic = graphic.clone(), graphic.interactiveGraphic = interactiveGraphic, interactiveGraphic.baseGraphic = graphic), interactiveGraphic.setAttributes({
        globalZIndex: 0,
        zIndex: graphic.attribute.globalZIndex
      }, !1, {
        skipUpdateCallback: !0
      }), drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).add(interactiveGraphic);
      }
      return !0;
    }
    if (interactiveGraphic) {
      drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).removeChild(interactiveGraphic);
      }
      graphic.interactiveGraphic = null, interactiveGraphic.baseGraphic = null;
    }
    return !1;
  }
  beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params) {
    const baseGraphic = graphic.baseGraphic;
    let intree = !!baseGraphic.stage,
      _g = baseGraphic.parent;
    for (; intree && _g && _g.stage !== _g;) intree = !!_g.stage, _g = _g.parent;
    if (!intree) {
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).removeChild(graphic);
      }
      return !0;
    }
    if (baseGraphic) {
      this.processing = !0;
      const {
        context: context
      } = drawContext;
      return context.highPerformanceSave(), context.setTransformFromMatrix(baseGraphic.parent.globalTransMatrix, !0), baseGraphic.isContainer ? drawContribution.renderGroup(baseGraphic, drawContext, baseGraphic.parent.globalTransMatrix) : drawContribution.renderItem(baseGraphic, drawContext), context.highPerformanceRestore(), this.processing = !1, !0;
    }
    return !1;
  }
  getShadowRoot(interactiveLayer) {
    var _a;
    let group = interactiveLayer.getElementById("_interactive_group");
    return group || (group = graphicCreator.CreateGraphic("group", {}), group.id = "_interactive_group", interactiveLayer.add(group)), null !== (_a = group.shadowRoot) && void 0 !== _a ? _a : group.attachShadow();
  }
}
class Canvas3DDrawItemInterceptor {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    if (!graphic.in3dMode || drawContext.in3dInterceptor) return !1;
    drawContext.in3dInterceptor = !0;
    const {
      context: context,
      stage: stage
    } = renderService.drawParams;
    context.canvas;
    context.save(), this.initCanvasCtx(context), context.camera = stage.camera;
    const m = context.currentMatrix;
    m.a /= context.dpr, m.b /= context.dpr, m.c /= context.dpr, m.d /= context.dpr, m.e /= context.dpr, m.f /= context.dpr;
    const matrix = mat4Allocate.allocate();
    mat3Tomat4(matrix, m);
    const lastModelMatrix = context.modelMatrix;
    if (lastModelMatrix) {
      if (matrix) {
        const m = mat4Allocate.allocate();
        context.modelMatrix = multiplyMat4Mat4(m, lastModelMatrix, matrix);
      }
    } else context.modelMatrix = matrix;
    return context.setTransform(1, 0, 0, 1, 0, 0, !0), graphic.isContainer ? draw3dItem(context, graphic, (isPie, is3d) => drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix, !isPie && is3d), drawContext) : drawContribution.renderItem(graphic, drawContext), context.camera = null, context.restore(), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, drawContext.in3dInterceptor = !1, !0;
  }
  initCanvasCtx(context) {
    context.setTransformForCurrent();
  }
}

var __decorate$u = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$o = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$m = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
const RenderService = Symbol.for("RenderService");
let DefaultRenderService = class {
  constructor(drawContribution) {
    this.drawContribution = drawContribution;
  }
  prepare(updateBounds) {
    updateBounds && this.renderTreeRoots.forEach(g => {
      this._prepare(g, updateBounds);
    });
  }
  _prepare(g, updateBounds) {
    g.forEachChildren(g => {
      this._prepare(g, updateBounds);
    }), g.update({
      bounds: updateBounds,
      trans: !0
    });
  }
  prepareRenderList() {}
  beforeDraw(params) {}
  draw(params) {
    this.drawContribution.draw(this, Object.assign({}, this.drawParams));
  }
  afterDraw(params) {
    this.drawContribution.afterDraw && this.drawContribution.afterDraw(this, Object.assign({}, this.drawParams));
  }
  reInit() {
    this.drawContribution.reInit();
  }
  render(groups, params) {
    this.renderTreeRoots = groups, this.drawParams = params;
    const updateBounds = params.updateBounds;
    this.prepare(updateBounds), this.prepareRenderList(), this.beforeDraw(params), this.draw(params), this.afterDraw(params), this.drawParams = null;
  }
};
DefaultRenderService = __decorate$u([injectable(), __param$m(0, inject(DrawContribution)), __metadata$o("design:paramtypes", [Object])], DefaultRenderService);

var renderModule$1 = new ContainerModule(bind => {
  bind(RenderService).to(DefaultRenderService);
});

const PickerService = Symbol.for("PickerService");
const GlobalPickerService = Symbol.for("GlobalPickerService");
const PickItemInterceptor = Symbol.for("PickItemInterceptor");
const PickServiceInterceptor = Symbol.for("PickServiceInterceptor");

var __decorate$t = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ShadowPickServiceInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterPickItem(result, pickerService, point, pickParams, params) {
    if (result.graphic) {
      let g = result.graphic;
      for (; g.parent;) g = g.parent;
      g.shadowHost && (result.params = {
        shadowTarget: result.graphic
      }, result.graphic = g.shadowHost);
    }
    return result;
  }
};
ShadowPickServiceInterceptorContribution = __decorate$t([injectable()], ShadowPickServiceInterceptorContribution);
let ShadowRootPickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterPickItem(graphic, pickerService, point, pickParams, params) {
    return graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx ? this._pickItem(graphic, pickerService, point, pickParams, params) : null;
  }
  beforePickItem(graphic, pickerService, point, pickParams, params) {
    return graphic.attribute.shadowRootIdx < 0 ? this._pickItem(graphic, pickerService, point, pickParams, params) : null;
  }
  _pickItem(graphic, pickerService, point, pickParams, params) {
    var _a;
    if (!graphic.shadowRoot) return null;
    const {
      parentMatrix: parentMatrix
    } = params || {};
    if (!parentMatrix) return null;
    const context = pickerService.pickContext;
    context.highPerformanceSave();
    const theme = null === (_a = getTheme(graphic)) || void 0 === _a ? void 0 : _a[graphic.type],
      {
        shadowPickMode = null == theme ? void 0 : theme.shadowPickMode
      } = graphic.attribute,
      g = graphic.shadowRoot,
      currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix),
      newPoint = new Point(currentGroupMatrix.a * point.x + currentGroupMatrix.c * point.y + currentGroupMatrix.e, currentGroupMatrix.b * point.x + currentGroupMatrix.d * point.y + currentGroupMatrix.f),
      result = pickerService.pickGroup(g, newPoint, currentGroupMatrix, pickParams);
    return context.highPerformanceRestore(), !result.graphic && result.group && "full" === shadowPickMode && (result.graphic = result.group), result;
  }
};
ShadowRootPickItemInterceptorContribution = __decorate$t([injectable()], ShadowRootPickItemInterceptorContribution);
let InteractivePickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(graphic, pickerService, point, pickParams, params) {
    const originGraphic = graphic.baseGraphic;
    if (originGraphic && originGraphic.parent) {
      const newPoint = new Point(point.x, point.y),
        context = pickerService.pickContext;
      context.highPerformanceSave();
      const parentMatrix = originGraphic.parent.globalTransMatrix;
      parentMatrix.transformPoint(newPoint, newPoint);
      const result = originGraphic.isContainer ? pickerService.pickGroup(originGraphic, newPoint.clone(), parentMatrix, pickParams) : pickerService.pickItem(originGraphic, newPoint.clone(), parentMatrix, pickParams);
      return context.highPerformanceRestore(), result;
    }
    return null;
  }
};
InteractivePickItemInterceptorContribution = __decorate$t([injectable()], InteractivePickItemInterceptorContribution);
let Canvas3DPickItemInterceptor = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(graphic, pickerService, point, pickParams, params) {
    if (!graphic.in3dMode || pickParams.in3dInterceptor) return null;
    const context = pickerService.pickContext,
      stage = graphic.stage;
    if (!context || !stage) return null;
    if (pickParams.in3dInterceptor = !0, context.save(), this.initCanvasCtx(context), context.camera = stage.camera, graphic.isContainer) {
      const result = draw3dItem(context, graphic, () => pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams), pickParams);
      return context.camera = null, pickParams.in3dInterceptor = !1, context.restore(), result;
    }
    return context.restore(), null;
  }
  initCanvasCtx(context) {
    context.setTransformForCurrent();
  }
};
Canvas3DPickItemInterceptor = __decorate$t([injectable()], Canvas3DPickItemInterceptor);

var pickModule = new ContainerModule((bind, unbind, isBound) => {
  isBound(PickerService) || (bind(GlobalPickerService).toSelf(), bind(PickerService).toService(GlobalPickerService)), bind(Canvas3DPickItemInterceptor).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(Canvas3DPickItemInterceptor), bind(ShadowRootPickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(ShadowRootPickItemInterceptorContribution), bind(InteractivePickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(InteractivePickItemInterceptorContribution), bindContributionProvider(bind, PickItemInterceptor), bind(ShadowPickServiceInterceptorContribution).toSelf().inSingletonScope(), bind(PickServiceInterceptor).toService(ShadowPickServiceInterceptorContribution), bindContributionProvider(bind, PickServiceInterceptor);
});

var graphicModule = new ContainerModule(bind => {
  bind(GraphicService).to(DefaultGraphicService), bind(GraphicCreator$1).toConstantValue(graphicCreator);
});

const AutoEnablePlugins = Symbol.for("AutoEnablePlugins");
const PluginService = Symbol.for("PluginService");

var __decorate$s = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$n = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$l = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultPluginService = class {
  constructor(autoEnablePlugins) {
    this.autoEnablePlugins = autoEnablePlugins, this.onStartupFinishedPlugin = [], this.onRegisterPlugin = [], this.actived = !1;
  }
  active(stage, params) {
    this.stage = stage, this.actived = !0;
    const {
      pluginList: pluginList
    } = params;
    pluginList && container.isBound(AutoEnablePlugins) && this.autoEnablePlugins.getContributions().forEach(p => {
      pluginList.includes(p.name) && this.register(p);
    });
  }
  findPluginsByName(name) {
    const arr = [];
    return this.onStartupFinishedPlugin.forEach(plugin => {
      plugin.name === name && arr.push(plugin);
    }), this.onRegisterPlugin.forEach(plugin => {
      plugin.name === name && arr.push(plugin);
    }), arr;
  }
  register(plugin) {
    "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.push(plugin) : "onRegister" === plugin.activeEvent && (this.onRegisterPlugin.push(plugin), plugin.activate(this));
  }
  unRegister(plugin) {
    "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1) : "onRegister" === plugin.activeEvent && this.onRegisterPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1), plugin.deactivate(this);
  }
  release(...params) {
    this.onStartupFinishedPlugin.forEach(plugin => {
      plugin.deactivate(this);
    }), this.onStartupFinishedPlugin = [], this.onRegisterPlugin.forEach(plugin => {
      plugin.deactivate(this);
    }), this.onRegisterPlugin = [];
  }
};
DefaultPluginService = __decorate$s([injectable(), __param$l(0, inject(ContributionProvider)), __param$l(0, named(AutoEnablePlugins)), __metadata$n("design:paramtypes", [Object])], DefaultPluginService);

var pluginModule = new ContainerModule(bind => {
  bind(PluginService).to(DefaultPluginService), bindContributionProviderNoSingletonScope(bind, AutoEnablePlugins);
});

var envModules = new ContainerModule(bind => {
  bindContributionProvider(bind, EnvContribution);
});

var textMeasureModules = new ContainerModule(bind => {
  bind(TextMeasureContribution).to(DefaultTextMeasureContribution).inSingletonScope(), bindContributionProvider(bind, TextMeasureContribution);
});

var __decorate$r = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$m = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let CanvasLayerHandlerContribution = class {
  constructor() {
    this.type = "static", this.offscreen = !1, this.global = application.global;
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  init(layer, window, params) {
    if (this.layer = layer, this.window = window, params.main) this.main = !0, this.context = window.getContext(), this.canvas = this.context.getCanvas();else {
      let nativeCanvas;
      this.main = !1, params.canvasId && (nativeCanvas = this.global.getElementById(params.canvasId)), nativeCanvas || (nativeCanvas = this.global.createCanvas({
        width: window.width,
        height: window.height
      })), nativeCanvas.style && (nativeCanvas.style["pointer-events"] = "none");
      const windowCanvas = window.getContext().getCanvas().nativeCanvas,
        canvas = wrapCanvas({
          nativeCanvas: nativeCanvas,
          width: window.width,
          height: window.height,
          dpr: window.dpr,
          id: params.canvasId,
          canvasControled: !0,
          container: window.getContainer(),
          x: windowCanvas.offsetLeft,
          y: windowCanvas.offsetTop
        });
      canvas.applyPosition(), this.canvas = canvas, this.context = canvas.getContext();
    }
  }
  resize(w, h) {
    this.canvas.resize(w, h);
  }
  resizeView(w, h) {}
  render(group, params, userParams) {
    var _a;
    if (!this.main) {
      const windowCanvas = this.window.getContext().getCanvas().nativeCanvas;
      !windowCanvas || this.canvas.x === windowCanvas.offsetLeft && this.canvas.y === windowCanvas.offsetTop || (this.canvas.x = windowCanvas.offsetLeft, this.canvas.y = windowCanvas.offsetTop, this.canvas.applyPosition());
    }
    params.renderService.render(group, Object.assign(Object.assign({
      context: this.context,
      clear: null !== (_a = params.background) && void 0 !== _a ? _a : "#ffffff"
    }, params), userParams));
  }
  merge(layerHandlers) {
    layerHandlers.forEach(l => {
      const canvas = l.getContext().canvas.nativeCanvas;
      this.context.drawImage(canvas, 0, 0);
    });
  }
  prepare(dirtyBounds, params) {}
  drawTo(target, group, params) {
    var _a;
    const context = target.getContext();
    params.renderService.render(group, Object.assign(Object.assign({
      context: context
    }, params), {
      clear: params.clear ? null !== (_a = params.background) && void 0 !== _a ? _a : "#fff" : void 0
    }));
  }
  getContext() {
    return this.context;
  }
  release() {
    this.canvas.release();
  }
};
CanvasLayerHandlerContribution = __decorate$r([injectable(), __metadata$m("design:paramtypes", [])], CanvasLayerHandlerContribution);

var layerHandlerModules = new ContainerModule(bind => {
  bind(CanvasLayerHandlerContribution).toSelf(), bind(StaticLayerHandlerContribution).toService(CanvasLayerHandlerContribution);
});

function load$1(container) {
  container.load(envModules), container.load(textMeasureModules), container.load(layerHandlerModules);
}

var __awaiter$2 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function parseChildMap(graphic, defaultZIndex, reverse) {
  const childMap = {},
    zIdxArray = [];
  return graphic.forEachChildren(item => {
    const {
      zIndex = defaultZIndex
    } = item.attribute;
    childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [item], zIdxArray.push(zIndex));
  }, reverse), zIdxArray.sort((a, b) => reverse ? b - a : a - b), {
    childMap: childMap,
    zIdxArray: zIdxArray
  };
}
function foreach(graphic, defaultZIndex, cb, reverse = !1, sort3d = !1) {
  let needSort = !1;
  if (sort3d) needSort = !0;else {
    let lastZIndex;
    graphic.forEachChildren((item, i) => {
      const {
        zIndex = defaultZIndex
      } = item.attribute;
      if (0 === i) lastZIndex = zIndex;else if (lastZIndex !== zIndex) return needSort = !0, !0;
      return !1;
    }, reverse);
  }
  if (needSort) {
    const {
      childMap: childMap,
      zIdxArray: zIdxArray
    } = parseChildMap(graphic, defaultZIndex, reverse);
    let skip = !1;
    for (let i = 0; i < zIdxArray.length && !skip; i++) {
      const children = childMap[zIdxArray[i]];
      sort3d && children.sort((a, b) => {
        var _a, _b;
        return (reverse ? -1 : 1) * ((null !== (_a = b.attribute.z) && void 0 !== _a ? _a : 0) - (null !== (_b = a.attribute.z) && void 0 !== _b ? _b : 0));
      });
      for (let i = 0; i < children.length; i++) if (cb(children[i], i)) {
        skip = !0;
        break;
      }
    }
  } else graphic.forEachChildren(cb, reverse);
}
function foreachAsync(graphic, defaultZIndex, cb, reverse = !1) {
  return __awaiter$2(this, void 0, void 0, function* () {
    yield graphic.forEachChildrenAsync(cb, reverse);
  });
}
function findNextGraphic(graphic, id, defaultZIndex, reverse = !1) {
  let needSort = !1;
  graphic.forEachChildren((item, i) => {
    const {
      zIndex = defaultZIndex
    } = item.attribute;
    if (0 === i) ;else if (undefined !== zIndex) return needSort = !0, !0;
    return !1;
  }, reverse);
  let result = null,
    next = !1;
  if (needSort) {
    const {
      childMap: childMap,
      zIdxArray: zIdxArray
    } = parseChildMap(graphic, defaultZIndex, reverse);
    let skip = !1;
    for (let i = 0; i < zIdxArray.length && !skip; i++) {
      const children = childMap[zIdxArray[i]];
      for (let i = 0; i < children.length; i++) {
        if (next) {
          skip = !0, result = children[i];
          break;
        }
        children[i]._uid !== id || (next = !0);
      }
    }
  } else graphic.forEachChildren(item => next ? (result = item, !0) : (item._uid === id && (next = !0), !1), reverse);
  return result;
}

var __decorate$q = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$l = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$k = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultDrawContribution = class {
  constructor(contributions, drawItemInterceptorContributions) {
    this.contributions = contributions, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this._renderInGroup = (skipSort, group, drawContext, nextM) => {
      var _a;
      skipSort ? group.forEachChildren(item => {
        drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
      }) : foreach(group, DefaultAttribute.zIndex, item => {
        drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
      }, !1, !!(null === (_a = drawContext.context) || void 0 === _a ? void 0 : _a.camera));
    }, this.currentRenderMap = new Map(), this.defaultRenderMap = new Map(), this.styleRenderMap = new Map(), this.dirtyBounds = new Bounds(), this.backupDirtyBounds = new Bounds(), this.global = application.global, this.layerService = application.layerService, isArray(this.contributions) || (this.contributions = [this.contributions]), this.init();
  }
  reInit() {
    this.init(), this.contributions.forEach(item => {
      item.reInit();
    });
  }
  init() {
    this.contributions.forEach(item => {
      if (item.style) {
        const map = this.styleRenderMap.get(item.style) || new Map();
        map.set(item.numberType, item), this.styleRenderMap.set(item.style, map);
      } else this.defaultRenderMap.set(item.numberType, item);
    }), this.InterceptorContributions = this.drawItemInterceptorContributions.getContributions().sort((a, b) => a.order - b.order);
  }
  prepareForDraw(renderService, drawContext) {
    drawContext.updateBounds ? this.useDirtyBounds = !0 : this.useDirtyBounds = !drawContext.stage.params.optimize.disableCheckGraphicWidthOutRange;
  }
  draw(renderService, drawContext) {
    var _a;
    this.prepareForDraw(renderService, drawContext), drawContext.drawContribution = this, this.currentRenderMap = this.styleRenderMap.get(drawContext.renderStyle) || this.defaultRenderMap, this.currentRenderService = renderService;
    const {
      context: context,
      stage: stage,
      viewBox: viewBox,
      transMatrix: transMatrix
    } = drawContext;
    if (!context) return;
    const dirtyBounds = this.dirtyBounds.setValue(0, 0, viewBox.width(), viewBox.height());
    if (stage.dirtyBounds && !stage.dirtyBounds.empty()) {
      const b = getRectIntersect(dirtyBounds, stage.dirtyBounds, !1);
      dirtyBounds.x1 = Math.floor(b.x1), dirtyBounds.y1 = Math.floor(b.y1), dirtyBounds.x2 = Math.ceil(b.x2), dirtyBounds.y2 = Math.ceil(b.y2);
    }
    const d = context.dpr % 1;
    (d || .5 !== d) && (dirtyBounds.x1 = Math.floor(dirtyBounds.x1 * context.dpr) / context.dpr, dirtyBounds.y1 = Math.floor(dirtyBounds.y1 * context.dpr) / context.dpr, dirtyBounds.x2 = Math.ceil(dirtyBounds.x2 * context.dpr) / context.dpr, dirtyBounds.y2 = Math.ceil(dirtyBounds.y2 * context.dpr) / context.dpr), this.backupDirtyBounds.copy(dirtyBounds), context.reset(!1), context.save(), context.setClearMatrix(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), context.clearMatrix(!1), context.translate(viewBox.x1, viewBox.y1, !0), context.beginPath(), context.rect(dirtyBounds.x1, dirtyBounds.y1, dirtyBounds.width(), dirtyBounds.height()), context.clip(), stage.camera && (this.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), this.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0)), this.clearScreen(renderService, context, drawContext), (null === (_a = renderService.drawParams) || void 0 === _a ? void 0 : _a.stage) && renderService.drawParams.stage.hooks.afterClearScreen.call(renderService.drawParams), renderService.renderTreeRoots.sort((a, b) => {
      var _a, _b;
      return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
    }).forEach(group => {
      group.isContainer ? this.renderGroup(group, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)) : this.renderItem(group, drawContext);
    }), context.restore(), context.draw();
  }
  doRegister() {
    throw new Error("暂不支持");
  }
  _findNextGraphic(group) {
    let parent = group.parent,
      id = group._uid;
    for (; parent;) {
      const g = findNextGraphic(parent, id, DefaultAttribute.zIndex);
      if (g) return g;
      id = parent._uid, parent = parent.parent;
    }
    return null;
  }
  renderGroup(group, drawContext, parentMatrix, skipSort) {
    if (drawContext.break || !1 === group.attribute.visibleAll) return;
    if (group.incremental && (null == drawContext.startAtId || drawContext.startAtId === group._uid)) return drawContext.break = !0, void this._increaseRender(group, drawContext);
    if (this.useDirtyBounds && !isRectIntersect(group.AABBBounds, this.dirtyBounds, !1) && "empty" !== group.attribute.boundsMode) return;
    let tempBounds,
      nextM = parentMatrix;
    if (this.useDirtyBounds) {
      tempBounds = boundsAllocate.allocateByObj(this.dirtyBounds);
      const gm = group.transMatrix;
      nextM = matrixAllocate.allocateByObj(parentMatrix).multiply(gm.a, gm.b, gm.c, gm.d, gm.e, gm.f), this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(nextM.getInverse());
    }
    drawContext.isGroupScroll = !(!group.attribute.scrollX && !group.attribute.scrollY), this.renderItem(group, drawContext, {
      renderInGroupParams: {
        skipSort: skipSort,
        nextM: nextM
      },
      renderInGroup: this._renderInGroup
    }), this.useDirtyBounds && (this.dirtyBounds.copy(tempBounds), boundsAllocate.free(tempBounds), matrixAllocate.free(nextM));
  }
  _increaseRender(group, drawContext) {
    const {
        layer: layer,
        stage: stage
      } = drawContext,
      {
        subLayers: subLayers
      } = layer;
    let incrementalLayer = subLayers.get(group._uid);
    incrementalLayer || (incrementalLayer = {
      layer: this.layerService.createLayer(stage),
      zIndex: subLayers.size,
      group: group
    }, subLayers.set(group._uid, incrementalLayer));
    const incrementalContext = incrementalLayer.layer.getNativeHandler().getContext(),
      idc = incrementalLayer.drawContribution || container.get(IncrementalDrawContribution);
    idc.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
      drawContribution: idc,
      clear: "transparent",
      layer: incrementalLayer.layer,
      context: incrementalContext,
      startAtId: group._uid,
      break: !1
    })), incrementalLayer.drawContribution = idc;
    const nextGraphic = this._findNextGraphic(group);
    if (nextGraphic) if (nextGraphic.isContainer && nextGraphic.incremental) this._increaseRender(nextGraphic, drawContext);else {
      let afterLayer = subLayers.get(nextGraphic._uid);
      afterLayer || (afterLayer = {
        layer: this.layerService.createLayer(stage),
        zIndex: subLayers.size
      }, subLayers.set(nextGraphic._uid, afterLayer));
      const afterContext = afterLayer.layer.getNativeHandler().getContext();
      this.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
        drawContribution: idc,
        clear: "transparent",
        layer: afterLayer.layer,
        context: afterContext,
        startAtId: nextGraphic._uid,
        break: !1
      }));
    }
  }
  getRenderContribution(graphic) {
    let renderer;
    return renderer || (renderer = this.selectRenderByNumberType(graphic.numberType, graphic)), renderer || (renderer = this.selectRenderByType(graphic.type)), renderer;
  }
  renderItem(graphic, drawContext, params) {
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.beforeDrawItem && drawContribution.beforeDrawItem(graphic, this.currentRenderService, drawContext, this, params)) return;
    }
    const renderer = this.getRenderContribution(graphic);
    if (!renderer) return;
    let tempBounds,
      retrans = !1;
    if (drawContext.isGroupScroll) {
      const {
        scrollX = 0,
        scrollY = 0
      } = graphic.parent.attribute;
      retrans = !0, this.scrollMatrix || (this.scrollMatrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0)), this.scrollMatrix.translate(-scrollX, -scrollY);
    }
    if (retrans && (tempBounds = this.dirtyBounds.clone().transformWithMatrix(this.scrollMatrix)), this.useDirtyBounds && !graphic.isContainer && "empty" !== graphic.attribute.boundsMode && !isRectIntersect(graphic.AABBBounds, null != tempBounds ? tempBounds : this.dirtyBounds, !1)) {
      if (retrans && graphic.parent) {
        const {
          scrollX = 0,
          scrollY = 0
        } = graphic.parent.attribute;
        this.scrollMatrix && this.scrollMatrix.translate(scrollX, scrollY);
      }
      return;
    }
    const skipDraw = null != drawContext.startAtId && graphic._uid !== drawContext.startAtId;
    if (graphic._uid === drawContext.startAtId && (drawContext.startAtId = null), params && (params.skipDraw = skipDraw), skipDraw ? graphic.isContainer && renderer.draw(graphic, this.currentRenderService, drawContext, params) : renderer.draw(graphic, this.currentRenderService, drawContext, params), retrans && graphic.parent) {
      const {
        scrollX = 0,
        scrollY = 0
      } = graphic.parent.attribute;
      this.scrollMatrix && this.scrollMatrix.translate(scrollX, scrollY);
    }
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.afterDrawItem && drawContribution.afterDrawItem(graphic, this.currentRenderService, drawContext, this)) return;
    }
  }
  selectRenderByType(type) {
    return Logger.getInstance().warn("未知错误，不应该走到这里"), null;
  }
  selectRenderByNumberType(type, graphic) {
    let data;
    if (graphic.attribute.renderStyle) {
      const currentRenderMap = this.styleRenderMap.get(graphic.attribute.renderStyle);
      data = currentRenderMap && currentRenderMap.get(type);
    }
    return data || this.currentRenderMap.get(type) || this.defaultRenderMap.get(type);
  }
  clearScreen(renderService, context, drawContext) {
    var _a, _b, _c;
    const {
        clear: clear,
        viewBox: viewBox
      } = drawContext,
      width = viewBox.width(),
      height = viewBox.height();
    if (clear) {
      context.clearRect(0, 0, width, height), (null === (_a = renderService.drawParams) || void 0 === _a ? void 0 : _a.stage) && renderService.drawParams.stage.hooks.afterClearRect.call(renderService.drawParams);
      const stage = null === (_b = renderService.drawParams) || void 0 === _b ? void 0 : _b.stage;
      if (stage && (context.globalAlpha = null !== (_c = stage.attribute.opacity) && void 0 !== _c ? _c : 1), stage && stage.backgroundImg && stage.resources) {
        const res = stage.resources.get(clear);
        res && "success" === res.state && res.data && context.drawImage(res.data, 0, 0, width, height);
      } else context.fillStyle = createColor(context, clear, {
        AABBBounds: {
          x1: 0,
          y1: 0,
          x2: 0 + width,
          y2: 0 + height
        }
      }, 0, 0), context.fillRect(0, 0, width, height);
    }
  }
  afterDraw(renderService, drawParams) {}
};
DefaultDrawContribution = __decorate$q([injectable(), __param$k(0, multiInject(GraphicRender)), __param$k(1, inject(ContributionProvider)), __param$k(1, named(DrawItemInterceptor)), __metadata$l("design:paramtypes", [Array, Object])], DefaultDrawContribution);

var __decorate$p = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultIncrementalCanvasLineRender = class extends DefaultCanvasLineRender {
  constructor() {
    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
  }
  drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
    if (line.incremental && drawContext.multiGraphicOptions) {
      const {
          startAtIdx: startAtIdx,
          length: length
        } = drawContext.multiGraphicOptions,
        {
          segments = []
        } = line.attribute;
      if (startAtIdx > segments.length) return;
      const lineAttribute = getTheme(line).line,
        {
          fill = lineAttribute.fill,
          stroke = lineAttribute.stroke,
          opacity = lineAttribute.opacity,
          fillOpacity = lineAttribute.fillOpacity,
          strokeOpacity = lineAttribute.strokeOpacity,
          lineWidth = lineAttribute.lineWidth,
          visible = lineAttribute.visible
        } = line.attribute,
        fVisible = fillVisible(opacity, fillOpacity, fill),
        sVisible = strokeVisible(opacity, strokeOpacity),
        doFill = runFill(fill),
        doStroke = runStroke(stroke, lineWidth);
      if (!line.valid || !visible) return;
      if (!doFill && !doStroke) return;
      if (!(fVisible || sVisible || fillCb || strokeCb)) return;
      const {
        context: context
      } = drawContext;
      for (let i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(line, context, segments[i - 1], segments[i], line.attribute.segments[i], [lineAttribute, line.attribute], x, y);
    } else super.drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb);
  }
  drawIncreaseSegment(line, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
    seg && (context.beginPath(), drawIncrementalSegments(context.nativeContext, lastSeg, seg, {
      offsetX: offsetX,
      offsetY: offsetY
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute), context.setStrokeStyle(line, attribute, offsetX, offsetY, defaultAttribute), context.stroke());
  }
};
DefaultIncrementalCanvasLineRender = __decorate$p([injectable()], DefaultIncrementalCanvasLineRender);

var __decorate$o = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultIncrementalCanvasAreaRender = class extends DefaultCanvasAreaRender {
  constructor() {
    super(...arguments), this.numberType = AREA_NUMBER_TYPE;
  }
  drawShape(area, context, x, y, drawContext, params, fillCb) {
    if (area.incremental && drawContext.multiGraphicOptions) {
      const {
          startAtIdx: startAtIdx,
          length: length
        } = drawContext.multiGraphicOptions,
        {
          segments = []
        } = area.attribute;
      if (startAtIdx > segments.length) return;
      const areaAttribute = getTheme(area).area,
        {
          fill = areaAttribute.fill,
          fillOpacity = areaAttribute.fillOpacity,
          opacity = areaAttribute.opacity,
          visible = areaAttribute.visible
        } = area.attribute,
        fVisible = fillVisible(opacity, fillOpacity, fill),
        doFill = runFill(fill);
      if (!area.valid || !visible) return;
      if (!doFill) return;
      if (!fVisible && !fillCb) return;
      for (let i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(area, context, segments[i - 1], segments[i], area.attribute.segments[i], [areaAttribute, area.attribute], x, y);
    } else super.drawShape(area, context, x, y, drawContext, params, fillCb);
  }
  drawIncreaseSegment(area, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
    seg && (context.beginPath(), drawIncrementalAreaSegments(context.camera ? context : context.nativeContext, lastSeg, seg, {
      offsetX: offsetX,
      offsetY: offsetY
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute), context.setCommonStyle(area, attribute, offsetX, offsetY, defaultAttribute), context.fill());
  }
};
DefaultIncrementalCanvasAreaRender = __decorate$o([injectable()], DefaultIncrementalCanvasAreaRender);

var STATUS,
  __decorate$n = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$k = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$j = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  },
  __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        var value;
        result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        })).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
!function (STATUS) {
  STATUS[STATUS.NORMAL = 0] = "NORMAL", STATUS[STATUS.STOP = 1] = "STOP";
}(STATUS || (STATUS = {}));
let DefaultIncrementalDrawContribution = class extends DefaultDrawContribution {
  constructor(contributions, lineRender, areaRender, drawItemInterceptorContributions) {
    super(contributions, drawItemInterceptorContributions), this.contributions = contributions, this.lineRender = lineRender, this.areaRender = areaRender, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.rendering = !1, this.currFrameStartAt = 0, this.currentIdx = 0, this.status = STATUS.NORMAL, this.checkingForDrawPromise = null, this.hooks = {
      completeDraw: new SyncHook([])
    }, this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender), this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
  }
  draw(renderService, drawContext) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (this.checkingForDrawPromise) return;
      this.lastRenderService = renderService, this.lastDrawContext = drawContext, this.checkingForDrawPromise = this.checkForDraw(drawContext);
      const skipDraw = yield this.checkingForDrawPromise;
      if (this.checkingForDrawPromise = null, skipDraw) return;
      this.currentRenderService = renderService;
      const {
        context: context,
        viewBox: viewBox
      } = drawContext;
      context && (context.inuse = !0, context.clearMatrix(), context.setTransformForCurrent(!0), context.save(), drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext), context.translate(viewBox.x1, viewBox.y1, !0), context.save(), renderService.renderTreeRoots.sort((a, b) => {
        var _a, _b;
        return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
      }).forEach(group => {
        this.renderGroup(group, drawContext);
      }), this.hooks.completeDraw.tap("top-draw", () => {
        context.restore(), context.restore(), context.draw(), context.inuse = !1, this.rendering = !1;
      }));
    });
  }
  _increaseRender(group, drawContext) {
    return __awaiter$1(this, void 0, void 0, function* () {
      this.rendering = !0, yield this._renderIncrementalGroup(group, drawContext);
    });
  }
  _renderIncrementalGroup(group, drawContext) {
    return __awaiter$1(this, void 0, void 0, function* () {
      this.count = group.count, yield new Promise(resolve => {
        this.renderItem(group, drawContext, {
          drawingCb: () => __awaiter$1(this, void 0, void 0, function* () {
            if (2 !== group.count) yield foreachAsync(group, DefaultAttribute.zIndex, (item, i) => {
              if (this.status === STATUS.STOP) return !0;
              if (item.isContainer) return !1;
              if (i < this.currentIdx) return !1;
              const frameTail = this.currFrameStartAt + group.incremental;
              return i < frameTail && (this.currentIdx = i + 1, this.renderItem(item, drawContext)), i === frameTail - 1 && (this.currFrameStartAt = this.currentIdx, this.waitToNextFrame());
            }), resolve(!1);else {
              const graphic = group.getChildAt(0);
              if (graphic.incremental && graphic.attribute.segments) for (graphic.incrementalAt || (graphic.incrementalAt = 0); graphic.incrementalAt < graphic.attribute.segments.length;) drawContext.multiGraphicOptions = {
                startAtIdx: graphic.incrementalAt,
                length: graphic.incremental
              }, this.renderItem(graphic, drawContext), graphic.incrementalAt += graphic.incremental, yield this.waitToNextFrame();else this.renderItem(graphic, drawContext);
              resolve(!1);
            }
          })
        });
      }), this.hooks.completeDraw.call();
    });
  }
  waitToNextFrame() {
    return __awaiter$1(this, void 0, void 0, function* () {
      return new Promise(resolve => {
        this.global.getRequestAnimationFrame()(() => {
          resolve(!1);
        });
      });
    });
  }
  checkForDraw(drawContext) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let skip = this.rendering;
      return drawContext.restartIncremental && (skip = !1, yield this.forceStop(), this.resetToInit()), skip;
    });
  }
  forceStop() {
    return __awaiter$1(this, void 0, void 0, function* () {
      this.rendering && (this.status = STATUS.STOP, yield new Promise(resolve => {
        this.hooks.completeDraw.tap("stopCb", () => {
          this.status = STATUS.NORMAL, this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter(item => "stopCb" !== item.name), resolve(!1);
        });
      }));
    });
  }
  resetToInit() {
    this.currFrameStartAt = 0, this.currentIdx = 0;
  }
  renderGroup(group, drawContext) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (!drawContext.break && !1 !== group.attribute.visibleAll) return group.incremental && drawContext.startAtId === group._uid ? (yield this._increaseRender(group, drawContext), void (drawContext.break = !0)) : void (yield new Promise(resolve => {
        this.renderItem(group, drawContext, {
          drawingCb: () => __awaiter$1(this, void 0, void 0, function* () {
            yield foreachAsync(group, DefaultAttribute.zIndex, item => __awaiter$1(this, void 0, void 0, function* () {
              drawContext.break || item.isContainer && (yield this.renderGroup(item, drawContext));
            })), resolve(!1);
          })
        });
      }));
    });
  }
};
DefaultIncrementalDrawContribution = __decorate$n([injectable(), __param$j(0, multiInject(GraphicRender)), __param$j(1, inject(DefaultIncrementalCanvasLineRender)), __param$j(2, inject(DefaultIncrementalCanvasAreaRender)), __param$j(3, inject(ContributionProvider)), __param$j(3, named(DrawItemInterceptor)), __metadata$k("design:paramtypes", [Array, Object, Object, Object])], DefaultIncrementalDrawContribution);

var renderModule = new ContainerModule(bind => {
  bind(DefaultBaseBackgroundRenderContribution).toSelf().inSingletonScope(), bind(DefaultBaseTextureRenderContribution).toSelf().inSingletonScope(), bind(DrawContribution).to(DefaultDrawContribution), bind(IncrementalDrawContribution).to(DefaultIncrementalDrawContribution), bind(GroupRender).to(DefaultCanvasGroupRender).inSingletonScope(), bind(GraphicRender).toService(GroupRender), bindContributionProvider(bind, GroupRenderContribution), bind(DefaultBaseInteractiveRenderContribution).toSelf().inSingletonScope(), bindContributionProvider(bind, InteractiveSubRenderContribution), bindContributionProvider(bind, GraphicRender), bind(CommonDrawItemInterceptorContribution).toSelf().inSingletonScope(), bind(DrawItemInterceptor).toService(CommonDrawItemInterceptorContribution), bindContributionProvider(bind, DrawItemInterceptor);
});

function load(container) {
  container.load(renderModule);
}

function preLoadAllModule() {
  preLoadAllModule.__loaded || (preLoadAllModule.__loaded = !0, container.load(coreModule), container.load(graphicModule), container.load(renderModule$1), container.load(pickModule), container.load(pluginModule), load$1(container), load(container));
}
preLoadAllModule.__loaded = !1, preLoadAllModule();
const vglobal = container.get(VGlobal);
application.global = vglobal;
const graphicUtil = container.get(GraphicUtil);
application.graphicUtil = graphicUtil;
const transformUtil = container.get(TransformUtil);
application.transformUtil = transformUtil;
const graphicService = container.get(GraphicService);
application.graphicService = graphicService;
const renderService = container.get(RenderService);
application.renderService = renderService;
const layerService = container.get(LayerService);
application.layerService = layerService;

let _isBrowserEnv;
function initIsBrowserEnv() {
  if (null == _isBrowserEnv) try {
    const canvas = document.createElement("canvas"),
      ctx = canvas.getContext("2d");
    _isBrowserEnv = !!(window && canvas.getBoundingClientRect && requestAnimationFrame && window.devicePixelRatio && ctx && ctx.isPointInPath && ctx.isPointInStroke), _isBrowserEnv && (_isBrowserEnv = !!document.createElement);
  } catch (err) {
    _isBrowserEnv = !1;
  }
}
function isBrowserEnv() {
  initIsBrowserEnv();
  const env = application.global && application.global.env;
  return env ? "browser" === env : _isBrowserEnv;
}

function simplifyRadialDist(points, sqTolerance) {
  let deltaX,
    deltaY,
    lastX = points[0].x,
    lastY = points[0].y;
  const newPoints = [points[0]];
  for (let i = 1, len = points.length; i < len; i++) deltaX = points[i].x - lastX, deltaY = points[i].y - lastY, deltaX * deltaX + deltaY * deltaY > sqTolerance && (lastX = points[i].x, lastY = points[i].y, newPoints.push(points[i]));
  return points[points.length - 1].x === lastX && points[points.length - 1].y === lastY || newPoints.push(points[points.length - 1]), newPoints;
}
function flatten_simplify(points, tolerance, highestQuality) {
  if (points.length <= 10) return points;
  return points = highestQuality ? points : simplifyRadialDist(points, void 0 !== tolerance ? tolerance * tolerance : 1);
}

function diff(oldAttrs, newAttrs, getAttr) {
  const diffObj = {};
  for (const key in newAttrs) key in oldAttrs && isEqual(oldAttrs[key], newAttrs[key]) || (diffObj[key] = newAttrs[key]);
  if (getAttr) for (const key in oldAttrs) if (!(key in newAttrs)) {
    const value = getAttr(key);
    void 0 !== value && (diffObj[key] = value);
  }
  return diffObj;
}

let loadArcModule = !1;
const arcModule = new ContainerModule(bind => {
  loadArcModule || (loadArcModule = !0, bind(DefaultCanvasArcRender).toSelf().inSingletonScope(), bind(ArcRender).to(DefaultCanvasArcRender).inSingletonScope(), bind(GraphicRender).toService(ArcRender), bind(ArcRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ArcRenderContribution));
});

let loadRectModule = !1;
const rectModule = new ContainerModule(bind => {
  loadRectModule || (loadRectModule = !0, bind(DefaultCanvasRectRender).toSelf().inSingletonScope(), bind(RectRender).to(DefaultCanvasRectRender).inSingletonScope(), bind(GraphicRender).toService(RectRender), bind(SplitRectAfterRenderContribution).toSelf(), bind(SplitRectBeforeRenderContribution).toSelf(), bind(RectRenderContribution).toService(SplitRectAfterRenderContribution), bind(RectRenderContribution).toService(SplitRectBeforeRenderContribution), bind(RectRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, RectRenderContribution));
});

let loadLineModule = !1;
const lineModule = new ContainerModule(bind => {
  loadLineModule || (loadLineModule = !0, bind(DefaultCanvasLineRender).toSelf().inSingletonScope(), bind(DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope(), bind(LineRender).to(DefaultCanvasLineRender).inSingletonScope(), bind(GraphicRender).toService(LineRender));
});

let loadAreaModule = !1;
const areaModule = new ContainerModule(bind => {
  loadAreaModule || (loadAreaModule = !0, bind(DefaultCanvasAreaRender).toSelf().inSingletonScope(), bind(AreaRender).to(DefaultCanvasAreaRender).inSingletonScope(), bind(GraphicRender).toService(AreaRender), bind(AreaRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, AreaRenderContribution), bind(DefaultIncrementalCanvasAreaRender).toSelf().inSingletonScope());
});

let loadSymbolModule = !1;
const symbolModule = new ContainerModule(bind => {
  loadSymbolModule || (loadSymbolModule = !0, bind(DefaultCanvasSymbolRender).toSelf().inSingletonScope(), bind(SymbolRender).to(DefaultCanvasSymbolRender).inSingletonScope(), bind(GraphicRender).toService(SymbolRender), bind(SymbolRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, SymbolRenderContribution));
});

let loadCircleModule = !1;
const circleModule = new ContainerModule(bind => {
  loadCircleModule || (loadCircleModule = !0, bind(DefaultCanvasCircleRender).toSelf().inSingletonScope(), bind(CircleRender).to(DefaultCanvasCircleRender).inSingletonScope(), bind(GraphicRender).toService(CircleRender), bind(CircleRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, CircleRenderContribution));
});

let loadTextModule = !1;
const textModule = new ContainerModule(bind => {
  loadTextModule || (loadTextModule = !0, bind(TextRender).to(DefaultCanvasTextRender).inSingletonScope(), bind(GraphicRender).toService(TextRender), bind(TextRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, TextRenderContribution));
});

let loadPathModule = !1;
const pathModule = new ContainerModule(bind => {
  loadPathModule || (loadPathModule = !0, bind(DefaultCanvasPathRender).toSelf().inSingletonScope(), bind(PathRender).to(DefaultCanvasPathRender).inSingletonScope(), bind(GraphicRender).toService(PathRender), bind(PathRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PathRenderContribution));
});

let loadPolygonModule = !1;
const polygonModule = new ContainerModule(bind => {
  loadPolygonModule || (loadPolygonModule = !0, bind(PolygonRender).to(DefaultCanvasPolygonRender).inSingletonScope(), bind(GraphicRender).toService(PolygonRender), bind(PolygonRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PolygonRenderContribution));
});

var __decorate$m = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$j = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let DefaultCanvasRichTextRender = class extends BaseRender {
  constructor() {
    super(), this.numberType = RICHTEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init();
  }
  drawShape(richtext, context, x, y, drawContext) {
    const richtextAttribute = getTheme(richtext).richtext,
      {
        strokeOpacity = richtextAttribute.strokeOpacity,
        opacity = richtextAttribute.opacity,
        fillOpacity = richtextAttribute.fillOpacity,
        visible = richtextAttribute.visible
      } = richtext.attribute;
    if (!richtext.valid || !visible) return;
    const fVisible = fillVisible(opacity, fillOpacity, !0),
      sVisible = fillVisible(opacity, strokeOpacity, !0);
    if (!fVisible) return;
    context.setShadowBlendStyle && context.setShadowBlendStyle(richtext, richtext.attribute, richtextAttribute), context.translate(x, y), this.beforeRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
    richtext.getFrameCache().draw(context, this.drawIcon), this.afterRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
  }
  drawIcon(icon, context, x, y, baseline) {
    var _a;
    const richtextIconAttribute = getTheme(icon).richtextIcon,
      {
        width = richtextIconAttribute.width,
        height = richtextIconAttribute.height,
        opacity = richtextIconAttribute.opacity,
        image: url,
        backgroundFill = richtextIconAttribute.backgroundFill,
        backgroundFillOpacity = richtextIconAttribute.backgroundFillOpacity,
        backgroundStroke = richtextIconAttribute.backgroundStroke,
        backgroundStrokeOpacity = richtextIconAttribute.backgroundStrokeOpacity,
        backgroundRadius = richtextIconAttribute.backgroundRadius,
        margin: margin
      } = icon.attribute,
      {
        backgroundWidth = width,
        backgroundHeight = height
      } = icon.attribute;
    if (margin && (x += icon._marginArray[3], y += icon._marginArray[0]), icon._hovered) {
      const expandX = (backgroundWidth - width) / 2,
        expandY = (backgroundHeight - height) / 2;
      0 === backgroundRadius ? (context.beginPath(), context.rect(x - expandX, y - expandY, backgroundWidth, backgroundHeight)) : (context.beginPath(), createRectPath(context, x - expandX, y - expandY, backgroundWidth, backgroundHeight, backgroundRadius, !0)), backgroundFill && (context.globalAlpha = backgroundFillOpacity, context.fillStyle = backgroundFill, context.fill()), backgroundStroke && (context.globalAlpha = backgroundStrokeOpacity, context.strokeStyle = backgroundStroke, context.stroke());
    }
    const res = url && (null === (_a = null == icon ? void 0 : icon.resources) || void 0 === _a ? void 0 : _a.get(url));
    res && "success" === res.state && (context.globalAlpha = opacity, context.drawImage(res.data, x, y, width, height));
  }
  draw(richtext, renderService, drawContext) {
    const richtextAttribute = getTheme(richtext).richtext;
    this._draw(richtext, richtextAttribute, !1, drawContext);
  }
};
DefaultCanvasRichTextRender = __decorate$m([injectable(), __metadata$j("design:paramtypes", [])], DefaultCanvasRichTextRender);

let loadRichtextModule = !1;
const richtextModule = new ContainerModule(bind => {
  loadRichtextModule || (loadRichtextModule = !0, bind(RichTextRender).to(DefaultCanvasRichTextRender).inSingletonScope(), bind(GraphicRender).toService(RichTextRender));
});

let loadImageModule = !1;
const imageModule = new ContainerModule(bind => {
  loadImageModule || (loadImageModule = !0, bind(ImageRender).to(DefaultCanvasImageRender).inSingletonScope(), bind(GraphicRender).toService(ImageRender), bind(ImageRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ImageRenderContribution));
});

function registerArcGraphic() {
  graphicCreator.RegisterGraphicCreator("arc", createArc);
}

function registerAreaGraphic() {
  graphicCreator.RegisterGraphicCreator("area", createArea);
}

function registerCircleGraphic() {
  graphicCreator.RegisterGraphicCreator("circle", createCircle);
}

function registerGroupGraphic() {
  graphicCreator.RegisterGraphicCreator("group", createGroup);
}

function registerImageGraphic() {
  graphicCreator.RegisterGraphicCreator("image", createImage);
}

function registerLineGraphic() {
  graphicCreator.RegisterGraphicCreator("line", createLine);
}

function registerPathGraphic() {
  graphicCreator.RegisterGraphicCreator("path", createPath);
}

function registerPolygonGraphic() {
  graphicCreator.RegisterGraphicCreator("polygon", createPolygon);
}

function registerRectGraphic() {
  graphicCreator.RegisterGraphicCreator("rect", createRect);
}

function registerRichtextGraphic() {
  graphicCreator.RegisterGraphicCreator("richtext", createRichText);
}

function registerSymbolGraphic() {
  graphicCreator.RegisterGraphicCreator("symbol", createSymbol);
}

function registerTextGraphic() {
  graphicCreator.RegisterGraphicCreator("text", createText);
}

function registerWrapTextGraphic() {
  graphicCreator.RegisterGraphicCreator("wrapText", createWrapText);
}

const GROUP_ATTRIBUTES = [
    'x',
    'y',
    'dx',
    'dy',
    'scaleX',
    'scaleY',
    'angle',
    'anchor',
    'postMatrix',
    'visible',
    'clip',
    'pickable',
    'childrenPickable',
    'zIndex',
    'cursor'
];
class AbstractComponent extends Group {
    constructor(attributes, options) {
        super(attributes);
        this._skipRenderAttributes = GROUP_ATTRIBUTES;
        if (options === null || options === void 0 ? void 0 : options.mode) {
            this.mode = options.mode;
            this.setMode(options.mode);
        }
        if (options === null || options === void 0 ? void 0 : options.skipDefault) {
            this.skipDefault = true;
        }
        this.setTheme({
            common: {
                strokeBoundsBuffer: 0
            }
        });
        this.attribute = attributes;
        this.onSetStage(() => {
            this.render();
            this.bindEvents();
        });
    }
    setAttribute(key, value, forceUpdateTag, context) {
        const params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({ [key]: value }, this.attribute, key, context);
        if (params) {
            return this._setAttributes(params, forceUpdateTag);
        }
        if (isPlainObject(this.attribute[key]) &&
            isPlainObject(value) &&
            !isFunction(this.attribute[key]) &&
            !isFunction(value)) {
            merge(this.attribute[key], value);
        }
        else {
            this.attribute[key] = value;
        }
        if (!this._skipRenderAttributes.includes(key)) {
            this.render();
        }
        this.valid = this.isValid();
        if (!this.updateShapeAndBoundsTagSetted() && (forceUpdateTag || this.needUpdateTag(key))) {
            this.addUpdateShapeAndBoundsTag();
        }
        else {
            this.addUpdateBoundTag();
        }
        this.addUpdatePositionTag();
        this.onAttributeUpdate();
    }
    setAttributes(params, forceUpdateTag, context) {
        params =
            (this.onBeforeAttributeUpdate &&
                this.onBeforeAttributeUpdate(params, this.attribute, null, context)) ||
                params;
        return this._setAttributes(params, forceUpdateTag);
    }
    _setAttributes(params, forceUpdateTag) {
        const keys = Object.keys(params);
        this._mergeAttributes(params, keys);
        if (!keys.every(key => this._skipRenderAttributes.includes(key))) {
            this.render();
        }
        this.valid = this.isValid();
        if (!this.updateShapeAndBoundsTagSetted() && (forceUpdateTag || this.needUpdateTags(keys))) {
            this.addUpdateShapeAndBoundsTag();
        }
        else {
            this.addUpdateBoundTag();
        }
        this.addUpdatePositionTag();
        this.onAttributeUpdate();
    }
    _mergeAttributes(params, keys) {
        if (isNil(keys)) {
            keys = Object.keys(params);
        }
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (isPlainObject(this.attribute[key]) && !isFunction(this.attribute[key]) && !isFunction(params[key])) {
                merge(this.attribute[key], params[key]);
            }
            else {
                this.attribute[key] = params[key];
            }
        }
    }
    bindEvents() {
    }
    _getNodeId(id) {
        var _a;
        return `${(_a = this.id) !== null && _a !== void 0 ? _a : this._uid}-${this.name}-${id}`;
    }
    _dispatchEvent(eventName, details) {
        var _a;
        const changeEvent = new CustomEvent(eventName, details);
        changeEvent.manager = (_a = this.stage) === null || _a === void 0 ? void 0 : _a.eventSystem.manager;
        this.dispatchEvent(changeEvent);
    }
    eventPosToStagePos(e) {
        var _a, _b;
        const result = { x: 0, y: 0 };
        const stagePoints = (_b = (_a = this.stage) === null || _a === void 0 ? void 0 : _a.eventPointTransform(e)) !== null && _b !== void 0 ? _b : { x: 0, y: 0 };
        this.globalTransMatrix.transformPoint(stagePoints, result);
        return result;
    }
}

const MathPickerContribution = Symbol.for("MathPickerContribution");
const MathArcPicker = Symbol.for("MathArcPicker");
const MathAreaPicker = Symbol.for("MathAreaPicker");
const MathCirclePicker = Symbol.for("MathCirclePicker");
const MathImagePicker = Symbol.for("MathImagePicker");
const MathLinePicker = Symbol.for("MathLinePicker");
const MathPathPicker = Symbol.for("MathPathPicker");
const MathRectPicker = Symbol.for("MathRectPicker");
const MathSymbolPicker = Symbol.for("MathSymbolPicker");
const MathTextPicker = Symbol.for("MathTextPicker");
const MathPolygonPicker = Symbol.for("MathPolygonPicker");
const CanvasArcPicker = Symbol.for("CanvasArcPicker");
const CanvasAreaPicker = Symbol.for("CanvasAreaPicker");
const CanvasCirclePicker = Symbol.for("CanvasCirclePicker");
const CanvasImagePicker = Symbol.for("CanvasImagePicker");
const CanvasLinePicker = Symbol.for("CanvasLinePicker");
const CanvasPathPicker = Symbol.for("CanvasPathPicker");
const CanvasRectPicker = Symbol.for("CanvasRectPicker");
const CanvasSymbolPicker = Symbol.for("CanvasSymbolPicker");
const CanvasTextPicker = Symbol.for("CanvasTextPicker");
const CanvasPolygonPicker = Symbol.for("CanvasPolygonPicker");
const CanvasRichTextPicker = Symbol.for("CanvasRichTextPicker");
const CanvasPickerContribution = Symbol.for("CanvasPickerContribution");

class PickerBase {
  contains(graphic, point, params) {
    if (!graphic.AABBBounds.containsPoint(point)) return !1;
    if ("imprecise" === graphic.attribute.pickMode) return !0;
    if (!this.canvasRenderer) return !0;
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    const attribute = graphic.getGraphicTheme();
    pickContext.highPerformanceSave();
    let {
      x = attribute.x,
      y = attribute.y
    } = graphic.attribute;
    if (graphic.transMatrix.onlyTranslate()) {
      const point = graphic.getOffsetXY(attribute);
      x += point.x, y += point.y, pickContext.setTransformForCurrent();
    } else x = 0, y = 0, pickContext.transformFromMatrix(graphic.transMatrix, !0);
    let picked = !1,
      _final = !1;
    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, {}, null, (context, arcAttribute, themeAttribute, final) => !(!picked && !_final) || (picked = context.isPointInPath(point.x, point.y), _final = final || _final, picked), (context, arcAttribute, themeAttribute, final) => {
      if (picked || _final) return !0;
      const lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth,
        pickStrokeBuffer = arcAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
        keepStrokeScale = arcAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), _final = final || _final, picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
}

var __decorate$l = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$i = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$i = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathArcPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
};
DefaultMathArcPicker = __decorate$l([injectable(), __param$i(0, inject(ArcRender)), __metadata$i("design:paramtypes", [Object])], DefaultMathArcPicker);

let loadArcPick$1 = !1;
const arcMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArcPick$1 || (loadArcPick$1 = !0, bind(MathArcPicker).to(DefaultMathArcPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathArcPicker));
});

var __decorate$k = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$h = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$h = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathAreaPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
};
DefaultMathAreaPicker = __decorate$k([injectable(), __param$h(0, inject(AreaRender)), __metadata$h("design:paramtypes", [Object])], DefaultMathAreaPicker);

let loadAreaPick$1 = !1;
const areaMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadAreaPick$1 || (loadAreaPick$1 = !0, bind(MathAreaPicker).to(DefaultMathAreaPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathAreaPicker));
});

var __decorate$j = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$g = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$g = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathCirclePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
};
DefaultMathCirclePicker = __decorate$j([injectable(), __param$g(0, inject(CircleRender)), __metadata$g("design:paramtypes", [Object])], DefaultMathCirclePicker);

let loadCirclePick$1 = !1;
const circleMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadCirclePick$1 || (loadCirclePick$1 = !0, bind(MathCirclePicker).to(DefaultMathCirclePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathCirclePicker));
});

var __decorate$i = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultMathImagePicker = class {
  constructor() {
    this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
  }
  contains(image, point, params) {
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    return !!pickContext && !!image.AABBBounds.containsPoint(point);
  }
};
DefaultMathImagePicker = __decorate$i([injectable()], DefaultMathImagePicker);

let loadImagePick$1 = !1;
const imageMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadImagePick$1 || (loadImagePick$1 = !0, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
});

var __decorate$h = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$f = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$f = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathLinePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
};
DefaultMathLinePicker = __decorate$h([injectable(), __param$f(0, inject(LineRender)), __metadata$f("design:paramtypes", [Object])], DefaultMathLinePicker);

let loadLinePick$1 = !1;
const lineMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLinePick$1 || (loadLinePick$1 = !0, bind(MathLinePicker).to(DefaultMathLinePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathLinePicker));
});

var __decorate$g = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$e = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$e = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathPolygonPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
};
DefaultMathPolygonPicker = __decorate$g([injectable(), __param$e(0, inject(PolygonRender)), __metadata$e("design:paramtypes", [Object])], DefaultMathPolygonPicker);

let loadPolygonPick$1 = !1;
const polygonMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPolygonPick$1 || (loadPolygonPick$1 = !0, bind(MathPolygonPicker).to(DefaultMathPolygonPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPolygonPicker));
});

var __decorate$f = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$d = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$d = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathPathPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
};
DefaultMathPathPicker = __decorate$f([injectable(), __param$d(0, inject(PathRender)), __metadata$d("design:paramtypes", [Object])], DefaultMathPathPicker);

let loadPathPick$1 = !1;
const pathMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPathPick$1 || (loadPathPick$1 = !0, bind(MathPathPicker).to(DefaultMathPathPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPathPicker));
});

const _bounds = new AABBBounds();
class RectPickerBase {
  constructor() {
    this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  contains(rect, point, params) {
    if (!rect.AABBBounds.containsPoint(point)) return !1;
    if ("imprecise" === rect.attribute.pickMode) return !0;
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    const rectAttribute = rect.getGraphicTheme(),
      {
        cornerRadius = rectAttribute.cornerRadius
      } = rect.attribute;
    let {
      x = rectAttribute.x,
      y = rectAttribute.y
    } = rect.attribute;
    pickContext.highPerformanceSave();
    let onlyTranslate = !0;
    if (rect.transMatrix.onlyTranslate()) {
      const point = rect.getOffsetXY(rectAttribute);
      x += point.x, y += point.y, pickContext.setTransformForCurrent();
    } else x = 0, y = 0, onlyTranslate = !1, pickContext.transformFromMatrix(rect.transMatrix, !0);
    let picked = !0;
    if (!onlyTranslate || rect.shadowRoot || isNumber(cornerRadius, !0) && 0 !== cornerRadius || isArray(cornerRadius) && cornerRadius.some(num => 0 !== num)) picked = !1, this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, (context, rectAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), picked), (context, rectAttribute, themeAttribute) => {
      if (picked) return !0;
      const lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth,
        pickStrokeBuffer = rectAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
        keepStrokeScale = rectAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), picked;
    });else {
      const {
        fill = rectAttribute.fill,
        stroke = rectAttribute.stroke,
        lineWidth = rectAttribute.lineWidth
      } = rect.attribute;
      if (fill) picked = !0;else if (stroke) {
        const bounds = rect.AABBBounds;
        _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), picked = !_bounds.containsPoint(point);
      }
    }
    return pickContext.highPerformanceRestore(), picked;
  }
}

var __decorate$e = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$c = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$c = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathRectPicker = class extends RectPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultMathRectPicker = __decorate$e([injectable(), __param$c(0, inject(RectRender)), __metadata$c("design:paramtypes", [Object])], DefaultMathRectPicker);

let loadRectPick$1 = !1;
const rectMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRectPick$1 || (loadRectPick$1 = !0, bind(MathRectPicker).to(DefaultMathRectPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathRectPicker));
});

let loadRichTextPick = !1;
const richTextMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRichTextPick || (loadRichTextPick = !0, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
});

var __decorate$d = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$b = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$b = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathSymbolPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
};
DefaultMathSymbolPicker = __decorate$d([injectable(), __param$b(0, inject(SymbolRender)), __metadata$b("design:paramtypes", [Object])], DefaultMathSymbolPicker);

let loadSymbolPick$1 = !1;
const symbolMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadSymbolPick$1 || (loadSymbolPick$1 = !0, bind(MathSymbolPicker).to(DefaultMathSymbolPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathSymbolPicker));
});

var __decorate$c = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultMathTextPicker = class {
  constructor() {
    this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
  }
  contains(text, point, params) {
    return !!text.AABBBounds.containsPoint(point);
  }
};
DefaultMathTextPicker = __decorate$c([injectable()], DefaultMathTextPicker);

let loadTextPick$1 = !1;
const textMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadTextPick$1 || (loadTextPick$1 = !0, bind(MathTextPicker).to(DefaultMathTextPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathTextPicker));
});

var __decorate$b = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$a = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$a = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasArcPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
};
DefaultCanvasArcPicker = __decorate$b([injectable(), __param$a(0, inject(ArcRender)), __metadata$a("design:paramtypes", [Object])], DefaultCanvasArcPicker);

let loadArcPick = !1;
const arcCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArcPick || (loadArcPick = !0, bind(CanvasArcPicker).to(DefaultCanvasArcPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArcPicker));
});

var __decorate$a = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$9 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$9 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasRectPicker = class extends RectPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultCanvasRectPicker = __decorate$a([injectable(), __param$9(0, inject(RectRender)), __metadata$9("design:paramtypes", [Object])], DefaultCanvasRectPicker);

let loadRectPick = !1;
const rectCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRectPick || (loadRectPick = !0, bind(CanvasRectPicker).to(DefaultCanvasRectPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRectPicker));
});

class BaseLinePicker extends BaseRender {
  contains(graphic, point, params) {
    if (!graphic.AABBBounds.containsPoint(point)) return !1;
    if ("imprecise" === graphic.attribute.pickMode) return !0;
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    pickContext.highPerformanceSave();
    const lineAttribute = graphic.getGraphicTheme(),
      data = this.transform(graphic, lineAttribute, pickContext),
      {
        x: x,
        y: y,
        z: z,
        lastModelMatrix: lastModelMatrix
      } = data;
    let pickPoint = point;
    if (pickContext.camera) {
      pickPoint = point.clone();
      const globalMatrix = graphic.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = !1;
    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, {}, null, context => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, lineAttribute, themeAttribute) => {
      if (picked) return !0;
      const lineWidth = lineAttribute.lineWidth || themeAttribute.lineWidth,
        pickStrokeBuffer = lineAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
        keepStrokeScale = lineAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
}

var __decorate$9 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$8 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$8 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasLinePicker = class extends BaseLinePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
};
DefaultCanvasLinePicker = __decorate$9([injectable(), __param$8(0, inject(LineRender)), __metadata$8("design:paramtypes", [Object])], DefaultCanvasLinePicker);

let loadLinePick = !1;
const lineCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLinePick || (loadLinePick = !0, bind(CanvasLinePicker).to(DefaultCanvasLinePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasLinePicker));
});

var __decorate$8 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$7 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$7 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasAreaPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
};
DefaultCanvasAreaPicker = __decorate$8([injectable(), __param$7(0, inject(AreaRender)), __metadata$7("design:paramtypes", [Object])], DefaultCanvasAreaPicker);

let loadAreaPick = !1;
const areaCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadAreaPick || (loadAreaPick = !0, bind(CanvasAreaPicker).to(DefaultCanvasAreaPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasAreaPicker));
});

class Base3dPicker extends BaseRender {
  contains(graphic, point, params) {
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    const attribute = graphic.getGraphicTheme();
    pickContext.highPerformanceSave();
    const data = this.transform(graphic, attribute, pickContext),
      {
        x: x,
        y: y,
        z: z,
        lastModelMatrix: lastModelMatrix
      } = data;
    let pickPoint = point;
    if (pickContext.camera) {
      pickPoint = point.clone();
      const globalMatrix = graphic.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = !1;
    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, params, null, (context, arc3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked)), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
}

var __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$6 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$6 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasSymbolPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  contains(symbol, point, params) {
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    const parsedPath = symbol.getParsedPath();
    if (!pickContext.camera) {
      if (!symbol.AABBBounds.containsPoint(point)) return !1;
      if (parsedPath.isSvg || "imprecise" === symbol.attribute.pickMode) return !0;
    }
    pickContext.highPerformanceSave();
    const symbolAttribute = symbol.getGraphicTheme(),
      data = this.transform(symbol, symbolAttribute, pickContext),
      {
        x: x,
        y: y,
        z: z,
        lastModelMatrix: lastModelMatrix
      } = data;
    let pickPoint = point;
    if (pickContext.camera) {
      pickPoint = point.clone();
      const globalMatrix = symbol.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = !1;
    return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, symbolAttribute, themeAttribute) => {
      if (picked) return !0;
      const lineWidth = symbolAttribute.lineWidth || themeAttribute.lineWidth,
        pickStrokeBuffer = symbolAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
        keepStrokeScale = symbolAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasSymbolPicker = __decorate$7([injectable(), __param$6(0, inject(SymbolRender)), __metadata$6("design:paramtypes", [Object])], DefaultCanvasSymbolPicker);

let loadSymbolPick = !1;
const symbolCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadSymbolPick || (loadSymbolPick = !0, bind(CanvasSymbolPicker).to(DefaultCanvasSymbolPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasSymbolPicker));
});

var __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$5 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$5 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasCirclePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
};
DefaultCanvasCirclePicker = __decorate$6([injectable(), __param$5(0, inject(CircleRender)), __metadata$5("design:paramtypes", [Object])], DefaultCanvasCirclePicker);

let loadCirclePick = !1;
const circleCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadCirclePick || (loadCirclePick = !0, bind(CanvasCirclePicker).to(DefaultCanvasCirclePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasCirclePicker));
});

var __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$4 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$4 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasTextPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
  }
  contains(text, point, params) {
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    const bounds = text.AABBBounds;
    if (!pickContext.camera) return !!bounds.containsPoint(point);
    pickContext.highPerformanceSave();
    const textAttribute = text.getGraphicTheme(),
      {
        keepDirIn3d = textAttribute.keepDirIn3d
      } = text.attribute,
      computed3dMatrix = !keepDirIn3d,
      data = this.transform(text, textAttribute, pickContext, computed3dMatrix),
      {
        x: x,
        y: y,
        z: z,
        lastModelMatrix: lastModelMatrix
      } = data;
    this.canvasRenderer.z = z;
    let pickPoint = point;
    if (pickContext.camera) {
      pickPoint = point.clone();
      const globalMatrix = text.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
    }
    let picked = !1;
    return this.canvasRenderer.drawShape(text, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => {
      if (picked) return !0;
      const {
          fontSize = textAttribute.fontSize,
          textBaseline = textAttribute.textBaseline,
          textAlign = textAttribute.textAlign
        } = text.attribute,
        bounds = text.AABBBounds,
        height = bounds.height(),
        width = bounds.width(),
        offsetY = textLayoutOffsetY(textBaseline, height, fontSize),
        offsetX = textDrawOffsetX(textAlign, width);
      return context.rect(offsetX + x, offsetY + y, width, height, z), picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked;
    }, (context, symbolAttribute, themeAttribute) => picked), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasTextPicker = __decorate$5([injectable(), __param$4(0, inject(TextRender)), __metadata$4("design:paramtypes", [Object])], DefaultCanvasTextPicker);

let loadTextPick = !1;
const textCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadTextPick || (loadTextPick = !0, bind(CanvasTextPicker).to(DefaultCanvasTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasTextPicker));
});

var __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$3 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$3 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasPathPicker = class extends BaseLinePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
};
DefaultCanvasPathPicker = __decorate$4([injectable(), __param$3(0, inject(PathRender)), __metadata$3("design:paramtypes", [Object])], DefaultCanvasPathPicker);

let loadPathPick = !1;
const pathCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPathPick || (loadPathPick = !0, bind(CanvasPathPicker).to(DefaultCanvasPathPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPathPicker));
});

var __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$2 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$2 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasPolygonPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
};
DefaultCanvasPolygonPicker = __decorate$3([injectable(), __param$2(0, inject(PolygonRender)), __metadata$2("design:paramtypes", [Object])], DefaultCanvasPolygonPicker);

let loadPolygonPick = !1;
const polygonCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPolygonPick || (loadPolygonPick = !0, bind(CanvasPolygonPicker).to(DefaultCanvasPolygonPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPolygonPicker));
});

var __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$1 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasRichTextPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "richtext", this.numberType = RICHTEXT_NUMBER_TYPE;
  }
  contains(richtext, point, params) {
    return !!richtext.AABBBounds.containsPoint(point);
  }
};
DefaultCanvasRichTextPicker = __decorate$2([injectable(), __param$1(0, inject(RichTextRender)), __metadata$1("design:paramtypes", [Object])], DefaultCanvasRichTextPicker);

let loadRichtextPick = !1;
const richtextCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRichtextPick || (loadRichtextPick = !0, bind(CanvasRichTextPicker).to(DefaultCanvasRichTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRichTextPicker));
});

var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasImagePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
  }
};
DefaultCanvasImagePicker = __decorate$1([injectable(), __param(0, inject(ImageRender)), __metadata("design:paramtypes", [Object])], DefaultCanvasImagePicker);

let loadImagePick = !1;
const imageCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadImagePick || (loadImagePick = !0, bind(CanvasImagePicker).to(DefaultCanvasImagePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasImagePicker));
});

const browser = isBrowserEnv();

function _registerArc() {
  _registerArc.__loaded || (_registerArc.__loaded = !0, registerArcGraphic(), container.load(arcModule), container.load(browser ? arcCanvasPickModule : arcMathPickModule));
}
_registerArc.__loaded = !1;
const registerArc = _registerArc;

function _registerArea() {
  _registerArea.__loaded || (_registerArea.__loaded = !0, registerAreaGraphic(), container.load(areaModule), container.load(browser ? areaCanvasPickModule : areaMathPickModule));
}
_registerArea.__loaded = !1;
const registerArea = _registerArea;

function _registerCircle() {
  _registerCircle.__loaded || (_registerCircle.__loaded = !0, registerCircleGraphic(), container.load(circleModule), container.load(browser ? circleCanvasPickModule : circleMathPickModule));
}
_registerCircle.__loaded = !1;
const registerCircle = _registerCircle;

function _registerGroup() {
  _registerGroup.__loaded || (_registerGroup.__loaded = !0, registerGroupGraphic());
}
_registerGroup.__loaded = !1;
const registerGroup = _registerGroup;

function _registerImage() {
  _registerImage.__loaded || (_registerImage.__loaded = !0, registerImageGraphic(), container.load(imageModule), container.load(browser ? imageCanvasPickModule : imageMathPickModule));
}
_registerImage.__loaded = !1;
const registerImage = _registerImage;

function _registerLine() {
  _registerLine.__loaded || (_registerLine.__loaded = !0, registerLineGraphic(), container.load(lineModule), container.load(browser ? lineCanvasPickModule : lineMathPickModule));
}
_registerLine.__loaded = !1;
const registerLine = _registerLine;

function _registerPath() {
  _registerPath.__loaded || (_registerPath.__loaded = !0, registerPathGraphic(), container.load(pathModule), container.load(browser ? pathCanvasPickModule : pathMathPickModule));
}
_registerPath.__loaded = !1;
const registerPath = _registerPath;

function _registerPolygon() {
  _registerPolygon.__loaded || (_registerPolygon.__loaded = !0, registerPolygonGraphic(), container.load(polygonModule), container.load(browser ? polygonCanvasPickModule : polygonMathPickModule));
}
_registerPolygon.__loaded = !1;
const registerPolygon = _registerPolygon;

function _registerRect() {
  _registerRect.__loaded || (_registerRect.__loaded = !0, registerRectGraphic(), container.load(rectModule), container.load(browser ? rectCanvasPickModule : rectMathPickModule));
}
_registerRect.__loaded = !1;
const registerRect = _registerRect;

function _registerRichtext() {
  _registerRichtext.__loaded || (_registerRichtext.__loaded = !0, registerRichtextGraphic(), container.load(richtextModule), container.load(browser ? richtextCanvasPickModule : richTextMathPickModule));
}
_registerRichtext.__loaded = !1;
const registerRichtext = _registerRichtext;

function _registerSymbol() {
  _registerSymbol.__loaded || (_registerSymbol.__loaded = !0, registerSymbolGraphic(), container.load(symbolModule), container.load(browser ? symbolCanvasPickModule : symbolMathPickModule));
}
_registerSymbol.__loaded = !1;
const registerSymbol = _registerSymbol;

function _registerText() {
  _registerText.__loaded || (_registerText.__loaded = !0, registerTextGraphic(), container.load(textModule), container.load(browser ? textCanvasPickModule : textMathPickModule));
}
_registerText.__loaded = !1;
const registerText = _registerText;

function _registerWrapText() {
  _registerWrapText.__loaded || (_registerWrapText.__loaded = !0, registerWrapTextGraphic());
}
_registerWrapText.__loaded = !1;
const registerWrapText = _registerWrapText;

function loadScrollbarComponent() {
    registerGroup();
    registerRect();
}

const POLAR_START_ANGLE = -0.5 * Math.PI;
const POLAR_END_ANGLE = 1.5 * Math.PI;
const DEFAULT_TEXT_FONT_FAMILY = 'PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol';
const DEFAULT_TEXT_FONT_SIZE = 14;
var StateValue;
(function (StateValue) {
    StateValue["selected"] = "selected";
    StateValue["selectedReverse"] = "selected_reverse";
    StateValue["hover"] = "hover";
    StateValue["hoverReverse"] = "hover_reverse";
})(StateValue || (StateValue = {}));
const DEFAULT_STATES$2 = {
    [StateValue.selectedReverse]: {},
    [StateValue.selected]: {},
    [StateValue.hover]: {},
    [StateValue.hoverReverse]: {}
};
const DEFAULT_HTML_TEXT_SPEC = {
    container: '',
    width: 30,
    height: 30,
    style: {}
};
const SCROLLBAR_START_EVENT = 'scrollDown';
const SCROLLBAR_EVENT = 'scrollDrag';
const SCROLLBAR_END_EVENT = 'scrollUp';

function getEndTriggersOfDrag() {
    if (vglobal.env === 'browser') {
        return ['pointerup', 'pointerleave', 'pointercancel'];
    }
    return ['pointerup', 'pointerleave', 'pointerupoutside'];
}

const delayMap$2 = {
    debounce: debounce,
    throttle: throttle
};
loadScrollbarComponent();
class ScrollBar extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, ScrollBar.defaultAttributes, attributes));
        this.name = 'scrollbar';
        this._handleTouchMove = (e) => {
            if (isValid(this._prePos)) {
                e.preventDefault();
            }
        };
        this._onRailPointerDown = (e) => {
            const { viewX, viewY } = e;
            const { direction, width, height, range } = this.attribute;
            const sliderSize = this._sliderSize;
            const [min, max] = this._getScrollRange();
            let currentScrollValue;
            if (direction === 'vertical') {
                const relativeY = viewY - this._viewPosition.y;
                const currentYPos = clamp(relativeY - sliderSize / 2, min, max);
                currentScrollValue = relativeY / height;
                this._slider.setAttribute('y', currentYPos, true);
            }
            else {
                const relativeX = viewX - this._viewPosition.x;
                const currentXPos = clamp(relativeX - sliderSize / 2, min, max);
                currentScrollValue = relativeX / width;
                this._slider.setAttribute('x', currentXPos, true);
            }
            this.setScrollRange([currentScrollValue - (range[1] - range[0]) / 2, currentScrollValue + (range[1] - range[0]) / 2], false);
            if (this.stage && !this.stage.autoRender) {
                this.stage.renderNextFrame();
            }
        };
        this._onSliderPointerDown = (e) => {
            this._clearDragEvents();
            const { stopSliderDownPropagation = true } = this.attribute;
            if (stopSliderDownPropagation) {
                e.stopPropagation();
            }
            const { direction } = this.attribute;
            const { x, y } = this.stage.eventPointTransform(e);
            this._prePos = direction === 'horizontal' ? x : y;
            this._dispatchEvent(SCROLLBAR_START_EVENT, {
                pos: this._prePos,
                event: e
            });
            const triggers = getEndTriggersOfDrag();
            const obj = vglobal.env === 'browser' ? vglobal : this.stage;
            obj.addEventListener('pointermove', this._onSliderPointerMoveWithDelay, { capture: true });
            triggers.forEach((trigger) => {
                obj.addEventListener(trigger, this._onSliderPointerUp);
            });
        };
        this._computeScrollValue = (e) => {
            const { direction } = this.attribute;
            const { x, y } = this.stage.eventPointTransform(e);
            let currentScrollValue;
            let currentPos;
            let delta = 0;
            const { width, height } = this.getSliderRenderBounds();
            if (direction === 'vertical') {
                currentPos = y;
                delta = currentPos - this._prePos;
                currentScrollValue = delta / height;
            }
            else {
                currentPos = x;
                delta = currentPos - this._prePos;
                currentScrollValue = delta / width;
            }
            return [currentPos, currentScrollValue];
        };
        this._onSliderPointerMove = (e) => {
            const { stopSliderMovePropagation = true } = this.attribute;
            if (stopSliderMovePropagation) {
                e.stopPropagation();
            }
            const preScrollRange = this.getScrollRange();
            const [currentPos, currentScrollValue] = this._computeScrollValue(e);
            this.setScrollRange([preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue], true);
            this._prePos = currentPos;
        };
        this._onSliderPointerMoveWithDelay = this.attribute.delayTime === 0
            ? this._onSliderPointerMove
            : delayMap$2[this.attribute.delayType](this._onSliderPointerMove, this.attribute.delayTime);
        this._onSliderPointerUp = (e) => {
            const { range: preRange, limitRange = [0, 1] } = this.attribute;
            const preScrollRange = this.getScrollRange();
            const [currentPos, currentScrollValue] = this._computeScrollValue(e);
            const range = [preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue];
            this._prePos = null;
            this._dispatchEvent(SCROLLBAR_END_EVENT, {
                pre: preRange,
                value: clampRange(range, limitRange[0], limitRange[1])
            });
            this._clearDragEvents();
        };
    }
    setScrollRange(range, render = true) {
        const { direction = 'horizontal', limitRange = [0, 1], range: preRange, realTime = true } = this.attribute;
        const currScrollRange = clampRange(range, limitRange[0], limitRange[1]);
        if (render) {
            const sliderPos = this._getSliderPos(currScrollRange);
            if (this._slider) {
                const sliderSize = sliderPos[1] - sliderPos[0];
                this._sliderSize = sliderSize;
                if (direction === 'horizontal') {
                    this._slider.setAttributes({
                        x: sliderPos[0],
                        width: sliderSize
                    }, true);
                }
                else {
                    this._slider.setAttributes({
                        y: sliderPos[0],
                        height: sliderSize
                    }, true);
                }
                if (this.stage && !this.stage.autoRender) {
                    this.stage.renderNextFrame();
                }
            }
        }
        this.attribute.range = currScrollRange;
        if (realTime) {
            this._dispatchEvent(SCROLLBAR_EVENT, {
                pre: preRange,
                value: currScrollRange
            });
        }
    }
    getScrollRange() {
        return this.attribute.range;
    }
    bindEvents() {
        if (this.attribute.disableTriggerEvent) {
            return;
        }
        const { delayType = 'throttle', delayTime = 0 } = this.attribute;
        if (this._rail) {
            this._rail.addEventListener('pointerdown', delayMap$2[delayType](this._onRailPointerDown, delayTime));
        }
        if (this._slider) {
            this._slider.addEventListener('pointerdown', this._onSliderPointerDown);
        }
        (vglobal.env === 'browser' ? vglobal : this.stage).addEventListener('touchmove', this._handleTouchMove, {
            passive: false
        });
    }
    render() {
        this._reset();
        const { direction = 'horizontal', width, height, range, limitRange = [0, 1], railStyle, sliderStyle, padding = 2 } = this.attribute;
        const group = this.createOrUpdateChild('scrollbar-container', {}, 'group');
        const rail = group.createOrUpdateChild('scrollbar-rail', Object.assign({ x: 0, y: 0, width,
            height }, railStyle), 'rect');
        this._rail = rail;
        const sliderRenderBounds = this.getSliderRenderBounds();
        const sliderPos = this._getSliderPos(clampRange(range, limitRange[0], limitRange[1]));
        const sliderSize = sliderPos[1] - sliderPos[0];
        this._sliderSize = sliderSize;
        let sliderAttribute;
        if (direction === 'horizontal') {
            sliderAttribute = {
                x: sliderPos[0],
                y: sliderRenderBounds.y1,
                width: sliderSize,
                height: sliderRenderBounds.height
            };
        }
        else {
            sliderAttribute = {
                x: sliderRenderBounds.x1,
                y: sliderPos[0],
                width: sliderRenderBounds.width,
                height: sliderSize
            };
        }
        const slider = group.createOrUpdateChild('slider', Object.assign(Object.assign(Object.assign(Object.assign({}, sliderAttribute), { cornerRadius: this._getDefaultSliderCornerRadius() }), sliderStyle), { boundsPadding: normalizePadding(padding), pickMode: 'imprecise' }), 'rect');
        this._slider = slider;
        this._container = group;
        const containerAABBBounds = this._container.AABBBounds;
        this._viewPosition = {
            x: containerAABBBounds.x1,
            y: containerAABBBounds.y1
        };
    }
    getSliderRenderBounds() {
        if (this._sliderRenderBounds) {
            return this._sliderRenderBounds;
        }
        const { width, height, padding = 2 } = this.attribute;
        const [top, right, bottom, left] = normalizePadding(padding);
        const renderBounds = {
            x1: left,
            y1: top,
            x2: width - right,
            y2: height - bottom,
            width: Math.max(0, width - (left + right)),
            height: Math.max(0, height - (top + bottom))
        };
        this._sliderRenderBounds = renderBounds;
        return renderBounds;
    }
    _getDefaultSliderCornerRadius() {
        const { direction, round } = this.attribute;
        if (round) {
            const { width, height } = this.getSliderRenderBounds();
            return direction === 'horizontal' ? height : width;
        }
        return 0;
    }
    _getSliderPos(range) {
        const { direction } = this.attribute;
        const { width, height, x1, y1 } = this.getSliderRenderBounds();
        if (direction === 'horizontal') {
            return [width * range[0] + x1, width * range[1] + x1];
        }
        return [height * range[0] + y1, height * range[1] + y1];
    }
    _getScrollRange() {
        if (this._sliderLimitRange) {
            return this._sliderLimitRange;
        }
        const { limitRange = [0, 1], direction } = this.attribute;
        const [min, max] = clampRange(limitRange, 0, 1);
        const { width, height, x1, y1 } = this.getSliderRenderBounds();
        const sliderSize = this._sliderSize;
        return direction === 'horizontal'
            ? clampRange([x1 + min * width, x1 + max * width], x1, width - sliderSize)
            : clampRange([y1 + min * height, y1 + max * height], y1, height - sliderSize);
    }
    _clearDragEvents() {
        const triggers = getEndTriggersOfDrag();
        const obj = vglobal.env === 'browser' ? vglobal : this.stage;
        obj.removeEventListener('pointermove', this._onSliderPointerMoveWithDelay, { capture: true });
        triggers.forEach((trigger) => {
            obj.removeEventListener(trigger, this._onSliderPointerUp);
        });
    }
    _reset() {
        this._sliderRenderBounds = null;
        this._sliderLimitRange = null;
    }
    release(all) {
        super.release(all);
        (vglobal.env === 'browser' ? vglobal : this.stage).addEventListener('touchmove', this._handleTouchMove, {
            passive: false
        });
        this._clearDragEvents();
    }
}
ScrollBar.defaultAttributes = {
    direction: 'horizontal',
    round: true,
    sliderSize: 20,
    sliderStyle: {
        fill: 'rgba(0, 0, 0, .5)'
    },
    railStyle: {
        fill: 'rgba(0, 0, 0, .0)'
    },
    padding: 2,
    scrollRange: [0, 1],
    delayType: 'throttle',
    delayTime: 0,
    realTime: true
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var ScrollBarPlugin_1;
let ScrollBarPlugin = ScrollBarPlugin_1 = class ScrollBarPlugin {
    constructor() {
        this.name = 'scrollbar';
        this.activeEvent = 'onRegister';
        this._uid = Generator.GenAutoIncrementId();
        this.key = this.name + this._uid;
        this.scroll = (e) => {
            var _a, _b;
            const graphic = e.target;
            const data = this.getScrollContainer(graphic);
            if (!data && !this.scrollContainer) {
                return;
            }
            if (!data && this.scrollContainer) {
                if (!this.scrollContainer.g.stage || this.scrollContainer.g.stage !== graphic.stage) {
                    return;
                }
                const newScrollContainer = this.formatScrollContainer(this.scrollContainer.g);
                if (!newScrollContainer) {
                    this.clearScrollbar(this.scrollContainer.g, 'all');
                    return;
                }
                if (this.scrollContainer.showH && !newScrollContainer.showH) {
                    this.clearScrollbar(this.scrollContainer.g, 'horizontal');
                }
                if (this.scrollContainer.showV && !newScrollContainer.showV) {
                    this.clearScrollbar(this.scrollContainer.g, 'vertical');
                }
                this.scrollContainer = newScrollContainer;
            }
            else if (data && this.scrollContainer && data.g !== this.scrollContainer.g) {
                this.clearScrollbar(this.scrollContainer.g, 'all');
            }
            this.scrollContainer = data !== null && data !== void 0 ? data : this.scrollContainer;
            if (!data) {
                return;
            }
            const scrollContainer = data.g;
            if (!scrollContainer) {
                return;
            }
            const { width, height, scrollX = 0, scrollY = 0 } = scrollContainer.attribute;
            let newScrollX = scrollX;
            let newScrollY = scrollY;
            let { showH, showV } = data;
            this.scrollContainerBounds = new Bounds().set(0, 0, scrollContainer.attribute.width, scrollContainer.attribute.height);
            if (showH && showH) {
                if (abs(e.deltaX) > abs(e.deltaY)) {
                    showH = showH && true;
                    showV = showV && false;
                }
                else {
                    showH = showH && false;
                    showV = showV && true;
                }
            }
            const scrollWidth = this.childrenBounds.width();
            const scrollHeight = this.childrenBounds.height();
            if (showH) {
                newScrollX = scrollX - ((_a = e.deltaX) !== null && _a !== void 0 ? _a : 0);
                if (newScrollX > 0) {
                    newScrollX = 0;
                }
                else if (newScrollX < width - scrollWidth) {
                    newScrollX = width - scrollWidth;
                }
            }
            if (showV) {
                newScrollY = scrollY - ((_b = e.deltaY) !== null && _b !== void 0 ? _b : 0);
                if (newScrollY > 0) {
                    newScrollY = 0;
                }
                else if (newScrollY < height - scrollHeight) {
                    newScrollY = height - scrollHeight;
                }
            }
            scrollContainer.setAttributes({
                scrollX: newScrollX,
                scrollY: newScrollY
            });
            this.addOrUpdateScroll(showH, showV, scrollContainer.parent, scrollContainer);
        };
        this.handleScrollBarChange = (params) => {
            if (!this.scrollContainer ||
                !this.scrollContainerBounds ||
                !this.childrenBounds ||
                !params ||
                !params.target ||
                !params.detail ||
                !params.detail.value) {
                return;
            }
            const scrollbar = params.target;
            const newRange = params.detail.value;
            if (scrollbar.attribute.direction === 'horizontal') {
                const scrollWidth = this.childrenBounds.width();
                this.scrollContainer.g.setAttributes({ scrollX: -newRange[0] * scrollWidth });
            }
            else {
                const scrollHeight = this.childrenBounds.height();
                this.scrollContainer.g.setAttributes({ scrollY: -newRange[0] * scrollHeight });
            }
        };
    }
    activate(context) {
        this.pluginService = context;
        const { stage } = this.pluginService;
        this.childrenBounds = new AABBBounds();
        stage.addEventListener('wheel', this.scroll);
        this.params = ScrollBarPlugin_1.defaultParams;
    }
    initEventOfScrollbar(scrollContainer, scrollbar, isHorozntal) {
        scrollContainer.addEventListener('pointerover', () => {
            scrollbar.setAttribute('visibleAll', true);
        });
        scrollContainer.addEventListener('pointermove', () => {
            scrollbar.setAttribute('visibleAll', true);
        });
        scrollContainer.addEventListener('pointerout', () => {
            scrollbar.setAttribute('visibleAll', false);
        });
        scrollbar.addEventListener('pointerover', () => {
            scrollbar.setAttribute('visibleAll', true);
        });
        scrollbar.addEventListener('pointerout', () => {
            scrollbar.setAttribute('visibleAll', true);
        });
        scrollbar.addEventListener('scrollUp', this.handleScrollBarChange);
        scrollbar.addEventListener(SCROLLBAR_EVENT, this.handleScrollBarChange);
    }
    addOrUpdateScroll(showH, showV, container, scrollContainer) {
        if (showH) {
            const { scrollBar: hScrollbar, isUpdate } = this.addOrUpdateHScroll(scrollContainer, container, true);
            if (!isUpdate) {
                this.initEventOfScrollbar(scrollContainer, hScrollbar, true);
            }
        }
        else {
            this.clearScrollbar(scrollContainer, 'horizontal');
        }
        if (showV) {
            const { scrollBar: vScrollbar, isUpdate } = this.addOrUpdateHScroll(scrollContainer, container, false);
            if (!isUpdate) {
                this.initEventOfScrollbar(scrollContainer, vScrollbar, false);
            }
        }
        else {
            this.clearScrollbar(scrollContainer, 'vertical');
        }
    }
    getDirection(isHorozntal) {
        return isHorozntal ? 'horizontal' : 'vertical';
    }
    addOrUpdateHScroll(scrollContainer, container, isHorozntal) {
        var _a, _b;
        const direction = this.getDirection(isHorozntal);
        const name = `${(_a = scrollContainer.name) !== null && _a !== void 0 ? _a : scrollContainer._uid}_${this.getDirection(isHorozntal)}_${this.name}`;
        const scrollbars = container.children.filter((g) => g.name === name);
        let isUpdate = true;
        let scrollBar = scrollbars[0];
        const { y = 0, dy = 0, x = 0, dx = 0, height, width, zIndex = 0 } = this.scrollContainer.g.attribute;
        const attrs = {
            x: 0,
            y: 0,
            direction,
            zIndex: zIndex + 1,
            visibleAll: true,
            padding: [2, 0],
            railStyle: {
                fill: 'rgba(0, 0, 0, .1)'
            },
            range: [0, 0.05]
        };
        if (isHorozntal) {
            attrs.width = this.scrollContainerBounds.width();
            attrs.height = 12;
        }
        else {
            attrs.height = this.scrollContainerBounds.height();
            attrs.width = 12;
        }
        if (!scrollBar) {
            isUpdate = false;
            scrollBar = new ScrollBar(attrs);
            scrollBar.name = name;
            container.add(scrollBar);
            scrollBar.isScrollBar = true;
        }
        else if (scrollbars.length > 1) {
            scrollbars.forEach((child, index) => {
                var _a;
                if (index) {
                    (_a = child.parent) === null || _a === void 0 ? void 0 : _a.removeChild(child);
                }
            });
        }
        const childrenBounds = this.childrenBounds;
        const { scrollX, scrollY } = scrollContainer.attribute;
        if (isHorozntal) {
            const ratio = Math.min(this.scrollContainerBounds.width() / childrenBounds.width(), 1);
            const start = Math.max(Math.min(scrollX / this.childrenBounds.width(), 0), ratio - 1);
            attrs.x = x + dx;
            attrs.y = y + dy + height - ((_b = attrs.height) !== null && _b !== void 0 ? _b : 0);
            attrs.range = [-start, -start + ratio];
        }
        else {
            const ratio = Math.min(this.scrollContainerBounds.height() / childrenBounds.height(), 1);
            const start = Math.max(Math.min(scrollY / this.childrenBounds.height(), 0), ratio - 1);
            attrs.x = x + dx + width - this.scrollContainerBounds.width();
            attrs.y = y + dy;
            attrs.range = [-start, -start + ratio];
        }
        scrollBar.setAttributes(attrs);
        return {
            scrollBar,
            isUpdate
        };
    }
    clearScrollbar(scrollContainer, type) {
        if (!scrollContainer.parent) {
            return;
        }
        const scrollbarBars = scrollContainer.parent.children.filter((child) => {
            return child.isScrollBar && (type === 'all' || child.attribute.direction === type);
        });
        scrollbarBars.forEach((child) => {
            child.parent.removeChild(child);
        });
    }
    formatScrollContainer(g) {
        if (!g || g.type !== 'group' || !g.attribute) {
            return null;
        }
        const { overflow, width, height } = g.attribute;
        if (!overflow || overflow === 'hidden') {
            return null;
        }
        let showH = false;
        let showV = false;
        if (overflow === 'scroll') {
            showH = true;
            showV = true;
        }
        else {
            showH = overflow === 'scroll-x';
            showV = !showH;
        }
        const childrenBounds = this.childrenBounds;
        childrenBounds.clear();
        g.forEachChildren((g) => {
            childrenBounds.union(g.AABBBounds);
        });
        if (!g.AABBBounds.empty()) {
            if (showH) {
                showH = width < childrenBounds.width();
            }
            if (showV) {
                showV = height < childrenBounds.height();
            }
        }
        return showH || showV ? { g: g, showH, showV } : null;
    }
    getScrollContainer(graphic) {
        let g = graphic;
        while (g) {
            const res = this.formatScrollContainer(g);
            if (res) {
                return res;
            }
            g = g.parent;
        }
        return null;
    }
    deactivate(context) {
        const { stage } = this.pluginService;
        stage.removeEventListener('wheel', this.scroll);
    }
};
ScrollBarPlugin.defaultParams = {
    timeout: 500
};
ScrollBarPlugin = ScrollBarPlugin_1 = __decorate([
    injectable()
], ScrollBarPlugin);

const scrollbarModule = new ContainerModule((bind, unbind, isBound, rebind) => {
    if (!isBound(ScrollBarPlugin)) {
        bind(ScrollBarPlugin).toSelf();
        bind(AutoEnablePlugins).toService(ScrollBarPlugin);
    }
});
function loadScrollbar() {
    container.load(scrollbarModule);
}

function traverseGroup(group, cb) {
    group.forEachChildren(node => {
        const stopped = cb(node);
        if (node.isContainer && !stopped) {
            traverseGroup(node, cb);
        }
    });
}
const isVisible = (obj) => {
    if (isNil(obj)) {
        return false;
    }
    return obj.visible !== false;
};
function getMarksByName(root, name) {
    if (!name) {
        return [];
    }
    const group = root.find(node => node.name === name, true);
    if (!group) {
        return [];
    }
    return group.getChildren();
}
function getNoneGroupMarksByName(root, name) {
    if (!name) {
        return [];
    }
    const group = root.find(node => node.name === name, true);
    if (!group) {
        return [];
    }
    return group.findAll(node => node.type !== 'group', true);
}
function removeRepeatPoint(points) {
    const result = [points[0]];
    for (let i = 1; i < points.length; i++) {
        if (points[i].x !== points[i - 1].x || points[i].y !== points[i - 1].y) {
            result.push(points[i]);
        }
    }
    return result;
}
function isPostiveXAxis(angle) {
    return (angle >= 0 && angle < Math.PI / 2) || (angle > (Math.PI * 3) / 2 && angle <= Math.PI * 2);
}
function fuzzyEqualNumber(a, b, delta) {
    return Math.abs(a - b) < delta;
}
function getTextAlignAttrOfVerticalDir(autoRotate, lineEndAngle, itemPosition) {
    if (autoRotate) {
        return {
            textAlign: 'right',
            textBaseline: 'middle'
        };
    }
    return {
        textAlign: (lineEndAngle < Math.PI && itemPosition.toLocaleLowerCase().includes('top')) ||
            (lineEndAngle > Math.PI && itemPosition.toLocaleLowerCase().includes('bottom'))
            ? 'left'
            :
                (lineEndAngle < Math.PI && itemPosition.toLocaleLowerCase().includes('bottom')) ||
                    (lineEndAngle > Math.PI && itemPosition.toLocaleLowerCase().includes('top'))
                    ? 'right'
                    : 'center',
        textBaseline: (lineEndAngle < Math.PI && itemPosition.includes('inside')) ||
            (lineEndAngle > Math.PI && !itemPosition.includes('inside'))
            ? 'bottom'
            : 'top'
    };
}

const defaultAlternativeColors = ['#ffffff', '#000000'];
function labelSmartInvert(foregroundColorOrigin, backgroundColorOrogin, textType, contrastRatiosThreshold, alternativeColors, mode) {
    if (typeof foregroundColorOrigin !== 'string' || typeof backgroundColorOrogin !== 'string') {
        return foregroundColorOrigin;
    }
    const foregroundColor = new Color(foregroundColorOrigin).toHex();
    const backgroundColor = new Color(backgroundColorOrogin).toHex();
    if (!contrastAccessibilityChecker(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, mode)) {
        return improveContrastReverse(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode);
    }
    return foregroundColor;
}
function improveContrastReverse(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode) {
    const alternativeColorPalletes = [];
    if (alternativeColors) {
        if (alternativeColors instanceof Array) {
            alternativeColorPalletes.push(...alternativeColors);
        }
        else {
            alternativeColorPalletes.push(alternativeColors);
        }
    }
    alternativeColorPalletes.push(...defaultAlternativeColors);
    for (const alternativeColor of alternativeColorPalletes) {
        if (foregroundColor === alternativeColor) {
            continue;
        }
        if (contrastAccessibilityChecker(alternativeColor, backgroundColor, textType, contrastRatiosThreshold, mode)) {
            return alternativeColor;
        }
    }
    return undefined;
}
function contrastAccessibilityChecker(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, mode) {
    if (mode === 'lightness') {
        const backgroundColorLightness = Color.getColorBrightness(new Color(backgroundColor));
        const foregroundColorLightness = Color.getColorBrightness(new Color(foregroundColor));
        if (foregroundColorLightness < 0.5) {
            if (backgroundColorLightness >= 0.5) {
                return true;
            }
            return false;
        }
        if (backgroundColorLightness < 0.5) {
            return true;
        }
        return false;
    }
    if (contrastRatiosThreshold) {
        if (contrastRatios(foregroundColor, backgroundColor) > contrastRatiosThreshold) {
            return true;
        }
        return false;
    }
    else if (textType === 'largeText') {
        if (contrastRatios(foregroundColor, backgroundColor) > 3) {
            return true;
        }
        return false;
    }
    if (contrastRatios(foregroundColor, backgroundColor) > 4.5) {
        return true;
    }
    return false;
}
function contrastRatios(foregroundColor, backgroundColor) {
    const foregroundColorLuminance = getColorLuminance(foregroundColor);
    const backgroundColorLuminance = getColorLuminance(backgroundColor);
    const L1 = foregroundColorLuminance > backgroundColorLuminance ? foregroundColorLuminance : backgroundColorLuminance;
    const L2 = foregroundColorLuminance > backgroundColorLuminance ? backgroundColorLuminance : foregroundColorLuminance;
    const contrastRatios = (L1 + 0.05) / (L2 + 0.05);
    return contrastRatios;
}
function getColorLuminance(color) {
    const rgb8bit = hexToRgb(color);
    const RsRGB = rgb8bit[0] / 255;
    const GsRGB = rgb8bit[1] / 255;
    const BsRGB = rgb8bit[2] / 255;
    let R;
    let G;
    let B;
    if (RsRGB <= 0.03928) {
        R = RsRGB / 12.92;
    }
    else {
        R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
        G = GsRGB / 12.92;
    }
    else {
        G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
        B = BsRGB / 12.92;
    }
    else {
        B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    const L = 0.2126 * R + 0.7152 * G + 0.0722 * B;
    return L;
}
function smartInvertStrategy(fillStrategy, baseColor, invertColor, similarColor) {
    let result;
    switch (fillStrategy) {
        case 'base':
            result = baseColor;
            break;
        case 'invertBase':
            result = invertColor;
            break;
        case 'similarBase':
            result = similarColor;
    }
    return result;
}

function scale(vector, scale) {
    return [vector[0] * scale, vector[1] * scale];
}
function length(vector) {
    const [x, y] = vector;
    return Math.sqrt(x * x + y * y);
}
function normalize(vector) {
    let len = length(vector);
    if (len > 0) {
        len = 1 / len;
    }
    return [vector[0] * len, vector[1] * len];
}
function angle(vector1, vector2) {
    const [x1, y1] = vector1;
    const [x2, y2] = vector2;
    const mag = Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2));
    const cosine = mag && (x1 * x2 + y1 * y2) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function angleTo(v1, v2, direct) {
    const ang = angle(v1, v2);
    const angleLargeThanPI = crossProduct(v1, v2) >= 0;
    if (direct) {
        if (angleLargeThanPI) {
            return Math.PI * 2 - ang;
        }
        return ang;
    }
    if (angleLargeThanPI) {
        return ang;
    }
    return Math.PI * 2 - ang;
}

const initTextMeasure = (textSpec, option, useNaiveCanvas, defaultFontParams) => {
    return new TextMeasure(Object.assign({ defaultFontParams: Object.assign({ fontFamily: DEFAULT_TEXT_FONT_FAMILY, fontSize: DEFAULT_TEXT_FONT_SIZE }, defaultFontParams), getTextBounds: useNaiveCanvas ? undefined : getTextBounds, specialCharSet: '-/: .,@%\'"~' + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase() }, (option !== null && option !== void 0 ? option : {})), textSpec);
};
function measureTextSize(text, textSpec, defaultTextTheme = {}) {
    if (!text) {
        return { width: 0, height: 0 };
    }
    const bounds = getTextBounds({
        text,
        fontFamily: textSpec.fontFamily || defaultTextTheme.fontFamily || DEFAULT_TEXT_FONT_FAMILY,
        fontSize: textSpec.fontSize || defaultTextTheme.fontSize || 12,
        fontWeight: textSpec.fontWeight || defaultTextTheme.fontWeight,
        textAlign: textSpec.textAlign || 'center',
        textBaseline: textSpec.textBaseline,
        ellipsis: !!textSpec.ellipsis,
        maxLineWidth: textSpec.maxLineWidth || Infinity,
        lineHeight: textSpec.fontSize || defaultTextTheme.fontSize || 12
    });
    return { width: bounds.width(), height: bounds.height() };
}
function isRichText(attributes, typeKey = 'type') {
    return getTextType(attributes, typeKey) === 'rich';
}
function getTextType(attributes, typeKey = 'type') {
    var _a, _b;
    if (isObject(attributes.text) && 'type' in attributes.text) {
        return (_a = attributes.text.type) !== null && _a !== void 0 ? _a : 'text';
    }
    if (typeKey in attributes) {
        return (_b = attributes[typeKey]) !== null && _b !== void 0 ? _b : 'text';
    }
    return 'text';
}
function richTextAttributeTransform(attributes) {
    var _a, _b;
    if (isValid(attributes.maxLineWidth)) {
        attributes.maxWidth = attributes.maxLineWidth;
        delete attributes.maxLineWidth;
    }
    attributes.width = (_a = attributes.width) !== null && _a !== void 0 ? _a : 0;
    attributes.height = (_b = attributes.height) !== null && _b !== void 0 ? _b : 0;
    attributes.textConfig = attributes.text.text || attributes.text;
    return attributes;
}
function htmlAttributeTransform(attributes) {
    const { text, _originText } = attributes;
    const { text: html } = text;
    attributes.html = html;
    attributes.text = _originText;
    attributes.renderable = false;
    return attributes;
}
function reactAttributeTransform(attributes) {
    const { text, _originText } = attributes;
    const { text: react } = text;
    attributes.react = react;
    attributes.text = _originText;
    attributes.renderable = false;
    return attributes;
}
function createTextGraphicByType(textAttributes, typeKey = 'type') {
    const textType = getTextType(textAttributes, typeKey);
    if (textType === 'rich') {
        return graphicCreator.richtext(richTextAttributeTransform(textAttributes));
    }
    if (textType === 'html') {
        textAttributes = htmlAttributeTransform(textAttributes);
    }
    else if (textType === 'react') {
        textAttributes = reactAttributeTransform(textAttributes);
    }
    return graphicCreator.text(textAttributes);
}
function alignTextInLine(layoutAlign, graphic, textAlign, pos, textWidth) {
    if (layoutAlign === 'right') {
        if (textAlign === 'center') {
            graphic.setAttribute('x', pos - textWidth / 2);
        }
        else if (textAlign === 'right' || textAlign === 'end') {
            graphic.setAttribute('x', pos);
        }
        else {
            graphic.setAttribute('x', pos - textWidth);
        }
    }
    else {
        if (textAlign === 'center') {
            graphic.setAttribute('x', pos + textWidth / 2);
        }
        else if (textAlign === 'right' || textAlign === 'end') {
            graphic.setAttribute('x', pos + textWidth);
        }
        else {
            graphic.setAttribute('x', pos);
        }
    }
}

const deltaXYToAngle = (y, x) => {
    const angle = Math.atan2(y, x);
    return angle < 0 ? angle + Math.PI * 2 : angle;
};
const tan2AngleToAngle = (angle) => {
    return angle < 0 ? angle + Math.PI * 2 : angle;
};

function computeOffsetForlimit(shape, bounds) {
    const { x1: regionMinX, y1: regionMinY, x2: regionMaxX, y2: regionMaxY } = bounds;
    const { x1, y1, x2, y2 } = shape.AABBBounds;
    let dx = 0;
    let dy = 0;
    if (x1 < regionMinX) {
        dx = regionMinX - x1;
    }
    if (y1 < regionMinY) {
        dy = regionMinY - y1;
    }
    if (x2 > regionMaxX) {
        dx = regionMaxX - x2;
    }
    if (y2 > regionMaxY) {
        dy = regionMaxY - y2;
    }
    return {
        dx,
        dy
    };
}
function limitShapeInBounds(shape, bounds) {
    const { dx, dy } = computeOffsetForlimit(shape, bounds);
    const { dx: originDx = 0, dy: originDy = 0 } = shape.attribute;
    if (dx) {
        shape.setAttribute('dx', dx + originDx);
    }
    if (dy) {
        shape.setAttribute('dy', dy + originDy);
    }
}

function loadTagComponent() {
    registerGroup();
    registerRect();
    registerSymbol();
    registerRichtext();
    registerText();
}

loadTagComponent();
class Tag extends AbstractComponent {
    getBgRect() {
        return this._bgRect;
    }
    getTextShape() {
        return this._textShape;
    }
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, Tag.defaultAttributes, attributes));
        this.name = 'tag';
        this._tagStates = [];
        this._rectStates = [];
        this._symbolStates = [];
        this._textStates = [];
    }
    render() {
        var _a, _b, _c;
        this.cacheStates();
        const { text = '', textStyle = {}, shape = {}, panel = {}, space = 4, minWidth, maxWidth, padding = 4, visible, state, type, textAlwaysCenter, containerTextAlign } = this.attribute;
        const parsedPadding = normalizePadding(padding);
        const group = this.createOrUpdateChild('tag-content', { x: 0, y: 0, zIndex: 1 }, 'group');
        let symbol;
        let tagX = -parsedPadding[3];
        let tagY = -parsedPadding[0];
        let tagWidth = parsedPadding[1] + parsedPadding[3];
        let tagHeight = parsedPadding[0] + parsedPadding[2];
        let textX = 0;
        let symbolPlaceWidth = 0;
        const { visible: shapeVisible } = shape, shapeStyle = __rest(shape, ["visible"]);
        if (isBoolean(shapeVisible)) {
            const size = (shapeStyle === null || shapeStyle === void 0 ? void 0 : shapeStyle.size) || 10;
            const maxSize = (isNumber(size) ? size : Math.max(size[0], size[1]));
            symbol = group.createOrUpdateChild('tag-shape', Object.assign(Object.assign({ symbolType: 'circle', size, strokeBoundsBuffer: 0 }, shapeStyle), { visible: shapeVisible, x: maxSize / 2, y: maxSize / 2 }), 'symbol');
            if (!isEmpty(state === null || state === void 0 ? void 0 : state.shape)) {
                symbol.states = state.shape;
            }
            if (shapeVisible) {
                symbolPlaceWidth = maxSize + space;
            }
        }
        tagWidth += symbolPlaceWidth;
        textX += symbolPlaceWidth;
        let textShape;
        let textWidth;
        let textHeight;
        const isRich = isRichText({ text }) || type === 'rich';
        if (isRich) {
            const richTextAttrs = Object.assign(Object.assign(Object.assign({}, richTextAttributeTransform(Object.assign({ type, text }, textStyle))), textStyle), { visible: isValid(text) && visible !== false, x: textX, y: 0 });
            if (isNil(richTextAttrs.lineHeight)) {
                richTextAttrs.lineHeight = textStyle.fontSize;
            }
            textShape = group.createOrUpdateChild('tag-text', richTextAttrs, 'richtext');
            textWidth = textShape.AABBBounds.width();
            textHeight = textShape.AABBBounds.height();
        }
        else {
            const textAttrs = Object.assign(Object.assign({ text: isObject(text) && 'type' in text && text.type === 'text' ? text.text : text, visible: isValid(text) && visible !== false, lineHeight: textStyle === null || textStyle === void 0 ? void 0 : textStyle.fontSize }, textStyle), { x: textX, y: 0 });
            if (isNil(textAttrs.lineHeight)) {
                textAttrs.lineHeight = textStyle.fontSize;
            }
            textShape = group.createOrUpdateChild('tag-text', textAttrs, 'text');
            const textBounds = measureTextSize(textAttrs.text, textStyle, (_b = (_a = this.stage) === null || _a === void 0 ? void 0 : _a.getTheme()) === null || _b === void 0 ? void 0 : _b.text);
            textWidth = textBounds.width;
            textHeight = textBounds.height;
        }
        tagWidth += textWidth;
        const size = (_c = shape.size) !== null && _c !== void 0 ? _c : 10;
        const maxSize = (isNumber(size) ? size : Math.max(size[0], size[1]));
        tagHeight += Math.max(textHeight, shape.visible ? maxSize : 0);
        const { textAlign, textBaseline } = textStyle;
        if (isValid(minWidth) || isValid(maxWidth)) {
            if (isValid(minWidth) && tagWidth < minWidth) {
                tagWidth = minWidth;
            }
            if (isValid(maxWidth) && tagWidth > maxWidth) {
                tagWidth = maxWidth;
                textShape.setAttribute('maxLineWidth', maxWidth - parsedPadding[1] - parsedPadding[2]);
            }
        }
        tagX = 0;
        tagY = 0;
        let flag = 0;
        if (textAlign === 'left' || textAlign === 'start') {
            flag = 1;
        }
        else if (textAlign === 'right' || textAlign === 'end') {
            flag = -1;
        }
        else if (textAlign === 'center') {
            flag = 0;
        }
        if (!flag) {
            tagX -= tagWidth / 2;
            if (symbol) {
                symbol.setAttribute('x', (symbol.attribute.x || 0) - textWidth / 2);
            }
            group.setAttribute('x', -symbolPlaceWidth / 2);
        }
        else if (flag < 0) {
            tagX -= tagWidth;
            if (symbol) {
                symbol.setAttribute('x', (symbol.attribute.x || 0) - textWidth);
            }
            group.setAttribute('x', -parsedPadding[1] - symbolPlaceWidth);
        }
        else if (flag > 0) {
            group.setAttribute('x', parsedPadding[3]);
        }
        const shouldCenter = containerTextAlign ? containerTextAlign === 'center' : textAlwaysCenter;
        const shouldRight = containerTextAlign === 'right' || containerTextAlign === 'end';
        const shouldLeft = containerTextAlign === 'left' || containerTextAlign === 'start';
        const updateTextAttrs = (textX, textAlign) => {
            if (textShape.type === 'richtext') {
                textShape.setAttributes({
                    x: textX,
                    textAlign,
                    textConfig: array(textShape.attribute.textConfig).map(t => {
                        return Object.assign(Object.assign({}, t), { textAlign });
                    })
                });
            }
            else {
                textShape.setAttributes({
                    x: textX,
                    textAlign
                });
            }
        };
        if (shouldCenter && flag) {
            const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3];
            const tsWidth = textWidth + symbolPlaceWidth;
            const textX = flag === 1
                ? (containerWidth - tsWidth) / 2 + symbolPlaceWidth + textWidth / 2
                : parsedPadding[0] + symbolPlaceWidth - (tagWidth / 2 + tsWidth / 2 - symbolPlaceWidth) + textWidth / 2;
            updateTextAttrs(textX, 'center');
            if (symbol) {
                const symbolX = textX - textWidth / 2 - symbolPlaceWidth + maxSize / 2;
                symbol.setAttributes({
                    x: symbolX
                });
            }
        }
        if (shouldLeft && flag !== 1) {
            const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3];
            const offset = flag === 0
                ? -containerWidth / 2 + symbolPlaceWidth / 2
                : -tagWidth + parsedPadding[3] + parsedPadding[1] + symbolPlaceWidth;
            const textX = offset + symbolPlaceWidth;
            updateTextAttrs(textX, 'left');
            if (symbol) {
                const symbolX = offset + maxSize / 2;
                symbol.setAttributes({
                    x: symbolX
                });
            }
        }
        if (shouldRight && flag !== -1) {
            const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3];
            const textX = flag === 0 ? containerWidth / 2 + symbolPlaceWidth / 2 : containerWidth;
            updateTextAttrs(textX, 'right');
            if (symbol) {
                const symbolX = textX - textWidth - symbolPlaceWidth + maxSize / 2;
                symbol.setAttributes({
                    x: symbolX
                });
            }
        }
        if (textBaseline === 'middle') {
            tagY -= tagHeight / 2;
            if (symbol) {
                symbol.setAttribute('y', 0);
            }
        }
        else if (textBaseline === 'bottom') {
            tagY -= tagHeight;
            if (symbol) {
                symbol.setAttribute('y', -textHeight / 2);
            }
            group.setAttribute('y', -parsedPadding[2]);
        }
        else if (textBaseline === 'top') {
            group.setAttribute('y', parsedPadding[0]);
            if (symbol) {
                symbol.setAttribute('y', textHeight / 2);
            }
        }
        if (!isEmpty(state === null || state === void 0 ? void 0 : state.text)) {
            textShape.states = state.text;
        }
        const { visible: bgVisible } = panel, backgroundStyle = __rest(panel, ["visible"]);
        if (visible && isBoolean(bgVisible)) {
            const bgRect = this.createOrUpdateChild('tag-panel', Object.assign(Object.assign({}, backgroundStyle), { visible: bgVisible && !!text, width: tagWidth, height: tagHeight, x: tagX, y: tagY }), 'rect');
            if (!isEmpty(state === null || state === void 0 ? void 0 : state.panel)) {
                bgRect.states = state.panel;
            }
            if (backgroundStyle.customShape) {
                const customShape = backgroundStyle.customShape;
                bgRect.pathProxy = (attrs) => {
                    return customShape(this, attrs, new CustomPath2D());
                };
            }
            this._bgRect = bgRect;
        }
        this._textShape = textShape;
        this._symbol = symbol;
        this.resetStates();
    }
    initAttributes(params, options) {
        params = (options === null || options === void 0 ? void 0 : options.skipDefault) ? params : merge({}, Tag.defaultAttributes, params);
        super.initAttributes(params);
        this.render();
    }
    addState(stateName, keepCurrentStates, hasAnimation) {
        super.addState(stateName, keepCurrentStates, hasAnimation);
        if (this._textShape) {
            this._textShape.addState(stateName, keepCurrentStates, hasAnimation);
        }
        if (this._bgRect) {
            this._bgRect.addState(stateName, keepCurrentStates, hasAnimation);
        }
        if (this._symbol) {
            this._symbol.addState(stateName, keepCurrentStates, hasAnimation);
        }
    }
    removeState(stateName, hasAnimation) {
        super.removeState(stateName, hasAnimation);
        if (this._textShape) {
            this._textShape.removeState(stateName, hasAnimation);
        }
        if (this._bgRect) {
            this._bgRect.removeState(stateName, hasAnimation);
        }
        if (this._symbol) {
            this._symbol.removeState(stateName, hasAnimation);
        }
    }
    cacheStates() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        this._tagStates = (_b = (_a = this.currentStates) === null || _a === void 0 ? void 0 : _a.slice()) !== null && _b !== void 0 ? _b : [];
        this._rectStates = (_e = (_d = (_c = this._bgRect) === null || _c === void 0 ? void 0 : _c.currentStates) === null || _d === void 0 ? void 0 : _d.slice()) !== null && _e !== void 0 ? _e : [];
        this._symbolStates = (_h = (_g = (_f = this._symbol) === null || _f === void 0 ? void 0 : _f.currentStates) === null || _g === void 0 ? void 0 : _g.slice()) !== null && _h !== void 0 ? _h : [];
        this._textStates = (_l = (_k = (_j = this._textShape) === null || _j === void 0 ? void 0 : _j.currentStates) === null || _k === void 0 ? void 0 : _k.slice()) !== null && _l !== void 0 ? _l : [];
        this.clearStates();
        (_m = this._bgRect) === null || _m === void 0 ? void 0 : _m.clearStates();
        (_o = this._symbol) === null || _o === void 0 ? void 0 : _o.clearStates();
        (_p = this._textShape) === null || _p === void 0 ? void 0 : _p.clearStates();
    }
    resetStates() {
        var _a, _b, _c;
        this._tagStates.length && this.useStates(this._tagStates);
        this._rectStates.length && ((_a = this._bgRect) === null || _a === void 0 ? void 0 : _a.useStates(this._rectStates));
        this._symbolStates.length && ((_b = this._symbol) === null || _b === void 0 ? void 0 : _b.useStates(this._symbolStates));
        this._textStates.length && ((_c = this._textShape) === null || _c === void 0 ? void 0 : _c.useStates(this._textStates));
    }
}
Tag.defaultAttributes = {
    visible: true,
    textStyle: {
        fontSize: 12,
        fill: '#000',
        textAlign: 'left',
        textBaseline: 'top'
    },
    space: 4,
    padding: 4,
    shape: {
        fill: '#000'
    }
};

const DEFAULT_THEME = {
    visible: true,
    position: 'auto',
    titleStyle: {
        fontSize: 16,
        fill: '#08979c'
    },
    contentStyle: {
        fontSize: 12,
        fill: 'green'
    },
    panel: {
        visible: true,
        fill: '#e6fffb',
        size: 12,
        space: 0,
        stroke: '#87e8de',
        lineWidth: 1,
        cornerRadius: 4
    }
};
const theme = {
    poptip: merge({}, DEFAULT_THEME)
};

function loadPoptipComponent() {
    registerGroup();
    registerText();
    registerSymbol();
    registerRect();
}
function setPoptipTheme(defaultPoptipTheme) {
    merge(theme.poptip, DEFAULT_THEME, defaultPoptipTheme);
}

const _tBounds = new AABBBounds();
loadPoptipComponent();
const tlStr = 'M -0.5 -0.5, L -0.5 0.5, L 0.5 -0.5, Z';
const blStr = 'M -0.5 -0.5, L -0.5 0.5, L 0.5 0.5, Z';
const trStr = 'M -0.5 -0.5, L 0.5 -0.5, L 0.5 0.5, Z';
const brStr = 'M 0.5 -0.5, L 0.5 0.5, L -0.5 0.5, Z';
const conciseSymbolMap = {
    tl: tlStr,
    tr: trStr,
    bl: blStr,
    br: brStr,
    lt: tlStr,
    lb: blStr,
    rt: trStr,
    rb: brStr
};
class PopTip extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, PopTip.defaultAttributes, attributes));
        this.name = 'poptip';
        this.positionList = ['top', 'tl', 'tr', 'bottom', 'bl', 'br', 'left', 'lt', 'lb', 'right', 'rt', 'rb'];
    }
    render() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const { titleStyle = {}, position, contentStyle = {}, panel, logoSymbol, poptipAnchor = 'position', logoText, logoTextStyle = {}, triangleMode = 'default', space = 4, minWidth = 0, maxWidth = Infinity, padding = 4, maxWidthPercent, visible, state, dx = 0, dy = 0, positionBounds } = this.attribute;
        let { title = '', content = '' } = this.attribute;
        title = this.attribute.titleFormatMethod ? this.attribute.titleFormatMethod(title) : title;
        content = this.attribute.contentFormatMethod ? this.attribute.contentFormatMethod(content) : content;
        const parsedPadding = normalizePadding(padding);
        const group = this.createOrUpdateChild('poptip-content', { x: 0, y: 0, zIndex: 1 }, 'group');
        this.group = group;
        const maxLineWidth = maxWidth - parsedPadding[1] - parsedPadding[3];
        const titleVisible = isValid(title) && visible !== false;
        const titleAttrs = Object.assign(Object.assign({ text: isArray(title) ? title : [title], visible: titleVisible, wrap: true }, titleStyle), { x: parsedPadding[3], y: parsedPadding[0], maxLineWidth, textAlign: 'left', textBaseline: 'top' });
        const titleShape = group.createOrUpdateChild('poptip-title', titleAttrs, 'text');
        if (!isEmpty(state === null || state === void 0 ? void 0 : state.title)) {
            titleShape.states = state.title;
        }
        const titleBounds = titleShape.AABBBounds;
        const titleHeight = titleBounds.height();
        const titleWidth = titleBounds.width();
        let height = titleHeight + space;
        if (!titleVisible) {
            height = 0;
        }
        const contentVisible = isValid(content) && visible !== false;
        const contentAttrs = Object.assign(Object.assign({ text: isArray(content) ? content : [content], visible: contentVisible, wrap: true }, contentStyle), { x: parsedPadding[3], y: parsedPadding[0] + height, maxLineWidth, textAlign: 'left', textBaseline: 'top' });
        const contentShape = group.createOrUpdateChild('poptip-content', contentAttrs, 'text');
        if (!isEmpty(state === null || state === void 0 ? void 0 : state.content)) {
            contentShape.states = state.content;
        }
        const contentBounds = contentShape.AABBBounds;
        const contentHeight = contentBounds.height();
        const contentWidth = contentBounds.width();
        if (contentVisible) {
            height += contentHeight;
        }
        this.titleShape = titleShape;
        this.contentShape = contentShape;
        let popTipWidth = max(titleWidth + parsedPadding[1] + parsedPadding[3], contentWidth + parsedPadding[1] + parsedPadding[3]);
        if (popTipWidth > maxWidth) {
            popTipWidth = maxWidth;
        }
        else if (popTipWidth < minWidth) {
            popTipWidth = minWidth;
        }
        let poptipHeight = parsedPadding[0] + parsedPadding[2] + height;
        const { visible: bgVisible, square } = panel, backgroundStyle = __rest(panel, ["visible", "square"]);
        if (square) {
            const maxWH = max(popTipWidth, poptipHeight);
            popTipWidth = maxWH;
            const deltaH = maxWH - poptipHeight;
            poptipHeight = maxWH;
            titleShape.setAttributes({ dy: deltaH / 2 });
            contentShape.setAttributes({ dy: deltaH / 2 });
        }
        const symbolSize = (_a = backgroundStyle.size) !== null && _a !== void 0 ? _a : 12;
        const spaceSize = isArray(symbolSize)
            ? [symbolSize[0] + ((_b = backgroundStyle.space) !== null && _b !== void 0 ? _b : 0), symbolSize[1] + ((_c = backgroundStyle.space) !== null && _c !== void 0 ? _c : 0)]
            : symbolSize + ((_d = backgroundStyle.space) !== null && _d !== void 0 ? _d : 0);
        const lineWidth = (_e = backgroundStyle.lineWidth) !== null && _e !== void 0 ? _e : 1;
        const range = this.stage
            ? [
                (_f = this.stage.viewWidth) !== null && _f !== void 0 ? _f : this.stage.width,
                (_g = this.stage.viewHeight) !== null && _g !== void 0 ? _g : this.stage.height
            ]
            : undefined;
        if (range) {
            const b = this.AABBBounds;
            const leftWidth = (_h = this.attribute.x) !== null && _h !== void 0 ? _h : b.x1;
            const rightWidth = range[0] - b.x1;
            let maxSpace = Math.max(leftWidth, rightWidth);
            const buf = (isArray(symbolSize) ? symbolSize[0] : 12) + 3;
            maxSpace = Math.min(maxSpace - buf, maxSpace * maxWidthPercent);
            if (maxSpace < popTipWidth) {
                popTipWidth = maxSpace;
                const buf = parsedPadding[1] + parsedPadding[3];
                titleShape.setAttribute('maxLineWidth', maxSpace - buf);
                contentShape.setAttribute('maxLineWidth', maxSpace - buf);
                poptipHeight = parsedPadding[0] + parsedPadding[2];
                if (titleVisible) {
                    poptipHeight += titleShape.AABBBounds.height() + space;
                }
                poptipHeight += contentShape.AABBBounds.height();
            }
        }
        const layout = position === 'auto' || isArray(position);
        const positionList = isArray(position) ? position : this.positionList;
        let maxBBoxI;
        let maxBBoxSize = -Infinity;
        for (let i = 0; i < positionList.length + 1; i++) {
            const p = layout ? positionList[i === positionList.length ? maxBBoxI : i] : position;
            let symbolType = 'arrow2Left';
            let offsetX = (isArray(symbolSize) ? symbolSize[0] : symbolSize) / 4;
            let offsetY = 0;
            if (p === 'top' || p === 'bottom' || p === 'left' || p === 'right') {
                symbolType = 'arrow2Left';
            }
            else if (triangleMode === 'concise') {
                symbolType = conciseSymbolMap[p];
                offsetX = ['tl', 'bl', 'rt', 'rb'].includes(p)
                    ? (isArray(symbolSize) ? symbolSize[0] : symbolSize) / 2
                    : -(isArray(symbolSize) ? symbolSize[0] : symbolSize) / 2;
                offsetY = ['tl', 'tr', 'lb', 'rb'].includes(p)
                    ? -(isArray(symbolSize) ? symbolSize[1] : symbolSize) / 2
                    : (isArray(symbolSize) ? symbolSize[1] : symbolSize) / 2;
            }
            const { angle, offset } = this.getAngleAndOffset(p, popTipWidth, poptipHeight, isArray(spaceSize) ? spaceSize : [spaceSize, spaceSize - lineWidth], symbolType);
            let anchorPoint = { x: 0, y: 0 };
            if (poptipAnchor === 'bounds' && positionBounds) {
                anchorPoint = this.calculateAnchorPoint(p, positionBounds);
            }
            let bgSymbol;
            if (isBoolean(bgVisible)) {
                bgSymbol = group.createOrUpdateChild('poptip-symbol-panel', Object.assign(Object.assign({}, backgroundStyle), { visible: bgVisible && (contentVisible || titleVisible), x: offsetX, y: offsetY, strokeBoundsBuffer: -1, boundsPadding: -2, anchor: [0, 0], symbolType, angle: angle, dx: offset[0], dy: offset[1] - ((_j = backgroundStyle.space) !== null && _j !== void 0 ? _j : 0), size: symbolSize, zIndex: 9 }), 'symbol');
                if (!isEmpty(state === null || state === void 0 ? void 0 : state.panel)) {
                    bgSymbol.states = state.panel;
                }
                let bgRect;
                if (panel.panelSymbolType) {
                    bgRect = group.createOrUpdateChild('poptip-rect-panel', Object.assign(Object.assign({}, backgroundStyle), { visible: bgVisible && (contentVisible || titleVisible), x: 0, y: 0, symbolType: 'rect', size: [popTipWidth, poptipHeight], zIndex: -8 }), 'symbol');
                }
                else {
                    bgRect = group.createOrUpdateChild('poptip-rect-panel', Object.assign(Object.assign({}, backgroundStyle), { visible: bgVisible && (contentVisible || titleVisible), x: 0, y: 0, width: popTipWidth, height: poptipHeight, zIndex: -8 }), 'rect');
                }
                if (!isEmpty(state === null || state === void 0 ? void 0 : state.panel)) {
                    bgRect.states = state.panel;
                }
            }
            group.setAttributes({
                x: -offset[0] + dx + anchorPoint.x,
                y: -offset[1] + dy + anchorPoint.y,
                anchor: [offsetX, offsetY]
            });
            if (logoSymbol) {
                const { size = 12 } = logoSymbol;
                const sizeArray = isArray(size) ? size : [size, size];
                if (sizeArray[1] === 'auto') {
                    sizeArray[1] = poptipHeight;
                }
                if (sizeArray[0] === 'auto') {
                    sizeArray[0] = poptipHeight;
                }
                const sizeW = sizeArray[0];
                group.createOrUpdateChild('poptip-logo', Object.assign(Object.assign({}, logoSymbol), { x: 0, y: poptipHeight / 2, visible: bgVisible && (contentVisible || titleVisible), zIndex: 10, size: sizeArray }), 'symbol');
                group.setAttributes({
                    x: -offset[0] + dx + sizeW / 2,
                    y: -offset[1] + dy
                });
                if (logoText) {
                    group.createOrUpdateChild('poptip-logo-text', Object.assign(Object.assign({}, logoTextStyle), { x: 0, y: poptipHeight / 2, visible: bgVisible && (contentVisible || titleVisible), text: logoText, textAlign: 'center', textBaseline: 'middle', zIndex: 10 }), 'text');
                }
            }
            if (range) {
                _tBounds.setValue(0, 0, popTipWidth, poptipHeight).transformWithMatrix(group.globalTransMatrix);
                const b = _tBounds;
                const stageBounds = new Bounds().setValue(0, 0, range[0], range[1]);
                if (layout) {
                    if (rectInsideAnotherRect(b, stageBounds, false)) {
                        break;
                    }
                    else {
                        const bbox = getRectIntersect(b, stageBounds, false);
                        const size = (bbox.x2 - bbox.x1) * (bbox.y2 - bbox.y1);
                        if (size > maxBBoxSize) {
                            maxBBoxSize = size;
                            maxBBoxI = i;
                        }
                    }
                }
                if (['top', 'bottom', 'left', 'right'].includes(p)) {
                    const isVerticalPosition = p === 'top' || p === 'bottom';
                    const isHorizontalPosition = p === 'left' || p === 'right';
                    let mainDirectionOverlap = false;
                    if (isVerticalPosition) {
                        mainDirectionOverlap = (p === 'top' && b.y1 < 0) || (p === 'bottom' && b.y2 > stageBounds.y2);
                    }
                    else if (isHorizontalPosition) {
                        mainDirectionOverlap = (p === 'left' && b.x1 < 0) || (p === 'right' && b.x2 > stageBounds.x2);
                    }
                    if (!mainDirectionOverlap) {
                        let secondaryOffset = 0;
                        const szNumber = (isArray(symbolSize) ? symbolSize[1] : symbolSize) / 2;
                        if (isVerticalPosition) {
                            if (b.x1 < 0) {
                                secondaryOffset = -b.x1;
                            }
                            else if (b.x2 > stageBounds.x2) {
                                secondaryOffset = stageBounds.x2 - b.x2;
                            }
                            group.setAttribute('x', group.attribute.x + secondaryOffset);
                            bgSymbol.setAttribute('dx', min(max(bgSymbol.attribute.dx - secondaryOffset, szNumber), b.width() - szNumber));
                        }
                        else if (isHorizontalPosition) {
                            if (b.y1 < 0) {
                                secondaryOffset = -b.y1;
                            }
                            else if (b.y2 > stageBounds.y2) {
                                secondaryOffset = stageBounds.y2 - b.y2;
                            }
                            group.setAttribute('y', group.attribute.y + secondaryOffset);
                            bgSymbol.setAttribute('dy', min(max(bgSymbol.attribute.dy - secondaryOffset, szNumber), b.height() - szNumber));
                        }
                        break;
                    }
                }
                if (!layout) {
                    break;
                }
            }
            else {
                break;
            }
        }
    }
    calculateAnchorPoint(position, positionBounds) {
        if (!positionBounds) {
            return { x: 0, y: 0 };
        }
        const { x, y } = this.attribute;
        const { x1, y1, x2, y2 } = positionBounds;
        const width = x2 - x1;
        const height = y2 - y1;
        switch (position) {
            case 'top':
            case 'tl':
            case 'tr':
                return { x: x1 + width / 2 - x, y: y1 - y };
            case 'bottom':
            case 'bl':
            case 'br':
                return { x: x1 + width / 2 - x, y: y2 - y };
            case 'left':
            case 'lt':
            case 'lb':
                return { x: x1 - x, y: y1 + height / 2 - y };
            case 'right':
            case 'rt':
            case 'rb':
                return { x: x2 - x, y: y1 + height / 2 - y };
            default:
                return { x: 0, y: 0 };
        }
    }
    getAngleAndOffset(position, width, height, size, symbolType) {
        const sizeH = symbolType === 'arrow2Left' ? size[1] / 2 : size[1];
        switch (position) {
            case 'tl':
                return {
                    angle: symbolType === 'arrow2Left' ? (pi / 2) * 3 : 0,
                    offset: symbolType === 'arrow2Left' ? [width / 4, height + sizeH] : [0, height + sizeH]
                };
            case 'top':
                return { angle: (pi / 2) * 3, offset: [width / 2, height + sizeH] };
            case 'tr':
                return {
                    angle: symbolType === 'arrow2Left' ? (pi / 2) * 3 : 0,
                    offset: symbolType === 'arrow2Left' ? [(width / 4) * 3, height + sizeH] : [width, height + sizeH]
                };
            case 'rt':
                return {
                    angle: 0,
                    offset: symbolType === 'arrow2Left' ? [-sizeH, height / 5] : [-sizeH, 0]
                };
            case 'right':
                return { angle: 0, offset: [-sizeH, height / 2] };
            case 'rb':
                return {
                    angle: 0,
                    offset: symbolType === 'arrow2Left' ? [-sizeH, (height / 5) * 4] : [-sizeH, height]
                };
            case 'bl':
                return {
                    angle: symbolType === 'arrow2Left' ? pi / 2 : 0,
                    offset: symbolType === 'arrow2Left' ? [width / 4, -sizeH] : [0, -sizeH]
                };
            case 'bottom':
                return { angle: pi / 2, offset: [width / 2, -sizeH] };
            case 'br':
                return {
                    angle: symbolType === 'arrow2Left' ? pi / 2 : 0,
                    offset: symbolType === 'arrow2Left' ? [(width / 4) * 3, -sizeH] : [width, -sizeH]
                };
            case 'lt':
                return {
                    angle: symbolType === 'arrow2Left' ? pi : 0,
                    offset: symbolType === 'arrow2Left' ? [width + sizeH, height / 5] : [width + sizeH, 0]
                };
            case 'left':
                return { angle: pi, offset: [width + sizeH, height / 2] };
            case 'lb':
                return {
                    angle: symbolType === 'arrow2Left' ? pi : 0,
                    offset: symbolType === 'arrow2Left' ? [width + sizeH, (height / 5) * 4] : [width + sizeH, height]
                };
        }
    }
}
PopTip.defaultAttributes = {
    position: 'rt',
    visible: true,
    title: null,
    content: null,
    titleStyle: {
        fontSize: 12,
        fill: '#000',
        textAlign: 'left',
        textBaseline: 'top'
    },
    contentStyle: {
        fontSize: 12,
        fill: '#000',
        textAlign: 'left',
        textBaseline: 'top'
    },
    panel: {},
    maxWidthPercent: 0.8,
    space: 8,
    padding: 10
};

function wrapPoptip(target, source) {
    merge(target, theme.poptip, source);
    return target;
}
let PopTipRenderContribution = class PopTipRenderContribution {
    render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        var _a, _b;
        if (graphic._showPoptip === 1) {
            const { visible, visibleCb } = graphic.attribute.poptip || {};
            if (visible === false || (visibleCb && visibleCb(graphic) === false)) {
                return;
            }
            const attribute = {};
            merge(attribute, PopTip.defaultAttributes, graphic.attribute.poptip ? graphic.attribute.poptip : {});
            if (!this.poptipComponent) {
                this.poptipComponent = new PopTip(attribute);
            }
            else {
                this.poptipComponent.initAttributes(attribute);
            }
            let poptip = graphic.attribute.poptip || {};
            if (graphic.type === 'text' && poptip.title == null && poptip.content == null) {
                const out = {};
                wrapPoptip(out, poptip);
                poptip = out;
                poptip.content = (_a = poptip.content) !== null && _a !== void 0 ? _a : graphic.attribute.text;
            }
            const matrix = graphic.globalTransMatrix;
            this.poptipComponent.setAttributes(Object.assign(Object.assign({ visibleAll: true, pickable: false, childrenPickable: false, poptipAnchor: 'bounds' }, poptip), { x: matrix.e, y: matrix.f, positionBounds: graphic.globalAABBBounds }));
            drawContext.stage.tryInitInteractiveLayer();
            const interactiveLayer = drawContext.stage.getLayer('_builtin_interactive');
            if (interactiveLayer) {
                interactiveLayer.add(this.poptipComponent);
            }
        }
        else if (graphic._showPoptip === 2) {
            graphic._showPoptip = 0;
            if (this.poptipComponent) {
                this.poptipComponent.setAttributes({
                    visibleAll: false
                });
                (_b = this.poptipComponent.parent) === null || _b === void 0 ? void 0 : _b.removeChild(this.poptipComponent);
                this.poptipComponent = null;
            }
        }
    }
};
PopTipRenderContribution = __decorate([
    injectable()
], PopTipRenderContribution);

class PopTipPluginBase {
    constructor() {
        this.activeEvent = 'onRegister';
        this._uid = Generator.GenAutoIncrementId();
        this.poptip = (e) => {
            const graphic = e.target;
            if (this.needHide(graphic)) {
                this.unpoptip(e);
                return;
            }
            if (graphic === this.activeGraphic) {
                return;
            }
            if (this.needShow(graphic)) {
                graphic.setAttributes({});
                graphic._showPoptip = 1;
            }
            if (this.activeGraphic) {
                this.activeGraphic.setAttributes({});
                this.activeGraphic._showPoptip = 2;
            }
            this.setActiveGraphic(graphic, true);
        };
        this.unpoptip = (e) => {
            if (!this.activeGraphic) {
                return;
            }
            this.activeGraphic.setAttributes({});
            this.activeGraphic._showPoptip = 2;
            this.setActiveGraphic(null, true);
        };
    }
    activate(context) {
        this.pluginService = context;
        const { stage } = this.pluginService;
        stage.addEventListener('pointerover', this.poptip);
    }
    needHide(graphic) {
        return graphic.isContainer || !graphic.attribute;
    }
    needShow(graphic) {
        return !!graphic.attribute.poptip;
    }
    setActiveGraphic(graphic, rerender) {
        this.activeGraphic = graphic;
        this.pluginService.stage.renderNextFrame();
    }
    deactivate(context) {
        const { stage } = this.pluginService;
        stage.removeEventListener('pointerover', this.poptip);
    }
}
let PopTipPlugin = class PopTipPlugin extends PopTipPluginBase {
    constructor() {
        super(...arguments);
        this.name = 'poptip';
        this.key = this.name + this._uid;
    }
};
PopTipPlugin = __decorate([
    injectable()
], PopTipPlugin);
let PopTipForClipedTextPlugin = class PopTipForClipedTextPlugin extends PopTipPluginBase {
    constructor() {
        super(...arguments);
        this.name = 'poptipForText';
        this.key = this.name + this._uid;
        this.pointerlave = (e) => {
            const { stage } = this.pluginService;
            if (e.target === stage) {
                this.unpoptip(e);
            }
        };
    }
    activate(context) {
        super.activate(context);
        const { stage } = this.pluginService;
        stage.addEventListener('pointerleave', this.pointerlave);
    }
    needHide(graphic) {
        return (graphic.type !== 'text' ||
            !graphic.cliped ||
            graphic.isContainer ||
            !graphic.attribute ||
            graphic.attribute.disableAutoClipedPoptip);
    }
    needShow(graphic) {
        return true;
    }
    deactivate(context) {
        const { stage } = this.pluginService;
        super.deactivate(context);
        stage.removeEventListener('pointerleave', this.pointerlave);
    }
};
PopTipForClipedTextPlugin = __decorate([
    injectable()
], PopTipForClipedTextPlugin);

const popTipModule = new ContainerModule((bind, unbind, isBound, rebind) => {
    if (!isBound(PopTipRenderContribution)) {
        bind(PopTipRenderContribution).toSelf().inSingletonScope();
        bind(InteractiveSubRenderContribution).toService(PopTipRenderContribution);
    }
    if (!isBound(PopTipPlugin)) {
        bind(PopTipPlugin).toSelf();
        bind(AutoEnablePlugins).toService(PopTipPlugin);
    }
    if (!isBound(PopTipForClipedTextPlugin)) {
        bind(PopTipForClipedTextPlugin).toSelf();
        bind(AutoEnablePlugins).toService(PopTipForClipedTextPlugin);
    }
});
function loadPoptip() {
    container.load(popTipModule);
}

class CrosshairBase extends AbstractComponent {
    constructor() {
        super(...arguments);
        this.name = 'crosshair';
    }
    render() {
        this.renderCrosshair(this);
    }
}

function loadLineCrosshairComponent() {
    registerGroup();
    registerLine();
}
function loadCircleCrosshairComponent() {
    registerGroup();
    registerArc();
}
function loadPolygonCrosshairComponent() {
    registerGroup();
    registerPath();
}
function loadRectCrosshairComponent() {
    registerGroup();
    registerRect();
}
function loadSectorCrosshairComponent() {
    registerGroup();
    registerArc();
}
function loadPolygonSectorCrosshairComponent() {
    registerGroup();
    registerPath();
}

loadLineCrosshairComponent();
class LineCrosshair extends CrosshairBase {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, LineCrosshair.defaultAttributes, attributes));
    }
    renderCrosshair(container) {
        const { start, end, lineStyle } = this.attribute;
        const line = container.createOrUpdateChild('crosshair-line', Object.assign({ points: [start, end] }, lineStyle), 'line');
        return line;
    }
    setLocation(region) {
        const { start, end } = region;
        this.setAttributes({
            start,
            end
        });
    }
}
LineCrosshair.defaultAttributes = {
    lineStyle: {
        stroke: '#b2bacf',
        lineWidth: 1,
        lineDash: [2]
    }
};

loadRectCrosshairComponent();
class RectCrosshair extends CrosshairBase {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, RectCrosshair.defaultAttributes, attributes));
    }
    renderCrosshair(container) {
        const { start, end, rectStyle } = this.attribute;
        const rect = container.createOrUpdateChild('crosshair-rect', Object.assign({ x: start.x, y: start.y, width: end.x - start.x, height: end.y - start.y }, rectStyle), 'rect');
        return rect;
    }
    setLocation(region) {
        const { start, end } = region;
        this.setAttributes({
            start,
            end
        });
    }
}
RectCrosshair.defaultAttributes = {
    rectStyle: {
        fill: '#b2bacf',
        opacity: 0.2
    }
};

loadCircleCrosshairComponent();
class CircleCrosshair extends CrosshairBase {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, CircleCrosshair.defaultAttributes, attributes));
    }
    renderCrosshair(container) {
        const { center, radius, lineStyle } = this.attribute;
        const circle = container.createOrUpdateChild('crosshair-circle', Object.assign(Object.assign(Object.assign(Object.assign({}, center), { outerRadius: radius }), this.attribute), lineStyle), 'arc');
        return circle;
    }
    setLocation(point) {
        const { center } = this.attribute;
        const radius = PointService.distancePP(point, center);
        this.setAttribute('radius', radius);
    }
}
CircleCrosshair.defaultAttributes = {
    lineStyle: {
        stroke: ['#b2bacf', false, false, false],
        lineWidth: 1,
        lineDash: [2]
    }
};

loadSectorCrosshairComponent();
class SectorCrosshair extends CrosshairBase {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, SectorCrosshair.defaultAttributes, attributes));
    }
    renderCrosshair(container) {
        const { center, radius, innerRadius = 0, sectorStyle } = this.attribute;
        const { startAngle, endAngle } = this.attribute;
        const circle = container.createOrUpdateChild('crosshair-sector', Object.assign(Object.assign(Object.assign({}, center), { outerRadius: radius, innerRadius,
            startAngle,
            endAngle }), sectorStyle), 'arc');
        return circle;
    }
    setLocation(point) {
        const { center, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute;
        const sectorAngle = endAngle - startAngle;
        const pointAngle = radianToDegree(getAngleByPoint(center, point));
        this.setAttributes({
            startAngle: pointAngle - sectorAngle / 2,
            endAngle: pointAngle + sectorAngle / 2
        });
    }
}
SectorCrosshair.defaultAttributes = {
    sectorStyle: {
        fill: '#b2bacf',
        opacity: 0.2
    }
};

loadPolygonCrosshairComponent();
class PolygonCrosshair extends CrosshairBase {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, PolygonCrosshair.defaultAttributes, attributes));
    }
    renderCrosshair(container) {
        const { center, radius, sides = 6, lineStyle } = this.attribute;
        const { startAngle, endAngle } = this.attribute;
        const isClose = (endAngle - startAngle) % (Math.PI * 2) === 0;
        const eachAngle = (endAngle - startAngle) / sides;
        let path;
        for (let index = 0; index <= sides; index++) {
            const angle = startAngle + eachAngle * index;
            const point = polarToCartesian(center, radius, angle);
            if (index === 0) {
                path = `M${point.x},${point.y}`;
            }
            else {
                path += `L${point.x},${point.y}`;
            }
            if (index === sides && isClose) {
                path += 'Z';
            }
        }
        const polygon = container.createOrUpdateChild('crosshair-polygon', Object.assign({ path }, lineStyle), 'path');
        return polygon;
    }
    setLocation(point) {
        const { center } = this.attribute;
        const radius = PointService.distancePP(point, center);
        this.setAttribute('radius', radius);
    }
}
PolygonCrosshair.defaultAttributes = {
    lineStyle: {
        stroke: '#b2bacf',
        lineWidth: 1,
        lineDash: [2]
    }
};

function loadSegmentComponent() {
    registerGroup();
    registerLine();
    registerPolygon();
    registerSymbol();
}
function loadArcSegmentComponent() {
    registerGroup();
    registerLine();
    registerArc();
    registerSymbol();
}

loadSegmentComponent();
class Segment extends AbstractComponent {
    getStartAngle() {
        return normalizeAngle(this._startAngle);
    }
    getEndAngle() {
        return normalizeAngle(this._endAngle);
    }
    getMainSegmentPoints() {
        return this._mainSegmentPoints;
    }
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, Segment.defaultAttributes, attributes));
        this.name = 'segment';
        this.key = 'segment';
        this.lines = [];
    }
    render() {
        this.removeAllChild(true);
        this._reset();
        const { startSymbol, endSymbol, lineStyle, state, visible = true, multiSegment, mainSegmentIndex } = this.attribute;
        if (!visible) {
            return;
        }
        this._computeLineAngle();
        const points = this._getMainSegmentPoints();
        const startSymbolShape = this._renderSymbol(startSymbol, points, 'start');
        const endSymbolShape = this._renderSymbol(endSymbol, points, 'end');
        this.startSymbol = startSymbolShape;
        this.endSymbol = endSymbolShape;
        if (multiSegment) {
            const points = [...this.attribute.points];
            if (isValidNumber(mainSegmentIndex)) {
                points[mainSegmentIndex] = this._clipPoints(points[mainSegmentIndex]);
            }
            else {
                const clipPoints = this._clipPoints(flattenArray(points));
                points[0][0] = clipPoints[0];
                points[points.length - 1][points[points.length - 1].length - 1] =
                    clipPoints[clipPoints.length - 1];
            }
            points.forEach((point, index) => {
                var _a, _b;
                const line = graphicCreator.line(Object.assign(Object.assign({ points: point }, (isArray(lineStyle) ? (_a = lineStyle[index]) !== null && _a !== void 0 ? _a : lineStyle[lineStyle.length - 1] : lineStyle)), { fill: false }));
                line.name = `${this.name}-line`;
                line.id = this._getNodeId('line' + index);
                if (!isEmpty(state === null || state === void 0 ? void 0 : state.line)) {
                    line.states = isArray(state.line) ? (_b = state.line[index]) !== null && _b !== void 0 ? _b : state.line[state.line.length - 1] : state.line;
                }
                this.add(line);
                this.lines.push(line);
            });
        }
        else {
            let lineCreator = graphicCreator.line;
            if (array(lineStyle)[0].cornerRadius) {
                lineCreator = graphicCreator.polygon;
            }
            const line = lineCreator(Object.assign(Object.assign({ points: this._clipPoints(this.attribute.points) }, array(lineStyle)[0]), { fill: false, closePath: false }));
            line.name = `${this.name}-line`;
            line.id = this._getNodeId('line');
            if (!isEmpty(state === null || state === void 0 ? void 0 : state.line)) {
                line.states = [].concat(state.line)[0];
            }
            this.add(line);
            this.lines.push(line);
        }
    }
    _computeStartRotate(angle) {
        return angle + Math.PI / 2;
    }
    _computeEndRotate(angle) {
        return angle + Math.PI / 2;
    }
    _renderSymbol(attribute, points, dim) {
        if (!points.length) {
            return;
        }
        const { autoRotate = true } = attribute;
        let symbol;
        if (attribute && attribute.visible) {
            const startAngle = this.getStartAngle();
            const endAngle = this.getEndAngle();
            const { state } = this.attribute;
            const start = points[0];
            const end = points[points.length - 1];
            const { refX = 0, refY = 0, refAngle = 0, style, symbolType, size = 12 } = attribute;
            let position;
            let rotate;
            if (dim === 'start') {
                position = {
                    x: start.x +
                        (isValidNumber(startAngle) ? refX * Math.cos(startAngle) + refY * Math.cos(startAngle - Math.PI / 2) : 0),
                    y: start.y +
                        (isValidNumber(startAngle) ? refX * Math.sin(startAngle) + refY * Math.sin(startAngle - Math.PI / 2) : 0)
                };
                rotate = this._computeStartRotate(this._startAngle);
            }
            else {
                position = {
                    x: end.x + (isValidNumber(endAngle) ? refX * Math.cos(endAngle) + refY * Math.cos(endAngle - Math.PI / 2) : 0),
                    y: end.y + (isValidNumber(endAngle) ? refX * Math.sin(endAngle) + refY * Math.sin(endAngle - Math.PI / 2) : 0)
                };
                rotate = this._computeEndRotate(this._endAngle);
            }
            symbol = graphicCreator.symbol(Object.assign(Object.assign(Object.assign({}, position), { symbolType: symbolType, size, angle: autoRotate ? rotate + refAngle : 0, strokeBoundsBuffer: 0 }), style));
            symbol.name = `${this.name}-${dim}-symbol`;
            symbol.id = this._getNodeId(`${dim}-symbol`);
            if (!isEmpty(state === null || state === void 0 ? void 0 : state.symbol)) {
                symbol.states = state.symbol;
            }
            if (dim === 'start') {
                if (!isEmpty(state === null || state === void 0 ? void 0 : state.startSymbol)) {
                    symbol.states = state.startSymbol;
                }
            }
            else {
                if (!isEmpty(state === null || state === void 0 ? void 0 : state.endSymbol)) {
                    symbol.states = state.endSymbol;
                }
            }
            this.add(symbol);
        }
        return symbol;
    }
    _getMainSegmentPoints() {
        if (this._mainSegmentPoints) {
            return this._mainSegmentPoints;
        }
        const { points: originPoints, multiSegment, mainSegmentIndex } = this.attribute;
        let points;
        if (multiSegment) {
            if (isValidNumber(mainSegmentIndex)) {
                points = originPoints[mainSegmentIndex];
            }
            else {
                points = flattenArray(originPoints);
            }
        }
        else {
            points = originPoints;
        }
        this._mainSegmentPoints = points;
        return points;
    }
    _clipPoints(points) {
        const { startSymbol = {}, endSymbol = {} } = this.attribute;
        let pointsAfterClip = points;
        if (startSymbol.visible) {
            const startSize = startSymbol.clip ? startSymbol.size || 10 : 0;
            const pointsStart = {
                x: points[0].x - (startSize / 2) * (Math.cos(this._startAngle) || 0),
                y: points[0].y - (startSize / 2) * (Math.sin(this._startAngle) || 0)
            };
            pointsAfterClip = [pointsStart, ...pointsAfterClip.slice(1)];
        }
        if (endSymbol.visible) {
            const endSize = endSymbol.clip ? endSymbol.size || 10 : 0;
            const pointsEnd = {
                x: points[points.length - 1].x - (endSize / 2) * (Math.cos(this._endAngle) || 0),
                y: points[points.length - 1].y - (endSize / 2) * (Math.sin(this._endAngle) || 0)
            };
            pointsAfterClip = [...pointsAfterClip.slice(0, pointsAfterClip.length - 1), pointsEnd];
        }
        return pointsAfterClip;
    }
    _computeLineAngle() {
        const points = this._getMainSegmentPoints();
        if (points.length <= 1) {
            return;
        }
        const start = points[0];
        const startInside = points[1];
        const endInside = points[points.length - 2];
        const end = points[points.length - 1];
        const startVector = [start.x - startInside.x, start.y - startInside.y];
        const startAngle = Math.atan2(startVector[1], startVector[0]);
        const endVector = [end.x - endInside.x, end.y - endInside.y];
        const endAngle = Math.atan2(endVector[1], endVector[0]);
        this._startAngle = startAngle;
        this._endAngle = endAngle;
    }
    _reset() {
        this.startSymbol = null;
        this.endSymbol = null;
        this._startAngle = null;
        this._endAngle = null;
        this._mainSegmentPoints = null;
    }
}
Segment.defaultAttributes = {
    visible: true,
    lineStyle: {
        lineWidth: 1,
        stroke: '#000'
    },
    startSymbol: {
        visible: false,
        autoRotate: true,
        symbolType: 'triangle',
        size: 12,
        refX: 0,
        refY: 0,
        refAngle: 0,
        style: {
            fill: '#000',
            zIndex: 1
        }
    },
    endSymbol: {
        visible: false,
        autoRotate: true,
        symbolType: 'triangle',
        size: 12,
        refX: 0,
        refY: 0,
        refAngle: 0,
        style: {
            fill: '#000',
            zIndex: 1
        }
    }
};

loadArcSegmentComponent();
class ArcSegment extends Segment {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, Segment.defaultAttributes, attributes));
        this.name = 'arc-segment';
        this.key = 'arc-segment';
        this.isReverseArc = false;
    }
    getStartAngle() {
        const tangAng = this.isReverseArc ? this._startAngle + Math.PI / 2 : this._startAngle - Math.PI / 2;
        return tangAng < 0 ? tangAng + Math.PI * 2 : tangAng > Math.PI * 2 ? tangAng - Math.PI * 2 : tangAng;
    }
    getEndAngle() {
        const tangAng = this.isReverseArc ? this._endAngle - Math.PI / 2 : this._endAngle + Math.PI / 2;
        return tangAng < 0 ? tangAng + Math.PI * 2 : tangAng > Math.PI * 2 ? tangAng - Math.PI * 2 : tangAng;
    }
    getMainSegmentPoints() {
        return this._mainSegmentPoints;
    }
    _computeStartRotate(angle) {
        return this.isReverseArc ? angle + Math.PI : angle;
    }
    _computeEndRotate(angle) {
        return this.isReverseArc ? angle : angle + Math.PI;
    }
    render() {
        this.removeAllChild(true);
        this._reset();
        const { startSymbol, endSymbol, lineStyle, state, visible = true, radius, startAngle, endAngle, center } = this.attribute;
        if (!visible) {
            return;
        }
        this._startAngle = startAngle;
        this._endAngle = endAngle;
        this.isReverseArc = startAngle > endAngle;
        const startPoint = {
            x: center.x + radius * Math.cos(this._startAngle),
            y: center.y + radius * Math.sin(this._startAngle)
        };
        const endPoint = {
            x: center.x + radius * Math.cos(this._endAngle),
            y: center.y + radius * Math.sin(this._endAngle)
        };
        this._mainSegmentPoints = [startPoint, endPoint];
        const startSymbolShape = this._renderSymbol(startSymbol, this._mainSegmentPoints, 'start');
        const endSymbolShape = this._renderSymbol(endSymbol, this._mainSegmentPoints, 'end');
        this.startSymbol = startSymbolShape;
        this.endSymbol = endSymbolShape;
        const line = graphicCreator.arc(Object.assign({ x: center.x, y: center.y, startAngle,
            endAngle, innerRadius: radius, outerRadius: radius }, lineStyle));
        line.name = `${this.name}-line`;
        line.id = this._getNodeId('arc');
        if (!isEmpty(state === null || state === void 0 ? void 0 : state.line)) {
            line.states = [].concat(state.line)[0];
        }
        this.add(line);
        this.line = line;
    }
}

var AXIS_ELEMENT_NAME;
(function (AXIS_ELEMENT_NAME) {
    AXIS_ELEMENT_NAME["innerView"] = "inner-view";
    AXIS_ELEMENT_NAME["axisContainer"] = "axis-container";
    AXIS_ELEMENT_NAME["labelContainer"] = "axis-label-container";
    AXIS_ELEMENT_NAME["tickContainer"] = "axis-tick-container";
    AXIS_ELEMENT_NAME["tick"] = "axis-tick";
    AXIS_ELEMENT_NAME["subTick"] = "axis-sub-tick";
    AXIS_ELEMENT_NAME["label"] = "axis-label";
    AXIS_ELEMENT_NAME["title"] = "axis-title";
    AXIS_ELEMENT_NAME["gridContainer"] = "axis-grid-container";
    AXIS_ELEMENT_NAME["grid"] = "axis-grid";
    AXIS_ELEMENT_NAME["gridRegion"] = "axis-grid-region";
    AXIS_ELEMENT_NAME["line"] = "axis-line";
    AXIS_ELEMENT_NAME["background"] = "axis-background";
    AXIS_ELEMENT_NAME["axisLabelBackground"] = "axis-label-background";
    AXIS_ELEMENT_NAME["axisBreak"] = "axis-break";
    AXIS_ELEMENT_NAME["axisBreakSymbol"] = "axis-break-symbol";
})(AXIS_ELEMENT_NAME || (AXIS_ELEMENT_NAME = {}));
var AxisStateValue;
(function (AxisStateValue) {
    AxisStateValue["selected"] = "selected";
    AxisStateValue["selectedReverse"] = "selected_reverse";
    AxisStateValue["hover"] = "hover";
    AxisStateValue["hoverReverse"] = "hover_reverse";
})(AxisStateValue || (AxisStateValue = {}));
const DEFAULT_STATES$1 = {
    [AxisStateValue.selectedReverse]: {},
    [AxisStateValue.selected]: {},
    [AxisStateValue.hover]: {},
    [AxisStateValue.hoverReverse]: {}
};
const TopZIndex = 999;

const DEFAULT_AXIS_THEME = {
    title: {
        space: 4,
        padding: 0,
        textStyle: {
            fontSize: 12,
            fill: '#333333',
            fontWeight: 'normal',
            fillOpacity: 1
        }
    },
    label: {
        visible: true,
        inside: false,
        space: 4,
        padding: 0,
        style: {
            fontSize: 12,
            fill: '#333',
            fontWeight: 'normal',
            fillOpacity: 1
        }
    },
    tick: {
        visible: true,
        inside: false,
        alignWithLabel: true,
        length: 4,
        style: {
            lineWidth: 1,
            stroke: '#000',
            strokeOpacity: 1
        }
    },
    subTick: {
        visible: false,
        inside: false,
        count: 4,
        length: 2,
        style: {
            lineWidth: 1,
            stroke: '#999',
            strokeOpacity: 1
        }
    },
    line: {
        visible: true,
        style: {
            lineWidth: 1,
            stroke: '#000',
            strokeOpacity: 1
        }
    }
};
const DEFAULT_AXIS_BREAK_SYMBOL_STYLE = {
    size: 8,
    stroke: '#000',
    lineWidth: 1,
    zIndex: 1
};

function genNormalBounds(item) {
    const bounds = item.AABBBounds;
    return {
        x1: bounds.x1,
        x2: bounds.x2,
        y1: bounds.y1,
        y2: bounds.y2,
        centerX: item.attribute.x,
        centerY: item.attribute.y,
        angle: item.attribute.angle
    };
}
function genRotateBounds(items) {
    items.forEach(item => {
        if (item.rotatedBounds || !item.attribute.angle) {
            return;
        }
        const bounds = genNormalBounds(item);
        const rotatedCenter = rotatePoint({ x: item.attribute.x, y: item.attribute.y }, bounds.angle, {
            x: bounds.centerX,
            y: bounds.centerY
        });
        const deltaX = rotatedCenter.x - bounds.centerX;
        const deltaY = rotatedCenter.y - bounds.centerY;
        bounds.x1 += deltaX;
        bounds.x2 += deltaX;
        bounds.y1 += deltaY;
        bounds.y2 += deltaY;
        bounds.centerX += deltaX;
        bounds.centerY += deltaY;
        item.rotatedBounds = bounds;
    });
}
function itemIntersect(item1, item2) {
    var _a, _b;
    if (!((_a = item1.OBBBounds) === null || _a === void 0 ? void 0 : _a.empty()) && !((_b = item2.OBBBounds) === null || _b === void 0 ? void 0 : _b.empty())) {
        return item1.OBBBounds.intersects(item2.OBBBounds);
    }
    return (isRectIntersect(item1.AABBBounds, item2.AABBBounds, false) &&
        (item1.rotatedBounds && item2.rotatedBounds
            ? isRotateAABBIntersect(item1.rotatedBounds, item2.rotatedBounds, true)
            : true));
}
const DELTA_ANGLE = Math.sin(Math.PI / 10);
function isAngleVertical(angle, delta = DELTA_ANGLE) {
    const hasAngle = !isNil(angle) && angle !== 0;
    const cos = hasAngle ? Math.cos(angle) : 1;
    return hasAngle && Math.abs(cos) <= delta;
}
function isAngleHorizontal(angle, delta = DELTA_ANGLE) {
    const hasAngle = !isNil(angle) && angle !== 0;
    const sin = hasAngle ? Math.sin(angle) : 0;
    return !hasAngle || Math.abs(sin) <= delta;
}

const clampRadian = (angle = 0) => {
    if (angle < 0) {
        while (angle < 0) {
            angle += tau;
        }
    }
    else if (angle > 0) {
        while (angle > tau) {
            angle -= tau;
        }
    }
    return angle;
};
function isInRange(a, min, max) {
    return !isLess(a, min, 0, 1e-6) && !isGreater(a, max, 0, 1e-6);
}
function getCircleLabelPosition(tickPosition, tickVector) {
    return {
        x: tickPosition.x + tickVector[0],
        y: tickPosition.y + tickVector[1]
    };
}
function getAxisBreakSymbolAttrs(props = {}) {
    var _a, _b;
    const { style = {}, angle = Math.PI * 0.5 } = props;
    const symbolStyle = merge({}, DEFAULT_AXIS_BREAK_SYMBOL_STYLE, style);
    const symbolSize = (_a = symbolStyle.size) !== null && _a !== void 0 ? _a : DEFAULT_AXIS_BREAK_SYMBOL_STYLE.size;
    return Object.assign(Object.assign({}, symbolStyle), { symbolType: (_b = symbolStyle.symbolType) !== null && _b !== void 0 ? _b : `M ${-symbolSize / 2} ${symbolSize * Math.sin(angle)} L ${symbolSize / 2} ${-symbolSize * Math.sin(angle)}`, symbolSize });
}
function getElMap(g) {
    const elMap = {};
    traverseGroup(g, (el) => {
        if (el.type !== 'group' && el.id) {
            elMap[el.id] = el;
        }
    });
    return elMap;
}
function getVerticalCoord(point, vector) {
    return {
        x: point.x + vector[0],
        y: point.y + vector[1]
    };
}
function getCircleVerticalVector(offset, point, center, inside = false, axisInside = false) {
    const vector = [point.x - center.x, point.y - center.y];
    return scale(vector, ((inside ? -1 : 1) * (axisInside ? -1 : 1) * offset) / length(vector));
}
function angleLabelOrientAttribute(angle) {
    let align = 'center';
    let baseline = 'middle';
    angle = normalizeAngle(angle);
    if (angle >= Math.PI * (5 / 3) || angle <= Math.PI * (1 / 3)) {
        align = 'left';
    }
    else if (angle >= Math.PI * (2 / 3) && angle <= Math.PI * (4 / 3)) {
        align = 'right';
    }
    else {
        align = 'center';
    }
    if (angle >= Math.PI * (7 / 6) && angle <= Math.PI * (11 / 6)) {
        baseline = 'bottom';
    }
    else if (angle >= Math.PI * (1 / 6) && angle <= Math.PI * (5 / 6)) {
        baseline = 'top';
    }
    else {
        baseline = 'middle';
    }
    return { align, baseline };
}
function getPolarAngleLabelPosition(angle, center, radius, labelOffset, inside) {
    const point = polarToCartesian({ x: 0, y: 0 }, radius, angle);
    const labelPoint = getVerticalCoord(point, getCircleVerticalVector(labelOffset, point, center, inside));
    const vector = getCircleVerticalVector(labelOffset || 1, labelPoint, center, inside);
    return getCircleLabelPosition(labelPoint, vector);
}
function getCirclePoints(center, count, radius, startAngle, endAngle) {
    const points = [];
    const range = endAngle - startAngle;
    for (let i = 0; i < count; i++) {
        const angle = startAngle + (i * range) / count;
        points.push(polarToCartesian(center, radius, angle));
    }
    return points;
}
function getPolygonPath(points, closed) {
    let path = '';
    if (points.length === 0) {
        return path;
    }
    points.forEach((point, index) => {
        if (index === 0) {
            path = `M${point.x},${point.y}`;
        }
        else {
            path += `L${point.x},${point.y}`;
        }
    });
    if (closed) {
        path += 'Z';
    }
    return path;
}
function textIntersect(textA, textB, sep) {
    var _a;
    const angle = (_a = textA.attribute) === null || _a === void 0 ? void 0 : _a.angle;
    const isHorizontal = isAngleHorizontal(angle, Number.EPSILON);
    if (isHorizontal) {
        return sep > aabbSeparation(textA.AABBBounds, textB.AABBBounds);
    }
    const a = textA.OBBBounds;
    const b = textB.OBBBounds;
    if (!a || !b || a.empty() || b.empty()) {
        return sep > aabbSeparation(textA.AABBBounds, textB.AABBBounds);
    }
    return a.intersects(b) || sep > obbSeparation(a, b);
}
function hasOverlap(items, pad) {
    for (let i = 1, n = items.length, a = items[0], b; i < n; a = b, ++i) {
        b = items[i];
        if (textIntersect(a, b, pad)) {
            return true;
        }
    }
    return false;
}

const dispatchHoverState = (e, container, lastHover) => {
    const target = e.target;
    if (target !== lastHover && target.name && !isEmpty(target.states)) {
        target.addState(StateValue.hover, true);
        traverseGroup(container, (node) => {
            if (node !== target && node.name && !isEmpty(node.states)) {
                node.addState(StateValue.hoverReverse, true);
            }
        });
        return target;
    }
    return lastHover;
};
const dispatchUnHoverState = (e, container, lastHover) => {
    if (lastHover) {
        traverseGroup(container, (node) => {
            if (node.name && !isEmpty(node.states)) {
                node.removeState(StateValue.hoverReverse);
                node.removeState(StateValue.hover);
            }
        });
        return null;
    }
    return lastHover;
};
const dispatchClickState = (e, container, lastSelect) => {
    const target = e.target;
    if (lastSelect === target && target.hasState(StateValue.selected)) {
        traverseGroup(container, (node) => {
            if (node.name && !isEmpty(node.states)) {
                node.removeState(StateValue.selectedReverse);
                node.removeState(StateValue.selected);
            }
        });
        return null;
    }
    if (target.name && !isEmpty(target.states)) {
        target.addState(StateValue.selected, true);
        traverseGroup(container, (node) => {
            if (node !== target && node.name && !isEmpty(node.states)) {
                node.addState(StateValue.selectedReverse, true);
            }
        });
        return target;
    }
    return lastSelect;
};

class AnimateComponent extends AbstractComponent {
    _prepareAnimate(defaultAnimation) {
        if (this.attribute.animation !== false) {
            const { animation, animationEnter, animationExit, animationUpdate } = this.attribute;
            const animationCfg = isObject(animation) ? animation : {};
            this._animationConfig = {
                enter: animationEnter !== false ? merge({}, defaultAnimation, animationCfg, animationEnter !== null && animationEnter !== void 0 ? animationEnter : {}) : false,
                exit: animationExit !== false ? merge({}, defaultAnimation, animationCfg, animationExit !== null && animationExit !== void 0 ? animationExit : {}) : false,
                update: animationUpdate !== false
                    ? isArray(animationUpdate)
                        ? animationUpdate
                        : merge({}, defaultAnimation, animationCfg, animationUpdate !== null && animationUpdate !== void 0 ? animationUpdate : {})
                    : false
            };
        }
        else {
            this._animationConfig = {
                enter: false,
                exit: false,
                update: false
            };
        }
    }
}

const DefaultAxisAnimation = {
    type: 'default',
    duration: 300,
    easing: 'linear'
};

class AxisBase extends AnimateComponent {
    constructor() {
        super(...arguments);
        this.name = 'axis';
        this.data = [];
        this.tickLineItems = [];
        this.subTickLineItems = [];
        this.axisLabelLayerSize = {};
        this.axisLabelsContainer = null;
        this._onHover = (e) => {
            this._lastHover = dispatchHoverState(e, this.axisContainer, this._lastHover);
        };
        this._onUnHover = (e) => {
            this._lastHover = dispatchUnHoverState(e, this.axisContainer, this._lastHover);
        };
        this._onClick = (e) => {
            this._lastSelect = dispatchClickState(e, this.axisContainer, this._lastSelect);
        };
    }
    getInnerView() {
        return this._innerView;
    }
    getPrevInnerView() {
        return this._prevInnerView;
    }
    getBoundsWithoutRender(attributes) {
        const currentAttribute = cloneDeep(this.attribute);
        currentAttribute.scale = this.attribute.scale;
        this.attribute = attributes;
        const offscreenGroup = graphicCreator.group({
            x: this.attribute.x,
            y: this.attribute.y
        });
        this.add(offscreenGroup);
        this._renderInner(offscreenGroup);
        this.removeChild(offscreenGroup);
        this.attribute = currentAttribute;
        return offscreenGroup.AABBBounds;
    }
    render() {
        this._prepare();
        this._prevInnerView = this._innerView && getElMap(this._innerView);
        this.removeAllChild(true);
        this._innerView = graphicCreator.group({ x: 0, y: 0, pickable: false });
        this.add(this._innerView);
        this._renderInner(this._innerView);
        this._bindEvent();
        this.runAnimation();
    }
    _prepare() {
        this._prepareAnimate(DefaultAxisAnimation);
    }
    _bindEvent() {
        if (this.attribute.disableTriggerEvent) {
            return;
        }
        const { hover, select } = this.attribute;
        if (hover) {
            this._innerView.addEventListener('pointermove', this._onHover);
            this._innerView.addEventListener('pointerout', this._onUnHover);
        }
        if (select) {
            this._innerView.addEventListener('pointerdown', this._onClick);
        }
    }
    _renderInner(container) {
        const { title, label, tick, line, items } = this.attribute;
        const axisContainer = graphicCreator.group({ x: 0, y: 0, zIndex: 1, pickable: false });
        axisContainer.name = AXIS_ELEMENT_NAME.axisContainer;
        axisContainer.id = this._getNodeId('container');
        axisContainer.setMode(this.mode);
        this.axisContainer = axisContainer;
        container.add(axisContainer);
        if (line && line.visible) {
            this.renderLine(axisContainer);
        }
        if (items && items.length) {
            this.data = this._transformItems(items[0]);
            if (tick && tick.visible) {
                this.renderTicks(axisContainer);
            }
            if (label && label.visible) {
                const labelGroup = graphicCreator.group({ x: 0, y: 0, pickable: false });
                labelGroup.name = AXIS_ELEMENT_NAME.labelContainer;
                labelGroup.id = this._getNodeId('label-container');
                this.axisLabelsContainer = labelGroup;
                axisContainer.add(labelGroup);
                items.forEach((axisItems, layer) => {
                    const layerLabelGroup = this.renderLabels(labelGroup, axisItems, layer);
                    const labels = layerLabelGroup.getChildren();
                    this.beforeLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length);
                    this.handleLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length);
                    this.afterLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length);
                    let maxTextWidth = 0;
                    let maxTextHeight = 0;
                    let textAlign = 'center';
                    let textBaseline = 'middle';
                    let labelPos = 0;
                    labels.forEach((label, index) => {
                        var _a;
                        const labelStyle = label.attribute;
                        const angle = (_a = labelStyle.angle) !== null && _a !== void 0 ? _a : 0;
                        const textBounds = label.AABBBounds;
                        let textWidth = textBounds.width();
                        let textHeight = textBounds.height();
                        if (angle) {
                            textWidth = Math.abs(textWidth * Math.cos(angle));
                            textHeight = Math.abs(textHeight * Math.sin(angle));
                        }
                        maxTextWidth = Math.max(maxTextWidth, textWidth);
                        maxTextHeight = Math.max(maxTextHeight, textHeight);
                        textAlign = labelStyle.textAlign;
                        textBaseline = labelStyle.textBaseline;
                        if (index === 0) {
                            labelPos = labelStyle.x;
                        }
                    });
                    this.axisLabelLayerSize[layer] = {
                        width: maxTextWidth,
                        height: maxTextHeight,
                        labelPos,
                        textAlign,
                        textBaseline
                    };
                });
            }
        }
        if (title && title.visible) {
            this.renderTitle(axisContainer);
        }
    }
    renderTicks(container) {
        const tickLineItems = this.getTickLineItems();
        const tickLineGroup = graphicCreator.group({ x: 0, y: 0, pickable: false });
        tickLineGroup.name = AXIS_ELEMENT_NAME.tickContainer;
        tickLineGroup.id = this._getNodeId('tick-container');
        container.add(tickLineGroup);
        tickLineItems.forEach((item, index) => {
            var _a;
            const line = graphicCreator.line(Object.assign({}, this._getTickLineAttribute('tick', item, index, tickLineItems)));
            line.name = AXIS_ELEMENT_NAME.tick;
            line.id = this._getNodeId(item.id);
            if (isEmpty((_a = this.attribute.tick) === null || _a === void 0 ? void 0 : _a.state)) {
                line.states = DEFAULT_STATES$2;
            }
            else {
                const data = this.data[index];
                const tickLineState = merge({}, DEFAULT_STATES$2, this.attribute.tick.state);
                Object.keys(tickLineState).forEach(key => {
                    if (isFunction(tickLineState[key])) {
                        tickLineState[key] = tickLineState[key](data.rawValue, index, data, this.data);
                    }
                });
                line.states = tickLineState;
            }
            tickLineGroup.add(line);
        });
        this.tickLineItems = tickLineItems;
        const { subTick } = this.attribute;
        if (subTick && subTick.visible) {
            const subTickLineItems = this.getSubTickLineItems();
            if (subTickLineItems.length) {
                subTickLineItems.forEach((item, index) => {
                    const line = graphicCreator.line(Object.assign({}, this._getTickLineAttribute('subTick', item, index, tickLineItems)));
                    line.name = AXIS_ELEMENT_NAME.subTick;
                    line.id = this._getNodeId(`${index}`);
                    if (isEmpty(subTick.state)) {
                        line.states = DEFAULT_STATES$2;
                    }
                    else {
                        const subTickLineState = merge({}, DEFAULT_STATES$2, subTick.state);
                        Object.keys(subTickLineState).forEach(key => {
                            if (isFunction(subTickLineState[key])) {
                                subTickLineState[key] = subTickLineState[key](item.value, index, item, tickLineItems);
                            }
                        });
                        line.states = subTickLineState;
                    }
                    tickLineGroup.add(line);
                });
            }
            this.subTickLineItems = subTickLineItems;
        }
    }
    renderLabels(container, items, layer) {
        const { dataFilter } = this.attribute.label;
        if (dataFilter && isFunction(dataFilter)) {
            items = dataFilter(items, layer);
        }
        const data = this._transformItems(items);
        const labelGroup = graphicCreator.group({ x: 0, y: 0, pickable: false });
        labelGroup.name = `${AXIS_ELEMENT_NAME.labelContainer}-layer-${layer}`;
        labelGroup.id = this._getNodeId(`label-container-layer-${layer}`);
        container.add(labelGroup);
        data.forEach((item, index) => {
            var _a;
            const labelStyle = this._getLabelAttribute(item, index, data, layer);
            const text = createTextGraphicByType(labelStyle);
            text.name = AXIS_ELEMENT_NAME.label;
            text.id = this._getNodeId(`layer${layer}-label-${item.id}`);
            if (isEmpty((_a = this.attribute.label) === null || _a === void 0 ? void 0 : _a.state)) {
                text.states = DEFAULT_STATES$2;
            }
            else {
                const labelState = merge({}, DEFAULT_STATES$2, this.attribute.label.state);
                Object.keys(labelState).forEach(key => {
                    if (isFunction(labelState[key])) {
                        labelState[key] = labelState[key](item, index, data, layer);
                    }
                });
                text.states = labelState;
            }
            text.data = Object.assign(Object.assign({}, item), { index, layer });
            labelGroup.add(text);
        });
        return labelGroup;
    }
    renderTitle(container) {
        const titleAttributes = this.getTitleAttribute();
        const axisTitle = new Tag(Object.assign({}, titleAttributes));
        axisTitle.name = AXIS_ELEMENT_NAME.title;
        axisTitle.id = this._getNodeId('title');
        container.add(axisTitle);
    }
    getVerticalCoord(point, offset, inside) {
        return getVerticalCoord(point, this.getVerticalVector(offset, inside, point));
    }
    getTickLineItems() {
        const { tick } = this.attribute;
        const data = this.data;
        const tickLineItems = [];
        const { alignWithLabel, inside = false, length, dataFilter } = tick;
        let tickSegment = 1;
        const count = data.length;
        if (count >= 2) {
            tickSegment = data[1].value - data[0].value;
        }
        (dataFilter && isFunction(dataFilter) ? dataFilter(data) : data).forEach((item) => {
            let point = item.point;
            let tickValue = item.value;
            if (!alignWithLabel) {
                const value = item.value - tickSegment / 2;
                if (this.isInValidValue(value)) {
                    return;
                }
                point = this.getTickCoord(value);
                tickValue = value;
            }
            const endPoint = this.getVerticalCoord(point, length, inside);
            if (this.mode === '3d') {
                const vec = this.getVerticalVector(length, inside, point);
                let alpha = 0;
                let beta = 0;
                if (abs(vec[0]) > abs(vec[1])) {
                    alpha = (pi / 2) * (endPoint.x > point.x ? 1 : -1);
                }
                else {
                    beta = (pi / 2) * (endPoint.y > point.y ? -1 : 1);
                }
                tickLineItems.push({
                    start: point,
                    end: endPoint,
                    value: tickValue,
                    id: `tick-${item.id}`,
                    anchor: [point.x, point.y],
                    alpha,
                    beta
                });
            }
            else {
                tickLineItems.push({
                    start: point,
                    end: endPoint,
                    value: tickValue,
                    id: `tick-${item.id}`
                });
            }
        });
        return tickLineItems;
    }
    getSubTickLineItems() {
        const { subTick } = this.attribute;
        const subTickLineItems = [];
        const { count: subCount = 4, inside = false, length = 2 } = subTick;
        const tickLineItems = this.tickLineItems;
        const tickLineCount = tickLineItems.length;
        if (tickLineCount >= 2) {
            for (let i = 0; i < tickLineCount - 1; i++) {
                const pre = tickLineItems[i];
                const next = tickLineItems[i + 1];
                for (let j = 0; j < subCount; j++) {
                    const percent = (j + 1) / (subCount + 1);
                    const value = (1 - percent) * pre.value + percent * next.value;
                    const point = this.getTickCoord(value);
                    const endPoint = this.getVerticalCoord(point, length, inside);
                    subTickLineItems.push({
                        start: point,
                        end: endPoint,
                        value,
                        id: `sub-tick-${value}`
                    });
                }
            }
        }
        return subTickLineItems;
    }
    _getTickLineAttribute(type, tickItem, index, tickItems) {
        let style = get(this.attribute, `${type}.style`);
        const data = this.data[index];
        style = isFunction(style)
            ? merge({}, get(DEFAULT_AXIS_THEME, `${type}.style`), type === 'tick'
                ? style(data.rawValue, index, data, this.data)
                : style(tickItem.value, index, tickItem, tickItems))
            : style;
        const { start, end, anchor, alpha, beta } = tickItem;
        return Object.assign({ points: [start, end], anchor,
            alpha,
            beta }, style);
    }
    _getLabelAttribute(tickDatum, index, tickData, layer) {
        var _a, _b;
        const { space = 4, inside = false, formatMethod, type = 'text', text } = this.attribute.label;
        let offset = space;
        let tickLength = 0;
        if (((_a = this.attribute.tick) === null || _a === void 0 ? void 0 : _a.visible) && this.attribute.tick.inside === inside) {
            tickLength = this.attribute.tick.length || 4;
        }
        if (((_b = this.attribute.subTick) === null || _b === void 0 ? void 0 : _b.visible) && this.attribute.subTick.inside === inside) {
            tickLength = Math.max(tickLength, this.attribute.subTick.length || 2);
        }
        offset += tickLength;
        const axisVector = this.getRelativeVector(tickDatum.point);
        if (layer > 0) {
            if (axisVector[1] === 0) {
                offset += (this.axisLabelLayerSize[layer - 1].height + get(this.attribute, 'label.space', 4)) * layer;
            }
            else {
                offset += (this.axisLabelLayerSize[layer - 1].width + get(this.attribute, 'label.space', 4)) * layer;
            }
        }
        const point = this.getVerticalCoord(tickDatum.point, offset, inside);
        const vector = this.getVerticalVector(offset || 1, inside, point);
        const textContent = formatMethod
            ? formatMethod(`${tickDatum.label}`, tickDatum, index, tickData, layer)
            : tickDatum.label;
        let { style: textStyle } = this.attribute.label;
        textStyle = isFunction(textStyle)
            ? merge({}, DEFAULT_AXIS_THEME.label.style, textStyle(tickDatum, index, tickData, layer))
            : textStyle;
        const labelAlign = this.getLabelAlign(vector, inside, textStyle.angle);
        textStyle = merge(labelAlign, textStyle);
        if (isFunction(textStyle.text)) {
            textStyle.text = textStyle.text({
                label: tickDatum.label,
                value: tickDatum.rawValue,
                index: tickDatum.index,
                layer
            });
        }
        return Object.assign(Object.assign(Object.assign({}, this.getLabelPosition(point, vector, textContent, textStyle)), { text: text !== null && text !== void 0 ? text : textContent, _originText: tickDatum.label, lineHeight: textStyle === null || textStyle === void 0 ? void 0 : textStyle.fontSize, type }), textStyle);
    }
    getLabelPosition(point, vector, text, style) {
        return point;
    }
    _transformItems(items) {
        const data = [];
        items.forEach((item) => {
            var _a;
            data.push(Object.assign(Object.assign({}, item), { point: this.getTickCoord(item.value), id: (_a = item.id) !== null && _a !== void 0 ? _a : item.label }));
        });
        return data;
    }
    runAnimation() {
        const lastScale = this.lastScale;
        if (this.attribute.scale) {
            const scale = this.attribute.scale;
            this.lastScale = scale.clone();
            this.lastScale.range([0, 1]);
        }
        if (this.attribute.animation && this.applyAnimationState) {
            const currentInnerView = this.getInnerView();
            const prevInnerView = this.getPrevInnerView();
            if (!prevInnerView) {
                return;
            }
            const animationConfig = this._animationConfig;
            this._newElementAttrMap = {};
            traverseGroup(currentInnerView, (el) => {
                var _a;
                if (el.type !== 'group' && el.id) {
                    const oldEl = prevInnerView[el.id];
                    el.setFinalAttributes(el.attribute);
                    if (oldEl) {
                        oldEl.release();
                        const oldAttrs = oldEl.attribute;
                        const finalAttrs = el.getFinalAttribute();
                        const diffAttrs = diff(oldAttrs, finalAttrs);
                        let hasDiff = Object.keys(diffAttrs).length > 0;
                        if ('opacity' in oldAttrs && finalAttrs.opacity !== oldAttrs.opacity) {
                            diffAttrs.opacity = (_a = finalAttrs.opacity) !== null && _a !== void 0 ? _a : 1;
                            hasDiff = true;
                        }
                        if (animationConfig.update && hasDiff) {
                            this._newElementAttrMap[el.id] = {
                                state: 'update',
                                node: el,
                                attrs: el.attribute
                            };
                            const oldAttrs = oldEl.attribute;
                            el.setAttributes(oldAttrs);
                            el.applyAnimationState(['update'], [
                                {
                                    name: 'update',
                                    animation: Object.assign(Object.assign({ selfOnly: true }, animationConfig.update), { type: 'axisUpdate', customParameters: {
                                            config: animationConfig.update,
                                            diffAttrs,
                                            lastScale
                                        } })
                                }
                            ]);
                        }
                    }
                    else if (animationConfig.enter) {
                        this._newElementAttrMap[el.id] = {
                            state: 'enter',
                            node: el,
                            attrs: el.attribute
                        };
                        el.applyAnimationState(['enter'], [
                            {
                                name: 'enter',
                                animation: Object.assign(Object.assign({}, animationConfig.enter), { type: 'axisEnter', selfOnly: true, customParameters: {
                                        config: animationConfig.enter,
                                        lastScale,
                                        getTickCoord: this.getTickCoord.bind(this)
                                    } })
                            }
                        ]);
                    }
                }
            });
        }
    }
    release() {
        super.release();
        this._prevInnerView = null;
        this._innerView = null;
    }
}

const methods$1 = {
    parity: function (items) {
        return items.filter((item, i) => (i % 2 ? item.setAttribute('opacity', 0) : 1));
    },
    greedy: function (items, sep) {
        let a;
        return items.filter((b, i) => {
            if (!i || !textIntersect(a, b, sep)) {
                a = b;
                return 1;
            }
            return b.setAttribute('opacity', 0);
        });
    }
};
function hasBounds(item) {
    let bounds;
    if (!item.OBBBounds.empty()) {
        bounds = item.OBBBounds;
    }
    else {
        bounds = item.AABBBounds;
    }
    return bounds.width() > 1 && bounds.height() > 1;
}
function reset(items) {
    items.forEach(item => item.setAttribute('opacity', 1));
    return items;
}
function forceItemVisible$1(sourceItem, items, check, comparator, inverse = false) {
    if (check && !sourceItem.attribute.opacity) {
        const remainLength = items.length;
        if (remainLength > 1) {
            sourceItem.setAttribute('opacity', 1);
            for (let i = 0; i < remainLength; i++) {
                const item = inverse ? items[remainLength - 1 - i] : items[i];
                if (comparator(item)) {
                    item.setAttribute('opacity', 0);
                }
                else {
                    break;
                }
            }
        }
    }
}
function autoHide(labels, config) {
    if (isEmpty(labels)) {
        return;
    }
    const source = labels.filter(hasBounds);
    if (isEmpty(source)) {
        return;
    }
    let items;
    items = reset(source);
    const { method = 'parity', separation: sep = 0 } = config;
    const reduce = isFunction(method) ? method : methods$1[method] || methods$1.parity;
    if (items.length >= 3 && hasOverlap(items, sep)) {
        do {
            items = reduce(items, sep);
        } while (items.length >= 3 && hasOverlap(items, sep));
        const shouldCheck = (length, visibility, checkLength = true) => {
            return checkLength ? length < 3 || visibility : visibility;
        };
        const checkFirst = shouldCheck(items.length, config.firstVisible, false);
        let checkLast = shouldCheck(items.length, config.lastVisible);
        const firstSourceItem = source[0];
        const lastSourceItem = last(source);
        if (textIntersect(firstSourceItem, lastSourceItem, sep) && checkFirst && checkLast) {
            lastSourceItem.setAttribute('opacity', 0);
            checkLast = false;
        }
        forceItemVisible$1(firstSourceItem, items, checkFirst, (item) => textIntersect(item, firstSourceItem, sep));
        forceItemVisible$1(lastSourceItem, items, checkLast, (item) => textIntersect(item, lastSourceItem, sep) ||
            (checkFirst && item !== firstSourceItem ? textIntersect(item, firstSourceItem, sep) : false), true);
    }
    source.forEach(item => {
        item.setAttribute('visible', !!item.attribute.opacity);
    });
}

function autoRotate(items, rotateConfig) {
    if (isEmpty(items)) {
        return;
    }
    const { orient, labelRotateAngle = [0, 45, 90] } = rotateConfig;
    if (labelRotateAngle.length === 0 || items.some(item => !!item.attribute.angle)) {
        return;
    }
    let i = 0;
    let n = 0;
    if (labelRotateAngle && labelRotateAngle.length > 0) {
        n = labelRotateAngle.length;
    }
    while (i < n) {
        const angle = labelRotateAngle[i++];
        items.forEach(item => {
            item.attribute.angle = degreeToRadian(angle);
        });
        tryRotate(orient, items);
        if (!hasIntersect(items)) {
            break;
        }
    }
}
function hasIntersect(items) {
    for (let i = 1; i < items.length; i++) {
        if (itemIntersect(items[i - 1], items[i])) {
            return true;
        }
    }
    return false;
}
function tryRotate(orient, items) {
    if (orient === 'bottom' || orient === 'top') {
        rotateXAxis(orient, items);
    }
    if (orient === 'left' || orient === 'right') {
        rotateYAxis(orient, items);
    }
    genRotateBounds(items);
}
function clampAngle(angle = 0) {
    if (angle < 0) {
        while (angle < 0) {
            angle += Math.PI * 2;
        }
    }
    if (angle > 0) {
        while (angle >= Math.PI * 2) {
            angle -= Math.PI * 2;
        }
    }
    return angle;
}
function rotateYAxis(orient, items) {
    items.forEach((item, i) => {
        item.attribute.angle &&
            item.setAttributes(Object.assign(Object.assign({}, getYAxisLabelAlign(orient, item.attribute.angle)), { angle: clampAngle(item.attribute.angle) }));
    });
}
function rotateXAxis(orient, items) {
    items.forEach(item => {
        item.attribute.angle &&
            item.setAttributes(Object.assign(Object.assign({}, getXAxisLabelAlign(orient, item.attribute.angle)), { angle: clampAngle(item.attribute.angle) }));
    });
}
function getXAxisLabelAlign(orient, angle = 0) {
    let align = ['center', 'left', 'left', 'left', 'center', 'right', 'right', 'right', 'left'];
    let baseline = ['top', 'top', 'middle', 'bottom', 'bottom', 'bottom', 'middle', 'top', 'top'];
    if (orient === 'top') {
        align = ['center', 'right', 'right', 'right', 'center', 'left', 'left', 'left', 'right'];
        baseline = ['bottom', 'bottom', 'middle', 'top', 'top', 'top', 'middle', 'bottom', 'bottom'];
    }
    angle = clampAngle(angle);
    const step = angle / (Math.PI * 0.5);
    let index;
    if (step === Math.floor(step)) {
        index = Math.floor(step) * 2;
    }
    else {
        index = Math.floor(step) * 2 + 1;
    }
    return {
        textAlign: align[index],
        textBaseline: baseline[index]
    };
}
function getYAxisLabelAlign(orient, angle = 0) {
    let align = ['right', 'right', 'center', 'left', 'left', 'left', 'center', 'right', 'right'];
    let baseline = ['middle', 'middle', 'top', 'top', 'middle', 'middle', 'bottom', 'bottom', 'middle'];
    if (orient === 'right') {
        align = ['left', 'left', 'center', 'right', 'right', 'right', 'center', 'left', 'left'];
        baseline = ['middle', 'middle', 'bottom', 'bottom', 'middle', 'middle', 'top', 'middle', 'middle'];
    }
    angle = clampAngle(angle);
    const step = angle / (Math.PI * 0.5);
    let index;
    if (step === Math.floor(step)) {
        index = Math.floor(step) * 2;
    }
    else {
        index = Math.floor(step) * 2 + 1;
    }
    return {
        textAlign: align[index],
        textBaseline: baseline[index]
    };
}

function normalizeOverflowLimitLength(overflowLimitLength) {
    if (isValidNumber(overflowLimitLength)) {
        return {
            left: overflowLimitLength,
            right: overflowLimitLength
        };
    }
    else if (isObject(overflowLimitLength)) {
        return {
            left: overflowLimitLength.left || 0,
            right: overflowLimitLength.right || 0
        };
    }
    return { left: 0, right: 0 };
}
function autoLimit(labels, config) {
    const { limitLength, verticalLimitLength, ellipsis = '...', orient, axisLength } = config;
    if (isEmpty(labels) || !isValidNumber(limitLength)) {
        return;
    }
    const overflowLimitLength = normalizeOverflowLimitLength(config.overflowLimitLength);
    const firstLabel = labels[0];
    const angle = firstLabel.attribute.angle;
    const hasAngle = !isNil(angle);
    const cos = hasAngle ? Math.cos(angle) : 1;
    const sin = hasAngle ? Math.sin(angle) : 0;
    const isHorizontal = isAngleHorizontal(angle);
    const isVertical = isAngleVertical(angle);
    const isX = orient === 'top' || orient === 'bottom';
    const direction = firstLabel.attribute.direction;
    const THRESHOLD = 2;
    const checkBox = !isHorizontal &&
        !isVertical &&
        isX &&
        (labels.length < 2 ||
            labels.some(label => Math.abs(label.AABBBounds.width() - firstLabel.AABBBounds.width()) >= THRESHOLD)) &&
        firstLabel.AABBBounds.width() > Math.abs(limitLength / sin);
    labels.forEach(label => {
        var _a;
        if (isX) {
            if (isVertical && Math.floor(label.AABBBounds.height()) <= limitLength) {
                return;
            }
            if (isHorizontal && Math.floor(label.AABBBounds.width()) <= verticalLimitLength) {
                return;
            }
        }
        if (!isX) {
            if (direction === 'vertical' && Math.floor(label.AABBBounds.height()) <= verticalLimitLength) {
                return;
            }
            if (direction !== 'vertical') {
                if (isHorizontal && Math.floor(label.AABBBounds.width()) <= limitLength) {
                    return;
                }
                if (isVertical && Math.floor(label.AABBBounds.height()) <= verticalLimitLength) {
                    return;
                }
            }
        }
        let limitLabelLength = null;
        if (!isHorizontal && !isVertical) {
            if (isX) {
                const { x1, x2 } = label.AABBBounds;
                const tan = sin / cos;
                const verticalSizeLimit = Math.abs(limitLength / sin);
                if (checkBox &&
                    tan > 0 &&
                    x1 <= axisLength + overflowLimitLength.right &&
                    limitLength / tan + x1 > axisLength + overflowLimitLength.right) {
                    const lengthLimit = (axisLength - x1 + overflowLimitLength.right) / Math.abs(cos);
                    limitLabelLength = Math.min(lengthLimit, verticalSizeLimit);
                }
                else if (checkBox &&
                    tan < 0 &&
                    x2 >= -overflowLimitLength.left &&
                    limitLength / tan + x2 < -overflowLimitLength.left) {
                    const lengthLimit = (x2 + overflowLimitLength.left) / Math.abs(cos);
                    limitLabelLength = Math.min(lengthLimit, verticalSizeLimit);
                }
                else {
                    limitLabelLength = verticalSizeLimit;
                }
            }
            else {
                limitLabelLength = Math.abs(limitLength / cos);
            }
        }
        else if (isX) {
            limitLabelLength = isHorizontal ? verticalLimitLength : limitLength;
        }
        else {
            limitLabelLength = direction === 'vertical' || isVertical ? verticalLimitLength : limitLength;
        }
        if (isValidNumber(label.attribute.maxLineWidth)) {
            limitLabelLength = isValidNumber(limitLabelLength)
                ? Math.min(label.attribute.maxLineWidth, limitLabelLength)
                : label.attribute.maxLineWidth;
        }
        label.setAttributes({
            maxLineWidth: limitLabelLength,
            ellipsis: (_a = label.attribute.ellipsis) !== null && _a !== void 0 ? _a : ellipsis
        });
    });
}

function autoWrap(labels, config) {
    const { limitLength, axisLength, ellipsis = '...', orient } = config;
    if (isEmpty(labels) || !isValidNumber(limitLength)) {
        return;
    }
    const firstLabel = labels[0];
    const angle = firstLabel.attribute.angle;
    const isHorizontal = isAngleHorizontal(angle);
    const isVertical = isAngleVertical(angle);
    const isX = orient === 'top' || orient === 'bottom';
    let verticalLimitLength = axisLength / labels.length;
    labels.forEach((label, index) => {
        var _a, _b, _c, _d, _e;
        if (isX) {
            if (isVertical && Math.floor(label.AABBBounds.height()) <= limitLength) {
                return;
            }
            if (isHorizontal) {
                const curLabelX = label.attribute.x;
                const nextLabelX = (_a = labels[index + 1]) === null || _a === void 0 ? void 0 : _a.attribute.x;
                const lastLabelX = (_b = labels[index - 1]) === null || _b === void 0 ? void 0 : _b.attribute.x;
                const minGap = getLabelMinGap(curLabelX, nextLabelX, lastLabelX);
                if (isValidNumber(minGap)) {
                    verticalLimitLength = min(verticalLimitLength, minGap);
                }
            }
        }
        else {
            if (isVertical) {
                const curLabelY = label.attribute.y;
                const nextLabelY = (_c = labels[index + 1]) === null || _c === void 0 ? void 0 : _c.attribute.y;
                const lastLabelY = (_d = labels[index - 1]) === null || _d === void 0 ? void 0 : _d.attribute.y;
                const minGap = getLabelMinGap(curLabelY, nextLabelY, lastLabelY);
                if (isValidNumber(minGap)) {
                    verticalLimitLength = min(verticalLimitLength, minGap);
                }
            }
            if (isHorizontal && Math.floor(label.AABBBounds.width()) <= limitLength) {
                return;
            }
        }
        let limitLabelLength = null;
        let heightLimit = null;
        if (isX) {
            if (isVertical) {
                limitLabelLength = limitLength;
                heightLimit = verticalLimitLength;
            }
            else {
                limitLabelLength = verticalLimitLength;
                heightLimit = limitLength;
            }
        }
        else {
            if (isVertical) {
                limitLabelLength = verticalLimitLength;
                heightLimit = limitLength;
            }
            else {
                limitLabelLength = limitLength;
                heightLimit = verticalLimitLength;
            }
        }
        label.setAttributes({
            maxLineWidth: limitLabelLength,
            ellipsis: (_e = label.attribute.ellipsis) !== null && _e !== void 0 ? _e : ellipsis,
            whiteSpace: 'normal',
            heightLimit
        });
    });
}
function getLabelMinGap(current, next, prev) {
    let minGap;
    if (isValidNumber(next)) {
        minGap = Math.abs(next - current);
    }
    if (isValidNumber(prev)) {
        if (isValidNumber(minGap)) {
            minGap = Math.min(Math.abs(current - prev), minGap);
        }
        else {
            minGap = Math.abs(current - prev);
        }
    }
    return minGap;
}

function alignAxisLabels(labels, start, containerSize, orient, align) {
    if (orient === 'left' || orient === 'right') {
        if (align === 'left') {
            labels.forEach(label => {
                var _a;
                label.setAttributes({
                    dx: ((_a = label.attribute.dx) !== null && _a !== void 0 ? _a : 0) + start - label.AABBBounds.x1
                });
            });
        }
        else if (align === 'right') {
            labels.forEach(label => {
                var _a;
                label.setAttributes({
                    dx: ((_a = label.attribute.dx) !== null && _a !== void 0 ? _a : 0) + start + containerSize - label.AABBBounds.x2
                });
            });
        }
        else if (align === 'center') {
            labels.forEach(label => {
                var _a;
                label.setAttributes({
                    dx: ((_a = label.attribute.dx) !== null && _a !== void 0 ? _a : 0) + start + containerSize / 2 - (label.AABBBounds.x1 + label.AABBBounds.x2) / 2
                });
            });
        }
    }
    else if (orient === 'bottom' || orient === 'top') {
        if (align === 'top') {
            labels.forEach(label => {
                var _a;
                label.setAttributes({
                    dy: ((_a = label.attribute.dy) !== null && _a !== void 0 ? _a : 0) + start - label.AABBBounds.y1
                });
            });
        }
        else if (align === 'bottom') {
            labels.forEach(label => {
                var _a;
                label.setAttributes({
                    dy: ((_a = label.attribute.dy) !== null && _a !== void 0 ? _a : 0) + start + containerSize - label.AABBBounds.y2
                });
            });
        }
        else if (align === 'middle') {
            labels.forEach(label => {
                var _a;
                label.setAttributes({
                    dy: ((_a = label.attribute.dy) !== null && _a !== void 0 ? _a : 0) + start + containerSize / 2 - (label.AABBBounds.y1 + label.AABBBounds.y2) / 2
                });
            });
        }
    }
}

class LineAxisMixin {
    isInValidValue(value) {
        return value < 0 || value > 1;
    }
    getTickCoord(tickValue) {
        const { start } = this.attribute;
        const axisVector = this.getRelativeVector();
        return {
            x: start.x + axisVector[0] * tickValue,
            y: start.y + axisVector[1] * tickValue
        };
    }
    getRelativeVector(point) {
        const { start, end } = this.attribute;
        return [end.x - start.x, end.y - start.y];
    }
    getVerticalVector(offset, inside = false, point) {
        const { verticalFactor = 1 } = this.attribute;
        const axisVector = this.getRelativeVector();
        const normalizedAxisVector = normalize(axisVector);
        const verticalVector = [normalizedAxisVector[1], normalizedAxisVector[0] * -1];
        return scale(verticalVector, offset * (inside ? 1 : -1) * verticalFactor);
    }
}

class Easing {
  constructor() {}
  static linear(t) {
    return t;
  }
  static none() {
    return this.linear;
  }
  static get(amount) {
    return amount < -1 ? amount = -1 : amount > 1 && (amount = 1), function (t) {
      return 0 === amount ? t : amount < 0 ? t * (t * -amount + 1 + amount) : t * ((2 - t) * amount + (1 - amount));
    };
  }
  static getPowIn(pow) {
    return function (t) {
      return Math.pow(t, pow);
    };
  }
  static getPowOut(pow) {
    return function (t) {
      return 1 - Math.pow(1 - t, pow);
    };
  }
  static getPowInOut(pow) {
    return function (t) {
      return (t *= 2) < 1 ? .5 * Math.pow(t, pow) : 1 - .5 * Math.abs(Math.pow(2 - t, pow));
    };
  }
  static getBackIn(amount) {
    return function (t) {
      return t * t * ((amount + 1) * t - amount);
    };
  }
  static getBackOut(amount) {
    return function (t) {
      return --t * t * ((amount + 1) * t + amount) + 1;
    };
  }
  static getBackInOut(amount) {
    return amount *= 1.525, function (t) {
      return (t *= 2) < 1 ? t * t * ((amount + 1) * t - amount) * .5 : .5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
    };
  }
  static sineIn(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  }
  static sineOut(t) {
    return Math.sin(t * Math.PI / 2);
  }
  static sineInOut(t) {
    return -(Math.cos(Math.PI * t) - 1) / 2;
  }
  static expoIn(t) {
    return 0 === t ? 0 : Math.pow(2, 10 * t - 10);
  }
  static expoOut(t) {
    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
  }
  static expoInOut(t) {
    return 0 === t ? 0 : 1 === t ? 1 : t < .5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
  }
  static circIn(t) {
    return -(Math.sqrt(1 - t * t) - 1);
  }
  static circOut(t) {
    return Math.sqrt(1 - --t * t);
  }
  static circInOut(t) {
    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
  }
  static bounceOut(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  static bounceIn(t) {
    return 1 - Easing.bounceOut(1 - t);
  }
  static bounceInOut(t) {
    return t < .5 ? .5 * Easing.bounceIn(2 * t) : .5 * Easing.bounceOut(2 * t - 1) + .5;
  }
  static getElasticIn(amplitude, period) {
    return function (t) {
      if (0 === t || 1 === t) return t;
      const s = period / pi2 * Math.asin(1 / amplitude);
      return -amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period);
    };
  }
  static getElasticOut(amplitude, period) {
    return function (t) {
      if (0 === t || 1 === t) return t;
      const s = period / pi2 * Math.asin(1 / amplitude);
      return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * pi2 / period) + 1;
    };
  }
  static getElasticInOut(amplitude, period) {
    return function (t) {
      const s = period / pi2 * Math.asin(1 / amplitude);
      return (t *= 2) < 1 ? amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * -.5 : amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * .5 + 1;
    };
  }
  static registerFunc(name, func) {
    Easing[name] = func;
  }
}
function flicker(t, n) {
  const step = 1 / n;
  let flag = 1;
  for (; t > step;) t -= step, flag *= -1;
  const v = flag * t / step;
  return v > 0 ? v : 1 + v;
}
Easing.quadIn = Easing.getPowIn(2), Easing.quadOut = Easing.getPowOut(2), Easing.quadInOut = Easing.getPowInOut(2), Easing.cubicIn = Easing.getPowIn(3), Easing.cubicOut = Easing.getPowOut(3), Easing.cubicInOut = Easing.getPowInOut(3), Easing.quartIn = Easing.getPowIn(4), Easing.quartOut = Easing.getPowOut(4), Easing.quartInOut = Easing.getPowInOut(4), Easing.quintIn = Easing.getPowIn(5), Easing.quintOut = Easing.getPowOut(5), Easing.quintInOut = Easing.getPowInOut(5), Easing.backIn = Easing.getBackIn(1.7), Easing.backOut = Easing.getBackOut(1.7), Easing.backInOut = Easing.getBackInOut(1.7), Easing.elasticIn = Easing.getElasticIn(1, .3), Easing.elasticOut = Easing.getElasticOut(1, .3), Easing.elasticInOut = Easing.getElasticInOut(1, .3 * 1.5), Easing.easeInOutQuad = t => (t /= .5) < 1 ? .5 * Math.pow(t, 2) : -.5 * ((t -= 2) * t - 2), Easing.easeOutElastic = x => {
  const c4 = 2 * Math.PI / 3;
  return 0 === x ? 0 : 1 === x ? 1 : Math.pow(2, -10 * x) * Math.sin((10 * x - .75) * c4) + 1;
}, Easing.easeInOutElastic = x => {
  const c5 = 2 * Math.PI / 4.5;
  return 0 === x ? 0 : 1 === x ? 1 : x < .5 ? -Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1;
};
for (let i = 0; i < 10; i++) Easing[`flicker${i}`] = t => flicker(t, i);
for (let i = 2; i < 10; i++) Easing[`aIn${i}`] = t => i * t * t + (1 - i) * t;

function interpolateNumber(from, to, ratio) {
  return from + (to - from) * ratio;
}

class InterpolateUpdateStore {
  constructor() {
    this.opacity = (key, from, to, ratio, step, target) => {
      target.attribute.opacity = interpolateNumber(from, to, ratio);
    }, this.baseOpacity = (key, from, to, ratio, step, target) => {
      target.attribute.baseOpacity = interpolateNumber(from, to, ratio);
    }, this.fillOpacity = (key, from, to, ratio, step, target) => {
      target.attribute.fillOpacity = interpolateNumber(from, to, ratio);
    }, this.strokeOpacity = (key, from, to, ratio, step, target) => {
      target.attribute.strokeOpacity = interpolateNumber(from, to, ratio);
    }, this.zIndex = (key, from, to, ratio, step, target) => {
      target.attribute.zIndex = interpolateNumber(from, to, ratio);
    }, this.backgroundOpacity = (key, from, to, ratio, step, target) => {
      target.attribute.backgroundOpacity = interpolateNumber(from, to, ratio);
    }, this.shadowOffsetX = (key, from, to, ratio, step, target) => {
      target.attribute.shadowOffsetX = interpolateNumber(from, to, ratio);
    }, this.shadowOffsetY = (key, from, to, ratio, step, target) => {
      target.attribute.shadowOffsetY = interpolateNumber(from, to, ratio);
    }, this.shadowBlur = (key, from, to, ratio, step, target) => {
      target.attribute.shadowBlur = interpolateNumber(from, to, ratio);
    }, this.fill = (key, from, to, ratio, step, target) => {
      target.attribute.fill = interpolateColor(from, to, ratio, !1);
    }, this.fillPure = (key, from, to, ratio, step, target) => {
      target.attribute.fill = step.fromParsedProps.fill ? interpolatePureColorArrayToStr(step.fromParsedProps.fill, step.toParsedProps.fill, ratio) : step.toParsedProps.fill;
    }, this.stroke = (key, from, to, ratio, step, target) => {
      target.attribute.stroke = interpolateColor(from, to, ratio, !1);
    }, this.strokePure = (key, from, to, ratio, step, target) => {
      target.attribute.stroke = step.fromParsedProps.stroke ? interpolatePureColorArrayToStr(step.fromParsedProps.stroke, step.toParsedProps.stroke, ratio) : step.toParsedProps.stroke;
    }, this.width = (key, from, to, ratio, step, target) => {
      target.attribute.width = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
    }, this.height = (key, from, to, ratio, step, target) => {
      target.attribute.height = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
    }, this.x = (key, from, to, ratio, step, target) => {
      target.attribute.x = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
    }, this.y = (key, from, to, ratio, step, target) => {
      target.attribute.y = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
    }, this.dx = (key, from, to, ratio, step, target) => {
      target.attribute.dx = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
    }, this.dy = (key, from, to, ratio, step, target) => {
      target.attribute.dy = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
    }, this.angle = (key, from, to, ratio, step, target) => {
      target.attribute.angle = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
    }, this.scaleX = (key, from, to, ratio, step, target) => {
      target.attribute.scaleX = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
    }, this.scaleY = (key, from, to, ratio, step, target) => {
      target.attribute.scaleY = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
    }, this.lineWidth = (key, from, to, ratio, step, target) => {
      target.attribute.lineWidth = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
    }, this.startAngle = (key, from, to, ratio, step, target) => {
      target.attribute.startAngle = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
    }, this.endAngle = (key, from, to, ratio, step, target) => {
      target.attribute.endAngle = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
    }, this.radius = (key, from, to, ratio, step, target) => {
      target.attribute.radius = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
    }, this.outerRadius = (key, from, to, ratio, step, target) => {
      target.attribute.outerRadius = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
    }, this.innerRadius = (key, from, to, ratio, step, target) => {
      target.attribute.innerRadius = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
    }, this.size = (key, from, to, ratio, step, target) => {
      target.attribute.size = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
    }, this.points = (key, from, to, ratio, step, target) => {
      target.attribute.points = pointsInterpolation(from, to, ratio), target.addUpdateBoundTag();
    };
  }
}
const interpolateUpdateStore = new InterpolateUpdateStore();
function commonInterpolateUpdate(key, from, to, ratio, step, target) {
  if (Number.isFinite(to) && Number.isFinite(from)) return target.attribute[key] = from + (to - from) * ratio, !0;
  if (Array.isArray(to) && Array.isArray(from) && to.length === from.length) {
    const nextList = [];
    let valid = !0;
    for (let i = 0; i < to.length; i++) {
      const v = from[i],
        val = v + (to[i] - v) * ratio;
      if (!Number.isFinite(val)) {
        valid = !1;
        break;
      }
      nextList.push(val);
    }
    return valid && (target.attribute[key] = nextList), !0;
  }
  return !1;
}

function noop() {}
class Step {
  constructor(type, props, duration, easing) {
    var _a;
    this._startTime = 0, this._hasFirstRun = !1, this._syncAttributeUpdate = () => {
      this.target.setAttributes(this.target.attribute);
    }, this.type = type, this.props = props, this.duration = duration, this.easing = easing ? "function" == typeof easing ? easing : null !== (_a = Easing[easing]) && void 0 !== _a ? _a : Easing.linear : Easing.linear, "wait" === type && (this.onUpdate = noop), this.id = Generator.GenAutoIncrementId(), this.syncAttributeUpdate = noop;
  }
  bind(target, animate) {
    this.target = target, this.animate = animate, this.onBind(), this.syncAttributeUpdate();
  }
  append(step) {
    this.next = step, step.prev = this, step.setStartTime(this.getStartTime() + this.duration, !1);
  }
  updateDownstreamStartTimes() {
    let currentStep = this.next,
      currentStartTime = this._startTime + this.duration;
    for (; currentStep;) currentStep.setStartTime(currentStartTime, !1), currentStartTime += currentStep.duration, currentStep = currentStep.next;
    this.animate.updateDuration();
  }
  getLastProps() {
    return this.prev ? this.prev.props || {} : this.animate.getStartProps();
  }
  setDuration(duration, updateDownstream = !0) {
    this.duration = duration, updateDownstream && this.updateDownstreamStartTimes();
  }
  getDuration() {
    return this.duration;
  }
  determineInterpolateUpdateFunction() {
    if (!this.props) return;
    const funcs = [];
    this.propKeys.forEach(key => {
      if ("fill" === key || "stroke" === key) {
        const from = this.fromProps[key],
          to = this.props[key];
        if (isString(from) && isString(to)) {
          const fromArray = ColorStore.Get(from, ColorType.Color255),
            toArray = ColorStore.Get(to, ColorType.Color255);
          this.fromParsedProps || (this.fromParsedProps = {}), this.toParsedProps || (this.toParsedProps = {}), this.fromParsedProps[key] = fromArray, this.toParsedProps[key] = toArray, funcs.push(interpolateUpdateStore["fill" === key ? "fillPure" : "strokePure"]);
        } else interpolateUpdateStore[key] ? funcs.push(interpolateUpdateStore[key]) : funcs.push(commonInterpolateUpdate);
      } else interpolateUpdateStore[key] ? funcs.push(interpolateUpdateStore[key]) : funcs.push(commonInterpolateUpdate);
    }), this.interpolateUpdateFunctions = funcs;
  }
  setStartTime(time, updateDownstream = !0) {
    this._startTime = time, updateDownstream && this.updateDownstreamStartTimes();
  }
  getStartTime() {
    return this._startTime;
  }
  onBind() {
    "glyph" === this.target.type && (this.syncAttributeUpdate = this._syncAttributeUpdate);
  }
  onFirstRun() {}
  onStart() {
    if (!this._hasFirstRun) {
      this._hasFirstRun = !0, this.fromProps = this.getLastProps();
      const startProps = this.animate.getStartProps();
      this.propKeys && this.propKeys.forEach(key => {
        var _a;
        this.fromProps[key] = null !== (_a = this.fromProps[key]) && void 0 !== _a ? _a : startProps[key];
      }), this.determineInterpolateUpdateFunction(), this.tryPreventConflict(), this.trySyncStartProps(), this.onFirstRun();
    }
  }
  tryPreventConflict() {
    const animate = this.animate;
    this.target.animates.forEach(a => {
      if (a === animate || a.priority > animate.priority || a.priority === 1 / 0) return;
      const fromProps = a.getStartProps();
      this.propKeys.forEach(key => {
        null != fromProps[key] && a.preventAttr(key);
      });
    });
  }
  deleteSelfAttr(key) {
    var _a;
    delete this.props[key], this.fromProps && delete this.fromProps[key];
    const index = this.propKeys.indexOf(key);
    -1 !== index && (this.propKeys.splice(index, 1), null === (_a = this.interpolateUpdateFunctions) || void 0 === _a || _a.splice(index, 1));
  }
  trySyncStartProps() {
    this.propKeys.forEach(key => {
      this.fromProps[key] = this.animate.target.getComputedAttribute(key);
    });
  }
  update(end, ratio, out) {
    if (this.onStart(), !this.props || !this.propKeys) return;
    const easedRatio = this.easing(ratio);
    this.animate.interpolateUpdateFunction ? this.animate.interpolateUpdateFunction(this.fromProps, this.props, easedRatio, this, this.target) : this.interpolateUpdateFunctions.forEach((func, index) => {
      if (!this.animate.validAttr(this.propKeys[index])) return;
      const key = this.propKeys[index];
      func(key, this.fromProps[key], this.props[key], easedRatio, this, this.target);
    }), this.onUpdate(end, easedRatio, out), this.syncAttributeUpdate();
  }
  onUpdate(end, ratio, out) {}
  onEnd(cb) {
    this.target.setAttributes(this.props), cb ? this._endCb = cb : this._endCb && this._endCb(this.animate, this);
  }
  getEndProps() {
    return this.props;
  }
  getFromProps() {
    return this.fromProps;
  }
  getMergedEndProps() {
    return this.getEndProps();
  }
  stop() {}
  release() {}
}
class WaitStep extends Step {
  constructor(type, props, duration, easing) {
    super(type, props, duration, easing);
  }
  onStart() {
    super.onStart();
    const fromProps = this.getFromProps();
    this.target.setAttributes(fromProps);
  }
  update(end, ratio, out) {
    this.onStart();
  }
  determineInterpolateUpdateFunction() {}
}

class DefaultTimeline extends EventEmitter {
  get animateCount() {
    return this._animateCount;
  }
  constructor() {
    super(), this.head = null, this.tail = null, this.animateMap = new Map(), this._animateCount = 0, this._playSpeed = 1, this._totalDuration = 0, this._startTime = 0, this._currentTime = 0, this._animationEndFlag = !0, this.id = Generator.GenAutoIncrementId(), this.paused = !1;
  }
  isRunning() {
    return !this.paused && this._animateCount > 0;
  }
  forEachAccessAnimate(cb) {
    let current = this.head,
      index = 0;
    for (; current;) {
      const next = current.next;
      cb(current.animate, index), index++, current = next;
    }
  }
  addAnimate(animate) {
    const newNode = {
      animate: animate,
      next: null,
      prev: null
    };
    this.head ? this.tail && (this.tail.next = newNode, newNode.prev = this.tail, this.tail = newNode) : (this.head = newNode, this.tail = newNode), this.animateMap.set(animate, newNode), this._animateCount++, this._totalDuration = Math.max(this._totalDuration, animate.getStartTime() + animate.getDuration());
  }
  pause() {
    this.paused = !0;
  }
  resume() {
    this.paused = !1;
  }
  tick(delta) {
    if (this.paused) return;
    this._animationEndFlag && (this._animationEndFlag = !1, this.emit("animationStart"));
    const scaledDelta = delta * this._playSpeed;
    this._currentTime += scaledDelta, this.forEachAccessAnimate((animate, i) => {
      animate.status === AnimateStatus.END ? this.removeAnimate(animate, !0) : animate.status !== AnimateStatus.RUNNING && animate.status !== AnimateStatus.INITIAL || animate.advance(scaledDelta);
    }), 0 === this._animateCount && (this._animationEndFlag = !0, this.emit("animationEnd"));
  }
  clear() {
    this.forEachAccessAnimate(animate => {
      animate.release();
    }), this.head = null, this.tail = null, this.animateMap.clear(), this._animateCount = 0, this._totalDuration = 0;
  }
  removeAnimate(animate, release = !0) {
    const node = this.animateMap.get(animate);
    node && (release && (animate._onRemove && animate._onRemove.forEach(cb => cb()), animate.release()), node.prev ? node.prev.next = node.next : this.head = node.next, node.next ? node.next.prev = node.prev : this.tail = node.prev, this.animateMap.delete(animate), this._animateCount--, animate.getStartTime() + animate.getDuration() >= this._totalDuration && this.recalculateTotalDuration());
  }
  recalculateTotalDuration() {
    this._totalDuration = 0, this.forEachAccessAnimate(animate => {
      this._totalDuration = Math.max(this._totalDuration, animate.getStartTime() + animate.getDuration());
    });
  }
  getTotalDuration() {
    return this._totalDuration;
  }
  getPlaySpeed() {
    return this._playSpeed;
  }
  setPlaySpeed(speed) {
    this._playSpeed = speed;
  }
  getPlayState() {
    return this.paused ? "paused" : 0 === this.animateCount ? "stopped" : "playing";
  }
  setStartTime(time) {
    this._startTime = time;
  }
  getStartTime() {
    return this._startTime;
  }
  getCurrentTime() {
    return this._currentTime;
  }
  setCurrentTime(time) {
    this._currentTime = time;
  }
}
const defaultTimeline = new DefaultTimeline();
defaultTimeline.isGlobal = !0;

class Animate {
  constructor(id = Generator.GenAutoIncrementId(), timeline = defaultTimeline, slience) {
    this.id = id, this.status = AnimateStatus.INITIAL, this._timeline = timeline, timeline.addAnimate(this), this.slience = slience, this._startTime = 0, this._duration = 0, this._totalDuration = 0, this._loopCount = 0, this._currentLoop = 0, this._bounce = !1, this._firstStep = null, this._lastStep = null, this._startProps = {}, this._endProps = {}, this._preventAttrs = new Set(), this.currentTime = 0, this.interpolateUpdateFunction = null, this.priority = 0;
  }
  getStartProps() {
    return this._startProps;
  }
  getEndProps() {
    return this._endProps;
  }
  setTimeline(timeline) {
    this._timeline = timeline;
  }
  getTimeline() {
    return this._timeline;
  }
  get timeline() {
    return this._timeline;
  }
  bind(target) {
    return this.target = target, this.target.animates || (this.target.animates = new Map()), this.target.animates.set(this.id, this), this.onRemove(() => {
      this.stop(), this.target.animates.delete(this.id);
    }), this.target.onAnimateBind && !this.slience && this.target.onAnimateBind(this), this.target.animationAttribute || (this.target.animationAttribute = {}), this;
  }
  to(props, duration = 300, easing = "linear") {
    const step = new Step(AnimateStepType.to, props, duration, easing);
    return step.bind(this.target, this), this.updateStepAfterAppend(step), this;
  }
  wait(delay) {
    const step = new WaitStep(AnimateStepType.wait, {}, delay, "linear");
    return step.bind(this.target, this), this.updateStepAfterAppend(step), this;
  }
  updateStepAfterAppend(step) {
    this._firstStep ? (this._lastStep.append(step), this._lastStep = step) : (this._firstStep = step, this._lastStep = step), this.parseStepProps(step), this.updateDuration();
  }
  parseStepProps(step) {
    this._lastStep && (step.propKeys = step.propKeys || Object.keys(step.props), Object.keys(this._endProps).forEach(key => {
      var _a;
      step.props[key] = null !== (_a = step.props[key]) && void 0 !== _a ? _a : this._endProps[key];
    }), step.propKeys.forEach(key => {
      this._endProps[key] = step.props[key];
    }));
  }
  reSyncProps() {
    if (!this._lastStep) return;
    this._endProps = {};
    let currentStep = this._firstStep;
    for (; currentStep;) Object.keys(this._endProps).forEach(key => {
      var _a;
      currentStep.props[key] = null !== (_a = currentStep.props[key]) && void 0 !== _a ? _a : this._endProps[key];
    }), currentStep.propKeys.forEach(key => {
      this._endProps[key] = currentStep.props[key];
    }), currentStep = currentStep.next;
  }
  from(props, duration = 300, easing = "linear") {
    const step = new Step(AnimateStepType.from, props, duration, easing);
    return this._firstStep ? (this._lastStep.append(step), this._lastStep = step) : (this._firstStep = step, this._lastStep = step), this.updateDuration(), this;
  }
  play(customAnimate) {
    return customAnimate.bind(this.target, this), this.updateStepAfterAppend(customAnimate), this;
  }
  pause() {
    this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.PAUSED);
  }
  resume() {
    this.status === AnimateStatus.PAUSED && (this.status = AnimateStatus.RUNNING);
  }
  onStart(cb) {
    var _a;
    cb ? (this._onStart || (this._onStart = []), this._onStart.push(cb)) : (null === (_a = this._onStart) || void 0 === _a || _a.forEach(cb => cb()), Object.keys(this._endProps).forEach(key => {
      this._startProps[key] = this.target.getComputedAttribute(key);
    }));
  }
  onEnd(cb) {
    var _a;
    cb ? (this._onEnd || (this._onEnd = []), this._onEnd.push(cb)) : null === (_a = this._onEnd) || void 0 === _a || _a.forEach(cb => cb());
  }
  onFrame(cb) {
    cb && (this._onFrame || (this._onFrame = []), this._onFrame.push(cb));
  }
  onRemove(cb) {
    var _a;
    cb ? (this._onRemove || (this._onRemove = []), this._onRemove.push(cb)) : null === (_a = this._onRemove) || void 0 === _a || _a.forEach(cb => cb());
  }
  preventAttr(key) {
    this._preventAttrs.add(key), delete this._startProps[key], delete this._endProps[key];
    let step = this._firstStep;
    for (; step;) step.deleteSelfAttr(key), step = step.next;
  }
  preventAttrs(keys) {
    keys.forEach(key => this._preventAttrs.add(key));
  }
  validAttr(key) {
    return !this._preventAttrs.has(key);
  }
  runCb(cb) {
    var _a;
    return null === (_a = this._lastStep) || void 0 === _a || _a.onEnd(cb), this;
  }
  startAt(t) {
    return this._startTime = t, this;
  }
  customInterpolate(key, ratio, from, to, target, ret) {
    return !1;
  }
  getFromValue() {
    return this._startProps;
  }
  getToValue() {
    return this._endProps;
  }
  stop(type) {
    let step = this._firstStep;
    for (; step;) step.stop(), step = step.next;
    this.status !== AnimateStatus.END && this.onEnd(), this.status = AnimateStatus.END, this.target && ("start" === type ? this.target.setAttributes(this._startProps) : "end" === type ? this.target.setAttributes(this._endProps) : type && this.target.setAttributes(type));
  }
  release() {
    this.status = AnimateStatus.END, this._onRemove && this._onRemove.forEach(cb => cb()), this._onStart = [], this._onFrame = [], this._onEnd = [], this._onRemove = [], this.forEachStep(step => {
      step.release();
    });
  }
  getDuration() {
    return this._duration;
  }
  getStartTime() {
    return this._startTime;
  }
  afterAll(list) {
    if (!list || 0 === list.length) return this;
    let maxEndTime = 0;
    return list.forEach(animate => {
      const endTime = animate.getStartTime() + animate.getTotalDuration();
      maxEndTime = Math.max(maxEndTime, endTime);
    }), this.startAt(maxEndTime);
  }
  after(animate) {
    if (!animate) return this;
    const endTime = animate.getStartTime() + animate.getTotalDuration();
    return this.startAt(endTime);
  }
  parallel(animate) {
    return animate ? (this.startAt(animate.getStartTime()), this) : this;
  }
  loop(n) {
    return !0 === n ? n = 1 / 0 : !1 === n && (n = 0), this._loopCount = n, this.updateDuration(), this;
  }
  bounce(b) {
    return this._bounce = b, this;
  }
  advance(delta) {
    var _a, _b, _c;
    if (this.status === AnimateStatus.END) return void console.warn("aaa 动画已经结束，不能推进");
    const nextTime = this.currentTime + delta;
    if (nextTime < this._startTime) return void (this.currentTime = nextTime);
    if (nextTime >= this._startTime + this._totalDuration) return null === (_a = this._lastStep) || void 0 === _a || _a.onUpdate(!0, 1, {}), null === (_b = this._lastStep) || void 0 === _b || _b.onEnd(), this.onEnd(), void (this.status = AnimateStatus.END);
    this.status = AnimateStatus.RUNNING, this.currentTime <= this._startTime && this.onStart(), this.currentTime = nextTime;
    let cycleTime = nextTime - this._startTime,
      newLoop = !1,
      bounceTime = !1;
    if (this._loopCount > 0) {
      cycleTime = (nextTime - this._startTime) % this._duration;
      const currentLoop = Math.floor((nextTime - this._startTime) / this._duration);
      newLoop = currentLoop > this._currentLoop, this._currentLoop = currentLoop, bounceTime = this._bounce && currentLoop % 2 == 1, bounceTime && (cycleTime = this._duration - cycleTime);
    }
    newLoop && !bounceTime && this.target.setAttributes(this._startProps);
    let targetStep = null;
    if (this._lastStep === this._firstStep) targetStep = this._firstStep;else {
      let currentStep = this._firstStep;
      for (; currentStep;) {
        const stepStartTime = currentStep.getStartTime(),
          stepDuration = currentStep.getDuration();
        if (cycleTime >= stepStartTime && cycleTime <= stepStartTime + stepDuration) {
          targetStep = currentStep;
          break;
        }
        currentStep = currentStep.next;
      }
    }
    if (!targetStep) return;
    targetStep !== this.lastRunStep && (null === (_c = this.lastRunStep) || void 0 === _c || _c.onEnd()), this.lastRunStep = targetStep;
    const ratio = (cycleTime - targetStep.getStartTime()) / targetStep.getDuration(),
      isEnd = ratio >= 1;
    targetStep.update(isEnd, ratio, {}), isEnd && (targetStep.onEnd(), this.lastRunStep = null);
  }
  updateDuration() {
    this._lastStep ? (this._duration = this._lastStep.getStartTime() + this._lastStep.getDuration(), this._totalDuration = this._duration * (this._loopCount + 1)) : this._duration = 0;
  }
  getTotalDuration() {
    return this._totalDuration;
  }
  getLoop() {
    return this._loopCount;
  }
  forEachStep(cb) {
    let step = this._firstStep;
    for (; step;) cb(step), step = step.next;
  }
}

const performanceRAF = new PerformanceRAF();
class RAFTickHandler {
  constructor() {
    this.released = !1;
  }
  tick(interval, cb) {
    performanceRAF.addAnimationFrameCb(() => {
      if (!this.released) return cb(this);
    });
  }
  release() {
    this.released = !0;
  }
  getTime() {
    return Date.now();
  }
}
class DefaultTicker extends EventEmitter {
  constructor(stage) {
    super(), this.timelines = [], this.frameTimeHistory = [], this.handleTick = (handler, params) => {
      const {
        once = !1
      } = null != params ? params : {};
      if (this.ifCanStop()) return this.stop(), !1;
      const currentTime = handler.getTime();
      this._lastTickTime = currentTime, this.lastFrameTime < 0 && (this.lastFrameTime = currentTime - this.interval + this.timeOffset, this.frameTimeHistory.push(this.lastFrameTime));
      const delta = currentTime - this.lastFrameTime,
        skip = this.checkSkip(delta);
      return skip || (this._handlerTick(delta), this.lastFrameTime = currentTime, this.frameTimeHistory.push(this.lastFrameTime)), once || handler.tick(this.interval, this.handleTick), !skip;
    }, this._handlerTick = delta => {
      this.status === STATUS$1.RUNNING && (this.tickCounts++, this.timelines.forEach(timeline => {
        timeline.tick(delta);
      }), this.emit("tick", delta));
    }, this.init(), this.lastFrameTime = -1, this.tickCounts = 0, this.stage = stage, this.autoStop = !0, this.interval = 16, this.computeTimeOffsetAndJitter();
  }
  bindStage(stage) {
    this.stage = stage;
  }
  computeTimeOffsetAndJitter() {
    this.timeOffset = Math.floor(Math.random() * this.interval), this._jitter = Math.min(Math.max(.2 * this.interval, 6), .7 * this.interval);
  }
  init() {
    this.interval = 16, this.status = STATUS$1.INITIAL, application.global.hooks.onSetEnv.tap("graph-ticker", () => {
      this.initHandler(!1);
    }), application.global.env && this.initHandler(!1);
  }
  addTimeline(timeline) {
    this.timelines.push(timeline);
  }
  remTimeline(timeline) {
    this.timelines = this.timelines.filter(t => t !== timeline);
  }
  getTimelines() {
    return this.timelines;
  }
  initHandler(force = !1) {
    this.setupTickHandler(force);
  }
  setupTickHandler(force = !1) {
    if (!force && this.tickerHandler) return !0;
    const handler = new RAFTickHandler();
    return this.tickerHandler && this.tickerHandler.release(), this.tickerHandler = handler, !0;
  }
  setInterval(interval) {
    this.interval = interval, this.computeTimeOffsetAndJitter();
  }
  getInterval() {
    return this.interval;
  }
  setFPS(fps) {
    this.setInterval(Math.floor(1e3 / fps));
  }
  getFPS() {
    return 1e3 / this.interval;
  }
  tick(interval) {
    this.tickerHandler.tick(interval, handler => this.handleTick(handler, {
      once: !0
    }));
  }
  tickTo(t) {
    this.tickerHandler.tickTo && this.tickerHandler.tickTo(t, handler => {
      this.handleTick(handler, {
        once: !0
      });
    });
  }
  pause() {
    return this.status !== STATUS$1.INITIAL && (this.status = STATUS$1.PAUSE, !0);
  }
  resume() {
    return this.status !== STATUS$1.INITIAL && (this.status = STATUS$1.RUNNING, !0);
  }
  ifCanStop() {
    if (this.autoStop) {
      if (!this.timelines.length) return !0;
      if (this.timelines.every(timeline => !timeline.isRunning())) return !0;
    }
    return !1;
  }
  start(force = !1) {
    if (this.status === STATUS$1.RUNNING) return !1;
    if (!this.tickerHandler) return !1;
    if (!force) {
      if (this.status === STATUS$1.PAUSE) return !1;
      if (this.ifCanStop()) return !1;
    }
    return this.status = STATUS$1.RUNNING, this.tickerHandler.tick(0, this.handleTick), !0;
  }
  stop() {
    this.status = STATUS$1.INITIAL, this.setupTickHandler(!0), this.lastFrameTime = -1;
  }
  trySyncTickStatus() {
    this.status === STATUS$1.INITIAL && this.timelines.some(timeline => timeline.isRunning()) ? this.start() : this.status === STATUS$1.RUNNING && this.timelines.every(timeline => !timeline.isRunning()) && this.stop();
  }
  release() {
    var _a;
    this.stop(), this.timelines = [], null === (_a = this.tickerHandler) || void 0 === _a || _a.release(), this.tickerHandler = null, this.lastFrameTime = -1;
  }
  checkSkip(delta) {
    var _a, _b, _c;
    if ("performance" === (null === (_c = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.params) || void 0 === _b ? void 0 : _b.optimize) || void 0 === _c ? void 0 : _c.tickRenderMode)) return !1;
    return delta < this.interval + 2 * (Math.random() - .5) * this._jitter;
  }
}

class AnimationTransitionRegistry {
  constructor() {
    this.transitions = new Map(), this.registerDefaultTransitions();
  }
  static getInstance() {
    return AnimationTransitionRegistry.instance || (AnimationTransitionRegistry.instance = new AnimationTransitionRegistry()), AnimationTransitionRegistry.instance;
  }
  registerDefaultTransitions() {
    this.registerTransition("appear", "*", () => ({
      allowTransition: !0,
      stopOriginalTransition: !1
    })), this.registerTransition("appear", "appear", () => ({
      allowTransition: !1,
      stopOriginalTransition: !1
    })), this.registerTransition("appear", "disappear", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    })), this.registerTransition("appear", "exit", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    })), this.registerTransition("normal", "*", () => ({
      allowTransition: !0,
      stopOriginalTransition: !1
    })), this.registerTransition("normal", "normal", () => ({
      allowTransition: !1,
      stopOriginalTransition: !1
    })), this.registerTransition("normal", "disappear", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    })), this.registerTransition("normal", "exit", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    })), this.registerTransition("exit", "*", () => ({
      allowTransition: !1,
      stopOriginalTransition: !1
    })), this.registerTransition("exit", "disappear", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    })), this.registerTransition("exit", "enter", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    })), this.registerTransition("exit", "exit", () => ({
      allowTransition: !1,
      stopOriginalTransition: !1
    })), this.registerTransition("enter", "*", () => ({
      allowTransition: !0,
      stopOriginalTransition: !1
    })), this.registerTransition("enter", "enter", () => ({
      allowTransition: !1,
      stopOriginalTransition: !1
    })), this.registerTransition("enter", "disappear", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    })), this.registerTransition("enter", "exit", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    })), this.registerTransition("disappear", "*", () => ({
      allowTransition: !1,
      stopOriginalTransition: !1
    })), this.registerTransition("disappear", "appear", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    })), this.registerTransition("update", "*", () => ({
      allowTransition: !0,
      stopOriginalTransition: !1
    })), this.registerTransition("update", "disappear", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    })), this.registerTransition("update", "exit", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    })), this.registerTransition("state", "*", () => ({
      allowTransition: !0,
      stopOriginalTransition: !1
    })), this.registerTransition("state", "disappear", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    })), this.registerTransition("state", "exit", () => ({
      allowTransition: !0,
      stopOriginalTransition: !0
    }));
  }
  isTransitionAllowed(fromState, toState, graphic) {
    var _a, _b, _c, _d;
    let func = null === (_a = this.transitions.get(fromState)) || void 0 === _a ? void 0 : _a.get(toState);
    return func ? func(graphic, fromState) : (func = null === (_b = this.transitions.get(fromState)) || void 0 === _b ? void 0 : _b.get("*"), func ? func(graphic, fromState) : (func = null === (_c = this.transitions.get("*")) || void 0 === _c ? void 0 : _c.get(toState), func ? func(graphic, fromState) : (func = null === (_d = this.transitions.get("*")) || void 0 === _d ? void 0 : _d.get("*"), func ? func(graphic, fromState) : {
      allowTransition: !0,
      stopOriginalTransition: !0
    })));
  }
  registerTransition(fromState, toState, transition) {
    let fromStateMap = this.transitions.get(fromState);
    fromStateMap || (fromStateMap = new Map(), this.transitions.set(fromState, fromStateMap)), fromStateMap.set(toState, transition);
  }
}
AnimationTransitionRegistry.getInstance();

class AnimateExecutor {
  static registerBuiltInAnimate(name, animate) {
    AnimateExecutor.builtInAnimateMap[name] = animate;
  }
  constructor(target) {
    this._animates = [], this._startCallbacks = [], this._endCallbacks = [], this._started = !1, this._activeCount = 0, this._target = target;
  }
  get started() {
    return this._started;
  }
  onStart(cb) {
    cb ? (this._startCallbacks.push(cb), this._started && this._activeCount > 0 && cb()) : this._startCallbacks.forEach(cb => {
      cb();
    });
  }
  onEnd(cb) {
    cb ? this._endCallbacks.push(cb) : this._endCallbacks.forEach(cb => {
      cb();
    });
  }
  _trackAnimation(animate) {
    this._animates.push(animate), this._activeCount++, 1 !== this._activeCount || this._started || (this._started = !0, this.onStart()), animate.onEnd(() => {
      this._activeCount--;
      const index = this._animates.indexOf(animate);
      index >= 0 && this._animates.splice(index, 1), 0 === this._activeCount && this._started && (this._started = !1, this.onEnd());
    });
  }
  parseParams(params, isTimeline, child) {
    var _a, _b;
    const totalTime = this.resolveValue(params.totalTime, void 0, void 0),
      startTime = this.resolveValue(params.startTime, void 0, 0),
      parsedParams = Object.assign({}, params);
    parsedParams.oneByOneDelay = 0, parsedParams.startTime = startTime, parsedParams.totalTime = totalTime;
    const oneByOne = this.resolveValue(params.oneByOne, child, !1);
    if (isTimeline) {
      const timeSlices = parsedParams.timeSlices;
      isArray(timeSlices) || (parsedParams.timeSlices = [timeSlices]);
      let sliceTime = 0;
      parsedParams.timeSlices = parsedParams.timeSlices.map(slice => {
        const delay = this.resolveValue(slice.delay, child, 0),
          delayAfter = this.resolveValue(slice.delayAfter, child, 0),
          duration = this.resolveValue(slice.duration, child, 300);
        return sliceTime += delay + duration + delayAfter, Object.assign(Object.assign({}, slice), {
          delay: delay,
          delayAfter: delayAfter,
          duration: duration
        });
      });
      let oneByOneDelay = 0;
      oneByOne && (oneByOneDelay = "number" == typeof oneByOne ? oneByOne : oneByOne ? sliceTime : 0), parsedParams.oneByOneDelay = oneByOneDelay;
      let scale = 1;
      if (totalTime) {
        const _totalTime = sliceTime + oneByOneDelay * (this._target.count - 2);
        scale = totalTime ? totalTime / _totalTime : 1;
      }
      parsedParams.timeSlices = parsedParams.timeSlices.map(slice => {
        let effects = slice.effects;
        return Array.isArray(effects) || (effects = [effects]), Object.assign(Object.assign({}, slice), {
          delay: slice.delay * scale,
          delayAfter: slice.delayAfter * scale,
          duration: slice.duration * scale,
          effects: effects.map(effect => {
            var _a, _b;
            const custom = null !== (_a = effect.custom) && void 0 !== _a ? _a : AnimateExecutor.builtInAnimateMap[null !== (_b = effect.type) && void 0 !== _b ? _b : "fromTo"],
              customType = custom && isFunction(custom) ? /^class\s/.test(Function.prototype.toString.call(custom)) ? 1 : 2 : 0;
            return Object.assign(Object.assign({}, effect), {
              custom: custom,
              customType: customType
            });
          })
        });
      }), parsedParams.oneByOneDelay = oneByOneDelay * scale, parsedParams.startTime = startTime * scale;
    } else {
      const delay = this.resolveValue(params.delay, child, 0),
        delayAfter = this.resolveValue(params.delayAfter, child, 0),
        duration = this.resolveValue(params.duration, child, 300);
      let oneByOneDelay = 0;
      oneByOne && (oneByOneDelay = "number" == typeof oneByOne ? oneByOne : oneByOne ? delay + delayAfter + duration : 0), parsedParams.oneByOneDelay = oneByOneDelay, parsedParams.custom = null !== (_a = params.custom) && void 0 !== _a ? _a : AnimateExecutor.builtInAnimateMap[null !== (_b = params.type) && void 0 !== _b ? _b : "fromTo"];
      const customType = parsedParams.custom && isFunction(parsedParams.custom) ? /^class\s/.test(Function.prototype.toString.call(parsedParams.custom)) ? 1 : 2 : 0;
      if (parsedParams.customType = customType, totalTime) {
        const _totalTime = delay + delayAfter + duration + oneByOneDelay * (this._target.count - 2),
          scale = totalTime ? totalTime / _totalTime : 1;
        parsedParams.delay = delay * scale, parsedParams.delayAfter = delayAfter * scale, parsedParams.duration = duration * scale, parsedParams.oneByOneDelay = oneByOneDelay * scale, parsedParams.startTime = startTime;
      }
    }
    return parsedParams;
  }
  execute(params) {
    Array.isArray(params) ? params.forEach(param => this._execute(param)) : this._execute(params);
  }
  _execute(params) {
    if (params.selfOnly) return this._executeItem(params, this._target, 0, 1);
    const isTimeline = ("timeSlices" in params);
    let filteredChildren;
    isTimeline && params.partitioner && (filteredChildren = (null != filteredChildren ? filteredChildren : this._target.getChildren()).filter(child => {
      var _a, _b;
      return params.partitioner(null === (_b = null === (_a = child.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], child, {});
    })), isTimeline && params.sort && (filteredChildren = null != filteredChildren ? filteredChildren : this._target.getChildren(), filteredChildren.sort((a, b) => {
      var _a, _b, _c, _d;
      return params.sort(null === (_b = null === (_a = a.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], null === (_d = null === (_c = b.context) || void 0 === _c ? void 0 : _c.data) || void 0 === _d ? void 0 : _d[0], a, b, {});
    }));
    const cb = isTimeline ? (child, index, count) => {
      const parsedParams = this.parseParams(params, isTimeline, child),
        animate = this.executeTimelineItem(parsedParams, child, index, count);
      animate && this._trackAnimation(animate);
    } : (child, index, count) => {
      const parsedParams = this.parseParams(params, isTimeline, child),
        animate = this.executeTypeConfigItem(parsedParams, child, index, count);
      animate && this._trackAnimation(animate);
    };
    filteredChildren ? filteredChildren.forEach((child, index) => cb(child, index, filteredChildren.length)) : this._target.count <= 1 ? cb(this._target, 0, 1) : this._target.forEachChildren((child, index) => cb(child, index, this._target.count - 1));
  }
  executeTypeConfigItem(params, graphic, index, count) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const {
        type = "fromTo",
        channel: channel,
        customParameters: customParameters,
        easing = "linear",
        delay = 0,
        delayAfter = 0,
        duration = 300,
        startTime = 0,
        oneByOneDelay = 0,
        loop: loop,
        bounce: bounce,
        priority = 0,
        options: options,
        custom: custom,
        customType: customType,
        controlOptions: controlOptions
      } = params,
      animate = graphic.animate();
    animate.priority = priority;
    const delayValue = isFunction(delay) ? delay(null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], graphic, {}) : delay,
      datum = null === (_d = null === (_c = graphic.context) || void 0 === _c ? void 0 : _c.data) || void 0 === _d ? void 0 : _d[0],
      indexKey = null === (_e = graphic.context) || void 0 === _e ? void 0 : _e.indexKey;
    datum && indexKey && (index = null !== (_f = datum[indexKey]) && void 0 !== _f ? _f : index), animate.startAt(startTime);
    const wait = index * oneByOneDelay + delayValue;
    wait > 0 && animate.wait(wait);
    let parsedFromProps = null,
      props = params.to,
      from = params.from;
    props || (parsedFromProps || (parsedFromProps = this.createPropsFromChannel(channel, graphic)), props = parsedFromProps.props), from || (parsedFromProps || (parsedFromProps = this.createPropsFromChannel(channel, graphic)), from = parsedFromProps.from), this._handleRunAnimate(animate, custom, customType, from, props, duration, easing, customParameters, controlOptions, options, type, graphic);
    let totalDelay = 0;
    oneByOneDelay && (totalDelay = oneByOneDelay * (count - index - 1));
    const delayAfterValue = isFunction(delayAfter) ? delayAfter(null === (_h = null === (_g = graphic.context) || void 0 === _g ? void 0 : _g.data) || void 0 === _h ? void 0 : _h[0], graphic, {}) : delayAfter;
    return delayAfterValue > 0 && (totalDelay += delayAfterValue), totalDelay > 0 && animate.wait(totalDelay), loop && loop > 0 && animate.loop(loop), bounce && animate.bounce(!0), animate;
  }
  _handleRunAnimate(animate, custom, customType, from, props, duration, easing, customParameters, controlOptions, options, type, graphic) {
    var _a, _b, _c, _d, _e, _f;
    if (custom && customType) {
      const customParams = Object.assign({
          width: (null === (_a = graphic.stage) || void 0 === _a ? void 0 : _a.width) || 0,
          height: (null === (_b = graphic.stage) || void 0 === _b ? void 0 : _b.height) || 0,
          group: this._target.parent
        }, this.resolveValue(customParameters, graphic)),
        objOptions = isFunction(options) ? options.call(null, null !== (_d = customParams && (null === (_c = customParams.data) || void 0 === _c ? void 0 : _c[0])) && void 0 !== _d ? _d : null === (_f = null === (_e = graphic.context) || void 0 === _e ? void 0 : _e.data) || void 0 === _f ? void 0 : _f[0], graphic, customParams) : options;
      customParams.options = objOptions, customParams.controlOptions = controlOptions, 1 === customType ? this.createCustomAnimation(animate, custom, from, props, duration, easing, customParams) : 2 === customType && this.createCustomInterpolatorAnimation(animate, custom, props, duration, easing, customParams);
    } else "to" === type ? animate.to(props, duration, easing) : "from" === type && animate.from(props, duration, easing);
  }
  executeTimelineItem(params, graphic, index, count) {
    var _a, _b, _c, _d;
    const {
        timeSlices: timeSlices,
        startTime = 0,
        loop: loop,
        bounce: bounce,
        oneByOneDelay: oneByOneDelay,
        priority: priority,
        controlOptions: controlOptions
      } = params,
      datum = null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0],
      indexKey = null === (_c = graphic.context) || void 0 === _c ? void 0 : _c.indexKey;
    datum && indexKey && (index = null !== (_d = datum[indexKey]) && void 0 !== _d ? _d : index);
    const animate = graphic.animate();
    animate.priority = priority, animate.startAt(startTime), animate.wait(index * oneByOneDelay), loop && loop > 0 && animate.loop(loop), bounce && animate.bounce(!0);
    return (Array.isArray(timeSlices) ? timeSlices : [timeSlices]).forEach(slice => {
      this.applyTimeSliceToAnimate(slice, animate, graphic, controlOptions);
    }), oneByOneDelay && animate.wait(oneByOneDelay * (count - index - 1)), animate;
  }
  applyTimeSliceToAnimate(slice, animate, graphic, controlOptions) {
    var _a, _b, _c, _d;
    const {
        effects: effects,
        duration = 300,
        delay = 0,
        delayAfter = 0
      } = slice,
      delayValue = isFunction(delay) ? delay(null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], graphic, {}) : delay,
      delayAfterValue = isFunction(delayAfter) ? delayAfter(null === (_d = null === (_c = graphic.context) || void 0 === _c ? void 0 : _c.data) || void 0 === _d ? void 0 : _d[0], graphic, {}) : delayAfter;
    delayValue > 0 && animate.wait(delayValue);
    (Array.isArray(effects) ? effects : [effects]).forEach(effect => {
      var _a;
      const {
        type = "fromTo",
        channel: channel,
        customParameters: customParameters,
        easing = "linear",
        options: options
      } = effect;
      let parsedFromProps = null,
        props = effect.to,
        from = effect.from;
      props || (parsedFromProps || (parsedFromProps = this.createPropsFromChannel(channel, graphic)), props = parsedFromProps.props), from || (parsedFromProps || (parsedFromProps = this.createPropsFromChannel(channel, graphic)), from = parsedFromProps.from);
      const custom = null !== (_a = effect.custom) && void 0 !== _a ? _a : AnimateExecutor.builtInAnimateMap[type],
        customType = effect.customType;
      this._handleRunAnimate(animate, custom, customType, from, props, duration, easing, customParameters, controlOptions, options, type, graphic);
    }), delayAfterValue > 0 && animate.wait(delayAfterValue);
  }
  createCustomInterpolatorAnimation(animate, interpolator, props, duration, easing, customParams) {
    const to = props;
    Object.keys(to).forEach(key => {
      animate.target.getComputedAttribute(key);
    }), animate.interpolateUpdateFunction = (from, to, ratio, step, target) => {
      interpolator(ratio, from, to, step, target, animate.target, customParams);
    }, animate.to(props, duration, easing);
  }
  createCustomAnimation(animate, CustomAnimateConstructor, from, props, duration, easing, customParams) {
    const customAnimate = new CustomAnimateConstructor(from, props, duration, easing, customParams);
    animate.play(customAnimate);
  }
  createPropsFromChannel(channel, graphic) {
    const props = {};
    let from = null;
    return channel ? (Array.isArray(channel) ? channel.forEach(key => {
      var _a, _b;
      const value = null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.diffAttrs) || void 0 === _b ? void 0 : _b[key];
      void 0 !== value && (props[key] = value);
    }) : Object.keys(channel).forEach(key => {
      var _a, _b, _c, _d;
      const config = channel[key];
      void 0 !== config.to && ("function" == typeof config.to ? props[key] = config.to(null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], graphic, {}) : props[key] = config.to), void 0 !== config.from && (from || (from = {}), "function" == typeof config.from ? from[key] = config.from(null === (_d = null === (_c = graphic.context) || void 0 === _c ? void 0 : _c.data) || void 0 === _d ? void 0 : _d[0], graphic, {}) : from[key] = config.from);
    }), {
      from: from,
      props: props
    }) : {
      from: from,
      props: props
    };
  }
  resolveValue(value, graphic, defaultValue) {
    var _a, _b;
    return void 0 === value ? defaultValue : "function" == typeof value && graphic ? value(null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], graphic, {}) : value;
  }
  executeItem(params, graphic, index = 0, count = 1) {
    return Array.isArray(params) ? params.map(param => this._executeItem(param, graphic, index, count)).filter(Boolean) : [this._executeItem(params, graphic, index, count)].filter(Boolean);
  }
  _executeItem(params, graphic, index = 0, count = 1) {
    if (!graphic) return null;
    const isTimeline = ("timeSlices" in params);
    let animate = null;
    const parsedParams = this.parseParams(params, isTimeline);
    return animate = isTimeline ? this.executeTimelineItem(parsedParams, graphic, index, count) : this.executeTypeConfigItem(parsedParams, graphic, index, count), animate && this._trackAnimation(animate), animate;
  }
  stop(type) {
    for (; this._animates.length > 0;) {
      const animate = this._animates.pop();
      null == animate || animate.stop(type);
    }
    this._animates = [], this._activeCount = 0, this._started && (this._started = !1, this.onEnd());
  }
}
AnimateExecutor.builtInAnimateMap = {};

const AnimationStates = {
  APPEAR: "appear",
  DISAPPEAR: "disappear",
  UPDATE: "update",
  HIGHLIGHT: "highlight",
  UNHIGHLIGHT: "unhighlight",
  SELECT: "select",
  UNSELECT: "unselect",
  HOVER: "hover",
  UNHOVER: "unhover",
  ACTIVE: "active",
  INACTIVE: "inactive"
};
class AnimationStateStore {
  constructor(graphic) {
    this.graphic = graphic;
  }
  registerState(state) {
    this.states || (this.states = new Map()), this.states.set(state.name, state);
  }
  clearStates() {
    var _a;
    null === (_a = this.states) || void 0 === _a || _a.clear();
  }
}
class AnimationStateManager {
  constructor(graphic) {
    this.stateList = null, this.graphic = graphic;
  }
  applyState(nextState, animationConfig, callback) {
    const registry = AnimationTransitionRegistry.getInstance(),
      shouldStopState = [],
      shouldApplyState = [];
    if (this.stateList && this.stateList.length ? nextState.forEach((state, index) => {
      const result = {
        allowTransition: !0,
        stopOriginalTransition: !0
      };
      this.stateList.forEach(currState => {
        const _result = registry.isTransitionAllowed(currState.state, state, this.graphic);
        result.allowTransition = result.allowTransition && _result.allowTransition;
      }), result.allowTransition && (shouldApplyState.push({
        state: state,
        animationConfig: isArray(animationConfig[index]) ? animationConfig[index].map(item => item.animation) : animationConfig[index].animation,
        executor: new AnimateExecutor(this.graphic)
      }), this.stateList.forEach(currState => {
        registry.isTransitionAllowed(currState.state, state, this.graphic).stopOriginalTransition && shouldStopState.push(currState);
      }));
    }) : nextState.forEach((state, index) => {
      shouldApplyState.push({
        state: state,
        animationConfig: isArray(animationConfig[index]) ? animationConfig[index].map(item => item.animation) : animationConfig[index].animation,
        executor: new AnimateExecutor(this.graphic)
      });
    }), shouldStopState.forEach(state => {
      state.executor.stop();
    }), shouldApplyState.length) {
      shouldApplyState[0].executor.execute(shouldApplyState[0].animationConfig);
      for (let i = 0; i < shouldApplyState.length; i++) {
        const nextState = shouldApplyState[i + 1],
          currentState = shouldApplyState[i];
        currentState.executor.onEnd(() => {
          nextState && nextState.executor.execute(nextState.animationConfig), this.stateList = this.stateList.filter(state => state !== currentState), i === shouldApplyState.length - 1 && callback && callback(!1);
        });
      }
    } else callback && callback(!0);
    this.stateList ? this.stateList = this.stateList.filter(state => !shouldStopState.includes(state)) : this.stateList = [], this.stateList.push(...shouldApplyState);
  }
  applyAppearState(animationConfig, callback) {
    this.applyState([AnimationStates.APPEAR], [{
      name: AnimationStates.APPEAR,
      animation: animationConfig
    }], callback);
  }
  applyDisappearState(animationConfig, callback) {
    this.applyState([AnimationStates.DISAPPEAR], [{
      name: AnimationStates.DISAPPEAR,
      animation: animationConfig
    }], callback);
  }
  applyUpdateState(animationConfig, callback) {
    this.applyState([AnimationStates.UPDATE], [{
      name: AnimationStates.UPDATE,
      animation: animationConfig
    }], callback);
  }
  applyHighlightState(animationConfig, callback) {
    this.applyState([AnimationStates.HIGHLIGHT], [{
      name: AnimationStates.HIGHLIGHT,
      animation: animationConfig
    }], callback);
  }
  applyUnhighlightState(animationConfig, callback) {
    this.applyState([AnimationStates.UNHIGHLIGHT], [{
      name: AnimationStates.UNHIGHLIGHT,
      animation: animationConfig
    }], callback);
  }
  stopState(state, type) {
    var _a;
    const stateInfo = null === (_a = this.stateList) || void 0 === _a ? void 0 : _a.find(stateInfo => stateInfo.state === state);
    stateInfo && stateInfo.executor.stop(type);
  }
  clearState() {
    var _a;
    null === (_a = this.stateList) || void 0 === _a || _a.forEach(state => {
      state.executor.stop();
    }), this.stateList = null;
  }
  reApplyState(state) {
    var _a;
    const stateInfo = null === (_a = this.stateList) || void 0 === _a ? void 0 : _a.find(stateInfo => stateInfo.state === state);
    if (stateInfo && stateInfo.executor.started) {
      const stateList = this.stateList.slice();
      stateInfo.executor.stop(), this.stateList = stateList, stateInfo.executor.execute(stateInfo.animationConfig);
    }
  }
}

class GraphicStateExtension {
  _getAnimationStateManager(graphic) {
    return graphic._animationStateManager || (graphic._animationStateManager = new AnimationStateManager(graphic)), graphic._animationStateManager;
  }
  _getAnimationStateStore(graphic) {
    return graphic._animationStateStore || (graphic._animationStateStore = new AnimationStateStore(graphic)), graphic._animationStateStore;
  }
  registerAnimationState(state) {
    return this._getAnimationStateStore(this).registerState(state), this;
  }
  applyAnimationState(state, animationConfig, callback) {
    return this._getAnimationStateManager(this).applyState(state, animationConfig, callback), this;
  }
  applyAppearState(animationConfig, callback) {
    return this._getAnimationStateManager(this).applyAppearState(animationConfig, callback), this;
  }
  applyDisappearState(animationConfig, callback) {
    return this._getAnimationStateManager(this).applyDisappearState(animationConfig, callback), this;
  }
  applyUpdateState(animationConfig, callback) {
    return this._getAnimationStateManager(this).applyUpdateState(animationConfig, callback), this;
  }
  applyHighlightState(animationConfig, callback) {
    return this._getAnimationStateManager(this).applyHighlightState(animationConfig, callback), this;
  }
  applyUnhighlightState(animationConfig, callback) {
    return this._getAnimationStateManager(this).applyUnhighlightState(animationConfig, callback), this;
  }
  stopAnimationState(state, type, deep = !1) {
    return this._getAnimationStateManager(this).stopState(state, type), deep && this.isContainer && this.forEachChildren(child => {
      child.stopAnimationState(state, type, deep);
    }), this;
  }
  clearAnimationStates() {
    const stateManager = this._animationStateManager;
    return stateManager && stateManager.clearState(), this;
  }
  reApplyAnimationState(state, deep = !1) {
    const stateManager = this._animationStateManager;
    return stateManager && stateManager.reApplyState(state), deep && this.isContainer && this.forEachChildren(child => {
      child.reApplyAnimationState(state, deep);
    }), this;
  }
  static extend(graphic) {
    return new GraphicStateExtension()._getAnimationStateManager(graphic), graphic;
  }
}

class AnimateExtension {
  getAttributes(final = !1) {
    return final && this.finalAttribute ? this.finalAttribute : this.attribute;
  }
  animate(params) {
    var _a, _b, _c;
    const animate = new Animate(null == params ? void 0 : params.id, null !== (_b = null !== (_a = null == params ? void 0 : params.timeline) && void 0 !== _a ? _a : this.stage && this.stage.getTimeline()) && void 0 !== _b ? _b : defaultTimeline, null == params ? void 0 : params.slience);
    if (animate.bind(this), params) {
      const {
        onStart: onStart,
        onEnd: onEnd,
        onRemove: onRemove
      } = params;
      null != onStart && animate.onStart(onStart), null != onEnd && animate.onEnd(onEnd), null != onRemove && animate.onRemove(onRemove);
    }
    return null === (_c = this.stage) || void 0 === _c || _c.ticker.start(), animate;
  }
  createTimeline() {
    return new DefaultTimeline();
  }
  createTicker(stage) {
    return new DefaultTicker(stage);
  }
  setFinalAttributes(finalAttribute) {
    this.finalAttribute || (this.finalAttribute = {}), Object.assign(this.finalAttribute, finalAttribute);
  }
  initFinalAttributes(finalAttribute) {
    this.finalAttribute = finalAttribute;
  }
  initAnimateExecutor() {
    this._animateExecutor || (this._animateExecutor = new AnimateExecutor(this));
  }
  executeAnimation(config) {
    return this.initAnimateExecutor(), this._animateExecutor.execute(config), this;
  }
  executeAnimations(configs) {
    return this.initAnimateExecutor(), configs.forEach(config => {
      this._animateExecutor.execute(config);
    }), this;
  }
  getFinalAttribute() {
    return this.finalAttribute;
  }
  getGraphicAttribute(key, prev = !1) {
    return !prev && this.finalAttribute ? this.finalAttribute[key] : this.attribute[key];
  }
  pauseAnimation(deep = !1) {
    this.animates && this.animates.forEach(animate => animate.pause()), deep && this.isContainer && this.forEachChildren(child => {
      child.pauseAnimation(deep);
    });
  }
  resumeAnimation(deep = !1) {
    this.animates && this.animates.forEach(animate => animate.resume()), deep && this.isContainer && this.forEachChildren(child => {
      child.resumeAnimation(deep);
    });
  }
  stopAnimation(deep = !1) {
    this.animates && this.animates.forEach(animate => animate.stop()), deep && this.isContainer && this.forEachChildren(child => {
      child.stopAnimation(deep);
    });
  }
}

function registerAnimate() {
  mixin(Graphic, GraphicStateExtension), mixin(Graphic, AnimateExtension);
}

class ACustomAnimate extends Step {
  constructor(customFrom, customTo, duration, easing, params) {
    super("customAnimate", customTo, duration, easing), this.type = "customAnimate", this.customFrom = customFrom, this.params = params, this.from = customFrom, this.to = customTo;
  }
  update(end, ratio, out) {
    if (this.onStart(), !this.props || !this.propKeys) return;
    const easedRatio = this.easing(ratio);
    this.onUpdate(end, easedRatio, out), this.syncAttributeUpdate();
  }
  setProps(props) {
    this.props = props, this.propKeys = Object.keys(props), this.animate.reSyncProps();
  }
}
class AComponentAnimate extends ACustomAnimate {
  completeBind(animator) {
    this.setStartTime(0), this._animator && this._animator.start(), this.setDuration(animator.getDuration());
  }
  stop() {
    this._animator && this._animator.stop();
  }
}

class ComponentAnimator {
  constructor(component) {
    this.tasks = [], this.started = !1, this.completed = 0, this.totalDuration = 0, this.onStartCallbacks = [], this.onEndCallbacks = [], this.onUpdateCallbacks = [], this.component = component;
  }
  animate(graphic, config) {
    return this.started ? (console.warn("Cannot add animations after animation has started"), this) : (this.tasks.push({
      graphic: graphic,
      config: config
    }), this);
  }
  onStart(callback) {
    return this.onStartCallbacks.push(callback), this;
  }
  onEnd(callback) {
    return this.onEndCallbacks.push(callback), this;
  }
  onUpdate(callback) {
    return this.onUpdateCallbacks.push(callback), this;
  }
  start() {
    return this.started ? (console.warn("Animation has already started"), this) : (this.started = !0, this.completed = 0, this.onStartCallbacks.forEach(callback => callback()), 0 === this.tasks.length ? (setTimeout(() => {
      this.onEndCallbacks.forEach(callback => callback());
    }, 0), this) : (this.tasks.forEach(task => {
      const executor = new AnimateExecutor(task.graphic);
      executor.onEnd(() => {
        this.completed++, this.completed === this.tasks.length && this.onEndCallbacks.forEach(callback => callback());
      });
      const animate = executor.executeItem(task.config, task.graphic);
      task.animate = animate, animate.forEach(animate => {
        this.totalDuration = Math.max(this.totalDuration, animate.getStartTime() + animate.getDuration());
      });
    }), this));
  }
  deleteSelfAttr(key) {
    this.tasks.forEach(task => {
      task.animate && task.animate.forEach(animate => animate.preventAttr(key));
    });
  }
  stop(type) {
    return this.tasks.forEach(task => {
      task.animate && task.animate.forEach(animate => animate.stop(type));
    }), this.started && this.completed !== this.tasks.length && (this.onEndCallbacks.forEach(callback => callback()), this.completed = this.tasks.length), this;
  }
  getDuration() {
    return this.totalDuration;
  }
}
function createComponentAnimator(component) {
  return new ComponentAnimator(component);
}

class IncreaseCount extends ACustomAnimate {
  constructor(from, to, duration, easing, params) {
    super(from, to, duration, easing, params), this.formatTemplate = null, this.decimalLength = null == params ? void 0 : params.decimalLength, (null == params ? void 0 : params.formatTemplate) && params.formatTemplate.includes("{{var}}") && (this.formatTemplate = params.formatTemplate);
  }
  onFirstRun() {
    var _a, _b, _c;
    const fromProps = this.getLastProps(),
      toProps = this.getEndProps(),
      fromText = null !== (_a = fromProps.text) && void 0 !== _a ? _a : 0,
      toText = null !== (_b = toProps.text) && void 0 !== _b ? _b : 0;
    this.valid = !0;
    let fromNum = 0,
      toNum = 0,
      fromFormat = "",
      toFormat = "",
      maxDecimalLength = 0;
    if ("number" == typeof fromText) {
      fromNum = fromText;
      const decimalPart = fromText.toString().split(".")[1] || "";
      maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length);
    } else {
      if ("string" != typeof fromText) return void (this.valid = !1);
      if (fromText.endsWith("%")) {
        fromFormat = "%";
        const cleanNumStr = fromText.substring(0, fromText.length - 1).replace(/,/g, "");
        if (fromNum = parseFloat(cleanNumStr) / 100, isNaN(fromNum)) return void (this.valid = !1);
        const decimalPart = cleanNumStr.split(".")[1] || "";
        maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length + 2);
      } else {
        const cleanNumStr = fromText.replace(/,/g, "");
        if (fromNum = parseFloat(cleanNumStr), isNaN(fromNum)) return void (this.valid = !1);
        fromText.includes(",") && (fromFormat = ",");
        const decimalPart = cleanNumStr.split(".")[1] || "";
        maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length);
      }
    }
    if ("number" == typeof toText) {
      toNum = toText;
      const decimalPart = toText.toString().split(".")[1] || "";
      maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length);
    } else {
      if ("string" != typeof toText) return void (this.valid = !1);
      if (toText.endsWith("%")) {
        toFormat = "%";
        const cleanNumStr = toText.substring(0, toText.length - 1).replace(/,/g, "");
        if (toNum = parseFloat(cleanNumStr) / 100, isNaN(toNum)) return void (this.valid = !1);
        const decimalPart = cleanNumStr.split(".")[1] || "";
        maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length + 2);
      } else {
        const cleanNumStr = toText.replace(/,/g, "");
        if (toNum = parseFloat(cleanNumStr), isNaN(toNum)) return void (this.valid = !1);
        toText.includes(",") && (toFormat = ",");
        const decimalPart = cleanNumStr.split(".")[1] || "";
        maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length);
      }
    }
    if (null === (_c = this.params) || void 0 === _c ? void 0 : _c.format) {
      switch (this.params.format) {
        case "percent":
          this.format = "%";
          break;
        case "thousandth":
          this.format = ",";
          break;
        case "none":
          this.format = "";
          break;
        default:
          this.format = toFormat || fromFormat;
      }
      "%" === this.format && "%" !== toFormat && "%" !== fromFormat && void 0 === this.decimalLength && (this.decimalLength = 2), "%" === this.format || "%" !== toFormat && "%" !== fromFormat || (fromNum *= 100, toNum *= 100);
    } else this.format = toFormat || fromFormat;
    this.fromNumber = fromNum, this.toNumber = toNum, void 0 === this.decimalLength && (this.decimalLength = maxDecimalLength);
  }
  onEnd(cb) {
    super.onEnd(cb), cb || this.props && this.target.setAttributes(this.props);
  }
  onUpdate(end, ratio, out) {
    if (!this.valid) return;
    const currentNumber = this.fromNumber + (this.toNumber - this.fromNumber) * ratio;
    let formattedText = "";
    const format = this.format,
      numberWithDecimals = ("%" === format ? 100 * currentNumber : currentNumber).toFixed(this.decimalLength);
    let formattedWithBasicFormat,
      formattedNumber = numberWithDecimals;
    if (parseFloat(numberWithDecimals) === Math.floor(parseFloat(numberWithDecimals)) && (formattedNumber = Math.floor(parseFloat(numberWithDecimals))), "%" === format) formattedWithBasicFormat = `${formattedNumber}%`;else if ("," === format) {
      const parts = formattedNumber.toString().split(".");
      parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","), formattedWithBasicFormat = parts.join(".");
    } else formattedWithBasicFormat = formattedNumber;
    formattedText = this.formatTemplate ? this.formatTemplate.replace("{{var}}", formattedWithBasicFormat.toString()) : formattedWithBasicFormat, this.target.setAttribute("text", formattedText);
  }
}

class AxisEnter extends AComponentAnimate {
    onBind() {
        var _a;
        const animator = createComponentAnimator(this.target);
        this._animator = animator;
        const duration = this.duration;
        const easing = this.easing;
        const { config, lastScale, getTickCoord } = this.params;
        let ratio = 1;
        const currData = this.target.data;
        if (lastScale && getTickCoord && currData) {
            ratio = 0.7;
            const oldValue = lastScale.scale(currData.rawValue);
            const point = getTickCoord(oldValue);
            const newX = this.target.attribute.x;
            const newY = this.target.attribute.y;
            this.target.setAttributes({ x: point.x, y: point.y });
            animator.animate(this.target, {
                type: 'to',
                to: { x: newX, y: newY },
                duration,
                easing
            });
        }
        animator.animate(this.target, {
            type: (_a = config.type) !== null && _a !== void 0 ? _a : 'fadeIn',
            to: config.to,
            duration: duration * ratio,
            easing
        });
        this.completeBind(animator);
    }
}
class AxisUpdate extends AComponentAnimate {
    onBind() {
        const animator = createComponentAnimator(this.target);
        this._animator = animator;
        const duration = this.duration;
        const easing = this.easing;
        const { config, diffAttrs } = this.params;
        animator.animate(this.target, {
            type: 'to',
            to: Object.assign({}, diffAttrs),
            duration,
            easing,
            customParameters: {
                diffAttrs: Object.assign({}, diffAttrs)
            }
        });
        this.completeBind(animator);
    }
    deleteSelfAttr(key) {
        super.deleteSelfAttr(key);
        this._animator.deleteSelfAttr(key);
    }
    tryPreventConflict() {
        return;
    }
}
function registerAxisAnimate() {
    AnimateExecutor.registerBuiltInAnimate('axisEnter', AxisEnter);
    AnimateExecutor.registerBuiltInAnimate('axisUpdate', AxisUpdate);
}

function loadBasicAxis() {
    registerGroup();
    registerLine();
    registerRichtext();
    registerText();
    registerAxisAnimate();
}
function loadLineAxisComponent() {
    loadBasicAxis();
    registerRect();
}
function loadCircleAxisComponent() {
    loadBasicAxis();
    registerCircle();
}
function loadLineAxisGridComponent() {
    registerGroup();
    registerPath();
}
function loadCircleAxisGridComponent() {
    registerGroup();
    registerPath();
}

loadLineAxisComponent();
class LineAxis extends AxisBase {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, LineAxis.defaultAttributes, attributes), options);
    }
    _renderInner(container) {
        var _a;
        this._breaks = null;
        if (this.attribute.breaks && this.attribute.breaks.length) {
            const transformedBreaks = [];
            for (let index = 0; index < this.attribute.breaks.length; index++) {
                const aBreak = this.attribute.breaks[index];
                const { range, breakSymbol, rawRange } = aBreak;
                transformedBreaks.push({
                    startPoint: this.getTickCoord(range[0]),
                    endPoint: this.getTickCoord(range[1]),
                    range,
                    breakSymbol,
                    rawRange
                });
            }
            this._breaks = transformedBreaks;
        }
        super._renderInner(container);
        if (this._breaks && this._breaks.length) {
            this._breaks.forEach((b, index) => {
                const { startPoint, endPoint, breakSymbol, rawRange } = b;
                if ((breakSymbol === null || breakSymbol === void 0 ? void 0 : breakSymbol.visible) !== false) {
                    const axisBreakGroup = graphicCreator.group({
                        zIndex: TopZIndex
                    });
                    axisBreakGroup.name = AXIS_ELEMENT_NAME.axisBreak;
                    axisBreakGroup.id = this._getNodeId(`${AXIS_ELEMENT_NAME.axisBreak}-${index}`);
                    axisBreakGroup.data = rawRange;
                    const symbolStyle = getAxisBreakSymbolAttrs(breakSymbol);
                    const shape1 = graphicCreator.symbol(Object.assign({ x: startPoint.x, y: startPoint.y }, symbolStyle));
                    shape1.name = AXIS_ELEMENT_NAME.axisBreakSymbol;
                    const shape2 = graphicCreator.symbol(Object.assign({ x: endPoint.x, y: endPoint.y }, symbolStyle));
                    shape2.name = AXIS_ELEMENT_NAME.axisBreakSymbol;
                    axisBreakGroup.add(shape1);
                    axisBreakGroup.add(shape2);
                    container.add(axisBreakGroup);
                }
            });
        }
        const { panel } = this.attribute;
        if (panel && panel.visible) {
            const axisContainer = this.axisContainer;
            const axisContainerBounds = axisContainer.AABBBounds;
            const bgRect = graphicCreator.rect(Object.assign({ x: axisContainerBounds.x1, y: axisContainerBounds.y1, width: axisContainerBounds.width(), height: axisContainerBounds.height() }, panel.style));
            bgRect.name = AXIS_ELEMENT_NAME.background;
            bgRect.id = this._getNodeId('background');
            bgRect.states = merge({}, DEFAULT_STATES$1, (_a = panel.state) !== null && _a !== void 0 ? _a : {});
            axisContainer.insertBefore(bgRect, axisContainer.firstChild);
        }
    }
    renderLine(container) {
        const { start, end, line } = this.attribute;
        const _a = line, { startSymbol, endSymbol, style, state } = _a, restLineAttrs = __rest(_a, ["startSymbol", "endSymbol", "style", "state"]);
        const lineAttrs = Object.assign({ startSymbol,
            endSymbol, lineStyle: style }, restLineAttrs);
        if (this._breaks && this._breaks.length) {
            const linePoints = [];
            let lastStartPoint = start;
            this._breaks.forEach(b => {
                const { startPoint, endPoint } = b;
                linePoints.push([lastStartPoint, startPoint]);
                lastStartPoint = endPoint;
            });
            linePoints.push([lastStartPoint, end]);
            lineAttrs.points = linePoints;
            lineAttrs.multiSegment = true;
        }
        else {
            lineAttrs.points = [start, end];
        }
        if (!isEmpty(state)) {
            lineAttrs.state = {
                line: merge({}, DEFAULT_STATES$1, state),
                symbol: merge({}, DEFAULT_STATES$1, state)
            };
        }
        const axisLineGroup = new Segment(lineAttrs);
        axisLineGroup.name = AXIS_ELEMENT_NAME.line;
        axisLineGroup.id = this._getNodeId('line');
        container.add(axisLineGroup);
    }
    getTextAlign(vector) {
        let align = 'center';
        if (isNumberClose(vector[0], 0)) {
            if (isNumberClose(vector[1], 0)) {
                if (Object.is(vector[1], -0)) {
                    align = 'start';
                }
                else if (Object.is(vector[0], -0)) {
                    align = 'end';
                }
            }
            else {
                align = 'center';
            }
        }
        else if (vector[0] > 0) {
            align = 'start';
        }
        else if (vector[0] < 0) {
            align = 'end';
        }
        return align;
    }
    getTitleAttribute() {
        var _a, _b, _c;
        const _d = this.attribute.title, { position = 'middle', space = 4, textStyle = {}, autoRotate = true, shape, background, state = {}, maxWidth } = _d, restAttrs = __rest(_d, ["position", "space", "textStyle", "autoRotate", "shape", "background", "state", "maxWidth"]);
        let percent = 0.5;
        if (position === 'start') {
            percent = 0;
        }
        else if (position === 'end') {
            percent = 1;
        }
        const { verticalFactor = 1 } = this.attribute;
        const factor = -1 * verticalFactor;
        const point = this.getTickCoord(percent);
        const axisVector = this.getRelativeVector();
        let labelLength = 0;
        if (((_a = this.attribute.label) === null || _a === void 0 ? void 0 : _a.visible) && this.attribute.label.inside === false) {
            const space = +get(this.attribute, 'label.space', 4);
            labelLength += space;
            const layerCount = Object.keys(this.axisLabelLayerSize).length;
            if (axisVector[1] === 0) {
                const labelBoundsHeight = this.axisLabelsContainer ? this.axisLabelsContainer.AABBBounds.height() : 0;
                if (isFinite(labelBoundsHeight)) {
                    labelLength += labelBoundsHeight + (layerCount - 1) * space;
                }
                else {
                    labelLength = 0;
                }
            }
            else {
                if (axisVector[0] === 0) {
                    if (this.axisLabelsContainer &&
                        this.axisLabelsContainer.AABBBounds &&
                        !this.axisLabelsContainer.AABBBounds.empty()) {
                        const baseX = this.axisLabelLayerSize[0].labelPos;
                        const bounds = this.axisLabelsContainer.AABBBounds;
                        labelLength +=
                            (factor === 1
                                ? bounds.x2 > baseX
                                    ? Math.min(bounds.x2 - baseX, bounds.width())
                                    : 0
                                : bounds.x1 < baseX
                                    ? Math.min(baseX - bounds.x1, bounds.width())
                                    : 0) +
                                (layerCount - 1) * space;
                    }
                    else {
                        labelLength = 0;
                    }
                }
                else {
                    Object.keys(this.axisLabelLayerSize).forEach((layer, index) => {
                        labelLength += this.axisLabelLayerSize[layer].width + (index > 0 ? space : 0);
                    });
                }
            }
        }
        let tickLength = 0;
        if (((_b = this.attribute.tick) === null || _b === void 0 ? void 0 : _b.visible) && this.attribute.tick.inside === false) {
            tickLength = this.attribute.tick.length || 4;
        }
        if (((_c = this.attribute.subTick) === null || _c === void 0 ? void 0 : _c.visible) && this.attribute.subTick.inside === false) {
            tickLength = Math.max(tickLength, this.attribute.subTick.length || 2);
        }
        const offset = tickLength + labelLength + space;
        const titlePoint = this.getVerticalCoord(point, offset, false);
        const vector = this.getVerticalVector(offset, false, { x: 0, y: 0 });
        let { angle } = restAttrs;
        let textAlign;
        if (position === 'start') {
            textAlign = 'start';
        }
        else if (position === 'end') {
            textAlign = 'end';
        }
        else {
            textAlign = 'center';
        }
        let textBaseline;
        if (isNil(angle) && autoRotate) {
            const v1 = [1, 0];
            const radian = angleTo(axisVector, v1, true);
            angle = radian;
            const { verticalFactor = 1 } = this.attribute;
            const factor = -1 * verticalFactor;
            if (factor === 1) {
                textBaseline = 'bottom';
            }
            else {
                textBaseline = 'top';
            }
        }
        else {
            textAlign = this.getTextAlign(vector);
            textBaseline = this.getTextBaseline(vector, false);
        }
        let maxTagWidth = maxWidth;
        if (isNil(maxTagWidth)) {
            const { verticalLimitSize, verticalMinSize, orient } = this.attribute;
            const limitSize = Math.min(verticalLimitSize || Infinity, verticalMinSize || Infinity);
            if (isValidNumber(limitSize)) {
                const isX = orient === 'bottom' || orient === 'top';
                if (isX) {
                    if (angle !== Math.PI / 2) {
                        const cosValue = Math.abs(Math.cos(angle !== null && angle !== void 0 ? angle : 0));
                        maxTagWidth = cosValue < 1e-6 ? Infinity : this.attribute.end.x / cosValue;
                    }
                    else {
                        maxTagWidth = limitSize - offset;
                    }
                }
                else {
                    if (angle && angle !== 0) {
                        const sinValue = Math.abs(Math.sin(angle));
                        maxTagWidth = sinValue < 1e-6 ? Infinity : this.attribute.end.y / sinValue;
                    }
                    else {
                        maxTagWidth = limitSize - offset;
                    }
                }
            }
        }
        const attrs = Object.assign(Object.assign(Object.assign({}, titlePoint), restAttrs), { maxWidth: maxTagWidth, textStyle: Object.assign({ textAlign,
                textBaseline }, textStyle), state: {
                text: merge({}, DEFAULT_STATES$1, state.text),
                shape: merge({}, DEFAULT_STATES$1, state.shape),
                panel: merge({}, DEFAULT_STATES$1, state.background)
            } });
        attrs.angle = angle;
        if (shape && shape.visible) {
            attrs.shape = Object.assign({ visible: true }, shape.style);
            if (shape.space) {
                attrs.space = shape.space;
            }
        }
        if (background && background.visible) {
            attrs.panel = Object.assign({ visible: true }, background.style);
        }
        return attrs;
    }
    getTextBaseline(vector, inside) {
        let base = 'middle';
        const { verticalFactor = 1 } = this.attribute;
        const factor = (inside ? 1 : -1) * verticalFactor;
        if (isNumberClose(vector[1], 0)) {
            if (isNumberClose(vector[0], 0) && !Object.is(vector[0], -0) && !Object.is(vector[1], -0)) {
                base = factor === 1 ? 'bottom' : 'top';
            }
            else {
                base = 'middle';
            }
        }
        else if (vector[1] > 0) {
            base = 'top';
        }
        else if (vector[1] < 0) {
            base = 'bottom';
        }
        return base;
    }
    getLabelAlign(vector, inside, angle) {
        const orient = this.attribute.orient;
        const isCartesian = ['top', 'bottom', 'right', 'left'].includes(orient);
        if (isCartesian || (vector[0] === 0 && vector[1] === 0)) {
            if (orient === 'top' || orient === 'bottom') {
                return getXAxisLabelAlign(inside ? (orient === 'bottom' ? 'top' : 'bottom') : orient, angle);
            }
            if (orient === 'left' || orient === 'right') {
                return getYAxisLabelAlign(inside ? (orient === 'left' ? 'right' : 'left') : orient, angle);
            }
        }
        return {
            textAlign: this.getTextAlign(vector),
            textBaseline: this.getTextBaseline(vector, inside)
        };
    }
    beforeLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
        var _a, _b, _c, _d;
        const { flush = false } = this.attribute.label || {};
        if (flush && labelShapes.length) {
            const { orient, start: axisStart, end: axisEnd } = this.attribute;
            const isX = orient === 'bottom' || orient === 'top';
            const first = labelShapes[0];
            const last$1 = last(labelShapes);
            const isInverse = isX ? first.attribute.x > last$1.attribute.x : first.attribute.y < last$1.attribute.y;
            if (isX) {
                const leftMostLabel = isInverse ? last$1 : first;
                const rightMostLabel = isInverse ? first : last$1;
                const left = axisStart.x;
                const right = axisEnd.x;
                const leftBound = leftMostLabel.AABBBounds.x1;
                const rightBound = rightMostLabel.AABBBounds.x2;
                if (leftBound < left) {
                    const angle = leftMostLabel.attribute.angle;
                    if (angle) {
                        leftMostLabel.setAttributes({ dx: ((_a = leftMostLabel.attribute.dx) !== null && _a !== void 0 ? _a : 0) + left - leftBound });
                    }
                    else {
                        leftMostLabel.setAttributes({
                            x: left,
                            textAlign: 'left'
                        });
                    }
                }
                if (rightBound > right) {
                    const angle = rightMostLabel.attribute.angle;
                    if (angle) {
                        rightMostLabel.setAttributes({ dx: ((_b = rightMostLabel.attribute.dx) !== null && _b !== void 0 ? _b : 0) + right - rightBound });
                    }
                    else {
                        rightMostLabel.setAttributes({
                            x: right,
                            textAlign: 'right'
                        });
                    }
                }
            }
            else {
                const bottomMostLabel = isInverse ? last$1 : first;
                const topMostLabel = isInverse ? first : last$1;
                const bottomBound = bottomMostLabel.AABBBounds.y2;
                const topBound = topMostLabel.AABBBounds.y1;
                const top = axisStart.y;
                const bottom = axisEnd.y;
                if (topBound < top) {
                    const angle = topMostLabel.attribute.angle;
                    if (angle) {
                        topMostLabel.setAttributes({
                            dy: ((_c = topMostLabel.attribute.dy) !== null && _c !== void 0 ? _c : 0) + top - topBound
                        });
                    }
                    else {
                        topMostLabel.setAttributes({
                            y: top,
                            textBaseline: 'top'
                        });
                    }
                }
                if (bottomBound > bottom) {
                    const angle = bottomMostLabel.attribute.angle;
                    if (angle) {
                        bottomMostLabel.setAttributes({
                            dy: ((_d = bottomMostLabel.attribute.dy) !== null && _d !== void 0 ? _d : 0) + bottom - bottomBound
                        });
                    }
                    else {
                        bottomMostLabel.setAttributes({
                            y: bottom,
                            textBaseline: 'bottom'
                        });
                    }
                }
            }
        }
        return;
    }
    handleLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
        if (isEmpty(labelShapes)) {
            return;
        }
        const { verticalLimitSize, label, orient } = this.attribute;
        const limitLength = this._getAxisLabelLimitLength(verticalLimitSize, layerCount);
        const { layoutFunc, autoRotate: autoRotate$1, autoRotateAngle, autoLimit: autoLimit$1, limitEllipsis, autoHide: autoHide$1, autoHideMethod, autoHideSeparation, lastVisible, firstVisible, autoWrap: autoWrap$1, overflowLimitLength } = label;
        if (isFunction(layoutFunc)) {
            layoutFunc(labelShapes, labelData, layer, this);
        }
        else {
            if (autoRotate$1) {
                autoRotate(labelShapes, {
                    labelRotateAngle: autoRotateAngle,
                    orient
                });
            }
            else if (autoWrap$1) {
                const isVertical = orient === 'left' || orient === 'right';
                const axisLength = isVertical
                    ? Math.abs(this.attribute.start.y - this.attribute.end.y)
                    : Math.abs(this.attribute.start.x - this.attribute.end.x);
                autoWrap(labelShapes, { orient, limitLength, axisLength, ellipsis: limitEllipsis });
            }
            if (!autoWrap$1 && autoLimit$1 && isValidNumber(limitLength) && limitLength > 0) {
                const isVertical = orient === 'left' || orient === 'right';
                const axisLength = isVertical
                    ? Math.abs(this.attribute.start.y - this.attribute.end.y)
                    : Math.abs(this.attribute.start.x - this.attribute.end.x);
                const verticalLimitLength = isVertical
                    ? axisLength / labelShapes.length
                    : !autoHide$1 && !autoRotate$1
                        ? axisLength / labelShapes.length
                        : Infinity;
                autoLimit(labelShapes, {
                    limitLength,
                    verticalLimitLength,
                    ellipsis: limitEllipsis,
                    orient,
                    axisLength,
                    overflowLimitLength
                });
            }
            if (autoHide$1) {
                autoHide(labelShapes, {
                    orient,
                    method: autoHideMethod,
                    separation: autoHideSeparation,
                    lastVisible,
                    firstVisible
                });
            }
        }
    }
    afterLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
        const { verticalLimitSize, orient } = this.attribute;
        const isHorizontal = orient === 'bottom' || orient === 'top';
        const axisLabelContainerBounds = labelContainer.AABBBounds;
        let axisLabelContainerSize = isHorizontal ? axisLabelContainerBounds.height() : axisLabelContainerBounds.width();
        const { verticalMinSize } = this.attribute;
        if (isValidNumber(verticalMinSize) && (!isValidNumber(verticalLimitSize) || verticalMinSize <= verticalLimitSize)) {
            const minSize = this._getAxisLabelLimitLength(verticalMinSize, layerCount);
            axisLabelContainerSize = Math.max(axisLabelContainerSize, minSize);
            let x;
            let y;
            if (orient === 'left') {
                x = axisLabelContainerBounds.x2 - axisLabelContainerSize;
                y = axisLabelContainerBounds.y1;
            }
            else if (orient === 'right') {
                x = axisLabelContainerBounds.x1;
                y = axisLabelContainerBounds.y1;
            }
            else if (orient === 'top') {
                x = axisLabelContainerBounds.x1;
                y = axisLabelContainerBounds.y2 - axisLabelContainerSize;
            }
            else if (orient === 'bottom') {
                x = axisLabelContainerBounds.x1;
                y = axisLabelContainerBounds.y1;
            }
            const bgRect = graphicCreator.rect({
                x,
                y,
                width: isHorizontal ? axisLabelContainerBounds.width() : axisLabelContainerSize,
                height: isHorizontal ? axisLabelContainerSize : axisLabelContainerBounds.height(),
                pickable: false
            });
            bgRect.name = AXIS_ELEMENT_NAME.axisLabelBackground;
            bgRect.id = this._getNodeId('axis-label-background');
            labelContainer.insertBefore(bgRect, labelContainer.firstChild);
        }
        if (isValid(this.attribute.label.containerAlign)) {
            let start;
            if (orient === 'left') {
                start = axisLabelContainerBounds.x2 - axisLabelContainerSize;
            }
            else if (orient === 'right') {
                start = axisLabelContainerBounds.x1;
            }
            else if (orient === 'top') {
                start = axisLabelContainerBounds.y2 - axisLabelContainerSize;
            }
            else if (orient === 'bottom') {
                start = axisLabelContainerBounds.y1;
            }
            alignAxisLabels(labelShapes, start, axisLabelContainerSize, orient, this.attribute.label.containerAlign);
        }
    }
    _getAxisLabelLimitLength(limitSize, layerCount) {
        var _a, _b, _c, _d, _e;
        const { label, title, line, tick } = this.attribute;
        const labelSpace = (_a = label.space) !== null && _a !== void 0 ? _a : 4;
        let limitLength = limitSize;
        let titleHeight = 0;
        let titleSpacing = 0;
        const axisLineWidth = line && line.visible ? (_b = line.style.lineWidth) !== null && _b !== void 0 ? _b : 1 : 0;
        const tickLength = tick && tick.visible ? (_c = tick.length) !== null && _c !== void 0 ? _c : 4 : 0;
        if (title && title.visible && typeof title.text === 'string') {
            titleHeight = measureTextSize(title.text, title.textStyle, (_e = (_d = this.stage) === null || _d === void 0 ? void 0 : _d.getTheme()) === null || _e === void 0 ? void 0 : _e.text).height;
            const padding = normalizePadding(title.padding);
            titleSpacing = title.space + padding[0] + padding[2];
        }
        if (limitLength) {
            limitLength = (limitLength - labelSpace - titleSpacing - titleHeight - axisLineWidth - tickLength) / layerCount;
        }
        return limitLength;
    }
    release() {
        super.release();
        this._breaks = null;
    }
}
LineAxis.defaultAttributes = DEFAULT_AXIS_THEME;
mixin(LineAxis, LineAxisMixin);

class CircleAxisMixin {
    isInValidValue(value) {
        const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute;
        if (Math.abs(endAngle - startAngle) % (Math.PI * 2) === 0) {
            return value > 1;
        }
        return value < 0 || value > 1;
    }
    getTickCoord(tickValue) {
        const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE, center, radius, inside = false, innerRadius = 0 } = this.attribute;
        const angle = startAngle + (endAngle - startAngle) * tickValue;
        return polarToCartesian(center, inside && innerRadius > 0 ? innerRadius : radius, angle);
    }
    getVerticalVector(offset, inside = false, point) {
        return getCircleVerticalVector(offset, point, this.attribute.center, inside, this.attribute.inside);
    }
    getRelativeVector(point) {
        const { center } = this.attribute;
        return [point.y - center.y, -1 * (point.x - center.x)];
    }
}

function findSiblingLabels(labels, selfIndex) {
    const len = labels.length;
    const prevLabel = selfIndex >= 1 ? labels[selfIndex - 1] : labels[len - 1];
    const nextLabel = selfIndex < len - 1 ? labels[selfIndex + 1] : labels[0];
    return { prevLabel, nextLabel };
}
function adjustMaxLineWidth(label, maxLineWidth, ellipsis) {
    var _a;
    label.setAttributes({
        maxLineWidth,
        ellipsis: (_a = label.attribute.ellipsis) !== null && _a !== void 0 ? _a : ellipsis
    });
}
function adjustMaxHeight(labels, selfIndex, bounds) {
    const siblings = [];
    if (labels.length >= 3) {
        const { prevLabel, nextLabel } = findSiblingLabels(labels, selfIndex);
        siblings.push(prevLabel, nextLabel);
    }
    else if (labels.length === 2) {
        siblings.push(labels[selfIndex === 0 ? 1 : 0]);
    }
    const label = labels[selfIndex];
    let heightLimit = Math.min(Math.abs(label.attribute.y - bounds.y1), Math.abs(label.attribute.y - bounds.y2));
    siblings.forEach(sibling => {
        heightLimit = Math.min(heightLimit, Math.abs(sibling.attribute.y - label.attribute.y));
    });
    if (heightLimit > 0) {
        label.setAttributes({ whiteSpace: 'normal', heightLimit });
    }
}
function circleAutoLimit(labels, config) {
    const { ellipsis, inside, bounds, autoWrap, center } = config;
    if (!inside) {
        labels.forEach((label, index) => {
            const { x, y } = label.attribute;
            const b = label.AABBBounds;
            if (isNumberClose(x, center.x)) {
                if (y > bounds.y2 || y < bounds.y1) {
                    adjustMaxLineWidth(label, 0, ellipsis);
                    return;
                }
                const boxWidth = bounds.x2 - bounds.x1;
                if (labels.length >= 3) {
                    const { prevLabel, nextLabel } = findSiblingLabels(labels, index);
                    let leftX = prevLabel.attribute.x;
                    let rightX = nextLabel.attribute.x;
                    if (leftX > rightX) {
                        leftX = nextLabel.attribute.x;
                        rightX = prevLabel.attribute.x;
                    }
                    const maxWidth = leftX === rightX
                        ? boxWidth
                        : x >= leftX && x <= rightX
                            ? rightX - leftX
                            : Math.min(Math.abs(leftX - x), Math.abs(rightX - x));
                    if (label.AABBBounds.width() > maxWidth) {
                        adjustMaxLineWidth(label, maxWidth, ellipsis);
                    }
                }
                else if (label.AABBBounds.width() > boxWidth) {
                    adjustMaxLineWidth(label, boxWidth, ellipsis);
                }
            }
            else if (x > center.x && b.x2 > bounds.x2) {
                adjustMaxLineWidth(label, bounds.x2 - x, ellipsis);
                autoWrap && adjustMaxHeight(labels, index, bounds);
            }
            else if (x < center.x && b.x1 < bounds.x1) {
                adjustMaxLineWidth(label, x - bounds.x1, ellipsis);
                autoWrap && adjustMaxHeight(labels, index, bounds);
            }
        });
    }
}

loadCircleAxisComponent();
class CircleAxis extends AxisBase {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, CircleAxis.defaultAttributes, attributes));
    }
    renderLine(container) {
        const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE, radius, center, innerRadius = 0, line = {}, inside = false, sides } = this.attribute;
        let arcRadius = radius;
        let arcInnerRadius = innerRadius;
        if (inside && innerRadius > 0) {
            arcRadius = innerRadius;
            arcInnerRadius = 0;
        }
        let lineGraphic;
        if (isValidNumber(sides) && sides >= 3) {
            const gridPoints = getCirclePoints(center, sides, arcRadius, startAngle, endAngle);
            lineGraphic = graphicCreator.path(Object.assign(Object.assign({}, line.style), { path: getPolygonPath(gridPoints, true) }));
        }
        else {
            const arcAttrs = Object.assign(Object.assign(Object.assign({}, center), { startAngle,
                endAngle, radius: arcRadius, innerRadius: arcInnerRadius }), line.style);
            lineGraphic = graphicCreator.circle(arcAttrs);
        }
        lineGraphic.name = AXIS_ELEMENT_NAME.line;
        lineGraphic.id = this._getNodeId('line');
        if (!isEmpty(line.state)) {
            lineGraphic.states = merge({}, DEFAULT_STATES$1, line.state);
        }
        container.add(lineGraphic);
    }
    getTitleAttribute() {
        var _a, _b, _c;
        const { center, radius, innerRadius = 0 } = this.attribute;
        const _d = this.attribute.title, { space = 4, textStyle = {}, shape, background, state = {} } = _d, restAttrs = __rest(_d, ["space", "textStyle", "shape", "background", "state"]);
        let titlePoint = center;
        let labelHeight = 0;
        if (((_a = this.attribute.label) === null || _a === void 0 ? void 0 : _a.visible) && this.attribute.label.inside === false) {
            labelHeight = get(this.attribute.label, 'style.fontSize', 12) + get(this.attribute.label, 'space', 4);
        }
        let tickLength = 0;
        if (((_b = this.attribute.tick) === null || _b === void 0 ? void 0 : _b.visible) && this.attribute.tick.inside === false) {
            tickLength = this.attribute.tick.length || 4;
        }
        if (((_c = this.attribute.subTick) === null || _c === void 0 ? void 0 : _c.visible) && this.attribute.subTick.inside === false) {
            tickLength = Math.max(tickLength, this.attribute.subTick.length || 2);
        }
        const offset = radius + tickLength + labelHeight + space;
        let textBaseline = 'middle';
        let { position } = this.attribute.title;
        if (isNil(position)) {
            position = innerRadius === 0 ? 'end' : 'middle';
        }
        if (position === 'start') {
            textBaseline = 'bottom';
            titlePoint = {
                x: center.x,
                y: center.y - offset
            };
        }
        else if (position === 'end') {
            textBaseline = 'top';
            titlePoint = {
                x: center.x,
                y: center.y + offset
            };
        }
        const attrs = Object.assign(Object.assign(Object.assign({}, titlePoint), restAttrs), { textStyle: Object.assign({ textBaseline, textAlign: 'center' }, textStyle), state: {
                text: merge({}, DEFAULT_STATES$1, state.text),
                shape: merge({}, DEFAULT_STATES$1, state.shape),
                panel: merge({}, DEFAULT_STATES$1, state.background)
            } });
        const { angle } = restAttrs;
        attrs.angle = angle;
        if (shape && shape.visible) {
            attrs.shape = Object.assign({ visible: true }, shape.style);
            if (shape.space) {
                attrs.space = shape.space;
            }
        }
        if (background && background.visible) {
            attrs.panel = Object.assign({ visible: true }, background.style);
        }
        return attrs;
    }
    getSubTickLineItems() {
        var _a, _b;
        const { subTick } = this.attribute;
        const subTickLineItems = [];
        const { count: subCount = 4, inside = false, length = 2 } = subTick;
        const tickLineItems = this.tickLineItems;
        const tickLineCount = tickLineItems.length;
        if (tickLineCount >= 2) {
            const tickSegment = this.data[1].value - this.data[0].value;
            const isAlignWithLable = (_b = (_a = this.attribute) === null || _a === void 0 ? void 0 : _a.tick) === null || _b === void 0 ? void 0 : _b.alignWithLabel;
            for (let i = 0; i < tickLineCount; i++) {
                const pre = tickLineItems[i];
                const next = tickLineItems[i + 1];
                for (let j = 0; j < subCount; j++) {
                    const percent = (j + 1) / (subCount + 1);
                    const value = (1 - percent) * pre.value + percent * (next ? next.value : isAlignWithLable ? 1 : pre.value + tickSegment);
                    const point = this.getTickCoord(value);
                    const endPoint = this.getVerticalCoord(point, length, inside);
                    subTickLineItems.push({
                        start: point,
                        end: endPoint,
                        value
                    });
                }
            }
        }
        return subTickLineItems;
    }
    beforeLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
        return;
    }
    handleLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
        if (isEmpty(labelShapes)) {
            return;
        }
        const { inside, radius, center, size, label, orient } = this.attribute;
        const bounds = size
            ? {
                x1: 0,
                y1: 0,
                x2: size.width,
                y2: size.height
            }
            : {
                x1: center.x - radius,
                y1: center.y - radius,
                x2: center.x + radius,
                y2: center.y + radius
            };
        const { layoutFunc, autoLimit, limitEllipsis, autoHide: autoHide$1, autoHideMethod, autoHideSeparation, autoWrap } = label;
        if (isFunction(layoutFunc)) {
            layoutFunc(labelShapes, labelData, layer, this);
        }
        else {
            if (autoLimit || autoWrap) {
                circleAutoLimit(labelShapes, { inside, autoWrap, bounds, ellipsis: limitEllipsis, center });
            }
            if (autoHide$1) {
                autoHide(labelShapes, {
                    orient,
                    method: autoHideMethod,
                    separation: autoHideSeparation
                });
            }
        }
    }
    afterLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
        return;
    }
    getTextBaseline(vector) {
        if (Math.abs(vector[1] / vector[0]) < 0.3) {
            return 'middle';
        }
        else if (vector[1] < 0) {
            return 'bottom';
        }
        else if (vector[1] > 0) {
            return 'top';
        }
        return 'middle';
    }
    getLabelAlign(vector, inside, angle) {
        if (isNumberClose(vector[0], 0)) {
            return {
                textAlign: 'center',
                textBaseline: vector[1] > 0 ? 'top' : 'bottom'
            };
        }
        else if (vector[0] < 0) {
            return {
                textAlign: 'right',
                textBaseline: this.getTextBaseline(vector)
            };
        }
        else if (vector[0] > 0) {
            return {
                textAlign: 'left',
                textBaseline: this.getTextBaseline(vector)
            };
        }
        return {
            textAlign: 'center',
            textBaseline: 'middle'
        };
    }
    getLabelPosition(point, vector, text, style) {
        return point;
    }
}
CircleAxis.defaultAttributes = DEFAULT_AXIS_THEME;
mixin(CircleAxis, CircleAxisMixin);

class GroupTransition extends ACustomAnimate {
    constructor() {
        super(...arguments);
        this.mode = AnimateMode.NORMAL;
    }
    onBind() {
        const currentInnerView = this.target.getInnerView();
        const prevInnerView = this.target.getPrevInnerView();
        if (!prevInnerView) {
            return;
        }
        this._newElementAttrMap = {};
        traverseGroup(currentInnerView, (el) => {
            var _a, _b, _c, _d, _e, _f;
            if (el.type !== 'group' && el.id) {
                const oldEl = prevInnerView[el.id];
                if (oldEl) {
                    if (!isEqual(el.attribute, oldEl.attribute)) {
                        const newProps = cloneDeep(el.attribute);
                        this._newElementAttrMap[el.id] = {
                            state: 'update',
                            node: el,
                            attrs: Object.assign(Object.assign({}, newProps), { opacity: (_a = newProps.opacity) !== null && _a !== void 0 ? _a : 1, fillOpacity: (_b = newProps.fillOpacity) !== null && _b !== void 0 ? _b : 1, strokeOpacity: (_c = newProps.strokeOpacity) !== null && _c !== void 0 ? _c : 1 })
                        };
                        el.setAttributes(oldEl.attribute);
                    }
                }
                else {
                    const finalOpacityAttrs = {
                        opacity: (_d = el.attribute.opacity) !== null && _d !== void 0 ? _d : 1,
                        fillOpacity: (_e = el.attribute.fillOpacity) !== null && _e !== void 0 ? _e : 1,
                        strokeOpacity: (_f = el.attribute.strokeOpacity) !== null && _f !== void 0 ? _f : 1
                    };
                    this._newElementAttrMap[el.id] = {
                        state: 'enter',
                        node: el,
                        attrs: finalOpacityAttrs
                    };
                    el.setAttributes({
                        opacity: 0,
                        fillOpacity: 0,
                        strokeOpacity: 0
                    });
                }
            }
        });
    }
    onStart() {
        let duration = this.duration;
        let easing = this.easing;
        this._newElementAttrMap &&
            Object.keys(this._newElementAttrMap).forEach(id => {
                var _a;
                const { node, attrs, state } = this._newElementAttrMap[id];
                if (state === 'enter') {
                    const { enter = {} } = (_a = this.params) !== null && _a !== void 0 ? _a : {};
                    duration = isValidNumber(enter.duration) ? enter.duration : duration;
                    easing = enter.easing ? enter.easing : easing;
                }
                if (node.type === 'path') {
                    node
                        .animate({
                        interpolate(key, ratio, from, to, nextAttributes) {
                            if (key === 'path') {
                                nextAttributes.path = interpolateString(from, to)(ratio);
                                return true;
                            }
                            return false;
                        }
                    })
                        .to(attrs, duration, easing);
                }
                else {
                    node
                        .animate()
                        .to(attrs, duration, easing);
                }
            });
    }
    onUpdate(end, ratio, out) {
    }
}

const convertDomainToTickData = (domain) => {
    const ticks = domain.map((t, index) => {
        return {
            index,
            value: t
        };
    });
    return ticks;
};
const labelOverlap = (prevLabel, nextLabel, gap = 0) => {
    const prevBounds = new AABBBounds(prevLabel).expand(gap / 2);
    const nextBounds = new AABBBounds(nextLabel).expand(gap / 2);
    return prevBounds.intersects(nextBounds);
};
const MIN_TICK_GAP = 12;
const calculateFlushPos = (basePosition, size, rangePosition, otherEnd) => {
    return rangePosition < basePosition
        ? Math.max(basePosition - size / 2, rangePosition)
        : rangePosition > basePosition
            ? Math.min(basePosition - size / 2, rangePosition - size)
            : rangePosition < otherEnd
                ? rangePosition
                : rangePosition - size;
};
const getCartesianLabelBounds = (scale, domain, op) => {
    var _a, _b, _c;
    const { labelStyle, axisOrientType, labelFlush, labelFormatter, startAngle = 0 } = op;
    let labelAngle = (_a = labelStyle.angle) !== null && _a !== void 0 ? _a : 0;
    if (labelStyle.direction === 'vertical') {
        labelAngle += degreeToRadian(90);
    }
    const isHorizontal = ['bottom', 'top'].includes(axisOrientType);
    const isVertical = ['left', 'right'].includes(axisOrientType);
    let scaleX = 1;
    let scaleY = 0;
    if (isHorizontal) ;
    else if (isVertical) {
        scaleX = 0;
        scaleY = 1;
    }
    else if (startAngle) {
        scaleX = Math.cos(startAngle);
        scaleY = -Math.sin(startAngle);
    }
    const textMeasure = initTextMeasure(labelStyle);
    const range = scale.range();
    let labelBoundsList = [];
    for (let i = 0; i < domain.length; i++) {
        const v = domain[i];
        const str = labelFormatter ? labelFormatter(v) : `${v}`;
        if (isPlainObject(str)) {
            labelBoundsList = undefined;
            break;
        }
        const { width, height } = textMeasure.quickMeasure(str);
        const textWidth = Math.max(width, MIN_TICK_GAP);
        const textHeight = Math.max(height, MIN_TICK_GAP);
        const pos = scale.scale(v);
        const baseTextX = scaleX * pos;
        const baseTextY = scaleY * pos;
        let textX = baseTextX;
        let textY = baseTextY;
        let align;
        if (labelFlush && isHorizontal && i === 0) {
            textX = calculateFlushPos(baseTextX, textWidth, range[0], range[range.length - 1]);
        }
        else if (labelFlush && isHorizontal && i === domain.length - 1) {
            textX = calculateFlushPos(baseTextX, textWidth, range[range.length - 1], range[0]);
        }
        else {
            align = (_b = labelStyle.textAlign) !== null && _b !== void 0 ? _b : 'center';
        }
        if (align === 'right') {
            textX -= textWidth;
        }
        else if (align === 'center') {
            textX -= textWidth / 2;
        }
        let baseline;
        if (labelFlush && isVertical && i === 0) {
            textY = calculateFlushPos(baseTextY, textHeight, range[0], range[range.length - 1]);
        }
        else if (labelFlush && isVertical && i === domain.length - 1) {
            textY = calculateFlushPos(baseTextY, textHeight, range[range.length - 1], range[0]);
        }
        else {
            baseline = (_c = labelStyle.textBaseline) !== null && _c !== void 0 ? _c : 'middle';
        }
        if (baseline === 'bottom') {
            textY -= textHeight;
        }
        else if (baseline === 'middle') {
            textY -= textHeight / 2;
        }
        const bounds = new AABBBounds().set(textX, textY, textX + textWidth, textY + textHeight);
        if (labelAngle) {
            bounds.rotate(labelAngle, baseTextX, baseTextY);
        }
        labelBoundsList.push(bounds);
    }
    return labelBoundsList;
};
const isAxisHorizontal = (axisOrientType) => {
    return ['bottom', 'top', 'z'].includes(axisOrientType);
};

const filterTicksByBreak = (ticks, breakDomains) => {
    return breakDomains && breakDomains.length
        ? ticks.filter(tick => {
            return breakDomains.every(breakDomain => {
                return tick < breakDomain[0] || tick > breakDomain[1];
            });
        })
        : ticks;
};
function getScaleTicks(op, scale, count, getTicks) {
    let scaleTicks;
    const { breakData } = op;
    if (breakData && breakData()) {
        const { breakDomains } = breakData();
        const domain = scale.domain();
        scaleTicks = [];
        for (let i = 0; i < domain.length - 1; i++) {
            const subDomain = [domain[i], domain[i + 1]];
            const ticks = getTicks(count, subDomain);
            ticks.forEach(tick => {
                if (!breakDomains.some(breakDomain => tick >= breakDomain[0] && tick <= breakDomain[1])) {
                    scaleTicks.push(tick);
                }
            });
        }
        scale.domain(domain);
    }
    else {
        scaleTicks = getTicks(count);
    }
    return scaleTicks;
}
function forceItemVisible(sourceItem, items, check, comparator, inverse = false) {
    if (check && !items.includes(sourceItem)) {
        let remainLength = items.length;
        if (remainLength > 1) {
            if (inverse) {
                items.push(sourceItem);
            }
            else {
                items.unshift(sourceItem);
            }
            for (let i = 0; i < remainLength; i++) {
                const index = inverse ? remainLength - 1 - i : i;
                if (comparator(items[index])) {
                    items.splice(index, 1);
                    i--;
                    remainLength--;
                }
                else {
                    break;
                }
            }
        }
    }
}
const DEFAULT_CONTINUOUS_TICK_COUNT = 5;
const continuousTicks = (scale, op) => {
    var _a, _b, _c, _d;
    if (!isContinuous(scale.type)) {
        return convertDomainToTickData(scale.domain());
    }
    const range = scale.range();
    const rangeSize = Math.abs(range[range.length - 1] - range[0]);
    if (rangeSize < 2) {
        return convertDomainToTickData([scale.domain()[0]]);
    }
    const { tickCount, forceTickCount, tickStep, noDecimals = false, labelStyle, breakData } = op;
    let scaleTicks;
    if (isValid(tickStep)) {
        scaleTicks = filterTicksByBreak(scale.stepTicks(tickStep), breakData && breakData() ? breakData().breakDomains : null);
    }
    else if (isValid(forceTickCount)) {
        scaleTicks = getScaleTicks(op, scale, forceTickCount, (count, subDomain) => {
            if (subDomain && subDomain.length) {
                return scale.domain(subDomain, true).forceTicks(count);
            }
            return scale.forceTicks(count);
        });
    }
    else if (op.tickMode === 'd3') {
        const count = (_a = (isFunction(tickCount) ? tickCount({ axisLength: rangeSize, labelStyle }) : tickCount)) !== null && _a !== void 0 ? _a : DEFAULT_CONTINUOUS_TICK_COUNT;
        scaleTicks = getScaleTicks(op, scale, count, (count, subDomain) => {
            if (subDomain && subDomain.length) {
                return scale.domain(subDomain, true).d3Ticks(count, { noDecimals });
            }
            return scale.d3Ticks(count, { noDecimals });
        });
    }
    else {
        const count = (_b = (isFunction(tickCount) ? tickCount({ axisLength: rangeSize, labelStyle }) : tickCount)) !== null && _b !== void 0 ? _b : DEFAULT_CONTINUOUS_TICK_COUNT;
        const customTicks = isFunction(op.tickMode) ? op.tickMode : undefined;
        scaleTicks = getScaleTicks(op, scale, count, (count, subDomain) => {
            if (subDomain && subDomain.length) {
                return scale.domain(subDomain, true).ticks(count, { noDecimals, customTicks });
            }
            return scale.ticks(count, { noDecimals, customTicks });
        });
    }
    const domain = scale.domain();
    if (op.labelFirstVisible && domain[0] !== scaleTicks[0] && !scaleTicks.includes(domain[0])) {
        scaleTicks.unshift(domain[0]);
    }
    if (op.labelLastVisible &&
        domain[domain.length - 1] !== scaleTicks[scaleTicks.length - 1] &&
        !scaleTicks.includes(domain[domain.length - 1])) {
        scaleTicks.push(domain[domain.length - 1]);
    }
    if (op.sampling && scaleTicks.length > 1) {
        if (op.coordinateType === 'cartesian' || (op.coordinateType === 'polar' && op.axisOrientType === 'radius')) {
            const { labelGap = 4, labelFlush } = op;
            const MIN_FONT_SIZE = 6;
            let items;
            if (scaleTicks.length * MIN_FONT_SIZE > rangeSize) {
                const samplingScaleTicks = [];
                const step = Math.floor((scaleTicks.length * MIN_FONT_SIZE) / rangeSize);
                scaleTicks.forEach((tick, index) => {
                    if (index % step === 0 || index === scaleTicks.length - 1) {
                        samplingScaleTicks.push(tick);
                    }
                });
                items = (_c = getCartesianLabelBounds(scale, samplingScaleTicks, op)) === null || _c === void 0 ? void 0 : _c.map((bounds, i) => ({
                    AABBBounds: bounds,
                    value: samplingScaleTicks[i]
                }));
            }
            else {
                items = (_d = getCartesianLabelBounds(scale, scaleTicks, op)) === null || _d === void 0 ? void 0 : _d.map((bounds, i) => ({
                    AABBBounds: bounds,
                    value: scaleTicks[i]
                }));
            }
            if (items) {
                const firstSourceItem = items[0];
                const lastSourceItem = last(items);
                const samplingMethod = breakData && breakData() ? methods.greedy : methods.parity;
                while (items.length >= 3 && hasOverlap(items, labelGap)) {
                    items = samplingMethod(items, labelGap);
                }
                const checkFirst = op.labelFirstVisible;
                let checkLast = op.labelLastVisible;
                if (textIntersect(firstSourceItem, lastSourceItem, labelGap)) {
                    if (items.includes(lastSourceItem) && items.length > 1 && checkFirst && checkLast) {
                        items.splice(items.indexOf(lastSourceItem), 1);
                        checkLast = false;
                    }
                }
                forceItemVisible(firstSourceItem, items, checkFirst, (item) => textIntersect(item, firstSourceItem, labelGap));
                forceItemVisible(lastSourceItem, items, checkLast, (item) => textIntersect(item, lastSourceItem, labelGap) ||
                    (checkFirst && item !== firstSourceItem ? textIntersect(item, firstSourceItem, labelGap) : false), true);
                const ticks = items.map(item => item.value);
                if (ticks.length < 3 && labelFlush) {
                    if (ticks.length > 1) {
                        ticks.pop();
                    }
                    if (last(ticks) !== last(scaleTicks)) {
                        ticks.push(last(scaleTicks));
                    }
                }
                scaleTicks = ticks;
            }
        }
    }
    return convertDomainToTickData(scaleTicks);
};
const methods = {
    parity: function (items) {
        return items.filter((item, i) => i % 2 === 0);
    },
    greedy: function (items, sep) {
        let a;
        return items.filter((b, i) => {
            if (!i || !textIntersect(a, b, sep)) {
                a = b;
                return true;
            }
            return false;
        });
    }
};

const getOneDimensionalLabelBounds = (scale, domain, op, isHorizontal) => {
    const labelBoundsList = getCartesianLabelBounds(scale, domain, op);
    return (labelBoundsList &&
        labelBoundsList.map(bounds => {
            if (isHorizontal) {
                return [bounds.x1, bounds.x2, bounds.width()];
            }
            return [bounds.y1, bounds.y2, bounds.height()];
        }));
};
const boundsOverlap = (prevBounds, nextBounds, gap = 0) => {
    return Math.max(prevBounds[0], nextBounds[0]) - gap / 2 <= Math.min(prevBounds[1], nextBounds[1]) + gap / 2;
};
const boundsDistance = (prevBounds, nextBounds) => {
    if (prevBounds[1] < nextBounds[0]) {
        return nextBounds[0] - prevBounds[1];
    }
    else if (nextBounds[1] < prevBounds[0]) {
        return prevBounds[0] - nextBounds[1];
    }
    return 0;
};
const linearDiscreteTicks = (scale, op) => {
    var _a;
    const domain = scale.domain();
    if (!domain.length) {
        return [];
    }
    const { tickCount, forceTickCount, tickStep, labelGap = 4, axisOrientType, labelStyle } = op;
    const isHorizontal = isAxisHorizontal(axisOrientType);
    const range = scale.range();
    const rangeSize = scale.calculateWholeRangeSize();
    if (rangeSize < 2) {
        if (op.labelLastVisible) {
            return convertDomainToTickData([domain[domain.length - 1]]);
        }
        return convertDomainToTickData([domain[0]]);
    }
    let scaleTicks;
    if (isValid(tickStep)) {
        scaleTicks = scale.stepTicks(tickStep);
    }
    else if (isValid(forceTickCount)) {
        scaleTicks = scale.forceTicks(forceTickCount);
    }
    else if (isValid(tickCount)) {
        const count = isFunction(tickCount) ? tickCount({ axisLength: rangeSize, labelStyle }) : tickCount;
        scaleTicks = scale.ticks(count);
    }
    else if (op.sampling) {
        const fontSize = ((_a = op.labelStyle.fontSize) !== null && _a !== void 0 ? _a : 12) + 2;
        const rangeStart = minInArray(range);
        const rangeEnd = maxInArray(range);
        if (domain.length <= rangeSize / fontSize) {
            const labelBoundsList = getOneDimensionalLabelBounds(scale, domain, op, isHorizontal);
            if (labelBoundsList) {
                const minBoundsLength = Math.min(...labelBoundsList.map(bounds => bounds[2]));
                const incrementUnit = (rangeEnd - rangeStart) / domain.length;
                const stepResult = getStep$1(domain, labelBoundsList, labelGap, op.labelLastVisible, Math.floor(minBoundsLength / incrementUnit), false);
                scaleTicks = scale.stepTicks(stepResult.step);
                if (op.labelLastVisible) {
                    if (stepResult.delCount) {
                        scaleTicks = scaleTicks.slice(0, scaleTicks.length - stepResult.delCount);
                    }
                    scaleTicks.push(domain[domain.length - 1]);
                }
            }
        }
        else {
            const tempDomain = [domain[0], domain[Math.floor(domain.length / 2)], domain[domain.length - 1]];
            const tempList = getOneDimensionalLabelBounds(scale, tempDomain, op, isHorizontal);
            if (tempList) {
                let maxBounds = null;
                tempList.forEach(current => {
                    if (!maxBounds) {
                        maxBounds = current;
                        return;
                    }
                    if (maxBounds[2] < current[2]) {
                        maxBounds = current;
                    }
                });
                const step = rangeEnd - rangeStart - labelGap > 0
                    ? Math.ceil((domain.length * (labelGap + maxBounds[2])) / (rangeEnd - rangeStart - labelGap))
                    : domain.length - 1;
                scaleTicks = scale.stepTicks(step);
                if (op.labelLastVisible &&
                    (!scaleTicks.length || scaleTicks[scaleTicks.length - 1] !== domain[domain.length - 1])) {
                    if (scaleTicks.length &&
                        Math.abs(scale.scale(scaleTicks[scaleTicks.length - 1]) - scale.scale(domain[domain.length - 1])) <
                            maxBounds[2]) {
                        scaleTicks = scaleTicks.slice(0, -1);
                    }
                    scaleTicks.push(domain[domain.length - 1]);
                }
            }
        }
    }
    if (isNil(scaleTicks)) {
        scaleTicks = scale.domain();
    }
    return convertDomainToTickData(scaleTicks);
};
const getStep$1 = (domain, labelBoundsList, labelGap, labelLastVisible, defaultStep, areAllBoundsSame) => {
    let resultDelCount = 0;
    let resultStep = 0;
    let resultTickCount = -1;
    let minDiff = Number.MAX_VALUE;
    const validateStep = (step) => {
        let success = true;
        let ptr = 0;
        do {
            if (ptr + step < domain.length && boundsOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap)) {
                success = false;
            }
            ptr += step;
        } while (success && ptr < domain.length);
        return success;
    };
    const minValidStep = binaryFuzzySearchInNumberRange(defaultStep, domain.length, step => validateStep(step) ? 1 : -1);
    let step = minValidStep;
    do {
        if (step > minValidStep && !areAllBoundsSame) {
            if (!validateStep(step)) {
                step++;
                continue;
            }
        }
        if (labelLastVisible) {
            const lastIndex = domain.length - 1;
            let delCount = 0;
            let ptr;
            if (domain.length % step > 0) {
                ptr = domain.length - (domain.length % step) + step;
            }
            else {
                ptr = domain.length;
            }
            do {
                ptr -= step;
                if (ptr === lastIndex || boundsOverlap(labelBoundsList[ptr], labelBoundsList[lastIndex], labelGap)) {
                    delCount++;
                }
                else {
                    break;
                }
            } while (ptr > 0);
            if (ptr === lastIndex) {
                resultStep = step;
                resultDelCount = delCount;
                break;
            }
            else {
                const tickCount = Math.floor(domain.length / step) - delCount + 1;
                if (tickCount < resultTickCount) {
                    break;
                }
                else {
                    resultTickCount = tickCount;
                    const distance1 = boundsDistance(labelBoundsList[ptr], labelBoundsList[lastIndex]);
                    const distance2 = ptr - step >= 0 ? boundsDistance(labelBoundsList[ptr - step], labelBoundsList[ptr]) : distance1;
                    const diff = Math.abs(distance1 - distance2);
                    if (diff < minDiff) {
                        minDiff = diff;
                        resultStep = step;
                        resultDelCount = delCount;
                    }
                    if (distance1 <= distance2) {
                        break;
                    }
                }
            }
        }
        else {
            resultStep = step;
            break;
        }
        step++;
    } while (step <= domain.length);
    return {
        step: resultStep,
        delCount: resultDelCount
    };
};

const getPolarAngleLabelBounds = (scale, domain, op) => {
    var _a;
    const { labelStyle, getRadius, labelOffset, labelFormatter, inside } = op;
    const radius = getRadius === null || getRadius === void 0 ? void 0 : getRadius();
    const labelAngle = (_a = labelStyle.angle) !== null && _a !== void 0 ? _a : 0;
    const textMeasure = initTextMeasure(labelStyle);
    const labelBoundsList = domain.map((v) => {
        const str = labelFormatter ? labelFormatter(v) : `${v}`;
        const { width, height } = textMeasure.quickMeasure(str);
        const textWidth = Math.max(width, MIN_TICK_GAP);
        const textHeight = Math.max(height, MIN_TICK_GAP);
        const angle = scale.scale(v);
        const center = { x: 0, y: 0 };
        let textX = 0;
        let textY = 0;
        const orient = {
            align: labelStyle.textAlign,
            baseline: labelStyle.textBaseline
        };
        const { x, y } = getPolarAngleLabelPosition(angle, center, radius, labelOffset, inside);
        if (!orient.align) {
            if (isNumberClose(x, center.x)) {
                if (!orient.baseline) {
                    if (y > center.y) {
                        orient.baseline = 'top';
                    }
                    else {
                        orient.baseline = 'bottom';
                    }
                }
            }
            else if (x > center.x) {
                orient.align = 'left';
            }
            else if (x < center.x) {
                orient.align = 'right';
            }
        }
        textX = x + (orient.align === 'right' ? -textWidth : orient.align === 'left' ? 0 : -textWidth / 2);
        textY = y + (orient.baseline === 'bottom' ? -textHeight : orient.baseline === 'top' ? 0 : -textHeight / 2);
        const bounds = new AABBBounds()
            .set(textX, textY, textX + textWidth, textY + textHeight)
            .rotate(labelAngle, textX + textWidth / 2, textY + textHeight / 2);
        return bounds;
    });
    return labelBoundsList;
};
const polarAngleAxisDiscreteTicks = (scale, op) => {
    const { tickCount, forceTickCount, tickStep, getRadius, labelOffset, labelGap = 0, labelStyle } = op;
    const radius = getRadius === null || getRadius === void 0 ? void 0 : getRadius();
    if (!radius) {
        return convertDomainToTickData(scale.domain());
    }
    let scaleTicks;
    if (isValid(tickStep)) {
        scaleTicks = scale.stepTicks(tickStep);
    }
    else if (isValid(forceTickCount)) {
        scaleTicks = scale.forceTicks(forceTickCount);
    }
    else if (isValid(tickCount)) {
        const range = scale.range();
        const rangeSize = Math.abs(range[range.length - 1] - range[0]);
        const count = isFunction(tickCount)
            ? tickCount({ axisLength: rangeSize, labelStyle })
            : tickCount;
        scaleTicks = scale.ticks(count);
    }
    else if (op.sampling) {
        const domain = scale.domain();
        const range = scale.range();
        const labelBoundsList = getPolarAngleLabelBounds(scale, domain, op);
        const rangeStart = minInArray(range);
        const rangeEnd = maxInArray(range);
        const axisLength = Math.abs(rangeEnd - rangeStart) * (radius + labelOffset);
        const incrementUnit = axisLength / domain.length;
        const { step, delCount } = getStep(domain, labelBoundsList, labelGap, Math.floor(labelBoundsList.reduce((min, curBounds) => {
            return Math.min(min, curBounds.width(), curBounds.height());
        }, Number.MAX_VALUE) / incrementUnit));
        scaleTicks = scale.stepTicks(step);
        scaleTicks = scaleTicks.slice(0, scaleTicks.length - delCount);
    }
    else {
        scaleTicks = scale.domain();
    }
    return convertDomainToTickData(scaleTicks);
};
const getStep = (domain, labelBoundsList, labelGap, defaultStep) => {
    let step = defaultStep;
    do {
        let success = true;
        step++;
        let ptr = 0;
        do {
            if (ptr + step < domain.length && labelOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap)) {
                success = false;
            }
            ptr += step;
        } while (success && ptr < domain.length);
        if (success) {
            break;
        }
    } while (step <= domain.length);
    let delCount = 0;
    if (domain.length > 2) {
        let ptr = domain.length - (domain.length % step);
        if (ptr >= domain.length) {
            ptr -= step;
        }
        while (ptr > 0 && labelOverlap(labelBoundsList[0], labelBoundsList[ptr])) {
            delCount++;
            ptr -= step;
        }
    }
    return {
        step,
        delCount
    };
};

const ticks = (scale, op) => {
    if (isContinuous(scale.type)) {
        return continuousTicks(scale, op);
    }
    else if (isDiscrete(scale.type)) {
        if (op.coordinateType === 'cartesian') {
            return linearDiscreteTicks(scale, op);
        }
        else if (op.coordinateType === 'polar') {
            if (op.axisOrientType === 'angle') {
                return polarAngleAxisDiscreteTicks(scale, op);
            }
        }
    }
    return convertDomainToTickData(scale.domain());
};

const cartesianTicks = (scale, op) => {
    if (isContinuous(scale.type)) {
        return continuousTicks(scale, op);
    }
    else if (isDiscrete(scale.type)) {
        if (op.coordinateType === 'cartesian') {
            return linearDiscreteTicks(scale, op);
        }
    }
    return convertDomainToTickData(scale.domain());
};

const polarTicks = (scale, op) => {
    if (isContinuous(scale.type)) {
        return continuousTicks(scale, op);
    }
    else if (isDiscrete(scale.type)) {
        if (op.coordinateType === 'polar') {
            if (op.axisOrientType === 'angle') {
                return polarAngleAxisDiscreteTicks(scale, op);
            }
        }
    }
    return convertDomainToTickData(scale.domain());
};

loadPolygonSectorCrosshairComponent();
class PolygonSectorCrosshair extends CrosshairBase {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, PolygonSectorCrosshair.defaultAttributes, attributes));
    }
    renderCrosshair(container) {
        const { center, radius, innerRadius = 0, polygonSectorStyle } = this.attribute;
        const { startAngle, endAngle } = this.attribute;
        const points = [];
        points.push(polarToCartesian(center, innerRadius, startAngle));
        points.push(polarToCartesian(center, radius * Math.cos((endAngle - startAngle) / 2), startAngle));
        points.push(polarToCartesian(center, radius, (startAngle + endAngle) / 2));
        points.push(polarToCartesian(center, radius * Math.cos((endAngle - startAngle) / 2), endAngle));
        points.push(polarToCartesian(center, innerRadius, endAngle));
        const polygon = container.createOrUpdateChild('crosshair-polygon-sector', Object.assign({ path: getPolygonPath(points, true) }, polygonSectorStyle), 'path');
        return polygon;
    }
    setLocation(point) {
        const { center, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute;
        const sectorAngle = endAngle - startAngle;
        const pointAngle = radianToDegree(getAngleByPoint(center, point));
        this.setAttributes({
            startAngle: pointAngle - sectorAngle / 2,
            endAngle: pointAngle + sectorAngle / 2
        });
    }
}
PolygonSectorCrosshair.defaultAttributes = {
    polygonSectorStyle: {
        fill: '#b2bacf',
        opacity: 0.2
    }
};

const DIV = 5;
const MOD = 31;
const SIZE = 32;
const RIGHT0 = new Uint32Array(SIZE + 1);
const RIGHT1 = new Uint32Array(SIZE + 1);
RIGHT1[0] = 0;
RIGHT0[0] = ~RIGHT1[0];
for (let i = 1; i <= SIZE; ++i) {
    RIGHT1[i] = (RIGHT1[i - 1] << 1) | 1;
    RIGHT0[i] = ~RIGHT1[i];
}
function bitmap(w, h) {
    const array = new Uint32Array(~~((w * h + SIZE) / SIZE));
    function _set(index, mask) {
        array[index] |= mask;
    }
    function _clear(index, mask) {
        array[index] &= mask;
    }
    return {
        array: array,
        get: (x, y) => {
            const index = y * w + x;
            return array[index >>> DIV] & (1 << (index & MOD));
        },
        set: (x, y) => {
            const index = y * w + x;
            _set(index >>> DIV, 1 << (index & MOD));
        },
        clear: (x, y) => {
            const index = y * w + x;
            _clear(index >>> DIV, ~(1 << (index & MOD)));
        },
        getRange: ({ x1, y1, x2, y2 }) => {
            if (x2 < 0 || y2 < 0 || x1 > w || y1 > h) {
                return true;
            }
            let r = y2;
            let start;
            let end;
            let indexStart;
            let indexEnd;
            for (; r >= y1; --r) {
                start = r * w + x1;
                end = r * w + x2;
                indexStart = start >>> DIV;
                indexEnd = end >>> DIV;
                if (indexStart === indexEnd) {
                    if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {
                        return true;
                    }
                }
                else {
                    if (array[indexStart] & RIGHT0[start & MOD]) {
                        return true;
                    }
                    if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) {
                        return true;
                    }
                    for (let i = indexStart + 1; i < indexEnd; ++i) {
                        if (array[i]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        },
        setRange: ({ x1, y1, x2, y2 }) => {
            if (x2 < 0 || y2 < 0 || x1 > w || y1 > h) {
                return;
            }
            let start;
            let end;
            let indexStart;
            let indexEnd;
            let i;
            for (; y1 <= y2; ++y1) {
                start = y1 * w + x1;
                end = y1 * w + x2;
                indexStart = start >>> DIV;
                indexEnd = end >>> DIV;
                if (indexStart === indexEnd) {
                    _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);
                }
                else {
                    _set(indexStart, RIGHT0[start & MOD]);
                    _set(indexEnd, RIGHT1[(end & MOD) + 1]);
                    for (i = indexStart + 1; i < indexEnd; ++i) {
                        _set(i, 0xffffffff);
                    }
                }
            }
        },
        clearRange: ({ x1, y1, x2, y2 }) => {
            let start;
            let end;
            let indexStart;
            let indexEnd;
            let i;
            for (; y1 <= y2; ++y1) {
                start = y1 * w + x1;
                end = y1 * w + x2;
                indexStart = start >>> DIV;
                indexEnd = end >>> DIV;
                if (indexStart === indexEnd) {
                    _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);
                }
                else {
                    _clear(indexStart, RIGHT1[start & MOD]);
                    _clear(indexEnd, RIGHT0[(end & MOD) + 1]);
                    for (i = indexStart + 1; i < indexEnd; ++i) {
                        _clear(i, 0);
                    }
                }
            }
        },
        outOfBounds: ({ x1, y1, x2, y2 }) => x1 < 0 || y1 < 0 || y2 >= h || x2 >= w,
        toImageData: (ctx) => {
            const imageData = ctx.createImageData(w, h);
            const data = imageData.data;
            for (let y = 0; y < h; ++y) {
                for (let x = 0; x < w; ++x) {
                    const index = y * w + x;
                    const offset = 4 * index;
                    const occupied = array[index >>> DIV] & (1 << (index & MOD));
                    data[offset + 0] = occupied * 0xff;
                    data[offset + 1] = occupied * 0xff;
                    data[offset + 2] = occupied * 0xff;
                    data[offset + 3] = 0x1f;
                }
            }
            return imageData;
        }
    };
}

function bitmapTool(width, height, padding = { top: 0, left: 0, right: 0, bottom: 0 }) {
    const { top = 0, left = 0, right = 0, bottom = 0 } = padding;
    const ratio = Math.max(1, Math.sqrt((width * height) / 1e6));
    const w = ~~((width + left + right + ratio) / ratio);
    const h = ~~((height + top + bottom + ratio) / ratio);
    const scale = (_) => ~~(_ / ratio);
    scale.bitmap = () => bitmap(w, h);
    scale.x = (_) => ~~((_ + left) / ratio);
    scale.y = (_) => ~~((_ + top) / ratio);
    scale.ratio = ratio;
    scale.padding = padding;
    scale.width = width;
    scale.height = height;
    return scale;
}
function clampRangeByBitmap($, range) {
    const { x1, x2, y1, y2 } = range;
    const { top = 0, left = 0, right = 0, bottom = 0 } = $.padding;
    const _x1 = clamp(x1, -left, $.width + right);
    const _x2 = clamp(x2, -left, $.width + right);
    const _y1 = clamp(y1, -top, $.height + bottom);
    const _y2 = clamp(y2, -top, $.height + bottom);
    return {
        x1: $.x(_x1),
        x2: $.x(_x2),
        y1: $.y(_y1),
        y2: $.y(_y2)
    };
}
function boundToRange($, bound, clamp = false) {
    if (clamp) {
        return clampRangeByBitmap($, bound);
    }
    return {
        x1: $.x(bound.x1),
        x2: $.x(bound.x2),
        y1: $.y(bound.y1),
        y2: $.y(bound.y2)
    };
}

function canPlace($, bitmap, bound, checkBound = true, pad = 0) {
    let range = bound;
    if (pad > 0) {
        range = {
            x1: bound.x1 - pad,
            x2: bound.x2 + pad,
            y1: bound.y1 - pad,
            y2: bound.y2 + pad
        };
    }
    range = boundToRange($, range);
    const outOfBounds = bitmap.outOfBounds(range);
    if (checkBound && outOfBounds) {
        return false;
    }
    if (outOfBounds) {
        range = clampRangeByBitmap($, range);
    }
    return !bitmap.getRange(range);
}
function placeToCandidates($, bitmap, text, candidates = [], clampForce = true, pad = 0, changePosition = false) {
    const validCandidates = candidates.filter(candidate => isValid(candidate));
    for (let i = 0; i < validCandidates.length; i++) {
        let measureText;
        if (changePosition) {
            measureText = text;
        }
        else {
            measureText = text.clone();
        }
        measureText.setAttributes(validCandidates[i]);
        if (canPlace($, bitmap, measureText.AABBBounds, clampForce, pad)) {
            bitmap.setRange(boundToRange($, measureText.AABBBounds, true));
            return validCandidates[i];
        }
    }
    return false;
}
function place($, bitmap, s, attrs, text, bounds, labeling) {
    var _a, _b;
    const clampForce = (_a = attrs.overlap) === null || _a === void 0 ? void 0 : _a.clampForce;
    const overlapPadding = (_b = attrs.overlap) === null || _b === void 0 ? void 0 : _b.overlapPadding;
    if (s.type === 'bound' || s.type === 'position') {
        if (isFunction(labeling)) {
            const userPosition = isFunction(s.position) ? s.position(text.attribute) : s.position;
            const positions = (userPosition || defaultLabelPosition(attrs.type));
            const candidates = positions.map(p => labeling(text.AABBBounds, bounds, p, attrs.offset));
            const shouldClone = s.restorePosition === false;
            return placeToCandidates($, bitmap, text, candidates, clampForce, overlapPadding, shouldClone);
        }
        return false;
    }
    if (s.type === 'moveY') {
        const offset = s.offset ? (isFunction(s.offset) ? s.offset(text.attribute) : s.offset) : [];
        const candidates = offset.map(dy => {
            return { x: text.attribute.x, y: text.attribute.y + dy };
        });
        return placeToCandidates($, bitmap, text, candidates, clampForce, overlapPadding);
    }
    if (s.type === 'moveX') {
        const offset = s.offset ? (isFunction(s.offset) ? s.offset(text.attribute) : s.offset) : [];
        const candidates = offset.map(dx => {
            return { x: text.attribute.x + dx, y: text.attribute.y };
        });
        return placeToCandidates($, bitmap, text, candidates, clampForce, overlapPadding);
    }
    return false;
}
const DefaultPositions = [
    'top',
    'bottom',
    'right',
    'left',
    'top-right',
    'bottom-right',
    'top-left',
    'bottom-left'
];
const DefaultRectPositions = ['top', 'inside-top', 'inside'];
function defaultLabelPosition(type) {
    switch (type) {
        case 'rect':
            return DefaultRectPositions;
        default:
            return DefaultPositions;
    }
}
function clampText(text, width, height, padding = {}) {
    const { x1, x2, y1, y2 } = text.AABBBounds;
    const { top = 0, left = 0, right = 0, bottom = 0 } = padding;
    const minX = Math.min(x1, x2);
    const maxX = Math.max(x1, x2);
    const minY = Math.min(y1, y2);
    const maxY = Math.max(y1, y2);
    const minXWithPadding = 0 - left;
    const maxXWithPadding = width + right;
    const minYWithPadding = 0 - top;
    const maxYWithPadding = height + bottom;
    let dx = 0;
    let dy = 0;
    if (minX < minXWithPadding) {
        dx = -minX;
    }
    else if (maxX > maxXWithPadding) {
        dx = maxXWithPadding - maxX;
    }
    if (minY < minYWithPadding) {
        dy = -minY;
    }
    else if (maxY > maxYWithPadding) {
        dy = maxYWithPadding - maxY;
    }
    return { dx, dy };
}

const DefaultLabelAnimation = {
    mode: 'same-time',
    duration: 300,
    easing: 'linear'
};

function isQuadrantLeft(quadrant) {
    return quadrant === 3 || quadrant === 4;
}
function isQuadrantRight(quadrant) {
    return quadrant === 1 || quadrant === 2;
}
function lineCirclePoints(a, b, c, x0, y0, r) {
    if ((a === 0 && b === 0) || r <= 0) {
        return [];
    }
    if (a === 0) {
        const y1 = -c / b;
        const fy = (y1 - y0) ** 2;
        const fd = r ** 2 - fy;
        if (fd < 0) {
            return [];
        }
        else if (fd === 0) {
            return [{ x: x0, y: y1 }];
        }
        const x1 = Math.sqrt(fd) + x0;
        const x2 = -Math.sqrt(fd) + x0;
        return [
            { x: x1, y: y1 },
            { x: x2, y: y1 }
        ];
    }
    else if (b === 0) {
        const x1 = -c / a;
        const fx = (x1 - x0) ** 2;
        const fd = r ** 2 - fx;
        if (fd < 0) {
            return [];
        }
        else if (fd === 0) {
            return [{ x: x1, y: y0 }];
        }
        const y1 = Math.sqrt(fd) + y0;
        const y2 = -Math.sqrt(fd) + y0;
        return [
            { x: x1, y: y1 },
            { x: x1, y: y2 }
        ];
    }
    const fa = (b / a) ** 2 + 1;
    const fb = 2 * ((c / a + x0) * (b / a) - y0);
    const fc = (c / a + x0) ** 2 + y0 ** 2 - r ** 2;
    const fd = fb ** 2 - 4 * fa * fc;
    if (fd < 0) {
        return [];
    }
    const y1 = (-fb + Math.sqrt(fd)) / (2 * fa);
    const y2 = (-fb - Math.sqrt(fd)) / (2 * fa);
    const x1 = -(b * y1 + c) / a;
    const x2 = -(b * y2 + c) / a;
    if (fd === 0) {
        return [{ x: x1, y: y1 }];
    }
    return [
        { x: x1, y: y1 },
        { x: x2, y: y2 }
    ];
}
function connectLineRadian(radius, length) {
    if (length > radius * 2) {
        return NaN;
    }
    return Math.asin(length / 2 / radius) * 2;
}
function checkBoundsOverlap(boundsA, boundsB) {
    const { x1: ax1, y1: ay1, x2: ax2, y2: ay2 } = boundsA;
    const { x1: bx1, y1: by1, x2: bx2, y2: by2 } = boundsB;
    return !((ax1 <= bx1 && ax2 <= bx1) ||
        (ax1 >= bx2 && ax2 >= bx2) ||
        (ay1 <= by1 && ay2 <= by1) ||
        (ay1 >= by2 && ay2 >= by2));
}
const labelingPoint = (textBounds, graphicBounds, position = 'top', offset = 0) => {
    if (!textBounds) {
        return;
    }
    const { x1, y1, x2, y2 } = textBounds;
    const width = Math.abs(x2 - x1);
    const height = Math.abs(y2 - y1);
    const anchorX = (graphicBounds.x1 + graphicBounds.x2) / 2;
    const anchorY = (graphicBounds.y1 + graphicBounds.y2) / 2;
    let sx = 0;
    let sy = 0;
    let offsetX = 0;
    let offsetY = 0;
    if (graphicBounds) {
        offsetX = Math.abs(graphicBounds.x1 - graphicBounds.x2) / 2;
        offsetY = Math.abs(graphicBounds.y1 - graphicBounds.y2) / 2;
    }
    const angle = {
        'top-right': -235,
        'top-left': 235,
        'bottom-right': 45,
        'bottom-left': -45
    };
    switch (position) {
        case 'top':
            sy = -1;
            break;
        case 'bottom':
            sy = 1;
            break;
        case 'left':
            sx = -1;
            break;
        case 'right':
            sx = 1;
            break;
        case 'bottom-left':
        case 'bottom-right':
        case 'top-left':
        case 'top-right':
            sx = Math.sin(angle[position] * (Math.PI / 180));
            sy = Math.cos(angle[position] * (Math.PI / 180));
            break;
        case 'center':
            sx = 0;
            sy = 0;
            break;
    }
    const x = anchorX + sx * (offset + offsetX) + Math.sign(sx) * (width / 2);
    const y = anchorY + sy * (offset + offsetY) + Math.sign(sy) * (height / 2);
    return { x, y };
};
const getPointsOfLineArea = (graphic) => {
    if (!graphic || !graphic.attribute) {
        return [];
    }
    const { points, segments } = graphic.attribute;
    if (segments && segments.length) {
        const res = [];
        segments.forEach(seg => {
            const segPoints = seg.points;
            segPoints.forEach(point => {
                res.push(point);
            });
        });
        return res;
    }
    return points;
};
function labelingLineOrArea(textBounds, graphicBounds, position = 'end', offset = 0) {
    if (!textBounds || !graphicBounds) {
        return { x: Infinity, y: Infinity };
    }
    const { x1, x2 } = textBounds;
    const width = Math.abs(x2 - x1);
    const anchorX = graphicBounds.x1;
    const anchorY = graphicBounds.y1;
    let x = anchorX;
    const y = anchorY;
    if (position === 'end') {
        x = anchorX + width / 2 + offset;
    }
    else if (position === 'start') {
        x = anchorX - width / 2 - offset;
    }
    return { x, y };
}
function connectLineBetweenBounds(boundA, boundB) {
    if (!boundA || !boundB) {
        return;
    }
    if (isRectIntersect(boundA, boundB, true)) {
        return;
    }
    const x1 = Math.min(boundA.x1, boundA.x2);
    const y1 = Math.min(boundA.y1, boundA.y2);
    const x2 = Math.min(boundB.x1, boundB.x2);
    const y2 = Math.min(boundB.y1, boundB.y2);
    const w1 = Math.abs(boundA.x2 - x1) / 2;
    const h1 = Math.abs(boundA.y2 - y1) / 2;
    const w2 = Math.abs(boundB.x2 - x2) / 2;
    const h2 = Math.abs(boundB.y2 - y2) / 2;
    const cx1 = x1 + w1;
    const cy1 = y1 + h1;
    const cx2 = x2 + w2;
    const cy2 = y2 + h2;
    const dx = cx2 - cx1;
    const dy = cy2 - cy1;
    const p1 = getIntersection(dx, dy, cx1, cy1, w1, h1);
    const p2 = getIntersection(-dx, -dy, cx2, cy2, w2, h2);
    return [p1, p2];
}
function getIntersection(dx, dy, cx, cy, w, h) {
    if (Math.abs(dy / dx) < h / w) {
        return { x: cx + (dx > 0 ? w : -w), y: cy + (dy * w) / Math.abs(dx) };
    }
    return { x: cx + (dx * h) / Math.abs(dy), y: cy + (dy > 0 ? h : -h) };
}
function getAlignOffset(align) {
    if (align === 'left') {
        return 0;
    }
    else if (align === 'right') {
        return 1;
    }
    return 0.5;
}

class LabelUpdate extends AComponentAnimate {
    onBind() {
        const animator = createComponentAnimator(this.target);
        this._animator = animator;
        const duration = this.duration;
        const easing = this.easing;
        const { prevText, curText, prevLabelLine, curLabelLine, increaseEffect = true } = this.params;
        const diff = {};
        for (const key in curText.attribute) {
            if (prevText.attribute[key] !== curText.attribute[key]) {
                diff[key] = curText.attribute[key];
            }
        }
        const rest = __rest(diff, ["text"]);
        animator.animate(prevText, {
            type: 'to',
            to: rest,
            duration,
            easing
        });
        if (increaseEffect !== false) {
            animator.animate(prevText, {
                type: 'increaseCount',
                to: {
                    text: curText.attribute.text
                },
                duration,
                easing
            });
        }
        if (prevLabelLine) {
            animator.animate(prevLabelLine, {
                type: 'to',
                to: curLabelLine.attribute,
                duration,
                easing
            });
        }
        this.completeBind(animator);
    }
    tryPreventConflict() {
        return;
    }
}
class LabelEnter extends AComponentAnimate {
    onBind() {
        const animator = createComponentAnimator(this.target);
        this._animator = animator;
        const duration = this.duration;
        const easing = this.easing;
        const { relatedGraphic, relatedGraphics, config } = this.params;
        const { mode, type = 'fadeIn' } = config;
        const target = this.target;
        let startTime = 0;
        if (mode === 'after') {
            relatedGraphic.animates &&
                relatedGraphic.animates.forEach((animate) => {
                    startTime = Math.max(startTime, animate.getStartTime() + animate.getTotalDuration());
                });
        }
        else if (mode === 'after-all') {
            relatedGraphics &&
                relatedGraphics.forEach((graphic) => {
                    graphic.animates &&
                        graphic.animates.forEach((animate) => {
                            startTime = Math.max(startTime, animate.getStartTime() + animate.getTotalDuration());
                        });
                });
        }
        else {
            relatedGraphic.animates &&
                relatedGraphic.animates.forEach((animate) => {
                    startTime = Math.max(startTime, animate.getStartTime());
                });
        }
        animator.animate(target, Object.assign(Object.assign({}, config), { duration,
            easing,
            startTime,
            type }));
        this.completeBind(animator);
    }
    tryPreventConflict() {
        return;
    }
}
function registerLabelAnimate() {
    AnimateExecutor.registerBuiltInAnimate('increaseCount', IncreaseCount);
    AnimateExecutor.registerBuiltInAnimate('labelUpdate', LabelUpdate);
    AnimateExecutor.registerBuiltInAnimate('labelEnter', LabelEnter);
}

function loadLabelComponent() {
    registerGroup();
    registerText();
    registerRichtext();
    registerLine();
    registerLabelAnimate();
}

const isIntersect = (top, bottom) => {
    return Math.ceil(top) > Math.floor(bottom);
};
const isXIntersect = ([a, b], [c, d]) => {
    return d > a && b > c;
};
function getIntersectionLength(range1, range2) {
    const [start1, end1] = range1;
    const [start2, end2] = range2;
    const start = Math.max(start1, start2);
    const end = Math.min(end1, end2);
    return Math.max(0, end - start);
}
function shiftY(texts, option) {
    const { maxY = Number.MAX_VALUE, labelling, globalShiftY = { enable: true, maxIterations: 10, maxError: 0.1, padding: 1 } } = option;
    const n = texts.length;
    if (n <= 1) {
        return texts;
    }
    const xMap = new Map();
    const textInformation = new Map();
    const getY1Initial = (text) => textInformation.get(text).y1Initial;
    const getHeight = (text) => textInformation.get(text).height;
    const getY1 = (text) => textInformation.get(text).y1;
    const getY = (text) => textInformation.get(text).y;
    const getX = (text) => textInformation.get(text).x;
    const getX1 = (text) => textInformation.get(text).x1;
    const getX2 = (text) => textInformation.get(text).x2;
    const getAdjustAttempts = (text) => textInformation.get(text).attempts;
    const setY1 = (text, y) => {
        textInformation.get(text).y1 = y;
    };
    const setAdjustAttempts = (text, attempts) => {
        textInformation.get(text).attempts = attempts;
    };
    function adjustPositionInOneGroup(texts) {
        for (let i = texts.length - 1; i >= 0; i--) {
            const curText = texts[i];
            const upperText = texts[i - 1];
            const lowerText = texts[i + 1];
            if ((upperText && isIntersect(getY1(upperText) + getHeight(upperText), getY1(curText))) ||
                (getY1(curText) === 0 && curText._isClamped)) {
                const { y } = labelling(curText);
                if (!lowerText || !isIntersect(y + getHeight(curText) / 2, getY1(lowerText))) {
                    if (y + getHeight(curText) / 2 <= maxY) {
                        setY1(curText, getY1(curText) + y - getY(curText));
                    }
                }
            }
        }
    }
    texts.sort((a, b) => a.attribute.x - b.attribute.x);
    for (const text of texts) {
        const { y1, y2, x1, x2 } = text.AABBBounds;
        const { x, y } = text.attribute;
        textInformation.set(text, { y1Initial: y1, y1, y2, y, height: y2 - y1, x1, x2, x, attempts: 0 });
        let hasRange = false;
        for (const [range, xGroupTexts] of xMap) {
            const { start, end } = range;
            if (x1 >= start && x2 <= end) {
                xGroupTexts.push(text);
                hasRange = true;
            }
            else if (isNumberClose(x, getX(xGroupTexts[0]), undefined, 5)) {
                const newRange = { start: Math.min(start, x1), end: Math.max(end, x2) };
                xGroupTexts.push(text);
                xMap.set(newRange, xGroupTexts);
                xMap.delete(range);
                hasRange = true;
            }
            else if (getIntersectionLength([start, end], [x1, x2]) / (end - start) > 0.5) {
                const newRange = { start: Math.min(start, x1), end: Math.max(end, x2) };
                xGroupTexts.push(text);
                xMap.set(newRange, xGroupTexts);
                xMap.delete(range);
                hasRange = true;
            }
            if (hasRange) {
                break;
            }
        }
        if (!hasRange) {
            xMap.set({ start: x1, end: x2 }, [text]);
        }
    }
    for (const xTexts of xMap.values()) {
        xTexts.sort((a, b) => getY1Initial(a) - getY1Initial(b));
        adjustPositionInOneGroup(xTexts);
    }
    if (globalShiftY.enable !== false) {
        const { maxIterations = 10, maxError = 0.1, padding = 1, maxAttempts = 1000, deltaYTolerance = Number.MAX_VALUE } = globalShiftY;
        for (let iter = 0; iter < maxIterations; iter++) {
            texts.sort((a, b) => getY1Initial(a) - getY1Initial(b));
            let error = 0;
            for (let i = 0; i < n - 1; i++) {
                const curText = texts[i];
                if (getAdjustAttempts(curText) >= maxAttempts) {
                    continue;
                }
                let j = i + 1;
                let nextText;
                while ((nextText = texts[j]) &&
                    !isXIntersect([getX1(curText), getX2(curText)], [getX1(nextText), getX2(nextText)])) {
                    j += 1;
                }
                if (nextText) {
                    const y1 = getY1(curText);
                    const h0 = getHeight(curText);
                    const nextY1 = getY1(nextText);
                    const delta = nextY1 - (y1 + h0);
                    if (delta < padding) {
                        const newDelta = (padding - delta) / 2;
                        error = Math.max(error, newDelta);
                        if (y1 + newDelta + getHeight(nextText) > maxY) {
                            const newY1 = y1 - (padding - delta);
                            const curTextDelta = getY1Initial(curText) - newY1;
                            if (Math.abs(curTextDelta) <= deltaYTolerance) {
                                setY1(curText, newY1);
                                setAdjustAttempts(curText, getAdjustAttempts(curText) + 1);
                            }
                        }
                        else if (y1 - newDelta < 0) {
                            const newY1 = nextY1 + (padding - delta);
                            const nextTextDelta = getY1Initial(nextText) - newY1;
                            if (Math.abs(nextTextDelta) <= deltaYTolerance) {
                                setY1(nextText, newY1);
                                setAdjustAttempts(nextText, getAdjustAttempts(nextText) + 1);
                            }
                        }
                        else {
                            const newCurY1 = y1 - newDelta;
                            const curTextDelta = getY1Initial(curText) - newCurY1;
                            const newNextY1 = nextY1 + newDelta;
                            const nextTextDelta = getY1Initial(nextText) - newNextY1;
                            if (Math.abs(curTextDelta) <= deltaYTolerance && Math.abs(nextTextDelta) <= deltaYTolerance) {
                                setY1(curText, newCurY1);
                                setY1(nextText, newNextY1);
                                setAdjustAttempts(curText, getAdjustAttempts(curText) + 1);
                                setAdjustAttempts(nextText, getAdjustAttempts(nextText) + 1);
                            }
                        }
                    }
                }
            }
            if (error < maxError) {
                break;
            }
        }
    }
    for (const text of texts) {
        const finalY = text.attribute.y + getY1(text) - getY1Initial(text);
        text.setAttribute('y', finalY);
    }
    const result = [];
    texts.sort((a, b) => a.attribute.x - b.attribute.x);
    let start = 0;
    let end = texts.length - 1;
    while (start <= end) {
        if (start === end) {
            result.push(texts[start]);
        }
        else {
            result.push(texts[start]);
            result.push(texts[end]);
        }
        start++;
        end--;
    }
    return result;
}

loadLabelComponent();
class LabelBase extends AnimateComponent {
    setBitmap(bitmap) {
        this._bitmap = bitmap;
    }
    setBitmapTool(bmpTool) {
        this._bmpTool = bmpTool;
    }
    constructor(attributes, options) {
        const { data } = attributes, restAttributes = __rest(attributes, ["data"]);
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : Object.assign({ data }, merge({}, LabelBase.defaultAttributes, restAttributes)));
        this.name = 'label';
        this._onHover = (e) => {
            const target = e.target;
            if (target !== this._lastHover && !isEmpty(target.states)) {
                target.addState(StateValue.hover, true);
                traverseGroup(this, (node) => {
                    if (node !== target && !isEmpty(node.states)) {
                        node.addState(StateValue.hoverReverse, true);
                    }
                });
                this._lastHover = target;
            }
        };
        this._onUnHover = (e) => {
            if (this._lastHover) {
                traverseGroup(this, (node) => {
                    if (!isEmpty(node.states)) {
                        node.removeState(StateValue.hoverReverse);
                        node.removeState(StateValue.hover);
                    }
                });
                this._lastHover = null;
            }
        };
        this._onClick = (e) => {
            const target = e.target;
            if (this._lastSelect === target && target.hasState('selected')) {
                this._lastSelect = null;
                traverseGroup(this, (node) => {
                    if (!isEmpty(node.states)) {
                        node.removeState(StateValue.selectedReverse);
                        node.removeState(StateValue.selected);
                    }
                });
                return;
            }
            if (!isEmpty(target.states)) {
                target.addState(StateValue.selected, true);
                traverseGroup(this, (node) => {
                    if (node !== target && !isEmpty(node.states)) {
                        node.addState(StateValue.selectedReverse, true);
                    }
                });
                this._lastSelect = target;
            }
        };
        this._handleRelatedGraphicSetState = (e) => {
            var _a, _b, _c, _d, _e;
            if (((_a = e.detail) === null || _a === void 0 ? void 0 : _a.type) === AttributeUpdateType.STATE ||
                (((_b = e.detail) === null || _b === void 0 ? void 0 : _b.type) === AttributeUpdateType.ANIMATE_UPDATE && ((_c = e.detail.animationState) === null || _c === void 0 ? void 0 : _c.isFirstFrameOfStep))) {
                const currentStates = (_e = (_d = e.target) === null || _d === void 0 ? void 0 : _d.currentStates) !== null && _e !== void 0 ? _e : [];
                const labels = this._isCollectionBase ? [...this._graphicToText.values()] : [this._graphicToText.get(e.target)];
                this.updateStatesOfLabels(labels, currentStates);
            }
        };
    }
    labeling(textBounds, graphicBounds, position, offset) {
        return;
    }
    _getLabelLinePoints(text, baseMark) {
        return connectLineBetweenBounds(text.AABBBounds, baseMark === null || baseMark === void 0 ? void 0 : baseMark.AABBBounds);
    }
    _createLabelLine(text, baseMark) {
        const points = this._getLabelLinePoints(text, baseMark);
        if (points) {
            const lineGraphic = graphicCreator.line({
                points
            });
            const { line = {} } = text.attribute;
            if (line.customShape) {
                const customShape = line.customShape;
                lineGraphic.pathProxy = (attrs) => {
                    return customShape({
                        text,
                        baseMark: baseMark
                    }, attrs, new CustomPath2D());
                };
            }
            if (baseMark && baseMark.getAttributes(true).fill) {
                lineGraphic.setAttribute('stroke', baseMark.getAttributes(true).fill);
            }
            if (this.attribute.line && !isEmpty(this.attribute.line.style)) {
                lineGraphic.setAttributes(this.attribute.line.style);
            }
            this._setStatesOfLabelLine(lineGraphic);
            return lineGraphic;
        }
    }
    render() {
        this._prepare();
        if (isNil(this._idToGraphic) || (this._isCollectionBase && isNil(this._idToPoint))) {
            return;
        }
        const markAttributeList = [];
        if (this._enableAnimation !== false) {
            this._baseMarks.forEach(mark => {
                markAttributeList.push(mark.attribute);
                mark.initAttributes(mark.getAttributes(true));
            });
        }
        const { overlap, smartInvert, dataFilter, customLayoutFunc, customOverlapFunc } = this.attribute;
        let data = this.attribute.data;
        if (isFunction(dataFilter)) {
            data = dataFilter(data);
        }
        if (data && data.length) {
            const seenIds = new Set();
            data = data.filter(d => !seenIds.has(d.id) && seenIds.add(d.id));
        }
        let labels = this._initText(data);
        if (isFunction(customLayoutFunc)) {
            labels = customLayoutFunc(data, labels, this.getRelatedGraphic.bind(this), this._isCollectionBase ? (d) => this._idToPoint.get(d.id) : null, this);
        }
        else {
            labels = this._layout(labels);
        }
        if (isFunction(customOverlapFunc)) {
            labels = customOverlapFunc(labels, this.getRelatedGraphic.bind(this), this._isCollectionBase ? (d) => this._idToPoint.get(d.id) : null, this);
        }
        else {
            if (overlap !== false) {
                labels = this._overlapping(labels);
            }
        }
        if (isFunction(this.attribute.onAfterOverlapping)) {
            this.attribute.onAfterOverlapping(labels, this.getRelatedGraphic.bind(this), this._isCollectionBase ? (d) => this._idToPoint.get(d.id) : null, this);
        }
        if (labels && labels.length) {
            labels.forEach(label => {
                this._bindEvent(label);
                this._setStatesOfText(label);
            });
        }
        if (smartInvert !== false) {
            this._smartInvert(labels);
        }
        this._renderLabels(labels);
        if (this._enableAnimation !== false) {
            this._baseMarks.forEach((mark, index) => {
                mark.initAttributes(markAttributeList[index]);
            });
        }
    }
    _bindEvent(target) {
        if (this.attribute.disableTriggerEvent) {
            return;
        }
        if (!target) {
            return;
        }
        const { hover, select } = this.attribute;
        if (hover) {
            target.addEventListener('pointermove', this._onHover);
            target.addEventListener('pointerout', this._onUnHover);
        }
        if (select) {
            target.addEventListener('pointerdown', this._onClick);
        }
    }
    _setStatesOfText(target) {
        if (!target) {
            return;
        }
        const state = this.attribute.state;
        if (!state || isEmpty(state)) {
            return;
        }
        target.states = state;
    }
    _setStatesOfLabelLine(target) {
        if (!target) {
            return;
        }
        const state = this.attribute.labelLineState;
        if (!state || isEmpty(state)) {
            return;
        }
        target.states = state;
    }
    _createLabelText(attributes) {
        var _a, _b;
        const textAttrs = Object.assign(Object.assign({}, (_b = (_a = this.stage) === null || _a === void 0 ? void 0 : _a.getTheme()) === null || _b === void 0 ? void 0 : _b.text), attributes);
        return createTextGraphicByType(textAttrs, 'textType');
    }
    _prepare() {
        var _a, _b;
        const currentBaseMarks = [];
        let baseMarks;
        if (isFunction(this.attribute.getBaseMarks)) {
            baseMarks = this.attribute.getBaseMarks();
        }
        else {
            baseMarks = getMarksByName(this.getRootNode(), this.attribute.baseMarkGroupName);
        }
        baseMarks.forEach(mark => {
            if (mark.releaseStatus !== 'willRelease') {
                currentBaseMarks.push(mark);
            }
        });
        (_a = this._idToGraphic) === null || _a === void 0 ? void 0 : _a.clear();
        (_b = this._idToPoint) === null || _b === void 0 ? void 0 : _b.clear();
        this._baseMarks = currentBaseMarks;
        this._isCollectionBase = this.attribute.type === 'line-data';
        if (!currentBaseMarks || currentBaseMarks.length === 0) {
            return;
        }
        const { data } = this.attribute;
        if (!data || data.length === 0) {
            return;
        }
        if (!this._idToGraphic) {
            this._idToGraphic = new Map();
        }
        if (this._isCollectionBase) {
            if (!this._idToPoint) {
                this._idToPoint = new Map();
            }
            let cur = 0;
            for (let i = 0; i < currentBaseMarks.length; i++) {
                const baseMark = currentBaseMarks[i];
                const points = getPointsOfLineArea(baseMark);
                if (points && points.length) {
                    for (let j = 0; j < points.length; j++) {
                        const textData = data[cur];
                        if (textData && points[j]) {
                            if (!isValid(textData.id)) {
                                textData.id = `vrender-component-${this.name}-${cur}`;
                            }
                            this._idToPoint.set(textData.id, points[j]);
                            this._idToGraphic.set(textData.id, baseMark);
                        }
                        cur++;
                    }
                }
            }
        }
        else {
            for (let i = 0; i < currentBaseMarks.length; i++) {
                const textData = data[i];
                const baseMark = currentBaseMarks[i];
                if (textData && baseMark) {
                    if (!isValid(textData.id)) {
                        textData.id = `vrender-component-${this.name}-${i}`;
                    }
                    this._idToGraphic.set(textData.id, baseMark);
                }
            }
        }
        this._prepareAnimate(DefaultLabelAnimation);
    }
    getRelatedGraphic(item) {
        return this._idToGraphic.get(item.id);
    }
    _initText(data = []) {
        const { textStyle = {} } = this.attribute;
        const labels = [];
        for (let i = 0; i < data.length; i++) {
            const textData = data[i];
            const baseMark = this.getRelatedGraphic(textData);
            if (!baseMark) {
                continue;
            }
            const graphicAttribute = baseMark.getAttributes(true);
            const labelAttribute = Object.assign(Object.assign({ fill: this._isCollectionBase
                    ? isArray(graphicAttribute.stroke)
                        ? graphicAttribute.stroke.find(entry => !!entry && entry !== true)
                        : graphicAttribute.stroke
                    : graphicAttribute.fill }, textStyle), textData);
            const text = this._createLabelText(labelAttribute);
            labels.push(text);
        }
        return labels;
    }
    _layout(texts) {
        const { position, offset } = this.attribute;
        for (let i = 0; i < texts.length; i++) {
            const text = texts[i];
            if (!text) {
                return;
            }
            const textData = text.attribute;
            const baseMark = this.getRelatedGraphic(textData);
            if (!baseMark) {
                continue;
            }
            text.attachedThemeGraphic = this;
            const textBounds = this.getGraphicBounds(text);
            text.attachedThemeGraphic = null;
            const actualPosition = isFunction(position) ? position(textData) : position;
            const graphicBounds = this._isCollectionBase
                ? this.getGraphicBounds(null, this._idToPoint.get(textData.id), actualPosition)
                : this.getGraphicBounds(baseMark, { x: textData.x, y: textData.y }, actualPosition);
            const textLocation = this.labeling(textBounds, graphicBounds, actualPosition, offset);
            if (textLocation) {
                text.setAttributes(textLocation);
            }
        }
        return texts;
    }
    _overlapping(labels) {
        var _a, _b, _c;
        if (labels.length === 0) {
            return [];
        }
        const option = (isObject(this.attribute.overlap) ? this.attribute.overlap : {});
        const baseMarkGroup = this.getBaseMarkGroup();
        const size = (_a = option.size) !== null && _a !== void 0 ? _a : {
            width: (_b = baseMarkGroup === null || baseMarkGroup === void 0 ? void 0 : baseMarkGroup.AABBBounds.width()) !== null && _b !== void 0 ? _b : 0,
            height: (_c = baseMarkGroup === null || baseMarkGroup === void 0 ? void 0 : baseMarkGroup.AABBBounds.height()) !== null && _c !== void 0 ? _c : 0
        };
        if (size.width === 0 || size.height === 0) {
            return labels;
        }
        const { strategy, priority } = option;
        const bmpTool = this._bmpTool || bitmapTool(size.width, size.height);
        const bitmap = this._bitmap || bmpTool.bitmap();
        if (priority) {
            labels = labels.sort((a, b) => priority(b.attribute.data) - priority(a.attribute.data));
        }
        if ((strategy === null || strategy === void 0 ? void 0 : strategy.type) === 'shiftY') {
            return this._overlapGlobal(labels, option, bmpTool, bitmap);
        }
        return this._overlapByStrategy(labels, option, bmpTool, bitmap);
    }
    _overlapGlobal(labels, option, bmpTool, bitmap) {
        let result = labels.filter(label => label.attribute.visible &&
            label.attribute.opacity !== 0 &&
            this.isMarkInsideRect(this.getRelatedGraphic(label.attribute), bmpTool));
        const { clampForce = true, hideOnHit = true, hideOnOverflow = false, overlapPadding, strategy } = option;
        if (clampForce || hideOnOverflow) {
            for (let i = 0; i < result.length; i++) {
                const text = labels[i];
                const { dx = 0, dy = 0 } = clampText(text, bmpTool.width, bmpTool.height, bmpTool.padding);
                if (dx !== 0 || dy !== 0) {
                    if (hideOnOverflow) {
                        text.setAttributes({ visible: false });
                    }
                    else {
                        text.setAttributes({ x: text.attribute.x + dx, y: text.attribute.y + dy });
                        text._isClamped = true;
                    }
                }
            }
        }
        result = shiftY(result, Object.assign(Object.assign({ maxY: bmpTool.height }, strategy), { labelling: (text) => {
                const baseMark = this.getRelatedGraphic(text.attribute);
                const graphicBound = this._isCollectionBase
                    ? this.getGraphicBounds(null, this._idToPoint.get(text.attribute.id))
                    : this.getGraphicBounds(baseMark, text);
                return this.labeling(text.AABBBounds, graphicBound, 'bottom', this.attribute.offset);
            } }));
        for (let i = 0; i < result.length; i++) {
            const text = result[i];
            const bounds = text.AABBBounds;
            const range = boundToRange(bmpTool, bounds, true);
            if (canPlace(bmpTool, bitmap, bounds, clampForce, overlapPadding)) {
                bitmap.setRange(range);
            }
            else {
                if (hideOnOverflow) {
                    if (this._processHideOnOverflow(text, bmpTool)) {
                        continue;
                    }
                }
                else if (clampForce) {
                    if (this._processClampForce(text, bmpTool, bitmap, overlapPadding)) {
                        continue;
                    }
                }
                if (hideOnHit) {
                    text.setAttributes({ visible: false });
                }
                else {
                    bitmap.setRange(range);
                }
            }
        }
        return result;
    }
    _processHideOnOverflow(text, bmpTool) {
        const { dy: dy = 0, dx: dx = 0 } = clampText(text, bmpTool.width, bmpTool.height, bmpTool.padding);
        if (0 !== dx || 0 !== dy) {
            text.setAttributes({
                visible: false
            });
            return false;
        }
        return true;
    }
    _processClampForce(text, bmpTool, bitmap, overlapPadding = 0) {
        const { dy = 0, dx = 0 } = clampText(text, bmpTool.width, bmpTool.height, bmpTool.padding);
        if (dx === 0 && dy === 0) {
            if (canPlace(bmpTool, bitmap, text.AABBBounds, false, overlapPadding)) {
                bitmap.setRange(boundToRange(bmpTool, text.AABBBounds, true));
                return true;
            }
        }
        else if (canPlace(bmpTool, bitmap, {
            x1: text.AABBBounds.x1 + dx,
            x2: text.AABBBounds.x2 + dx,
            y1: text.AABBBounds.y1 + dy,
            y2: text.AABBBounds.y2 + dy
        })) {
            text.setAttributes({ x: text.attribute.x + dx, y: text.attribute.y + dy });
            bitmap.setRange(boundToRange(bmpTool, text.AABBBounds, true));
            return true;
        }
        return false;
    }
    _overlapByStrategy(labels, option, bmpTool, bitmap) {
        var _a;
        const { avoidBaseMark, strategy = [], hideOnHit = true, clampForce = true, avoidMarks = [], overlapPadding, hideOnOverflow = false } = option;
        const result = [];
        const checkBounds = strategy.some(s => s.type === 'bound');
        if (avoidBaseMark) {
            (_a = this._baseMarks) === null || _a === void 0 ? void 0 : _a.forEach(mark => {
                mark.AABBBounds && bitmap.setRange(boundToRange(bmpTool, mark.AABBBounds, true));
            });
        }
        if (avoidMarks.length > 0) {
            avoidMarks.forEach(avoid => {
                if (isString(avoid)) {
                    getNoneGroupMarksByName(this.getRootNode(), avoid).forEach(avoidMark => {
                        avoidMark.AABBBounds && bitmap.setRange(boundToRange(bmpTool, avoidMark.AABBBounds, true));
                    });
                }
                else if (avoid.AABBBounds) {
                    bitmap.setRange(boundToRange(bmpTool, avoid.AABBBounds, true));
                }
            });
        }
        for (let i = 0; i < labels.length; i++) {
            if (labels[i].attribute.visible === false) {
                continue;
            }
            const text = labels[i];
            const baseMark = this.getRelatedGraphic(text.attribute);
            text.update();
            if (!this.isMarkInsideRect(baseMark, bmpTool)) {
                continue;
            }
            if (canPlace(bmpTool, bitmap, text.AABBBounds, clampForce, overlapPadding)) {
                if (!checkBounds) {
                    bitmap.setRange(boundToRange(bmpTool, text.AABBBounds, true));
                    result.push(text);
                    continue;
                }
                if (checkBounds &&
                    baseMark &&
                    baseMark.AABBBounds &&
                    this._canPlaceInside(text.AABBBounds, baseMark.AABBBounds)) {
                    bitmap.setRange(boundToRange(bmpTool, text.AABBBounds, true));
                    result.push(text);
                    continue;
                }
            }
            let hasPlace = false;
            for (let j = 0; j < strategy.length; j++) {
                hasPlace = place(bmpTool, bitmap, strategy[j], this.attribute, text, this._isCollectionBase
                    ? this.getGraphicBounds(null, this._idToPoint.get(labels[i].attribute.id))
                    : this.getGraphicBounds(baseMark, labels[i].attribute), this.labeling);
                if (hasPlace !== false) {
                    text.setAttributes({ x: hasPlace.x, y: hasPlace.y });
                    if (!(hideOnOverflow && !this._processHideOnOverflow(text, bmpTool))) {
                        result.push(text);
                        break;
                    }
                }
            }
            if (!hasPlace) {
                if (hideOnOverflow) {
                    if (!this._processHideOnOverflow(text, bmpTool)) {
                        continue;
                    }
                }
                if (clampForce) {
                    if (this._processClampForce(text, bmpTool, bitmap, overlapPadding)) {
                        result.push(text);
                        continue;
                    }
                }
            }
            !hasPlace && !hideOnHit && result.push(text);
        }
        return result;
    }
    isMarkInsideRect(baseMark, bmpTool) {
        const { left, right, top, bottom } = bmpTool.padding;
        const rect = { x1: -left, x2: bmpTool.width + right, y1: -top, y2: bmpTool.height + bottom };
        const bounds = baseMark.AABBBounds;
        if (bounds.width() !== 0 && bounds.height() !== 0) {
            return isRectIntersect(baseMark.AABBBounds, rect, true);
        }
        const { attribute } = baseMark;
        if (baseMark.type === 'rect') {
            const { x, x1, y, y1 } = attribute;
            return pointInRect({ x: x !== null && x !== void 0 ? x : x1, y: y !== null && y !== void 0 ? y : y1 }, rect, true);
        }
        else if ('x' in attribute && 'y' in attribute) {
            return pointInRect({ x: attribute.x, y: attribute.y }, rect, true);
        }
        return false;
    }
    getBaseMarkGroup() {
        const { baseMarkGroupName } = this.attribute;
        if (!baseMarkGroupName) {
            return;
        }
        return this.getRootNode().find(node => node.name === baseMarkGroupName, true);
    }
    getGraphicBounds(graphic, point = {}, position) {
        var _a;
        if (graphic) {
            if (graphic.attribute.visible !== false) {
                if ((_a = graphic.context) === null || _a === void 0 ? void 0 : _a.animationState) {
                    const clonedGraphic = graphic.clone();
                    Object.assign(clonedGraphic.attribute, graphic.getAttributes(true));
                    return clonedGraphic.AABBBounds;
                }
                return graphic.AABBBounds;
            }
            const { x, y } = graphic.attribute;
            return { x1: x, x2: x, y1: y, y2: y };
        }
        if (point && position && position === 'inside-middle') {
            const { x, y, x1 = x, y1 = y } = point;
            return {
                x1: (x + x1) / 2,
                x2: (x + x1) / 2,
                y1: (y + y1) / 2,
                y2: (y + y1) / 2
            };
        }
        const { x, y } = point;
        return { x1: x, x2: x, y1: y, y2: y };
    }
    _renderLabels(labels) {
        var _a;
        const { syncState } = this.attribute;
        const currentTextMap = new Map();
        const prevTextMap = this._graphicToText || new Map();
        const texts = [];
        const labelLines = [];
        const { visible: showLabelLine } = (_a = this.attribute.line) !== null && _a !== void 0 ? _a : {};
        labels &&
            labels.forEach((text, index) => {
                var _a;
                const relatedGraphic = this.getRelatedGraphic(text.attribute);
                const textKey = this._isCollectionBase ? text.attribute.id : relatedGraphic;
                const state = (prevTextMap === null || prevTextMap === void 0 ? void 0 : prevTextMap.get(textKey)) ? 'update' : 'enter';
                let labelLine;
                if (showLabelLine) {
                    labelLine = this._createLabelLine(text, relatedGraphic);
                }
                const currentLabel = labelLine ? { text, labelLine } : { text };
                if (syncState) {
                    this.updateStatesOfLabels([currentLabel], (_a = relatedGraphic.currentStates) !== null && _a !== void 0 ? _a : []);
                }
                if (state === 'enter') {
                    texts.push(text);
                    currentTextMap.set(textKey, currentLabel);
                    this._addLabel(currentLabel, texts, labelLines, index);
                }
                else if (state === 'update') {
                    const prevLabel = prevTextMap.get(textKey);
                    prevTextMap.delete(textKey);
                    currentTextMap.set(textKey, prevLabel);
                    this._updateLabel(prevLabel, currentLabel);
                }
            });
        this._removeLabel(prevTextMap);
        this._graphicToText = currentTextMap;
    }
    runEnterAnimation(text, labelLine) {
        if (this._enableAnimation === false || !this._animationConfig.enter) {
            return;
        }
        const relatedGraphic = this.getRelatedGraphic(text.attribute);
        const { enter } = this._animationConfig;
        [text, labelLine].filter(Boolean).forEach(item => item.applyAnimationState(['enter'], [
            {
                name: 'enter',
                animation: Object.assign(Object.assign({}, enter), { type: 'labelEnter', selfOnly: true, customParameters: {
                        relatedGraphic,
                        relatedGraphics: this._idToGraphic,
                        config: Object.assign(Object.assign({}, enter), { type: item === text ? enter.type : 'fadeIn' })
                    } })
            }
        ]));
    }
    _runUpdateAnimation(prevLabel, currentLabel) {
        const { text: prevText, labelLine: prevLabelLine } = prevLabel;
        const { text: curText, labelLine: curLabelLine } = currentLabel;
        prevText.applyAnimationState(['update'], [
            {
                name: 'update',
                animation: {
                    type: 'labelUpdate',
                    customParameters: Object.assign(Object.assign({}, this._animationConfig.update), { prevText,
                        curText,
                        prevLabelLine,
                        curLabelLine })
                }
            }
        ]);
    }
    _syncStateWithRelatedGraphic(relatedGraphic) {
        if (this.attribute.syncState && relatedGraphic) {
            relatedGraphic.on('afterStateUpdate', this._handleRelatedGraphicSetState);
        }
    }
    _addLabel(label, texts, labelLines, index) {
        const { text, labelLine } = label;
        const relatedGraphic = this.getRelatedGraphic(text.attribute);
        this._syncStateWithRelatedGraphic(relatedGraphic);
        if (text) {
            this.add(text);
        }
        if (labelLine) {
            this.add(labelLine);
        }
        this.runEnterAnimation(text, labelLine);
    }
    _updateLabel(prevLabel, currentLabel) {
        const { text: prevText, labelLine: prevLabelLine } = prevLabel;
        const { text: curText, labelLine: curLabelLine } = currentLabel;
        if (this._enableAnimation === false || this._animationConfig.update === false) {
            prevLabel.text.setAttributes(curText.attribute);
            if (prevLabelLine && curLabelLine) {
                prevLabel.labelLine.setAttributes(curLabelLine.attribute);
            }
        }
        else {
            this._runUpdateAnimation(prevLabel, currentLabel);
        }
    }
    _removeLabel(textMap) {
        const removeLabelAndLine = (label) => {
            this.removeChild(label.text);
            if (label.labelLine) {
                this.removeChild(label.labelLine);
            }
        };
        if (this._enableAnimation !== false && this._animationConfig.exit !== false) {
            textMap.forEach(label => {
                var _a;
                label.text.applyAnimationState(['exit'], [
                    {
                        name: 'exit',
                        animation: Object.assign(Object.assign({}, this._animationConfig.exit), { type: 'fadeOut' })
                    }
                ], () => {
                    removeLabelAndLine(label);
                });
                (_a = label.labelLine) === null || _a === void 0 ? void 0 : _a.applyAnimationState(['exit'], [
                    {
                        name: 'exit',
                        animation: Object.assign(Object.assign({}, this._animationConfig.exit), { type: 'fadeOut' })
                    }
                ], () => {
                });
            });
        }
        else {
            textMap.forEach(label => {
                removeLabelAndLine(label);
            });
        }
    }
    updateStatesOfLabels(labels, currentStates) {
        labels.forEach(label => {
            if (label) {
                if (label.text) {
                    label.text.useStates(currentStates);
                }
                if (label.labelLine) {
                    label.labelLine.useStates(currentStates);
                }
            }
        });
    }
    _smartInvert(labels) {
        var _a, _b, _c, _d, _e, _f, _g;
        const option = (isObject(this.attribute.smartInvert) ? this.attribute.smartInvert : {});
        const { textType, contrastRatiosThreshold, alternativeColors, mode, interactInvertType } = option;
        const fillStrategy = (_a = option.fillStrategy) !== null && _a !== void 0 ? _a : 'invertBase';
        const strokeStrategy = (_b = option.strokeStrategy) !== null && _b !== void 0 ? _b : 'base';
        const brightColor = (_c = option.brightColor) !== null && _c !== void 0 ? _c : '#ffffff';
        const darkColor = (_d = option.darkColor) !== null && _d !== void 0 ? _d : '#000000';
        const outsideEnable = (_e = option.outsideEnable) !== null && _e !== void 0 ? _e : false;
        if (fillStrategy === 'null' && strokeStrategy === 'null') {
            return;
        }
        for (let i = 0; i < labels.length; i++) {
            const label = labels[i];
            if (!label) {
                continue;
            }
            const baseMark = this.getRelatedGraphic(label.attribute);
            let backgroundColor = baseMark.getAttributes(true).fill;
            let foregroundColor = label.attribute.fill;
            if (isObject(backgroundColor) && backgroundColor.gradient) {
                const firstStopColor = (_g = (_f = backgroundColor.stops) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.color;
                if (firstStopColor) {
                    backgroundColor = firstStopColor;
                    foregroundColor = firstStopColor;
                }
            }
            const invertColor = labelSmartInvert(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode);
            const similarColor = contrastAccessibilityChecker(invertColor, brightColor) ? brightColor : darkColor;
            const isInside = this._canPlaceInside(label.AABBBounds, baseMark.AABBBounds);
            const isIntersect = !isInside && label.AABBBounds && baseMark.AABBBounds && baseMark.AABBBounds.intersects(label.AABBBounds);
            if (isInside || outsideEnable || (isIntersect && interactInvertType === 'inside')) {
                const fill = smartInvertStrategy(fillStrategy, backgroundColor, invertColor, similarColor);
                fill && label.setAttributes({ fill });
                if (label.attribute.lineWidth === 0 || label.attribute.strokeOpacity === 0) {
                    continue;
                }
                const stroke = smartInvertStrategy(strokeStrategy, backgroundColor, invertColor, similarColor);
                stroke && label.setAttributes({ stroke });
            }
            else if (isIntersect && interactInvertType !== 'none') {
                if (label.attribute.lineWidth === 0 || label.attribute.strokeOpacity === 0) {
                    continue;
                }
                if (label.attribute.stroke) {
                    label.setAttributes({
                        fill: labelSmartInvert(label.attribute.fill, label.attribute.stroke, textType, contrastRatiosThreshold, alternativeColors, mode)
                    });
                    continue;
                }
                const fill = smartInvertStrategy(fillStrategy, backgroundColor, invertColor, similarColor);
                fill && label.setAttributes({ fill });
                const stroke = smartInvertStrategy(strokeStrategy, backgroundColor, invertColor, similarColor);
                stroke && label.setAttributes({ stroke });
            }
        }
    }
    _canPlaceInside(textBound, shapeBound) {
        if (!textBound || !shapeBound) {
            return false;
        }
        return shapeBound.encloses(textBound);
    }
    setLocation(point) {
        this.translateTo(point.x, point.y);
    }
    disableAnimation() {
        this._enableAnimation = false;
    }
    enableAnimation() {
        this._enableAnimation = true;
    }
}
LabelBase.defaultAttributes = {
    textStyle: {
        fontSize: 12,
        textAlign: 'center',
        textBaseline: 'middle',
        boundsPadding: [-2, -1, -2, -1]
    },
    offset: 0,
    pickable: false
};

const labelComponentMap = {};
const registerLabelComponent = (type, LabelClass) => {
    labelComponentMap[type] = LabelClass;
};
const getLabelComponent = (type) => {
    return labelComponentMap[type];
};

class SymbolLabel extends LabelBase {
    constructor(attributes, options) {
        const { data } = attributes, restAttributes = __rest(attributes, ["data"]);
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : Object.assign({ data }, merge({}, SymbolLabel.defaultAttributes, restAttributes)));
        this.name = 'symbol-label';
    }
    labeling(textBounds, graphicBounds, position = 'top', offset = 0) {
        return labelingPoint(textBounds, graphicBounds, position, offset);
    }
}
SymbolLabel.defaultAttributes = {
    textStyle: {
        fill: '#000'
    },
    position: 'top',
    offset: 5
};
const registerSymbolDataLabel = () => {
    registerLabelComponent('symbol', SymbolLabel);
    registerLabelComponent('line-data', SymbolLabel);
};

class RectLabel extends LabelBase {
    constructor(attributes, options) {
        const { data } = attributes, restAttributes = __rest(attributes, ["data"]);
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : Object.assign({ data }, merge({}, RectLabel.defaultAttributes, restAttributes)));
    }
    labeling(textBounds, graphicBounds, position = 'top', offset = 0) {
        if (!textBounds || !graphicBounds) {
            return;
        }
        const { x1, y1, x2, y2 } = textBounds;
        const width = Math.abs(x2 - x1);
        const height = Math.abs(y2 - y1);
        const { x: anchorX, y: anchorY } = calculateAnchorOfBounds(graphicBounds, position);
        let vx = 0;
        let vy = 0;
        const isInside = position.includes('inside');
        if (position.includes('top')) {
            vy = isInside ? 1 : -1;
        }
        else if (position.includes('bottom')) {
            vy = isInside ? -1 : 1;
        }
        else if (position.includes('left')) {
            vx = isInside ? 1 : -1;
        }
        else if (position.includes('right')) {
            vx = isInside ? -1 : 1;
        }
        switch (position) {
            case 'top-right':
            case 'bottom-right':
                vx = -1;
                break;
            case 'top-left':
            case 'bottom-left':
                vx = 1;
                break;
        }
        const x = anchorX + vx * offset + (vx * width) / 2;
        const y = anchorY + vy * offset + (vy * height) / 2;
        return { x, y };
    }
}
RectLabel.tag = 'rect-label';
RectLabel.defaultAttributes = {
    textStyle: {
        fill: '#000'
    },
    position: 'top',
    offset: 5
};
const registerRectDataLabel = () => {
    registerLabelComponent('rect', RectLabel);
};

class LineLabel extends LabelBase {
    constructor(attributes, options) {
        const { data } = attributes, restAttributes = __rest(attributes, ["data"]);
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : Object.assign({ data }, merge({}, LineLabel.defaultAttributes, restAttributes)));
        this.name = 'line-label';
    }
    getGraphicBounds(graphic, point = {}, position = 'end') {
        if (!graphic || (graphic.type !== 'line' && graphic.type !== 'area')) {
            return super.getGraphicBounds(graphic, point);
        }
        let points = graphic.attribute.points;
        const segments = graphic.attribute.segments;
        if (!points && segments && segments.length) {
            points = segments.reduce((res, seg) => {
                var _a;
                return res.concat((_a = seg.points) !== null && _a !== void 0 ? _a : []);
            }, []);
        }
        if (!points || points.length === 0) {
            points = [point];
        }
        const index = position === 'start' ? 0 : points.length - 1;
        if (!points[index]) {
            return;
        }
        return {
            x1: points[index].x,
            x2: points[index].x,
            y1: points[index].y,
            y2: points[index].y
        };
    }
    labeling(textBounds, graphicBounds, position = 'end', offset = 0) {
        return labelingLineOrArea(textBounds, graphicBounds, position, offset);
    }
}
LineLabel.defaultAttributes = {
    textStyle: {
        fill: '#000'
    },
    position: 'end',
    offset: 6
};
const registerLineDataLabel = () => {
    registerLabelComponent('line', LineLabel);
    registerLabelComponent('area', LineLabel);
};

class ArcInfo {
    constructor(refDatum, center, outerCenter, quadrant, radian, middleAngle, innerRadius, outerRadius, circleCenter) {
        this.refDatum = refDatum;
        this.center = center;
        this.outerCenter = outerCenter;
        this.quadrant = quadrant;
        this.radian = radian;
        this.middleAngle = middleAngle;
        this.innerRadius = innerRadius;
        this.outerRadius = outerRadius;
        this.circleCenter = circleCenter;
        this.labelVisible = true;
    }
    getLabelBounds() {
        if (!this.labelPosition || !this.labelSize) {
            return { x1: 0, x2: 0, y1: 0, y2: 0 };
        }
        return {
            x1: this.labelPosition.x - this.labelSize.width / 2,
            y1: this.labelPosition.y - this.labelSize.height / 2,
            x2: this.labelPosition.x + this.labelSize.width / 2,
            y2: this.labelPosition.y + this.labelSize.height / 2
        };
    }
}
class ArcLabel extends LabelBase {
    constructor(attributes, options) {
        const { data } = attributes, restAttributes = __rest(attributes, ["data"]);
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : Object.assign({ data }, merge({}, ArcLabel.defaultAttributes, restAttributes)));
        this.name = 'arc-label';
        this._ellipsisWidth = 0;
        this._arcLeft = new Map();
        this._arcRight = new Map();
        this._line2MinLength = 0;
        this._alignOffset = 0;
    }
    _overlapping(labels) {
        if (['inside', 'inside-center'].includes(this.attribute.position)) {
            return super._overlapping(labels);
        }
        return labels;
    }
    labeling(textBounds, graphicBounds, position = 'outside', offset = 0) {
        if (!textBounds || !graphicBounds) {
            return;
        }
        return { x: 0, y: 0 };
    }
    _layout(texts) {
        var _a, _b, _c;
        if (!texts || !texts.length) {
            return;
        }
        const labels = super._layout(texts);
        const textBoundsArray = labels.map(label => {
            return this.getGraphicBounds(label);
        });
        const ellipsisLabelAttribute = Object.assign(Object.assign({}, this.attribute.textStyle), { text: '…' });
        let ellipsisWidth = Infinity;
        if (ellipsisLabelAttribute.ellipsis !== false) {
            const ellipsisText = this._createLabelText(ellipsisLabelAttribute);
            const ellipsisTextBounds = this.getGraphicBounds(ellipsisText);
            ellipsisWidth = ellipsisTextBounds.x2 - ellipsisTextBounds.x1;
        }
        const data = labels.map(label => label.attribute);
        const currentMarks = Array.from(this._idToGraphic.values());
        this._line2MinLength = isFunction(this.attribute.line.line2MinLength)
            ? this.attribute.line.line2MinLength(texts, currentMarks, this.attribute)
            : this.attribute.line.line2MinLength;
        this._alignOffset =
            (_a = (isFunction(this.attribute.layout.alignOffset)
                ? this.attribute.layout.alignOffset(texts, currentMarks, this.attribute)
                : this.attribute.layout.alignOffset)) !== null && _a !== void 0 ? _a : 0;
        const arcs = this.layoutArcLabels(this.attribute.position, this.attribute, currentMarks, data, textBoundsArray, ellipsisWidth);
        for (let i = 0; i < data.length; i++) {
            const textData = data[i];
            const basedArc = arcs.find(arc => { var _a; return ((_a = arc.refDatum) === null || _a === void 0 ? void 0 : _a.id) === textData.id; });
            if (basedArc) {
                const labelAttribute = {
                    visible: basedArc.labelVisible,
                    x: basedArc.labelPosition.x,
                    y: basedArc.labelPosition.y,
                    angle: basedArc.angle,
                    points: basedArc.pointA && basedArc.pointB && basedArc.pointC
                        ? [basedArc.pointA, basedArc.pointB, basedArc.pointC]
                        : undefined,
                    line: basedArc.labelLine
                };
                if (labels[i].type === 'richtext') {
                    labelAttribute.width =
                        (_b = basedArc.labelLimit) !== null && _b !== void 0 ? _b : labels[i].attribute.width;
                }
                else {
                    labelAttribute.maxLineWidth =
                        (_c = basedArc.labelLimit) !== null && _c !== void 0 ? _c : labels[i].attribute.maxLineWidth;
                }
                if (basedArc.refArc && basedArc.refArc.type === 'arc3d') {
                    labelAttribute.anchor3d = [
                        basedArc.circleCenter.x - labelAttribute.x,
                        basedArc.circleCenter.y - labelAttribute.y
                    ];
                    labelAttribute.beta = basedArc.refArc.attribute.beta;
                }
                labels[i].setAttributes(labelAttribute);
            }
        }
        return labels;
    }
    layoutArcLabels(position, attribute, currentMarks, data, textBoundsArray, ellipsisWidth) {
        this._arcLeft.clear();
        this._arcRight.clear();
        this._ellipsisWidth = ellipsisWidth;
        let maxRadius = 0;
        currentMarks.forEach(currentMarks => {
            if (currentMarks.attribute.outerRadius > maxRadius) {
                maxRadius = currentMarks.attribute.outerRadius;
            }
        });
        data.forEach((d, index) => {
            var _a, _b;
            const currentMark = this._idToGraphic.get(d.id);
            const graphicAttribute = currentMark.getAttributes(true);
            const center = { x: (_a = graphicAttribute === null || graphicAttribute === void 0 ? void 0 : graphicAttribute.x) !== null && _a !== void 0 ? _a : 0, y: (_b = graphicAttribute === null || graphicAttribute === void 0 ? void 0 : graphicAttribute.y) !== null && _b !== void 0 ? _b : 0 };
            if (!isNil(data[index]) && !isNil(textBoundsArray[index])) {
                const item = data[index] ? data[index] : null;
                const textBounds = textBoundsArray[index] ? textBoundsArray[index] : { x1: 0, x2: 0, y1: 0, y2: 0 };
                const arcMiddleAngle = (graphicAttribute.startAngle + graphicAttribute.endAngle) / 2;
                const intervalAngle = graphicAttribute.endAngle - graphicAttribute.startAngle;
                const arcQuadrant = computeQuadrant(graphicAttribute.endAngle - intervalAngle / 2);
                const arcMiddle = polarToCartesian(center, graphicAttribute.outerRadius, arcMiddleAngle);
                const outerArcMiddle = polarToCartesian(center, maxRadius + attribute.line.line1MinLength, arcMiddleAngle);
                const arc = new ArcInfo(item, arcMiddle, outerArcMiddle, arcQuadrant, intervalAngle, arcMiddleAngle, graphicAttribute.innerRadius, graphicAttribute.outerRadius, center);
                arc.refArc = currentMark;
                arc.pointA = polarToCartesian(center, this.computeDatumRadius(center.x * 2, center.y * 2, graphicAttribute.outerRadius), arc.middleAngle);
                arc.labelSize = {
                    width: textBounds.x2 - textBounds.x1,
                    height: textBounds.y2 - textBounds.y1
                };
                if (isQuadrantRight(arc.quadrant)) {
                    this._arcRight.set(arc.refDatum, arc);
                }
                else if (isQuadrantLeft(arc.quadrant)) {
                    this._arcLeft.set(arc.refDatum, arc);
                }
            }
        });
        const leftArcs = Array.from(this._arcLeft.values());
        const rightArcs = Array.from(this._arcRight.values());
        const arcs = [];
        switch (position) {
            case 'inside':
            case 'inside-inner':
            case 'inside-outer':
            case 'inside-center':
                arcs.push(...this._layoutInsideLabels(rightArcs, attribute, currentMarks));
                arcs.push(...this._layoutInsideLabels(leftArcs, attribute, currentMarks));
                break;
            case 'outside':
            default:
                arcs.push(...this._layoutOutsideLabels(rightArcs, attribute, currentMarks));
                arcs.push(...this._layoutOutsideLabels(leftArcs, attribute, currentMarks));
                break;
        }
        return arcs;
    }
    _layoutInsideLabels(arcs, attribute, currentMarks) {
        var _a, _b;
        const labelConfig = attribute;
        const spaceWidth = labelConfig.spaceWidth;
        const position = (_a = labelConfig.position) !== null && _a !== void 0 ? _a : 'inside';
        const offsetRadius = (_b = labelConfig.offsetRadius) !== null && _b !== void 0 ? _b : -spaceWidth;
        arcs.forEach((arc) => {
            var _a, _b, _c;
            const { labelSize, radian } = arc;
            const innerRadius = arc.innerRadius;
            const outerRadius = arc.outerRadius;
            const minRadian = connectLineRadian(outerRadius, labelSize.height);
            let limit;
            if (radian < minRadian) {
                limit = 0;
            }
            else {
                let minRadius;
                if (radian >= Math.PI) {
                    minRadius = innerRadius;
                }
                else {
                    minRadius = Math.max(innerRadius, labelSize.height / 2 / Math.tan(radian / 2));
                }
                limit = outerRadius - minRadius - spaceWidth;
            }
            if (labelConfig.rotate !== true) {
                limit = outerRadius - spaceWidth;
            }
            const text = this._getFormatLabelText(arc.refDatum, limit);
            arc.labelText = text;
            const labelWidth = Math.min(limit, arc.labelSize.width);
            const align = this._computeAlign(arc, attribute);
            let alignOffset = 0;
            if (position === 'inside') {
                alignOffset = align === 'left' ? labelWidth : align === 'right' ? 0 : labelWidth / 2;
            }
            let labelRadius;
            if (position === 'inside-inner') {
                labelRadius = innerRadius - offsetRadius + alignOffset;
            }
            else if (position === 'inside-center') {
                labelRadius = innerRadius + (outerRadius - innerRadius) / 2;
            }
            else {
                labelRadius = outerRadius + offsetRadius - alignOffset;
            }
            arc.labelPosition = polarToCartesian(arc.circleCenter, labelRadius, arc.middleAngle);
            arc.labelLimit = labelWidth;
            if (!isGreater(labelWidth, 0)) {
                arc.labelVisible = false;
            }
            if (labelConfig.rotate !== false) {
                arc.angle = (_b = (_a = attribute.textStyle) === null || _a === void 0 ? void 0 : _a.angle) !== null && _b !== void 0 ? _b : arc.middleAngle;
                let offsetAngle = (_c = labelConfig.offsetAngle) !== null && _c !== void 0 ? _c : 0;
                if (['inside-inner', 'inside-outer'].includes(position)) {
                    offsetAngle += Math.PI / 2;
                }
                arc.angle += offsetAngle;
            }
        });
        return arcs;
    }
    _layoutOutsideLabels(arcs, attribute, currentMarks) {
        var _a, _b, _c;
        const center = { x: (_a = currentMarks[0].attribute.x) !== null && _a !== void 0 ? _a : 0, y: (_b = currentMarks[0].attribute.y) !== null && _b !== void 0 ? _b : 0 };
        const height = center.y * 2;
        const labelLayout = attribute.layout;
        const spaceWidth = attribute.spaceWidth;
        arcs.forEach(arc => {
            const direction = isQuadrantLeft(arc.quadrant) ? -1 : 1;
            arc.labelPosition = {
                x: arc.outerCenter.x + direction * (arc.labelSize.width / 2 + this._line2MinLength + spaceWidth),
                y: arc.outerCenter.y
            };
        });
        arcs.sort((a, b) => {
            return a.labelPosition.y - b.labelPosition.y;
        });
        if (attribute.coverEnable !== false || labelLayout.strategy === 'none') {
            for (const arc of arcs) {
                const { labelPosition, labelSize } = arc;
                arc.labelLimit = labelSize.width;
                arc.pointB = isQuadrantLeft(arc.quadrant)
                    ? {
                        x: labelPosition.x + labelSize.width / 2 + this._line2MinLength + spaceWidth,
                        y: labelPosition.y
                    }
                    : {
                        x: labelPosition.x - labelSize.width / 2 - this._line2MinLength - spaceWidth,
                        y: labelPosition.y
                    };
                this._computeX(arc, attribute, currentMarks);
            }
            if (attribute.coverEnable === false && labelLayout.strategy === 'none') {
                this._coverLabels(arcs);
            }
        }
        else {
            const maxLabels = height / (((_c = attribute.textStyle) === null || _c === void 0 ? void 0 : _c.fontSize) || 16);
            this._adjustY(arcs, maxLabels, attribute, currentMarks);
            const { minY, maxY } = arcs.reduce((yInfo, arc) => {
                const { y1, y2 } = arc.getLabelBounds();
                yInfo.minY = Math.max(0, Math.min(y1, yInfo.minY));
                yInfo.maxY = Math.min(height, Math.max(y2, yInfo.maxY));
                return yInfo;
            }, { minY: Infinity, maxY: -Infinity });
            const halfY = Math.max(Math.abs(height / 2 - minY), Math.abs(maxY - height / 2));
            const r = this._computeLayoutRadius(halfY, attribute, currentMarks);
            for (const arc of arcs) {
                this._computePointB(arc, r, attribute, currentMarks);
                this._computeX(arc, attribute, currentMarks);
            }
        }
        const width = center.x * 2;
        arcs.forEach(arc => {
            var _a, _b;
            if (arc.labelVisible &&
                (isLess(arc.pointB.x, this._line2MinLength + spaceWidth) ||
                    isGreater(arc.pointB.x, width - this._line2MinLength - spaceWidth))) {
                arc.labelVisible = false;
            }
            arc.angle = (_b = (_a = attribute.textStyle) === null || _a === void 0 ? void 0 : _a.angle) !== null && _b !== void 0 ? _b : 0;
            if (attribute.offsetAngle) {
                arc.angle += attribute.offsetAngle;
            }
            arc.labelLine = Object.assign(Object.assign({}, attribute.line), { visible: arc.labelVisible });
        });
        return arcs;
    }
    _computeX(arc, attribute, currentMarks) {
        var _a;
        const center = arc.circleCenter;
        const plotLayout = {
            x1: 0,
            x2: this.attribute.width,
            y1: 0,
            y2: this.attribute.height
        };
        let maxRadius = 0;
        currentMarks.forEach((currentMark) => {
            if (currentMark.getAttributes(true).outerRadius > maxRadius) {
                maxRadius = currentMark.getAttributes(true).outerRadius;
            }
        });
        const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height);
        const line1MinLength = attribute.line.line1MinLength;
        const labelLayoutAlign = (_a = attribute.layout) === null || _a === void 0 ? void 0 : _a.align;
        const spaceWidth = attribute.spaceWidth;
        const { labelPosition, quadrant, pointB } = arc;
        if (!isValidNumber(pointB.x * pointB.y)) {
            arc.pointC = { x: NaN, y: NaN };
            labelPosition.x = NaN;
            arc.labelLimit = 0;
        }
        const radius = this.computeRadius(radiusRatio, attribute.width, attribute.height);
        const flag = isQuadrantLeft(quadrant) ? -1 : 1;
        let cx = 0;
        let limit = (flag > 0 ? plotLayout.x2 - pointB.x : pointB.x - plotLayout.x1) +
            this._alignOffset -
            this._line2MinLength -
            spaceWidth;
        if (labelLayoutAlign === 'labelLine') {
            cx = (radius + line1MinLength + this._line2MinLength) * flag + center.x;
            limit = (flag > 0 ? plotLayout.x2 - cx : cx - plotLayout.x1) - spaceWidth;
        }
        const text = this._getFormatLabelText(arc.refDatum, limit);
        arc.labelText = text;
        let labelWidth = Math.min(limit, arc.labelSize.width);
        switch (labelLayoutAlign) {
            case 'labelLine':
                break;
            case 'edge':
                cx = flag > 0 ? plotLayout.x2 - labelWidth - spaceWidth : plotLayout.x1 + labelWidth + spaceWidth;
                break;
            case 'arc':
            default:
                cx = pointB.x + flag * this._line2MinLength;
                break;
        }
        labelWidth = Math.max(this._ellipsisWidth, labelWidth);
        const needAdjustLimit = labelWidth < arc.labelSize.width - 1;
        if (needAdjustLimit) {
            arc.labelLimit = labelWidth;
        }
        else {
            arc.labelLimit = null;
        }
        arc.pointC = { x: cx, y: labelPosition.y };
        const align = this._computeAlign(arc, attribute);
        const targetCenterOffset = getAlignOffset(align) * (needAdjustLimit ? labelWidth : arc.labelSize.width);
        if (labelLayoutAlign === 'edge') {
            labelPosition.x =
                (flag > 0 ? plotLayout.x2 : plotLayout.x1) - flag * targetCenterOffset + flag * this._alignOffset;
            arc.pointC.x += flag * this._alignOffset;
        }
        else {
            labelPosition.x = cx + flag * (this._alignOffset + spaceWidth + targetCenterOffset);
        }
    }
    _computeAlign(arc, attribute) {
        var _a, _b, _c, _d, _e, _f;
        const labelConfig = attribute;
        const textAlign = (_b = (_a = labelConfig.textStyle) === null || _a === void 0 ? void 0 : _a.textAlign) !== null && _b !== void 0 ? _b : (_c = labelConfig.textStyle) === null || _c === void 0 ? void 0 : _c.align;
        const layoutAlign = (_e = (_d = labelConfig.layout) === null || _d === void 0 ? void 0 : _d.textAlign) !== null && _e !== void 0 ? _e : (_f = labelConfig.layout) === null || _f === void 0 ? void 0 : _f.align;
        if (labelConfig.position !== 'inside') {
            if (isNil(textAlign) || textAlign === 'auto') {
                if (layoutAlign === 'edge') {
                    return isQuadrantLeft(arc.quadrant) ? 'left' : 'right';
                }
                return isQuadrantLeft(arc.quadrant) ? 'right' : 'left';
            }
            return textAlign;
        }
        return isNil(textAlign) || textAlign === 'auto' ? 'center' : textAlign;
    }
    _getFormatLabelText(value, limit) {
        var _a;
        return (_a = value === null || value === void 0 ? void 0 : value.text) !== null && _a !== void 0 ? _a : '';
    }
    _adjustY(arcs, maxLabels, attribute, currentMarks) {
        var _a, _b;
        const center = { x: (_a = currentMarks[0].attribute.x) !== null && _a !== void 0 ? _a : 0, y: (_b = currentMarks[0].attribute.y) !== null && _b !== void 0 ? _b : 0 };
        const plotRect = { width: center.x * 2, height: center.y * 2 };
        const labelLayout = attribute.layout;
        if (labelLayout.strategy === 'vertical') {
            let lastY = 0;
            let delta;
            const len = arcs.length;
            if (len <= 0) {
                return;
            }
            for (let i = 0; i < len; i++) {
                const { y1 } = arcs[i].getLabelBounds();
                delta = y1 - lastY;
                if (isLess(delta, 0)) {
                    const index = this._shiftY(arcs, i, len - 1, -delta);
                    this._shiftY(arcs, index, 0, delta / 2);
                }
                const { y2 } = arcs[i].getLabelBounds();
                lastY = y2;
            }
            const { y1: firstY1 } = arcs[0].getLabelBounds();
            delta = firstY1 - 0;
            if (isLess(delta, 0)) {
                this._shiftY(arcs, 0, len - 1, -delta);
            }
            for (let i = arcs.length - 1; i >= 0; i--) {
                if (arcs[i].getLabelBounds().y2 > plotRect.height) {
                    arcs[i].labelVisible = false;
                }
                else {
                    break;
                }
            }
        }
        else if (labelLayout.strategy !== 'none') {
            const priorityArcs = arcs.map((arc, i) => {
                return {
                    arc,
                    originIndex: i,
                    priorityIndex: 0
                };
            });
            priorityArcs.sort((a, b) => {
                return b.arc.radian - a.arc.radian;
            });
            priorityArcs.forEach((priorityArc, i) => {
                priorityArc.priorityIndex = i;
                priorityArc.arc.labelVisible = false;
            });
            let topLabelIndex = Infinity;
            let bottomLabelIndex = -Infinity;
            for (let i = 0; i < maxLabels && i < arcs.length; i++) {
                this._storeY(arcs);
                const arc = priorityArcs[i].arc;
                this._computeYRange(arc, attribute, currentMarks);
                arc.labelVisible = true;
                const curY = arc.labelPosition.y;
                const { lastIndex, nextIndex } = this._findNeighborIndex(arcs, priorityArcs[i]);
                const lastArc = arcs[lastIndex];
                const nextArc = arcs[nextIndex];
                if (lastIndex === -1 && nextIndex !== -1) {
                    const nextY = nextArc.labelPosition.y;
                    if (curY > nextY) {
                        arc.labelPosition.y = nextY - nextArc.labelSize.height / 2 - arc.labelSize.height / 2;
                    }
                    else {
                        this._twoWayShift(arcs, arc, nextArc, nextIndex);
                    }
                }
                else if (lastIndex !== -1 && nextIndex === -1) {
                    const lastY = lastArc.labelPosition.y;
                    if (curY < lastY) {
                        arc.labelPosition.y = lastY + lastArc.labelSize.height / 2 + arc.labelSize.height / 2;
                    }
                    else {
                        this._twoWayShift(arcs, lastArc, arc, priorityArcs[i].originIndex);
                    }
                }
                else if (lastIndex !== -1 && nextIndex !== -1) {
                    const lastY = lastArc.labelPosition.y;
                    const nextY = nextArc.labelPosition.y;
                    if (curY > nextY) {
                        arc.labelPosition.y = nextY - nextArc.labelSize.height / 2 - arc.labelSize.height / 2;
                        this._twoWayShift(arcs, lastArc, arc, priorityArcs[i].originIndex);
                    }
                    else if (curY < lastY) {
                        arc.labelPosition.y = lastY + lastArc.labelSize.height / 2 + arc.labelSize.height / 2;
                        this._twoWayShift(arcs, arc, nextArc, nextIndex);
                    }
                    else {
                        this._twoWayShift(arcs, lastArc, arc, priorityArcs[i].originIndex);
                        this._twoWayShift(arcs, arc, nextArc, nextIndex);
                    }
                }
                const nextTopIndex = Math.min(topLabelIndex, priorityArcs[i].originIndex);
                const nextBottomIndex = Math.max(bottomLabelIndex, priorityArcs[i].originIndex);
                let delta;
                delta = arcs[nextBottomIndex].getLabelBounds().y2 - plotRect.height;
                if (isGreater(delta, 0)) {
                    this._shiftY(arcs, nextBottomIndex, 0, -delta);
                }
                delta = arcs[nextTopIndex].getLabelBounds().y1 - 0;
                if (isLess(delta, 0)) {
                    this._shiftY(arcs, nextTopIndex, arcs.length - 1, -delta);
                }
                delta = arcs[nextBottomIndex].getLabelBounds().y2 - plotRect.height;
                if (isGreater(delta, 0)) {
                    arc.labelVisible = false;
                    this._restoreY(arcs);
                    break;
                }
                else if (labelLayout.tangentConstraint && !this._checkYRange(arcs)) {
                    arc.labelVisible = false;
                    this._restoreY(arcs);
                }
                else {
                    topLabelIndex = nextTopIndex;
                    bottomLabelIndex = nextBottomIndex;
                }
            }
        }
    }
    _shiftY(arcs, start, end, delta) {
        const direction = start < end ? 1 : -1;
        let index = start;
        while (index !== -1) {
            arcs[index].labelPosition.y += delta;
            const nextIndex = this._findNextVisibleIndex(arcs, index, end, direction);
            if (nextIndex >= 0 && nextIndex < arcs.length) {
                const { y1: curY1, y2: curY2 } = arcs[index].getLabelBounds();
                const { y1: nextY1, y2: nextY2 } = arcs[nextIndex].getLabelBounds();
                if ((direction > 0 && curY2 < nextY1) || (direction < 0 && curY1 > nextY2)) {
                    return index;
                }
            }
            index = nextIndex;
        }
        return end;
    }
    _findNextVisibleIndex(arcs, start, end, direction) {
        const diff = (end - start) * direction;
        for (let i = 1; i <= diff; i++) {
            const index = start + i * direction;
            if (arcs[index].labelVisible) {
                return index;
            }
        }
        return -1;
    }
    _computePointB(arc, r, attribute, currentMarks) {
        const labelConfig = attribute;
        let maxRadius = 0;
        currentMarks.forEach((currentMark) => {
            if (currentMark.getAttributes(true).outerRadius > maxRadius) {
                maxRadius = currentMark.getAttributes(true).outerRadius;
            }
        });
        const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height);
        const line1MinLength = labelConfig.line.line1MinLength;
        const labelLayout = labelConfig.layout;
        if (labelLayout.strategy === 'none') {
            arc.pointB = {
                x: arc.outerCenter.x,
                y: arc.outerCenter.y
            };
        }
        else {
            const center = arc.circleCenter;
            const radius = this.computeRadius(radiusRatio, attribute.width, attribute.height);
            const { labelPosition, quadrant } = arc;
            const outerR = Math.max(radius + line1MinLength, arc.outerRadius);
            const rd = r - outerR;
            const x = Math.sqrt(r ** 2 - Math.abs(center.y - labelPosition.y) ** 2) - rd;
            if (isValidNumber(x)) {
                arc.pointB = {
                    x: center.x + x * (isQuadrantLeft(quadrant) ? -1 : 1),
                    y: labelPosition.y
                };
            }
            else {
                arc.pointB = { x: NaN, y: NaN };
            }
        }
    }
    _storeY(arcs) {
        for (const arc of arcs) {
            if (arc.labelVisible) {
                arc.lastLabelY = arc.labelPosition.y;
            }
        }
    }
    _computeYRange(arc, attribute, currentMarks) {
        const center = arc.circleCenter;
        const plotRect = { width: center.x * 2, height: center.y * 2 };
        let maxRadius = 0;
        currentMarks.forEach((currentMark) => {
            if (currentMark.getAttributes(true).outerRadius > maxRadius) {
                maxRadius = currentMark.getAttributes(true).outerRadius;
            }
        });
        const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height);
        const line1MinLength = attribute.line.line1MinLength;
        const { width, height } = plotRect;
        const radius = this.computeRadius(radiusRatio, attribute.width, attribute.height);
        const r = this._computeLayoutRadius(height / 2, attribute, currentMarks);
        const cx = Math.abs(arc.center.x - width / 2);
        const cy = arc.center.y - height / 2;
        let a;
        let b;
        let c;
        if (isNumberClose(width / 2, cx)) {
            a = 0;
            b = 1;
            c = -cy;
        }
        else if (isNumberClose(height / 2, cy)) {
            a = 1;
            b = 0;
            c = -cx;
        }
        else {
            const k = -1 / (cy / cx);
            a = k;
            b = -1;
            c = cy - k * cx;
        }
        const points = lineCirclePoints(a, b, c, line1MinLength + radius - r, 0, r);
        if (points.length < 2) {
            return;
        }
        let min;
        let max;
        if (points[0].x > points[1].x) {
            points.reverse();
        }
        if (points[0].x < 0) {
            if (isNumberClose(points[0].y, points[1].y)) {
                if ((isGreater(arc.middleAngle, -Math.PI) && isLess(arc.middleAngle, 0)) ||
                    (isGreater(arc.middleAngle, Math.PI) && isLess(arc.middleAngle, Math.PI * 2))) {
                    min = 0;
                    max = points[1].y + height / 2;
                }
                else {
                    min = points[1].y + height / 2;
                    max = height;
                }
            }
            else if (points[0].y < points[1].y) {
                min = 0;
                max = points[1].y + height / 2;
            }
            else {
                min = points[1].y + height / 2;
                max = plotRect.height;
            }
        }
        else {
            min = Math.min(points[0].y, points[1].y) + height / 2;
            max = Math.max(points[0].y, points[1].y) + height / 2;
        }
        arc.labelYRange = [min, max];
    }
    _computeLayoutRadius(halfYLength, attribute, currentMarks) {
        const labelConfig = attribute;
        const layoutArcGap = labelConfig.layoutArcGap;
        const line1MinLength = labelConfig.line.line1MinLength;
        let maxRadius = 0;
        currentMarks.forEach((currentMark) => {
            if (currentMark.getAttributes(true).outerRadius > maxRadius) {
                maxRadius = currentMark.getAttributes(true).outerRadius;
            }
        });
        const radiusRatio = this.computeLayoutOuterRadius(maxRadius, attribute.width, attribute.height);
        const radius = this.computeRadius(radiusRatio, attribute.width, attribute.height);
        const outerR = radius + line1MinLength;
        const a = outerR - layoutArcGap;
        return Math.max((a ** 2 + halfYLength ** 2) / (2 * a), outerR);
    }
    _findNeighborIndex(arcs, priorityArc) {
        const index = priorityArc.originIndex;
        let lastIndex = -1;
        let nextIndex = -1;
        for (let i = index - 1; i >= 0; i--) {
            if (arcs[i].labelVisible) {
                lastIndex = i;
                break;
            }
        }
        for (let i = index + 1; i < arcs.length; i++) {
            if (arcs[i].labelVisible) {
                nextIndex = i;
                break;
            }
        }
        return {
            lastIndex,
            nextIndex
        };
    }
    _twoWayShift(arcs, lastArc, nextArc, nextIndex) {
        const delta = nextArc.getLabelBounds().y1 - lastArc.getLabelBounds().y2;
        if (isLess(delta, 0)) {
            const i = this._shiftY(arcs, nextIndex, arcs.length - 1, -delta);
            this._shiftY(arcs, i, 0, delta / 2);
        }
    }
    _restoreY(arcs) {
        for (const arc of arcs) {
            if (arc.labelVisible) {
                arc.labelPosition.y = arc.lastLabelY;
            }
        }
    }
    _checkYRange(arcs) {
        for (const arc of arcs) {
            const { labelYRange, labelPosition } = arc;
            if (arc.labelVisible &&
                labelYRange &&
                (isLess(labelPosition.y, labelYRange[0]) || isGreater(labelPosition.y, labelYRange[1]))) {
                return false;
            }
        }
        return true;
    }
    _coverLabels(arcs) {
        if (arcs.length <= 1) {
            return;
        }
        let lastBounds = arcs[0].getLabelBounds();
        for (let i = 1; i < arcs.length; i++) {
            const bounds = arcs[i].getLabelBounds();
            if (!checkBoundsOverlap(lastBounds, bounds)) {
                lastBounds = bounds;
            }
            else {
                arcs[i].labelVisible = false;
            }
        }
    }
    _getLabelLinePoints(text, baseMark) {
        return text.attribute.points;
    }
    _createLabelLine(text, baseMark) {
        var _a, _b, _c, _d, _e;
        const { line = {}, visible } = text.attribute;
        const lineGraphic = super._createLabelLine(text, baseMark);
        if (lineGraphic) {
            lineGraphic.setAttributes({
                visible: (_c = (_a = (line.visible && visible)) !== null && _a !== void 0 ? _a : (_b = text.attribute) === null || _b === void 0 ? void 0 : _b.visible) !== null && _c !== void 0 ? _c : true,
                lineWidth: (_e = (_d = line.style) === null || _d === void 0 ? void 0 : _d.lineWidth) !== null && _e !== void 0 ? _e : 1
            });
            if (line.smooth) {
                lineGraphic.setAttributes({
                    curveType: 'basis'
                });
            }
            if (baseMark.type === 'arc3d' && baseMark) {
                const { beta, x, y } = baseMark.getAttributes(true);
                lineGraphic.setAttributes({
                    beta,
                    anchor3d: [x, y]
                });
            }
        }
        return lineGraphic;
    }
    computeRadius(r, width, height, k) {
        return this.computeLayoutRadius(width ? width : 0, height ? height : 0) * r * (isNil(k) ? 1 : k);
    }
    computeLayoutRadius(width, height) {
        return Math.min(width / 2, height / 2);
    }
    _canPlaceInside(textBound, shapeBound) {
        return this.attribute.position === 'inside' || this.attribute.position === 'inside-center';
    }
    computeLayoutOuterRadius(r, width, height) {
        return r / (Math.min(width, height) / 2);
    }
    computeDatumRadius(width, height, outerRadius) {
        const outerRadiusRatio = this.computeLayoutOuterRadius(outerRadius, width, height);
        return this.computeLayoutRadius(width ? width : 0, height ? height : 0) * outerRadiusRatio;
    }
}
ArcLabel.defaultAttributes = {
    coverEnable: false,
    spaceWidth: 5,
    layoutArcGap: 6,
    textStyle: {
        visible: true,
        fontSize: 14,
        fontWeight: 'normal',
        fillOpacity: 1,
        boundsPadding: [-1, 0, -1, 0],
        ellipsis: true
    },
    position: 'outside',
    line: {
        visible: true,
        line1MinLength: 20,
        line2MinLength: 10
    },
    layout: {
        align: 'arc',
        strategy: 'priority',
        tangentConstraint: true
    }
};
const registerArcDataLabel = () => {
    registerLabelComponent('arc', ArcLabel);
};

class DataLabel extends AbstractComponent {
    constructor(attributes, options) {
        const { dataLabels } = attributes, restAttributes = __rest(attributes, ["dataLabels"]);
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : Object.assign({ dataLabels }, merge({}, DataLabel.defaultAttributes, restAttributes)));
        this.name = 'data-label';
    }
    render() {
        var _a;
        const { dataLabels, size } = this.attribute;
        if (!dataLabels || dataLabels.length === 0) {
            return;
        }
        const { width = 0, height = 0, padding } = size || {};
        if (!width || !height || !isValidNumber(height * width)) {
            return;
        }
        if (!this._componentMap) {
            this._componentMap = new Map();
        }
        const tool = bitmapTool(width, height, padding);
        const bitmap = tool.bitmap();
        const currentComponentMap = new Map();
        const prevComponentMap = this._componentMap;
        for (let i = 0; i < dataLabels.length; i++) {
            const dataLabel = dataLabels[i];
            const labelComponent = getLabelComponent(dataLabel.type) || LabelBase;
            if (labelComponent) {
                const { baseMarkGroupName, type } = dataLabel;
                const id = (_a = dataLabel.id) !== null && _a !== void 0 ? _a : `${baseMarkGroupName}-${type}-${i}`;
                if (dataLabel.type === 'arc') {
                    dataLabel.width = size.width;
                    dataLabel.height = size.height;
                }
                let component = this._componentMap.get(id);
                if (component) {
                    component.setBitmapTool(tool);
                    component.setBitmap(bitmap);
                    component.setAttributes(dataLabel);
                    currentComponentMap.set(id, component);
                }
                else {
                    component = new labelComponent(dataLabel);
                    component.setBitmap(bitmap);
                    component.setBitmapTool(tool);
                    this.add(component);
                    currentComponentMap.set(id, component);
                }
            }
        }
        prevComponentMap.forEach((cp, key) => {
            if (!currentComponentMap.get(key)) {
                this.removeChild(cp);
            }
        });
        this._componentMap = currentComponentMap;
    }
    setLocation(point) {
        this.translateTo(point.x, point.y);
    }
    disableAnimation() {
        this._componentMap.forEach(component => {
            component.disableAnimation();
        });
    }
    enableAnimation() {
        this._componentMap.forEach(component => {
            component.enableAnimation();
        });
    }
}
DataLabel.defaultAttributes = {
    pickable: false
};

function getArcPath(center, points, reverse, closed) {
    let path = '';
    if (!center || points.length === 0) {
        return path;
    }
    const firstPoint = points[0];
    const radius = PointService.distancePP(center, firstPoint);
    const sweepFlag = reverse ? 0 : 1;
    if (closed) {
        path += `M${center.x},${center.y - radius}A${radius},${radius},0,0,${sweepFlag},${center.x},${center.y + radius}A${radius},${radius},0,0,${sweepFlag},${center.x},${center.y - radius}Z`;
    }
    else {
        points.forEach((point, index) => {
            if (index === 0) {
                path = `M${point.x},${point.y}`;
            }
            else {
                path += `A${radius},${radius},0,0,${sweepFlag},${point.x},${point.y}`;
            }
        });
    }
    return path;
}
function getRegionPath(from, to, attribute) {
    const { type, closed } = attribute;
    const reversePoints = to.slice(0).reverse();
    let regionPath = '';
    let nextPath = '';
    if (type === 'line' && attribute.smoothLink && attribute.center) {
        const fromStart = from[0];
        const toEnd = reversePoints[0];
        const center = attribute.center;
        regionPath = getPolygonPath(from, !!closed);
        nextPath = getPolygonPath(reversePoints, !!closed);
        const toEndRadius = PointService.distancePP(toEnd, center);
        const fromStartRadius = PointService.distancePP(fromStart, center);
        regionPath += `A${toEndRadius},${toEndRadius},0,0,1,${toEnd.x},${toEnd.y}L${toEnd.x},${toEnd.y}`;
        nextPath += `A${fromStartRadius},${fromStartRadius},0,0,0,${fromStart.x},${fromStart.y}`;
    }
    else if (type === 'circle') {
        const { center } = attribute;
        regionPath = getArcPath(center, from, false, !!closed);
        nextPath = getArcPath(center, reversePoints, true, !!closed);
    }
    else if (type === 'line' || type === 'polygon') {
        regionPath = getPolygonPath(from, !!closed);
        nextPath = getPolygonPath(reversePoints, !!closed);
    }
    if (closed) {
        regionPath += nextPath;
    }
    else {
        nextPath = 'L' + nextPath.substring(1);
        regionPath += nextPath;
        regionPath += 'Z';
    }
    return regionPath;
}
class BaseGrid extends AbstractComponent {
    constructor() {
        super(...arguments);
        this.name = 'axis-grid';
        this.data = [];
    }
    getInnerView() {
        return this._innerView;
    }
    getPrevInnerView() {
        return this._prevInnerView;
    }
    render() {
        this._prevInnerView = this._innerView && getElMap(this._innerView);
        this.removeAllChild(true);
        this._innerView = graphicCreator.group({ x: 0, y: 0, pickable: false });
        this.add(this._innerView);
        const { items, visible } = this.attribute;
        if (items && items.length && visible !== false) {
            this.data = this._transformItems(items);
            this._renderGrid(this._innerView);
        }
    }
    getVerticalCoord(point, offset, inside) {
        return getVerticalCoord(point, this.getVerticalVector(offset, inside, point));
    }
    _transformItems(items) {
        const data = [];
        items.forEach((item) => {
            var _a;
            data.push(Object.assign(Object.assign({}, item), { point: this.getTickCoord(item.value), id: (_a = item.id) !== null && _a !== void 0 ? _a : item.label }));
        });
        return data;
    }
    _renderGrid(container) {
        const { visible } = this.attribute.subGrid || {};
        if (visible) {
            this._renderGridByType(true, container);
        }
        this._renderGridByType(false, container);
    }
    _renderGridByType(isSubGrid, container) {
        const gridAttrs = merge({}, this.attribute, this.getGridAttribute(isSubGrid));
        const { type, items, style, closed, alternateColor, depth = 0 } = gridAttrs;
        const name = isSubGrid ? `${AXIS_ELEMENT_NAME.grid}-sub` : `${AXIS_ELEMENT_NAME.grid}`;
        items.forEach((item, index) => {
            const { id, points } = item;
            let path = '';
            if (type === 'line' || type === 'polygon') {
                path = getPolygonPath(points, !!closed);
            }
            else if (type === 'circle') {
                const { center } = this.attribute;
                path = getArcPath(center, points, false, !!closed);
            }
            const shape = graphicCreator.path(Object.assign({ path, z: depth }, (isFunction(style)
                ? merge({}, this.skipDefault ? null : BaseGrid.defaultAttributes.style, style(item, index))
                : style)));
            shape.name = `${name}-line`;
            shape.id = this._getNodeId(`${name}-path-${id}`);
            container.add(shape);
        });
        if (depth && type === 'line') {
            items.forEach((item, index) => {
                const { id, points } = item;
                const nextPoints = [];
                nextPoints.push(points[0]);
                const dir = { x: points[1].x - points[0].x, y: points[1].y - points[0].y };
                const dirLen = Math.sqrt(dir.x * dir.x + dir.y * dir.y);
                const ratio = depth / dirLen;
                nextPoints.push({ x: points[0].x + dir.x * ratio, y: points[0].y + dir.y * ratio });
                const path = getPolygonPath(nextPoints, !!closed);
                const deltaX = abs(nextPoints[0].x - nextPoints[1].x);
                const deltaY = abs(nextPoints[0].y - nextPoints[1].y);
                const shape = graphicCreator.path(Object.assign({ path, z: 0, alpha: deltaX > deltaY ? ((points[1].x - points[0].x > 0 ? -1 : 1) * pi) / 2 : 0, beta: deltaX < deltaY ? -pi / 2 : 0, anchor3d: deltaX > deltaY ? [nextPoints[0].x, 0] : [0, nextPoints[0].y] }, (isFunction(style)
                    ? merge({}, this.skipDefault ? null : BaseGrid.defaultAttributes.style, style(item, index))
                    : style)));
                shape.name = `${name}-line`;
                shape.id = this._getNodeId(`${name}-path-${id}`);
                container.add(shape);
            });
        }
        if (items.length > 1 && alternateColor) {
            const colors = isArray(alternateColor)
                ? alternateColor
                : [alternateColor, 'transparent'];
            const getColor = (index) => colors[index % colors.length];
            const originalItems = this.attribute.items;
            const firstItem = originalItems[0];
            const lastItem = originalItems[originalItems.length - 1];
            const noZero = !isNumberClose(firstItem.value, 0) && !isNumberClose(lastItem.value, 0);
            const noOne = !isNumberClose(firstItem.value, 1) && !isNumberClose(lastItem.value, 1);
            const allPoints = [];
            const isDesc = firstItem.value > lastItem.value;
            if ((isDesc && noOne) || (!isDesc && noZero)) {
                allPoints.push(this.getGridPointsByValue(isDesc ? 1 : 0));
            }
            items.forEach((item) => {
                allPoints.push(item.points);
            });
            if ((isDesc && noZero) || (!isDesc && noOne)) {
                allPoints.push(this.getGridPointsByValue(isDesc ? 0 : 1));
            }
            for (let index = 0; index < allPoints.length - 1; index++) {
                const prev = allPoints[index];
                const curr = allPoints[index + 1];
                const path = getRegionPath(prev, curr, gridAttrs);
                const shape = graphicCreator.path({
                    path,
                    fill: getColor(index)
                });
                shape.name = `${name}-region`;
                shape.id = this._getNodeId(`${name}-region-${index}`);
                container.add(shape);
            }
        }
    }
    _getNodeId(id) {
        return `${this.id}-${id}`;
    }
    _parseTickSegment() {
        let tickSegment = 1;
        const count = this.data.length;
        if (count >= 2) {
            tickSegment = this.data[1].value - this.data[0].value;
        }
        return tickSegment;
    }
    _getPointsOfSubGrid(tickSegment, alignWithLabel) {
        const tickLineCount = this.data.length;
        const points = [];
        if (tickLineCount >= 2) {
            this.data.forEach((item) => {
                let tickValue = item.value;
                if (!alignWithLabel) {
                    const value = item.value - tickSegment / 2;
                    if (this.isInValidValue(value)) {
                        return;
                    }
                    tickValue = value;
                }
                points.push({
                    value: tickValue
                });
            });
        }
        return points;
    }
    release() {
        super.release();
        this._prevInnerView = null;
        this._innerView = null;
    }
}
BaseGrid.defaultAttributes = {
    style: {
        lineWidth: 1,
        stroke: '#999',
        strokeOpacity: 1,
        lineDash: [4, 4]
    },
    subGrid: {
        visible: false,
        style: {
            lineWidth: 1,
            stroke: '#999',
            strokeOpacity: 1,
            lineDash: [4, 4]
        }
    }
};

loadLineAxisGridComponent();
class LineAxisGrid extends BaseGrid {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);
    }
    _getGridPoint(gridType, point) {
        let gridPoints;
        if (gridType === 'line') {
            const { length } = this.attribute;
            const endPoint = this.getVerticalCoord(point, length, true);
            gridPoints = [point, endPoint];
        }
        else if (gridType === 'circle' || gridType === 'polygon') {
            const { center, sides = 6, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute;
            const distance = PointService.distancePP(center, point);
            gridPoints = getCirclePoints(center, sides, distance, startAngle, endAngle);
        }
        return gridPoints;
    }
    getGridPointsByValue(value) {
        const basePoint = this.getTickCoord(value);
        return this._getGridPoint(this.attribute.type, basePoint);
    }
    getGridAttribute(isSubGrid) {
        const { type: gridType, alignWithLabel = true } = this.attribute;
        const tickSegment = this._parseTickSegment();
        let gridAttribute;
        let items = [];
        if (!isSubGrid) {
            gridAttribute = this.attribute;
            const gridItems = [];
            this.data.forEach(item => {
                let { point } = item;
                if (!alignWithLabel) {
                    const value = item.value - tickSegment / 2;
                    if (this.isInValidValue(value)) {
                        return;
                    }
                    point = this.getTickCoord(value);
                }
                gridItems.push({
                    id: item.label,
                    datum: item,
                    points: this._getGridPoint(gridType, point)
                });
            });
            items = gridItems;
        }
        else {
            gridAttribute = merge({}, this.attribute, this.attribute.subGrid);
            const subGridItems = [];
            const { count: subCount = 4 } = gridAttribute;
            const tickLineCount = this.data.length;
            if (tickLineCount >= 2) {
                const points = this._getPointsOfSubGrid(tickSegment, alignWithLabel);
                for (let i = 0; i < points.length - 1; i++) {
                    const pre = points[i];
                    const next = points[i + 1];
                    subGridItems.push({
                        id: `sub-${i}-0`,
                        points: this.getGridPointsByValue(pre.value),
                        datum: {}
                    });
                    for (let j = 0; j < subCount; j++) {
                        const percent = (j + 1) / (subCount + 1);
                        const value = (1 - percent) * pre.value + percent * next.value;
                        subGridItems.push({
                            id: `sub-${i}-${j + 1}`,
                            points: this.getGridPointsByValue(value),
                            datum: {}
                        });
                    }
                    if (i === points.length - 2) {
                        subGridItems.push({
                            id: `sub-${i}-${subCount + 1}`,
                            points: this.getGridPointsByValue(next.value),
                            datum: {}
                        });
                    }
                }
                items = subGridItems;
            }
        }
        return Object.assign(Object.assign({}, gridAttribute), { items });
    }
}
mixin(LineAxisGrid, LineAxisMixin);

loadCircleAxisGridComponent();
class CircleAxisGrid extends BaseGrid {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);
    }
    getGridPointsByValue(value) {
        const basePoint = this.getTickCoord(value);
        const { radius, innerRadius = 0 } = this.attribute;
        return [basePoint, this.getVerticalCoord(basePoint, radius - innerRadius, true)];
    }
    getGridAttribute(isSubGrid) {
        let gridAttribute;
        let items = [];
        const _a = this.attribute, { radius, innerRadius = 0, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE, center, subGrid } = _a, grid = __rest(_a, ["radius", "innerRadius", "startAngle", "endAngle", "center", "subGrid"]);
        const { alignWithLabel = true } = grid || {};
        const length = radius - innerRadius;
        const tickSegment = this._parseTickSegment();
        if (!isSubGrid) {
            gridAttribute = grid;
            const gridItems = [];
            let data;
            if (Math.abs(endAngle - startAngle) % (Math.PI * 2) === 0) {
                data = [...this.data].concat(this.data[0]);
            }
            else {
                data = this.data;
            }
            data.forEach(item => {
                let { point } = item;
                if (!alignWithLabel) {
                    const value = item.value - tickSegment / 2;
                    if (this.isInValidValue(value)) {
                        return;
                    }
                    point = this.getTickCoord(value);
                }
                const endPoint = this.getVerticalCoord(point, length, true);
                gridItems.push({
                    id: item.id,
                    points: [point, endPoint],
                    datum: item
                });
            });
            items = gridItems;
        }
        else {
            gridAttribute = merge({}, grid, subGrid);
            const subGridItems = [];
            const { count: subCount = 4 } = subGrid || {};
            const tickLineCount = this.data.length;
            if (tickLineCount >= 2) {
                const points = this._getPointsOfSubGrid(tickSegment, alignWithLabel);
                for (let i = 0; i < tickLineCount; i++) {
                    const pre = points[i];
                    const next = points[i + 1];
                    subGridItems.push({
                        id: `sub-${i}-${0}`,
                        points: [this.getTickCoord(pre.value), this.getVerticalCoord(this.getTickCoord(pre.value), length, true)],
                        datum: {}
                    });
                    for (let j = 0; j < subCount; j++) {
                        const percent = (j + 1) / (subCount + 1);
                        const value = (1 - percent) * pre.value + percent * (next ? next.value : alignWithLabel ? 1 : pre.value + tickSegment);
                        const point = this.getTickCoord(value);
                        const endPoint = this.getVerticalCoord(point, length, true);
                        subGridItems.push({
                            id: `sub-${i}-${j + 1}`,
                            points: [point, endPoint],
                            datum: {}
                        });
                    }
                }
                if (Math.abs(endAngle - startAngle) % (Math.PI * 2) === 0) {
                    subGridItems.push(subGridItems[0]);
                }
                items = subGridItems;
            }
        }
        return Object.assign(Object.assign({}, gridAttribute), { items,
            center, type: 'line' });
    }
}
mixin(CircleAxisGrid, CircleAxisMixin);

const DEFAULT_HANDLER_PATH = 'M -0.0544 0.25 C -0.0742 0.25 -0.0901 0.234 -0.0901 0.2143 L -0.0901 -0.1786 C -0.0901 -0.1983 -0.0742 -0.2143 -0.0544 -0.2143 L -0.0187 -0.2143 L -0.0187 -0.5 L 0.017 -0.5 L 0.017 -0.2143 L 0.0527 -0.2143 C 0.0724 -0.2143 0.0884 -0.1983 0.0884 -0.1786 L 0.0884 0.2143 C 0.0884 0.234 0.0724 0.25 0.0527 0.25 L 0.017 0.25 L 0.017 0.5 L -0.0187 0.5 L -0.0187 0.25 L -0.0544 0.25 Z M -0.0187 -0.1429 L -0.0544 -0.1429 L -0.0544 0.1786 L -0.0187 0.1786 L -0.0187 -0.1429 Z M 0.0527 -0.1429 L 0.017 -0.1429 L 0.017 0.1786 L 0.0527 0.1786 L 0.0527 -0.1429 Z';
const DEFAULT_DATA_ZOOM_ATTRIBUTES = {
    orient: 'bottom',
    showDetail: 'auto',
    brushSelect: true,
    zoomLock: false,
    minSpan: 0,
    maxSpan: 1,
    delayType: 'throttle',
    delayTime: 0,
    realTime: true,
    backgroundStyle: {
        fill: 'white',
        stroke: '#D1DBEE',
        lineWidth: 1,
        cornerRadius: 2
    },
    dragMaskStyle: {
        fill: '#B0C8F9',
        fillOpacity: 0.2
    },
    backgroundChartStyle: {
        area: {
            visible: true,
            stroke: '#D1DBEE',
            lineWidth: 1,
            fill: '#F6F8FC'
        },
        line: {
            visible: true,
            stroke: '#D1DBEE',
            lineWidth: 1
        }
    },
    selectedBackgroundStyle: {
        fill: '#B0C8F9',
        fillOpacity: 0.5
    },
    selectedBackgroundChartStyle: {
        area: {
            visible: true,
            stroke: '#B0C8F9',
            lineWidth: 1,
            fill: '#fbb934'
        },
        line: {
            visible: true,
            stroke: '#fbb934',
            lineWidth: 1
        }
    },
    middleHandlerStyle: {
        visible: true,
        background: {
            size: 8,
            style: {
                fill: 'white',
                stroke: '#B0C8F9',
                cornerRadius: 2
            }
        },
        icon: {
            size: 6,
            fill: 'white',
            stroke: '#B0C8F9',
            symbolType: 'M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z',
            lineWidth: 0.5
        }
    },
    startHandlerStyle: {
        visible: true,
        triggerMinSize: 0,
        symbolType: DEFAULT_HANDLER_PATH,
        fill: 'white',
        stroke: '#B0C8F9',
        lineWidth: 0.5
    },
    endHandlerStyle: {
        visible: true,
        triggerMinSize: 0,
        symbolType: DEFAULT_HANDLER_PATH,
        fill: 'white',
        stroke: '#B0C8F9',
        lineWidth: 0.5
    },
    startTextStyle: {
        padding: 4,
        textStyle: {
            fontSize: 10,
            fill: '#6F6F6F'
        }
    },
    endTextStyle: {
        padding: 4,
        textStyle: {
            fontSize: 10,
            fill: '#6F6F6F'
        }
    }
};
const DEFAULT_HANDLER_ATTR_MAP = {
    horizontal: {
        angle: 0,
        strokeBoundsBuffer: 0,
        boundsPadding: 2,
        pickMode: 'imprecise',
        cursor: 'ew-resize'
    },
    vertical: {
        angle: 90 * (Math.PI / 180),
        cursor: 'ns-resize',
        boundsPadding: 2,
        pickMode: 'imprecise',
        strokeBoundsBuffer: 0
    }
};

var DataZoomActiveTag;
(function (DataZoomActiveTag) {
    DataZoomActiveTag["startHandler"] = "startHandler";
    DataZoomActiveTag["endHandler"] = "endHandler";
    DataZoomActiveTag["middleHandler"] = "middleHandler";
    DataZoomActiveTag["background"] = "background";
})(DataZoomActiveTag || (DataZoomActiveTag = {}));

function loadDataZoomComponent() {
    loadTagComponent();
    registerRect();
    registerSymbol();
    registerArea();
    registerLine();
}

const delayMap$1 = {
    debounce: debounce,
    throttle: throttle
};
loadDataZoomComponent();
class DataZoom extends AbstractComponent {
    setPropsFromAttrs() {
        const { start, end, orient, previewData, previewPointsX, previewPointsY, previewPointsX1, previewPointsY1 } = this
            .attribute;
        start && (this.state.start = start);
        end && (this.state.end = end);
        const { width, height } = this.getLayoutAttrFromConfig();
        this._spanCache = this.state.end - this.state.start;
        this._isHorizontal = orient === 'top' || orient === 'bottom';
        this._layoutCache.max = this._isHorizontal ? width : height;
        this._layoutCache.attPos = this._isHorizontal ? 'x' : 'y';
        this._layoutCache.attSize = this._isHorizontal ? 'width' : 'height';
        previewData && (this._previewData = previewData);
        isFunction(previewPointsX) && (this._previewPointsX = previewPointsX);
        isFunction(previewPointsY) && (this._previewPointsY = previewPointsY);
        isFunction(previewPointsX1) && (this._previewPointsX1 = previewPointsX1);
        isFunction(previewPointsY1) && (this._previewPointsY1 = previewPointsY1);
    }
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, DataZoom.defaultAttributes, attributes));
        this.name = 'dataZoom';
        this._previewData = [];
        this._activeState = false;
        this._activeCache = {
            startPos: { x: 0, y: 0 },
            lastPos: { x: 0, y: 0 }
        };
        this._layoutCache = {
            attPos: 'x',
            attSize: 'width',
            max: 0
        };
        this.state = {
            start: 0,
            end: 1
        };
        this._statePointToData = state => state;
        this._handleTouchMove = (e) => {
            if (this._activeState) {
                e.preventDefault();
            }
        };
        this._onHandlerPointerDown = (e, tag) => {
            this._clearDragEvents();
            if (tag === 'start') {
                this._activeTag = DataZoomActiveTag.startHandler;
                this._activeItem = this._startHandlerMask;
            }
            else if (tag === 'end') {
                this._activeTag = DataZoomActiveTag.endHandler;
                this._activeItem = this._endHandlerMask;
            }
            else if (tag === 'middleRect') {
                this._activeTag = DataZoomActiveTag.middleHandler;
                this._activeItem = this._middleHandlerRect;
            }
            else if (tag === 'middleSymbol') {
                this._activeTag = DataZoomActiveTag.middleHandler;
                this._activeItem = this._middleHandlerSymbol;
            }
            else if (tag === 'background') {
                this._activeTag = DataZoomActiveTag.background;
                this._activeItem = this._background;
            }
            this._activeState = true;
            this._activeCache.startPos = this.eventPosToStagePos(e);
            this._activeCache.lastPos = this.eventPosToStagePos(e);
            const evtTarget = vglobal.env === 'browser' ? vglobal : this.stage;
            const triggers = getEndTriggersOfDrag();
            evtTarget.addEventListener('pointermove', this._onHandlerPointerMove, { capture: true });
            this.addEventListener('pointermove', this._onHandlerPointerMove, {
                capture: true
            });
            triggers.forEach((trigger) => {
                evtTarget.addEventListener(trigger, this._onHandlerPointerUp);
            });
        };
        this._pointerMove = (e) => {
            const { start: startAttr, end: endAttr, brushSelect, realTime = true } = this.attribute;
            const pos = this.eventPosToStagePos(e);
            const { attPos, max } = this._layoutCache;
            const dis = (pos[attPos] - this._activeCache.lastPos[attPos]) / max;
            let { start, end } = this.state;
            if (this._activeState) {
                if (this._activeTag === DataZoomActiveTag.middleHandler) {
                    this.moveZoomWithMiddle((this.state.start + this.state.end) / 2 + dis);
                }
                else if (this._activeTag === DataZoomActiveTag.startHandler) {
                    if (start + dis > end) {
                        start = end;
                        end = start + dis;
                        this._activeTag = DataZoomActiveTag.endHandler;
                    }
                    else {
                        start = start + dis;
                    }
                }
                else if (this._activeTag === DataZoomActiveTag.endHandler) {
                    if (end + dis < start) {
                        end = start;
                        start = end + dis;
                        this._activeTag = DataZoomActiveTag.startHandler;
                    }
                    else {
                        end = end + dis;
                    }
                }
                this._activeCache.lastPos = pos;
                brushSelect && this.renderDragMask();
            }
            start = Math.min(Math.max(start, 0), 1);
            end = Math.min(Math.max(end, 0), 1);
            if (startAttr !== start || endAttr !== end) {
                this.setStateAttr(start, end, true);
                if (realTime) {
                    this._dispatchEvent('change', {
                        start,
                        end,
                        tag: this._activeTag
                    });
                }
            }
        };
        this._onHandlerPointerMove = this.attribute.delayTime === 0
            ? this._pointerMove
            : delayMap$1[this.attribute.delayType](this._pointerMove, this.attribute.delayTime);
        this._onHandlerPointerUp = (e) => {
            const { start, end, brushSelect, realTime = true } = this.attribute;
            if (this._activeState) {
                if (this._activeTag === DataZoomActiveTag.background) {
                    const pos = this.eventPosToStagePos(e);
                    this.backgroundDragZoom(this._activeCache.startPos, pos);
                }
            }
            this._activeState = false;
            brushSelect && this.renderDragMask();
            this._dispatchEvent('change', {
                start: this.state.start,
                end: this.state.end,
                tag: this._activeTag
            });
            this._clearDragEvents();
        };
        const { position, showDetail } = attributes;
        this._activeCache.startPos = position;
        this._activeCache.lastPos = position;
        if (showDetail === 'auto') {
            this._showText = false;
        }
        else {
            this._showText = showDetail;
        }
        this.setPropsFromAttrs();
    }
    setAttributes(params, forceUpdateTag) {
        super.setAttributes(params, forceUpdateTag);
        this.setPropsFromAttrs();
    }
    bindEvents() {
        if (this.attribute.disableTriggerEvent) {
            this.setAttribute('childrenPickable', false);
            return;
        }
        const { showDetail, brushSelect } = this.attribute;
        if (this._startHandlerMask) {
            this._startHandlerMask.addEventListener('pointerdown', (e) => this._onHandlerPointerDown(e, 'start'));
        }
        if (this._endHandlerMask) {
            this._endHandlerMask.addEventListener('pointerdown', (e) => this._onHandlerPointerDown(e, 'end'));
        }
        if (this._middleHandlerSymbol) {
            this._middleHandlerSymbol.addEventListener('pointerdown', (e) => this._onHandlerPointerDown(e, 'middleSymbol'));
        }
        if (this._middleHandlerRect) {
            this._middleHandlerRect.addEventListener('pointerdown', (e) => this._onHandlerPointerDown(e, 'middleRect'));
        }
        const selectedTag = brushSelect ? 'background' : 'middleRect';
        if (this._selectedBackground) {
            this._selectedBackground.addEventListener('pointerdown', (e) => this._onHandlerPointerDown(e, selectedTag));
        }
        if (brushSelect && this._background) {
            this._background.addEventListener('pointerdown', (e) => this._onHandlerPointerDown(e, 'background'));
        }
        if (brushSelect && this._previewGroup) {
            this._previewGroup.addEventListener('pointerdown', (e) => this._onHandlerPointerDown(e, 'background'));
        }
        if (this._selectedPreviewGroup) {
            this._selectedPreviewGroup.addEventListener('pointerdown', (e) => this._onHandlerPointerDown(e, selectedTag));
        }
        if (showDetail === 'auto') {
            this.addEventListener('pointerenter', this._onHandlerPointerEnter);
            this.addEventListener('pointerleave', this._onHandlerPointerLeave);
        }
        (vglobal.env === 'browser' ? vglobal : this.stage).addEventListener('touchmove', this._handleTouchMove, {
            passive: false
        });
    }
    dragMaskSize() {
        const { position } = this.attribute;
        const { attPos, max } = this._layoutCache;
        if (this._activeCache.lastPos[attPos] - position[attPos] > max) {
            return max + position[attPos] - this._activeCache.startPos[attPos];
        }
        else if (this._activeCache.lastPos[attPos] - position[attPos] < 0) {
            return position[attPos] - this._activeCache.startPos[attPos];
        }
        return this._activeCache.lastPos[attPos] - this._activeCache.startPos[attPos];
    }
    setStateAttr(start, end, shouldRender) {
        const { zoomLock = false, minSpan = 0, maxSpan = 1 } = this.attribute;
        const span = end - start;
        if (span !== this._spanCache && (zoomLock || span < minSpan || span > maxSpan)) {
            return;
        }
        this._spanCache = span;
        this.state.start = start;
        this.state.end = end;
        shouldRender && this.setAttributes({ start, end });
    }
    _clearDragEvents() {
        const evtTarget = vglobal.env === 'browser' ? vglobal : this.stage;
        const triggers = getEndTriggersOfDrag();
        evtTarget.removeEventListener('pointermove', this._onHandlerPointerMove, { capture: true });
        triggers.forEach((trigger) => {
            evtTarget.removeEventListener(trigger, this._onHandlerPointerUp);
        });
        this.removeEventListener('pointermove', this._onHandlerPointerMove, {
            capture: true
        });
    }
    _onHandlerPointerEnter(e) {
        this._showText = true;
        this.renderText();
    }
    _onHandlerPointerLeave(e) {
        this._showText = false;
        this.renderText();
    }
    backgroundDragZoom(startPos, endPos) {
        const { attPos, max } = this._layoutCache;
        const { position } = this.attribute;
        const startPosInComponent = startPos[attPos] - position[attPos];
        const endPosInComponent = endPos[attPos] - position[attPos];
        const start = Math.min(Math.max(Math.min(startPosInComponent, endPosInComponent) / max, 0), 1);
        const end = Math.min(Math.max(Math.max(startPosInComponent, endPosInComponent) / max, 0), 1);
        if (Math.abs(start - end) < 0.01) {
            this.moveZoomWithMiddle(start);
        }
        else {
            this.setStateAttr(start, end, false);
        }
    }
    moveZoomWithMiddle(middle) {
        const currentMiddle = (this.state.start + this.state.end) / 2;
        let offset = middle - currentMiddle;
        if (offset === 0) {
            return;
        }
        else if (offset > 0) {
            if (this.state.end + offset > 1) {
                offset = 1 - this.state.end;
            }
        }
        else if (offset < 0) {
            if (this.state.start + offset < 0) {
                offset = -this.state.start;
            }
        }
        this.setStateAttr(this.state.start + offset, this.state.end + offset, false);
    }
    renderDragMask() {
        const { dragMaskStyle } = this.attribute;
        const { position, width, height } = this.getLayoutAttrFromConfig();
        if (this._isHorizontal) {
            this._dragMask = this._container.createOrUpdateChild('dragMask', Object.assign({ x: clamp(this.dragMaskSize() < 0 ? this._activeCache.lastPos.x : this._activeCache.startPos.x, position.x, position.x + width), y: position.y, width: (this._activeState && this._activeTag === DataZoomActiveTag.background && Math.abs(this.dragMaskSize())) ||
                    0, height }, dragMaskStyle), 'rect');
        }
        else {
            this._dragMask = this._container.createOrUpdateChild('dragMask', Object.assign({ x: position.x, y: clamp(this.dragMaskSize() < 0 ? this._activeCache.lastPos.y : this._activeCache.startPos.y, position.y, position.y + height), width, height: (this._activeState && this._activeTag === DataZoomActiveTag.background && Math.abs(this.dragMaskSize())) ||
                    0 }, dragMaskStyle), 'rect');
        }
    }
    isTextOverflow(componentBoundsLike, textBounds, layout) {
        if (!textBounds) {
            return false;
        }
        if (this._isHorizontal) {
            if (layout === 'start') {
                if (textBounds.x1 < componentBoundsLike.x1) {
                    return true;
                }
            }
            else {
                if (textBounds.x2 > componentBoundsLike.x2) {
                    return true;
                }
            }
        }
        else {
            if (layout === 'start') {
                if (textBounds.y1 < componentBoundsLike.y1) {
                    return true;
                }
            }
            else {
                if (textBounds.y2 > componentBoundsLike.y2) {
                    return true;
                }
            }
        }
        return false;
    }
    setTextAttr(startTextBounds, endTextBounds) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const { startTextStyle, endTextStyle } = this.attribute;
        const { formatMethod: startTextFormat } = startTextStyle, restStartTextStyle = __rest(startTextStyle, ["formatMethod"]);
        const { formatMethod: endTextFormat } = endTextStyle, restEndTextStyle = __rest(endTextStyle, ["formatMethod"]);
        const { start, end } = this.state;
        this._startValue = this._statePointToData(start);
        this._endValue = this._statePointToData(end);
        const { position, width, height } = this.getLayoutAttrFromConfig();
        const startTextValue = startTextFormat ? startTextFormat(this._startValue) : this._startValue;
        const endTextValue = endTextFormat ? endTextFormat(this._endValue) : this._endValue;
        const componentBoundsLike = {
            x1: position.x,
            y1: position.y,
            x2: position.x + width,
            y2: position.y + height
        };
        let startTextPosition;
        let endTextPosition;
        let startTextAlignStyle;
        let endTextAlignStyle;
        if (this._isHorizontal) {
            startTextPosition = {
                x: position.x + start * width,
                y: position.y + height / 2
            };
            endTextPosition = {
                x: position.x + end * width,
                y: position.y + height / 2
            };
            startTextAlignStyle = {
                textAlign: this.isTextOverflow(componentBoundsLike, startTextBounds, 'start') ? 'left' : 'right',
                textBaseline: (_b = (_a = restStartTextStyle === null || restStartTextStyle === void 0 ? void 0 : restStartTextStyle.textStyle) === null || _a === void 0 ? void 0 : _a.textBaseline) !== null && _b !== void 0 ? _b : 'middle'
            };
            endTextAlignStyle = {
                textAlign: this.isTextOverflow(componentBoundsLike, endTextBounds, 'end') ? 'right' : 'left',
                textBaseline: (_d = (_c = restEndTextStyle === null || restEndTextStyle === void 0 ? void 0 : restEndTextStyle.textStyle) === null || _c === void 0 ? void 0 : _c.textBaseline) !== null && _d !== void 0 ? _d : 'middle'
            };
        }
        else {
            startTextPosition = {
                x: position.x + width / 2,
                y: position.y + start * height
            };
            endTextPosition = {
                x: position.x + width / 2,
                y: position.y + end * height
            };
            startTextAlignStyle = {
                textAlign: (_f = (_e = restStartTextStyle === null || restStartTextStyle === void 0 ? void 0 : restStartTextStyle.textStyle) === null || _e === void 0 ? void 0 : _e.textAlign) !== null && _f !== void 0 ? _f : 'center',
                textBaseline: this.isTextOverflow(componentBoundsLike, startTextBounds, 'start') ? 'top' : 'bottom'
            };
            endTextAlignStyle = {
                textAlign: (_h = (_g = restEndTextStyle === null || restEndTextStyle === void 0 ? void 0 : restEndTextStyle.textStyle) === null || _g === void 0 ? void 0 : _g.textAlign) !== null && _h !== void 0 ? _h : 'center',
                textBaseline: this.isTextOverflow(componentBoundsLike, endTextBounds, 'end') ? 'bottom' : 'top'
            };
        }
        this._startText = this.maybeAddLabel(this._container, merge({}, restStartTextStyle, {
            text: startTextValue,
            x: startTextPosition.x,
            y: startTextPosition.y,
            visible: this._showText,
            pickable: false,
            childrenPickable: false,
            textStyle: startTextAlignStyle
        }), `data-zoom-start-text-${position}`);
        this._endText = this.maybeAddLabel(this._container, merge({}, restEndTextStyle, {
            text: endTextValue,
            x: endTextPosition.x,
            y: endTextPosition.y,
            visible: this._showText,
            pickable: false,
            childrenPickable: false,
            textStyle: endTextAlignStyle
        }), `data-zoom-end-text-${position}`);
    }
    renderText() {
        let startTextBounds = null;
        let endTextBounds = null;
        this.setTextAttr(startTextBounds, endTextBounds);
        startTextBounds = this._startText.AABBBounds;
        endTextBounds = this._endText.AABBBounds;
        this.setTextAttr(startTextBounds, endTextBounds);
        startTextBounds = this._startText.AABBBounds;
        endTextBounds = this._endText.AABBBounds;
        const { x1, x2, y1, y2 } = startTextBounds;
        const { dx: startTextDx = 0, dy: startTextDy = 0 } = this.attribute.startTextStyle;
        if (new Bounds().set(x1, y1, x2, y2).intersects(endTextBounds)) {
            const direction = this.attribute.orient === 'bottom' || this.attribute.orient === 'right' ? -1 : 1;
            if (this._isHorizontal) {
                const boundsYDiff = Math.abs(endTextBounds.y1 - endTextBounds.y2);
                this._startText.setAttribute('dy', startTextDy + direction * (Number.isFinite(boundsYDiff) ? boundsYDiff : 0));
            }
            else {
                const boundsXDiff = Math.abs(endTextBounds.x1 - endTextBounds.x2);
                this._startText.setAttribute('dx', startTextDx + direction * (Number.isFinite(boundsXDiff) ? boundsXDiff : 0));
            }
        }
        else {
            if (this._isHorizontal) {
                this._startText.setAttribute('dy', startTextDy);
            }
            else {
                this._startText.setAttribute('dx', startTextDx);
            }
        }
    }
    getLayoutAttrFromConfig() {
        var _a, _b, _c, _d, _e, _f;
        if (this._layoutAttrFromConfig) {
            return this._layoutAttrFromConfig;
        }
        const { position: positionConfig, size, orient, middleHandlerStyle = {}, startHandlerStyle = {}, endHandlerStyle = {}, backgroundStyle = {} } = this.attribute;
        const { width: widthConfig, height: heightConfig } = size;
        const middleHandlerSize = (_b = (_a = middleHandlerStyle.background) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 10;
        let width;
        let height;
        let position;
        if (middleHandlerStyle.visible) {
            if (this._isHorizontal) {
                width = widthConfig;
                height = heightConfig - middleHandlerSize;
                position = {
                    x: positionConfig.x,
                    y: positionConfig.y + middleHandlerSize
                };
            }
            else {
                width = widthConfig - middleHandlerSize;
                height = heightConfig;
                position = {
                    x: positionConfig.x + (orient === 'left' ? middleHandlerSize : 0),
                    y: positionConfig.y
                };
            }
        }
        else {
            width = widthConfig;
            height = heightConfig;
            position = positionConfig;
        }
        const startHandlerSize = (_c = startHandlerStyle.size) !== null && _c !== void 0 ? _c : (this._isHorizontal ? height : width);
        const endHandlerSize = (_d = endHandlerStyle.size) !== null && _d !== void 0 ? _d : (this._isHorizontal ? height : width);
        if (startHandlerStyle.visible) {
            if (this._isHorizontal) {
                width -= (startHandlerSize + endHandlerSize) / 2;
                position = {
                    x: position.x + startHandlerSize / 2,
                    y: position.y
                };
            }
            else {
                height -= (startHandlerSize + endHandlerSize) / 2;
                position = {
                    x: position.x,
                    y: position.y + startHandlerSize / 2
                };
            }
        }
        height += (_e = backgroundStyle.lineWidth / 2) !== null && _e !== void 0 ? _e : 1;
        width += (_f = backgroundStyle.lineWidth / 2) !== null && _f !== void 0 ? _f : 1;
        this._layoutAttrFromConfig = {
            position,
            width,
            height
        };
        return this._layoutAttrFromConfig;
    }
    render() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9;
        this._layoutAttrFromConfig = null;
        const { orient, backgroundStyle, backgroundChartStyle = {}, selectedBackgroundStyle = {}, selectedBackgroundChartStyle = {}, middleHandlerStyle = {}, startHandlerStyle = {}, endHandlerStyle = {}, brushSelect, zoomLock } = this.attribute;
        const { start, end } = this.state;
        const { position, width, height } = this.getLayoutAttrFromConfig();
        const startHandlerMinSize = (_a = startHandlerStyle.triggerMinSize) !== null && _a !== void 0 ? _a : 40;
        const endHandlerMinSize = (_b = endHandlerStyle.triggerMinSize) !== null && _b !== void 0 ? _b : 40;
        const group = this.createOrUpdateChild('dataZoom-container', {}, 'group');
        this._container = group;
        this._background = group.createOrUpdateChild('background', Object.assign(Object.assign({ x: position.x, y: position.y, width,
            height, cursor: brushSelect ? 'crosshair' : 'auto' }, backgroundStyle), { pickable: zoomLock ? false : (_c = backgroundStyle.pickable) !== null && _c !== void 0 ? _c : true }), 'rect');
        ((_d = backgroundChartStyle.line) === null || _d === void 0 ? void 0 : _d.visible) && this.setPreviewAttributes('line', group);
        ((_e = backgroundChartStyle.area) === null || _e === void 0 ? void 0 : _e.visible) && this.setPreviewAttributes('area', group);
        brushSelect && this.renderDragMask();
        if (this._isHorizontal) {
            this._selectedBackground = group.createOrUpdateChild('selectedBackground', Object.assign(Object.assign({ x: position.x + start * width, y: position.y, width: (end - start) * width, height: height, cursor: brushSelect ? 'crosshair' : 'move' }, selectedBackgroundStyle), { pickable: zoomLock ? false : (_f = selectedBackgroundChartStyle.pickable) !== null && _f !== void 0 ? _f : true }), 'rect');
        }
        else {
            this._selectedBackground = group.createOrUpdateChild('selectedBackground', Object.assign(Object.assign({ x: position.x, y: position.y + start * height, width, height: (end - start) * height, cursor: brushSelect ? 'crosshair' : 'move' }, selectedBackgroundStyle), { pickable: zoomLock ? false : (_g = selectedBackgroundStyle.pickable) !== null && _g !== void 0 ? _g : true }), 'rect');
        }
        ((_h = selectedBackgroundChartStyle.line) === null || _h === void 0 ? void 0 : _h.visible) && this.setSelectedPreviewAttributes('line', group);
        ((_j = selectedBackgroundChartStyle.area) === null || _j === void 0 ? void 0 : _j.visible) && this.setSelectedPreviewAttributes('area', group);
        if (this._isHorizontal) {
            if (middleHandlerStyle.visible) {
                const middleHandlerBackgroundSize = ((_k = middleHandlerStyle.background) === null || _k === void 0 ? void 0 : _k.size) || 10;
                this._middleHandlerRect = group.createOrUpdateChild('middleHandlerRect', Object.assign(Object.assign({ x: position.x + start * width, y: position.y - middleHandlerBackgroundSize, width: (end - start) * width, height: middleHandlerBackgroundSize }, (_l = middleHandlerStyle.background) === null || _l === void 0 ? void 0 : _l.style), { pickable: zoomLock ? false : (_p = (_o = (_m = middleHandlerStyle.background) === null || _m === void 0 ? void 0 : _m.style) === null || _o === void 0 ? void 0 : _o.pickable) !== null && _p !== void 0 ? _p : true }), 'rect');
                this._middleHandlerSymbol = group.createOrUpdateChild('middleHandlerSymbol', Object.assign(Object.assign({ x: position.x + ((start + end) / 2) * width, y: position.y - middleHandlerBackgroundSize / 2, strokeBoundsBuffer: 0, angle: 0, symbolType: (_r = (_q = middleHandlerStyle.icon) === null || _q === void 0 ? void 0 : _q.symbolType) !== null && _r !== void 0 ? _r : 'square' }, middleHandlerStyle.icon), { pickable: zoomLock ? false : (_s = middleHandlerStyle.icon.pickable) !== null && _s !== void 0 ? _s : true }), 'symbol');
            }
            this._startHandler = group.createOrUpdateChild('startHandler', Object.assign(Object.assign(Object.assign({ x: position.x + start * width, y: position.y + height / 2, size: height, symbolType: (_t = startHandlerStyle.symbolType) !== null && _t !== void 0 ? _t : 'square' }, DEFAULT_HANDLER_ATTR_MAP.horizontal), startHandlerStyle), { pickable: zoomLock ? false : (_u = startHandlerStyle.pickable) !== null && _u !== void 0 ? _u : true }), 'symbol');
            this._endHandler = group.createOrUpdateChild('endHandler', Object.assign(Object.assign(Object.assign({ x: position.x + end * width, y: position.y + height / 2, size: height, symbolType: (_v = endHandlerStyle.symbolType) !== null && _v !== void 0 ? _v : 'square' }, DEFAULT_HANDLER_ATTR_MAP.horizontal), endHandlerStyle), { pickable: zoomLock ? false : (_w = endHandlerStyle.pickable) !== null && _w !== void 0 ? _w : true }), 'symbol');
            const startHandlerWidth = Math.max(this._startHandler.AABBBounds.width(), startHandlerMinSize);
            const startHandlerHeight = Math.max(this._startHandler.AABBBounds.height(), startHandlerMinSize);
            const endHandlerWidth = Math.max(this._endHandler.AABBBounds.width(), endHandlerMinSize);
            const endHandlerHeight = Math.max(this._endHandler.AABBBounds.height(), endHandlerMinSize);
            this._startHandlerMask = group.createOrUpdateChild('startHandlerMask', Object.assign(Object.assign({ x: position.x + start * width - startHandlerWidth / 2, y: position.y + height / 2 - startHandlerHeight / 2, width: startHandlerWidth, height: startHandlerHeight, fill: 'white', fillOpacity: 0, zIndex: 999 }, DEFAULT_HANDLER_ATTR_MAP.horizontal), { pickable: !zoomLock }), 'rect');
            this._endHandlerMask = group.createOrUpdateChild('endHandlerMask', Object.assign(Object.assign({ x: position.x + end * width - endHandlerWidth / 2, y: position.y + height / 2 - endHandlerHeight / 2, width: endHandlerWidth, height: endHandlerHeight, fill: 'white', fillOpacity: 0, zIndex: 999 }, DEFAULT_HANDLER_ATTR_MAP.horizontal), { pickable: !zoomLock }), 'rect');
        }
        else {
            if (middleHandlerStyle.visible) {
                const middleHandlerBackgroundSize = ((_x = middleHandlerStyle.background) === null || _x === void 0 ? void 0 : _x.size) || 10;
                this._middleHandlerRect = group.createOrUpdateChild('middleHandlerRect', Object.assign(Object.assign({ x: orient === 'left' ? position.x - middleHandlerBackgroundSize : position.x + width, y: position.y + start * height, width: middleHandlerBackgroundSize, height: (end - start) * height }, (_y = middleHandlerStyle.background) === null || _y === void 0 ? void 0 : _y.style), { pickable: zoomLock ? false : (_1 = (_0 = (_z = middleHandlerStyle.background) === null || _z === void 0 ? void 0 : _z.style) === null || _0 === void 0 ? void 0 : _0.pickable) !== null && _1 !== void 0 ? _1 : true }), 'rect');
                this._middleHandlerSymbol = group.createOrUpdateChild('middleHandlerSymbol', Object.assign(Object.assign({ x: orient === 'left'
                        ? position.x - middleHandlerBackgroundSize / 2
                        : position.x + width + middleHandlerBackgroundSize / 2, y: position.y + ((start + end) / 2) * height, angle: 90 * (Math.PI / 180), symbolType: (_3 = (_2 = middleHandlerStyle.icon) === null || _2 === void 0 ? void 0 : _2.symbolType) !== null && _3 !== void 0 ? _3 : 'square', strokeBoundsBuffer: 0 }, middleHandlerStyle.icon), { pickable: zoomLock ? false : (_5 = (_4 = middleHandlerStyle.icon) === null || _4 === void 0 ? void 0 : _4.pickable) !== null && _5 !== void 0 ? _5 : true }), 'symbol');
            }
            this._startHandler = group.createOrUpdateChild('startHandler', Object.assign(Object.assign(Object.assign({ x: position.x + width / 2, y: position.y + start * height, size: width, symbolType: (_6 = startHandlerStyle.symbolType) !== null && _6 !== void 0 ? _6 : 'square' }, DEFAULT_HANDLER_ATTR_MAP.vertical), startHandlerStyle), { pickable: zoomLock ? false : (_7 = startHandlerStyle.pickable) !== null && _7 !== void 0 ? _7 : true }), 'symbol');
            this._endHandler = group.createOrUpdateChild('endHandler', Object.assign(Object.assign(Object.assign({ x: position.x + width / 2, y: position.y + end * height, size: width, symbolType: (_8 = endHandlerStyle.symbolType) !== null && _8 !== void 0 ? _8 : 'square' }, DEFAULT_HANDLER_ATTR_MAP.vertical), endHandlerStyle), { pickable: zoomLock ? false : (_9 = endHandlerStyle.pickable) !== null && _9 !== void 0 ? _9 : true }), 'symbol');
            const startHandlerWidth = Math.max(this._startHandler.AABBBounds.width(), startHandlerMinSize);
            const startHandlerHeight = Math.max(this._startHandler.AABBBounds.height(), startHandlerMinSize);
            const endHandlerWidth = Math.max(this._endHandler.AABBBounds.width(), endHandlerMinSize);
            const endHandlerHeight = Math.max(this._endHandler.AABBBounds.height(), endHandlerMinSize);
            this._startHandlerMask = group.createOrUpdateChild('startHandlerMask', Object.assign(Object.assign({ x: position.x + width / 2 + startHandlerWidth / 2, y: position.y + start * height - startHandlerHeight / 2, width: endHandlerHeight, height: endHandlerWidth, fill: 'white', fillOpacity: 0, zIndex: 999 }, DEFAULT_HANDLER_ATTR_MAP.vertical), { pickable: !zoomLock }), 'rect');
            this._endHandlerMask = group.createOrUpdateChild('endHandlerMask', Object.assign(Object.assign({ x: position.x + width / 2 + endHandlerWidth / 2, y: position.y + end * height - endHandlerHeight / 2, width: endHandlerHeight, height: endHandlerWidth, fill: 'white', fillOpacity: 0, zIndex: 999 }, DEFAULT_HANDLER_ATTR_MAP.vertical), { pickable: !zoomLock }), 'rect');
        }
        if (this._showText) {
            this.renderText();
        }
    }
    computeBasePoints() {
        const { orient } = this.attribute;
        const { position, width, height } = this.getLayoutAttrFromConfig();
        let basePointStart;
        let basePointEnd;
        if (this._isHorizontal) {
            basePointStart = [
                {
                    x: position.x,
                    y: position.y + height
                }
            ];
            basePointEnd = [
                {
                    x: position.x + width,
                    y: position.y + height
                }
            ];
        }
        else if (orient === 'left') {
            basePointStart = [
                {
                    x: position.x + width,
                    y: position.y
                }
            ];
            basePointEnd = [
                {
                    x: position.x + width,
                    y: position.y + height
                }
            ];
        }
        else {
            basePointStart = [
                {
                    x: position.x,
                    y: position.y + height
                }
            ];
            basePointEnd = [
                {
                    x: position.x,
                    y: position.y
                }
            ];
        }
        return {
            basePointStart,
            basePointEnd
        };
    }
    simplifyPoints(points) {
        var _a;
        const niceCount = 10000;
        if (points.length > niceCount) {
            const tolerance = (_a = this.attribute.tolerance) !== null && _a !== void 0 ? _a : this._previewData.length / niceCount;
            return flatten_simplify(points, tolerance, false);
        }
        return points;
    }
    getPreviewLinePoints() {
        let previewPoints = this._previewData.map(d => {
            return {
                x: this._previewPointsX && this._previewPointsX(d),
                y: this._previewPointsY && this._previewPointsY(d)
            };
        });
        if (previewPoints.length === 0) {
            return previewPoints;
        }
        previewPoints = this.simplifyPoints(previewPoints);
        const { basePointStart, basePointEnd } = this.computeBasePoints();
        return basePointStart.concat(previewPoints).concat(basePointEnd);
    }
    getPreviewAreaPoints() {
        let previewPoints = this._previewData.map(d => {
            return {
                x: this._previewPointsX && this._previewPointsX(d),
                y: this._previewPointsY && this._previewPointsY(d),
                x1: this._previewPointsX1 && this._previewPointsX1(d),
                y1: this._previewPointsY1 && this._previewPointsY1(d)
            };
        });
        if (previewPoints.length === 0) {
            return previewPoints;
        }
        previewPoints = this.simplifyPoints(previewPoints);
        const { basePointStart, basePointEnd } = this.computeBasePoints();
        return basePointStart.concat(previewPoints).concat(basePointEnd);
    }
    setPreviewAttributes(type, group) {
        if (!this._previewGroup) {
            this._previewGroup = group.createOrUpdateChild('previewGroup', { pickable: false }, 'group');
        }
        if (type === 'line') {
            this._previewLine = this._previewGroup.createOrUpdateChild('previewLine', {}, 'line');
        }
        else {
            this._previewArea = this._previewGroup.createOrUpdateChild('previewArea', { curveType: 'basis' }, 'area');
        }
        const { backgroundChartStyle = {} } = this.attribute;
        type === 'line' &&
            this._previewLine.setAttributes(Object.assign({ points: this.getPreviewLinePoints(), curveType: 'basis', pickable: false }, backgroundChartStyle.line));
        type === 'area' &&
            this._previewArea.setAttributes(Object.assign({ points: this.getPreviewAreaPoints(), curveType: 'basis', pickable: false }, backgroundChartStyle.area));
    }
    setSelectedPreviewAttributes(type, group) {
        if (!this._selectedPreviewGroupClip) {
            this._selectedPreviewGroupClip = group.createOrUpdateChild('selectedPreviewGroupClip', { pickable: false }, 'group');
            this._selectedPreviewGroup = this._selectedPreviewGroupClip.createOrUpdateChild('selectedPreviewGroup', {}, 'group');
        }
        if (type === 'line') {
            this._selectedPreviewLine = this._selectedPreviewGroup.createOrUpdateChild('selectedPreviewLine', {}, 'line');
        }
        else {
            this._selectedPreviewArea = this._selectedPreviewGroup.createOrUpdateChild('selectedPreviewArea', { curveType: 'basis' }, 'area');
        }
        const { selectedBackgroundChartStyle = {} } = this.attribute;
        const { start, end } = this.state;
        const { position, width, height } = this.getLayoutAttrFromConfig();
        this._selectedPreviewGroupClip.setAttributes({
            x: this._isHorizontal ? position.x + start * width : position.x,
            y: this._isHorizontal ? position.y : position.y + start * height,
            width: this._isHorizontal ? (end - start) * width : width,
            height: this._isHorizontal ? height : (end - start) * height,
            clip: true,
            pickable: false
        });
        this._selectedPreviewGroup.setAttributes({
            x: -(this._isHorizontal ? position.x + start * width : position.x),
            y: -(this._isHorizontal ? position.y : position.y + start * height),
            width: this._isHorizontal ? (end - start) * width : width,
            height: this._isHorizontal ? height : (end - start) * height,
            pickable: false
        });
        type === 'line' &&
            this._selectedPreviewLine.setAttributes(Object.assign({ points: this.getPreviewLinePoints(), curveType: 'basis', pickable: false }, selectedBackgroundChartStyle.line));
        type === 'area' &&
            this._selectedPreviewArea.setAttributes(Object.assign({ points: this.getPreviewAreaPoints(), curveType: 'basis', pickable: false }, selectedBackgroundChartStyle.area));
    }
    maybeAddLabel(container, attributes, name) {
        let labelShape = this.find(node => node.name === name, true);
        if (labelShape) {
            labelShape.setAttributes(attributes);
        }
        else {
            labelShape = new Tag(attributes);
            labelShape.name = name;
        }
        container.add(labelShape);
        return labelShape;
    }
    setStartAndEnd(start, end) {
        const { start: startAttr, end: endAttr } = this.attribute;
        if (isValid(start) && isValid(end) && (start !== this.state.start || end !== this.state.end)) {
            this.state.start = start;
            this.state.end = end;
            if (startAttr !== this.state.start || endAttr !== this.state.end) {
                this.setStateAttr(start, end, true);
                this._dispatchEvent('change', {
                    start,
                    end,
                    tag: this._activeTag
                });
            }
        }
    }
    setPreviewData(data) {
        this._previewData = data;
    }
    setText(text, tag) {
        if (tag === 'start') {
            this._startText.setAttribute('text', text);
        }
        else {
            this._endText.setAttribute('text', text);
        }
    }
    getStartValue() {
        return this._startValue;
    }
    getEndTextValue() {
        return this._endValue;
    }
    getMiddleHandlerSize() {
        var _a, _b, _c, _d;
        const { middleHandlerStyle = {} } = this.attribute;
        const middleHandlerRectSize = (_b = (_a = middleHandlerStyle.background) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 10;
        const middleHandlerSymbolSize = (_d = (_c = middleHandlerStyle.icon) === null || _c === void 0 ? void 0 : _c.size) !== null && _d !== void 0 ? _d : 10;
        return Math.max(middleHandlerRectSize, ...array(middleHandlerSymbolSize));
    }
    setPreviewPointsX(callback) {
        isFunction(callback) && (this._previewPointsX = callback);
    }
    setPreviewPointsY(callback) {
        isFunction(callback) && (this._previewPointsY = callback);
    }
    setPreviewPointsX1(callback) {
        isFunction(callback) && (this._previewPointsX1 = callback);
    }
    setPreviewPointsY1(callback) {
        isFunction(callback) && (this._previewPointsY1 = callback);
    }
    setStatePointToData(callback) {
        isFunction(callback) && (this._statePointToData = callback);
    }
    release(all) {
        super.release(all);
        (vglobal.env === 'browser' ? vglobal : this.stage).addEventListener('touchmove', this._handleTouchMove, {
            passive: false
        });
        this._clearDragEvents();
    }
}
DataZoom.defaultAttributes = DEFAULT_DATA_ZOOM_ATTRIBUTES;

var IMarkLineLabelPosition;
(function (IMarkLineLabelPosition) {
    IMarkLineLabelPosition["start"] = "start";
    IMarkLineLabelPosition["startTop"] = "startTop";
    IMarkLineLabelPosition["startBottom"] = "startBottom";
    IMarkLineLabelPosition["insideStart"] = "insideStart";
    IMarkLineLabelPosition["insideStartTop"] = "insideStartTop";
    IMarkLineLabelPosition["insideStartBottom"] = "insideStartBottom";
    IMarkLineLabelPosition["middle"] = "middle";
    IMarkLineLabelPosition["insideMiddleTop"] = "insideMiddleTop";
    IMarkLineLabelPosition["insideMiddleBottom"] = "insideMiddleBottom";
    IMarkLineLabelPosition["end"] = "end";
    IMarkLineLabelPosition["endTop"] = "endTop";
    IMarkLineLabelPosition["endBottom"] = "endBottom";
    IMarkLineLabelPosition["insideEnd"] = "insideEnd";
    IMarkLineLabelPosition["insideEndTop"] = "insideEndTop";
    IMarkLineLabelPosition["insideEndBottom"] = "insideEndBottom";
})(IMarkLineLabelPosition || (IMarkLineLabelPosition = {}));
var IMarkAreaLabelPosition;
(function (IMarkAreaLabelPosition) {
    IMarkAreaLabelPosition["left"] = "left";
    IMarkAreaLabelPosition["right"] = "right";
    IMarkAreaLabelPosition["top"] = "top";
    IMarkAreaLabelPosition["bottom"] = "bottom";
    IMarkAreaLabelPosition["topLeft"] = "topLeft";
    IMarkAreaLabelPosition["topRight"] = "topRight";
    IMarkAreaLabelPosition["bottomLeft"] = "bottomLeft";
    IMarkAreaLabelPosition["bottomRight"] = "bottomRight";
    IMarkAreaLabelPosition["middle"] = "middle";
    IMarkAreaLabelPosition["insideLeft"] = "insideLeft";
    IMarkAreaLabelPosition["insideRight"] = "insideRight";
    IMarkAreaLabelPosition["insideTop"] = "insideTop";
    IMarkAreaLabelPosition["insideBottom"] = "insideBottom";
    IMarkAreaLabelPosition["insideTopLeft"] = "insideTopLeft";
    IMarkAreaLabelPosition["insideTopRight"] = "insideTopRight";
    IMarkAreaLabelPosition["insideBottomLeft"] = "insideBottomLeft";
    IMarkAreaLabelPosition["insideBottomRight"] = "insideBottomRight";
})(IMarkAreaLabelPosition || (IMarkAreaLabelPosition = {}));
var IMarkCommonArcLabelPosition;
(function (IMarkCommonArcLabelPosition) {
    IMarkCommonArcLabelPosition["arcInnerStart"] = "arcInnerStart";
    IMarkCommonArcLabelPosition["arcInnerEnd"] = "arcInnerEnd";
    IMarkCommonArcLabelPosition["arcInnerMiddle"] = "arcInnerMiddle";
    IMarkCommonArcLabelPosition["arcOuterStart"] = "arcOuterStart";
    IMarkCommonArcLabelPosition["arcOuterEnd"] = "arcOuterEnd";
    IMarkCommonArcLabelPosition["arcOuterMiddle"] = "arcOuterMiddle";
    IMarkCommonArcLabelPosition["center"] = "center";
})(IMarkCommonArcLabelPosition || (IMarkCommonArcLabelPosition = {}));
var IMarkPointItemPosition;
(function (IMarkPointItemPosition) {
    IMarkPointItemPosition["top"] = "top";
    IMarkPointItemPosition["bottom"] = "bottom";
    IMarkPointItemPosition["middle"] = "middle";
    IMarkPointItemPosition["insideTop"] = "insideTop";
    IMarkPointItemPosition["insideBottom"] = "insideBottom";
    IMarkPointItemPosition["insideMiddle"] = "insideMiddle";
})(IMarkPointItemPosition || (IMarkPointItemPosition = {}));

function loadBaseMarker() {
    registerGroup();
    loadTagComponent();
    registerAnimate();
}
function loadMarkLineComponent() {
    loadBaseMarker();
    loadSegmentComponent();
    registerAnimate();
}
function loadMarkArcLineComponent() {
    loadBaseMarker();
    loadArcSegmentComponent();
    registerAnimate();
}
function loadMarkAreaComponent() {
    loadBaseMarker();
    registerPolygon();
    registerAnimate();
}
function loadMarkArcAreaComponent() {
    loadBaseMarker();
    registerArc();
    registerAnimate();
}
function loadMarkPointComponent() {
    loadBaseMarker();
    loadSegmentComponent();
    loadArcSegmentComponent();
    registerSymbol();
    registerImage();
    registerLine();
    registerAnimate();
}

class Marker extends AbstractComponent {
    constructor() {
        super(...arguments);
        this.name = 'marker';
        this._onHover = (e) => {
            this._lastHover = dispatchHoverState(e, this._container, this._lastHover);
        };
        this._onUnHover = (e) => {
            this._lastHover = dispatchUnHoverState(e, this._container, this._lastHover);
        };
        this._onClick = (e) => {
            this._lastSelect = dispatchClickState(e, this._container, this._lastSelect);
        };
    }
    transAnimationConfig() {
        var _a, _b, _c;
        if (this.attribute.animation !== false) {
            const animation = isObject(this.attribute.animation) ? this.attribute.animation : {};
            this._animationConfig = {
                enter: merge({}, this.defaultUpdateAnimation, animation, (_a = this.attribute.animationEnter) !== null && _a !== void 0 ? _a : {}),
                exit: merge({}, this.defaultExitAnimation, animation, (_b = this.attribute.animationExit) !== null && _b !== void 0 ? _b : {}),
                update: merge({}, this.defaultUpdateAnimation, animation, (_c = this.attribute.animationUpdate) !== null && _c !== void 0 ? _c : {})
            };
        }
    }
    setAttribute(key, value, forceUpdateTag) {
        super.setAttribute(key, value, forceUpdateTag);
        if (key === 'visible') {
            this.render();
        }
    }
    _bindEvent() {
        var _a, _b, _c;
        if (!this.attribute.interactive) {
            return;
        }
        const { hover, select } = this.attribute;
        if (hover) {
            (_a = this._container) === null || _a === void 0 ? void 0 : _a.addEventListener('pointermove', this._onHover);
            (_b = this._container) === null || _b === void 0 ? void 0 : _b.addEventListener('pointerout', this._onUnHover);
        }
        if (select) {
            (_c = this._container) === null || _c === void 0 ? void 0 : _c.addEventListener('pointerdown', this._onClick);
        }
    }
    _releaseEvent() {
        var _a, _b, _c;
        (_a = this._container) === null || _a === void 0 ? void 0 : _a.removeEventListener('pointermove', this._onHover);
        (_b = this._container) === null || _b === void 0 ? void 0 : _b.removeEventListener('pointerout', this._onUnHover);
        (_c = this._container) === null || _c === void 0 ? void 0 : _c.removeEventListener('pointerdown', this._onClick);
    }
    _initContainer() {
        var _a, _b;
        const { limitRect = {}, clipInRange } = this.attribute;
        let group;
        if (clipInRange) {
            const groupClip = graphicCreator.group(Object.assign(Object.assign({}, limitRect), { clip: true, pickable: false }));
            group = graphicCreator.group({
                x: -((_a = limitRect.x) !== null && _a !== void 0 ? _a : 0),
                y: -((_b = limitRect.y) !== null && _b !== void 0 ? _b : 0),
                pickable: false
            });
            groupClip.add(group);
            this._containerClip = groupClip;
            this.add(groupClip);
        }
        else {
            group = graphicCreator.group({
                x: 0,
                y: 0,
                pickable: false
            });
            this.add(group);
        }
        group.name = 'marker-container';
        this._container = group;
    }
    _updateContainer() {
        var _a, _b;
        const { limitRect = {}, clipInRange } = this.attribute;
        if (this._containerClip) {
            this._containerClip.setAttributes(Object.assign({}, limitRect));
        }
        this._container.setAttributes({
            x: clipInRange ? -((_a = limitRect.x) !== null && _a !== void 0 ? _a : 0) : 0,
            y: clipInRange ? -((_b = limitRect.y) !== null && _b !== void 0 ? _b : 0) : 0
        });
    }
    render() {
        var _a;
        this.transAnimationConfig();
        this.setAttribute('pickable', false);
        const markerVisible = (_a = this.attribute.visible) !== null && _a !== void 0 ? _a : true;
        if (this.attribute.interactive === false) {
            this.setAttribute('childrenPickable', false);
        }
        if (markerVisible && this.isValidPoints()) {
            if (!this._container) {
                this._initContainer();
                this.initMarker(this._container);
                this.markerAnimate('enter');
            }
            else {
                this._updateContainer();
                this.updateMarker();
                this.markerAnimate('update');
            }
        }
        else {
            this.markerAnimate('exit');
            this._container = null;
            this.removeAllChild(true);
        }
        this._releaseEvent();
        this._bindEvent();
    }
    release() {
        this.markerAnimate('exit');
        super.release();
        this._releaseEvent();
        this._container = null;
    }
}

function graphicFadeIn(graphic, delay, duration, easing) {
    var _a, _b, _c, _d, _e;
    if (!graphic) {
        return;
    }
    (_a = graphic === null || graphic === void 0 ? void 0 : graphic.animates) === null || _a === void 0 ? void 0 : _a.forEach(a => a.stop('end'));
    const fillOpacityConfig = (_c = (_b = graphic.attribute) === null || _b === void 0 ? void 0 : _b.fillOpacity) !== null && _c !== void 0 ? _c : 1;
    const strokeOpacityConfig = (_e = (_d = graphic.attribute) === null || _d === void 0 ? void 0 : _d.strokeOpacity) !== null && _e !== void 0 ? _e : 1;
    graphic.setAttributes({
        fillOpacity: 0,
        strokeOpacity: 0
    });
    graphic.animate().wait(delay).to({
        fillOpacity: fillOpacityConfig,
        strokeOpacity: strokeOpacityConfig
    }, duration, easing);
}
function segmentFadeIn(segment, delay, duration, easing) {
    if (!segment) {
        return;
    }
    graphicFadeIn(segment.startSymbol, delay, duration, easing);
    segment.lines.forEach(line => graphicFadeIn(line, delay, duration, easing));
    graphicFadeIn(segment.line, delay, duration, easing);
    graphicFadeIn(segment.endSymbol, delay, duration, easing);
}
function tagFadeIn(tag, delay, duration, easing) {
    if (!tag) {
        return;
    }
    graphicFadeIn(tag.getTextShape(), delay, duration, easing);
    graphicFadeIn(tag.getBgRect(), delay, duration, easing);
}
function graphicFadeOut(graphic, delay, duration, easing) {
    var _a, _b, _c, _d;
    if (!graphic) {
        return;
    }
    graphic.setAttributes({
        fillOpacity: (_b = (_a = graphic.attribute) === null || _a === void 0 ? void 0 : _a.fillOpacity) !== null && _b !== void 0 ? _b : 1,
        strokeOpacity: (_d = (_c = graphic.attribute) === null || _c === void 0 ? void 0 : _c.strokeOpacity) !== null && _d !== void 0 ? _d : 1
    });
    graphic.animate().wait(delay).to({ fillOpacity: 0, strokeOpacity: 0 }, duration, easing);
}
function segmentFadeOut(segment, delay, duration, easing) {
    if (!segment) {
        return;
    }
    graphicFadeOut(segment.startSymbol, delay, duration, easing);
    segment.lines.forEach(line => graphicFadeOut(line, delay, duration, easing));
    graphicFadeOut(segment.line, delay, duration, easing);
    graphicFadeOut(segment.endSymbol, delay, duration, easing);
}
function tagFadeOut(tag, delay, duration, easing) {
    if (!tag) {
        return;
    }
    graphicFadeOut(tag.getTextShape(), delay, duration, easing);
    graphicFadeOut(tag.getBgRect(), delay, duration, easing);
}

function commonLineClipIn(line, label, duration, delay, easing) {
    const startSymbolDuration = 0.1 * duration;
    const lineDuration = 0.7 * duration;
    const endSymbolDuration = 0.1 * duration;
    const labelDuration = 0.1 * duration;
    graphicFadeIn(line.startSymbol, delay, startSymbolDuration, easing);
    line.lines.forEach(line => line.setAttribute('clipRange', 0));
    line.lines.forEach((l, index) => {
        const stepDuration = lineDuration / line.lines.length;
        l.animate()
            .wait(delay + startSymbolDuration + index * stepDuration)
            .to({ clipRange: 1 }, stepDuration, easing);
    });
    graphicFadeIn(line.endSymbol, delay + startSymbolDuration + lineDuration, endSymbolDuration, easing);
    array(label).forEach(labelNode => {
        const delayTime = delay + startSymbolDuration + lineDuration + endSymbolDuration;
        graphicFadeIn(labelNode.getTextShape(), delayTime, labelDuration, easing);
        graphicFadeIn(labelNode.getBgRect(), delayTime, labelDuration, easing);
    });
}

function commonLineFadeIn(line, label, duration, delay, easing) {
    segmentFadeIn(line, delay, duration, easing);
    array(label).forEach(labelNode => {
        tagFadeIn(labelNode, delay, duration, easing);
    });
}
function areaFadeIn(area, label, duration, delay, easing) {
    graphicFadeIn(area, delay, duration, easing);
    array(label).forEach(labelNode => {
        tagFadeIn(labelNode, delay, duration, easing);
    });
}
function arcAreaFadeIn(area, label, duration, delay, easing) {
    graphicFadeIn(area, delay, duration, easing);
    array(label).forEach(labelNode => {
        tagFadeIn(labelNode, delay, duration, easing);
    });
}
function pointFadeIn(itemLine, decorativeLine, item, duration, delay, easing) {
    var _a;
    segmentFadeIn(itemLine, delay, duration, easing);
    graphicFadeIn(decorativeLine, delay, duration, easing);
    if ((_a = item.getTextShape) === null || _a === void 0 ? void 0 : _a.call(item)) {
        tagFadeIn(item, delay, duration, easing);
    }
    else {
        graphicFadeIn(item, delay, duration, easing);
    }
}

function commonLineFadeOut(line, label, duration, delay, easing) {
    segmentFadeOut(line, delay, duration, easing);
    array(label).forEach(labelNode => {
        tagFadeOut(labelNode, delay, duration, easing);
    });
}
function areaFadeOut(area, label, duration, delay, easing) {
    graphicFadeOut(area, delay, duration, easing);
    array(label).forEach(labelNode => {
        tagFadeOut(labelNode, delay, duration, easing);
    });
}
function arcAreaFadeOut(area, label, duration, delay, easing) {
    graphicFadeOut(area, delay, duration, easing);
    array(label).forEach(labelNode => {
        tagFadeOut(labelNode, delay, duration, easing);
    });
}
function pointFadeOut(itemLine, decorativeLine, item, duration, delay, easing) {
    var _a;
    segmentFadeOut(itemLine, delay, duration, easing);
    graphicFadeOut(decorativeLine, delay, duration, easing);
    if ((_a = item.getTextShape) === null || _a === void 0 ? void 0 : _a.call(item)) {
        tagFadeOut(item, delay, duration, easing);
    }
    else {
        graphicFadeOut(item, delay, duration, easing);
    }
}

function pointCallIn(itemLine, decorativeLine, item, duration, delay, easing) {
    var _a;
    const startSymbolDuration = 0.1 * duration;
    const lineDuration = 0.65 * duration;
    const decorativeDuration = 0.05 * duration;
    const endSymbolDuration = 0.1 * duration;
    const labelDuration = 0.1 * duration;
    graphicFadeIn(itemLine.startSymbol, delay, startSymbolDuration, easing);
    itemLine.lines.forEach(line => line.setAttribute('clipRange', 0));
    itemLine.lines.forEach((l, index) => {
        const stepDuration = lineDuration / itemLine.lines.length;
        l.animate()
            .wait(delay + startSymbolDuration + index * stepDuration)
            .to({ clipRange: 1 }, stepDuration, easing);
    });
    graphicFadeIn(decorativeLine, delay + startSymbolDuration + lineDuration, decorativeDuration, easing);
    graphicFadeIn(itemLine.endSymbol, delay + startSymbolDuration + lineDuration + decorativeDuration, endSymbolDuration, easing);
    if ((_a = item.getTextShape) === null || _a === void 0 ? void 0 : _a.call(item)) {
        graphicFadeIn(item.getTextShape(), delay + startSymbolDuration + lineDuration + decorativeDuration + endSymbolDuration, labelDuration, easing);
        graphicFadeIn(item.getBgRect(), delay + startSymbolDuration + lineDuration + endSymbolDuration, labelDuration, easing);
    }
    else {
        graphicFadeIn(item, delay + startSymbolDuration + lineDuration + endSymbolDuration, labelDuration, easing);
    }
}

function markCommonLineAnimate(line, label, animationconfig, state) {
    const { enter, update, exit } = animationconfig;
    if (state === 'enter') {
        const { type, duration, delay, easing } = enter;
        if (type === 'clipIn') {
            commonLineClipIn(line, label, duration, delay, easing);
        }
        else if (type === 'fadeIn') {
            commonLineFadeIn(line, label, duration, delay, easing);
        }
    }
    else if (state === 'update') {
        const { type, duration, delay, easing } = update;
        if (type === 'clipIn') {
            commonLineClipIn(line, label, duration, delay, easing);
        }
        else if (type === 'fadeIn') {
            commonLineFadeIn(line, label, duration, delay, easing);
        }
    }
    else if (state === 'exit') {
        const { duration, delay, easing } = exit;
        commonLineFadeOut(line, label, duration, delay, easing);
    }
}
function markAreaAnimate(area, label, animationconfig, state) {
    const { enter, update, exit } = animationconfig;
    if (state === 'enter') {
        const { type, duration, delay, easing } = enter;
        if (type === 'fadeIn') {
            areaFadeIn(area, label, duration, delay, easing);
        }
    }
    else if (state === 'update') {
        const { type, duration, delay, easing } = update;
        if (type === 'fadeIn') {
            areaFadeIn(area, label, duration, delay, easing);
        }
    }
    else if (state === 'exit') {
        const { duration, delay, easing } = exit;
        areaFadeOut(area, label, duration, delay, easing);
    }
}
function markArcAreaAnimate(area, label, animationconfig, state) {
    const { enter, update, exit } = animationconfig;
    if (state === 'enter') {
        const { type, duration, delay, easing } = enter;
        if (type === 'fadeIn') {
            arcAreaFadeIn(area, label, duration, delay, easing);
        }
    }
    else if (state === 'update') {
        const { type, duration, delay, easing } = update;
        if (type === 'fadeIn') {
            arcAreaFadeIn(area, label, duration, delay, easing);
        }
    }
    else if (state === 'exit') {
        const { duration, delay, easing } = exit;
        arcAreaFadeOut(area, label, duration, delay, easing);
    }
}
function markPointAnimate(lines, item, animationconfig, state) {
    const [itemLine, decorativeLine] = lines;
    const { enter, update, exit } = animationconfig;
    if (state === 'enter') {
        const { type, duration, delay, easing } = enter;
        if (type === 'fadeIn') {
            pointFadeIn(itemLine, decorativeLine, item, duration, delay, easing);
        }
        else if (type === 'callIn') {
            pointCallIn(itemLine, decorativeLine, item, duration, delay, easing);
        }
    }
    else if (state === 'update') {
        const { type, duration, delay, easing } = update;
        if (type === 'fadeIn') {
            pointFadeIn(itemLine, decorativeLine, item, duration, delay, easing);
        }
        else if (type === 'callIn') {
            pointCallIn(itemLine, decorativeLine, item, duration, delay, easing);
        }
    }
    else if (state === 'exit') {
        const { duration, delay, easing } = exit;
        pointFadeOut(itemLine, decorativeLine, item, duration, delay, easing);
    }
}
const DefaultUpdateMarkLineAnimation = {
    type: 'clipIn',
    duration: 500,
    easing: 'linear',
    delay: 0
};
const DefaultUpdateMarkAreaAnimation = {
    type: 'fadeIn',
    duration: 500,
    easing: 'linear',
    delay: 0
};
const DefaultUpdateMarkPointAnimation = {
    type: 'callIn',
    duration: 500,
    easing: 'linear',
    delay: 0
};
const DefaultExitMarkerAnimation = {
    type: 'fadeOut',
    duration: 500,
    easing: 'linear',
    delay: 0
};

class MarkLabelMixin {
    getLabel() {
        return this._label;
    }
    _addMarkLabels(container, labelName, defaultLabelAttrs) {
        const { label, state } = this.attribute;
        const labelStates = array(state === null || state === void 0 ? void 0 : state.label);
        const labelBackgroundStates = array(state === null || state === void 0 ? void 0 : state.labelBackground);
        const labelShapes = array(label).map((labelAttrs, index) => {
            var _a, _b;
            const finalLabelAttrs = merge({}, defaultLabelAttrs, labelAttrs);
            const markLabel = new Tag(Object.assign(Object.assign({}, finalLabelAttrs), { state: {
                    panel: merge({}, DEFAULT_STATES$2, (_a = labelBackgroundStates[index]) !== null && _a !== void 0 ? _a : last(labelBackgroundStates)),
                    text: merge({}, DEFAULT_STATES$2, (_b = labelStates[index]) !== null && _b !== void 0 ? _b : last(labelStates))
                } }));
            markLabel.name = labelName;
            container.add(markLabel);
            this.setLabelPos(markLabel, finalLabelAttrs);
            return markLabel;
        });
        this._label = array(labelShapes).length === 1 ? labelShapes[0] : labelShapes;
    }
    _updateMarkLabels(defaultLabelAttrs) {
        const { label, state } = this.attribute;
        const labelShapes = array(this._label);
        const labelStates = array(state === null || state === void 0 ? void 0 : state.label);
        const labelBackgroundStates = array(state === null || state === void 0 ? void 0 : state.labelBackground);
        if (labelShapes.length) {
            const labels = array(label);
            labelShapes.forEach((labelItem, index) => {
                var _a, _b;
                const finalLabelAttrs = merge({}, defaultLabelAttrs, labels[index]);
                labelItem.setAttributes(Object.assign(Object.assign({ dx: 0, dy: 0 }, finalLabelAttrs), { state: {
                        panel: merge({}, DEFAULT_STATES$2, (_a = labelBackgroundStates[index]) !== null && _a !== void 0 ? _a : last(labelBackgroundStates)),
                        text: merge({}, DEFAULT_STATES$2, (_b = labelStates[index]) !== null && _b !== void 0 ? _b : last(labelStates))
                    } }));
                this.setLabelPos(labelItem, finalLabelAttrs);
            });
        }
    }
}

class MarkCommonLine extends Marker {
    constructor() {
        super(...arguments);
        this.name = 'markCommonLine';
        this.defaultUpdateAnimation = DefaultUpdateMarkLineAnimation;
        this.defaultExitAnimation = DefaultExitMarkerAnimation;
    }
    getLine() {
        return this._line;
    }
    setLabelPos(labelNode, labelAttrs) {
        const { limitRect } = this.attribute;
        const { position, confine, autoRotate } = labelAttrs;
        const labelPoint = this.getPointAttrByPosition(position, labelAttrs);
        const labelAngle = position.toString().toLocaleLowerCase().includes('start')
            ? this._line.getStartAngle() || 0
            : this._line.getEndAngle() || 0;
        labelNode.setAttributes(Object.assign(Object.assign({}, labelPoint.position), { angle: autoRotate ? this.getRotateByAngle(labelPoint.angle, labelAttrs) : 0, textStyle: Object.assign(Object.assign({}, this.getTextStyle(position, labelAngle, autoRotate)), labelAttrs.textStyle) }));
        if (limitRect && confine) {
            const { x, y, width, height } = limitRect;
            limitShapeInBounds(labelNode, {
                x1: x,
                y1: y,
                x2: x + width,
                y2: y + height
            });
        }
    }
    initMarker(container) {
        const line = this.createSegment();
        line.name = 'mark-common-line-line';
        this._line = line;
        container.add(line);
        this.addMarkLineLabels(container);
    }
    updateMarker() {
        this.setLineAttributes();
        this.updateMarkLineLabels();
    }
}
mixin(MarkCommonLine, MarkLabelMixin);

const FUZZY_EQUAL_DELTA = 0.001;
const DEFAULT_MARK_LINE_THEME = {
    interactive: true,
    startSymbol: {
        visible: false,
        symbolType: 'triangle',
        size: 12,
        fill: 'rgba(46, 47, 50)',
        lineWidth: 0
    },
    endSymbol: {
        visible: true,
        symbolType: 'triangle',
        size: 12,
        fill: 'rgba(46, 47, 50)',
        lineWidth: 0
    },
    label: {
        position: IMarkLineLabelPosition.end,
        refX: 0,
        refY: 0,
        refAngle: 0,
        textStyle: {
            fill: '#fff',
            stroke: '#fff',
            lineWidth: 0,
            fontSize: 10,
            fontWeight: 'normal',
            fontStyle: 'normal'
        },
        padding: [2, 2, 4, 4],
        panel: {
            visible: true,
            cornerRadius: 0,
            fill: 'rgb(48, 115, 242)',
            fillOpacity: 0.8
        }
    },
    lineStyle: {
        stroke: '#b2bacf',
        lineWidth: 1,
        lineDash: [2]
    }
};
const DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP = {
    postiveXAxis: {
        start: {
            textAlign: 'left',
            textBaseline: 'middle'
        },
        startTop: {
            textAlign: 'left',
            textBaseline: 'bottom'
        },
        startBottom: {
            textAlign: 'left',
            textBaseline: 'top'
        },
        insideStart: {
            textAlign: 'right',
            textBaseline: 'middle'
        },
        insideStartTop: {
            textAlign: 'right',
            textBaseline: 'bottom'
        },
        insideStartBottom: {
            textAlign: 'right',
            textBaseline: 'top'
        },
        middle: {
            textAlign: 'center',
            textBaseline: 'middle'
        },
        insideMiddleTop: {
            textAlign: 'center',
            textBaseline: 'bottom'
        },
        insideMiddleBottom: {
            textAlign: 'center',
            textBaseline: 'top'
        },
        end: {
            textAlign: 'left',
            textBaseline: 'middle'
        },
        endTop: {
            textAlign: 'left',
            textBaseline: 'bottom'
        },
        endBottom: {
            textAlign: 'left',
            textBaseline: 'top'
        },
        insideEnd: {
            textAlign: 'right',
            textBaseline: 'middle'
        },
        insideEndTop: {
            textAlign: 'right',
            textBaseline: 'bottom'
        },
        insideEndBottom: {
            textAlign: 'right',
            textBaseline: 'top'
        }
    },
    negativeXAxis: {
        start: {
            textAlign: 'right',
            textBaseline: 'middle'
        },
        startTop: {
            textAlign: 'right',
            textBaseline: 'bottom'
        },
        startBottom: {
            textAlign: 'right',
            textBaseline: 'top'
        },
        insideStart: {
            textAlign: 'left',
            textBaseline: 'middle'
        },
        insideStartTop: {
            textAlign: 'left',
            textBaseline: 'bottom'
        },
        insideStartBottom: {
            textAlign: 'left',
            textBaseline: 'top'
        },
        middle: {
            textAlign: 'center',
            textBaseline: 'middle'
        },
        insideMiddleTop: {
            textAlign: 'center',
            textBaseline: 'bottom'
        },
        insideMiddleBottom: {
            textAlign: 'center',
            textBaseline: 'top'
        },
        end: {
            textAlign: 'right',
            textBaseline: 'middle'
        },
        endTop: {
            textAlign: 'right',
            textBaseline: 'bottom'
        },
        endBottom: {
            textAlign: 'right',
            textBaseline: 'top'
        },
        insideEnd: {
            textAlign: 'left',
            textBaseline: 'middle'
        },
        insideEndTop: {
            textAlign: 'left',
            textBaseline: 'bottom'
        },
        insideEndBottom: {
            textAlign: 'left',
            textBaseline: 'top'
        }
    }
};
const DEFAULT_MARK_ARC_LINE_THEME = {
    interactive: true,
    startSymbol: {
        visible: false,
        symbolType: 'triangle',
        size: 12,
        fill: 'rgba(46, 47, 50)',
        lineWidth: 0
    },
    endSymbol: {
        visible: true,
        symbolType: 'triangle',
        size: 12,
        fill: 'rgba(46, 47, 50)',
        lineWidth: 0
    },
    label: {
        autoRotate: true,
        position: IMarkCommonArcLabelPosition.arcOuterMiddle,
        refX: 0,
        refY: 0,
        refAngle: 0,
        textStyle: {
            fill: '#fff',
            stroke: '#fff',
            lineWidth: 0,
            fontSize: 10,
            fontWeight: 'normal',
            fontStyle: 'normal'
        },
        padding: [2, 2, 4, 4],
        panel: {
            visible: true,
            cornerRadius: 0,
            fill: 'rgb(48, 115, 242)',
            fillOpacity: 0.8
        }
    },
    lineStyle: {
        stroke: '#b2bacf',
        lineWidth: 1,
        lineDash: [2]
    }
};
const DEFAULT_MARK_AREA_THEME = {
    interactive: true,
    label: {
        position: IMarkAreaLabelPosition.right,
        textStyle: {
            fill: '#fff',
            stroke: '#fff',
            lineWidth: 0,
            fontSize: 10,
            fontWeight: 'normal',
            fontStyle: 'normal'
        },
        padding: [2, 2, 4, 4],
        panel: {
            visible: true,
            cornerRadius: 0,
            fill: 'rgb(48, 115, 242)',
            fillOpacity: 0.8
        }
    },
    areaStyle: {
        fill: '#b2bacf',
        visible: true
    }
};
const DEFAULT_MARK_ARC_AREA_THEME = {
    interactive: true,
    label: {
        autoRotate: true,
        position: IMarkCommonArcLabelPosition.arcOuterMiddle,
        textStyle: {
            fill: '#fff',
            stroke: '#fff',
            lineWidth: 0,
            fontSize: 10,
            fontWeight: 'normal',
            fontStyle: 'normal'
        },
        padding: [2, 2, 4, 4],
        panel: {
            visible: true,
            cornerRadius: 0,
            fill: 'rgb(48, 115, 242)',
            fillOpacity: 0.8
        }
    },
    areaStyle: {
        fill: '#b2bacf',
        visible: true
    }
};
const DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP = {
    arcInnerStart: {
        textAlign: 'center',
        textBaseline: 'bottom'
    },
    arcInnerEnd: {
        textAlign: 'center',
        textBaseline: 'bottom'
    },
    arcInnerMiddle: {
        textAlign: 'center',
        textBaseline: 'bottom'
    },
    arcOuterStart: {
        textAlign: 'center',
        textBaseline: 'top'
    },
    arcOuterEnd: {
        textAlign: 'center',
        textBaseline: 'top'
    },
    arcOuterMiddle: {
        textAlign: 'center',
        textBaseline: 'top'
    },
    center: {
        textAlign: 'center',
        textBaseline: 'middle'
    }
};
const DEFAULT_CARTESIAN_MARK_AREA_TEXT_STYLE_MAP = {
    left: {
        textAlign: 'right',
        textBaseline: 'middle'
    },
    insideLeft: {
        textAlign: 'left',
        textBaseline: 'middle'
    },
    right: {
        textAlign: 'left',
        textBaseline: 'middle'
    },
    insideRight: {
        textAlign: 'right',
        textBaseline: 'middle'
    },
    top: {
        textAlign: 'center',
        textBaseline: 'bottom'
    },
    insideTop: {
        textAlign: 'center',
        textBaseline: 'top'
    },
    bottom: {
        textAlign: 'center',
        textBaseline: 'top'
    },
    insideBottom: {
        textAlign: 'center',
        textBaseline: 'bottom'
    },
    middle: {
        textAlign: 'center',
        textBaseline: 'middle'
    },
    topLeft: {
        textAlign: 'right',
        textBaseline: 'top'
    },
    insideTopLeft: {
        textAlign: 'left',
        textBaseline: 'top'
    },
    topRight: {
        textAlign: 'left',
        textBaseline: 'top'
    },
    insideTopRight: {
        textAlign: 'right',
        textBaseline: 'top'
    },
    bottomLeft: {
        textAlign: 'right',
        textBaseline: 'bottom'
    },
    insideBottomLeft: {
        textAlign: 'left',
        textBaseline: 'bottom'
    },
    bottomRight: {
        textAlign: 'left',
        textBaseline: 'bottom'
    },
    insideBottomRight: {
        textAlign: 'right',
        textBaseline: 'bottom'
    }
};
const DEFAULT_MARK_POINT_THEME = {
    interactive: true,
    targetSymbol: {
        visible: false,
        offset: 0,
        style: {
            symbolType: 'circle',
            size: 20,
            fill: false,
            stroke: 'rgba(46, 47, 50)'
        }
    },
    itemLine: {
        visible: true,
        decorativeLine: {
            visible: false,
            length: 30
        },
        startSymbol: {
            visible: true,
            clip: true,
            symbolType: 'circle',
            size: 20,
            style: {
                fill: false,
                stroke: 'rgba(46, 47, 50)'
            }
        },
        endSymbol: {
            visible: false,
            clip: true,
            symbolType: 'triangle',
            size: 12,
            style: {
                fill: false,
                stroke: 'rgba(46, 47, 50)'
            }
        },
        lineStyle: {
            stroke: '#000',
            lineWidth: 1
        }
    },
    itemContent: {
        type: 'text',
        position: 'middle',
        refX: 10
    }
};
const DEFAULT_MARK_POINT_TEXT_STYLE_MAP = {
    postiveXAxis: {
        top: {
            textAlign: 'left',
            textBaseline: 'bottom'
        },
        bottom: {
            textAlign: 'left',
            textBaseline: 'top'
        },
        middle: {
            textAlign: 'left',
            textBaseline: 'middle'
        },
        insideTop: {
            textAlign: 'right',
            textBaseline: 'bottom'
        },
        insideBottom: {
            textAlign: 'right',
            textBaseline: 'top'
        },
        insideMiddle: {
            textAlign: 'right',
            textBaseline: 'middle'
        }
    },
    negativeXAxis: {
        top: {
            textAlign: 'right',
            textBaseline: 'bottom'
        },
        bottom: {
            textAlign: 'right',
            textBaseline: 'top'
        },
        middle: {
            textAlign: 'right',
            textBaseline: 'middle'
        },
        insideTop: {
            textAlign: 'left',
            textBaseline: 'bottom'
        },
        insideBottom: {
            textAlign: 'left',
            textBaseline: 'top'
        },
        insideMiddle: {
            textAlign: 'left',
            textBaseline: 'middle'
        }
    }
};

loadMarkLineComponent();
function registerMarkLineAnimate() {
    MarkLine._animate = markCommonLineAnimate;
}
class MarkLine extends MarkCommonLine {
    markerAnimate(state) {
        if (MarkLine._animate && this._animationConfig) {
            MarkLine._animate(this._line, this._label, this._animationConfig, state);
        }
    }
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, MarkLine.defaultAttributes, attributes));
        this.name = 'markLine';
    }
    getPointAttrByPosition(position, labelAttrs) {
        var _a;
        const { refX = 0, refY = 0 } = labelAttrs;
        const points = this._line.getMainSegmentPoints();
        const lineEndAngle = (_a = this._line.getEndAngle()) !== null && _a !== void 0 ? _a : 0;
        const labelAngle = isPostiveXAxis(lineEndAngle) ? lineEndAngle : lineEndAngle;
        const labelOffsetX = refX * Math.cos(labelAngle) + refY * Math.cos(labelAngle - Math.PI / 2);
        const labelOffsetY = refX * Math.sin(labelAngle) + refY * Math.sin(labelAngle - Math.PI / 2);
        if (position.includes('start') || position.includes('Start')) {
            return {
                position: {
                    x: points[0].x + labelOffsetX,
                    y: points[0].y + labelOffsetY
                },
                angle: labelAngle
            };
        }
        else if (position.includes('middle') || position.includes('Middle')) {
            return {
                position: {
                    x: (points[0].x + points[points.length - 1].x) / 2 + labelOffsetX,
                    y: (points[0].y + points[points.length - 1].y) / 2 + labelOffsetY
                },
                angle: labelAngle
            };
        }
        return {
            position: {
                x: points[points.length - 1].x + labelOffsetX,
                y: points[points.length - 1].y + labelOffsetY
            },
            angle: labelAngle
        };
    }
    getRotateByAngle(angle, labelAttrs) {
        var _a;
        const itemAngle = isPostiveXAxis(angle) ? angle : angle - Math.PI;
        return itemAngle + ((_a = labelAttrs.refAngle) !== null && _a !== void 0 ? _a : 0);
    }
    getTextStyle(position, labelAngle, autoRotate) {
        if (fuzzyEqualNumber(Math.abs(labelAngle), Math.PI / 2, FUZZY_EQUAL_DELTA) ||
            fuzzyEqualNumber(Math.abs(labelAngle), (Math.PI * 3) / 2, FUZZY_EQUAL_DELTA)) {
            return getTextAlignAttrOfVerticalDir(autoRotate, labelAngle, position);
        }
        if (isPostiveXAxis(labelAngle)) {
            return DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP.postiveXAxis[position];
        }
        return DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP.negativeXAxis[position];
    }
    createSegment() {
        const { points, startSymbol, endSymbol, lineStyle, mainSegmentIndex, multiSegment, state } = this
            .attribute;
        return new Segment({
            points,
            startSymbol,
            endSymbol,
            lineStyle,
            mainSegmentIndex,
            multiSegment,
            pickable: false,
            state: {
                line: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.line),
                startSymbol: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.lineStartSymbol),
                endSymbol: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.lineEndSymbol)
            }
        });
    }
    setLineAttributes() {
        const { points, startSymbol, endSymbol, lineStyle, mainSegmentIndex, multiSegment, state } = this
            .attribute;
        if (this._line) {
            this._line.setAttributes({
                points,
                startSymbol,
                endSymbol,
                lineStyle,
                mainSegmentIndex,
                multiSegment,
                state: {
                    line: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.line),
                    startSymbol: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.lineStartSymbol),
                    endSymbol: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.lineEndSymbol)
                }
            });
        }
    }
    isValidPoints() {
        const { points } = this.attribute;
        if (!points || points.length < 2) {
            return false;
        }
        let validFlag = true;
        points.forEach((point) => {
            if (point.length) {
                point.forEach((p) => {
                    if (!isValidNumber(p.x) || !isValidNumber(p.y)) {
                        validFlag = false;
                        return;
                    }
                });
            }
            else if (!isValidNumber(point.x) || !isValidNumber(point.y)) {
                validFlag = false;
                return;
            }
        });
        return validFlag;
    }
    addMarkLineLabels(container) {
        this._addMarkLabels(container, 'mark-common-line-label', MarkLine.defaultAttributes.label);
    }
    updateMarkLineLabels() {
        this._updateMarkLabels(MarkLine.defaultAttributes.label);
    }
}
MarkLine.defaultAttributes = DEFAULT_MARK_LINE_THEME;

loadMarkAreaComponent();
function registerMarkAreaAnimate() {
    MarkArea._animate = markAreaAnimate;
}
class MarkArea extends Marker {
    markerAnimate(state) {
        if (MarkArea._animate && this._animationConfig) {
            MarkArea._animate(this._area, this._label, this._animationConfig, state);
        }
    }
    getArea() {
        return this._area;
    }
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, MarkArea.defaultAttributes, attributes));
        this.name = 'markArea';
        this.defaultUpdateAnimation = DefaultUpdateMarkAreaAnimation;
        this.defaultExitAnimation = DefaultExitMarkerAnimation;
    }
    getPointAttrByPosition(position) {
        const { x1, x2, y1, y2 } = this._area.AABBBounds;
        const result = {
            x: (x1 + x2) / 2,
            y: (y1 + y2) / 2
        };
        if (position.includes('left') || position.includes('Left')) {
            result.x = x1;
        }
        if (position.includes('right') || position.includes('Right')) {
            result.x = x2;
        }
        if (position.includes('top') || position.includes('Top')) {
            result.y = y1;
        }
        if (position.includes('bottom') || position.includes('Bottom')) {
            result.y = y2;
        }
        return result;
    }
    setLabelPos(labelNode, labelAttrs) {
        var _a;
        if (this._area) {
            const labelPosition = (_a = labelAttrs.position) !== null && _a !== void 0 ? _a : 'middle';
            const labelPoint = this.getPointAttrByPosition(labelPosition);
            labelNode.setAttributes(Object.assign(Object.assign({}, labelPoint), { textStyle: Object.assign(Object.assign({}, DEFAULT_CARTESIAN_MARK_AREA_TEXT_STYLE_MAP[labelPosition]), labelAttrs.textStyle) }));
            if (this.attribute.limitRect && labelAttrs.confine) {
                const { x, y, width, height } = this.attribute.limitRect;
                limitShapeInBounds(labelNode, {
                    x1: x,
                    y1: y,
                    x2: x + width,
                    y2: y + height
                });
            }
        }
    }
    initMarker(container) {
        const { points, areaStyle, state } = this.attribute;
        const area = graphicCreator.polygon(Object.assign({ points: points }, areaStyle));
        area.states = merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.area);
        area.name = 'mark-area-polygon';
        this._area = area;
        container.add(area);
        this._addMarkLabels(container, 'mark-area-label', MarkArea.defaultAttributes.label);
    }
    updateMarker() {
        const { points, areaStyle, state } = this.attribute;
        if (this._area) {
            this._area.setAttributes(Object.assign({ points: points }, areaStyle));
            this._area.states = merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.area);
        }
        this._updateMarkLabels(MarkArea.defaultAttributes.label);
    }
    isValidPoints() {
        const { points } = this.attribute;
        if (!points || points.length < 3) {
            return false;
        }
        let validFlag = true;
        points.forEach((point) => {
            if (!isValidNumber(point.x) || !isValidNumber(point.y)) {
                validFlag = false;
                return;
            }
        });
        return validFlag;
    }
}
MarkArea.defaultAttributes = DEFAULT_MARK_AREA_THEME;
mixin(MarkArea, MarkLabelMixin);

loadMarkArcLineComponent();
function registerMarkArcLineAnimate() {
    MarkArcLine._animate = markCommonLineAnimate;
}
class MarkArcLine extends MarkCommonLine {
    markerAnimate(state) {
        if (MarkArcLine._animate && this._animationConfig) {
            MarkArcLine._animate(this._line, this._label, this._animationConfig, state);
        }
    }
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, MarkArcLine.defaultAttributes, attributes));
        this.name = 'markArcLine';
    }
    getPointAttrByPosition(direction, labelAttrs) {
        const { center, radius, startAngle, endAngle } = this.attribute;
        const { refX = 0, refY = 0 } = labelAttrs;
        let angle;
        switch (direction) {
            case IMarkCommonArcLabelPosition.arcInnerStart:
                angle = startAngle;
            case IMarkCommonArcLabelPosition.arcOuterStart:
                angle = startAngle;
                break;
            case IMarkCommonArcLabelPosition.arcInnerEnd:
                angle = endAngle;
            case IMarkCommonArcLabelPosition.arcOuterEnd:
                angle = endAngle;
                break;
            case IMarkCommonArcLabelPosition.center:
            case IMarkCommonArcLabelPosition.arcInnerMiddle:
            case IMarkCommonArcLabelPosition.arcOuterMiddle:
                angle = (startAngle + endAngle) / 2;
                break;
            default:
                angle = (startAngle + endAngle) / 2;
        }
        return {
            position: {
                x: center.x + (radius + refY) * Math.cos(angle) + refX * Math.cos(angle - Math.PI / 2),
                y: center.y + (radius + refY) * Math.sin(angle) + refX * Math.sin(angle - Math.PI / 2)
            },
            angle
        };
    }
    getTextStyle(position) {
        return DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP[position];
    }
    getRotateByAngle(angle, labelAttrs) {
        var _a;
        return angle - Math.PI / 2 + ((_a = labelAttrs.refAngle) !== null && _a !== void 0 ? _a : 0);
    }
    createSegment() {
        const { center, radius, startAngle, endAngle, startSymbol, endSymbol, lineStyle, state } = this
            .attribute;
        return new ArcSegment({
            center,
            radius,
            startAngle,
            endAngle,
            startSymbol,
            endSymbol,
            lineStyle,
            state: {
                line: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.line),
                startSymbol: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.lineStartSymbol),
                endSymbol: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.lineEndSymbol)
            }
        });
    }
    setLineAttributes() {
        const { center, radius, startAngle, endAngle, startSymbol, endSymbol, lineStyle, state } = this
            .attribute;
        if (this._line) {
            this._line.setAttributes({
                center,
                radius,
                startAngle,
                endAngle,
                startSymbol,
                endSymbol,
                lineStyle,
                state: {
                    line: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.line),
                    startSymbol: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.lineStartSymbol),
                    endSymbol: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.lineEndSymbol)
                }
            });
        }
    }
    isValidPoints() {
        return true;
    }
    addMarkLineLabels(container) {
        this._addMarkLabels(container, 'mark-common-line-label', MarkArcLine.defaultAttributes.label);
    }
    updateMarkLineLabels() {
        this._updateMarkLabels(MarkArcLine.defaultAttributes.label);
    }
}
MarkArcLine.defaultAttributes = DEFAULT_MARK_ARC_LINE_THEME;

loadMarkArcAreaComponent();
function registerMarkArcAreaAnimate() {
    MarkArcArea._animate = markArcAreaAnimate;
}
class MarkArcArea extends Marker {
    markerAnimate(state) {
        if (MarkArcArea._animate && this._animationConfig) {
            MarkArcArea._animate(this._area, this._label, this._animationConfig, state);
        }
    }
    getArea() {
        return this._area;
    }
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, MarkArcArea.defaultAttributes, attributes));
        this.name = 'markArcArea';
        this.defaultUpdateAnimation = DefaultUpdateMarkAreaAnimation;
        this.defaultExitAnimation = DefaultExitMarkerAnimation;
    }
    getPointAttrByPosition(position, labelAttrs) {
        const { center, innerRadius, outerRadius, startAngle, endAngle } = this.attribute;
        const { refX = 0, refY = 0 } = labelAttrs;
        let radius;
        let angle;
        switch (position) {
            case IMarkCommonArcLabelPosition.center:
                radius = (innerRadius + outerRadius) / 2;
                angle = (startAngle + endAngle) / 2;
                break;
            case IMarkCommonArcLabelPosition.arcInnerStart:
                radius = innerRadius;
                angle = startAngle;
                break;
            case IMarkCommonArcLabelPosition.arcOuterStart:
                radius = outerRadius;
                angle = startAngle;
                break;
            case IMarkCommonArcLabelPosition.arcInnerEnd:
                radius = innerRadius;
                angle = endAngle;
                break;
            case IMarkCommonArcLabelPosition.arcOuterEnd:
                radius = outerRadius;
                angle = endAngle;
                break;
            case IMarkCommonArcLabelPosition.arcInnerMiddle:
                radius = innerRadius;
                angle = (startAngle + endAngle) / 2;
                break;
            case IMarkCommonArcLabelPosition.arcOuterMiddle:
                radius = outerRadius;
                angle = (startAngle + endAngle) / 2;
                break;
            default:
                radius = innerRadius;
                angle = (startAngle + endAngle) / 2;
        }
        return {
            position: {
                x: center.x + (radius + refY) * Math.cos(angle) + refX * Math.cos(angle - Math.PI / 2),
                y: center.y + (radius + refY) * Math.sin(angle) + refX * Math.sin(angle - Math.PI / 2)
            },
            angle
        };
    }
    setLabelPos(labelNode, labelAttrs) {
        var _a;
        if (this._area) {
            const { position: labelPosition = 'arcInnerMiddle', autoRotate } = labelAttrs;
            const labelAttr = this.getPointAttrByPosition(labelPosition, labelAttrs);
            labelNode.setAttributes(Object.assign(Object.assign({}, labelAttr.position), { angle: autoRotate ? labelAttr.angle - Math.PI / 2 + ((_a = labelAttrs.refAngle) !== null && _a !== void 0 ? _a : 0) : 0, textStyle: Object.assign(Object.assign({}, DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP[labelPosition]), labelAttrs.textStyle) }));
            if (this.attribute.limitRect && labelAttrs.confine) {
                const { x, y, width, height } = this.attribute.limitRect;
                limitShapeInBounds(labelNode, {
                    x1: x,
                    y1: y,
                    x2: x + width,
                    y2: y + height
                });
            }
        }
    }
    initMarker(container) {
        const { center, innerRadius, outerRadius, startAngle, endAngle, areaStyle, state } = this
            .attribute;
        const area = graphicCreator.arc(Object.assign({ x: center.x, y: center.y, innerRadius,
            outerRadius,
            startAngle,
            endAngle }, areaStyle));
        area.states = merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.area);
        area.name = 'polar-mark-area-area';
        this._area = area;
        container.add(area);
        this._addMarkLabels(container, 'mark-area-label', MarkArcArea.defaultAttributes.label);
    }
    updateMarker() {
        const { center, innerRadius, outerRadius, startAngle, endAngle, areaStyle, label, state } = this
            .attribute;
        if (this._area) {
            this._area.setAttributes(Object.assign({ x: center.x, y: center.y, innerRadius,
                outerRadius,
                startAngle,
                endAngle }, areaStyle));
            this._area.states = merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.area);
        }
        this._updateMarkLabels(MarkArcArea.defaultAttributes.label);
    }
    isValidPoints() {
        return true;
    }
}
MarkArcArea.defaultAttributes = DEFAULT_MARK_ARC_AREA_THEME;
mixin(MarkArcArea, MarkLabelMixin);

loadMarkPointComponent();
function registerMarkPointAnimate() {
    MarkPoint._animate = markPointAnimate;
}
class MarkPoint extends Marker {
    markerAnimate(state) {
        if (MarkPoint._animate && this._animationConfig) {
            MarkPoint._animate([this._line, this._decorativeLine], this._item, this._animationConfig, state);
        }
    }
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, MarkPoint.defaultAttributes, attributes));
        this.name = 'markPoint';
        this.defaultUpdateAnimation = DefaultUpdateMarkPointAnimation;
        this.defaultExitAnimation = DefaultExitMarkerAnimation;
        this._isArcLine = false;
        this._isStraightLine = false;
    }
    setLabelPos() {
    }
    getTextAlignAttr(autoRotate, offsetX, offsetY, lineEndAngle, itemPosition) {
        if (fuzzyEqualNumber(Math.abs(lineEndAngle), Math.PI / 2, FUZZY_EQUAL_DELTA) ||
            fuzzyEqualNumber(Math.abs(lineEndAngle), (Math.PI * 3) / 2, FUZZY_EQUAL_DELTA)) {
            return getTextAlignAttrOfVerticalDir(autoRotate, lineEndAngle, itemPosition);
        }
        if (isPostiveXAxis(lineEndAngle)) {
            return DEFAULT_MARK_POINT_TEXT_STYLE_MAP.postiveXAxis[itemPosition];
        }
        return DEFAULT_MARK_POINT_TEXT_STYLE_MAP.negativeXAxis[itemPosition];
    }
    setItemAttributes(item, itemContent, newPosition, newItemPosition, itemType) {
        var _a, _b;
        if (!item) {
            return;
        }
        const { autoRotate = true, refX = 0, refY = 0, refAngle = 0, style, position: positionType = IMarkPointItemPosition.middle } = itemContent;
        const { state } = this.attribute;
        const lineEndAngle = ((_a = this._line) === null || _a === void 0 ? void 0 : _a.getEndAngle()) || 0;
        const itemRefOffsetX = refX * Math.cos(lineEndAngle) + refY * Math.cos(lineEndAngle - Math.PI / 2);
        const itemRefOffsetY = refX * Math.sin(lineEndAngle) + refY * Math.sin(lineEndAngle - Math.PI / 2);
        if (itemType === 'text') {
            const offsetX = newItemPosition.x - newPosition.x;
            const offsetY = newItemPosition.y - newPosition.y;
            item.setAttributes(Object.assign(Object.assign({}, style), { textStyle: Object.assign(Object.assign({}, this.getTextAlignAttr(autoRotate, offsetX, offsetY, lineEndAngle, (_b = itemContent.position) !== null && _b !== void 0 ? _b : 'end')), style.textStyle), state: {
                    panel: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.textBackground),
                    text: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.itemContent)
                } }));
        }
        else if (itemType === 'richText') {
            item.setAttributes({
                dx: this.getItemDx(item, positionType, style) + (style.dx || 0),
                dy: this.getItemDy(item, positionType, style) + (style.dy || 0)
            });
            item.states = merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.itemContent);
        }
        else if (itemType === 'image') {
            item.setAttributes({
                dx: this.getItemDx(item, positionType, style) + (style.dx || 0),
                dy: this.getItemDy(item, positionType, style) + (style.dy || 0)
            });
            item.states = merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.itemContent);
        }
        const itemAngle = isPostiveXAxis(lineEndAngle) ? lineEndAngle : lineEndAngle - Math.PI;
        item.setAttributes({
            x: newItemPosition.x + (itemRefOffsetX || 0),
            y: newItemPosition.y + (itemRefOffsetY || 0),
            angle: autoRotate && itemAngle + refAngle
        });
    }
    getItemDx(item, position, style) {
        var _a, _b;
        const width = (_b = (_a = item === null || item === void 0 ? void 0 : item.AABBBounds) === null || _a === void 0 ? void 0 : _a.width()) !== null && _b !== void 0 ? _b : ((style === null || style === void 0 ? void 0 : style.width) || 0);
        if (position.includes('inside')) {
            return -width;
        }
        if (position === 'insideTop') {
            return 0;
        }
        return 0;
    }
    getItemDy(item, position, style) {
        var _a, _b;
        const height = (_b = (_a = item === null || item === void 0 ? void 0 : item.AABBBounds) === null || _a === void 0 ? void 0 : _a.height()) !== null && _b !== void 0 ? _b : ((style === null || style === void 0 ? void 0 : style.height) || 0);
        if (position.includes('top') || position.includes('Top')) {
            return -height;
        }
        if (position.includes('middle') || position.includes('Middle')) {
            return -height / 2;
        }
        return 0;
    }
    initItem(itemContent, newPosition, newItemPosition) {
        const { state } = this.attribute;
        const { type = 'text', style, renderCustomCallback } = itemContent;
        let item;
        if (type === 'symbol') {
            item = graphicCreator.symbol(Object.assign(Object.assign({}, newItemPosition), style));
            item.states = merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.itemContent);
        }
        else if (type === 'text') {
            item = new Tag(Object.assign(Object.assign({}, newItemPosition), { state: {
                    panel: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.textBackground),
                    text: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.itemContent)
                } }));
        }
        else if (type === 'richText') {
            item = graphicCreator.richtext(Object.assign(Object.assign({}, newItemPosition), style));
            item.states = merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.itemContent);
        }
        else if (type === 'image') {
            item = graphicCreator.image(Object.assign(Object.assign({}, newItemPosition), style));
            item.states = merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.itemContent);
        }
        else if (type === 'custom' && renderCustomCallback) {
            item = renderCustomCallback();
            item.states = merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.itemContent);
        }
        item.name = `mark-point-${type}`;
        this.setItemAttributes(item, itemContent, newPosition, newItemPosition, type);
        return item;
    }
    getItemLineAttr(itemLine, newPosition, newItemPosition) {
        let points = [];
        let center = { x: 0, y: 0 };
        let radius = 0;
        let startAngle = 0;
        let endAngle = 0;
        const { type = 'type-s', arcRatio = 0.8 } = itemLine;
        const itemOffsetX = newItemPosition.x - newPosition.x;
        const itemOffsetY = newItemPosition.y - newPosition.y;
        this._isStraightLine =
            fuzzyEqualNumber(itemOffsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(itemOffsetY, 0, FUZZY_EQUAL_DELTA);
        if (this._isArcLine) {
            const { x: x1, y: y1 } = this.attribute.position;
            const { x: x2, y: y2 } = newItemPosition;
            const x0 = (x1 + x2) / 2;
            const y0 = (y1 + y2) / 2;
            const k = y1 === y2 ? 0 : -(x1 - x2) / (y1 - y2);
            const line = (x) => k * (x - x0) + y0;
            const direction = y2 > y1 ? -1 : 1;
            const deltaX = arcRatio * direction * x0;
            const centerX = x0 + deltaX;
            const centerY = line(centerX);
            startAngle = deltaXYToAngle(y1 - centerY, x1 - centerX);
            endAngle = deltaXYToAngle(y2 - centerY, x2 - centerX);
            center = { x: centerX, y: centerY };
            const R = Math.sqrt((centerX - x1) * (centerX - x1) + (centerY - y1) * (centerY - y1));
            const r = this.attribute.targetSymbol.style.size / 2;
            const deltaAngle = Math.acos(Math.sqrt(1 - (r * r) / (4 * R * R))) * 2;
            startAngle = startAngle + deltaAngle;
            if (arcRatio > 0) {
                if (endAngle < startAngle) {
                    endAngle += Math.PI * 2;
                }
            }
            else {
                if (startAngle < endAngle) {
                    startAngle += Math.PI * 2;
                }
            }
            radius = Math.sqrt((centerX - x1) * (centerX - x1) + (centerY - y1) * (centerY - y1));
        }
        else if (type === 'type-do' && !this._isStraightLine) {
            points = [
                newPosition,
                {
                    x: (newPosition.x + newItemPosition.x) / 2,
                    y: newItemPosition.y
                },
                newItemPosition
            ];
        }
        else if (type === 'type-po' && !this._isStraightLine) {
            points = [
                newPosition,
                {
                    x: newItemPosition.x,
                    y: newPosition.y
                },
                newItemPosition
            ];
        }
        else if (type === 'type-op' && !this._isStraightLine) {
            points = [
                newPosition,
                {
                    x: newPosition.x,
                    y: newItemPosition.y
                },
                newItemPosition
            ];
        }
        else {
            points = [newPosition, newItemPosition];
        }
        points = removeRepeatPoint(points);
        return {
            points,
            center,
            radius,
            startAngle,
            endAngle
        };
    }
    reDrawLine(itemLine, pointsAttr) {
        this._line.release();
        const { startSymbol, endSymbol, lineStyle, type = 'type-s' } = itemLine;
        const { state } = this.attribute;
        const lineConstructor = this._isArcLine ? ArcSegment : Segment;
        this._container.removeChild(this._line);
        this._line = new lineConstructor(Object.assign(Object.assign({}, pointsAttr), { pickable: false, startSymbol,
            endSymbol,
            lineStyle, visible: itemLine.visible, state: {
                line: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.line),
                startSymbol: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.lineStartSymbol),
                endSymbol: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.lineEndSymbol)
            } }));
        this._container.add(this._line);
    }
    setItemLineAttr(itemLine, newPosition, newItemPosition) {
        if (this._line) {
            const { startSymbol, endSymbol, lineStyle, type = 'type-s' } = itemLine;
            const { state } = this.attribute;
            const pointsAttr = this.getItemLineAttr(itemLine, newPosition, newItemPosition);
            if ((this._isArcLine && this._line.key === 'arc-segment') || (!this._isArcLine && this._line.key === 'segment')) {
                this._line.setAttributes(Object.assign(Object.assign({}, pointsAttr), { startSymbol,
                    endSymbol,
                    lineStyle, visible: itemLine.visible, state: {
                        line: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.line),
                        startSymbol: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.lineStartSymbol),
                        endSymbol: merge({}, DEFAULT_STATES$2, state === null || state === void 0 ? void 0 : state.lineEndSymbol)
                    } }));
            }
            else {
                this.reDrawLine(itemLine, pointsAttr);
            }
        }
    }
    getDecorativeLineAttr(itemLine) {
        var _a;
        const decorativeLength = ((_a = itemLine === null || itemLine === void 0 ? void 0 : itemLine.decorativeLine) === null || _a === void 0 ? void 0 : _a.length) || 10;
        const itemAngle = this._line.getEndAngle() || 0;
        const startPointOffsetX = (decorativeLength / 2) * Math.cos(itemAngle - Math.PI / 2);
        const startPointOffsetY = (decorativeLength / 2) * Math.sin(itemAngle - Math.PI / 2);
        const endPointOffsetX = (-decorativeLength / 2) * Math.cos(itemAngle - Math.PI / 2);
        const endPointOffsetY = (-decorativeLength / 2) * Math.sin(itemAngle - Math.PI / 2);
        return {
            startPointOffsetX,
            startPointOffsetY,
            endPointOffsetX,
            endPointOffsetY
        };
    }
    setDecorativeLineAttr(itemLine, newItemPosition, visible) {
        var _a;
        if (this._decorativeLine) {
            const { lineStyle } = itemLine;
            const { startPointOffsetX, startPointOffsetY, endPointOffsetX, endPointOffsetY } = this.getDecorativeLineAttr(itemLine);
            this._decorativeLine.setAttributes(Object.assign(Object.assign({ points: [
                    {
                        x: newItemPosition.x + startPointOffsetX,
                        y: newItemPosition.y + startPointOffsetY
                    },
                    {
                        x: newItemPosition.x + endPointOffsetX,
                        y: newItemPosition.y + endPointOffsetY
                    }
                ] }, lineStyle), { visible }));
            this._decorativeLine.states = merge({}, DEFAULT_STATES$2, (_a = this.attribute.state) === null || _a === void 0 ? void 0 : _a.line);
        }
    }
    setTargetItemAttributes(targetItem, position) {
        var _a, _b;
        if (this._targetItem) {
            this._targetItem.setAttributes(Object.assign({ x: position.x, y: position.y, visible: (_a = targetItem.visible) !== null && _a !== void 0 ? _a : false, size: targetItem.size }, targetItem.style));
            this._targetItem.states = merge({}, DEFAULT_STATES$2, (_b = this.attribute.state) === null || _b === void 0 ? void 0 : _b.targetItem);
        }
    }
    setAllOfItemsAttr(newPosition, newItemPosition) {
        var _a;
        const { position, itemLine = {}, itemContent = {}, limitRect, targetSymbol } = this.attribute;
        const { type = 'text', confine } = itemContent;
        if (limitRect && confine) {
            const { x, y, width, height } = limitRect;
            const { dx, dy } = computeOffsetForlimit(this._item, {
                x1: x,
                y1: y,
                x2: x + width,
                y2: y + height
            });
            newItemPosition.x = newItemPosition.x + dx;
            newItemPosition.y = newItemPosition.y + dy;
        }
        this.setTargetItemAttributes(targetSymbol, position);
        this.setItemLineAttr(itemLine, newPosition, newItemPosition);
        this.setItemAttributes(this._item, itemContent, newPosition, newItemPosition, type);
        this.setDecorativeLineAttr(itemLine, newItemPosition, (_a = itemLine.decorativeLine) === null || _a === void 0 ? void 0 : _a.visible);
    }
    computeNewPositionAfterTargetItem(position) {
        var _a, _b;
        const { itemContent = {}, targetSymbol, itemLine } = this.attribute;
        const { offsetX: itemContentOffsetX = 0, offsetY: itemContentOffsetY = 0 } = itemContent;
        const { offset: targetSymbolOffset = 0, style: targetSymbolStyle, visible: targetItemvisible = false, size: targetSymbolSize } = targetSymbol;
        const targetSize = targetItemvisible ? ((_b = (_a = targetSymbolStyle.size) !== null && _a !== void 0 ? _a : targetSymbolSize) !== null && _b !== void 0 ? _b : 20) : 0;
        let targetOffsetAngle;
        if (itemLine.type === 'type-do') {
            targetOffsetAngle = deltaXYToAngle(itemContentOffsetY, itemContentOffsetX / 2);
        }
        else if (itemLine.type === 'type-po') {
            targetOffsetAngle = deltaXYToAngle(0, itemContentOffsetX);
        }
        else if (itemLine.type === 'type-op') {
            targetOffsetAngle = deltaXYToAngle(itemContentOffsetY, 0);
        }
        else {
            targetOffsetAngle = deltaXYToAngle(itemContentOffsetY, itemContentOffsetX);
        }
        const newPosition = {
            x: position.x + (targetSize / 2 + targetSymbolOffset) * Math.cos(targetOffsetAngle),
            y: position.y + (targetSize / 2 + targetSymbolOffset) * Math.sin(targetOffsetAngle)
        };
        const newItemPosition = {
            x: position.x + (targetSize / 2 + targetSymbolOffset) * Math.cos(targetOffsetAngle) + itemContentOffsetX,
            y: position.y + (targetSize / 2 + targetSymbolOffset) * Math.sin(targetOffsetAngle) + itemContentOffsetY
        };
        return { newPosition, newItemPosition };
    }
    initMarker(container) {
        const { position, itemContent = {}, itemLine } = this.attribute;
        const { type: itemLineType = 'type-s', arcRatio = 0.8 } = itemLine;
        const { offsetX = 0, offsetY = 0 } = itemContent;
        this._isStraightLine =
            fuzzyEqualNumber(offsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(offsetY, 0, FUZZY_EQUAL_DELTA);
        this._isArcLine = itemLineType === 'type-arc' && arcRatio !== 0 && !this._isStraightLine;
        const { newPosition, newItemPosition } = this.computeNewPositionAfterTargetItem(position);
        const lineConstructor = this._isArcLine ? ArcSegment : Segment;
        const line = new lineConstructor({
            points: [],
            pickable: false,
            center: { x: 0, y: 0 },
            radius: 0,
            startAngle: 0,
            endAngle: 0
        });
        line.name = 'mark-point-line';
        this._line = line;
        container.add(line);
        const decorativeLine = graphicCreator.line({
            points: []
        });
        decorativeLine.name = 'mark-point-decorativeLine';
        this._decorativeLine = decorativeLine;
        container.add(decorativeLine);
        const targetItem = graphicCreator.symbol({});
        targetItem.name = 'mark-point-targetItem';
        this._targetItem = targetItem;
        container.add(this._targetItem);
        const item = this.initItem(itemContent, newPosition, newItemPosition);
        this._item = item;
        container.add(item);
        this.setAllOfItemsAttr(newPosition, newItemPosition);
    }
    updateMarker() {
        const { position, itemContent = {}, itemLine } = this.attribute;
        const { type = 'text' } = itemContent;
        const { type: itemLineType = 'type-s', arcRatio = 0.8 } = itemLine;
        const { offsetX = 0, offsetY = 0 } = itemContent;
        this._isStraightLine =
            fuzzyEqualNumber(offsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(offsetY, 0, FUZZY_EQUAL_DELTA);
        const isArcLine = itemLineType === 'type-arc' && arcRatio !== 0 && !this._isStraightLine;
        const { newPosition, newItemPosition } = this.computeNewPositionAfterTargetItem(position);
        if (isArcLine !== this._isArcLine) {
            this._isArcLine = isArcLine;
            this.reDrawLine(itemLine, {
                points: [{ x: 0, y: 0 }],
                pickable: false,
                center: { x: 0, y: 0 },
                radius: 0,
                startAngle: 0,
                endAngle: 0
            });
        }
        else {
            this._isArcLine = isArcLine;
        }
        this.setItemAttributes(this._item, itemContent, newPosition, newItemPosition, type);
        this.setAllOfItemsAttr(newPosition, newItemPosition);
    }
    isValidPoints() {
        const { position } = this.attribute;
        if (isValidNumber(position.x) && isValidNumber(position.y)) {
            return true;
        }
        return false;
    }
}
MarkPoint.defaultAttributes = DEFAULT_MARK_POINT_THEME;

function loadPagerComponent() {
    registerGroup();
    registerSymbol();
    registerText();
}

const DEFAULT_HANDLER_STYLE = {
    space: 8,
    style: {
        fill: 'rgb(47, 69, 84)',
        cursor: 'pointer',
        size: 15
    },
    state: {
        disable: {
            fill: 'rgb(170, 170, 170)',
            cursor: 'not-allowed'
        },
        hover: {}
    }
};
loadPagerComponent();
class Pager extends AbstractComponent {
    getCurrent() {
        return this._current;
    }
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, Pager.defaultAttributes, attributes));
        this.name = 'pager';
        this._current = 1;
        this._onHover = (e) => {
            const target = e.target;
            if (!target.hasState('disable')) {
                target.addState('hover');
            }
        };
        this._onUnHover = (e) => {
            const target = e.target;
            target.removeState('hover');
        };
        this._onClick = (e) => {
            const target = e.target;
            if (target.name === 'preHandler') {
                if (this._current === 1) {
                    return;
                }
                this._current -= 1;
                if (this._current === 1) {
                    target.addState('disable');
                }
                else {
                    target.removeState('disable');
                }
                this._dispatchEvent('toPrev', {
                    current: this._current,
                    total: this._total,
                    direction: 'pre',
                    event: e
                });
            }
            if (target.name === 'nextHandler') {
                if (this._current === this._total) {
                    return;
                }
                this._current += 1;
                if (this._current === this._total) {
                    target.addState('disable');
                }
                else {
                    target.removeState('disable');
                }
                this._dispatchEvent('toNext', {
                    current: this._current,
                    total: this._total,
                    direction: 'next',
                    event: e
                });
            }
            if (this._current > 1) {
                this.preHandler.removeState('disable');
            }
            if (this._current < this._total) {
                this.nextHandler.removeState('disable');
            }
            this.text.setAttribute('text', this._getPageText(this._current));
        };
    }
    render() {
        var _a, _b, _c;
        this._reset();
        const { layout = 'horizontal', handler = DEFAULT_HANDLER_STYLE, total, defaultCurrent = 1, textStyle, padding = 0 } = this.attribute;
        this._current = defaultCurrent;
        const parsedPadding = normalizePadding(padding);
        const isHorizontal = layout === 'horizontal';
        const container = graphicCreator.group({
            x: 0,
            y: 0
        });
        const handlerStyle = handler.style || {};
        const handlerSize = handlerStyle.size || 15;
        const handlerSpace = (_a = handler.space) !== null && _a !== void 0 ? _a : 8;
        const handlerState = handler.state || {};
        let { preShape, nextShape } = handler;
        if (!preShape) {
            preShape = isHorizontal ? 'triangleLeft' : 'triangleUp';
        }
        if (!nextShape) {
            nextShape = isHorizontal ? 'triangleRight' : 'triangleDown';
        }
        const preHandler = graphicCreator.symbol(Object.assign(Object.assign({ strokeBoundsBuffer: 0, pickMode: 'imprecise' }, handlerStyle), { x: 0, y: 0, symbolType: preShape, size: handlerSize }));
        preHandler.states = handlerState;
        preHandler.name = 'preHandler';
        this.preHandler = preHandler;
        container.add(preHandler);
        const { width: maxTextWidth, height: maxTextHeight } = measureTextSize(this._getPageText(total), Object.assign({ textAlign: 'center', textBaseline: 'middle' }, textStyle), (_c = (_b = this.stage) === null || _b === void 0 ? void 0 : _b.getTheme()) === null || _c === void 0 ? void 0 : _c.text);
        const handlerSizeX = isNumber(handlerSize) ? handlerSize : handlerSize[0];
        const handlerSizeY = isNumber(handlerSize) ? handlerSize : handlerSize[1];
        const text = graphicCreator.text(Object.assign({ x: isHorizontal ? handlerSizeX / 2 + handlerSpace + maxTextWidth / 2 : 0, y: isHorizontal ? 0 : handlerSizeY / 2 + handlerSpace + maxTextHeight / 2, text: this._getPageText(defaultCurrent), textAlign: 'center', textBaseline: 'middle', lineHeight: textStyle === null || textStyle === void 0 ? void 0 : textStyle.fontSize }, textStyle));
        this.text = text;
        container.add(text);
        const nextHandler = graphicCreator.symbol(Object.assign(Object.assign({ strokeBoundsBuffer: 0, pickMode: 'imprecise' }, handlerStyle), { x: isHorizontal ? handlerSizeX + handlerSpace * 2 + maxTextWidth : 0, y: isHorizontal ? 0 : handlerSizeY + handlerSpace * 2 + maxTextHeight, symbolType: nextShape, size: handlerSize }));
        nextHandler.name = 'nextHandler';
        nextHandler.states = handlerState;
        this.nextHandler = nextHandler;
        container.add(nextHandler);
        if (this._total === 1) {
            preHandler.addState('disable');
            nextHandler.addState('disable');
        }
        else if (this._current === 1) {
            preHandler.addState('disable');
        }
        else if (this._current === total) {
            nextHandler.addState('disable');
        }
        const containerBounds = container.AABBBounds;
        const width = containerBounds.width();
        const height = containerBounds.height();
        container.translateTo(0 - containerBounds.x1 + parsedPadding[3], 0 - containerBounds.y1 + parsedPadding[0]);
        this.add(container);
        this.attribute.width = width + parsedPadding[1] + parsedPadding[3];
        this.attribute.height = height + parsedPadding[0] + parsedPadding[2];
        this._bindEvents();
    }
    _bindEvents() {
        if (this.attribute.disableTriggerEvent) {
            return;
        }
        if (this.preHandler) {
            this.preHandler.addEventListener('pointerenter', this._onHover);
            this.preHandler.addEventListener('pointerleave', this._onUnHover);
            this.preHandler.addEventListener('pointerdown', this._onClick);
        }
        if (this.nextHandler) {
            this.nextHandler.addEventListener('pointerenter', this._onHover);
            this.nextHandler.addEventListener('pointerleave', this._onUnHover);
            this.nextHandler.addEventListener('pointerdown', this._onClick);
        }
    }
    _reset() {
        this.removeAllChild(true);
        this._current = 1;
        this._total = this.attribute.total;
        this.preHandler = this.nextHandler = this.text = null;
    }
    _getPageText(current) {
        const { pageFormatter } = this.attribute;
        if (pageFormatter) {
            return isFunction(pageFormatter)
                ? pageFormatter(current, this._total)
                : `${pageFormatter}`.replace('{current}', `${current}`).replace('{total}', `${this._total}`);
        }
        return `${current}/${this._total}`;
    }
    setTotal(total) {
        if (total !== this.attribute.total) {
            this._total = total;
            if (this._current !== 1 && this._current <= total) {
                this.setAttributes({ total, defaultCurrent: this._current });
            }
            else {
                this.setAttribute('total', total);
            }
        }
    }
}
Pager.defaultAttributes = {
    handler: DEFAULT_HANDLER_STYLE,
    textStyle: {
        fill: 'rgb(51, 51, 51)',
        fontSize: 12
    }
};

const DEFAULT_SHAPE_SIZE = 10;
const DEFAULT_SHAPE_SPACE = 8;
const DEFAULT_LABEL_SPACE = 8;
const DEFAULT_VALUE_SPACE = 8;
const DEFAULT_ITEM_SPACE_COL = 16;
const DEFAULT_ITEM_SPACE_ROW = 8;
const DEFAULT_TITLE_SPACE = 12;
const DEFAULT_PAGER_SPACE = 12;
var LegendStateValue;
(function (LegendStateValue) {
    LegendStateValue["selected"] = "selected";
    LegendStateValue["unSelected"] = "unSelected";
    LegendStateValue["selectedHover"] = "selectedHover";
    LegendStateValue["unSelectedHover"] = "unSelectedHover";
    LegendStateValue["focus"] = "focus";
})(LegendStateValue || (LegendStateValue = {}));
var LegendEvent;
(function (LegendEvent) {
    LegendEvent["legendItemHover"] = "legendItemHover";
    LegendEvent["legendItemUnHover"] = "legendItemUnHover";
    LegendEvent["legendItemClick"] = "legendItemClick";
    LegendEvent["legendItemAttributeUpdate"] = "legendItemAttributeUpdate";
})(LegendEvent || (LegendEvent = {}));
var LEGEND_ELEMENT_NAME;
(function (LEGEND_ELEMENT_NAME) {
    LEGEND_ELEMENT_NAME["innerView"] = "innerView";
    LEGEND_ELEMENT_NAME["title"] = "legendTitle";
    LEGEND_ELEMENT_NAME["item"] = "legendItem";
    LEGEND_ELEMENT_NAME["itemShape"] = "legendItemShape";
    LEGEND_ELEMENT_NAME["itemLabel"] = "legendItemLabel";
    LEGEND_ELEMENT_NAME["itemValue"] = "legendItemValue";
    LEGEND_ELEMENT_NAME["focus"] = "legendItemFocus";
})(LEGEND_ELEMENT_NAME || (LEGEND_ELEMENT_NAME = {}));

class LegendBase extends AbstractComponent {
    constructor() {
        super(...arguments);
        this.name = 'legend';
        this._title = null;
    }
    render() {
        this.removeAllChild(true);
        const { interactive = true, title, padding = 0 } = this.attribute;
        this._parsedPadding = normalizePadding(padding);
        const innerView = graphicCreator.group({
            x: this._parsedPadding[3],
            y: this._parsedPadding[0],
            pickable: interactive,
            childrenPickable: interactive
        });
        innerView.name = LEGEND_ELEMENT_NAME.innerView;
        this.add(innerView);
        this._innerView = innerView;
        if (title === null || title === void 0 ? void 0 : title.visible) {
            this._renderTitle(title);
        }
        this._renderContent();
        this._adjustLayout();
        if (interactive) {
            this._bindEvents();
        }
        const viewBounds = this._innerView.AABBBounds;
        this.attribute.width = viewBounds.width() + this._parsedPadding[1] + this._parsedPadding[3];
        this.attribute.height = viewBounds.height() + this._parsedPadding[0] + this._parsedPadding[2];
    }
    _renderTitle(title) {
        const { text = '', textStyle, padding = 0, background, minWidth, maxWidth, shape } = title;
        const tagAttrs = {
            x: 0,
            y: 0,
            text,
            textStyle,
            padding: normalizePadding(padding),
            minWidth,
            maxWidth
        };
        if (shape && shape.visible) {
            tagAttrs.shape = Object.assign({ visible: true }, shape.style);
            if (isValid(shape.space)) {
                tagAttrs.space = shape.space;
            }
        }
        if (background && background.visible) {
            tagAttrs.panel = Object.assign({ visible: true }, background.style);
        }
        const titleTag = new Tag(tagAttrs);
        titleTag.name = LEGEND_ELEMENT_NAME.title;
        this._title = titleTag;
        this._innerView.add(titleTag);
    }
    _adjustLayout() {
        var _a;
        if (this._title) {
            const innerViewWidth = this._innerView.AABBBounds.width();
            const titleWidth = this._title.AABBBounds.width();
            const align = (_a = this.attribute.title) === null || _a === void 0 ? void 0 : _a.align;
            if (align === 'center') {
                this._title.setAttribute('x', (innerViewWidth - titleWidth) / 2);
            }
            else if (align === 'end') {
                this._title.setAttribute('x', innerViewWidth - titleWidth);
            }
        }
    }
}

function loadSliderComponent() {
    registerGroup();
    registerText();
    registerRect();
    registerSymbol();
}

function loadBaseLegend() {
    registerGroup();
    loadTagComponent();
}
function loadDiscreteLegendComponent() {
    loadBaseLegend();
    loadPagerComponent();
    loadScrollbarComponent();
}
function loadColorContinuousLegendComponent() {
    loadBaseLegend();
    loadSliderComponent();
}
function loadSizeContinuousLegendComponent() {
    loadBaseLegend();
    loadSliderComponent();
    registerPath();
}

const DEFAULT_STATES = {
    [LegendStateValue.focus]: {},
    [LegendStateValue.selected]: {},
    [LegendStateValue.selectedHover]: {},
    [LegendStateValue.unSelected]: {},
    [LegendStateValue.unSelectedHover]: {}
};
loadDiscreteLegendComponent();
class DiscreteLegend extends LegendBase {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, DiscreteLegend.defaultAttributes, attributes));
        this.name = 'discreteLegend';
        this._itemsContainer = null;
        this._itemHeightByUser = undefined;
        this._itemHeight = 0;
        this._itemMaxWidth = 0;
        this._contentMaxHeight = 0;
        this._onHover = (e) => {
            const target = e.target;
            if (target && target.name && target.name.startsWith(LEGEND_ELEMENT_NAME.item)) {
                const legendItem = target.delegate;
                if (this._lastActiveItem) {
                    if (this._lastActiveItem.id === legendItem.id) {
                        return;
                    }
                    this._unHover(this._lastActiveItem, e);
                }
                this._hover(legendItem, e);
            }
            else if (this._lastActiveItem) {
                this._unHover(this._lastActiveItem, e);
                this._lastActiveItem = null;
            }
        };
        this._onUnHover = (e) => {
            if (this._lastActiveItem) {
                this._unHover(this._lastActiveItem, e);
                this._lastActiveItem = null;
            }
        };
        this._onClick = (e) => {
            var _a, _b, _c, _d;
            const target = e.target;
            if (target && target.name && target.name.startsWith(LEGEND_ELEMENT_NAME.item)) {
                const legendItem = target.delegate;
                const { selectMode = 'multiple' } = this.attribute;
                if (target.name === LEGEND_ELEMENT_NAME.focus || selectMode === 'focus') {
                    const isFocusSelected = legendItem.hasState(LegendStateValue.focus);
                    legendItem.toggleState(LegendStateValue.focus);
                    if (isFocusSelected) {
                        (_a = this._itemsContainer) === null || _a === void 0 ? void 0 : _a.getChildren().forEach(item => {
                            this._removeLegendItemState(item, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover, LegendStateValue.focus], e);
                            this._setLegendItemState(item, LegendStateValue.selected, e);
                        });
                    }
                    else {
                        this._setLegendItemState(legendItem, LegendStateValue.selected, e);
                        this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e);
                        (_b = this._itemsContainer) === null || _b === void 0 ? void 0 : _b.getChildren().forEach(item => {
                            if (legendItem !== item) {
                                this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover, LegendStateValue.focus], e);
                                this._setLegendItemState(item, LegendStateValue.unSelected, e);
                            }
                        });
                    }
                }
                else {
                    (_c = this._itemsContainer) === null || _c === void 0 ? void 0 : _c.getChildren().forEach(item => {
                        item.removeState(LegendStateValue.focus);
                    });
                    const { allowAllCanceled = true } = this.attribute;
                    const isSelected = legendItem.hasState(LegendStateValue.selected);
                    const currentSelectedItems = this._getSelectedLegends();
                    if (selectMode === 'multiple') {
                        if (allowAllCanceled === false && isSelected && currentSelectedItems.length === 1) {
                            this._dispatchLegendEvent(LegendEvent.legendItemClick, legendItem, e);
                            return;
                        }
                        if (isSelected) {
                            this._removeLegendItemState(legendItem, [LegendStateValue.selected, LegendStateValue.selectedHover], e);
                            this._setLegendItemState(legendItem, LegendStateValue.unSelected, e);
                        }
                        else {
                            this._setLegendItemState(legendItem, LegendStateValue.selected, e);
                            this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e);
                        }
                    }
                    else {
                        this._setLegendItemState(legendItem, LegendStateValue.selected, e);
                        this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e);
                        (_d = this._itemsContainer) === null || _d === void 0 ? void 0 : _d.getChildren().forEach(item => {
                            if (legendItem !== item) {
                                this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover], e);
                                this._setLegendItemState(item, LegendStateValue.unSelected, e);
                            }
                        });
                    }
                }
                this._dispatchLegendEvent(LegendEvent.legendItemClick, legendItem, e);
            }
        };
    }
    render() {
        super.render();
        this._lastActiveItem = null;
    }
    setSelected(selectedData) {
        var _a;
        ((_a = this._itemsContainer) === null || _a === void 0 ? void 0 : _a.getChildren()).forEach(item => {
            const itemData = item.data;
            if (selectedData.includes(itemData.label)) {
                this._setLegendItemState(item, LegendStateValue.selected);
                this._removeLegendItemState(item, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover]);
            }
            else {
                this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover]);
                this._setLegendItemState(item, LegendStateValue.unSelected);
            }
        });
    }
    _renderItems() {
        const { item: itemAttrs = {}, maxCol = 1, maxRow = 2, maxWidth, defaultSelected, lazyload, autoPage } = this.attribute;
        const { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW, verticalAlign = 'middle' } = itemAttrs;
        const itemsContainer = this._itemsContainer;
        const { items: legendItems, isHorizontal, startIndex, isScrollbar } = this._itemContext;
        const maxPages = isScrollbar ? 1 : isHorizontal ? maxRow : maxCol;
        const maxHeight = this._contentMaxHeight;
        let { doWrap, maxWidthInCol, startX, startY, pages } = this._itemContext;
        let item;
        let lastItemWidth = 0;
        let lastLineHeight = 0;
        const lastLineItemGroup = [];
        for (let index = startIndex, len = legendItems.length; index < len; index++) {
            if (lazyload && pages > this._itemContext.currentPage * maxPages) {
                break;
            }
            if (lazyload) {
                this._itemContext.startIndex = index + 1;
            }
            item = legendItems[index];
            if (!item.id) {
                item.id = item.label;
            }
            item.index = index;
            let isSelected = true;
            if (isArray(defaultSelected)) {
                isSelected = defaultSelected.includes(item.label);
            }
            const itemGroup = this._renderEachItem(item, isSelected, index, legendItems);
            const itemWidth = itemGroup.attribute.width;
            const itemHeight = itemGroup.attribute.height;
            this._itemHeight = Math.max(this._itemHeight, itemHeight);
            maxWidthInCol = Math.max(itemWidth, maxWidthInCol);
            this._itemMaxWidth = Math.max(itemWidth, this._itemMaxWidth);
            if (isHorizontal) {
                if (isValid(maxWidth)) {
                    if (isScrollbar && autoPage) {
                        pages = Math.ceil((startX + itemWidth) / maxWidth);
                        doWrap = pages > 1;
                    }
                    else if (startX + itemWidth > maxWidth) {
                        doWrap = true;
                        if (startX > 0) {
                            if (verticalAlign === 'middle' || verticalAlign === 'bottom') {
                                lastLineItemGroup.forEach(i => {
                                    i.setAttributes({
                                        y: i.attribute.y + (lastLineHeight - i.attribute.height) / (verticalAlign === 'middle' ? 2 : 1)
                                    });
                                });
                            }
                            pages += 1;
                            startX = 0;
                            startY += lastLineHeight + spaceRow;
                            lastLineHeight = 0;
                            lastLineItemGroup.length = 0;
                        }
                    }
                }
                if (startX !== 0 || startY !== 0) {
                    itemGroup.setAttributes({
                        x: startX,
                        y: startY
                    });
                }
                startX += spaceCol + itemWidth;
                lastLineHeight = Math.max(lastLineHeight, itemHeight);
                lastLineItemGroup.push(itemGroup);
            }
            else {
                if (isValid(maxHeight)) {
                    if (isScrollbar && autoPage) {
                        pages = Math.ceil((startY + itemHeight) / maxHeight);
                        doWrap = pages > 1;
                    }
                    else if (maxHeight <= itemHeight) {
                        pages += 1;
                        doWrap = true;
                        startY = 0;
                        if (index > 0) {
                            startX += lastItemWidth + spaceCol;
                        }
                    }
                    else if (maxHeight < startY + itemHeight) {
                        pages += 1;
                        doWrap = true;
                        startY = 0;
                        startX += maxWidthInCol + spaceCol;
                        maxWidthInCol = 0;
                    }
                }
                if (startX !== 0 || startY !== 0) {
                    itemGroup.setAttributes({
                        x: startX,
                        y: startY
                    });
                }
                startY += spaceRow + itemHeight;
            }
            itemsContainer.add(itemGroup);
            lastItemWidth = itemWidth;
        }
        if (isHorizontal && (verticalAlign === 'middle' || verticalAlign === 'bottom')) {
            lastLineItemGroup.forEach(i => {
                i.setAttributes({
                    y: i.attribute.y + (lastLineHeight - i.attribute.height) / (verticalAlign === 'middle' ? 2 : 1)
                });
            });
        }
        this._itemContext.doWrap = doWrap;
        this._itemContext.startX = startX;
        this._itemContext.startY = startY;
        this._itemContext.maxWidthInCol = maxWidthInCol;
        this._itemContext.pages = pages;
        this._itemContext.maxPages = maxPages;
        if (isScrollbar) {
            this._itemContext.totalPage = pages;
        }
        if (!lazyload) {
            this._itemContext.startIndex = legendItems.length;
        }
        return this._itemContext;
    }
    _renderContent() {
        const { item = {}, items, reversed, maxWidth, maxHeight } = this.attribute;
        if (item.visible === false || isEmpty(items)) {
            return;
        }
        let legendItems = items;
        if (reversed) {
            legendItems = items === null || items === void 0 ? void 0 : items.reverse();
        }
        this._contentMaxHeight = Math.max(0, maxHeight - this._parsedPadding[0] - this._parsedPadding[2]);
        const itemsContainer = graphicCreator.group({
            x: 0,
            y: 0
        });
        this._itemsContainer = itemsContainer;
        const { layout, autoPage } = this.attribute;
        const isHorizontal = layout === 'horizontal';
        const { maxWidth: maxItemWidth, width: itemWidth, height: itemHeight } = item;
        const widthsOptions = [];
        if (isValid(maxItemWidth)) {
            widthsOptions.push(maxItemWidth);
        }
        if (isValid(itemWidth)) {
            widthsOptions.push(itemWidth);
        }
        if (widthsOptions.length) {
            if (isValid(maxWidth)) {
                widthsOptions.push(maxWidth);
            }
            this._itemWidthByUser = minInArray(widthsOptions);
        }
        if (isValid(itemHeight)) {
            this._itemHeightByUser = itemHeight;
        }
        const pager = this.attribute.pager;
        this._itemContext = {
            currentPage: pager ? pager.defaultCurrent || 1 : 1,
            doWrap: false,
            maxWidthInCol: 0,
            maxPages: 1,
            pages: 1,
            startX: 0,
            startY: 0,
            startIndex: 0,
            items: legendItems,
            isHorizontal,
            totalPage: Infinity,
            isScrollbar: pager && pager.type === 'scrollbar',
            clipContainer: undefined
        };
        this._itemContext = this._renderItems();
        let pagerRendered = false;
        if (this._itemContext.doWrap && autoPage && this._itemContext.pages > this._itemContext.maxPages) {
            pagerRendered = this._renderPagerComponent();
        }
        if (!pagerRendered) {
            itemsContainer.setAttribute('y', this._title ? this._title.AABBBounds.height() + get(this.attribute, 'title.space', 8) : 0);
            this._innerView.add(itemsContainer);
        }
    }
    _bindEvents() {
        if (this.attribute.disableTriggerEvent) {
            return;
        }
        if (!this._itemsContainer) {
            return;
        }
        const { hover = true, select = true } = this.attribute;
        if (hover) {
            let trigger = 'pointermove';
            let triggerOff = 'pointerleave';
            if (isObject(hover)) {
                hover.trigger && (trigger = hover.trigger);
                hover.triggerOff && (triggerOff = hover.triggerOff);
            }
            this._itemsContainer.addEventListener(trigger, this._onHover);
            this._itemsContainer.addEventListener(triggerOff, this._onUnHover);
        }
        if (select) {
            let trigger = 'pointerdown';
            if (isObject(select) && select.trigger) {
                trigger = select.trigger;
            }
            this._itemsContainer.addEventListener(trigger, this._onClick);
        }
    }
    _autoEllipsis(autoEllipsisStrategy, layoutWidth, labelShape, valueShape) {
        var _a, _b;
        const { label: labelAttr, value: valueAttr } = this.attribute.item;
        const valueBounds = valueShape.AABBBounds;
        const labelBounds = labelShape.AABBBounds;
        const valueWidth = valueBounds.width();
        const labelWidth = labelBounds.width();
        let useWidthRatio = false;
        if (autoEllipsisStrategy === 'labelFirst') {
            if (labelWidth > layoutWidth) {
                useWidthRatio = true;
            }
            else {
                valueShape.setAttribute('maxLineWidth', layoutWidth - labelWidth);
            }
        }
        else if (autoEllipsisStrategy === 'valueFirst') {
            if (valueWidth > layoutWidth) {
                useWidthRatio = true;
            }
            else {
                labelShape.setAttribute('maxLineWidth', layoutWidth - valueWidth);
            }
        }
        else if (valueWidth + labelWidth > layoutWidth) {
            useWidthRatio = true;
        }
        if (useWidthRatio) {
            valueShape.setAttribute('maxLineWidth', Math.max(layoutWidth * ((_a = labelAttr.widthRatio) !== null && _a !== void 0 ? _a : 0.5), layoutWidth - labelWidth));
            labelShape.setAttribute('maxLineWidth', Math.max(layoutWidth * ((_b = valueAttr.widthRatio) !== null && _b !== void 0 ? _b : 0.5), layoutWidth - valueWidth));
        }
    }
    _renderEachItem(item, isSelected, index, items) {
        var _a, _b;
        const { id, label, value, shape } = item;
        const { padding = 0, focus, focusIconStyle, align, autoEllipsisStrategy } = this.attribute.item;
        const { shape: shapeAttr, label: labelAttr, value: valueAttr, background } = this.attribute.item;
        const shapeStyle = this._handleStyle(shapeAttr, item, isSelected, index, items);
        const labelStyle = this._handleStyle(labelAttr, item, isSelected, index, items);
        const valueStyle = this._handleStyle(valueAttr, item, isSelected, index, items);
        const backgroundStyle = this._handleStyle(background, item, isSelected, index, items);
        const parsedPadding = normalizePadding(padding);
        let itemGroup;
        if (background.visible === false) {
            itemGroup = graphicCreator.group({
                x: 0,
                y: 0,
                cursor: (_a = backgroundStyle.style) === null || _a === void 0 ? void 0 : _a.cursor
            });
            this._appendDataToShape(itemGroup, LEGEND_ELEMENT_NAME.item, item, itemGroup);
        }
        else {
            itemGroup = graphicCreator.group(Object.assign({ x: 0, y: 0 }, backgroundStyle.style));
            this._appendDataToShape(itemGroup, LEGEND_ELEMENT_NAME.item, item, itemGroup, backgroundStyle.state);
        }
        itemGroup.id = `${id !== null && id !== void 0 ? id : label}-${index}`;
        itemGroup.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected);
        const innerGroup = graphicCreator.group({
            x: 0,
            y: 0,
            pickable: false
        });
        itemGroup.add(innerGroup);
        let focusStartX = 0;
        let shapeSize = 0;
        let shapeSpace = 0;
        if (shapeAttr && shapeAttr.visible !== false) {
            const s = get(shapeStyle, 'style.size', DEFAULT_SHAPE_SIZE);
            if (isArray(s)) {
                shapeSize = s[0] || 0;
            }
            else {
                shapeSize = s;
            }
            shapeSpace = get(shapeAttr, 'space', DEFAULT_SHAPE_SPACE);
            const itemShape = graphicCreator.symbol(Object.assign(Object.assign({ x: 0, y: 0, symbolType: 'circle', strokeBoundsBuffer: 0 }, shape), shapeStyle.style));
            Object.keys(shapeStyle.state || {}).forEach(key => {
                const color = shapeStyle.state[key].fill ||
                    shapeStyle.state[key].stroke;
                if (shape.fill && isNil(shapeStyle.state[key].fill) && color) {
                    shapeStyle.state[key].fill = color;
                }
                if (shape.stroke && isNil(shapeStyle.state[key].stroke) && color) {
                    shapeStyle.state[key].stroke = color;
                }
            });
            this._appendDataToShape(itemShape, LEGEND_ELEMENT_NAME.itemShape, item, itemGroup, shapeStyle.state);
            itemShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected);
            innerGroup.add(itemShape);
        }
        let focusShape;
        let focusSpace = 0;
        if (focus) {
            const focusSize = get(focusIconStyle, 'size', DEFAULT_SHAPE_SIZE);
            focusShape = graphicCreator.symbol(Object.assign(Object.assign({ x: 0, y: -focusSize / 2 - 1, strokeBoundsBuffer: 0, boundsPadding: parsedPadding }, focusIconStyle), { visible: true, pickMode: 'imprecise' }));
            this._appendDataToShape(focusShape, LEGEND_ELEMENT_NAME.focus, item, itemGroup);
            focusSpace = focusSize;
        }
        const text = labelAttr.formatMethod ? labelAttr.formatMethod(label, item, index) : label;
        const labelAttributes = Object.assign(Object.assign({ x: shapeSize / 2 + shapeSpace, y: 0, textAlign: 'start', textBaseline: 'middle', lineHeight: (_b = labelStyle.style) === null || _b === void 0 ? void 0 : _b.fontSize }, labelStyle.style), { text, _originText: labelAttr.formatMethod ? label : undefined });
        const labelShape = createTextGraphicByType(labelAttributes);
        this._appendDataToShape(labelShape, LEGEND_ELEMENT_NAME.itemLabel, item, itemGroup, labelStyle.state);
        labelShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected);
        innerGroup.add(labelShape);
        const labelSpace = get(labelAttr, 'space', DEFAULT_LABEL_SPACE);
        if (isValid(value)) {
            const valueSpace = get(valueAttr, 'space', focus ? DEFAULT_VALUE_SPACE : 0);
            const valueText = valueAttr.formatMethod ? valueAttr.formatMethod(value, item, index) : value;
            const valueAttributes = Object.assign(Object.assign({ x: 0, y: 0, textAlign: 'start', textBaseline: 'middle', lineHeight: valueStyle.style.fontSize }, valueStyle.style), { text: valueText, _originText: valueAttr.formatMethod ? value : undefined });
            const valueShape = createTextGraphicByType(valueAttributes);
            this._appendDataToShape(valueShape, LEGEND_ELEMENT_NAME.itemValue, item, itemGroup, valueStyle.state);
            valueShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected);
            if (this._itemWidthByUser) {
                const layoutWidth = this._itemWidthByUser -
                    parsedPadding[1] -
                    parsedPadding[3] -
                    shapeSize -
                    shapeSpace -
                    labelSpace -
                    focusSpace -
                    valueSpace;
                this._autoEllipsis(autoEllipsisStrategy, layoutWidth, labelShape, valueShape);
                if (valueAttr.alignRight) {
                    valueShape.setAttributes({
                        textAlign: 'right',
                        x: this._itemWidthByUser - shapeSize / 2 - parsedPadding[1] - parsedPadding[3] - focusSpace - valueSpace
                    });
                }
                else {
                    valueShape.setAttribute('x', labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2));
                }
            }
            else {
                valueShape.setAttribute('x', labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2));
            }
            focusStartX = valueSpace + (valueShape.AABBBounds.empty() ? 0 : valueShape.AABBBounds.x2);
            innerGroup.add(valueShape);
        }
        else if (this._itemWidthByUser) {
            labelShape.setAttribute('maxLineWidth', this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - focusSpace);
            focusStartX = labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2);
        }
        else {
            focusStartX = labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2);
        }
        if (focusShape) {
            focusShape.setAttribute('x', focusStartX);
            innerGroup.add(focusShape);
        }
        const innerGroupBounds = innerGroup.AABBBounds;
        const innerGroupWidth = innerGroupBounds.width();
        if (align === 'right') {
            const x2 = innerGroupBounds.x2;
            const x1 = innerGroupBounds.x1;
            innerGroup.forEachChildren((child, index) => {
                if ((child.type !== 'symbol' && child.attribute.textAlign !== 'right') ||
                    child === focusShape) {
                    child.setAttribute('x', x1 + x2 - child.attribute.x - child.AABBBounds.width());
                }
                else if (child.type !== 'symbol') {
                    child.setAttributes({ x: x1 + x2 - child.attribute.x, textAlign: 'left' });
                }
                else {
                    child.setAttribute('x', x1 + x2 - child.attribute.x);
                }
            });
        }
        const innerGroupHeight = innerGroupBounds.height();
        const itemGroupWidth = isValid(this.attribute.item.width)
            ? this.attribute.item.width
            : innerGroupWidth + parsedPadding[1] + parsedPadding[3];
        const itemGroupHeight = this._itemHeightByUser || innerGroupHeight + parsedPadding[0] + parsedPadding[2];
        itemGroup.attribute.width = itemGroupWidth;
        itemGroup.attribute.height = itemGroupHeight;
        focusShape && focusShape.setAttribute('visible', false);
        innerGroup.translateTo(-innerGroupBounds.x1 + parsedPadding[3], -innerGroupBounds.y1 + parsedPadding[0]);
        return itemGroup;
    }
    _createPager(compStyle) {
        var _a, _b;
        const { disableTriggerEvent, maxRow } = this.attribute;
        const estimateTotal = (num) => {
            if (num <= 99) {
                return 99;
            }
            else if (num <= 999) {
                return 999;
            }
            return 9999;
        };
        return this._itemContext.isHorizontal
            ? new Pager(Object.assign(Object.assign({ layout: maxRow === 1 ? 'horizontal' : 'vertical', total: estimateTotal(this._itemContext.pages) }, merge({
                handler: {
                    preShape: 'triangleUp',
                    nextShape: 'triangleDown'
                }
            }, compStyle)), { defaultCurrent: (_a = this.attribute.pager) === null || _a === void 0 ? void 0 : _a.defaultCurrent, disableTriggerEvent }))
            : new Pager(Object.assign({ layout: 'horizontal', total: estimateTotal(this._itemContext.pages), disableTriggerEvent, defaultCurrent: (_b = this.attribute.pager) === null || _b === void 0 ? void 0 : _b.defaultCurrent }, compStyle));
    }
    _createScrollbar(compStyle, compSize) {
        const { disableTriggerEvent } = this.attribute;
        return this._itemContext.isHorizontal
            ? new ScrollBar(Object.assign(Object.assign({ direction: 'horizontal', disableTriggerEvent, range: [0, 0.5], height: compStyle.visible === false ? 0 : 12 }, compStyle), { width: compSize }))
            : new ScrollBar(Object.assign(Object.assign({ direction: 'vertical', width: compStyle.visible === false ? 0 : 12, range: [0, 0.5] }, compStyle), { height: compSize, disableTriggerEvent }));
    }
    _updatePositionOfPager(renderStartY, compWidth, compHeight) {
        const { pager } = this.attribute;
        const { totalPage, isHorizontal } = this._itemContext;
        const position = (pager && pager.position) || 'middle';
        this._pagerComponent.setTotal(totalPage);
        if (isHorizontal) {
            let y;
            if (position === 'start') {
                y = renderStartY;
            }
            else if (position === 'end') {
                y = renderStartY + compHeight - this._pagerComponent.AABBBounds.height() / 2;
            }
            else {
                y = renderStartY + compHeight / 2 - this._pagerComponent.AABBBounds.height() / 2;
            }
            this._pagerComponent.setAttributes({
                x: compWidth - this._pagerComponent.AABBBounds.width(),
                y
            });
        }
        else {
            let x;
            if (position === 'start') {
                x = 0;
            }
            else if (position === 'end') {
                x = compWidth - this._pagerComponent.AABBBounds.width();
            }
            else {
                x = (compWidth - this._pagerComponent.AABBBounds.width()) / 2;
            }
            this._pagerComponent.setAttributes({
                x,
                y: compHeight - this._pagerComponent.AABBBounds.height()
            });
        }
    }
    _computeScrollbarDelta() {
        const { isHorizontal, clipContainer } = this._itemContext;
        const itemContainerBounds = this._itemsContainer.AABBBounds;
        const clipContainerBounds = clipContainer.AABBBounds;
        let delta;
        let innerViewSize;
        if (isHorizontal) {
            innerViewSize = clipContainerBounds.width();
            delta = innerViewSize / itemContainerBounds.width();
        }
        else {
            innerViewSize = clipContainerBounds.height();
            delta = innerViewSize / itemContainerBounds.height();
        }
        return delta;
    }
    _updatePositionOfScrollbar(contentWidth, contentHeight, renderStartY) {
        const { isHorizontal, currentPage, totalPage } = this._itemContext;
        const start = (currentPage - 1) / totalPage;
        this._pagerComponent.setScrollRange([start, start + this._computeScrollbarDelta()]);
        if (isHorizontal) {
            this._pagerComponent.setAttributes({
                x: 0,
                y: renderStartY + contentHeight
            });
        }
        else {
            this._pagerComponent.setAttributes({
                x: contentWidth,
                y: renderStartY
            });
        }
    }
    _bindEventsOfPager(pageSize, channel) {
        const pager = this.attribute.pager || {};
        const { animation = true, animationDuration = 450, animationEasing = 'quadIn' } = pager;
        const pageParser = this._itemContext.isScrollbar
            ? (e) => {
                const { value } = e.detail;
                let newPage;
                if (value[0] === 0) {
                    newPage = 1;
                }
                else if (value[1] === 1) {
                    newPage = this._itemContext.totalPage;
                }
                else {
                    newPage = value[0] * this._itemContext.totalPage + 1;
                }
                return newPage;
            }
            : (e) => {
                return e.detail.current;
            };
        const onScroll = (e) => {
            const scrollComponent = this._pagerComponent;
            const preScrollRange = scrollComponent.getScrollRange();
            const { direction } = scrollComponent.attribute;
            const { width, height } = scrollComponent.getSliderRenderBounds();
            const currentScrollValue = direction === 'vertical' ? e.deltaY / height : e.deltaX / width;
            scrollComponent.setScrollRange([preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue], true);
            this.updateScrollMask();
        };
        const onPaging = (e) => {
            const newPage = pageParser(e);
            if (newPage === this._itemContext.currentPage) {
                return;
            }
            this._itemContext.currentPage = newPage;
            if (this._itemContext && this._itemContext.startIndex < this._itemContext.items.length) {
                this._renderItems();
                const newTotalPage = Math.ceil(this._itemContext.pages / this._itemContext.maxPages);
                this._itemContext.totalPage = newTotalPage;
                if (this._itemContext.isScrollbar && this._pagerComponent) {
                    const newDelta = this._computeScrollbarDelta();
                    const [start] = this._pagerComponent.getScrollRange();
                    this._pagerComponent.setScrollRange([start, start + newDelta]);
                }
            }
            if (!this._itemContext.isScrollbar) {
                if (animation) {
                    this._itemsContainer
                        .animate()
                        .to({ [channel]: -(newPage - 1) * pageSize }, animationDuration, animationEasing);
                }
                else {
                    this._itemsContainer.setAttribute(channel, -(newPage - 1) * pageSize);
                }
            }
            else {
                const [start] = this._pagerComponent.getScrollRange();
                let containerSize;
                if (this._itemContext.isHorizontal) {
                    containerSize = this._itemsContainer.AABBBounds.width();
                }
                else {
                    containerSize = this._itemsContainer.AABBBounds.height();
                }
                const startOffset = containerSize * start;
                this.updateScrollMask();
                if (animation) {
                    this._itemsContainer.animate().to({ [channel]: -startOffset }, animationDuration, animationEasing);
                }
                else {
                    this._itemsContainer.setAttribute(channel, -startOffset);
                }
            }
        };
        if (this._itemContext.isScrollbar) {
            this._pagerComponent.addEventListener('scrollDrag', onPaging);
            this._pagerComponent.addEventListener('scrollUp', onPaging);
            if (this.attribute.pager.roamScroll) {
                const THROTTLE_TIME = 50;
                this.addEventListener('wheel', (e) => e.nativeEvent.preventDefault());
                this.addEventListener('wheel', throttle(onScroll, THROTTLE_TIME));
            }
        }
        else {
            this._pagerComponent.addEventListener('toPrev', onPaging);
            this._pagerComponent.addEventListener('toNext', onPaging);
        }
    }
    _renderPager() {
        const renderStartY = this._title ? this._title.AABBBounds.height() + get(this.attribute, 'title.space', 8) : 0;
        const { maxWidth, maxCol = 1, maxRow = 2, item = {}, pager = {} } = this.attribute;
        const { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW } = item;
        const itemsContainer = this._itemsContainer;
        const { space: pagerSpace = DEFAULT_PAGER_SPACE, defaultCurrent = 1 } = pager, compStyle = __rest(pager, ["space", "defaultCurrent"]);
        const { isHorizontal } = this._itemContext;
        const maxHeight = this._contentMaxHeight;
        let comp;
        let compWidth = 0;
        let compHeight = 0;
        let contentWidth = 0;
        let contentHeight = 0;
        let startX = 0;
        let startY = 0;
        let pages = 1;
        if (isHorizontal) {
            compHeight = (maxRow - 1) * spaceRow + this._itemHeight * maxRow;
            compWidth = maxWidth;
            comp = this._createPager(compStyle);
            this._pagerComponent = comp;
            this._innerView.add(comp);
            contentWidth = maxWidth - comp.AABBBounds.width() - pagerSpace;
            if (contentWidth <= 0) {
                this._innerView.removeChild(comp);
                return false;
            }
            itemsContainer.getChildren().forEach((item, index) => {
                const { width, height } = item.attribute;
                if (contentWidth < startX + width) {
                    startX = 0;
                    startY += height + spaceRow;
                    pages += 1;
                }
                if (index > 0) {
                    item.setAttributes({
                        x: startX,
                        y: startY
                    });
                }
                startX += spaceCol + width;
            });
            this._itemContext.startX = startX;
            this._itemContext.startY = startY;
            this._itemContext.pages = pages;
            const total = Math.ceil(pages / maxRow);
            this._itemContext.totalPage = total;
            this._updatePositionOfPager(renderStartY, compWidth, compHeight);
        }
        else {
            compWidth = this._itemMaxWidth * maxCol + (maxCol - 1) * spaceCol;
            compHeight = maxHeight;
            contentWidth = compWidth;
            comp = this._createPager(compStyle);
            this._pagerComponent = comp;
            this._innerView.add(comp);
            contentHeight = maxHeight - comp.AABBBounds.height() - pagerSpace - renderStartY;
            if (contentHeight <= 0) {
                this._innerView.removeChild(comp);
                return false;
            }
            itemsContainer.getChildren().forEach((item, index) => {
                const { height } = item.attribute;
                if (contentHeight < startY + height) {
                    startY = 0;
                    startX += this._itemMaxWidth + spaceCol;
                    pages += 1;
                }
                if (index > 0) {
                    item.setAttributes({
                        x: startX,
                        y: startY
                    });
                }
                startY += spaceRow + height;
            });
            const total = Math.ceil(pages / maxCol);
            this._itemContext.totalPage = total;
            this._updatePositionOfPager(renderStartY, compWidth, compHeight);
        }
        if (defaultCurrent > 1) {
            if (isHorizontal) {
                itemsContainer.setAttribute('y', -(defaultCurrent - 1) * (compHeight + spaceRow));
            }
            else {
                itemsContainer.setAttribute('x', -(defaultCurrent - 1) * (compWidth + spaceCol));
            }
        }
        const clipGroup = graphicCreator.group({
            x: 0,
            y: renderStartY,
            width: isHorizontal ? contentWidth : compWidth,
            height: isHorizontal ? compHeight : contentHeight,
            clip: true,
            pickable: false
        });
        clipGroup.add(itemsContainer);
        this._innerView.add(clipGroup);
        this._itemContext.clipContainer = clipGroup;
        this._bindEventsOfPager(isHorizontal ? compHeight + spaceRow : compWidth + spaceCol, isHorizontal ? 'y' : 'x');
        return true;
    }
    _renderScrollbar() {
        var _a;
        const renderStartY = this._title ? this._title.AABBBounds.height() + get(this.attribute, 'title.space', 8) : 0;
        const { maxWidth, item = {}, pager = {} } = this.attribute;
        const { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW } = item;
        const itemsContainer = this._itemsContainer;
        const { space: pagerSpace = DEFAULT_PAGER_SPACE, defaultCurrent = 1 } = pager, compStyle = __rest(pager, ["space", "defaultCurrent"]);
        const { isHorizontal } = this._itemContext;
        const maxHeight = this._contentMaxHeight;
        let comp;
        let contentWidth = 0;
        let contentHeight = 0;
        let startY = 0;
        let pages = 1;
        if (isHorizontal) {
            contentWidth = maxWidth;
            contentHeight = this._itemHeight;
            comp = this._createScrollbar(compStyle, contentWidth);
            this._pagerComponent = comp;
            this._innerView.add(comp);
        }
        else {
            contentHeight = maxHeight - renderStartY;
            contentWidth = this._itemMaxWidth;
            comp = this._createScrollbar(compStyle, contentHeight);
            this._pagerComponent = comp;
            this._innerView.add(comp);
            if (contentHeight <= 0) {
                this._innerView.removeChild(comp);
                return false;
            }
            const items = itemsContainer.getChildren();
            const itemsHeightArr = items.map((item) => item.attribute.height);
            if (itemsHeightArr.length === 1 || itemsHeightArr.every(entry => entry === itemsHeightArr[0])) {
                const itemHeight = itemsHeightArr[0];
                const maxContentHeight = contentHeight;
                const pageItemsCount = Math.floor(maxContentHeight / (spaceRow + itemHeight));
                contentHeight = pageItemsCount * (spaceRow + itemHeight);
                pages = Math.ceil(items.length / pageItemsCount);
            }
            else {
                items.forEach((item, index) => {
                    const { height } = item.attribute;
                    const prePages = pages;
                    const preStartY = startY;
                    pages = Math.floor((startY + height) / contentHeight) + 1;
                    startY += spaceRow + height;
                    if (prePages !== pages &&
                        index === itemsContainer.getChildren().length - 1 &&
                        startY - contentHeight >= (1 / 3) * height) {
                        contentHeight = preStartY + height;
                        pages -= 1;
                    }
                });
            }
            this._itemContext.totalPage = pages;
            this._itemContext.pages = pages;
        }
        if (defaultCurrent > 1) {
            if (isHorizontal) {
                const maxOffset = this._itemsContainer.AABBBounds.width() - contentWidth;
                itemsContainer.setAttribute('x', -Math.min((defaultCurrent - 1) * (contentWidth + spaceCol), maxOffset));
            }
            else {
                const maxOffset = this._itemsContainer.AABBBounds.height() - contentHeight;
                itemsContainer.setAttribute('y', -Math.min((defaultCurrent - 1) * (contentHeight + spaceRow), maxOffset));
            }
        }
        const clipGroup = graphicCreator.group({
            x: 0,
            y: renderStartY,
            width: contentWidth,
            height: contentHeight,
            clip: true,
            pickable: false
        });
        clipGroup.add(itemsContainer);
        this._innerView.add(clipGroup);
        this._itemContext.clipContainer = clipGroup;
        this._updatePositionOfScrollbar(contentWidth, contentHeight, renderStartY);
        if ((_a = pager.scrollMask) === null || _a === void 0 ? void 0 : _a.visible) {
            this.renderScrollMask(clipGroup);
        }
        this._bindEventsOfPager(isHorizontal ? contentWidth : contentHeight, isHorizontal ? 'x' : 'y');
        return true;
    }
    renderScrollMask(clipGroup) {
        const { scrollMask = {} } = this.attribute
            .pager;
        const { visible = true, gradientLength = 16, gradientStops } = scrollMask;
        if (!visible || !gradientStops) {
            return;
        }
        const width = clipGroup.AABBBounds.width();
        const height = clipGroup.AABBBounds.height();
        const totalLength = this._itemContext.isHorizontal ? width : height;
        const startStops = gradientStops.map(stop => {
            return {
                offset: (gradientLength * stop.offset) / totalLength,
                color: stop.color
            };
        });
        const endStops = gradientStops.map(stop => {
            return {
                offset: (totalLength - gradientLength * stop.offset) / totalLength,
                color: stop.color
            };
        });
        const mask = graphicCreator.rect({
            x: 0,
            y: 0,
            width,
            height
        });
        this._scrollMask = mask;
        this._scrollMaskContext = { startStops, endStops };
        this.updateScrollMask();
        clipGroup.add(mask);
    }
    updateScrollMask() {
        if (!this._scrollMask || !this._pagerComponent) {
            return;
        }
        if (!this._itemContext.isScrollbar) {
            return;
        }
        const [start, end] = this._pagerComponent.getScrollRange();
        const stops = [];
        if (!isNumberClose(clamp(end, 0, 1), 1)) {
            stops.push(...this._scrollMaskContext.endStops);
        }
        if (!isNumberClose(clamp(start, 0, 1), 0)) {
            stops.push(...this._scrollMaskContext.startStops);
        }
        if (stops.length) {
            if (this._itemContext.isHorizontal) {
                this._scrollMask.setAttributes({
                    fill: {
                        gradient: 'linear',
                        x0: 0,
                        y0: 0,
                        x1: 1,
                        y1: 0,
                        stops
                    }
                });
            }
            else {
                this._scrollMask.setAttributes({
                    fill: {
                        gradient: 'linear',
                        x0: 0,
                        y0: 0,
                        x1: 0,
                        y1: 1,
                        stops
                    }
                });
            }
        }
    }
    _renderPagerComponent() {
        if (this._itemContext.isScrollbar) {
            this._renderScrollbar();
        }
        else {
            this._renderPager();
        }
        return true;
    }
    _hover(legendItem, e) {
        this._lastActiveItem = legendItem;
        const selected = legendItem.hasState(LegendStateValue.selected);
        if (selected) {
            this._setLegendItemState(legendItem, LegendStateValue.selectedHover, e);
        }
        else {
            this._setLegendItemState(legendItem, LegendStateValue.unSelectedHover, e);
        }
        const focusButton = legendItem.getChildren()[0].find(node => node.name === LEGEND_ELEMENT_NAME.focus, false);
        if (focusButton) {
            focusButton.setAttribute('visible', true);
        }
        this._dispatchLegendEvent(LegendEvent.legendItemHover, legendItem, e);
    }
    _unHover(legendItem, e) {
        let attributeUpdate = false;
        if (legendItem.hasState(LegendStateValue.unSelectedHover) || legendItem.hasState(LegendStateValue.selectedHover)) {
            attributeUpdate = true;
        }
        legendItem.removeState(LegendStateValue.unSelectedHover);
        legendItem.removeState(LegendStateValue.selectedHover);
        legendItem
            .getChildren()[0]
            .getChildren()
            .forEach((child) => {
            if (!attributeUpdate &&
                (child.hasState(LegendStateValue.unSelectedHover) || child.hasState(LegendStateValue.selectedHover))) {
                attributeUpdate = true;
            }
            child.removeState(LegendStateValue.unSelectedHover);
            child.removeState(LegendStateValue.selectedHover);
        });
        const focusButton = legendItem.getChildren()[0].find(node => node.name === LEGEND_ELEMENT_NAME.focus, false);
        if (focusButton) {
            focusButton.setAttribute('visible', false);
        }
        if (attributeUpdate) {
            this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e);
        }
        this._dispatchLegendEvent(LegendEvent.legendItemUnHover, legendItem, e);
    }
    _setLegendItemState(legendItem, stateName, e) {
        const keepCurrentStates = true;
        let attributeUpdate = false;
        if (!legendItem.hasState(stateName)) {
            attributeUpdate = true;
        }
        legendItem.addState(stateName, keepCurrentStates);
        legendItem
            .getChildren()[0]
            .getChildren()
            .forEach((child) => {
            if (child.name !== LEGEND_ELEMENT_NAME.focus) {
                if (!attributeUpdate && !child.hasState(stateName)) {
                    attributeUpdate = true;
                }
                child.addState(stateName, keepCurrentStates);
            }
        });
        if (attributeUpdate) {
            this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e);
        }
    }
    _removeLegendItemState(legendItem, stateNames, e) {
        let attributeUpdate = false;
        stateNames.forEach(name => {
            if (!attributeUpdate && legendItem.hasState(name)) {
                attributeUpdate = true;
            }
            legendItem.removeState(name);
        });
        legendItem
            .getChildren()[0]
            .getChildren()
            .forEach(child => {
            if (child.name !== LEGEND_ELEMENT_NAME.focus) {
                stateNames.forEach(name => {
                    if (!attributeUpdate && child.hasState(name)) {
                        attributeUpdate = true;
                    }
                    child.removeState(name);
                });
            }
        });
        if (attributeUpdate) {
            this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e);
        }
    }
    _getSelectedLegends() {
        var _a;
        const selectedData = [];
        (_a = this._itemsContainer) === null || _a === void 0 ? void 0 : _a.getChildren().forEach(item => {
            if (item.hasState(LegendStateValue.selected)) {
                selectedData.push(item.data);
            }
        });
        return selectedData;
    }
    _appendDataToShape(shape, name, data, delegateShape, states = {}) {
        shape.name = name;
        shape.data = data;
        shape.delegate = delegateShape;
        shape.states = merge({}, DEFAULT_STATES, states);
    }
    _dispatchLegendEvent(eventName, legendItem, event) {
        const currentSelectedItems = this._getSelectedLegends();
        currentSelectedItems.sort((pre, next) => pre.index - next.index);
        const currentSelected = currentSelectedItems.map((obj) => obj.label);
        this._dispatchEvent(eventName, {
            item: legendItem,
            data: legendItem.data,
            selected: legendItem.hasState(LegendStateValue.selected),
            currentSelectedItems,
            currentSelected,
            event
        });
    }
    _handleStyle(config, item, isSelected, index, items) {
        const newConfig = {};
        if (config.style) {
            if (isFunction(config.style)) {
                newConfig.style = config.style(item, isSelected, index, items);
            }
            else {
                newConfig.style = config.style;
            }
        }
        if (config.state) {
            newConfig.state = {};
            Object.keys(config.state).forEach(key => {
                if (config.state[key]) {
                    if (isFunction(config.state[key])) {
                        newConfig.state[key] = config.state[key](item, isSelected, index, items);
                    }
                    else {
                        newConfig.state[key] = config.state[key];
                    }
                }
            });
        }
        return newConfig;
    }
    release() {
        super.release();
        this.removeAllEventListeners();
    }
}
DiscreteLegend.defaultAttributes = {
    layout: 'horizontal',
    title: {
        align: 'start',
        space: DEFAULT_TITLE_SPACE,
        textStyle: {
            fontSize: 12,
            fontWeight: 'bold',
            fill: '#2C3542'
        }
    },
    item: {
        spaceCol: DEFAULT_ITEM_SPACE_COL,
        spaceRow: DEFAULT_ITEM_SPACE_ROW,
        shape: {
            space: DEFAULT_SHAPE_SPACE,
            style: {
                size: DEFAULT_SHAPE_SIZE,
                cursor: 'pointer'
            },
            state: {
                selectedHover: {
                    opacity: 0.85
                },
                unSelected: {
                    opacity: 0.5
                }
            }
        },
        label: {
            space: DEFAULT_LABEL_SPACE,
            style: {
                fontSize: 12,
                fill: '#2C3542',
                cursor: 'pointer'
            },
            state: {
                selectedHover: {
                    opacity: 0.85
                },
                unSelected: {
                    fill: '#D8D8D8'
                }
            }
        },
        value: {
            alignRight: false,
            style: {
                fontSize: 12,
                fill: '#ccc',
                cursor: 'pointer'
            },
            state: {
                selectedHover: {
                    opacity: 0.85
                },
                unSelected: {
                    fill: '#D8D8D8'
                }
            }
        },
        background: {
            style: {
                cursor: 'pointer'
            }
        },
        focus: false,
        focusIconStyle: {
            size: DEFAULT_SHAPE_SIZE,
            symbolType: 'M8 1C11.866 1 15 4.13401 15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1ZM8.75044 2.55077L8.75 3.75H7.25L7.25006 2.5507C4.81247 2.88304 2.88304 4.81247 2.5507 7.25006L3.75 7.25V8.75L2.55077 8.75044C2.8833 11.1878 4.81264 13.117 7.25006 13.4493L7.25 12.25H8.75L8.75044 13.4492C11.1876 13.1167 13.1167 11.1876 13.4492 8.75044L12.25 8.75V7.25L13.4493 7.25006C13.117 4.81264 11.1878 2.8833 8.75044 2.55077ZM8 5.5C9.38071 5.5 10.5 6.61929 10.5 8C10.5 9.38071 9.38071 10.5 8 10.5C6.61929 10.5 5.5 9.38071 5.5 8C5.5 6.61929 6.61929 5.5 8 5.5ZM8 7C7.44772 7 7 7.44772 7 8C7 8.55228 7.44772 9 8 9C8.55228 9 9 8.55228 9 8C9 7.44772 8.55228 7 8 7Z',
            fill: '#333',
            cursor: 'pointer'
        }
    },
    autoPage: true,
    pager: {
        space: DEFAULT_PAGER_SPACE,
        handler: {
            style: { size: 10 },
            space: 4
        }
    },
    hover: true,
    select: true,
    selectMode: 'multiple',
    allowAllCanceled: true
};

var SLIDER_ELEMENT_NAME;
(function (SLIDER_ELEMENT_NAME) {
    SLIDER_ELEMENT_NAME["innerView"] = "innerView";
    SLIDER_ELEMENT_NAME["railContainer"] = "sliderRailContainer";
    SLIDER_ELEMENT_NAME["rail"] = "sliderRail";
    SLIDER_ELEMENT_NAME["startText"] = "sliderStartText";
    SLIDER_ELEMENT_NAME["endText"] = "sliderEndText";
    SLIDER_ELEMENT_NAME["startHandler"] = "sliderStartHandler";
    SLIDER_ELEMENT_NAME["startHandlerText"] = "startHandlerText";
    SLIDER_ELEMENT_NAME["endHandler"] = "sliderEndHandler";
    SLIDER_ELEMENT_NAME["endHandlerText"] = "sliderEndHandlerText";
    SLIDER_ELEMENT_NAME["track"] = "sliderTrack";
    SLIDER_ELEMENT_NAME["trackContainer"] = "sliderTrackContainer";
})(SLIDER_ELEMENT_NAME || (SLIDER_ELEMENT_NAME = {}));

function convertValueToRange(value) {
    if (isArray(value)) {
        return value;
    }
    return [value, value];
}
function getDefaultCursor(isHorizontal) {
    return isHorizontal ? 'ew-resize' : 'ns-resize';
}
loadSliderComponent();
class Slider extends AbstractComponent {
    get track() {
        return this._track;
    }
    get currentValue() {
        return this._currentValue;
    }
    get startHandler() {
        return this._startHandler;
    }
    get endHandler() {
        return this._endHandler;
    }
    get tooltipShape() {
        return this._tooltipShape;
    }
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, Slider.defaultAttributes, attributes));
        this.name = 'slider';
        this._isHorizontal = true;
        this._startHandler = null;
        this._endHandler = null;
        this._startHandlerText = null;
        this._endHandlerText = null;
        this._currentHandler = null;
        this._currentValue = {};
        this._onTooltipShow = (e) => {
            if (this._isChanging || (this._tooltipState && this._tooltipState.isActive)) {
                return;
            }
            if (!this._tooltipState) {
                this._tooltipState = { isActive: true };
            }
            else {
                this._tooltipState.isActive = true;
            }
            this._onTooltipUpdate(e);
            this._dispatchTooltipEvent('sliderTooltipShow');
        };
        this._onTooltipUpdate = (e) => {
            if (this._isChanging || !this._tooltipState || !this._tooltipState.isActive) {
                return;
            }
            const railLen = this._isHorizontal ? this._rail.globalAABBBounds.width() : this._rail.globalAABBBounds.height();
            const pos = clamp(this._isHorizontal
                ? (e.viewX - this._rail.globalAABBBounds.x1) / railLen
                : (e.viewY - this._rail.globalAABBBounds.y1) / railLen, 0, 1);
            if (pos !== this._tooltipState.pos) {
                this._tooltipState.pos = pos;
                this._tooltipState.value = this.calculateValueByPos(pos * railLen);
                this._updateTooltip();
                this._dispatchTooltipEvent('sliderTooltipUpdate');
            }
        };
        this._onTooltipHide = () => {
            const { tooltip } = this.attribute;
            if (tooltip && tooltip.alwaysShow) {
                return;
            }
            this._tooltipState = null;
            if (this._tooltipShape) {
                this._tooltipShape.setAttribute('visible', false);
            }
            if (this._tooltipText) {
                this._tooltipText.setAttribute('visible', false);
            }
            this._dispatchTooltipEvent('sliderTooltipHide');
        };
        this._onHandlerPointerdown = (e) => {
            this._clearAllDragEvents();
            this._isChanging = true;
            const { x, y } = this.stage.eventPointTransform(e);
            this._currentHandler = e.target;
            this._prePos = this._isHorizontal ? x : y;
            const triggers = getEndTriggersOfDrag();
            const obj = vglobal.env === 'browser' ? vglobal : this.stage;
            obj.addEventListener('pointermove', this._onHandlerPointerMove, { capture: true });
            triggers.forEach((trigger) => {
                obj.addEventListener(trigger, this._onHandlerPointerUp);
            });
        };
        this._onHandlerPointerMove = (e) => {
            var _a, _b;
            this._isChanging = true;
            const { railWidth, railHeight, min, max } = this.attribute;
            if (max === min) {
                return;
            }
            const { x, y } = this.stage.eventPointTransform(e);
            let currentPos;
            let delta = 0;
            let originPos;
            let railLen;
            if (!this._isHorizontal) {
                currentPos = y;
                delta = currentPos - this._prePos;
                originPos = (_a = this._currentHandler) === null || _a === void 0 ? void 0 : _a.attribute.y;
                railLen = railHeight;
            }
            else {
                currentPos = x;
                delta = currentPos - this._prePos;
                originPos = (_b = this._currentHandler) === null || _b === void 0 ? void 0 : _b.attribute.x;
                railLen = railWidth;
            }
            const newPos = clamp(originPos + delta, 0, railLen);
            const currentValue = this.calculateValueByPos(newPos);
            if (this._currentHandler.type === 'text') {
                this._updateHandlerText(this._currentHandler, newPos, currentValue);
            }
            else {
                this._updateHandler(this._currentHandler, newPos, currentValue);
            }
            this._updateTrack();
            this._prePos = currentPos;
            this._dispatchChangeEvent();
        };
        this._onHandlerPointerUp = (e) => {
            this._isChanging = false;
            this._currentHandler = null;
            this._clearAllDragEvents();
        };
        this._handleTouchMove = (e) => {
            if (this._isChanging) {
                e.preventDefault();
            }
        };
        this._onTrackPointerdown = (e) => {
            this._clearAllDragEvents();
            this._isChanging = true;
            const { x, y } = this.stage.eventPointTransform(e);
            this._prePos = this._isHorizontal ? x : y;
            const triggers = getEndTriggersOfDrag();
            const obj = vglobal.env === 'browser' ? vglobal : this.stage;
            obj.addEventListener('pointermove', this._onTrackPointerMove, { capture: true });
            triggers.forEach((trigger) => {
                obj.addEventListener(trigger, this._onTrackPointerUp);
            });
        };
        this._onTrackPointerMove = (e) => {
            this._isChanging = true;
            const { railWidth, railHeight, min, max, inverse } = this.attribute;
            if (max === min) {
                return;
            }
            const { startHandler, endHandler } = this._getHandlers();
            let currentPos;
            let trackLen;
            let railLen;
            const { x, y } = this.stage.eventPointTransform(e);
            if (this._isHorizontal) {
                currentPos = x;
                trackLen = this._track.attribute.width;
                railLen = railWidth;
            }
            else {
                currentPos = y;
                trackLen = this._track.attribute.height;
                railLen = railHeight;
            }
            const delta = currentPos - this._prePos;
            if (startHandler) {
                const originPos = (this._isHorizontal ? startHandler.attribute.x : startHandler.attribute.y);
                const newPos = inverse
                    ? clamp(originPos + delta, trackLen, railLen)
                    : clamp(originPos + delta, 0, railLen - trackLen);
                const currentValue = this.calculateValueByPos(newPos);
                this._updateHandler(startHandler, newPos, currentValue);
            }
            if (endHandler) {
                const originPos = (this._isHorizontal ? endHandler.attribute.x : endHandler.attribute.y);
                const newPos = inverse
                    ? clamp(originPos + delta, 0, railLen - trackLen)
                    : clamp(originPos + delta, trackLen, railLen);
                const currentValue = this.calculateValueByPos(newPos);
                const startHandlerAttribute = startHandler === null || startHandler === void 0 ? void 0 : startHandler.attribute;
                this._updateHandler(endHandler, newPos, currentValue);
                this._track.setAttributes(this._isHorizontal
                    ? {
                        x: Math.min(startHandlerAttribute.x, endHandler.attribute.x),
                        width: Math.abs(startHandlerAttribute.x - endHandler.attribute.x)
                    }
                    : {
                        y: Math.min(startHandlerAttribute.y, endHandler.attribute.y),
                        height: Math.abs(startHandlerAttribute.y - endHandler.attribute.y)
                    });
            }
            this._prePos = currentPos;
            this._dispatchChangeEvent();
        };
        this._onTrackPointerUp = (e) => {
            this._isChanging = false;
            this._clearAllDragEvents();
        };
        this._onRailPointerDown = (e) => {
            this._clearAllDragEvents();
            this._isChanging = true;
            const { railWidth, railHeight, min, max } = this.attribute;
            if (max === min) {
                return;
            }
            const startHandler = this._startHandler;
            const endHandler = this._endHandler;
            let currentPos;
            let startHandlerPos;
            let endHandlerPos;
            if (this._isHorizontal) {
                currentPos = e.viewX - this._rail.globalAABBBounds.x1;
                startHandlerPos = startHandler === null || startHandler === void 0 ? void 0 : startHandler.attribute.x;
                endHandlerPos = endHandler === null || endHandler === void 0 ? void 0 : endHandler.attribute.x;
            }
            else {
                currentPos = e.viewY - this._rail.globalAABBBounds.y1;
                startHandlerPos = startHandler === null || startHandler === void 0 ? void 0 : startHandler.attribute.y;
                endHandlerPos = endHandler === null || endHandler === void 0 ? void 0 : endHandler.attribute.y;
            }
            const currentValue = this.calculateValueByPos(currentPos);
            if (isValid(endHandlerPos)) {
                const updateHandler = (Math.abs(currentPos - startHandlerPos) > Math.abs(currentPos - endHandlerPos) ? endHandler : startHandler);
                this._updateHandler(updateHandler, currentPos, currentValue);
            }
            else {
                this._updateHandler(startHandler, currentPos, currentValue);
            }
            this._updateTrack();
            this._dispatchChangeEvent();
        };
    }
    calculatePosByValue(value, pos) {
        const { layout, railWidth, railHeight, min, max, inverse } = this.attribute;
        let ratio = 0;
        if (min === max) {
            ratio = pos === 'start' ? 0 : pos === 'end' ? 1 : 0;
        }
        else {
            ratio = (value - min) / (max - min);
        }
        const railLen = layout === 'vertical' ? railHeight : railWidth;
        return (inverse ? 1 - ratio : ratio) * railLen;
    }
    calculateValueByPos(pos) {
        const { layout, railWidth, railHeight, min, max, inverse } = this.attribute;
        const railLen = layout === 'vertical' ? railHeight : railWidth;
        return min + (max - min) * (inverse ? 1 - pos / railLen : pos / railLen);
    }
    setValue(value) {
        const { min, max } = this.attribute;
        if (max === min) {
            return;
        }
        const [startValue, endValue] = array(value);
        const { startHandler, endHandler } = this._getHandlers();
        if (startHandler) {
            this._updateHandler(startHandler, this.calculatePosByValue(startValue), startValue);
        }
        if (endHandler) {
            this._updateHandler(endHandler, this.calculatePosByValue(endValue), endValue);
        }
        this._updateTrack();
    }
    render() {
        var _a, _b;
        this.removeAllChild(true);
        const { layout = 'horizontal', railWidth, railHeight, startText, endText, min, max, showHandler = true, showTooltip } = this.attribute;
        let { value } = this.attribute;
        if (isNil(value)) {
            value = [min, max];
        }
        this._currentValue = {
            startValue: convertValueToRange(value)[0],
            endValue: convertValueToRange(value)[1]
        };
        const isHorizontal = layout === 'horizontal';
        this._isHorizontal = isHorizontal;
        const innerView = graphicCreator.group({
            x: 0,
            y: 0
        });
        innerView.name = SLIDER_ELEMENT_NAME.innerView;
        this.add(innerView);
        this._innerView = innerView;
        let startLen = 0;
        let startTextShape;
        if (startText && startText.visible) {
            startTextShape = graphicCreator.text(Object.assign({ x: isHorizontal ? 0 : railWidth / 2, y: isHorizontal ? railHeight / 2 : 0, textAlign: isHorizontal ? 'start' : 'center', textBaseline: isHorizontal ? 'middle' : 'top', text: startText.text, lineHeight: (_a = startText.style) === null || _a === void 0 ? void 0 : _a.fontSize }, startText.style));
            startTextShape.name = SLIDER_ELEMENT_NAME.startText;
            innerView.add(startTextShape);
            const space = isValid(startText.space) ? startText.space : 0;
            startLen += (isHorizontal ? startTextShape.AABBBounds.width() : startTextShape.AABBBounds.height()) + space;
        }
        const mainContainer = graphicCreator.group({
            x: isHorizontal ? startLen : 0,
            y: isHorizontal ? 0 : startLen
        });
        innerView.add(mainContainer);
        const railContainer = graphicCreator.group({
            x: 0,
            y: 0
        });
        railContainer.name = SLIDER_ELEMENT_NAME.railContainer;
        this._railContainer = railContainer;
        mainContainer.add(railContainer);
        this._mainContainer = mainContainer;
        this._renderRail(railContainer);
        startLen += isHorizontal ? railWidth : railHeight;
        let endTextShape;
        if (endText && endText.visible) {
            const space = isValid(endText.space) ? endText.space : 0;
            endTextShape = graphicCreator.text(Object.assign({ x: isHorizontal ? startLen + space : railWidth / 2, y: isHorizontal ? railHeight / 2 : startLen + space, textAlign: isHorizontal ? 'start' : 'center', textBaseline: isHorizontal ? 'middle' : 'top', text: endText.text, lineHeight: (_b = endText.style) === null || _b === void 0 ? void 0 : _b.fontSize }, endText.style));
            endTextShape.name = SLIDER_ELEMENT_NAME.endText;
            innerView.add(endTextShape);
        }
        this._renderTrack(railContainer);
        if (showHandler) {
            this._renderHandlers(mainContainer);
            this._bindEvents();
        }
        if (showTooltip) {
            this._renderTooltip();
            this._bindTooltipEvents();
        }
    }
    _renderRail(container) {
        const { railWidth, railHeight, railStyle, slidable } = this.attribute;
        let cursor = 'default';
        if (slidable !== false) {
            cursor = 'pointer';
        }
        const railShape = graphicCreator.rect(Object.assign({ x: 0, y: 0, width: railWidth, height: railHeight, cursor }, railStyle));
        railShape.name = SLIDER_ELEMENT_NAME.rail;
        container.add(railShape);
        this._rail = railShape;
        return railShape;
    }
    _renderHandlers(container) {
        const { range, min, max, handlerSize = 14, handlerStyle, handlerText, railHeight, railWidth, slidable } = this.attribute;
        let { value } = this.attribute;
        if (isNil(value)) {
            value = [min, max];
        }
        const handlerTextVisible = handlerText && handlerText.visible;
        const isHorizontal = this._isHorizontal;
        const [startValue, endValue] = convertValueToRange(value);
        const startPos = this.calculatePosByValue(startValue, range ? 'start' : 'end');
        const startHandler = this._renderHandler(Object.assign({ x: isHorizontal ? startPos : railWidth / 2, y: isHorizontal ? railHeight / 2 : startPos, size: handlerSize, strokeBoundsBuffer: 0, cursor: slidable === false ? 'default' : getDefaultCursor(isHorizontal) }, handlerStyle));
        startHandler.name = SLIDER_ELEMENT_NAME.startHandler;
        this._startHandler = startHandler;
        container.add(startHandler);
        this._currentValue.startPos = startPos;
        if (handlerTextVisible) {
            const startHandlerText = this._renderHandlerText(startValue, range ? 'start' : 'end');
            startHandlerText.name = SLIDER_ELEMENT_NAME.startHandlerText;
            container.add(startHandlerText);
            this._startHandlerText = startHandlerText;
        }
        if (range) {
            const endPos = this.calculatePosByValue(endValue, 'end');
            const endHandler = this._renderHandler(Object.assign({ x: isHorizontal ? endPos : railWidth / 2, y: isHorizontal ? railHeight / 2 : endPos, size: handlerSize, strokeBoundsBuffer: 0, cursor: slidable === false ? 'default' : getDefaultCursor(isHorizontal) }, handlerStyle));
            endHandler.name = SLIDER_ELEMENT_NAME.endHandler;
            this._endHandler = endHandler;
            container.add(endHandler);
            this._currentValue.endPos = endPos;
            if (handlerTextVisible) {
                const endHandlerText = this._renderHandlerText(endValue, 'end');
                endHandlerText.name = SLIDER_ELEMENT_NAME.endHandlerText;
                container.add(endHandlerText);
                this._endHandlerText = endHandlerText;
            }
        }
    }
    _renderTrack(container) {
        const { range, min, max, railHeight, railWidth, trackStyle, railStyle, slidable, value } = this
            .attribute;
        let startValue;
        let endValue;
        if (isNil(value)) {
            if (range) {
                startValue = min;
                endValue = max;
            }
            else {
                startValue = endValue = min;
            }
        }
        else {
            if (range) {
                const clampValue = clampRange(value, min, max);
                startValue = clampValue[0];
                endValue = clampValue[1];
            }
            else {
                startValue = min;
                endValue = clamp(value, min, max);
            }
        }
        const isHorizontal = this._isHorizontal;
        if (!range) {
            startValue = min;
        }
        const trackContainer = graphicCreator.group({
            x: 0,
            y: 0,
            width: railWidth,
            height: railHeight,
            cornerRadius: railStyle === null || railStyle === void 0 ? void 0 : railStyle.cornerRadius,
            clip: true,
            pickable: false
        });
        trackContainer.name = SLIDER_ELEMENT_NAME.trackContainer;
        const draggableTrack = isObject(range) && range.draggableTrack === true;
        let cursor;
        if (slidable === false) {
            cursor = 'default';
        }
        else if (range === false) {
            cursor = 'pointer';
        }
        else if (draggableTrack === false) {
            cursor = 'pointer';
        }
        else {
            cursor = getDefaultCursor(isHorizontal);
        }
        const startPos = this.calculatePosByValue(startValue, 'start');
        const endPos = this.calculatePosByValue(endValue, range ? 'end' : 'start');
        const track = graphicCreator.rect(Object.assign({ x: isHorizontal ? Math.min(startPos, endPos) : 0, y: isHorizontal ? 0 : Math.min(startPos, endPos), width: isHorizontal ? Math.abs(endPos - startPos) : railWidth, height: isHorizontal ? railHeight : Math.abs(endPos - startPos), cursor }, trackStyle));
        track.name = SLIDER_ELEMENT_NAME.track;
        this._track = track;
        trackContainer.add(track);
        container.add(trackContainer);
    }
    _renderHandler(style) {
        const handler = graphicCreator.symbol(style);
        return handler;
    }
    _renderHandlerText(value, position) {
        var _a, _b, _c;
        const { align, handlerSize = 14, handlerText = {}, railHeight, railWidth, slidable } = this.attribute;
        const isHorizontal = this._isHorizontal;
        const pos = this.calculatePosByValue(value, position);
        const textSpace = (_a = handlerText.space) !== null && _a !== void 0 ? _a : 4;
        const textStyle = {
            text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed((_b = handlerText.precision) !== null && _b !== void 0 ? _b : 0),
            lineHeight: (_c = handlerText.style) === null || _c === void 0 ? void 0 : _c.lineHeight,
            cursor: slidable === false ? 'default' : getDefaultCursor(isHorizontal)
        };
        if (isHorizontal) {
            if (align === 'top') {
                textStyle.textBaseline = 'bottom';
                textStyle.textAlign = 'center';
                textStyle.x = pos;
                textStyle.y = (railHeight - handlerSize) / 2 - textSpace;
            }
            else {
                textStyle.textBaseline = 'top';
                textStyle.textAlign = 'center';
                textStyle.x = pos;
                textStyle.y = (railHeight + handlerSize) / 2 + textSpace;
            }
        }
        else {
            if (align === 'left') {
                textStyle.textBaseline = 'middle';
                textStyle.textAlign = 'end';
                textStyle.x = (railWidth - handlerSize) / 2 - textSpace;
                textStyle.y = pos;
            }
            else {
                textStyle.textBaseline = 'middle';
                textStyle.textAlign = 'start';
                textStyle.x = (railWidth + handlerSize) / 2 + textSpace;
                textStyle.y = pos;
            }
        }
        const textShape = graphicCreator.text(Object.assign(Object.assign({}, textStyle), handlerText.style));
        return textShape;
    }
    _renderTooltip() {
        var _a;
        const { tooltip, railHeight, railWidth, align } = this.attribute;
        if (tooltip && tooltip.alwaysShow) {
            this._tooltipState = {
                value: this._currentValue.startValue,
                pos: this._currentValue.startPos
            };
        }
        else {
            this._tooltipState = null;
        }
        const cx = this._isHorizontal ? 0 : railWidth / 2;
        const cy = this._isHorizontal ? railHeight / 2 : 0;
        if (tooltip && tooltip.shape) {
            const shape = graphicCreator.symbol(Object.assign({ pickable: false, visible: !!this._tooltipState, x: cx, y: cy, symbolType: 'circle' }, tooltip.shapeStyle));
            this._tooltipShape = shape;
            this._mainContainer.add(shape);
        }
        const textConfig = (tooltip && tooltip.text) || {};
        const space = (_a = textConfig.space) !== null && _a !== void 0 ? _a : 6;
        const textStyle = {
            pickable: false,
            visible: !!this._tooltipState,
            text: ''
        };
        if (this._isHorizontal) {
            textStyle.x = cx;
            textStyle.y = align === 'top' ? cy - railHeight / 2 - space : cy + railHeight / 2 + space;
            textStyle.textAlign = 'center';
            textStyle.textBaseline = align === 'top' ? 'bottom' : 'top';
        }
        else {
            textStyle.y = cy;
            textStyle.x = align === 'left' ? cx - railWidth / 2 - space : cy + railWidth / 2 + space;
            textStyle.textAlign = align === 'left' ? 'end' : 'start';
            textStyle.textBaseline = 'middle';
        }
        const text = graphicCreator.text(Object.assign(Object.assign({}, textStyle), textConfig.style));
        this._mainContainer.add(text);
        this._tooltipText = text;
        if (this._tooltipState) {
            this._updateTooltip();
        }
    }
    _updateTooltip() {
        var _a, _b;
        if ((!this._tooltipShape && !this._tooltipText) || !this._tooltipState) {
            return;
        }
        const { railWidth, railHeight } = this.attribute;
        const railLen = this._isHorizontal ? railWidth : railHeight;
        const coord = this._tooltipState.pos * railLen;
        const coordKey = this._isHorizontal ? 'x' : 'y';
        if (this._tooltipShape) {
            this._tooltipShape.setAttributes({
                visible: true,
                [coordKey]: coord
            });
        }
        const { align } = this.attribute;
        if (this._tooltipText) {
            const textConfig = (this.attribute.tooltip && this.attribute.tooltip.text) || {};
            this._tooltipText.setAttributes({
                visible: true,
                [coordKey]: coord,
                text: textConfig.formatter
                    ? textConfig.formatter(this._tooltipState.value)
                    : !this._isHorizontal && align === 'left'
                        ? `${this._tooltipState.value.toFixed((_a = textConfig.precision) !== null && _a !== void 0 ? _a : 0)} ≈`
                        : `≈ ${this._tooltipState.value.toFixed((_b = textConfig.precision) !== null && _b !== void 0 ? _b : 0)}`
            });
        }
    }
    _bindEvents() {
        if (this.attribute.disableTriggerEvent) {
            return;
        }
        const { slidable, range } = this.attribute;
        if (slidable) {
            if (this._startHandler) {
                this._startHandler.addEventListener('pointerdown', this._onHandlerPointerdown);
            }
            if (this._startHandlerText) {
                this._startHandlerText.addEventListener('pointerdown', this._onHandlerPointerdown);
            }
            if (this._endHandler) {
                this._endHandler.addEventListener('pointerdown', this._onHandlerPointerdown);
            }
            if (this._endHandlerText) {
                this._endHandlerText.addEventListener('pointerdown', this._onHandlerPointerdown);
            }
            if (isObject(range) && range.draggableTrack) {
                this._track.addEventListener('pointerdown', this._onTrackPointerdown);
            }
            this._railContainer.addEventListener('pointerdown', this._onRailPointerDown);
            (vglobal.env === 'browser' ? vglobal : this.stage).addEventListener('touchmove', this._handleTouchMove, {
                passive: false
            });
        }
    }
    _bindTooltipEvents() {
        if (this.attribute.disableTriggerEvent) {
            return;
        }
        this._mainContainer.addEventListener('pointerenter', this._onTooltipShow);
        this._mainContainer.addEventListener('pointermove', this._onTooltipUpdate);
        this._mainContainer.addEventListener('pointerleave', this._onTooltipHide);
    }
    _clearAllDragEvents() {
        const triggers = getEndTriggersOfDrag();
        const obj = vglobal.env === 'browser' ? vglobal : this.stage;
        obj.removeEventListener('pointermove', this._onHandlerPointerMove, { capture: true });
        triggers.forEach((trigger) => {
            obj.removeEventListener(trigger, this._onHandlerPointerUp);
        });
        obj.removeEventListener('pointermove', this._onTrackPointerMove, { capture: true });
        triggers.forEach((trigger) => {
            obj.removeEventListener(trigger, this._onTrackPointerUp);
        });
    }
    _updateTrack() {
        const { inverse, railWidth, railHeight } = this.attribute;
        const startHandler = this._startHandler;
        const endHandler = this._endHandler;
        if (this._isHorizontal) {
            const startHandlerPos = startHandler === null || startHandler === void 0 ? void 0 : startHandler.attribute.x;
            if (endHandler) {
                const endHandlerPos = endHandler === null || endHandler === void 0 ? void 0 : endHandler.attribute.x;
                this._track.setAttributes({
                    x: Math.min(startHandlerPos, endHandlerPos),
                    width: Math.abs(startHandlerPos - endHandlerPos)
                });
            }
            else if (inverse) {
                this._track.setAttributes({
                    x: startHandlerPos,
                    width: railWidth - startHandlerPos
                });
            }
            else {
                this._track.setAttributes({
                    width: startHandlerPos
                });
            }
        }
        else {
            const startHandlerPos = startHandler === null || startHandler === void 0 ? void 0 : startHandler.attribute.y;
            if (endHandler) {
                const endHandlerPos = endHandler === null || endHandler === void 0 ? void 0 : endHandler.attribute.y;
                this._track.setAttributes({
                    y: Math.min(startHandlerPos, endHandlerPos),
                    height: Math.abs(startHandlerPos - endHandlerPos)
                });
            }
            else if (inverse) {
                this._track.setAttributes({
                    y: startHandlerPos,
                    height: railHeight - startHandlerPos
                });
            }
            else {
                this._track.setAttributes({
                    height: startHandlerPos
                });
            }
        }
    }
    _updateHandler(handler, position, value) {
        var _a;
        const isHorizontal = this._isHorizontal;
        handler.setAttribute(isHorizontal ? 'x' : 'y', position);
        const updateHandlerText = handler.name === SLIDER_ELEMENT_NAME.startHandler ? this._startHandlerText : this._endHandlerText;
        if (updateHandlerText) {
            const { handlerText = {} } = this.attribute;
            updateHandlerText.setAttributes({
                text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed((_a = handlerText.precision) !== null && _a !== void 0 ? _a : 0),
                [isHorizontal ? 'x' : 'y']: position
            });
        }
        if (handler.name === SLIDER_ELEMENT_NAME.startHandler) {
            this._currentValue.startValue = value;
            this._currentValue.startPos = position;
        }
        else {
            this._currentValue.endValue = value;
            this._currentValue.endPos = position;
        }
    }
    _updateHandlerText(handlerText, position, value) {
        var _a;
        const isHorizontal = this._isHorizontal;
        const { handlerText: handlerTextAttr = {} } = this.attribute;
        handlerText.setAttributes({
            [isHorizontal ? 'x' : 'y']: position,
            text: handlerTextAttr.formatter ? handlerTextAttr.formatter(value) : value.toFixed((_a = handlerTextAttr.precision) !== null && _a !== void 0 ? _a : 0)
        });
        const updateHandler = handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? this._startHandler : this._endHandler;
        if (updateHandler) {
            updateHandler.setAttributes({
                [isHorizontal ? 'x' : 'y']: position
            });
        }
        if (handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText) {
            this._currentValue.startValue = value;
            this._currentValue.startPos = position;
        }
        else {
            this._currentValue.endValue = value;
            this._currentValue.endPos = position;
        }
    }
    _dispatchChangeEvent() {
        const isRange = !!this.attribute.range;
        const currentValue = this._currentValue;
        this._dispatchEvent('change', {
            value: isRange
                ? [
                    Math.min(currentValue.endValue, currentValue.startValue),
                    Math.max(currentValue.endValue, currentValue.startValue)
                ]
                : currentValue.startValue,
            position: isRange
                ? [
                    Math.min(currentValue.endPos, currentValue.startPos),
                    Math.max(currentValue.endPos, currentValue.startPos)
                ]
                : currentValue.startPos
        });
    }
    _dispatchTooltipEvent(type) {
        this._dispatchEvent('sliderTooltip', {
            type,
            position: this._tooltipState && this._tooltipState.pos,
            value: this._tooltipState && this._tooltipState.value
        });
    }
    _getHandlers() {
        const { inverse } = this.attribute;
        let startHandler = this._startHandler;
        let endHandler = this._endHandler;
        if (!endHandler) {
            return { startHandler, endHandler };
        }
        if (this._isHorizontal) {
            if ((!inverse && endHandler.attribute.x < (startHandler === null || startHandler === void 0 ? void 0 : startHandler.attribute.x)) ||
                (inverse && endHandler.attribute.x > (startHandler === null || startHandler === void 0 ? void 0 : startHandler.attribute.x))) {
                [startHandler, endHandler] = [endHandler, startHandler];
            }
        }
        else {
            if ((!inverse && endHandler.attribute.y < (startHandler === null || startHandler === void 0 ? void 0 : startHandler.attribute.y)) ||
                (inverse && endHandler.attribute.y > (startHandler === null || startHandler === void 0 ? void 0 : startHandler.attribute.y))) {
                [startHandler, endHandler] = [endHandler, startHandler];
            }
        }
        return {
            startHandler,
            endHandler
        };
    }
    release(all) {
        super.release(all);
        (vglobal.env === 'browser' ? vglobal : this.stage).addEventListener('touchmove', this._handleTouchMove, {
            passive: false
        });
        this._clearAllDragEvents();
    }
}
Slider.defaultAttributes = {
    slidable: true,
    layout: 'horizontal',
    align: 'bottom',
    height: 8,
    showHandler: true,
    handlerSize: 14,
    handlerStyle: {
        symbolType: 'circle',
        fill: '#fff',
        stroke: '#91caff',
        lineWidth: 2
    },
    tooltip: {
        shapeStyle: {
            symbolType: 'circle',
            fill: '#fff',
            stroke: '#91caff',
            lineWidth: 2
        },
        text: {
            style: {
                fill: '#2C3542',
                fontSize: 12
            }
        }
    },
    railStyle: {
        fill: 'rgba(0,0,0,.04)'
    },
    trackStyle: {
        fill: '#91caff'
    },
    showValue: true,
    valueStyle: {
        fill: '#2C3542',
        fontSize: 12
    },
    startText: {
        style: {
            fill: '#2C3542',
            fontSize: 12
        }
    },
    endText: {
        style: {
            fill: '#2C3542',
            fontSize: 12
        }
    },
    handlerText: {
        visible: true,
        space: 4,
        precision: 0,
        style: {
            fill: '#2C3542',
            fontSize: 12
        }
    }
};

loadColorContinuousLegendComponent();
class ColorContinuousLegend extends LegendBase {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, ColorContinuousLegend.defaultAttributes, attributes));
        this.name = 'colorLegend';
        this._onSliderToolipChange = (e) => {
            const tooltipShape = this._slider.tooltipShape;
            if (tooltipShape && e.detail && !isNil(e.detail.value)) {
                const color = this._colorScale.scale(e.detail.value);
                tooltipShape.setAttribute('fill', color);
            }
            this.dispatchEvent(e);
        };
        this._onSliderChange = (e) => {
            this._updateColor();
            this.dispatchEvent(e);
        };
    }
    setSelected(value) {
        if (!this._slider) {
            return;
        }
        this._slider.setValue(value);
        this._updateColor();
    }
    _renderContent() {
        const { colors, slidable, layout, align, min, max, value, railWidth, railHeight, showHandler = true, handlerSize, handlerStyle, railStyle, trackStyle, startText, endText, handlerText, showTooltip, tooltip, inverse, disableTriggerEvent } = this.attribute;
        const domain = [];
        const step = (max - min) / (colors.length - 1);
        for (let i = 0; i < colors.length; i++) {
            domain.push(min + step * i);
        }
        this._colorScale = new LinearScale().domain(domain, true).range(colors);
        this._color = this._getTrackColor();
        const slider = new Slider({
            x: 0,
            y: 0,
            range: {
                draggableTrack: true
            },
            slidable,
            layout,
            align,
            min,
            max,
            value,
            railWidth,
            railHeight,
            showHandler,
            handlerSize,
            handlerStyle,
            railStyle,
            trackStyle: Object.assign({ fill: this._color }, trackStyle),
            startText,
            endText,
            handlerText,
            showTooltip,
            tooltip,
            disableTriggerEvent,
            inverse
        });
        this._innerView.add(slider);
        this._slider = slider;
        slider.translateTo(0 - slider.AABBBounds.x1, (this._title ? this._title.AABBBounds.height() + get(this.attribute, 'title.space', DEFAULT_TITLE_SPACE) : 0) -
            slider.AABBBounds.y1);
        this._updateColor();
    }
    _bindEvents() {
        if (this.attribute.disableTriggerEvent) {
            return;
        }
        if (this._slider) {
            this._slider.addEventListener('change', this._onSliderChange);
            this._slider.addEventListener('sliderTooltip', this._onSliderToolipChange);
        }
    }
    _getTrackColor() {
        const { colors, layout, inverse } = this.attribute;
        if (isEmpty(colors)) {
            return undefined;
        }
        const count = colors.length;
        if (count === 1) {
            return colors[0];
        }
        const stops = [];
        for (let i = 0; i < count; i++) {
            const percent = i / (count - 1);
            stops.push({
                offset: percent,
                color: colors[i]
            });
        }
        const isHorizontal = layout === 'horizontal';
        const res = {
            gradient: 'linear',
            stops,
            x0: 0,
            y0: 0,
            x1: isHorizontal ? 1 : 0,
            y1: isHorizontal ? 0 : 1
        };
        if (inverse) {
            if (isHorizontal) {
                res.x0 = 1;
                res.x1 = 0;
            }
            else {
                res.y0 = 1;
                res.y1 = 0;
            }
        }
        return res;
    }
    _updateColor() {
        var _a;
        const { layout = 'horizontal', colors, railWidth, railHeight } = this.attribute;
        const { startHandler, endHandler, track, attribute } = this._slider;
        const { startValue, endValue, startPos, endPos } = this._slider.currentValue;
        const handlerColor = (_a = attribute.handlerStyle) === null || _a === void 0 ? void 0 : _a.fill;
        if (startHandler && !handlerColor) {
            const startHandlerColor = this._colorScale.scale(startValue);
            startHandler.setAttribute('fill', startHandlerColor);
        }
        if (endHandler && !handlerColor) {
            const endHandlerColor = this._colorScale.scale(endValue);
            endHandler.setAttribute('fill', endHandlerColor);
        }
        const isHorizontal = layout === 'horizontal';
        const railLen = isHorizontal ? railWidth : railHeight;
        const trackLength = Math.abs(startPos - endPos);
        if (trackLength !== railLen && colors && colors.length > 1) {
            const stops = this._color.stops;
            const start = Math.min(startPos, endPos);
            const end = Math.max(startPos, endPos);
            const startRatio = start / railLen;
            const endRatio = end / railLen;
            const range = endRatio - startRatio;
            const betweenStops = stops.filter(stop => stop.offset > startRatio && stop.offset < endRatio);
            const minValue = Math.min(startValue, endValue);
            const maxValue = Math.max(startValue, endValue);
            const startColor = this._colorScale.scale(minValue);
            const endColor = this._colorScale.scale(maxValue);
            const newStops = [{ offset: 0, color: startColor }];
            betweenStops.forEach(stop => {
                newStops.push({
                    offset: (stop.offset - startRatio) / range,
                    color: stop.color
                });
            });
            newStops.push({
                offset: 1,
                color: endColor
            });
            track.setAttribute('fill', Object.assign(Object.assign({}, this._color), { stops: newStops }));
        }
    }
}
ColorContinuousLegend.defaultAttributes = {
    layout: 'horizontal',
    title: {
        align: 'start',
        space: DEFAULT_TITLE_SPACE,
        textStyle: {
            fontSize: 12,
            fontWeight: 'bold',
            fill: 'rgba(46, 47, 50, 1)'
        }
    },
    handlerSize: 10,
    handlerStyle: {
        fill: null,
        lineWidth: 4,
        stroke: '#fff',
        outerBorder: {
            distance: 2,
            lineWidth: 1,
            stroke: '#ccc'
        }
    },
    tooltip: {
        shapeStyle: {
            lineWidth: 4,
            stroke: '#fff'
        }
    }
};

function getSizeHandlerPath(align = 'bottom') {
    let centerX = 0;
    const centerY = 0;
    const upperHalf = 3.5;
    const leftHalf = 2.5;
    const arrowY = 6;
    if (align === 'top') {
        return `
    M${centerX},${centerY - arrowY}L${centerX - upperHalf},${centerY - leftHalf}
    v${2 * leftHalf}
    h${2 * upperHalf}
    v${-2 * leftHalf}
    Z
`;
    }
    if (align === 'left') {
        centerX = 1;
        return `
    M${centerX - arrowY},${centerY}L${centerX - arrowY + leftHalf},${centerY - upperHalf}
    h${2 * leftHalf}
    v${2 * upperHalf}
    h${-2 * leftHalf}
    Z
`;
    }
    if (align === 'right') {
        centerX = -1;
        return `
    M${centerX + arrowY},${centerY}L${centerX + arrowY - leftHalf},${centerY - upperHalf}
    h${-2 * leftHalf}
    v${2 * upperHalf}
    h${2 * leftHalf}
    Z
  `;
    }
    return `
    M${centerX},${centerY + arrowY}L${centerX - upperHalf},${centerY + leftHalf}
    v${-2 * leftHalf}
    h${2 * upperHalf}
    v${2 * leftHalf}
    Z
`;
}

loadSizeContinuousLegendComponent();
class SizeContinuousLegend extends LegendBase {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, SizeContinuousLegend.defaultAttributes, attributes));
        this.name = 'sizeLegend';
        this._onSliderChange = (e) => {
            this.dispatchEvent(e);
        };
        this._onSliderToolipChange = (e) => {
            this.dispatchEvent(e);
        };
    }
    setSelected(value) {
        if (!this._slider) {
            return;
        }
        this._slider.setValue(value);
    }
    _renderContent() {
        const { slidable, layout, align, min, max, value, railWidth, railHeight, showHandler = true, handlerSize, handlerStyle, railStyle, trackStyle, startText, endText, handlerText, showTooltip, tooltip, sizeBackground, disableTriggerEvent, inverse } = this.attribute;
        const mainContainer = graphicCreator.group({
            x: 0,
            y: 0
        });
        this._innerView.add(mainContainer);
        const slider = new Slider({
            x: 0,
            y: 0,
            zIndex: 1,
            range: {
                draggableTrack: true
            },
            slidable,
            layout,
            align,
            min,
            max,
            value,
            railWidth,
            railHeight,
            showHandler,
            handlerSize,
            handlerStyle: Object.assign({ symbolType: getSizeHandlerPath(align) }, handlerStyle),
            railStyle,
            trackStyle,
            startText,
            endText,
            handlerText,
            showTooltip,
            tooltip,
            disableTriggerEvent,
            inverse
        });
        mainContainer.add(slider);
        let start = 0;
        let path;
        const backgroundHeight = 12;
        if (layout === 'horizontal') {
            if (align === 'top') {
                path = `M0,0L${railWidth},0L${inverse ? 0 : railWidth},${backgroundHeight}Z`;
                start = railHeight;
            }
            else {
                path = `M0,${backgroundHeight}L${railWidth},${backgroundHeight}L${inverse ? 0 : railWidth},0Z`;
                slider.setAttribute('y', backgroundHeight);
            }
        }
        else {
            if (align === 'left') {
                path = `M${railWidth},0L${railWidth + backgroundHeight},${inverse ? 0 : railHeight}L${railWidth},${railHeight}Z`;
            }
            else {
                path = `M0,${inverse ? 0 : railHeight}L${backgroundHeight},${railHeight}L${backgroundHeight},0Z`;
                slider.setAttribute('x', backgroundHeight);
            }
        }
        const background = graphicCreator.path(Object.assign(Object.assign({ x: 0, y: start, path }, sizeBackground), { zIndex: 0 }));
        mainContainer.add(background);
        const titleSpace = this._title
            ? this._title.AABBBounds.height() + get(this.attribute, 'title.space', DEFAULT_TITLE_SPACE)
            : 0;
        mainContainer.translate(0 - mainContainer.AABBBounds.x1, titleSpace - mainContainer.AABBBounds.y1);
        this._slider = slider;
    }
    _bindEvents() {
        if (this.attribute.disableTriggerEvent) {
            return;
        }
        if (this._slider) {
            this._slider.addEventListener('change', this._onSliderChange);
            this._slider.addEventListener('sliderTooltip', this._onSliderToolipChange);
        }
    }
}
SizeContinuousLegend.defaultAttributes = {
    layout: 'horizontal',
    title: {
        align: 'start',
        space: DEFAULT_TITLE_SPACE,
        textStyle: {
            fontSize: 12,
            fontWeight: 'bold',
            fill: 'rgba(46, 47, 50, 1)'
        }
    },
    handlerSize: 10,
    handlerStyle: {
        lineWidth: 1,
        stroke: '#ccc',
        fill: '#fff'
    },
    sizeBackground: {
        fill: 'rgba(20,20,20,0.1)'
    }
};

function loadTitleComponent() {
    registerGroup();
    registerText();
    registerRichtext();
}

loadTitleComponent();
class Title extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, Title.defaultAttributes, attributes));
        this.name = 'title';
    }
    render() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
        const { textType, text, subtextType, textStyle = {}, subtext, subtextStyle = {}, width, height, minWidth, maxWidth, minHeight, maxHeight, align, verticalAlign, padding = 0 } = this.attribute;
        const parsedPadding = normalizePadding(padding);
        const group = this.createOrUpdateChild('title-container', { x: parsedPadding[3], y: parsedPadding[0], zIndex: 1 }, 'group');
        const fixedMainTitleHeight = (_a = textStyle.height) !== null && _a !== void 0 ? _a : height;
        if (this.attribute.visible !== false && textStyle.visible !== false) {
            const { width: mainTitleWidth, maxHeight: mainTitleMaxHeight, maxWidth: mainTitleMaxWidth, x = 0, y = 0, ellipsis = true, wordBreak = 'break-word', maxWidth, lineClamp } = textStyle;
            if (textType === 'rich' || isValid(textStyle.character)) {
                const attr = Object.assign({ x,
                    y, width: (_b = mainTitleWidth !== null && mainTitleWidth !== void 0 ? mainTitleWidth : width) !== null && _b !== void 0 ? _b : 0, height: fixedMainTitleHeight !== null && fixedMainTitleHeight !== void 0 ? fixedMainTitleHeight : 0, ellipsis: ellipsis !== null && ellipsis !== void 0 ? ellipsis : true, wordBreak: wordBreak !== null && wordBreak !== void 0 ? wordBreak : 'break-word', maxHeight: mainTitleMaxHeight !== null && mainTitleMaxHeight !== void 0 ? mainTitleMaxHeight : maxHeight, maxWidth: mainTitleMaxWidth !== null && mainTitleMaxWidth !== void 0 ? mainTitleMaxWidth : maxWidth, textConfig: (_c = textStyle.character) !== null && _c !== void 0 ? _c : text }, textStyle);
                this._mainTitle = group.createOrUpdateChild('mainTitle', attr, 'richtext');
            }
            else if (textType === 'html') {
                const attr = Object.assign({ html: Object.assign(Object.assign({ dom: text }, DEFAULT_HTML_TEXT_SPEC), textStyle), x,
                    y, width: (_d = mainTitleWidth !== null && mainTitleWidth !== void 0 ? mainTitleWidth : width) !== null && _d !== void 0 ? _d : 0, height: fixedMainTitleHeight !== null && fixedMainTitleHeight !== void 0 ? fixedMainTitleHeight : 0, ellipsis,
                    wordBreak, maxHeight: mainTitleMaxHeight !== null && mainTitleMaxHeight !== void 0 ? mainTitleMaxHeight : maxHeight, maxWidth: mainTitleMaxWidth !== null && mainTitleMaxWidth !== void 0 ? mainTitleMaxWidth : maxWidth, textConfig: [] }, textStyle);
                this._mainTitle = group.createOrUpdateChild('mainTitle', attr, 'richtext');
            }
            else if (isValid(text)) {
                this._mainTitle = group.createOrUpdateChild('mainTitle', Object.assign(Object.assign({ text: isArray(text) ? text : [text], whiteSpace: 'normal' }, textStyle), { maxLineWidth: (_f = (_e = textStyle.maxLineWidth) !== null && _e !== void 0 ? _e : mainTitleWidth) !== null && _f !== void 0 ? _f : width, heightLimit: (_g = textStyle.height) !== null && _g !== void 0 ? _g : maxHeight, lineClamp,
                    ellipsis,
                    x,
                    y }), 'text');
            }
        }
        const mainTextBoundsHeight = this._mainTitle ? this._mainTitle.AABBBounds.height() : 0;
        const mainTextBoundsWidth = this._mainTitle ? this._mainTitle.AABBBounds.width() : 0;
        if (this.attribute.visible !== false && subtextStyle.visible !== false) {
            const { width: subTitleWidth, height: subTitleHeight, maxWidth: subTitleMaxWidth, maxHeight: subTitleMaxHeight, x = 0, y = 0, ellipsis = true, wordBreak = 'break-word', lineClamp } = subtextStyle;
            const maxSubTextHeight = Math.max(Number.MIN_VALUE, maxHeight - mainTextBoundsHeight);
            if (subtextType === 'rich' || isValid(subtextStyle.character)) {
                const attr = Object.assign({ x,
                    y, width: (_h = subTitleWidth !== null && subTitleWidth !== void 0 ? subTitleWidth : width) !== null && _h !== void 0 ? _h : 0, height: (_j = subTitleHeight !== null && subTitleHeight !== void 0 ? subTitleHeight : height) !== null && _j !== void 0 ? _j : 0, ellipsis,
                    wordBreak, maxHeight: subTitleMaxHeight !== null && subTitleMaxHeight !== void 0 ? subTitleMaxHeight : maxSubTextHeight, maxWidth: subTitleMaxWidth !== null && subTitleMaxWidth !== void 0 ? subTitleMaxWidth : maxWidth, textConfig: (_k = subtextStyle.character) !== null && _k !== void 0 ? _k : subtext }, subtextStyle);
                this._subTitle = group.createOrUpdateChild('subTitle', attr, 'richtext');
            }
            else if (subtextType === 'html') {
                const attr = Object.assign({ html: Object.assign(Object.assign({ dom: subtext }, DEFAULT_HTML_TEXT_SPEC), subtextStyle), x,
                    y, width: (_l = subTitleWidth !== null && subTitleWidth !== void 0 ? subTitleWidth : width) !== null && _l !== void 0 ? _l : 0, height: (_m = subTitleHeight !== null && subTitleHeight !== void 0 ? subTitleHeight : height) !== null && _m !== void 0 ? _m : 0, ellipsis,
                    wordBreak, maxHeight: subTitleMaxHeight !== null && subTitleMaxHeight !== void 0 ? subTitleMaxHeight : maxSubTextHeight, maxWidth: subTitleMaxWidth !== null && subTitleMaxWidth !== void 0 ? subTitleMaxWidth : maxWidth, textConfig: [] }, subtextStyle);
                this._subTitle = group.createOrUpdateChild('subTitle', attr, 'richtext');
            }
            else if (isValid(subtext)) {
                this._subTitle = group.createOrUpdateChild('subTitle', Object.assign(Object.assign({ text: isArray(subtext) ? subtext : [subtext], whiteSpace: 'normal' }, subtextStyle), { maxLineWidth: (_o = subtextStyle.maxLineWidth) !== null && _o !== void 0 ? _o : width, heightLimit: (_p = subtextStyle.heightLimit) !== null && _p !== void 0 ? _p : maxSubTextHeight, lineClamp,
                    ellipsis, x: 0, y: mainTextBoundsHeight }), 'text');
            }
        }
        const subTextBoundsHeight = this._subTitle ? this._subTitle.AABBBounds.height() : 0;
        const subTextBoundsWidth = this._subTitle ? this._subTitle.AABBBounds.width() : 0;
        let totalWidth = Math.max(mainTextBoundsWidth, subTextBoundsWidth);
        let totalHeight = mainTextBoundsHeight + ((_q = subtextStyle.height) !== null && _q !== void 0 ? _q : subTextBoundsHeight);
        if (isValid(width)) {
            totalWidth = width;
        }
        if (isValid(height)) {
            totalHeight = height;
        }
        if (isValid(minWidth) && totalWidth < minWidth) {
            totalWidth = minWidth;
        }
        if (isValid(maxWidth)) {
            if (totalWidth > maxWidth) {
                totalWidth = maxWidth;
            }
        }
        if (isValid(minHeight) && totalHeight < minHeight) {
            totalHeight = minHeight;
        }
        if (isValid(maxHeight)) {
            if (totalHeight > maxHeight) {
                totalHeight = maxHeight;
            }
        }
        group.attribute.width = totalWidth;
        group.attribute.height = totalHeight;
        group.attribute.boundsPadding = parsedPadding;
        if (this._mainTitle) {
            if (isValid(align) || isValid(textStyle.align)) {
                const mainTitleAlign = textStyle.align ? textStyle.align : align;
                const mainTitleWidth = (_r = textStyle.width) !== null && _r !== void 0 ? _r : totalWidth;
                if (mainTitleAlign === 'center') {
                    this._mainTitle.setAttribute('x', mainTitleWidth / 2);
                    this._mainTitle.setAttribute('textAlign', 'center');
                }
                else if (mainTitleAlign === 'right') {
                    this._mainTitle.setAttribute('x', mainTitleWidth);
                    this._mainTitle.setAttribute('textAlign', 'right');
                }
                else {
                    this._mainTitle.setAttribute('x', 0);
                    this._mainTitle.setAttribute('textAlign', 'left');
                }
            }
            const mainTitleVerticalAlign = textStyle.verticalAlign ? textStyle.verticalAlign : verticalAlign;
            const mainTitleHeight = fixedMainTitleHeight !== null && fixedMainTitleHeight !== void 0 ? fixedMainTitleHeight : (this._mainTitle.AABBBounds.empty() ? 0 : this._mainTitle.AABBBounds.height());
            if (mainTitleVerticalAlign === 'middle') {
                this._mainTitle.setAttribute('y', mainTitleHeight / 2);
                this._mainTitle.setAttribute('textBaseline', 'middle');
            }
            else if (mainTitleVerticalAlign === 'bottom') {
                this._mainTitle.setAttribute('y', mainTitleHeight);
                this._mainTitle.setAttribute('textBaseline', 'bottom');
            }
            else {
                this._mainTitle.setAttribute('y', 0);
                this._mainTitle.setAttribute('textBaseline', 'top');
            }
        }
        if (this._subTitle) {
            if (isValid(align) || isValid(subtextStyle.align)) {
                const subTitleAlign = subtextStyle.align ? subtextStyle.align : align;
                const subTitleWidth = (_t = (_s = subtextStyle.width) !== null && _s !== void 0 ? _s : textStyle.width) !== null && _t !== void 0 ? _t : totalWidth;
                if (subTitleAlign === 'center') {
                    this._subTitle.setAttribute('x', subTitleWidth / 2);
                    this._subTitle.setAttribute('textAlign', 'center');
                }
                else if (subTitleAlign === 'right') {
                    this._subTitle.setAttribute('x', subTitleWidth);
                    this._subTitle.setAttribute('textAlign', 'right');
                }
                else {
                    this._subTitle.setAttribute('x', 0);
                    this._subTitle.setAttribute('textAlign', 'left');
                }
            }
            const subTitleVerticalAlign = subtextStyle.verticalAlign ? subtextStyle.verticalAlign : verticalAlign;
            const subTitleYStart = this._mainTitle
                ? isValid(fixedMainTitleHeight)
                    ?
                        this._mainTitle.AABBBounds.y1 +
                            Math.max(this._mainTitle.AABBBounds.empty() ? 0 : this._mainTitle.AABBBounds.height(), fixedMainTitleHeight)
                    : this._mainTitle.AABBBounds.y2
                : 0;
            const subTitleHeight = (_v = (_u = subtextStyle.height) !== null && _u !== void 0 ? _u : height) !== null && _v !== void 0 ? _v : (this._subTitle.AABBBounds.empty() ? 0 : this._subTitle.AABBBounds.height());
            if (subTitleVerticalAlign === 'middle') {
                this._subTitle.setAttribute('y', subTitleYStart + subTitleHeight / 2);
                this._subTitle.setAttribute('textBaseline', 'middle');
            }
            else if (subTitleVerticalAlign === 'bottom') {
                this._subTitle.setAttribute('y', subTitleYStart + subTitleHeight);
                this._subTitle.setAttribute('textBaseline', 'bottom');
            }
            else {
                this._subTitle.setAttribute('y', subTitleYStart);
                this._subTitle.setAttribute('textBaseline', 'top');
            }
        }
    }
}
Title.defaultAttributes = {
    textStyle: {
        ellipsis: '...',
        fill: '#333',
        fontSize: 20,
        fontWeight: 'bold',
        textAlign: 'left',
        textBaseline: 'top'
    },
    subtextStyle: {
        ellipsis: '...',
        fill: '#6F6F6F',
        fontSize: 16,
        fontWeight: 'normal',
        textAlign: 'left',
        textBaseline: 'top'
    }
};

const DEFAULT_INDICATOR_THEME = {
    title: {
        style: {
            text: '',
            fontSize: 20,
            fill: 'black',
            fontWeight: 'normal',
            fillOpacity: 1,
            textBaseline: 'top',
            textAlign: 'center'
        }
    },
    content: {
        style: {
            text: '',
            fontSize: 16,
            fill: 'black',
            fontWeight: 'normal',
            fillOpacity: 1,
            textBaseline: 'top',
            textAlign: 'center'
        }
    }
};

function loadIndicatorComponent() {
    registerGroup();
    registerText();
    registerRichtext();
}

loadIndicatorComponent();
class Indicator extends AbstractComponent {
    constructor() {
        super(...arguments);
        this.name = 'indicator';
    }
    _renderText(group, title, limit, limitRatio, themePath, graphicName) {
        if (title.visible !== false) {
            const titleStyle = merge({}, get(DEFAULT_INDICATOR_THEME, themePath), title.style, {
                visible: title.visible
            });
            titleStyle.lineHeight = isValid(titleStyle.lineHeight) ? titleStyle.lineHeight : titleStyle.fontSize;
            if (title.formatMethod) {
                titleStyle._originText = titleStyle.text;
                titleStyle.text = title.formatMethod(titleStyle.text, titleStyle);
            }
            const textGraphic = createTextGraphicByType(titleStyle);
            textGraphic.name = graphicName;
            group.appendChild(textGraphic);
            if (title.autoFit && isValidNumber(limit)) {
                this._setLocalAutoFit(limit, textGraphic, title);
            }
            if (title.autoLimit && isValidNumber(limitRatio)) {
                textGraphic.setAttribute('maxLineWidth', limit);
            }
            return textGraphic;
        }
        return undefined;
    }
    render() {
        var _a, _b;
        this.removeAllChild(true);
        if (this.attribute.visible !== true) {
            return;
        }
        const { title = {}, content, size, limitRatio = Infinity } = this.attribute;
        const limit = Math.min(size.width, size.height) * limitRatio;
        const group = this.createOrUpdateChild('indicator-container', { x: 0, y: 0, zIndex: 1, pickable: (_a = this.attribute.pickable) !== null && _a !== void 0 ? _a : true }, 'group');
        if (isValid(title)) {
            this._title = this._renderText(group, title, limit, limitRatio, 'title.style', 'indicator-title');
        }
        if (isValid(content)) {
            const contents = array(content);
            const contentComponents = [];
            contents.forEach((contentItem, i) => {
                if (contentItem.visible !== false) {
                    contentComponents.push(this._renderText(group, contentItem, limit, limitRatio, 'content.style', 'indicator-content-' + i));
                }
            });
            this._content = contentComponents;
        }
        this._setGlobalAutoFit(limit);
        this._setYPosition();
        const totalHeight = (_b = group === null || group === void 0 ? void 0 : group.AABBBounds.height()) !== null && _b !== void 0 ? _b : 0;
        group.setAttribute('y', size.height / 2 - totalHeight / 2);
        group.setAttribute('x', size.width / 2);
    }
    _setLocalAutoFit(limit, indicatorItem, indicatorItemSpec) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (((_a = indicatorItemSpec.fitStrategy) !== null && _a !== void 0 ? _a : 'default') !== 'default') {
            return;
        }
        const originWidth = measureTextSize(((_c = (_b = indicatorItemSpec.style) === null || _b === void 0 ? void 0 : _b.text) !== null && _c !== void 0 ? _c : ''), ((_d = indicatorItemSpec.style) !== null && _d !== void 0 ? _d : {}), (_f = (_e = this.stage) === null || _e === void 0 ? void 0 : _e.getTheme()) === null || _f === void 0 ? void 0 : _f.text).width;
        if (originWidth > 0) {
            const ratio = (limit * ((_g = indicatorItemSpec.fitPercent) !== null && _g !== void 0 ? _g : 0.5)) / originWidth;
            const fontSize = Math.floor(((_j = (_h = indicatorItemSpec.style) === null || _h === void 0 ? void 0 : _h.fontSize) !== null && _j !== void 0 ? _j : 20) * ratio);
            indicatorItem.setAttribute('fontSize', fontSize);
            indicatorItem.setAttribute('lineHeight', isValid(indicatorItemSpec.style.lineHeight) ? indicatorItemSpec.style.lineHeight : fontSize);
        }
    }
    _setGlobalAutoFit(limit) {
        var _a, _b, _c, _d, _e, _f, _g;
        const r = limit / 2;
        const singleHeight = 12;
        const autoFitTexts = [];
        let otherHeight = 0;
        const titleSpec = (_a = this.attribute.title) !== null && _a !== void 0 ? _a : {};
        if (titleSpec.autoFit && titleSpec.fitStrategy === 'inscribed') {
            this._title.setAttribute('fontSize', singleHeight);
            autoFitTexts.push({ text: this._title, spec: (_b = this.attribute.title) !== null && _b !== void 0 ? _b : {} });
        }
        else {
            otherHeight += (_f = (_e = (_d = (_c = this._title) === null || _c === void 0 ? void 0 : _c.AABBBounds) === null || _d === void 0 ? void 0 : _d.height) === null || _e === void 0 ? void 0 : _e.call(_d)) !== null && _f !== void 0 ? _f : 0;
        }
        const titleSpace = (_g = titleSpec.space) !== null && _g !== void 0 ? _g : 0;
        otherHeight += titleSpace;
        array(this.attribute.content)
            .filter(contentSpec => contentSpec.visible !== false)
            .forEach((contentSpec, index) => {
            var _a, _b, _c, _d;
            const contentText = this._content[index];
            if (contentSpec.autoFit && contentSpec.fitStrategy === 'inscribed') {
                contentText.setAttribute('fontSize', singleHeight);
                autoFitTexts.push({ text: contentText, spec: contentSpec });
            }
            else {
                otherHeight += (_c = (_b = (_a = contentText === null || contentText === void 0 ? void 0 : contentText.AABBBounds) === null || _a === void 0 ? void 0 : _a.height) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : 0;
            }
            const contentSpace = (_d = contentSpec.space) !== null && _d !== void 0 ? _d : 0;
            otherHeight += contentSpace;
        });
        if (autoFitTexts.length <= 0) {
            return;
        }
        const maxWidth = autoFitTexts.reduce((width, textItem) => {
            return Math.max(width, textItem.text.AABBBounds.width());
        }, 0);
        const ra = (singleHeight / maxWidth) * autoFitTexts.length;
        const h = otherHeight / 2;
        const a = ra ** 2 + 1;
        const b = 2 * h * ra;
        const c = h ** 2 - r ** 2;
        const hx = (-b + Math.sqrt(b ** 2 - 4 * a * c)) / (2 * a);
        const hy = ra * hx + h;
        const y = 2 * hy;
        const lineHeight = (y - otherHeight) / autoFitTexts.length;
        if (isValidNumber(y)) {
            autoFitTexts.forEach(textItem => {
                var _a;
                const specLineHeight = (_a = textItem.spec.style) === null || _a === void 0 ? void 0 : _a.lineHeight;
                textItem.text.setAttribute('fontSize', lineHeight);
                textItem.text.setAttribute('lineHeight', isValid(specLineHeight) ? specLineHeight : lineHeight);
            });
        }
    }
    _setYPosition() {
        var _a, _b, _c, _d, _e, _f;
        let lastContentHeight = 0;
        const titleHeight = (_d = (_c = (_b = (_a = this._title) === null || _a === void 0 ? void 0 : _a.AABBBounds) === null || _b === void 0 ? void 0 : _b.height) === null || _c === void 0 ? void 0 : _c.call(_b)) !== null && _d !== void 0 ? _d : 0;
        const titleSpace = (_f = (_e = this.attribute.title) === null || _e === void 0 ? void 0 : _e.space) !== null && _f !== void 0 ? _f : 0;
        array(this.attribute.content)
            .filter(contentSpec => contentSpec.visible !== false)
            .forEach((contentSpec, index) => {
            var _a;
            const contentText = this._content[index];
            contentText.setAttribute('y', titleHeight + titleSpace + lastContentHeight);
            const contentSpace = (_a = contentSpec.space) !== null && _a !== void 0 ? _a : 0;
            lastContentHeight += contentText.AABBBounds.height() + contentSpace;
        });
    }
}

function loadLinkPathComponent() {
    registerGroup();
    registerPath();
}

const getHorizontalPath = (options, ratio) => {
    let x0 = options.x0;
    let x1 = options.x1;
    const thickness = typeof ratio === 'number' ? options.thickness * ratio : options.thickness;
    let y00 = options.y0 - options.thickness / 2;
    let y10 = options.y1 - options.thickness / 2;
    if (options.align === 'center') {
        y00 = options.y0 - thickness / 2;
        y10 = options.y1 - thickness / 2;
    }
    else if (options.align === 'end') {
        y00 = options.y0 + options.thickness / 2 - thickness;
        y10 = options.y1 + options.thickness / 2 - thickness;
    }
    let midX = (x0 + x1) / 2;
    let y01 = y00 + thickness;
    let y11 = y10 + thickness;
    if (options.round) {
        x0 = Math.round(x0);
        x1 = Math.round(x1);
        y00 = Math.round(y00);
        y10 = Math.round(y10);
        y01 = Math.round(y01);
        y11 = Math.round(y11);
        midX = Math.round(midX);
    }
    const hasLength = Math.abs(x1 - x0) > 1e-6;
    const endArrowPath = options.endArrow && hasLength
        ? `L${x1},${y10 - thickness / 2}L${x1 + thickness},${(y10 + y11) / 2}L${x1},${y11 + thickness / 2}`
        : '';
    const startArrowPath = options.startArrow && hasLength
        ? `L${x0},${y01 + thickness / 2}L${x0 - thickness},${(y00 + y01) / 2}L${x0},${y00 - thickness / 2}`
        : '';
    if (options.isSmooth === false) {
        return `M${x0},${y00}L${x1},${y10}${endArrowPath}L${x1},${y11}L${x0},${y01}${startArrowPath}Z`;
    }
    return `M${x0},${y00}
  C${midX},${y00},${midX},${y10},${x1},${y10}
  ${endArrowPath}
  L${x1},${y11}
  C${midX},${y11},${midX},${y01},${x0},${y01}
  ${startArrowPath}
  Z`;
};
const getVerticalPath = (options, ratio) => {
    let y0 = options.y0;
    let y1 = options.y1;
    let x00 = options.x0 - options.thickness / 2;
    let x10 = options.x1 - options.thickness / 2;
    const thickness = typeof ratio === 'number' ? options.thickness * ratio : options.thickness;
    if (options.align === 'center') {
        x00 = options.x0 - thickness / 2;
        x10 = options.x1 - thickness / 2;
    }
    else if (options.align === 'end') {
        x00 = options.x0 + options.thickness / 2 - thickness;
        x10 = options.x1 + options.thickness / 2 - thickness;
    }
    let midY = (y0 + y1) / 2;
    let x01 = x00 + thickness;
    let x11 = x10 + thickness;
    if (options.round) {
        y0 = Math.round(y0);
        y1 = Math.round(y1);
        x00 = Math.round(x00);
        x10 = Math.round(x10);
        x01 = Math.round(x01);
        x11 = Math.round(x11);
        midY = Math.round(midY);
    }
    const hasLength = Math.abs(y1 - y0) > 1e-6;
    const endArrowPath = options.endArrow && hasLength
        ? `L${x10 - thickness / 2},${y1}L${(x10 + x11) / 2},${y1 + thickness}L${x11 + thickness / 2},${y1}`
        : '';
    const startArrowPath = options.startArrow && hasLength
        ? `L${x01 + thickness / 2},${y0}L${(x01 + x00) / 2},${y0 - thickness}L${x00 - thickness / 2},${y0}`
        : '';
    if (options.isSmooth === false) {
        return `M${x00},${y0}L${x10},${y1}${endArrowPath}L${x11},${y1}L${x01},${y0}${startArrowPath}Z`;
    }
    return `M${x00},${y0}
  C${x00},${midY},${x10},${midY},${x10},${y1}
  ${endArrowPath}
  L${x11},${y1}
  C${x11},${midY},${x01},${midY},${x01},${y0}
  ${startArrowPath}
  Z`;
};
loadLinkPathComponent();
class LinkPath extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, LinkPath.defaultAttributes, attributes));
    }
    render() {
        const { direction = 'horizontal' } = this.attribute;
        const parsePath = direction === 'vertical' ? getVerticalPath : getHorizontalPath;
        const isRatioShow = typeof this.attribute.ratio === 'number' && this.attribute.ratio >= 0 && this.attribute.ratio <= 1;
        const groupAttrKeys = [
            'direction',
            'x0',
            'x1',
            'y0',
            'y1',
            'thickness',
            'round',
            'ratio',
            'align',
            'isSmooth',
            'backgroudStyle'
        ];
        const commonStyle = {};
        Object.keys(this.attribute).forEach(key => {
            if (!groupAttrKeys.includes(key)) {
                commonStyle[key] = this.attribute[key];
            }
        });
        if (isRatioShow) {
            const background = this.createOrUpdateChild('sankey-link-background', Object.assign({}, commonStyle, this.attribute.backgroudStyle, {
                path: parsePath(this.attribute, 1),
                visible: true,
                pickable: false,
                zIndex: -1
            }), 'path');
            this._backPath = background;
        }
        else if (this._backPath) {
            this._backPath.setAttribute('visible', false);
        }
        const front = this.createOrUpdateChild('sankey-link-front', Object.assign({}, commonStyle, {
            path: parsePath(this.attribute, isRatioShow ? this.attribute.ratio : 1),
            pickable: false
        }), 'path');
        this._frontPath = front;
    }
}
LinkPath.defaultAttributes = {
    direction: 'horizontal',
    align: 'start'
};

const iconPlay = `M 414.5 0.0238 c 228.9128 0 414.4762 185.5634 414.4762 414.4762 s -185.5634 414.4762 -414.4762 414.4762 S 0.0238 643.4128 0.0238 414.5 S 185.5872 0.0238 414.5 0.0238 z m 0 73.1429 C 225.9865 73.1667 73.1667 225.9865 73.1667 414.5 s 152.8198 341.3333 341.3333 341.3333 s 341.3333 -152.8198 341.3333 -341.3333 S 603.0135 73.1667 414.5 73.1667 z m -73.1429 161.4994 a 48.7619 48.7619 0 0 1 25.9901 7.5093 l 201.7524 127.1223 a 48.7619 48.7619 0 0 1 0.3657 82.2613 l -201.7524 129.6335 A 48.7619 48.7619 0 0 1 292.5952 540.1838 v -256.7314 a 48.7619 48.7619 0 0 1 48.7619 -48.7619 z m 24.381 92.9402 v 167.9116 l 131.9497 -84.7726 L 365.7381 327.6063 z`;
const iconPause = `M 414.5 0.0238 c 228.9128 0 414.4762 185.5634 414.4762 414.4762 s -185.5634 414.4762 -414.4762 414.4762 S 0.0238 643.4128 0.0238 414.5 S 185.5872 0.0238 414.5 0.0238 z m 0 73.1429 C 225.9865 73.1667 73.1667 225.9865 73.1667 414.5 s 152.8198 341.3333 341.3333 341.3333 s 341.3333 -152.8198 341.3333 -341.3333 S 603.0135 73.1667 414.5 73.1667 z m -48.7619 195.0476 v 316.9524 h -73.1429 V 268.2143 h 73.1429 z m 158.4762 0 v 316.9524 h -73.1429 V 268.2143 h 73.1429 z`;
const iconLeft = `M 521.29 734.276 L 230.929 448.019 L 521.29 161.762 c 37.685 -37.153 38.003 -97.625 0.707 -134.384 c -37.297 -36.758 -98.646 -36.435 -136.331 0.718 l -357.43 352.378 c -0.155 0.153 -0.297 0.314 -0.451 0.468 c -0.084 0.082 -0.172 0.157 -0.256 0.239 c -18.357 18.092 -27.581 41.929 -27.743 65.902 c -0.004 0.311 -0.017 0.623 -0.018 0.934 c 0.001 0.316 0.014 0.632 0.018 0.948 c 0.165 23.97 9.389 47.803 27.743 65.892 c 0.083 0.082 0.171 0.157 0.255 0.239 c 0.154 0.154 0.296 0.315 0.452 0.468 l 357.43 352.378 c 37.685 37.153 99.034 37.476 136.331 0.718 c 37.297 -36.758 36.979 -97.231 -0.707 -134.384 z`;
const iconDown = `M 734.276 28.71 L 448.019 319.071 L 161.762 28.71 c -37.153 -37.685 -97.625 -38.003 -134.384 -0.707 c -36.758 37.297 -36.435 98.646 0.718 136.331 l 352.378 357.43 c 0.153 0.155 0.314 0.297 0.468 0.451 c 0.082 0.084 0.157 0.172 0.239 0.256 c 18.092 18.357 41.929 27.581 65.902 27.743 c 0.311 0.004 0.623 0.017 0.934 0.018 c 0.316 -0.001 0.632 -0.014 0.948 -0.018 c 23.97 -0.165 47.803 -9.389 65.892 -27.743 c 0.082 -0.083 0.157 -0.171 0.239 -0.255 c 0.154 -0.154 0.315 -0.296 0.468 -0.452 l 352.378 -357.43 c 37.153 -37.685 37.476 -99.034 0.718 -136.331 c -36.758 -37.297 -97.231 -36.979 -134.384 0.707 z`;
const iconUp = `m 161.724 521.29 l 286.257 -290.361 l 286.257 290.361 c 37.153 37.685 97.625 38.003 134.384 0.707 c 36.758 -37.297 36.435 -98.646 -0.718 -136.331 l -352.378 -357.43 c -0.153 -0.155 -0.314 -0.297 -0.468 -0.451 c -0.082 -0.084 -0.157 -0.172 -0.239 -0.256 c -18.092 -18.357 -41.929 -27.581 -65.902 -27.743 c -0.311 -0.004 -0.623 -0.017 -0.934 -0.018 c -0.316 0.001 -0.632 0.014 -0.948 0.018 c -23.97 0.165 -47.803 9.389 -65.892 27.743 c -0.082 0.083 -0.157 0.171 -0.239 0.255 c -0.154 0.154 -0.315 0.296 -0.468 0.452 l -352.378 357.43 c -37.153 37.685 -37.476 99.034 -0.718 136.331 c 36.758 37.297 97.231 36.979 134.384 -0.707 z`;
const iconRight = `M 30 163 L 320.361 449.257 L 30 735.514 c -37.685 37.153 -38.003 97.625 -0.707 134.384 c 37.297 36.758 98.646 36.435 136.331 -0.718 l 357.43 -352.378 c 0.155 -0.153 0.297 -0.314 0.451 -0.468 c 0.084 -0.082 0.172 -0.157 0.256 -0.239 c 18.357 -18.092 27.581 -41.929 27.743 -65.902 c 0.004 -0.311 0.017 -0.623 0.018 -0.934 c -0.001 -0.316 -0.014 -0.632 -0.018 -0.948 c -0.165 -23.97 -9.389 -47.803 -27.743 -65.892 c -0.083 -0.082 -0.171 -0.157 -0.255 -0.239 c -0.154 -0.154 -0.296 -0.315 -0.452 -0.468 l -357.43 -352.378 c -37.685 -37.153 -99.034 -37.476 -136.331 -0.718 c -37.297 36.758 -36.979 97.231 0.707 134.384 z`;

class PlayerIcon extends Symbol$1 {
    constructor(params) {
        super(params);
    }
}

var ControllerEventEnum;
(function (ControllerEventEnum) {
    ControllerEventEnum["OnPlay"] = "onPlay";
    ControllerEventEnum["OnPause"] = "onPause";
    ControllerEventEnum["OnForward"] = "onForward";
    ControllerEventEnum["OnBackward"] = "onBackward";
})(ControllerEventEnum || (ControllerEventEnum = {}));
var ControllerTypeEnum;
(function (ControllerTypeEnum) {
    ControllerTypeEnum["Start"] = "start";
    ControllerTypeEnum["Pause"] = "pause";
    ControllerTypeEnum["Forward"] = "forward";
    ControllerTypeEnum["Backward"] = "backward";
})(ControllerTypeEnum || (ControllerTypeEnum = {}));

class Controller extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, Controller.defaultAttributes, attributes));
        this._isPaused = true;
        this.updateAttributes = () => {
            this._startAttr = {
                style: Object.assign(Object.assign(Object.assign({ symbolType: iconPlay }, Controller.defaultControllerAttr), { visible: this.attribute.start.visible }), this.attribute.start.style)
            };
            this._pauseAttr = {
                style: Object.assign(Object.assign(Object.assign({ symbolType: iconPause }, Controller.defaultControllerAttr), { visible: this.attribute.pause.visible }), this.attribute.pause.style)
            };
            this._forwardAttr = {
                style: Object.assign(Object.assign(Object.assign({}, Controller.defaultControllerAttr), { visible: this.attribute.forward.visible }), this.attribute.forward.style)
            };
            this._backwardAttr = {
                style: Object.assign(Object.assign(Object.assign({}, Controller.defaultControllerAttr), { visible: this.attribute.backward.visible }), this.attribute.backward.style)
            };
            this.updateLayout();
        };
        this.updateLayout = () => {
            var _a, _b, _c, _d;
            this._layout = this.attribute.layout;
            if (this._layout === 'horizontal') {
                this._backwardAttr.style.symbolType = (_a = this._backwardAttr.style.symbolType) !== null && _a !== void 0 ? _a : iconLeft;
                this._forwardAttr.style.symbolType = (_b = this._forwardAttr.style.symbolType) !== null && _b !== void 0 ? _b : iconRight;
            }
            else if (this._layout === 'vertical') {
                this._backwardAttr.style.symbolType = (_c = this._backwardAttr.style.symbolType) !== null && _c !== void 0 ? _c : iconUp;
                this._forwardAttr.style.symbolType = (_d = this._forwardAttr.style.symbolType) !== null && _d !== void 0 ? _d : iconDown;
            }
        };
        this._initPlay = () => {
            if (isNil(this._playController)) {
                this._playController = new PlayerIcon(Object.assign({}, this._startAttr.style));
                this.add(this._playController);
            }
        };
        this._initBackward = () => {
            if (isNil(this._backwardController)) {
                this._backwardController = new PlayerIcon(Object.assign({}, this._backwardAttr.style));
                this.add(this._backwardController);
            }
        };
        this._initForward = () => {
            if (isNil(this._forwardController)) {
                this._forwardController = new PlayerIcon(Object.assign({}, this._forwardAttr.style));
                this.add(this._forwardController);
            }
        };
        this._initEvents = () => {
            if (this.attribute.disableTriggerEvent) {
                return;
            }
            this._playController.addEventListener('pointerdown', (e) => {
                e.stopPropagation();
                if (this._isPaused === true) {
                    this.play();
                }
                else {
                    this.pause();
                }
            });
            this._backwardController.addEventListener('pointerdown', (e) => {
                e.stopPropagation();
                this.backward();
            });
            this._forwardController.addEventListener('pointerdown', (e) => {
                e.stopPropagation();
                this.forward();
            });
        };
        this.renderPlay = () => {
            if (this._isPaused) {
                this._playController.setAttributes(Object.assign({ symbolType: this._playController.getComputedAttribute('symbolType') }, this._startAttr.style));
            }
            else {
                this._playController.setAttributes(Object.assign({ symbolType: this._playController.getComputedAttribute('symbolType') }, this._pauseAttr.style));
            }
        };
        this.renderBackward = () => {
            this._backwardController.setAttributes(this._backwardAttr.style);
        };
        this.renderForward = () => {
            this._forwardController.setAttributes(this._forwardAttr.style);
        };
        this.play = () => {
            this._dispatchEvent(ControllerEventEnum.OnPlay);
        };
        this.pause = () => {
            this._dispatchEvent(ControllerEventEnum.OnPause);
        };
        this.forward = () => {
            this._dispatchEvent(ControllerEventEnum.OnForward);
        };
        this.backward = () => {
            this._dispatchEvent(ControllerEventEnum.OnBackward);
        };
        this.togglePlay = () => {
            this._playController.setAttributes(this._startAttr.style);
            this._isPaused = true;
        };
        this.togglePause = () => {
            this._playController.setAttributes(this._pauseAttr.style);
            this._isPaused = false;
        };
        this.updateAttributes();
        this._initPlay();
        this._initBackward();
        this._initForward();
        this._initEvents();
    }
    render() {
        this.updateAttributes();
        this.renderPlay();
        this.renderBackward();
        this.renderForward();
    }
}
Controller.defaultControllerAttr = {
    visible: true,
    x: 0,
    y: 0,
    size: 20,
    fill: '#91caff',
    pickMode: 'imprecise',
    cursor: 'pointer'
};
Controller.defaultAttributes = {
    [ControllerTypeEnum.Start]: {},
    [ControllerTypeEnum.Pause]: {},
    [ControllerTypeEnum.Backward]: {},
    [ControllerTypeEnum.Forward]: {}
};

const defaultControllerAttributes = {
    visible: true,
    style: {
        x: 0,
        y: 0,
        dx: 0,
        dy: 0,
        size: 20
    },
    order: 0,
    space: 10
};
const RailDefaultSize = [200, 10];

var DirectionEnum;
(function (DirectionEnum) {
    DirectionEnum["Default"] = "default";
    DirectionEnum["Reverse"] = "reverse";
})(DirectionEnum || (DirectionEnum = {}));

var PlayerEventEnum;
(function (PlayerEventEnum) {
    PlayerEventEnum["change"] = "change";
    PlayerEventEnum["play"] = "play";
    PlayerEventEnum["pause"] = "pause";
    PlayerEventEnum["backward"] = "backward";
    PlayerEventEnum["forward"] = "forward";
    PlayerEventEnum["end"] = "end";
    PlayerEventEnum["OnChange"] = "change";
    PlayerEventEnum["OnPlay"] = "play";
    PlayerEventEnum["OnPause"] = "pause";
    PlayerEventEnum["OnBackward"] = "backward";
    PlayerEventEnum["OnForward"] = "forward";
    PlayerEventEnum["OnEnd"] = "end";
})(PlayerEventEnum || (PlayerEventEnum = {}));

const isReachEndByDefault = ({ direction, maxIndex, dataIndex }) => {
    if (direction === DirectionEnum.Default) {
        return dataIndex === maxIndex;
    }
    return false;
};
const isReachEndByReverse = ({ direction, minIndex, dataIndex }) => {
    if (direction === DirectionEnum.Reverse) {
        return dataIndex === minIndex;
    }
    return false;
};
const isReachEnd = ({ direction, maxIndex, minIndex, dataIndex }) => {
    return (isReachEndByDefault({ direction, maxIndex, dataIndex }) || isReachEndByReverse({ direction, minIndex, dataIndex }));
};
const isReachStartByDefault = ({ direction, minIndex, dataIndex }) => {
    if (direction === DirectionEnum.Default) {
        return dataIndex === minIndex;
    }
    return false;
};
const isReachStartByReverse = ({ direction, maxIndex, dataIndex }) => {
    if (direction === DirectionEnum.Reverse) {
        return dataIndex === maxIndex;
    }
    return false;
};
const isReachStart = ({ direction, maxIndex, minIndex, dataIndex }) => {
    return (isReachStartByDefault({ direction, minIndex, dataIndex }) ||
        isReachStartByReverse({ direction, maxIndex, dataIndex }));
};
const isHorizontal = (orient) => orient === 'top' || orient === 'bottom';
const forwardStep = (direction, currentIndex, min, max) => {
    if (direction === 'default') {
        return Math.min(currentIndex + 1, max);
    }
    return Math.max(currentIndex - 1, min);
};

class BasePlayer extends AbstractComponent {
    getMinIndex() {
        return this._minIndex;
    }
    getMaxIndex() {
        return this._maxIndex;
    }
    getDataIndex() {
        return this._dataIndex;
    }
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, BasePlayer.defaultAttributes, attributes));
        this._data = [];
        this._dataIndex = 0;
        this._layoutInfo = {};
        this._updateSliderAttrs = () => {
            var _a, _b;
            let handlerSize;
            if (isValidNumber(this._handlerStyle.size)) {
                handlerSize = this._handlerStyle.size;
            }
            else if (this._handlerStyle.size && this._handlerStyle.size.length) {
                handlerSize = max(this._handlerStyle.size[0], this._handlerStyle.size[1]);
            }
            const attrs = {
                visible: this._sliderVisible,
                min: this._minIndex,
                max: this._maxIndex,
                value: this._dataIndex,
                railWidth: this._railStyle.width,
                railHeight: this._railStyle.height,
                railStyle: this._railStyle,
                trackStyle: this._trackStyle,
                handlerSize: isValidNumber(handlerSize) ? handlerSize : undefined,
                handlerStyle: this._handlerStyle,
                dy: this.attribute.slider.dy,
                dx: this.attribute.slider.dx,
                slidable: true,
                range: false,
                handlerText: { visible: false },
                startText: { visible: false },
                endText: { visible: false },
                disableTriggerEvent: this.attribute.disableTriggerEvent
            };
            if (isHorizontal(this._orient)) {
                const railWidth = Math.max(0, this._layoutInfo.slider.size);
                const railHeight = (_a = this._railStyle.height) !== null && _a !== void 0 ? _a : RailDefaultSize[1];
                attrs.layout = 'horizontal';
                attrs.railHeight = railHeight;
                attrs.railWidth = railWidth;
                attrs.x = this._layoutInfo.slider.x;
                attrs.y = this._layoutInfo.slider.y;
            }
            else {
                const railHeight = Math.max(0, this._layoutInfo.slider.size);
                const railWidth = (_b = this._railStyle.width) !== null && _b !== void 0 ? _b : RailDefaultSize[1];
                attrs.layout = 'vertical';
                attrs.railWidth = railWidth;
                attrs.railHeight = railHeight;
                attrs.x = this._layoutInfo.slider.x;
                attrs.y = this._layoutInfo.slider.y;
            }
            return attrs;
        };
        this._initSlider = () => {
            const attrs = this._updateSliderAttrs();
            this._slider = new Slider(attrs);
            if (this._sliderVisible) {
                this.add(this._slider);
            }
        };
        this._updateControllerAttrs = () => {
            const attrs = {
                start: this._start,
                pause: this._pause,
                forward: this._forward,
                backward: this._backward,
                disableTriggerEvent: this.attribute.disableTriggerEvent
            };
            attrs.layout = isHorizontal(this._orient) ? 'horizontal' : 'vertical';
            attrs.start = Object.assign(Object.assign({}, attrs.start), { style: Object.assign(Object.assign({}, attrs.start.style), { x: this._layoutInfo.start.x, y: this._layoutInfo.start.y }) });
            attrs.pause = Object.assign(Object.assign({}, attrs.pause), { style: Object.assign(Object.assign({}, attrs.pause.style), { x: this._layoutInfo.start.x, y: this._layoutInfo.start.y }) });
            attrs.backward = Object.assign(Object.assign({}, attrs.backward), { style: Object.assign(Object.assign({}, attrs.backward.style), { x: this._layoutInfo.backward.x, y: this._layoutInfo.backward.y }) });
            attrs.forward = Object.assign(Object.assign({}, attrs.forward), { style: Object.assign(Object.assign({}, attrs.forward.style), { x: this._layoutInfo.forward.x, y: this._layoutInfo.forward.y }) });
            return attrs;
        };
        this._initController = () => {
            const attrs = this._updateControllerAttrs();
            this._controller = new Controller(attrs);
            if (this._controllerVisible) {
                this.add(this._controller);
            }
        };
        this._initAttributes();
        this._initDataIndex();
        this._initLayoutInfo();
        this._initController();
        this._initSlider();
    }
    _initAttributes() {
        this._size = this.attribute.size;
        this._orient = this.attribute.orient;
        this._data = this.attribute.data;
        this._minIndex = 0;
        this._maxIndex = this._data.length - 1;
        const { slider = {}, controller = {} } = this.attribute;
        this._sliderVisible = slider.visible;
        this._railStyle = Object.assign({}, slider.railStyle);
        this._trackStyle = Object.assign({}, slider.trackStyle);
        this._handlerStyle = Object.assign({}, slider.handlerStyle);
        this._controllerVisible = controller.visible;
        this._start = Object.assign({}, controller.start);
        this._pause = Object.assign({}, controller.pause);
        this._forward = Object.assign({}, controller.forward);
        this._backward = Object.assign({}, controller.backward);
    }
    _initDataIndex() {
        var _a;
        this._dataIndex = (_a = this.attribute.dataIndex) !== null && _a !== void 0 ? _a : 0;
    }
    _initLayoutInfo() {
        var _a, _b, _c;
        const controllers = [this._start, this._backward, this._forward].sort((a, b) => a.order - b.order);
        const startControllers = controllers.filter(d => d.position !== 'end');
        const endControllers = controllers.filter(d => d.position === 'end');
        const railSectionLength = (_a = (isHorizontal(this._orient) ? this._railStyle.height : this._railStyle.width)) !== null && _a !== void 0 ? _a : RailDefaultSize[1];
        const controllerPx = controllers.reduce((len, controller) => {
            const size = controller.style.size;
            const maxSize = isNumber(size) ? size : max(size[0], size[1]);
            return len + controller.space + maxSize;
        }, 0);
        const sliderPx = this._sliderVisible
            ? (isHorizontal(this._orient) ? (_b = this._size) === null || _b === void 0 ? void 0 : _b.width : (_c = this._size) === null || _c === void 0 ? void 0 : _c.height) - controllerPx
            : 0;
        const railPx = sliderPx - this.attribute.slider.space;
        const startPx = startControllers.reduce((px, controller) => {
            const { key, space, style: { size } } = controller;
            const maxSize = isNumber(size) ? size : max(size[0], size[1]);
            this._layoutInfo[key] = Object.assign(Object.assign({}, this._layoutInfo[key]), { size: maxSize, x: isHorizontal(this._orient) ? px + space : (this._size.width - maxSize) / 2, y: isHorizontal(this._orient) ? (this._size.height - maxSize) / 2 : px + space });
            return px + space + maxSize;
        }, 0);
        this._layoutInfo.slider = Object.assign(Object.assign({}, this._layoutInfo.slider), { size: railPx, x: isHorizontal(this._orient)
                ? startPx + this.attribute.slider.space
                : (this._size.width - railSectionLength) / 2, y: isHorizontal(this._orient)
                ? (this._size.height - railSectionLength) / 2
                : startPx + this.attribute.slider.space });
        endControllers.reduce((px, controller) => {
            const { key, space, style: { size } } = controller;
            const maxSize = isNumber(size) ? size : max(size[0], size[1]);
            this._layoutInfo[key] = Object.assign(Object.assign({}, this._layoutInfo[key]), { size: maxSize, x: isHorizontal(this._orient) ? px + space : (this._size.width - maxSize) / 2, y: isHorizontal(this._orient) ? (this._size.height - maxSize) / 2 : px + space });
            return px + space + maxSize;
        }, startPx + sliderPx);
    }
    render() {
        this._initLayoutInfo();
        this.renderSlider();
        this.renderController();
    }
    renderSlider() {
        const attrs = this._updateSliderAttrs();
        this._slider.setAttributes(attrs);
    }
    renderController() {
        const attrs = this._updateControllerAttrs();
        this._controller.setAttributes(attrs);
    }
    dispatchCustomEvent(eventType, dataIndex) {
        this._dispatchEvent(eventType, {
            eventType,
            index: dataIndex,
            value: this._data[dataIndex]
        });
    }
}
BasePlayer.defaultAttributes = {
    visible: true,
    data: [],
    interval: 1000,
    orient: 'bottom',
    align: 'center',
    size: {
        height: 20,
        width: 300
    },
    slider: {
        visible: true,
        space: 10,
        dx: 0,
        dy: 0,
        railStyle: {
            cornerRadius: 5
        },
        trackStyle: {},
        handlerStyle: {}
    },
    controller: {
        visible: true,
        start: Object.assign(Object.assign({}, defaultControllerAttributes), { key: 'start', position: 'start', space: 0 }),
        pause: Object.assign(Object.assign({}, defaultControllerAttributes), { key: 'pause', position: 'start' }),
        forward: Object.assign(Object.assign({}, defaultControllerAttributes), { key: 'forward', position: 'end' }),
        backward: Object.assign(Object.assign({}, defaultControllerAttributes), { key: 'backward', position: 'start' })
    }
};

function loadBasePlayer() {
    loadSliderComponent();
    registerGroup();
    registerSymbol();
}
function loadDiscretePlayerComponent() {
    loadBasePlayer();
}
function loadContinuousPlayerComponent() {
    loadBasePlayer();
}

loadDiscretePlayerComponent();
class DiscretePlayer extends BasePlayer {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, attributes));
        this._activeIndex = -1;
        this._isReachEnd = false;
        this._initAttributes = () => {
            var _a, _b, _c;
            super._initAttributes();
            this._alternate = (_a = this.attribute.alternate) !== null && _a !== void 0 ? _a : false;
            this._interval = (_b = this.attribute.interval) !== null && _b !== void 0 ? _b : 1000;
            this._direction = (_c = this.attribute.direction) !== null && _c !== void 0 ? _c : DirectionEnum.Default;
        };
        this._initDataIndex = () => {
            var _a;
            this._dataIndex = isNil(this.attribute.dataIndex)
                ? this._direction === 'default'
                    ? this._minIndex
                    : this._maxIndex
                : (_a = this.attribute.dataIndex) !== null && _a !== void 0 ? _a : 0;
            this._slider.setAttribute('value', this._dataIndex);
        };
        this._initEvents = () => {
            if (this.attribute.disableTriggerEvent) {
                return;
            }
            this._controller.addEventListener(ControllerEventEnum.OnPlay, (e) => {
                e.stopPropagation();
                this.play();
            });
            this._controller.addEventListener(ControllerEventEnum.OnPause, (e) => {
                e.stopPropagation();
                this.pause();
            });
            this._controller.addEventListener(ControllerEventEnum.OnForward, (e) => {
                e.stopPropagation();
                this.forward();
            });
            this._controller.addEventListener(ControllerEventEnum.OnBackward, (e) => {
                e.stopPropagation();
                this.backward();
            });
            this._slider.addEventListener('change', (e) => {
                const middle = Math.floor(e.detail.value) + 0.5;
                this._dataIndex = e.detail.value >= middle ? Math.ceil(e.detail.value) : Math.floor(e.detail.value);
                this._slider.setValue(this._dataIndex);
                this.dispatchCustomEvent(PlayerEventEnum.change);
            });
        };
        this.play = () => {
            if (this._isPlaying) {
                return;
            }
            if (this._data.length === 1) {
                return;
            }
            this._controller.togglePause();
            this._isPlaying = true;
            if (isReachEnd({
                dataIndex: this._dataIndex,
                maxIndex: this._maxIndex,
                minIndex: this._minIndex,
                direction: this._direction
            }) ||
                isReachStart({
                    dataIndex: this._dataIndex,
                    maxIndex: this._maxIndex,
                    minIndex: this._minIndex,
                    direction: this._direction
                })) {
                if (this._direction === DirectionEnum.Default) {
                    this._updateDataIndex(this._minIndex);
                }
                else {
                    this._updateDataIndex(this._maxIndex);
                }
            }
            this.dispatchCustomEvent(PlayerEventEnum.play);
            this._isReachEnd = false;
            this._tickTime = Date.now();
            this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this, true));
        };
        this._play = (isFirstPlay) => {
            const now = Date.now();
            if (this._isReachEnd && now - this._tickTime >= this._interval) {
                this._isReachEnd = false;
                this._playEnd();
                return;
            }
            if (isFirstPlay && this._activeIndex !== this._dataIndex) {
                this.dispatchCustomEvent(PlayerEventEnum.change);
                this._activeIndex = this._dataIndex;
            }
            else if (now - this._tickTime >= this._interval) {
                this._tickTime = now;
                this._updateDataIndex(forwardStep(this._direction, this._dataIndex, this._minIndex, this._maxIndex));
                this._activeIndex = this._dataIndex;
                this.dispatchCustomEvent(PlayerEventEnum.change);
            }
            if ((this._direction === 'default' && this._dataIndex >= this._maxIndex) ||
                (this._direction === 'reverse' && this._dataIndex <= this._minIndex)) {
                this._isReachEnd = true;
            }
            this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this, false));
        };
        this._updateDataIndex = (dataIndex) => {
            this._dataIndex = dataIndex;
            this._slider.setValue(this._dataIndex);
        };
        this._playEnd = () => {
            this._isPlaying = false;
            this._controller.togglePlay();
            vglobal.getCancelAnimationFrame()(this._rafId);
            this._activeIndex = -1;
            this.dispatchCustomEvent(PlayerEventEnum.end);
        };
        this.pause = () => {
            if (!this._isPlaying) {
                return;
            }
            this._isPlaying = false;
            vglobal.getCancelAnimationFrame()(this._rafId);
            this._controller.togglePlay();
            this.dispatchCustomEvent(PlayerEventEnum.pause);
        };
        this.backward = () => {
            const { loop = false } = this.attribute;
            let index;
            if (loop) {
                index = this._dataIndex - 1 < this._minIndex ? this._maxIndex : this._dataIndex - 1;
            }
            else {
                index = Math.max(this._dataIndex - 1, this._minIndex);
            }
            this._updateDataIndex(index);
            this.dispatchCustomEvent(PlayerEventEnum.change);
            this.dispatchCustomEvent(PlayerEventEnum.backward);
        };
        this.forward = () => {
            const { loop = false } = this.attribute;
            let index;
            if (loop) {
                index = this._dataIndex + 1 > this._maxIndex ? this._minIndex : this._dataIndex + 1;
            }
            else {
                index = Math.min(this._dataIndex + 1, this._maxIndex);
            }
            this._updateDataIndex(index);
            this.dispatchCustomEvent(PlayerEventEnum.change);
            this.dispatchCustomEvent(PlayerEventEnum.forward);
        };
        this._initAttributes();
        this._initDataIndex();
        this._initEvents();
    }
    setAttributes(params, forceUpdateTag) {
        super.setAttributes(params, forceUpdateTag);
        this._initAttributes();
    }
    dispatchCustomEvent(event) {
        super.dispatchCustomEvent(event, this._dataIndex);
    }
}

loadContinuousPlayerComponent();
class ContinuousPlayer extends BasePlayer {
    constructor(attributes) {
        super(attributes);
        this._isPlaying = false;
        this._startTime = Date.now();
        this._initAttributes = () => {
            var _a;
            super._initAttributes();
            this._maxIndex = this._data.length;
            this._slider.setAttribute('max', this._maxIndex);
            this._isPlaying = false;
            this._elapsed = 0;
            this._interval = (_a = this.attribute.interval) !== null && _a !== void 0 ? _a : 1000;
            const frames = this._data.length;
            if (this.attribute.totalDuration && this._data.length) {
                this._totalDuration = this.attribute.totalDuration;
                this._interval = this._totalDuration / (frames !== null && frames !== void 0 ? frames : 1);
            }
            else {
                this._totalDuration = this._interval * frames;
                this._interval = this.attribute.interval;
            }
        };
        this._initDataIndex = () => {
            var _a;
            this._dataIndex = (_a = this.attribute.dataIndex) !== null && _a !== void 0 ? _a : this._minIndex;
        };
        this._initEvents = () => {
            if (this.attribute.disableTriggerEvent) {
                return;
            }
            this._controller.addEventListener(ControllerEventEnum.OnPlay, (e) => {
                e.stopPropagation();
                this.play();
            });
            this._controller.addEventListener(ControllerEventEnum.OnPause, (e) => {
                e.stopPropagation();
                this.pause();
            });
            this._controller.addEventListener(ControllerEventEnum.OnForward, (e) => {
                e.stopPropagation();
                this.forward();
            });
            this._controller.addEventListener(ControllerEventEnum.OnBackward, (e) => {
                e.stopPropagation();
                this.backward();
            });
            this._slider.addEventListener('change', (e) => {
                var _a;
                e.stopPropagation();
                const value = (_a = e.detail) === null || _a === void 0 ? void 0 : _a.value;
                const progress = value / this._maxIndex;
                this._elapsed = progress * this._totalDuration;
                this._startTime = Date.now() - this._elapsed;
                this._dispatchChange(value);
            });
        };
        this._getSliderValue = () => {
            const progress = this._elapsed / this._totalDuration;
            return Math.min(progress * this._maxIndex, this._maxIndex);
        };
        this._updateSlider = () => {
            const value = this._getSliderValue();
            this._dataIndex = Math.floor(value);
            this._slider.setValue(Math.min(value, this._maxIndex));
            this._dispatchChange(Math.floor(value));
        };
        this._dispatchChange = (value) => {
            const index = Math.floor(value);
            if (index !== this._activeIndex) {
                this._dataIndex = index;
                this._activeIndex = index;
                if (index !== this._maxIndex) {
                    this.dispatchCustomEvent(PlayerEventEnum.change);
                }
            }
        };
        this.play = () => __awaiter(this, void 0, void 0, function* () {
            if (this._isPlaying) {
                return;
            }
            this._controller.togglePause();
            this._isPlaying = true;
            if (this._elapsed >= this._totalDuration) {
                this._elapsed = 0;
            }
            this._startTime = Date.now() - this._elapsed;
            this.dispatchCustomEvent(PlayerEventEnum.play);
            this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this));
        });
        this._play = () => {
            this._elapsed = Date.now() - this._startTime;
            const value = this._getSliderValue();
            this._updateSlider();
            if (value >= this._maxIndex) {
                this._playEnd();
                return;
            }
            this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this));
        };
        this._playEnd = () => {
            this._isPlaying = false;
            vglobal.getCancelAnimationFrame()(this._rafId);
            this._controller.togglePlay();
            this.dispatchCustomEvent(PlayerEventEnum.end);
        };
        this.pause = () => {
            if (!this._isPlaying) {
                return;
            }
            this._isPlaying = false;
            this._elapsed = Date.now() - this._startTime;
            vglobal.getCancelAnimationFrame()(this._rafId);
            this._controller.togglePlay();
            this.dispatchCustomEvent(PlayerEventEnum.pause);
        };
        this.backward = () => {
            const now = Date.now();
            const interval = this._interval * 1;
            const elapsed = this._elapsed - interval;
            if (elapsed <= 0) {
                this._elapsed = 0;
                this._startTime = now;
            }
            else {
                this._elapsed = elapsed;
                this._startTime = this._startTime + this._interval;
            }
            this._updateSlider();
            this.dispatchCustomEvent(PlayerEventEnum.backward);
        };
        this.forward = () => {
            const now = Date.now();
            const interval = this._interval * 1;
            const elapsed = this._elapsed + interval;
            if (elapsed >= this._totalDuration) {
                this._startTime = now - this._totalDuration;
                this._elapsed = this._totalDuration;
            }
            else {
                this._startTime = this._startTime - interval;
                this._elapsed = elapsed;
            }
            this._updateSlider();
            this.dispatchCustomEvent(PlayerEventEnum.forward);
        };
        this._initAttributes();
        this._initDataIndex();
        this._initEvents();
    }
    dispatchCustomEvent(eventType) {
        super.dispatchCustomEvent(eventType, this._dataIndex);
    }
    render() {
        super.render();
    }
}

var IOperateType;
(function (IOperateType) {
    IOperateType["drawStart"] = "drawStart";
    IOperateType["drawEnd"] = "drawEnd";
    IOperateType["drawing"] = "drawing";
    IOperateType["moving"] = "moving";
    IOperateType["moveStart"] = "moveStart";
    IOperateType["moveEnd"] = "moveEnd";
    IOperateType["brushActive"] = "brushActive";
    IOperateType["brushClear"] = "brushClear";
})(IOperateType || (IOperateType = {}));

const DEFAULT_BRUSH_ATTRIBUTES = {
    trigger: 'pointerdown',
    updateTrigger: 'pointermove',
    endTrigger: ['pointerup', 'pointerleave'],
    resetTrigger: 'pointerupoutside',
    hasMask: true,
    brushMode: 'single',
    brushType: 'rect',
    brushStyle: {
        fill: '#B0C8F9',
        fillOpacity: 0.2,
        stroke: '#B0C8F9',
        strokeWidth: 2
    },
    brushMoved: true,
    removeOnClick: true,
    delayType: 'throttle',
    delayTime: 10,
    interactiveRange: {
        minY: -Infinity,
        maxY: Infinity,
        minX: -Infinity,
        maxX: Infinity
    }
};
const DEFAULT_SIZE_THRESHOLD = 5;

function loadBrushComponent() {
    registerGroup();
    registerPolygon();
}

const delayMap = {
    debounce: debounce,
    throttle: throttle
};
loadBrushComponent();
class Brush extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, Brush.defaultAttributes, attributes));
        this.name = 'brush';
        this._activeBrushState = false;
        this._activeDrawState = false;
        this._cacheDrawPoints = [];
        this._activeMoveState = false;
        this._operatingMaskMoveDx = 0;
        this._operatingMaskMoveDy = 0;
        this._operatingMaskMoveRangeX = [-Infinity, Infinity];
        this._operatingMaskMoveRangeY = [-Infinity, Infinity];
        this._brushMaskAABBBoundsDict = {};
        this._firstUpdate = true;
        this._onBrushStart = (e) => {
            const { updateTrigger = DEFAULT_BRUSH_ATTRIBUTES.updateTrigger, endTrigger = DEFAULT_BRUSH_ATTRIBUTES.endTrigger, brushMoved = true } = this.attribute;
            array(updateTrigger).forEach(t => this.stage.addEventListener(t, this._onBrushingWithDelay));
            array(endTrigger).forEach(t => this.stage.addEventListener(t, this._onBrushEnd));
            e.stopPropagation();
            this._firstUpdate = true;
            this._activeMoveState = brushMoved && this._isPosInBrushMask(e);
            this._activeDrawState = !this._activeMoveState;
            this._startPos = this.eventPosToStagePos(e);
            this._cacheDrawPoints = [this._startPos];
        };
        this._onBrushing = (e) => {
            if (this._outOfInteractiveRange(e)) {
                return;
            }
            e.stopPropagation();
            if (this._firstUpdate) {
                this._activeDrawState && this._initDraw(e);
                this._activeMoveState && this._initMove(e);
                this._firstUpdate = false;
            }
            else {
                this._activeDrawState && this._drawing(e);
                this._activeMoveState && this._moving(e);
            }
        };
        this._onBrushingWithDelay = this.attribute.delayTime === 0
            ? this._onBrushing
            : delayMap[this.attribute.delayType](this._onBrushing, this.attribute.delayTime);
        this._onBrushEnd = (e) => {
            this._releaseBrushUpdateEvents();
            e.preventDefault();
            this._activeDrawState && this._drawEnd(e);
            this._activeMoveState && this._moveEnd(e);
            this._activeDrawState = false;
            this._activeMoveState = false;
        };
        this._onBrushClear = (e) => {
            e.preventDefault();
            if (!this._isEmptyMask()) {
                this._clearMask();
                this._dispatchBrushEvent(IOperateType.brushClear, e);
            }
            this._activeDrawState = false;
            this._activeMoveState = false;
        };
    }
    _bindBrushEvents() {
        this.releaseBrushEvents();
        if (this.attribute.disableTriggerEvent) {
            return;
        }
        const { trigger = DEFAULT_BRUSH_ATTRIBUTES.trigger, resetTrigger = DEFAULT_BRUSH_ATTRIBUTES.resetTrigger } = this
            .attribute;
        array(trigger).forEach(t => this.stage.addEventListener(t, this._onBrushStart));
        array(resetTrigger).forEach(t => this.stage.addEventListener(t, this._onBrushClear));
    }
    _initDraw(e) {
        const { brushMode } = this.attribute;
        const pos = this.eventPosToStagePos(e);
        this._cacheDrawPoints.push(pos);
        brushMode === 'single' && this._clearMask();
        this._addBrushMask();
        this._dispatchBrushEvent(IOperateType.drawStart, e);
        this._activeBrushState = false;
    }
    _initMove(e) {
        var _a, _b;
        this._cacheMovePoint = this.eventPosToStagePos(e);
        this._operatingMaskMoveDx = (_a = this._operatingMask.attribute.dx) !== null && _a !== void 0 ? _a : 0;
        this._operatingMaskMoveDy = (_b = this._operatingMask.attribute.dy) !== null && _b !== void 0 ? _b : 0;
        const { interactiveRange } = this.attribute;
        const { minY = -Infinity, maxY = Infinity, minX = -Infinity, maxX = Infinity } = interactiveRange;
        const { x1, x2, y1, y2 } = this._operatingMask.globalAABBBounds;
        const minMoveStepX = minX - x1;
        const maxMoveStepX = maxX - x2;
        const minMoveStepY = minY - y1;
        const maxMoveStepY = maxY - y2;
        this._operatingMaskMoveRangeX = [minMoveStepX, maxMoveStepX];
        this._operatingMaskMoveRangeY = [minMoveStepY, maxMoveStepY];
        this._operatingMask.setAttribute('pickable', true);
        this._dispatchBrushEvent(IOperateType.moveStart, e);
    }
    _drawing(e) {
        var _a;
        const pos = this.eventPosToStagePos(e);
        const { brushType, sizeThreshold = DEFAULT_SIZE_THRESHOLD } = this.attribute;
        const cacheLength = this._cacheDrawPoints.length;
        if (cacheLength > 0) {
            const lastPos = (_a = this._cacheDrawPoints[this._cacheDrawPoints.length - 1]) !== null && _a !== void 0 ? _a : {};
            if (pos.x === lastPos.x && pos.y === lastPos.y) {
                return;
            }
        }
        if (brushType === 'polygon' || cacheLength <= 1) {
            this._cacheDrawPoints.push(pos);
        }
        else {
            this._cacheDrawPoints[cacheLength - 1] = pos;
        }
        const maskPoints = this._computeMaskPoints();
        this._operatingMask.setAttribute('points', maskPoints);
        const { x: x1, y: y1 } = this._startPos;
        const { x: x2, y: y2 } = this.eventPosToStagePos(e);
        if (Math.abs(x2 - x1) > sizeThreshold || Math.abs(y1 - y2) > sizeThreshold) {
            if (Object.keys(this._brushMaskAABBBoundsDict).length === 1 && !this._activeBrushState) {
                this._activeBrushState = true;
                this._dispatchBrushEvent(IOperateType.brushActive, e);
            }
            else {
                this._dispatchBrushEvent(IOperateType.drawing, e);
            }
        }
    }
    _moving(e) {
        const startPos = this._cacheMovePoint;
        const pos = this.eventPosToStagePos(e);
        if (pos.x === (startPos === null || startPos === void 0 ? void 0 : startPos.x) && pos.y === (startPos === null || startPos === void 0 ? void 0 : startPos.y)) {
            return;
        }
        const moveStepX = pos.x - startPos.x;
        const moveStepY = pos.y - startPos.y;
        const moveX = Math.min(this._operatingMaskMoveRangeX[1], Math.max(this._operatingMaskMoveRangeX[0], moveStepX)) +
            this._operatingMaskMoveDx;
        const moveY = Math.min(this._operatingMaskMoveRangeY[1], Math.max(this._operatingMaskMoveRangeY[0], moveStepY)) +
            this._operatingMaskMoveDy;
        this._operatingMask.setAttributes({
            dx: moveX,
            dy: moveY
        });
        this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds;
        this._dispatchBrushEvent(IOperateType.moving, e);
    }
    _drawEnd(e) {
        const { removeOnClick = true, sizeThreshold = DEFAULT_SIZE_THRESHOLD } = this.attribute;
        if (this._outOfInteractiveRange(e)) {
            if (!this._isEmptyMask()) {
                this._clearMask();
                this._dispatchBrushEvent(IOperateType.brushClear, e);
            }
        }
        else {
            const { x: x1, y: y1 } = this._startPos;
            const { x: x2, y: y2 } = this.eventPosToStagePos(e);
            if (Math.abs(x2 - x1) <= 1 && Math.abs(y2 - y1) <= 1 && removeOnClick) {
                if (!this._isEmptyMask()) {
                    this._clearMask();
                    this._dispatchBrushEvent(IOperateType.brushClear, e);
                }
            }
            else if (Math.abs(x2 - x1) < sizeThreshold && Math.abs(y1 - y2) < sizeThreshold) {
                delete this._brushMaskAABBBoundsDict[this._operatingMask.name];
                this._container.setAttributes({});
                this._container.removeChild(this._operatingMask);
                if (this._isEmptyMask()) {
                    this._dispatchBrushEvent(IOperateType.brushClear, e);
                }
            }
            else {
                this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds;
                this._dispatchBrushEvent(IOperateType.drawEnd, e);
            }
        }
    }
    _moveEnd(e) {
        if (this._operatingMask) {
            this._operatingMask.setAttribute('pickable', false);
        }
        this._dispatchBrushEvent(IOperateType.moveEnd, e);
    }
    render() {
        this._bindBrushEvents();
        const group = this.createOrUpdateChild('brush-container', {}, 'group');
        this._container = group;
    }
    releaseBrushEvents() {
        const { trigger = DEFAULT_BRUSH_ATTRIBUTES.trigger, resetTrigger = DEFAULT_BRUSH_ATTRIBUTES.resetTrigger } = this
            .attribute;
        array(trigger).forEach(t => this.stage.removeEventListener(t, this._onBrushStart));
        array(resetTrigger).forEach(t => this.stage.removeEventListener(t, this._onBrushClear));
        this._releaseBrushUpdateEvents();
    }
    _releaseBrushUpdateEvents() {
        const { updateTrigger = DEFAULT_BRUSH_ATTRIBUTES.updateTrigger, endTrigger = DEFAULT_BRUSH_ATTRIBUTES.endTrigger } = this.attribute;
        array(updateTrigger).forEach(t => this.stage.removeEventListener(t, this._onBrushingWithDelay));
        array(endTrigger).forEach(t => this.stage.removeEventListener(t, this._onBrushEnd));
    }
    _computeMaskPoints() {
        const { brushType, xRange = [0, 0], yRange = [0, 0] } = this.attribute;
        let maskPoints = [];
        const startPoint = this._cacheDrawPoints[0];
        const endPoint = this._cacheDrawPoints[this._cacheDrawPoints.length - 1];
        if (brushType === 'rect') {
            maskPoints = [
                startPoint,
                {
                    x: endPoint.x,
                    y: startPoint.y
                },
                endPoint,
                {
                    x: startPoint.x,
                    y: endPoint.y
                }
            ];
        }
        else if (brushType === 'x') {
            maskPoints = [
                {
                    x: startPoint.x,
                    y: yRange[0]
                },
                {
                    x: endPoint.x,
                    y: yRange[0]
                },
                {
                    x: endPoint.x,
                    y: yRange[1]
                },
                {
                    x: startPoint.x,
                    y: yRange[1]
                }
            ];
        }
        else if (brushType === 'y') {
            maskPoints = [
                {
                    x: xRange[0],
                    y: startPoint.y
                },
                {
                    x: xRange[0],
                    y: endPoint.y
                },
                {
                    x: xRange[1],
                    y: endPoint.y
                },
                {
                    x: xRange[1],
                    y: startPoint.y
                }
            ];
        }
        else {
            maskPoints = cloneDeep(this._cacheDrawPoints);
        }
        return maskPoints;
    }
    _addBrushMask() {
        var _a;
        const { brushStyle, hasMask } = this.attribute;
        const brushMask = graphicCreator.polygon(Object.assign(Object.assign({ points: cloneDeep(this._cacheDrawPoints), cursor: 'move', pickable: false }, brushStyle), { opacity: hasMask ? (_a = brushStyle.opacity) !== null && _a !== void 0 ? _a : 1 : 0 }));
        brushMask.name = `brush-${Date.now()}`;
        this._operatingMask = brushMask;
        this._container.add(brushMask);
        this._brushMaskAABBBoundsDict[brushMask.name] = brushMask.AABBBounds;
    }
    _isPosInBrushMask(e) {
        const pos = this.eventPosToStagePos(e);
        const brushMasks = this._container.getChildren();
        for (let i = 0; i < brushMasks.length; i++) {
            const { points = [], dx = 0, dy = 0 } = brushMasks[i].attribute;
            const pointsConsiderOffset = points.map((point) => {
                return {
                    x: point.x + dx,
                    y: point.y + dy
                };
            });
            if (polygonContainPoint(pointsConsiderOffset, pos.x, pos.y)) {
                this._operatingMask = brushMasks[i];
                return true;
            }
        }
        return false;
    }
    _outOfInteractiveRange(e) {
        const { interactiveRange } = this.attribute;
        const { minY = -Infinity, maxY = Infinity, minX = -Infinity, maxX = Infinity } = interactiveRange;
        const pos = this.eventPosToStagePos(e);
        if (pos.x > maxX || pos.x < minX || pos.y > maxY || pos.y < minY) {
            return true;
        }
        return false;
    }
    _dispatchBrushEvent(operateType, e) {
        this._dispatchEvent(operateType, {
            operateMask: this._operatingMask,
            operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
            event: e
        });
    }
    _clearMask() {
        this._brushMaskAABBBoundsDict = {};
        this._container.removeAllChild();
        this._operatingMask = null;
    }
    _isEmptyMask() {
        return (isEmpty(this._brushMaskAABBBoundsDict) ||
            Object.keys(this._brushMaskAABBBoundsDict).every(key => this._brushMaskAABBBoundsDict[key].empty()));
    }
}
Brush.defaultAttributes = DEFAULT_BRUSH_ATTRIBUTES;

const mergeRowAttrs = (target, ...sources) => {
    const shapeList = [target.shape, ...sources.map(s => s === null || s === void 0 ? void 0 : s.shape)];
    const keyList = [target.key, ...sources.map(s => s === null || s === void 0 ? void 0 : s.key)];
    const valueList = [target.value, ...sources.map(s => s === null || s === void 0 ? void 0 : s.value)];
    return merge(target, ...sources, {
        shape: shapeList.every(isNil) ? undefined : merge({}, ...shapeList),
        key: keyList.every(isNil) ? undefined : merge({}, ...keyList),
        value: valueList.every(isNil) ? undefined : merge({}, ...valueList)
    });
};
const getRichTextAttribute = (attr) => {
    const { width, height, wordBreak = 'break-word', textAlign, textBaseline, text } = attr;
    if (Array.isArray(text)) {
        return {
            width,
            height,
            wordBreak: wordBreak,
            textAlign: textAlign,
            textBaseline: textBaseline,
            singleLine: false,
            textConfig: array(text).map(text => (Object.assign(Object.assign({}, attr), { text })))
        };
    }
    return {
        width,
        height,
        wordBreak: wordBreak,
        textAlign: textAlign,
        textBaseline: textBaseline,
        singleLine: false,
        textConfig: text === null || text === void 0 ? void 0 : text.text
    };
};

const defaultAttributes = {
    panel: {
        visible: true,
        cornerRadius: [3, 3, 3, 3],
        fill: 'white',
        shadow: true,
        shadowBlur: 12,
        shadowColor: 'rgba(0, 0, 0, 0.1)',
        shadowOffsetX: 0,
        shadowOffsetY: 4,
        shadowSpread: 0,
        stroke: 'white'
    },
    titleStyle: {
        value: {
            fill: '#4E5969',
            fontFamily: DEFAULT_TEXT_FONT_FAMILY,
            fontSize: 14,
            lineHeight: 18,
            textAlign: 'left',
            textBaseline: 'middle'
        },
        spaceRow: 6
    },
    contentStyle: {
        shape: {
            fill: 'black',
            size: 8,
            symbolType: 'circle',
            spacing: 6
        },
        key: {
            fill: '#4E5969',
            fontFamily: DEFAULT_TEXT_FONT_FAMILY,
            fontSize: 12,
            lineHeight: 18,
            textAlign: 'left',
            textBaseline: 'middle',
            spacing: 26
        },
        value: {
            fill: '#4E5969',
            fontFamily: DEFAULT_TEXT_FONT_FAMILY,
            fontSize: 12,
            lineHeight: 18,
            textAlign: 'right',
            textBaseline: 'middle',
            spacing: 0
        },
        spaceRow: 6
    },
    padding: 10,
    positionX: 'right',
    positionY: 'bottom',
    offsetX: 10,
    offsetY: 10,
    parentBounds: new AABBBounds().setValue(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY),
    autoCalculatePosition: true,
    autoMeasure: true,
    pickable: false,
    childrenPickable: false,
    zIndex: 500
};
const TOOLTIP_POSITION_ATTRIBUTES = [
    'pointerX',
    'pointerY',
    'offsetX',
    'offsetY',
    'positionX',
    'positionY',
    'parentBounds'
];

function loadTooltipComponent() {
    registerGroup();
    registerRect();
    registerSymbol();
    registerText();
    registerRichtext();
}

const TOOLTIP_BACKGROUND_NAME = 'tooltip-background';
const TOOLTIP_TITLE_NAME = 'tooltip-title';
const TOOLTIP_CONTENT_NAME = 'tooltip-content';
const TOOLTIP_SHAPE_NAME_SUFFIX = 'shape';
const TOOLTIP_KEY_NAME_SUFFIX = 'key';
const TOOLTIP_VALUE_NAME_SUFFIX = 'value';
loadTooltipComponent();
class Tooltip extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, Tooltip.defaultAttributes, attributes), options);
        this.name = 'tooltip';
    }
    render() {
        var _a;
        const { visible, content, panel, keyWidth, valueWidth, hasContentShape, autoCalculatePosition, autoMeasure, align } = this.attribute;
        if (!visible) {
            this.hideAll();
            return;
        }
        if (autoMeasure) {
            Tooltip.measureTooltip(this.attribute);
        }
        if (autoCalculatePosition) {
            Tooltip.calculateTooltipPosition(this.attribute);
        }
        const padding = normalizePadding(this.attribute.padding);
        this._tooltipPanel = this.createOrUpdateChild(TOOLTIP_BACKGROUND_NAME, Object.assign({ visible: true }, panel), 'rect');
        this._tooltipTitleContainer = this.createOrUpdateChild(TOOLTIP_TITLE_NAME, { visible: true, x: padding[3], y: padding[0] }, 'group');
        const titleAttr = Tooltip.getTitleAttr(this.attribute);
        this._tooltipTitleSymbol = this._tooltipTitleContainer.createOrUpdateChild(`${TOOLTIP_TITLE_NAME}-${TOOLTIP_SHAPE_NAME_SUFFIX}`, merge({ symbolType: 'circle' }, titleAttr.shape, {
            visible: isVisible(titleAttr) && isVisible(titleAttr.shape)
        }), 'symbol');
        if (typeof titleAttr.value.text === 'object' &&
            titleAttr.value.text !== null &&
            (titleAttr.value.text.type === 'rich' ||
                titleAttr.value.text.type === 'html')) {
            if (titleAttr.value.text.type === 'rich') {
                this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild(`${TOOLTIP_TITLE_NAME}-${TOOLTIP_VALUE_NAME_SUFFIX}`, Object.assign({ visible: isVisible(titleAttr) && isVisible(titleAttr.value) }, getRichTextAttribute(titleAttr.value)), 'richtext');
            }
            else if (titleAttr.value.text.type === 'html') {
                this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild(`${TOOLTIP_TITLE_NAME}-${TOOLTIP_VALUE_NAME_SUFFIX}`, Object.assign({ html: Object.assign(Object.assign({ dom: titleAttr.value.text.text }, DEFAULT_HTML_TEXT_SPEC), titleAttr.value), visible: isVisible(titleAttr) && isVisible(titleAttr.value), width: titleAttr.value.width, height: titleAttr.value.height, wordBreak: titleAttr.value.wordBreak, textAlign: titleAttr.value.textAlign, textBaseline: titleAttr.value.textBaseline, singleLine: false, textConfig: [] }, titleAttr.value), 'richtext');
            }
        }
        else if (titleAttr.value.multiLine) {
            this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild(`${TOOLTIP_TITLE_NAME}-${TOOLTIP_VALUE_NAME_SUFFIX}`, Object.assign({ visible: isVisible(titleAttr) && isVisible(titleAttr.value) }, getRichTextAttribute(titleAttr.value)), 'richtext');
        }
        else {
            this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild(`${TOOLTIP_TITLE_NAME}-${TOOLTIP_VALUE_NAME_SUFFIX}`, Object.assign({ text: ((_a = titleAttr.value.text) !== null && _a !== void 0 ? _a : ''), visible: isVisible(titleAttr) && isVisible(titleAttr.value) }, titleAttr.value), 'text');
        }
        const titlePaddingLeft = isVisible(titleAttr.shape) ? titleAttr.shape.size + titleAttr.shape.spacing : 0;
        const { textAlign, textBaseline } = titleAttr.value;
        const contentWidth = panel.width - padding[3] - padding[0] - titlePaddingLeft;
        if (textAlign === 'center') {
            this._tooltipTitle.setAttribute('x', titlePaddingLeft + contentWidth / 2);
        }
        else if (textAlign === 'right' || textAlign === 'end') {
            this._tooltipTitle.setAttribute('x', titlePaddingLeft + contentWidth);
        }
        else {
            this._tooltipTitle.setAttribute('x', titlePaddingLeft);
        }
        if (textBaseline === 'bottom') {
            this._tooltipTitle.setAttribute('y', titleAttr.height);
        }
        else if (textBaseline === 'middle') {
            this._tooltipTitle.setAttribute('y', titleAttr.height / 2);
        }
        else {
            this._tooltipTitle.setAttribute('y', 0);
        }
        const titleHeight = isVisible(titleAttr) ? titleAttr.height + titleAttr.spaceRow : 0;
        this._tooltipContent = this.createOrUpdateChild(TOOLTIP_CONTENT_NAME, { visible: true }, 'group');
        this._tooltipContent.removeAllChild(true);
        if (content && content.length) {
            this._tooltipContent.setAttribute('x', padding[3]);
            this._tooltipContent.setAttribute('y', padding[0] + titleHeight);
            let lastYPos = 0;
            content.forEach((item, i) => {
                const itemAttr = Tooltip.getContentAttr(this.attribute, i);
                if (!isVisible(itemAttr)) {
                    return;
                }
                const itemGroupName = `${TOOLTIP_CONTENT_NAME}-${i}`;
                const itemGroup = this._tooltipContent.createOrUpdateChild(itemGroupName, { visible: true, x: 0, y: lastYPos }, 'group');
                const shapeOffsetWidth = itemAttr.shape.size + itemAttr.shape.spacing;
                let x = align === 'right'
                    ? (hasContentShape ? shapeOffsetWidth : 0) +
                        (isVisible(itemAttr.key) ? keyWidth + itemAttr.key.spacing : 0) +
                        (isVisible(itemAttr.value) ? valueWidth : 0)
                    : 0;
                this._createShape(align === 'right' ? x - itemAttr.shape.size / 2 : x + itemAttr.shape.size / 2, itemAttr, itemGroup, itemGroupName);
                if (hasContentShape) {
                    if (align === 'right') {
                        x -= shapeOffsetWidth;
                    }
                    else {
                        x += shapeOffsetWidth;
                    }
                }
                const keyGraphic = this._createKey(itemAttr, itemGroup, itemGroupName);
                if (keyGraphic) {
                    alignTextInLine(align, keyGraphic, itemAttr.key.textAlign, x, keyWidth);
                    keyGraphic.setAttribute('y', 0);
                    if (align === 'right') {
                        x -= keyWidth + itemAttr.key.spacing;
                    }
                    else {
                        x += keyWidth + itemAttr.key.spacing;
                    }
                }
                const valueGraphic = this._createValue(itemAttr, itemGroup, itemGroupName);
                if (valueGraphic) {
                    let textAlign = 'right';
                    if (isValid(itemAttr.value.textAlign)) {
                        textAlign = itemAttr.value.textAlign;
                    }
                    else if (!isVisible(itemAttr.key) && align !== 'right') {
                        textAlign = 'left';
                    }
                    valueGraphic.setAttribute('textAlign', textAlign);
                    alignTextInLine(align, valueGraphic, textAlign, x, valueWidth);
                    valueGraphic.setAttribute('y', 0);
                }
                lastYPos += itemAttr.height + itemAttr.spaceRow;
            });
        }
    }
    _createShape(x, itemAttr, itemGroup, itemGroupName) {
        var _a;
        if (isVisible(itemAttr.shape)) {
            return itemGroup.createOrUpdateChild(`${itemGroupName}-${TOOLTIP_SHAPE_NAME_SUFFIX}`, Object.assign({ visible: true, x: x, y: itemAttr.shape.size / 2 +
                    (((_a = calculateLineHeight(itemAttr.key.lineHeight, itemAttr.key.fontSize)) !== null && _a !== void 0 ? _a : itemAttr.key.fontSize) -
                        itemAttr.shape.size) /
                        2 }, itemAttr.shape), 'symbol');
        }
        return;
    }
    _createKey(itemAttr, itemGroup, itemGroupName) {
        var _a;
        if (isVisible(itemAttr.key)) {
            let element;
            if (itemAttr.key.multiLine) {
                element = itemGroup.createOrUpdateChild(`${itemGroupName}-${TOOLTIP_KEY_NAME_SUFFIX}`, Object.assign(Object.assign({ visible: true }, getRichTextAttribute(itemAttr.key)), { textBaseline: 'top' }), 'richtext');
            }
            else if (typeof itemAttr.key.text === 'object' &&
                itemAttr.key.text !== null &&
                (itemAttr.key.text.type === 'rich' ||
                    itemAttr.key.text.type === 'html')) {
                if (itemAttr.key.text.type === 'rich') {
                    element = itemGroup.createOrUpdateChild(`${itemGroupName}-${TOOLTIP_VALUE_NAME_SUFFIX}`, Object.assign(Object.assign({ visible: true }, getRichTextAttribute(itemAttr.key)), { textBaseline: 'top' }), 'richtext');
                }
                else {
                    element = itemGroup.createOrUpdateChild(`${itemGroupName}-${TOOLTIP_VALUE_NAME_SUFFIX}`, {
                        html: Object.assign(Object.assign({ dom: itemAttr.key.text.text }, DEFAULT_HTML_TEXT_SPEC), itemAttr.key)
                    }, 'richtext');
                }
            }
            else {
                element = itemGroup.createOrUpdateChild(`${itemGroupName}-${TOOLTIP_KEY_NAME_SUFFIX}`, Object.assign(Object.assign({ visible: true, text: ((_a = itemAttr.key.text) !== null && _a !== void 0 ? _a : '') }, itemAttr.key), { textBaseline: 'top' }), 'text');
            }
            return element;
        }
        return;
    }
    _createValue(itemAttr, itemGroup, itemGroupName) {
        var _a;
        if (isVisible(itemAttr.value)) {
            let element;
            if (itemAttr.value.multiLine) {
                element = itemGroup.createOrUpdateChild(`${itemGroupName}-${TOOLTIP_VALUE_NAME_SUFFIX}`, Object.assign(Object.assign({ visible: true }, getRichTextAttribute(itemAttr.value)), { textBaseline: 'top' }), 'richtext');
            }
            else if (typeof itemAttr.value.text === 'object' &&
                itemAttr.value.text !== null &&
                (itemAttr.value.text.type === 'rich' ||
                    itemAttr.value.text.type === 'html')) {
                if (itemAttr.value.text.type === 'rich') {
                    element = itemGroup.createOrUpdateChild(`${itemGroupName}-${TOOLTIP_VALUE_NAME_SUFFIX}`, Object.assign(Object.assign({ visible: true }, getRichTextAttribute(itemAttr.value)), { textBaseline: 'top' }), 'richtext');
                }
                else {
                    element = itemGroup.createOrUpdateChild(`${itemGroupName}-${TOOLTIP_VALUE_NAME_SUFFIX}`, {
                        html: Object.assign({ dom: itemAttr.value.text.text, container: '', width: 30, height: 30, style: {} }, itemAttr.value)
                    }, 'richtext');
                }
            }
            else {
                element = itemGroup.createOrUpdateChild(`${itemGroupName}-${TOOLTIP_VALUE_NAME_SUFFIX}`, Object.assign(Object.assign({ visible: true, text: ((_a = itemAttr.value.text) !== null && _a !== void 0 ? _a : '') }, itemAttr.value), { textBaseline: 'top' }), 'text');
            }
            return element;
        }
        return;
    }
    setAttributes(params, forceUpdateTag) {
        const keys = Object.keys(params);
        if (this.attribute.autoCalculatePosition && keys.every(key => TOOLTIP_POSITION_ATTRIBUTES.includes(key))) {
            this._mergeAttributes(params, keys);
            if (isNil(this.attribute.panel.width) && this.attribute.autoMeasure) {
                Tooltip.measureTooltip(this.attribute);
            }
            Tooltip.calculateTooltipPosition(this.attribute);
            super.setAttributes({
                x: this.attribute.x,
                y: this.attribute.y
            }, forceUpdateTag);
        }
        else {
            super.setAttributes(params, forceUpdateTag);
        }
    }
    static calculateTooltipPosition(attribute) {
        const { width: tooltipBoxWidth = 0, height: tooltipBoxHeight = 0 } = attribute.panel;
        const { offsetX, offsetY, pointerX, pointerY, positionX, positionY, parentBounds } = attribute;
        let x = pointerX;
        let y = pointerY;
        if (positionX === 'left') {
            x -= tooltipBoxWidth + offsetX;
        }
        else if (positionX === 'center') {
            x -= tooltipBoxWidth / 2;
        }
        else {
            x += offsetX;
        }
        if (positionY === 'top') {
            y -= tooltipBoxHeight + offsetY;
        }
        else if (positionY === 'middle') {
            y -= tooltipBoxHeight / 2;
        }
        else {
            y += offsetY;
        }
        if (x + tooltipBoxWidth > parentBounds.x2) {
            x -= tooltipBoxWidth + offsetX;
        }
        if (y + tooltipBoxHeight > parentBounds.y2) {
            y -= tooltipBoxHeight + offsetY;
        }
        if (x < parentBounds.x1) {
            x = parentBounds.x1;
        }
        if (y < parentBounds.y1) {
            y = parentBounds.y1;
        }
        attribute.x = x;
        attribute.y = y;
        return attribute;
    }
    static measureTooltip(attribute) {
        const { content, contentStyle } = attribute;
        const padding = normalizePadding(attribute.padding);
        const titleAttr = Tooltip.getTitleAttr(attribute);
        let maxWidth = 0;
        let containerHeight = padding[0] + padding[2];
        let titleMaxHeight = 0;
        const { value: titleValue, shape: titleShape } = titleAttr;
        const { visible: titleHasShape = false, symbolType: titleShapeType = '' } = titleShape !== null && titleShape !== void 0 ? titleShape : {};
        if (isValid(titleValue) && typeof titleAttr.value.text !== 'object') {
            const { width, height } = initTextMeasure(titleValue).quickMeasure(titleValue.text);
            maxWidth = width;
            titleMaxHeight = height;
        }
        if (titleHasShape && builtinSymbolsMap[titleShapeType]) {
            maxWidth += titleShape.size + titleShape.spacing;
            titleMaxHeight = Math.max(titleShape.size, titleMaxHeight);
        }
        if (attribute.title) {
            attribute.title.width = maxWidth;
            attribute.title.height = titleMaxHeight;
        }
        if (isVisible(titleAttr)) {
            containerHeight += titleMaxHeight + titleAttr.spaceRow;
        }
        if (content && content.length) {
            const filteredContent = [];
            content.forEach((item, i) => {
                const itemAttr = Tooltip.getContentAttr(attribute, i);
                if ((item.key || item.value) && isVisible(itemAttr)) {
                    filteredContent.push([item, itemAttr]);
                }
            });
            if (filteredContent.length) {
                let hasContentShape = false;
                const shapeWidths = [];
                const keyWidths = [];
                const valueWidths = [];
                filteredContent.forEach(([item, itemAttr], i) => {
                    var _a;
                    const { key, value, shape, spaceRow } = itemAttr;
                    const itemHasShape = isVisible(shape);
                    const itemShapeType = (_a = shape === null || shape === void 0 ? void 0 : shape.symbolType) !== null && _a !== void 0 ? _a : '';
                    const keyTextMeasure = initTextMeasure(key);
                    const valueTextMeasure = initTextMeasure(value);
                    let itemHeight = 0;
                    if (isVisible(key)) {
                        const { width, height } = keyTextMeasure.quickMeasure(key.text);
                        keyWidths.push(width);
                        itemHeight = Math.max(itemHeight, height);
                    }
                    if (isVisible(value)) {
                        const { width, height } = valueTextMeasure.quickMeasure(value.text);
                        valueWidths.push(width);
                        itemHeight = Math.max(itemHeight, height);
                    }
                    if (itemHasShape && builtinSymbolsMap[itemShapeType]) {
                        hasContentShape = true;
                        shapeWidths.push(shape.size);
                        itemHeight = Math.max(shape.size, itemHeight);
                    }
                    item.height = itemHeight;
                    containerHeight += itemHeight;
                    if (i < filteredContent.length - 1) {
                        containerHeight += spaceRow !== null && spaceRow !== void 0 ? spaceRow : contentStyle.spaceRow;
                    }
                });
                const maxShapeWidth = shapeWidths.length ? Math.max(...shapeWidths) : 0;
                const maxKeyWidth = keyWidths.length ? Math.max(...keyWidths) : 0;
                const maxValueWidth = valueWidths.length ? Math.max(...valueWidths) : 0;
                maxWidth = Math.max(maxKeyWidth +
                    maxValueWidth +
                    contentStyle.key.spacing +
                    contentStyle.value.spacing +
                    (hasContentShape ? maxShapeWidth + contentStyle.shape.spacing : 0), maxWidth);
                content.forEach(item => {
                    item.width = maxWidth;
                });
                attribute.hasContentShape = hasContentShape;
                attribute.keyWidth = maxKeyWidth;
                attribute.valueWidth = maxValueWidth;
            }
        }
        attribute.panel.width = maxWidth + padding[1] + padding[3];
        attribute.panel.height = containerHeight;
        return attribute;
    }
    static getTitleAttr(attribute) {
        return mergeRowAttrs({}, Tooltip.defaultAttributes.titleStyle, Tooltip.defaultAttributes.title, attribute.titleStyle, attribute.title);
    }
    static getContentAttr(attribute, index) {
        return mergeRowAttrs({}, Tooltip.defaultAttributes.contentStyle, attribute.contentStyle, attribute.content[index]);
    }
}
Tooltip.defaultAttributes = defaultAttributes;

function loadTimelineComponent() {
    registerGroup();
    registerText();
    registerSymbol();
    registerLine();
}

loadTimelineComponent();
class Timeline extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, Timeline.defaultAttributes, attributes));
        this.name = 'timeline';
    }
    render() {
        const { width, lineStyle, activeLineStyle, symbolStyle, activeSymbolStyle, labelStyle, activeLabelStyle, times, pointLayoutMode, labelSpace, clipRange, animation } = this.attribute;
        if (!(times && times.length)) {
            return;
        }
        const symbolHeight = (isArray(symbolStyle.size) ? symbolStyle.size[1] : symbolStyle.size) || 0;
        const activeSymbolHeight = (isArray(activeSymbolStyle.size) ? activeSymbolStyle.size[1] : activeSymbolStyle.size) || 0;
        const lineSymbolHeight = Math.max(lineStyle.lineWidth || 0, activeLineStyle.lineWidth || 0, symbolHeight, activeSymbolHeight);
        const lineY = lineSymbolHeight / 2;
        const lineAttr = {
            y: lineY,
            points: [
                { x: 0, y: 0 },
                { x: width, y: 0 }
            ]
        };
        this._line = this.createOrUpdateChild('line-axes', Object.assign(Object.assign({}, lineStyle), lineAttr), 'line');
        this._activeLine = this.createOrUpdateChild('active-line-axes', Object.assign(Object.assign(Object.assign({}, activeLineStyle), lineAttr), { clipRange }), 'line');
        const activeWidth = width * clipRange;
        const symbolGroup = this.createOrUpdateChild('symbol-group', {
            y: lineY
        }, 'group');
        const symbolSpace = times.length === 1
            ? width
            : pointLayoutMode === 'space-between'
                ? width / (times.length - 1)
                : width / times.length;
        const symbolStartX = pointLayoutMode === 'space-between' ? 0 : symbolSpace / 2;
        this._timesPercent = times.map((_, i) => (symbolStartX + symbolSpace * i) / width);
        times.forEach((item, i) => {
            const x = this._timesPercent[i] * width;
            symbolGroup.createOrUpdateChild(item.label, Object.assign(Object.assign({}, symbolStyle), { x }), 'symbol');
        });
        this._symbolGroup = symbolGroup;
        const labelY = lineSymbolHeight + labelSpace;
        const labelGroup = this.createOrUpdateChild('label-group', {
            y: labelY
        }, 'group');
        times.forEach((item, i) => {
            const x = this._timesPercent[i] * width;
            labelGroup.createOrUpdateChild(item.label, Object.assign(Object.assign({}, labelStyle), { x, text: item.label }), 'text');
        });
        this._labelGroup = labelGroup;
        const setActive = (group, activeStyle) => {
            group.forEachChildren((label) => {
                if (label.currentStates) {
                    const currentStates = label.currentStates;
                    label.clearStates();
                    label.useStates(currentStates, false);
                }
                label.states = {
                    active: activeStyle
                };
                if (label.attribute.x <= activeWidth) {
                    label.useStates(['active'], animation);
                }
            });
        };
        setActive(labelGroup, activeLabelStyle);
        setActive(symbolGroup, activeSymbolStyle);
    }
    appearAnimate(animateConfig) {
        const { duration = 1000, easing = 'quadOut' } = animateConfig;
        const { activeLabelStyle, activeSymbolStyle } = this.attribute;
        const percent = duration / 1000;
        const lineDuration = percent * 500;
        const activeLineDuration = percent * 200;
        const perSymbolDuration = percent * 100;
        const perSymbolNormalDuration = percent * 90;
        const symbolDelay = percent * 100;
        const symbolNormalDelay = percent * 600;
        if (this._line) {
            this._line.setAttributes({ clipRange: 0 });
            this._line.animate().to({ clipRange: 1 }, lineDuration, easing);
        }
        if (this._activeLine) {
            this._activeLine.setAttributes({ opacity: 0 });
            this._activeLine
                .animate()
                .wait(500)
                .to({ opacity: 1 }, activeLineDuration, easing);
        }
        if (this._symbolGroup) {
            const size = this._symbolGroup.count - 1;
            const delay = percent * (size === 1 ? 0 : (500 - 100) / (size - 1));
            const delayNormal = percent * (size === 1 ? 0 : (400 - 160) / (size - 1));
            this._symbolGroup.forEachChildren((symbol, i) => {
                const originAttrs = {};
                Object.keys(activeSymbolStyle).forEach(k => {
                    originAttrs[k] = symbol.attribute[k];
                });
                symbol.setAttributes({ opacity: 0 });
                symbol
                    .animate()
                    .wait(symbolDelay + delay * i)
                    .to({ opacity: 1 }, perSymbolDuration, easing);
                symbol
                    .animate()
                    .wait(symbolNormalDelay + delayNormal * i)
                    .to(Object.assign({}, activeSymbolStyle), perSymbolNormalDuration, easing)
                    .to(Object.assign({}, originAttrs), perSymbolNormalDuration, easing);
            });
        }
        if (this._labelGroup) {
            const size = this._labelGroup.count - 1;
            const delay = percent * (size === 1 ? 0 : (500 - 100) / (size - 1));
            const delayNormal = percent * (size === 1 ? 0 : (400 - 160) / (size - 1));
            this._labelGroup.forEachChildren((label, i) => {
                const originAttrs = {};
                Object.keys(activeLabelStyle).forEach(k => {
                    originAttrs[k] = label.attribute[k];
                });
                label.setAttributes({ opacity: 0 });
                label
                    .animate()
                    .wait(symbolDelay + delay * i)
                    .to({ opacity: 1 }, perSymbolDuration, easing);
                label
                    .animate()
                    .wait(symbolNormalDelay + delayNormal * i)
                    .to(Object.assign({ dy: 10 }, activeLabelStyle), perSymbolNormalDuration, easing)
                    .to(Object.assign({ dy: 0 }, originAttrs), perSymbolNormalDuration, easing);
            });
        }
    }
    goto(flag, animateConfig) {
        let { clipRange } = this.attribute;
        const { animation } = this.attribute;
        if (flag > 0) {
            if (clipRange >= 1) {
                return;
            }
            else if (clipRange < 0) {
                clipRange = 0;
            }
        }
        else {
            if (clipRange <= 0) {
                return;
            }
            else if (clipRange > 1) {
                clipRange = 1;
            }
        }
        if (clipRange !== this.attribute.clipRange) {
            this.setAttributes({ clipRange });
        }
        let i = 0;
        for (; i < this._timesPercent.length; i++) {
            if (clipRange < this._timesPercent[i]) {
                break;
            }
        }
        const nextClipRange = flag > 0 ? this._timesPercent[i] || 1 : this._timesPercent[i - 1] || 0;
        if (animation) {
            const { duration = 1000, easing = 'quadOut' } = animateConfig;
            this.animate().to({ clipRange: nextClipRange }, duration, easing);
        }
        else {
            this.setAttributes({ clipRange: nextClipRange });
        }
    }
    forward(animateConfig) {
        this.goto(1, animateConfig);
    }
    backward(animateConfig) {
        this.goto(-1, animateConfig);
    }
}
Timeline.defaultAttributes = {
    labelSpace: 10,
    pointLayoutMode: 'space-around',
    animation: true,
    symbolStyle: {
        fill: 'black',
        size: 12,
        symbolType: 'circle'
    },
    activeSymbolStyle: {
        fill: 'orange',
        size: 16
    },
    lineStyle: {
        lineDash: [2, 2],
        lineCap: 'butt',
        stroke: 'black',
        lineWidth: 2
    },
    activeLineStyle: {
        stroke: 'orange',
        lineWidth: 4
    },
    labelStyle: {
        fontSize: 12,
        fill: 'black',
        textAlign: 'center',
        textBaseline: 'top'
    },
    activeLabelStyle: {
        fontSize: 14,
        fill: 'orange'
    },
    clipRange: 0
};

function VTag(params) {
    return new Tag(params ? params.attribute : {});
}

function loadCheckBoxComponent() {
    registerGroup();
    registerRect();
    registerText();
    registerImage();
}

const checkSvg = '<svg width="200" height="200" viewBox="0 0 1024 1024" fill="#fff" xmlns="http://www.w3.org/2000/svg"><path d="M877.44815445 206.10060629a64.72691371 64.72691371 0 0 0-95.14856334 4.01306852L380.73381888 685.46812814 235.22771741 533.48933518a64.72691371 64.72691371 0 0 0-92.43003222-1.03563036l-45.82665557 45.82665443a64.72691371 64.72691371 0 0 0-0.90617629 90.61767965l239.61903446 250.10479331a64.72691371 64.72691371 0 0 0 71.19960405 15.14609778 64.33855261 64.33855261 0 0 0 35.08198741-21.23042702l36.24707186-42.71976334 40.5190474-40.77795556-3.36579926-3.49525333 411.40426297-486.74638962a64.72691371 64.72691371 0 0 0-3.88361443-87.64024149l-45.3088404-45.43829334z"></path></svg>';
const indeterminateSvg = '<svg width="200" height="200" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="none"><path stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width="5" d="M5 12h14"/></svg>';
loadCheckBoxComponent();
class CheckBox extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, CheckBox.defaultAttributes, attributes));
        this._handlePointerUp = () => {
            if (this.attribute.disabled) {
                return;
            }
            else if (this.attribute.checked) {
                this.setAttribute('checked', false);
                this.setAttribute('indeterminate', false);
            }
            else {
                this.setAttribute('checked', true);
                this.setAttribute('indeterminate', false);
            }
            this._dispatchEvent('checkbox_state_change', {
                eventType: 'checkbox_state_change',
                checked: this.attribute.checked
            });
            this.stage.renderNextFrame();
        };
        this.renderGroup();
        this.onBeforeAttributeUpdate = (val, attributes, key) => {
            if ('interactive' in val) {
                this.setAttribute('pickable', val.interactive);
            }
            if ('disabled' in val) {
                this.setAttribute('cursor', val.disable ? this.attribute.disableCursor : this.attribute.cursor);
            }
            return undefined;
        };
        this.addEventListener('pointerup', this._handlePointerUp);
    }
    render() {
        this.removeAllChild(true);
        this.renderBox();
        this.renderIcon();
        this.renderText();
        this.layout();
    }
    renderBox() {
        this._box = new Rect(merge({}, this.attribute.box));
        const isCheckedOrIndeterminate = this.attribute.checked || this.attribute.indeterminate;
        if (isCheckedOrIndeterminate && this.attribute.disabled) {
            this._box.setAttributes({
                fill: this.attribute.box.disableCheckedFill,
                stroke: this.attribute.box.disableCheckedStroke
            });
        }
        else if (isCheckedOrIndeterminate) {
            this._box.setAttributes({
                fill: this.attribute.box.checkedFill,
                stroke: this.attribute.box.checkedStroke
            });
        }
        else if (this.attribute.disabled) {
            this._box.setAttributes({
                fill: this.attribute.box.disableFill
            });
        }
        this.appendChild(this._box);
    }
    renderIcon() {
        this._checkIcon = new Image(merge({ image: this.attribute.icon.checkIconImage }, this.attribute.icon));
        this.appendChild(this._checkIcon);
        this._indeterminateIcon = new Image(merge({
            image: this.attribute.icon.indeterminateIconImage
        }, this.attribute.icon));
        this.appendChild(this._indeterminateIcon);
        if (this.attribute.checked) {
            this._checkIcon.setAttribute('visible', true);
            this._indeterminateIcon.setAttribute('visible', false);
        }
        else if (this.attribute.indeterminate) {
            this._checkIcon.setAttribute('visible', false);
            this._indeterminateIcon.setAttribute('visible', true);
        }
        else {
            this._checkIcon.setAttribute('visible', false);
            this._indeterminateIcon.setAttribute('visible', false);
        }
    }
    renderText() {
        this._text = new Text(merge({ wrap: true }, this.attribute.text));
        if (this.attribute.disabled) {
            this._text.setAttribute('fill', this.attribute.text.disableFill);
        }
        this.appendChild(this._text);
    }
    renderGroup() {
        if (!this.attribute.interactive) {
            this.setAttribute('pickable', false);
        }
        if (this.attribute.disabled) {
            this.setAttribute('cursor', this.attribute.disableCursor);
        }
    }
    layout() {
        const boxHeight = this.attribute.box.height;
        const iconHeight = this.attribute.icon.height;
        const textHeight = this._text.AABBBounds.height();
        const maxHeight = Math.max(boxHeight, iconHeight, textHeight);
        const boxY = maxHeight / 2 - boxHeight / 2;
        const iconY = maxHeight / 2 - iconHeight / 2;
        const textY = maxHeight / 2 - textHeight / 2;
        const boxWidth = this.attribute.box.width;
        const iconWidth = this.attribute.icon.width;
        const maxWidth = Math.max(boxWidth, iconWidth);
        const boxX = maxWidth / 2 - boxWidth / 2;
        const iconX = maxWidth / 2 - iconWidth / 2;
        const textX = maxWidth + this.attribute.spaceBetweenTextAndIcon;
        this._box.setAttributes({
            x: boxX,
            y: boxY
        });
        this._checkIcon.setAttributes({
            x: iconX,
            y: iconY
        });
        this._indeterminateIcon.setAttributes({
            x: iconX,
            y: iconY
        });
        this._text.setAttributes({
            x: textX,
            y: textY
        });
    }
    initAttributes(params, options) {
        params = (options === null || options === void 0 ? void 0 : options.skipDefault) ? params : merge({}, CheckBox.defaultAttributes, params);
        super.initAttributes(params);
        this.renderGroup();
        this.render();
    }
}
CheckBox.defaultAttributes = {
    interactive: true,
    disabled: false,
    checked: false,
    indeterminate: false,
    cursor: 'pointer',
    disableCursor: 'not-allowed',
    spaceBetweenTextAndIcon: 8,
    text: {
        text: 'text',
        fontSize: 14,
        fill: '#000',
        disableFill: 'rgb(201,205,212)',
        textBaseline: 'top',
        pickable: false
    },
    icon: {
        checkIconImage: checkSvg,
        indeterminateIconImage: indeterminateSvg,
        width: 10,
        height: 10,
        pickable: false
    },
    box: {
        width: 14,
        height: 14,
        cornerRadius: 2,
        fill: '#fff',
        stroke: 'rgb(229,230,235)',
        disableFill: 'rgb(242,243,245)',
        checkedFill: 'rgb(22, 93, 255)',
        checkedStroke: 'rgb(22, 93, 255)',
        disableCheckedFill: 'rgb(148, 191, 255)',
        disableCheckedStroke: 'rgb(148, 191, 255)',
        pickable: false
    }
};

function loadRadioComponent() {
    registerGroup();
    registerRect();
    registerWrapText();
    registerImage();
}

loadRadioComponent();
class Radio extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, Radio.defaultAttributes, attributes));
        this._handlePointerUp = () => {
            if (this.attribute.disabled || this.attribute.checked) {
                return;
            }
            this.setAttribute('checked', true);
            this._dispatchEvent('radio_checked', {
                eventType: 'radio_checked',
                target: this
            });
            this.stage.renderNextFrame();
        };
        this.renderGroup();
        this.onBeforeAttributeUpdate = (val, attributes, key) => {
            if ('interactive' in val) {
                this.setAttribute('pickable', val.interactive);
            }
            if ('disabled' in val) {
                this.setAttribute('cursor', val.disable ? this.attribute.disableCursor : this.attribute.cursor);
            }
            return undefined;
        };
        this.addEventListener('pointerup', this._handlePointerUp);
    }
    render() {
        this.removeAllChild(true);
        this.renderCircle();
        this.renderText();
        this.layout();
    }
    renderCircle() {
        this._circle = new Arc(merge({}, this.attribute.circle));
        const isChecked = this.attribute.checked;
        if (isChecked && this.attribute.disabled) {
            this._circle.setAttributes({
                fill: this.attribute.circle.disableCheckedFill,
                stroke: this.attribute.circle.disableCheckedStroke
            });
        }
        else if (isChecked) {
            this._circle.setAttributes({
                fill: this.attribute.circle.checkedFill,
                stroke: this.attribute.circle.checkedStroke
            });
        }
        else if (this.attribute.disabled) {
            this._circle.setAttributes({
                fill: this.attribute.circle.disableFill
            });
        }
        this.appendChild(this._circle);
    }
    renderText() {
        this._text = new Text(merge({}, this.attribute.text));
        if (this.attribute.disabled) {
            this._text.setAttribute('fill', this.attribute.text.disableFill);
        }
        this.appendChild(this._text);
    }
    renderGroup() {
        if (!this.attribute.interactive) {
            this.setAttribute('pickable', false);
        }
        if (this.attribute.disabled) {
            this.setAttribute('cursor', this.attribute.disableCursor);
        }
    }
    layout() {
        const circleHeight = (this.attribute.circle.outerRadius + this.attribute.circle.lineWidth) * 2;
        const textHeight = this._text.AABBBounds.height();
        const maxHeight = Math.max(circleHeight, textHeight);
        const circleY = maxHeight / 2 - circleHeight / 2 + this.attribute.circle.outerRadius + this.attribute.circle.lineWidth;
        const textY = maxHeight / 2 - textHeight / 2;
        const circleWidth = (this.attribute.circle.outerRadius + this.attribute.circle.lineWidth) * 2;
        const circleX = this.attribute.circle.outerRadius + this.attribute.circle.lineWidth;
        const textX = circleWidth + this.attribute.spaceBetweenTextAndIcon;
        this._circle.setAttributes({
            x: circleX,
            y: circleY
        });
        this._text.setAttributes({
            x: textX,
            y: textY
        });
    }
    initAttributes(params, options) {
        params = (options === null || options === void 0 ? void 0 : options.skipDefault) ? params : merge({}, Radio.defaultAttributes, params);
        super.initAttributes(params);
        this.renderGroup();
        this.render();
    }
}
Radio.defaultAttributes = {
    interactive: true,
    disabled: false,
    checked: false,
    cursor: 'pointer',
    disableCursor: 'not-allowed',
    spaceBetweenTextAndIcon: 8,
    text: {
        text: 'text',
        fontSize: 14,
        fill: '#000',
        disableFill: 'rgb(201,205,212)',
        textBaseline: 'top',
        pickable: false
    },
    circle: {
        outerRadius: 7,
        innerRadius: 3,
        startAngle: 0,
        endAngle: 2 * Math.PI,
        lineWidth: 1,
        fill: '#fff',
        stroke: 'rgb(229,230,235)',
        disableFill: 'rgb(242,243,245)',
        checkedFill: 'rgb(22, 93, 255)',
        checkedStroke: 'rgb(22, 93, 255)',
        disableCheckedFill: 'rgb(148, 191, 255)',
        disableCheckedStroke: 'rgb(148, 191, 255)',
        pickable: false
    }
};

function loadEmptyTipComponent() {
    registerGroup();
    registerText();
    registerImage();
}

const emptyTipSvg = '<svg t="1716726614852" class="icon" viewBox="0 0 1194 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2621" width="200" height="200"><path d="M1038.694079 367.237067c13.265507 23.342857-16.633865-40.004445-63.05621-40.004446H219.018794c-26.558738 0-46.46393 13.334815-63.05621 40.004446S0.006238 607.277601 0.006238 650.608819V940.647979a82.351494 82.351494 0 0 0 82.961402 83.349526H1111.702885a82.337632 82.337632 0 0 0 82.975264-83.349526V650.608819c0-43.331218-155.970208-283.371753-155.970208-283.371752zM730.066575 667.284269a136.328386 136.328386 0 0 1-132.738243 133.33429 133.417459 133.417459 0 0 1-132.738243-133.33429v-6.681269a40.6698 40.6698 0 0 0-36.497473-26.66963H73.015044l119.458874-220.02445s23.231965-40.004445 53.103614-40.004446h713.481918c26.544876 0 29.871649 10.008042 46.436207 40.004446L1128.33675 633.947231H769.904682c-26.184476 0-39.838107 7.623855-39.838107 33.337038zM338.505391 210.559919l-89.601086-86.69016a22.178487 22.178487 0 0 1 0-33.26773 21.984425 21.984425 0 0 1 33.170699 0l89.601087 86.676299a22.317102 22.317102 0 0 1 0 33.26773 24.950798 24.950798 0 0 1-33.1707 0z m252.197118-40.059891a25.532983 25.532983 0 0 1-6.639685-16.633865l-3.326773-126.694606A28.263709 28.263709 0 0 1 603.995739 0.515788c13.251646-3.326773 23.204242 10.021904 26.544877 23.342858V153.866163a28.249847 28.249847 0 0 1-23.259688 26.66963c-6.611961-3.312911-13.279369-3.312911-16.578419-10.035765z m235.646421 33.337038a22.372548 22.372548 0 0 1 0-33.337038l86.288175-90.030795a22.039871 22.039871 0 0 1 33.170699 0 22.289379 22.289379 0 0 1 0 33.364761l-82.961401 90.003072a25.962691 25.962691 0 0 1-36.483611 0z" fill="#8a8a8a" p-id="2622"></path></svg>';
loadEmptyTipComponent();
class EmptyTip extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, EmptyTip.defaultAttributes, attributes));
    }
    render() {
        this.removeAllChild(true);
        this.renderIcon();
        this.renderText();
        this.layout();
    }
    renderIcon() {
        this._emptyTipIcon = new Image(merge({ image: this.attribute.icon.image }, this.attribute.icon));
        this.appendChild(this._emptyTipIcon);
    }
    renderText() {
        this._text = new Text(merge({ wrap: true }, this.attribute.text));
        this.appendChild(this._text);
    }
    layout() {
        const iconHeight = this.attribute.icon.height;
        const textHeight = this._text.AABBBounds.height();
        const iconWidth = this.attribute.icon.width;
        const { width, height, spaceBetweenTextAndIcon } = this.attribute;
        this._emptyTipIcon.setAttribute('x', width / 2 - iconWidth / 2);
        this._emptyTipIcon.setAttribute('y', height / 2 - iconHeight / 2 - textHeight / 2 - spaceBetweenTextAndIcon / 2);
        this._text.setAttribute('x', width / 2);
        this._text.setAttribute('textAlign', 'center');
        this._text.setAttribute('y', height / 2 + iconHeight / 2 + spaceBetweenTextAndIcon / 2);
        this._text.setAttribute('textBaseline', 'middle');
    }
}
EmptyTip.defaultAttributes = {
    spaceBetweenTextAndIcon: 20,
    text: {
        text: 'no data',
        fontSize: 14,
        fill: '#000',
        disableFill: 'rgb(201,205,212)',
        pickable: false
    },
    icon: {
        image: emptyTipSvg,
        width: 100,
        height: 100,
        pickable: false
    }
};

function random() {
    return Math.random();
}
function createUniformRandom(count) {
    const result = [];
    const step = 1 / count;
    for (let i = 0; i < count; i++) {
        result.push(((random() - 0.5) * step) / 2 + step * i);
    }
    result.sort(() => Math.random() - 0.5);
    let idx = 0;
    return function (i) {
        if (idx > count - 1) {
            idx = 0;
        }
        if (i === void 0) {
            i = idx;
            idx++;
        }
        return result[i];
    };
}
class WeatherBox extends AbstractComponent {
    constructor(attributes, options) {
        var _a;
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, WeatherBox.defaultAttributes, attributes));
        this.name = 'weatherBox';
        this.timeline = (_a = options === null || options === void 0 ? void 0 : options.timeline) !== null && _a !== void 0 ? _a : new DefaultTimeline();
    }
    render() {
        const { rainRatio, rainIconPath, snowRatio, snowIconPath, rainCountThreshold, snowCountThreshold, windRatio, rainSizeRange, snowSizeRange, rainSpeed, snowSpeed, width, height, windIconPath, windSize, windSpeed } = this.attribute;
        this.attribute.clip = true;
        const windAngle = (-windRatio * Math.PI) / 4;
        const rainGroup = this.createOrUpdateChild('rain-container', { zIndex: 1, width, height }, 'group');
        if (rainRatio > 0) {
            this.generateRainOrSnow('rain', rainRatio, rainCountThreshold, windRatio, rainGroup, rainIconPath, windAngle, rainSizeRange, rainSpeed);
        }
        const snowGroup = this.createOrUpdateChild('snow-container', { zIndex: 1, width, height }, 'group');
        if (snowRatio > 0) {
            this.generateRainOrSnow('snow', snowRatio, snowCountThreshold, windRatio, snowGroup, snowIconPath, windAngle, snowSizeRange, snowSpeed);
        }
        const windGroup = this.createOrUpdateChild('wind-container', { zIndex: 0, width, height }, 'group');
        if (windRatio > 0) {
            this.generateWind(windRatio, windIconPath, windGroup, windSize, windSpeed);
        }
    }
    generateWind(windRatio, windIconPath, group, size, speed) {
        const { width, height } = group.attribute;
        const { windAnimateEffect, windStyle = {} } = this.attribute;
        let fromAttribute = { opacity: 0, clipRange: 1 };
        let toAttribute = { opacity: 1, clipRange: 1 };
        if (windAnimateEffect === 'clipRange') {
            fromAttribute = { clipRange: 0, opacity: 1 };
            toAttribute = { clipRange: 1, opacity: 1 };
        }
        const wind = group.createOrUpdateChild(`wind`, Object.assign(Object.assign({ x: (width - size) / 2, y: (height - size) / 2, symbolType: windIconPath, size, stroke: 'white', lineWidth: 2, dx: -size / 2, dy: -size / 2 }, windStyle), fromAttribute), 'symbol');
        const duration = (speed / 4) * 1000;
        new Animate(void 0, this.timeline)
            .bind(wind)
            .to(fromAttribute, duration, 'linear')
            .to(toAttribute, duration, 'linear')
            .wait(duration / 2)
            .loop(Infinity);
    }
    generateRainOrSnow(type, ratio, threshold, windRatio, group, path, windAngle, sizeRange, speed) {
        let { width } = group.attribute;
        const { height } = group.attribute;
        const { snowRainBottomPadding, rainStyle = {}, snowStyle = {} } = this.attribute;
        let maxCount = Math.round(ratio * threshold);
        if (windRatio > 0) {
            maxCount = maxCount * Math.round(1 + windRatio);
        }
        width = width * Math.round(1 + windRatio);
        const uniformRandomX = createUniformRandom(maxCount);
        const uniformRandomY = createUniformRandom(maxCount);
        for (let i = 0; i < maxCount; i++) {
            const x = uniformRandomX();
            const y = uniformRandomY();
            const size = sizeRange[0] + random() * (sizeRange[1] - sizeRange[0]);
            const deltaX = windAngle ? height * Math.tan(Math.abs(windAngle)) : 0;
            const startX = x * width - deltaX;
            const startY = -y * height;
            const particle = group.createOrUpdateChild(`${type}-${i}`, Object.assign({ x: startX, y: startY, symbolType: path, size, fill: 'white', angle: windAngle }, (type === 'rain' ? rainStyle : snowStyle)), 'symbol');
            const duration = (1 / speed / 2) * (1 + y) * 1000;
            let endX = x * width;
            if (type === 'rain' && windAngle) {
                endX = startX + (1 + y) * height * Math.tan(Math.abs(windAngle));
            }
            new Animate(void 0, this.timeline)
                .bind(particle)
                .to({ x: endX, y: height - snowRainBottomPadding }, duration, 'linear')
                .loop(Infinity);
            new Animate(void 0, this.timeline).bind(particle).to({ opacity: 0 }, duration, 'quintIn').loop(Infinity);
        }
    }
}
WeatherBox.defaultAttributes = {
    snowIconPath: 'M512 64c24.7 0 44.8 20.1 44.8 44.8v43.1l29.3-15.5c21.9-11.6 49-3.2 60.5 18.7s3.2 49-18.7 60.5l-71.2 37.6v85.2c32 8.2 60.6 25.1 83.1 48l73.8-42.6-3-80.4c-0.9-24.7 18.4-45.5 43.1-46.4 24.7-0.9 45.5 18.4 46.4 43.1l1.2 33.1 37.3-21.5c21.4-12.4 48.8-5 61.2 16.4 12.4 21.4 5 48.8-16.4 61.2l-37.3 21.5 28.1 17.6c21 13.2 27.3 40.8 14.1 61.8-13.2 20.9-40.8 27.3-61.8 14.1l-68.2-42.8-73.6 42.5c4.2 15.3 6.5 31.4 6.5 48s-2.3 32.7-6.5 48l73.8 42.6 68.2-42.8c20.9-13.2 48.6-6.8 61.8 14.1 13.2 21 6.8 48.6-14.1 61.8l-28.1 17.6 37.3 21.5c21.4 12.4 28.8 39.8 16.4 61.2-12.4 21.4-39.8 28.8-61.2 16.4l-37.3-21.5-1.2 33.1c-0.9 24.7-21.7 44-46.4 43.1-24.7-0.9-44-21.7-43.1-46.4l3-80.4-73.8-42.6c-22.5 22.9-51 39.8-83.1 48v85.2l71.2 37.6c21.9 11.6 30.2 38.7 18.7 60.5-11.6 21.9-38.7 30.2-60.5 18.7L557 872.2v43.1c0 24.7-20.1 44.8-44.8 44.8-24.7 0-44.8-20.1-44.8-44.8v-43.1l-29.3 15.5c-21.9 11.6-49 3.2-60.5-18.7-11.6-21.9-3.2-49 18.7-60.5l71.2-37.6v-85.2c-32-8.2-60.6-25.1-83.1-48l-73.8 42.6 3 80.4c0.9 24.7-18.4 45.5-43.1 46.4-24.7 0.9-45.5-18.4-46.4-43.1l-1.2-33.1-37.3 21.5c-21.4 12.4-48.8 5-61.2-16.4s-5-48.8 16.4-61.2l37.3-21.5-28.1-17.6c-21-13.2-27.3-40.8-14.1-61.8 13.2-20.9 40.8-27.3 61.8-14.1l68.2 42.8 73.8-42.6c-4.2-15.3-6.5-31.4-6.5-48s2.3-32.7 6.5-48l-73.8-42.6-68.2 42.8c-21 13.2-48.6 6.8-61.8-14.1-13.2-21-6.8-48.6 14.1-61.8l28.1-17.6-37.3-21.5C119 336.8 111.7 309.4 124 288c12.4-21.4 39.8-28.8 61.2-16.4l37.3 21.5 1.2-33.1c0.9-24.7 21.7-44 46.4-43.1 24.7 0.9 44 21.7 43.1 46.4l-3 80.4 73.8 42.6c22.5-22.9 51-39.8 83.1-48v-85.2L396 215.6c-21.9-11.6-30.2-38.7-18.7-60.5 11.6-21.9 38.7-30.2 60.5-18.7l29.3 15.5v-43.1C467.2 84.1 487.3 64 512 64z m0 537.6c49.5 0 89.6-40.1 89.6-89.6s-40.1-89.6-89.6-89.6-89.6 40.1-89.6 89.6 40.1 89.6 89.6 89.6z',
    rainIconPath: 'M802.94208 583.04c19.328 38.016 29.056 78.336 29.056 120.96a313.216 313.216 0 0 1-44.032 161.536 324.48 324.48 0 0 1-114.56 114.944c-23.552 13.696-49.024 24.32-76.416 32-27.264 7.68-55.68 11.52-84.992 11.52-29.44 0-57.6-3.84-84.992-11.52a331.136 331.136 0 0 1-76.544-32 337.536 337.536 0 0 1-65.024-49.92 337.536 337.536 0 0 1-49.92-65.024 331.136 331.136 0 0 1-32-76.544A313.216 313.216 0 0 1 191.99808 704c0-42.24 9.344-82.56 28.032-120.448L509.43808 0l293.504 583.04z',
    windIconPath: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M 4.0003 14.0002 L 12.0003 14.0008 M 12.0003 14.0008 C 13.1049 14.0009 14.0003 14.8964 14.0002 16.001 C 14.0001 17.1055 13.1046 18.0009 12 18.0008 L 10.5 18.0007" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M 7 10.0002 L 14.5 10.0008 C 15.6046 10.0009 16.5001 9.1055 16.5002 8.001 C 16.5003 6.8964 15.6049 6.0009 14.5003 6.0008 L 13.0003 6.0007" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>`,
    windRatio: 0,
    rainRatio: 0,
    snowRatio: 0,
    rainCountThreshold: 10,
    snowCountThreshold: 10,
    rainSizeRange: [5, 10],
    snowSizeRange: [5, 13],
    windSize: 30,
    rainSpeed: 1,
    snowSpeed: 0.5,
    windSpeed: 1,
    windAnimateEffect: 'fade',
    rainStyle: {},
    snowStyle: {},
    windStyle: {
        opacity: 0.8
    },
    snowRainBottomPadding: 0
};

function loadSwitchComponent() {
    registerGroup();
    registerRect();
    registerText();
    registerCircle();
}

loadSwitchComponent();
class Switch extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, Switch.defaultAttributes, attributes));
        this._handlePointerUp = () => {
            if (this.attribute.disabled) {
                return;
            }
            else if (this.attribute.checked) {
                this.setAttribute('checked', false);
            }
            else {
                this.setAttribute('checked', true);
            }
            this._dispatchEvent('switch_state_change', {
                eventType: 'switch_state_change',
                checked: this.attribute.checked
            });
            this.stage.renderNextFrame();
        };
        this.renderGroup();
        this.onBeforeAttributeUpdate = (val, attributes, key) => {
            if ('interactive' in val) {
                this.setAttribute('pickable', val.interactive);
            }
            if ('disabled' in val) {
                this.setAttribute('cursor', val.disable ? this.attribute.disableCursor : this.attribute.cursor);
            }
            return undefined;
        };
        this.addEventListener('pointerup', this._handlePointerUp);
    }
    render() {
        this.removeAllChild(true);
        this.renderBox();
        this.renderCircle();
        this.renderText();
        this.layout();
    }
    renderBox() {
        this._box = new Rect(merge({}, this.attribute.box));
        if (this.attribute.disabled && this.attribute.checked) {
            this._box.setAttributes({
                fill: this.attribute.box.disableCheckedFill
            });
        }
        else if (this.attribute.disabled && !this.attribute.checked) {
            this._box.setAttributes({
                fill: this.attribute.box.disableUncheckedFill
            });
        }
        else if (this.attribute.checked) {
            this._box.setAttributes({
                fill: this.attribute.box.checkedFill
            });
        }
        else {
            this._box.setAttributes({
                fill: this.attribute.box.uncheckedFill
            });
        }
        this.appendChild(this._box);
    }
    renderCircle() {
        this._circle = new Circle(merge({}, this.attribute.circle));
        this.appendChild(this._circle);
    }
    renderText() {
        var _a, _b, _c;
        this._text = new Text(merge({}, (_a = this.attribute.text) !== null && _a !== void 0 ? _a : {}));
        if (this.attribute.checked && ((_b = this.attribute.text) === null || _b === void 0 ? void 0 : _b.checkedText)) {
            this._text.setAttributes({
                text: this.attribute.text.checkedText
            });
        }
        else if ((_c = this.attribute.text) === null || _c === void 0 ? void 0 : _c.uncheckedText) {
            this._text.setAttributes({
                text: this.attribute.text.uncheckedText
            });
        }
        this.appendChild(this._text);
    }
    renderGroup() {
        if (!this.attribute.interactive) {
            this.setAttribute('pickable', false);
        }
        if (this.attribute.disabled) {
            this.setAttribute('cursor', this.attribute.disableCursor);
        }
    }
    layout() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const space = this.attribute.spaceBetweenTextAndCircle;
        const radius = this.attribute.circle.radius;
        const boxHeight = this.attribute.box.height;
        const circleHeight = radius * 2;
        const textHeight = this._text.AABBBounds.height();
        const maxHeight = Math.max(boxHeight, circleHeight, textHeight);
        const circleY = maxHeight / 2 - circleHeight / 2 + radius;
        const textY = maxHeight / 2 - textHeight / 2;
        const boxWidth = this.attribute.box.width;
        const circleWidth = radius * 2;
        const textWidth = measureTextSize(((_c = (_b = (_a = this.attribute.text) === null || _a === void 0 ? void 0 : _a.checkedText) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > ((_f = (_e = (_d = this.attribute.text) === null || _d === void 0 ? void 0 : _d.uncheckedText) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0)
            ? (_h = (_g = this.attribute.text) === null || _g === void 0 ? void 0 : _g.checkedText) !== null && _h !== void 0 ? _h : ''
            : (_k = (_j = this.attribute.text) === null || _j === void 0 ? void 0 : _j.uncheckedText) !== null && _k !== void 0 ? _k : '', this._text.attribute).width;
        const maxWidth = Math.max(boxWidth, circleWidth + textWidth + space * 3);
        const circleX = boxHeight / 2 - circleWidth / 2 + radius;
        const textX = circleX + radius + space;
        this._box.setAttributes({
            width: maxWidth,
            height: maxHeight
        });
        this._circle.setAttributes({
            y: circleY,
            x: !this.attribute.checked ? circleX : maxWidth - circleX
        });
        this._text.setAttributes({
            x: !this.attribute.checked ? textX : maxWidth - textX - textWidth,
            y: textY
        });
    }
    initAttributes(params, options) {
        params = (options === null || options === void 0 ? void 0 : options.skipDefault) ? params : merge({}, Switch.defaultAttributes, params);
        super.initAttributes(params);
        this.renderGroup();
        this.render();
    }
}
Switch.defaultAttributes = {
    interactive: true,
    disabled: false,
    checked: false,
    cursor: 'pointer',
    disableCursor: 'not-allowed',
    circle: {
        radius: 8,
        fill: '#FFF',
        pickable: false
    },
    box: {
        width: 40,
        height: 24,
        cornerRadius: 12,
        uncheckedFill: 'rgb(201,205,212)',
        checkedFill: '#165DFF',
        disableUncheckedFill: 'rgb(242,243,245)',
        disableCheckedFill: 'rgb(148,191,255)',
        pickable: false
    },
    text: {
        textAlign: 'left',
        textBaseline: 'top',
        pickable: false
    },
    spaceBetweenTextAndCircle: 6
};

class StoryLabelItem extends AbstractComponent {
    constructor(attributes, options) {
        super((options === null || options === void 0 ? void 0 : options.skipDefault) ? attributes : merge({}, StoryLabelItem.defaultAttributes, attributes));
    }
    render() {
        const { contentOffsetX, contentOffsetY, lineStyle, symbolStartStyle, symbolEndStyle, symbolStartOuterStyle, titleTop: titleTopText, titleBottom: titleBottomText, titleTopStyle, titleBottomStyle, titleSpace, titleTopPanelStyle, titleBottomPanelStyle, theme } = this.attribute;
        const group = this.createOrUpdateChild('label-item-container', { x: 0, y: 0, zIndex: 1 }, 'group');
        const symbolStart = group.createOrUpdateChild('label-item-symbol-start', Object.assign({ x: 0, y: 0 }, symbolStartStyle), 'symbol');
        const symbolEnd = group.createOrUpdateChild('label-item-symbol-end', Object.assign({ x: contentOffsetX, y: contentOffsetY }, symbolEndStyle), 'symbol');
        const symbolStartOut = group.createOrUpdateChild('label-item-symbol-start-out', Object.assign({ x: 0, y: 0 }, symbolStartOuterStyle), 'symbol');
        const spaceW = titleSpace[0];
        const spaceH = titleSpace[1];
        const titleTopGroup = group.createOrUpdateChild('label-item-title-top-group', { x: contentOffsetX, y: contentOffsetY, clip: true }, 'group');
        const titleTop = titleTopGroup.createOrUpdateChild('label-item-title-top', Object.assign(Object.assign({ x: spaceW, y: -spaceH, text: titleTopText }, titleTopStyle), { textBaseline: 'bottom', textAlign: 'left', zIndex: 10 }), 'text');
        const titleTopBounds = titleTop.AABBBounds;
        if (contentOffsetX > 0) {
            titleTopGroup.setAttributes({ x: contentOffsetX - titleTopBounds.width() - spaceW * 2 });
        }
        titleTopGroup.setAttributes({
            width: titleTopBounds.width() + spaceW * 2,
            height: -titleTopBounds.height() - spaceH * 2
        });
        const titleTopPanel = titleTopGroup.createOrUpdateChild('label-item-title-top-panel', Object.assign(Object.assign({}, titleTopPanelStyle), { x: titleTopPanelStyle.padding.left, y: (titleTopGroup.attribute.height > 0 ? 0 : titleTopGroup.attribute.height) + titleTopPanelStyle.padding.top, width: titleTopGroup.attribute.width - titleTopPanelStyle.padding.left - titleTopPanelStyle.padding.right, height: (titleTopGroup.attribute.height > 0 ? 1 : -1) * titleTopGroup.attribute.height -
                titleTopPanelStyle.padding.bottom -
                titleTopPanelStyle.padding.top, scaleCenter: [titleTopGroup.attribute.width / 2, titleTopGroup.attribute.height / 2] }), 'rect');
        this._titleTopPanel = titleTopPanel;
        const titleBottomGroup = group.createOrUpdateChild('label-item-title-bottom-group', { x: contentOffsetX, y: contentOffsetY, clip: true }, 'group');
        const titleBottom = titleBottomGroup.createOrUpdateChild('label-item-title-bottom', Object.assign(Object.assign({ x: spaceW, y: spaceH, text: titleBottomText }, titleBottomStyle), { textBaseline: 'top', textAlign: 'left', zIndex: 10 }), 'text');
        const titleBottomBounds = titleBottom.AABBBounds;
        if (contentOffsetX > 0) {
            titleBottomGroup.setAttributes({ x: contentOffsetX - titleBottomBounds.width() - spaceW * 2 });
        }
        titleBottomGroup.setAttributes({
            width: titleBottomBounds.width() + spaceW * 2,
            height: titleTopBounds.height() + spaceH * 2
        });
        const titleBottomPanel = titleBottomGroup.createOrUpdateChild('label-item-title-bottom-panel', Object.assign(Object.assign({}, titleBottomPanelStyle), { x: titleBottomPanelStyle.padding.left, y: (titleBottomGroup.attribute.height > 0 ? 0 : titleBottomGroup.attribute.height) +
                titleBottomPanelStyle.padding.top, width: titleBottomGroup.attribute.width - titleBottomPanelStyle.padding.left - titleBottomPanelStyle.padding.right, height: (titleBottomGroup.attribute.height > 0 ? 1 : -1) * titleBottomGroup.attribute.height -
                titleBottomPanelStyle.padding.bottom -
                titleBottomPanelStyle.padding.top, scaleCenter: [titleBottomGroup.attribute.width / 2, titleBottomGroup.attribute.height / 2] }), 'rect');
        this._titleBottomPanel = titleBottomPanel;
        const maxTextWidth = Math.max(titleTop.AABBBounds.width(), titleBottom.AABBBounds.width()) + spaceW * 2;
        const points = [
            { x: 0, y: 0 },
            contentOffsetX > 0
                ? { x: contentOffsetX - maxTextWidth, y: contentOffsetY }
                : { x: contentOffsetX + maxTextWidth, y: contentOffsetY },
            { x: contentOffsetX, y: contentOffsetY }
        ];
        if (theme === 'simple') {
            points.pop();
            const p = points[1];
            symbolEnd.setAttributes(p);
        }
        const line = group.createOrUpdateChild('label-item-line', Object.assign(Object.assign({ x: 0, y: 0 }, lineStyle), { points }), 'line');
        this._symbolEnd = symbolEnd;
        this._symbolStart = symbolStart;
        this._symbolStartOuter = symbolStartOut;
        this._titleTop = titleTop;
        this._titleBottom = titleBottom;
        this._line = line;
    }
}
StoryLabelItem.defaultAttributes = {
    contentOffsetX: 100,
    contentOffsetY: -60,
    titleTopStyle: {
        fontSize: 12,
        fill: 'white'
    },
    titleBottomStyle: {
        fontSize: 12,
        fill: 'white'
    },
    lineStyle: {
        stroke: 'white',
        lineWidth: 1
    },
    symbolStartStyle: {
        symbolType: 'circle',
        size: 3,
        fill: 'white'
    },
    symbolEndStyle: {
        symbolType: 'circle',
        size: 3,
        fill: 'white'
    },
    symbolStartOuterStyle: {
        symbolType: 'M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0',
        size: 8,
        stroke: 'white'
    },
    titleSpace: [2, 2],
    titleTopPanelStyle: {
        visible: false,
        padding: { left: 0, right: 0, bottom: 2, top: 2 },
        cornerRadius: 3
    },
    titleBottomPanelStyle: {
        visible: false,
        padding: { left: 0, right: 0, bottom: 2, top: 2 },
        cornerRadius: 3
    },
    theme: 'default'
};

const version = "1.0.13";

export { AXIS_ELEMENT_NAME, AbstractComponent, ArcInfo, ArcLabel, ArcSegment, AxisStateValue, BasePlayer, Brush, CheckBox, CircleAxis, CircleAxisGrid, CircleCrosshair, ColorContinuousLegend, ContinuousPlayer, DEFAULT_ITEM_SPACE_COL, DEFAULT_ITEM_SPACE_ROW, DEFAULT_LABEL_SPACE, DEFAULT_PAGER_SPACE, DEFAULT_SHAPE_SIZE, DEFAULT_SHAPE_SPACE, DEFAULT_STATES$1 as DEFAULT_STATES, DEFAULT_TITLE_SPACE, DEFAULT_VALUE_SPACE, DataLabel, DataZoom, DataZoomActiveTag, DirectionEnum, DiscreteLegend, DiscretePlayer, EmptyTip, GroupTransition, IMarkAreaLabelPosition, IMarkCommonArcLabelPosition, IMarkLineLabelPosition, IMarkPointItemPosition, IOperateType, Indicator, LEGEND_ELEMENT_NAME, LabelBase, LegendEvent, LegendStateValue, LineAxis, LineAxisGrid, LineCrosshair, LineLabel, LinkPath, MarkArcArea, MarkArcLine, MarkArea, MarkLine, MarkPoint, Pager, PlayerEventEnum, PolygonCrosshair, PolygonSectorCrosshair, PopTip, Radio, RectCrosshair, RectLabel, SLIDER_ELEMENT_NAME, ScrollBar, SectorCrosshair, Segment, SizeContinuousLegend, Slider, StoryLabelItem, Switch, SymbolLabel, Tag, Timeline, Title, Tooltip, TopZIndex, VTag, WeatherBox, alignTextInLine, angle, angleLabelOrientAttribute, angleTo, cartesianTicks, clampRadian, computeOffsetForlimit, continuousTicks, contrastAccessibilityChecker, convertDomainToTickData, createTextGraphicByType, deltaXYToAngle, fuzzyEqualNumber, getAxisBreakSymbolAttrs, getCircleLabelPosition, getCirclePoints, getCircleVerticalVector, getElMap, getHorizontalPath, getMarksByName, getNoneGroupMarksByName, getPolarAngleLabelPosition, getPolygonPath, getSizeHandlerPath, getTextAlignAttrOfVerticalDir, getTextType, getVerticalCoord, getVerticalPath, hasOverlap, htmlAttributeTransform, initTextMeasure, isInRange, isPostiveXAxis, isRichText, isVisible, labelSmartInvert, length, limitShapeInBounds, linearDiscreteTicks, loadPoptip, loadScrollbar, measureTextSize, normalize, polarAngleAxisDiscreteTicks, polarTicks, reactAttributeTransform, registerArcDataLabel, registerLineDataLabel, registerMarkArcAreaAnimate, registerMarkArcLineAnimate, registerMarkAreaAnimate, registerMarkLineAnimate, registerMarkPointAnimate, registerRectDataLabel, registerSymbolDataLabel, removeRepeatPoint, richTextAttributeTransform, scale, scrollbarModule, setPoptipTheme, smartInvertStrategy, tan2AngleToAngle, textIntersect, ticks, traverseGroup, version };
