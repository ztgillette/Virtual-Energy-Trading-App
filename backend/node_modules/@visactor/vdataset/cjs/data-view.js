"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.isDataView = exports.DataView = void 0;

const vutils_1 = require("@visactor/vutils"), uuid_1 = require("./utils/uuid"), fields_1 = require("./transform/fields");

class DataView {
    constructor(dataSet, options) {
        let name;
        this.dataSet = dataSet, this.options = options, this.isDataView = !0, this.target = new vutils_1.EventEmitter, 
        this.parseOption = null, this.transformsArr = [], this.isRunning = !1, this.rawData = {}, 
        this.history = !1, this.parserData = {}, this.latestData = {}, this._fields = null, 
        this.reRunAllTransform = (opt = {}) => {
            const prevLatestData = this.latestData;
            return this.isRunning = !0, this.resetTransformData(), this.transformsArr.forEach((t => {
                this.executeTransform(t, {
                    pushHistory: opt.pushHistory,
                    emitMessage: !1
                });
            })), this.isRunning = !1, !1 === opt.emitMessage || opt.skipEqual && (0, vutils_1.isEqual)(prevLatestData, this.latestData) || this.target.emit("change", {
                latestData: this.latestData
            }), this;
        }, this.markRunning = () => {
            this.isRunning = !0, this.target.emit("markRunning", []);
        }, name = (null == options ? void 0 : options.name) ? options.name : (0, uuid_1.getUUID)("dataview"), 
        this.name = name, (null == options ? void 0 : options.history) && (this.history = options.history, 
        this.historyData = []), this.dataSet.setDataView(name, this), this.setFields(null == options ? void 0 : options.fields);
    }
    parse(data, options, emit = !1) {
        var _a;
        this.isRunning = !0, emit && this.target.emit("beforeParse", []), options && (this.parseOption = options);
        const cloneData = this.cloneParseData(data, options);
        if (null == options ? void 0 : options.type) {
            const parserData = (null !== (_a = this.dataSet.getParser(options.type)) && void 0 !== _a ? _a : this.dataSet.getParser("bytejson"))(cloneData, options.options, this);
            this.rawData = cloneData, this.parserData = parserData, this.history && this.historyData.push(cloneData, parserData), 
            this.latestData = parserData;
        } else this.parserData = cloneData, this.rawData = cloneData, this.history && this.historyData.push(cloneData), 
        this.latestData = cloneData;
        return this.isRunning = !1, emit && this.target.emit("afterParse", []), this;
    }
    transform(options, execute = !0) {
        if (this.isRunning = !0, options && options.type) {
            let pushOption = !0;
            if ("fields" === options.type) {
                this._fields = options.options.fields;
                const index = this.transformsArr.findIndex((_op => _op.type === options.type));
                index >= 0 && (pushOption = !1, this.transformsArr[index].options.fields = this._fields);
            }
            pushOption && this.transformsArr.push(options), execute && this.executeTransform(options);
        }
        return this.sortTransform(), this.isRunning = !1, this;
    }
    sortTransform() {
        this.transformsArr.length >= 2 && this.transformsArr.sort(((a, b) => {
            var _a, _b;
            return (null !== (_a = a.level) && void 0 !== _a ? _a : 0) - (null !== (_b = b.level) && void 0 !== _b ? _b : 0);
        }));
    }
    executeTransform(options, opt = {}) {
        const {pushHistory: pushHistory, emitMessage: emitMessage, skipEqual: skipEqual} = opt, transformFn = this.dataSet.getTransform(options.type), prevLatestData = this.latestData, transformData = transformFn(prevLatestData, options.options);
        this.history && !1 !== pushHistory && this.historyData.push(transformData), this.latestData = transformData, 
        !1 === emitMessage || skipEqual && (0, vutils_1.isEqual)(prevLatestData, this.latestData) || this.target.emit("change", {
            latestData: this.latestData
        });
    }
    resetTransformData() {
        this.latestData = this.parserData, this.history && (this.historyData.length = 0, 
        this.historyData.push(this.rawData, this.parserData));
    }
    cloneParseData(data, options) {
        let clone = !1;
        return data instanceof DataView || !0 !== (null == options ? void 0 : options.clone) || (clone = !0), 
        clone ? (0, vutils_1.cloneDeep)(data) : data;
    }
    parseNewData(data, options) {
        this.parse(data, options || this.parseOption), this.reRunAllTransform();
    }
    updateRawData(data, options) {
        const cloneData = this.cloneParseData(data, options);
        this.rawData = cloneData, this.parserData = cloneData, this.latestData = cloneData, 
        this.reRunAllTransform();
    }
    getFields() {
        var _a;
        return this._fields ? this._fields : "dataview" === (null === (_a = this.parseOption) || void 0 === _a ? void 0 : _a.type) && 1 === this.rawData.length && this.rawData[0].getFields ? this.rawData[0].getFields() : null;
    }
    setFields(f, foreMerge = !1) {
        this._fields = f && foreMerge ? (0, vutils_1.merge)({}, this._fields, f) : f;
        const fieldsOption = this.transformsArr.find((_op => "fields" === _op.type));
        !(0, vutils_1.isNil)(this._fields) && (0, vutils_1.isNil)(fieldsOption) ? (this.dataSet.registerTransform("fields", fields_1.fields), 
        this.transform({
            type: "fields",
            options: {
                fields: this._fields
            }
        }, !1)) : fieldsOption && (fieldsOption.options.fields = this._fields);
    }
    destroy() {
        this.dataSet.removeDataView(this.name), this.latestData = null, this.rawData = null, 
        this.parserData = null, this.transformsArr = null, this.target = null;
    }
}

function isDataView(obj) {
    return obj instanceof DataView;
}

exports.DataView = DataView, exports.isDataView = isDataView;
//# sourceMappingURL=data-view.js.map