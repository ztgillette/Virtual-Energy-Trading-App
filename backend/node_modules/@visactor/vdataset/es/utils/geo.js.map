{"version":3,"sources":["../src/utils/geo.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AACrC,MAAM,YAAY,GAAG,OAAO,CAAC;AAC7B,MAAM,CAAC,MAAM,qBAAqB,GAAG,YAAY,GAAG,GAAG,CAAC;AAKxD,MAAM,CAAC,MAAM,UAAU,GAAG,qBAAqB,GAAG,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC;AAC9D,MAAM,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;AACjC,MAAM,YAAY,GAAG,UAAU,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;AACpD,MAAM,CAAC,MAAM,eAAe,GAAG,UAAU,CAAC;AAE1C,MAAM,mBAAmB,GAAG,WAAW,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;AAExG,MAAM,UAAU,cAAc,CAAC,QAAgB;IAC7C,OAAO,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,YAAY,CAAC,CAAC;AACjD,CAAC;AAED,MAAM,UAAU,aAAa,CAAC,YAAoB,EAAE,IAAY;IAC9D,OAAO,UAAU,GAAG,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;AACvD,CAAC;AACD,MAAM,UAAU,eAAe,CAAC,IAAY;IAC1C,OAAO,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;AAC1C,CAAC;AASD,MAAM,UAAU,OAAO,CACrB,KAAkD;IAElD,MAAM,UAAU,GAAG,mBAAmB,CAAC;IACvC,IAAI,OAAO,KAAK,CAAC,CAAC,CAAC,KAAK,WAAW,EAAE;QACnC,MAAM,MAAM,GAAG,UAAU,CAAC,KAAyB,CAAC,CAAC;QAErD,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;QAChB,OAAO,MAAM,CAAC;KACf;IACD,MAAM,MAAM,GAAG,UAAU,CAAC,KAAyB,CAAC,CAAC;IAErD,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;IAEhB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACtB,OAAO,MAAM,CAAC;AAChB,CAAC;AASD,MAAM,UAAU,SAAS,CACvB,KAAkD;IAElD,MAAM,UAAU,GAAG,mBAAmB,CAAC;IACvC,IAAI,OAAO,KAAK,CAAC,CAAC,CAAC,KAAK,WAAW,EAAE;QACnC,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,KAAyB,CAAC,CAAC;QAE5D,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;QAChB,OAAO,MAAM,CAAC;KACf;IACD,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,KAAyB,CAAC,CAAC;IAC5D,MAAM,CAAC,CAAC,CAAC,CAAC;IAEV,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;IAEhB,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IACtB,OAAO,MAAM,CAAC;AAChB,CAAC","file":"geo.js","sourcesContent":["/* eslint-disable no-redeclare */\n\n// eslint 好像对 ts 的多类型函数重载不支持\n\nimport { geoMercator } from 'd3-geo';\nconst EARTH_RADIUS = 6378100;\nexport const RELATIVE_EARTH_RADIUS = EARTH_RADIUS / 100;\n/**\n * 世界大小,这个应该是对外界无感知的\n * 墨卡托绝对坐标/100\n */\nexport const WORLD_SIZE = RELATIVE_EARTH_RADIUS * Math.PI * 2;\nconst fov = (45 / 180) * Math.PI;\nconst WORLD_HEIGHT = WORLD_SIZE / 2 / Math.tan(fov);\nexport const BASE_RESOLUTION = WORLD_SIZE;\n\nconst PROJECTION_MERCATOR = geoMercator().translate([0, 0]).center([0, 0]).scale(RELATIVE_EARTH_RADIUS);\n\nexport function distanceToZoom(distance: number): number {\n  return -1 * Math.log2(distance / WORLD_HEIGHT);\n}\n\nexport function getResolution(canvasHeight: number, zoom: number): number {\n  return WORLD_SIZE / canvasHeight / Math.pow(2, zoom);\n}\nexport function getCameraHeight(zoom: number): number {\n  return WORLD_HEIGHT / Math.pow(2, zoom);\n}\n\n/**\n * 经纬度转相对坐标\n * 传入二维数组,返回二维数组\n * 传入三维数组,返回三维数组\n */\nexport function project(lnglat: [number, number]): [number, number];\nexport function project(lnglatheight: [number, number, number]): [number, number, number];\nexport function project(\n  point: [number, number] | [number, number, number]\n): [number, number] | [number, number, number] {\n  const projection = PROJECTION_MERCATOR;\n  if (typeof point[2] === 'undefined') {\n    const result = projection(point as [number, number]);\n    // 屏幕像素坐标 Y轴 和 WebGL 坐标 Y 轴 方向相反\n    result[1] *= -1;\n    return result;\n  }\n  const result = projection(point as [number, number]);\n  // 屏幕像素坐标 Y轴 和 WebGL 坐标 Y 轴 方向相反\n  result[1] *= -1;\n  // height 和 z 直接怎么转换,现在还没有搞清楚,先 1:1 对应\n  result.push(point[2]);\n  return result;\n}\n\n/**\n * 相对坐标转经纬度\n * 传入二维数组,返回二维数组\n * 传入三维数组,返回三维数组\n */\nexport function unproject(point: [number, number]): [number, number];\nexport function unproject(point: [number, number, number]): [number, number, number];\nexport function unproject(\n  point: [number, number] | [number, number, number]\n): [number, number] | [number, number, number] {\n  const projection = PROJECTION_MERCATOR;\n  if (typeof point[2] === 'undefined') {\n    const result = projection.invert(point as [number, number]);\n    // 屏幕像素坐标 Y轴 和 WebGL 坐标 Y 轴 方向相反\n    result[1] *= -1;\n    return result;\n  }\n  const result = projection.invert(point as [number, number]);\n  result[1];\n  // 屏幕像素坐标 Y轴 和 WebGL 坐标 Y 轴 方向相反\n  result[1] *= -1;\n  // height 和 z 直接怎么转换,现在还没有搞清楚,先 1:1 对应\n  result.push(point[2]);\n  return result;\n}\n"]}