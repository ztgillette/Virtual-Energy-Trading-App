import { pi, pi2 } from "@visactor/vutils";

import { ACustomAnimate } from "./custom-animate";

export class RotateBySphereAnimate extends ACustomAnimate {
    onBind() {
        super.onBind(), this.propKeys = [ "x", "y", "z", "alpha", "zIndex" ];
    }
    onFirstRun() {
        super.onFirstRun();
        const finalAttribute = this.target.getFinalAttribute();
        finalAttribute && this.target.setAttributes(finalAttribute);
    }
    onStart() {
        super.onStart();
        const {center: center, r: r} = "function" == typeof this.params ? this.params() : this.params, startX = this.target.finalAttribute.x, startY = this.target.finalAttribute.y, startZ = this.target.finalAttribute.z, phi = Math.acos((startY - center.y) / r);
        let theta = Math.acos((startX - center.x) / r / Math.sin(phi));
        startZ - center.z < 0 && (theta = pi2 - theta), this.theta = theta, this.phi = phi;
    }
    onEnd() {}
    onUpdate(end, ratio, out) {
        if (null == this.phi || null == this.theta) return;
        const target = this.target, {center: center, r: r, cb: cb} = "function" == typeof this.params ? this.params() : this.params, deltaAngle = 2 * Math.PI * ratio, theta = this.theta + deltaAngle, phi = this.phi, x = r * Math.sin(phi) * Math.cos(theta) + center.x, y = r * Math.cos(phi) + center.y, z = r * Math.sin(phi) * Math.sin(theta) + center.z;
        for (target.attribute.x = x, target.attribute.y = y, target.attribute.z = z, target.attribute.alpha = theta + pi / 2; target.attribute.alpha > pi2; ) target.attribute.alpha -= pi2;
        target.attribute.alpha = pi2 - target.attribute.alpha, target.attribute.zIndex = -1e4 * target.attribute.z, 
        cb && cb(out);
    }
}
//# sourceMappingURL=sphere.js.map