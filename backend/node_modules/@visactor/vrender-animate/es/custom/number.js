import { ACustomAnimate } from "./custom-animate";

export class IncreaseCount extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params), this.formatTemplate = null, this.decimalLength = null == params ? void 0 : params.decimalLength, 
        (null == params ? void 0 : params.formatTemplate) && params.formatTemplate.includes("{{var}}") && (this.formatTemplate = params.formatTemplate);
    }
    onFirstRun() {
        var _a, _b, _c;
        const fromProps = this.getLastProps(), toProps = this.getEndProps(), fromText = null !== (_a = fromProps.text) && void 0 !== _a ? _a : 0, toText = null !== (_b = toProps.text) && void 0 !== _b ? _b : 0;
        this.valid = !0;
        let fromNum = 0, toNum = 0, fromFormat = "", toFormat = "", maxDecimalLength = 0;
        if ("number" == typeof fromText) {
            fromNum = fromText;
            const decimalPart = fromText.toString().split(".")[1] || "";
            maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length);
        } else {
            if ("string" != typeof fromText) return void (this.valid = !1);
            if (fromText.endsWith("%")) {
                fromFormat = "%";
                const cleanNumStr = fromText.substring(0, fromText.length - 1).replace(/,/g, "");
                if (fromNum = parseFloat(cleanNumStr) / 100, isNaN(fromNum)) return void (this.valid = !1);
                const decimalPart = cleanNumStr.split(".")[1] || "";
                maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length + 2);
            } else {
                const cleanNumStr = fromText.replace(/,/g, "");
                if (fromNum = parseFloat(cleanNumStr), isNaN(fromNum)) return void (this.valid = !1);
                fromText.includes(",") && (fromFormat = ",");
                const decimalPart = cleanNumStr.split(".")[1] || "";
                maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length);
            }
        }
        if ("number" == typeof toText) {
            toNum = toText;
            const decimalPart = toText.toString().split(".")[1] || "";
            maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length);
        } else {
            if ("string" != typeof toText) return void (this.valid = !1);
            if (toText.endsWith("%")) {
                toFormat = "%";
                const cleanNumStr = toText.substring(0, toText.length - 1).replace(/,/g, "");
                if (toNum = parseFloat(cleanNumStr) / 100, isNaN(toNum)) return void (this.valid = !1);
                const decimalPart = cleanNumStr.split(".")[1] || "";
                maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length + 2);
            } else {
                const cleanNumStr = toText.replace(/,/g, "");
                if (toNum = parseFloat(cleanNumStr), isNaN(toNum)) return void (this.valid = !1);
                toText.includes(",") && (toFormat = ",");
                const decimalPart = cleanNumStr.split(".")[1] || "";
                maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length);
            }
        }
        if (null === (_c = this.params) || void 0 === _c ? void 0 : _c.format) {
            switch (this.params.format) {
              case "percent":
                this.format = "%";
                break;

              case "thousandth":
                this.format = ",";
                break;

              case "none":
                this.format = "";
                break;

              default:
                this.format = toFormat || fromFormat;
            }
            "%" === this.format && "%" !== toFormat && "%" !== fromFormat && void 0 === this.decimalLength && (this.decimalLength = 2), 
            "%" === this.format || "%" !== toFormat && "%" !== fromFormat || (fromNum *= 100, 
            toNum *= 100);
        } else this.format = toFormat || fromFormat;
        this.fromNumber = fromNum, this.toNumber = toNum, void 0 === this.decimalLength && (this.decimalLength = maxDecimalLength);
    }
    onEnd(cb) {
        super.onEnd(cb), cb || this.props && this.target.setAttributes(this.props);
    }
    onUpdate(end, ratio, out) {
        if (!this.valid) return;
        const currentNumber = this.fromNumber + (this.toNumber - this.fromNumber) * ratio;
        let formattedText = "";
        const format = this.format, numberWithDecimals = ("%" === format ? 100 * currentNumber : currentNumber).toFixed(this.decimalLength);
        let formattedWithBasicFormat, formattedNumber = numberWithDecimals;
        if (parseFloat(numberWithDecimals) === Math.floor(parseFloat(numberWithDecimals)) && (formattedNumber = Math.floor(parseFloat(numberWithDecimals))), 
        "%" === format) formattedWithBasicFormat = `${formattedNumber}%`; else if ("," === format) {
            const parts = formattedNumber.toString().split(".");
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ","), formattedWithBasicFormat = parts.join(".");
        } else formattedWithBasicFormat = formattedNumber;
        formattedText = this.formatTemplate ? this.formatTemplate.replace("{{var}}", formattedWithBasicFormat.toString()) : formattedWithBasicFormat, 
        this.target.setAttribute("text", formattedText);
    }
}
//# sourceMappingURL=number.js.map