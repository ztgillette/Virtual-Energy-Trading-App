import { isNil, isNumber, isValid } from "@visactor/vutils";

import { ACustomAnimate } from "./custom-animate";

function growHeightInIndividual(graphic, options, animationParameters) {
    const attrs = graphic.getFinalAttribute(), y = attrs.y, y1 = attrs.y1, height = attrs.height;
    if (options && "negative" === options.orient) {
        const computedY1 = isValid(height) ? Math.max(y, y + height) : Math.max(y, y1);
        return {
            from: {
                y: computedY1,
                y1: isNil(y1) ? void 0 : computedY1,
                height: isNil(height) ? void 0 : 0
            },
            to: {
                y: y,
                y1: y1,
                height: height
            }
        };
    }
    const computedY = isValid(height) ? Math.min(y, y + height) : Math.min(y, y1);
    return {
        from: {
            y: computedY,
            y1: isNil(y1) ? void 0 : computedY,
            height: isNil(height) ? void 0 : 0
        },
        to: {
            y: y,
            y1: y1,
            height: height
        }
    };
}

function growHeightInOverall(graphic, options, animationParameters) {
    var _a, _b, _c;
    const attrs = graphic.getFinalAttribute(), y = attrs.y, y1 = attrs.y1, height = attrs.height;
    let overallValue;
    return options && "negative" === options.orient ? isNumber(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_c = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : null === (_b = options.layoutRect) || void 0 === _b ? void 0 : _b.height) && void 0 !== _c ? _c : animationParameters.group.getBounds().height(), 
    animationParameters.groupHeight = overallValue) : overallValue = animationParameters.height : overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0, 
    {
        from: {
            y: overallValue,
            y1: isNil(y1) ? void 0 : overallValue,
            height: isNil(height) ? void 0 : 0
        },
        to: {
            y: y,
            y1: y1,
            height: height
        }
    };
}

const growHeightIn = (graphic, options, animationParameters) => {
    var _a;
    return !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growHeightInOverall(graphic, options, animationParameters) : growHeightInIndividual(graphic, options, animationParameters);
};

export class GrowHeightIn extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c;
        super.onBind();
        const {from: from, to: to} = growHeightIn(this.target, this.params.options, this.params), fromAttrs = null !== (_b = null === (_a = this.target.context) || void 0 === _a ? void 0 : _a.lastAttrs) && void 0 !== _b ? _b : from;
        this.props = to, this.propKeys = Object.keys(to).filter((key => null != to[key])), 
        this.from = fromAttrs, this.to = to;
        const finalAttribute = this.target.getFinalAttribute();
        finalAttribute && this.target.setAttributes(finalAttribute), !1 !== (null === (_c = this.params.controlOptions) || void 0 === _c ? void 0 : _c.immediatelyApply) && this.target.setAttributes(fromAttrs);
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach((key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        })), this.target.addUpdatePositionTag(), this.target.addUpdateShapeAndBoundsTag();
    }
}

function growHeightOutIndividual(graphic, options, animationParameters) {
    const attrs = graphic.getFinalAttribute(), y = attrs.y, y1 = attrs.y1, height = attrs.height;
    if (options && "negative" === options.orient) {
        const computedY1 = isValid(height) ? Math.max(y, y + height) : Math.max(y, y1);
        return {
            to: {
                y: computedY1,
                y1: isNil(y1) ? void 0 : computedY1,
                height: isNil(height) ? void 0 : 0
            }
        };
    }
    const computedY = isValid(height) ? Math.min(y, y + height) : Math.min(y, y1);
    return {
        to: {
            y: computedY,
            y1: isNil(y1) ? void 0 : computedY,
            height: isNil(height) ? void 0 : 0
        }
    };
}

function growHeightOutOverall(graphic, options, animationParameters) {
    var _a, _b, _c;
    const attrs = graphic.getFinalAttribute(), y1 = attrs.y1, height = attrs.height;
    let overallValue;
    return options && "negative" === options.orient ? isNumber(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_c = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : null === (_b = options.layoutRect) || void 0 === _b ? void 0 : _b.height) && void 0 !== _c ? _c : animationParameters.group.getBounds().height(), 
    animationParameters.groupHeight = overallValue) : overallValue = animationParameters.height : overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0, 
    {
        to: {
            y: overallValue,
            y1: isNil(y1) ? void 0 : overallValue,
            height: isNil(height) ? void 0 : 0
        }
    };
}

export const growHeightOut = (graphic, options, animationParameters) => {
    var _a;
    return !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growHeightOutOverall(graphic, options, animationParameters) : growHeightOutIndividual(graphic, options, animationParameters);
};

export class GrowHeightOut extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        super.onBind();
        const {from: from, to: to} = (graphic = this.target, options = this.params.options, 
        animationParameters = this.params, !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growHeightOutOverall(graphic, options, animationParameters) : growHeightOutIndividual(graphic, options, animationParameters));
        var graphic, options, animationParameters, _a;
        this.props = to, this.propKeys = Object.keys(to).filter((key => null != to[key])), 
        this.from = null != from ? from : this.target.attribute, this.to = to;
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach((key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        })), this.target.addUpdatePositionTag(), this.target.addUpdateShapeAndBoundsTag();
    }
}
//# sourceMappingURL=growHeight.js.map