import { ACustomAnimate } from "./custom-animate";

import { isNumber } from "@visactor/vutils";

const growAngleInIndividual = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    return options && "anticlockwise" === options.orient ? {
        from: {
            startAngle: null == attrs ? void 0 : attrs.endAngle
        },
        to: {
            startAngle: null == attrs ? void 0 : attrs.startAngle
        }
    } : {
        from: {
            endAngle: null == attrs ? void 0 : attrs.startAngle
        },
        to: {
            endAngle: null == attrs ? void 0 : attrs.endAngle
        }
    };
}, growAngleInOverall = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    if (options && "anticlockwise" === options.orient) {
        const overallValue = isNumber(options.overall) ? options.overall : 2 * Math.PI;
        return {
            from: {
                startAngle: overallValue,
                endAngle: overallValue
            },
            to: {
                startAngle: null == attrs ? void 0 : attrs.startAngle,
                endAngle: null == attrs ? void 0 : attrs.endAngle
            }
        };
    }
    const overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0;
    return {
        from: {
            startAngle: overallValue,
            endAngle: overallValue
        },
        to: {
            startAngle: null == attrs ? void 0 : attrs.startAngle,
            endAngle: null == attrs ? void 0 : attrs.endAngle
        }
    };
};

export const growAngleIn = (graphic, options, animationParameters) => {
    var _a;
    return !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growAngleInOverall(graphic, options) : growAngleInIndividual(graphic, options);
};

const growAngleOutIndividual = (graphic, options, animationParameters) => {
    const attrs = graphic.attribute;
    return options && "anticlockwise" === options.orient ? {
        from: {
            startAngle: attrs.startAngle
        },
        to: {
            startAngle: null == attrs ? void 0 : attrs.endAngle
        }
    } : {
        from: {
            endAngle: attrs.endAngle
        },
        to: {
            endAngle: null == attrs ? void 0 : attrs.startAngle
        }
    };
}, growAngleOutOverall = (graphic, options, animationParameters) => {
    const attrs = graphic.attribute;
    if (options && "anticlockwise" === options.orient) {
        const overallValue = isNumber(options.overall) ? options.overall : 2 * Math.PI;
        return {
            from: {
                startAngle: attrs.startAngle,
                endAngle: attrs.endAngle
            },
            to: {
                startAngle: overallValue,
                endAngle: overallValue
            }
        };
    }
    const overallValue = isNumber(null == options ? void 0 : options.overall) ? options.overall : 0;
    return {
        from: {
            startAngle: attrs.startAngle,
            endAngle: attrs.endAngle
        },
        to: {
            startAngle: overallValue,
            endAngle: overallValue
        }
    };
};

export const growAngleOut = (graphic, options, animationParameters) => {
    var _a;
    return !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growAngleOutOverall(graphic, options) : growAngleOutIndividual(graphic, options);
};

export class GrowAngleBase extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    determineUpdateFunction() {
        this.propKeys ? this.propKeys && this.propKeys.length > 1 ? this._updateFunction = this.updateAngle : "startAngle" === this.propKeys[0] ? this._updateFunction = this.updateStartAngle : "endAngle" === this.propKeys[0] ? this._updateFunction = this.updateEndAngle : this.valid = !1 : this.valid = !1;
    }
    deleteSelfAttr(key) {
        delete this.props[key], this.fromProps && delete this.fromProps[key];
        const index = this.propKeys.indexOf(key);
        -1 !== index && this.propKeys.splice(index, 1), this.propKeys && this.propKeys.length > 1 ? this._updateFunction = this.updateAngle : "startAngle" === this.propKeys[0] ? this._updateFunction = this.updateStartAngle : "endAngle" === this.propKeys[0] ? this._updateFunction = this.updateEndAngle : this._updateFunction = null;
    }
    updateStartAngle(ratio) {
        this.target.attribute.startAngle = this.from.startAngle + (this.to.startAngle - this.from.startAngle) * ratio;
    }
    updateEndAngle(ratio) {
        this.target.attribute.endAngle = this.from.endAngle + (this.to.endAngle - this.from.endAngle) * ratio;
    }
    updateAngle(ratio) {
        this.updateStartAngle(ratio), this.updateEndAngle(ratio);
    }
    onUpdate(end, ratio, out) {
        this._updateFunction && (this._updateFunction(ratio), this.target.addUpdateShapeAndBoundsTag());
    }
}

export class GrowAngleIn extends GrowAngleBase {
    onBind() {
        var _a, _b, _c;
        super.onBind();
        const {from: from, to: to} = growAngleIn(this.target, this.params.options, this.params), fromAttrs = null !== (_b = null === (_a = this.target.context) || void 0 === _a ? void 0 : _a.lastAttrs) && void 0 !== _b ? _b : from;
        this.props = to, this.propKeys = Object.keys(to).filter((key => null != to[key])), 
        this.from = fromAttrs, this.to = to;
        const finalAttribute = this.target.getFinalAttribute();
        finalAttribute && this.target.setAttributes(finalAttribute), !1 !== (null === (_c = this.params.controlOptions) || void 0 === _c ? void 0 : _c.immediatelyApply) && this.target.setAttributes(fromAttrs), 
        this.determineUpdateFunction();
    }
}

export class GrowAngleOut extends GrowAngleBase {
    onBind() {
        super.onBind();
        const {from: from, to: to} = (graphic = this.target, options = this.params.options, 
        this.params, !1 !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growAngleOutOverall(graphic, options) : growAngleOutIndividual(graphic, options));
        var graphic, options, _a;
        const fromAttrs = from;
        this.props = to, this.propKeys = Object.keys(to).filter((key => null != to[key])), 
        this.from = null != fromAttrs ? fromAttrs : this.target.attribute, this.to = to, 
        this.determineUpdateFunction();
    }
}
//# sourceMappingURL=growAngle.js.map