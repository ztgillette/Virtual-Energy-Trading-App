import { vglobal } from "@visactor/vrender-core";

export class ImageProcessUtils {
    static createTempCanvas(width, height, dpr) {
        return vglobal.createCanvas({
            width: width,
            height: height,
            dpr: dpr || vglobal.devicePixelRatio
        });
    }
    static cloneImageData(imageData) {
        const clonedData = new Uint8ClampedArray(imageData.data);
        return new ImageData(clonedData, imageData.width, imageData.height);
    }
    static lerp(start, end, t) {
        return start * (1 - t) + end * t;
    }
    static smoothstep(edge0, edge1, x) {
        const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
        return t * t * (3 - 2 * t);
    }
    static distance(x1, y1, x2, y2) {
        const dx = x2 - x1, dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }
    static normalizeAngle(angle) {
        return (angle + Math.PI) / (2 * Math.PI);
    }
    static pixelNoise(x, y, pixelSize) {
        if (pixelSize <= 0) return 0;
        const gridX = Math.floor(x / pixelSize) * pixelSize, gridY = Math.floor(y / pixelSize) * pixelSize, n = 43758.5453 * Math.sin(12.9898 * gridX + 78.233 * gridY);
        return n - Math.floor(n);
    }
    static generateNoiseTexture(width, height) {
        const data = new Uint8Array(width * height);
        for (let i = 0; i < data.length; i++) data[i] = Math.floor(256 * Math.random());
        return data;
    }
    static applyCSSFilter(canvas, filter) {
        const outputCanvas = this.createTempCanvas(canvas.width, canvas.height), ctx = outputCanvas.getContext("2d");
        return ctx ? (ctx.filter = filter, ctx.drawImage(canvas, 0, 0), ctx.filter = "none", 
        outputCanvas) : canvas;
    }
    static extractChannel(imageData, channelIndex) {
        const {data: data, width: width, height: height} = imageData, channelData = new Uint8ClampedArray(data.length);
        for (let i = 0; i < data.length; i += 4) channelData[i] = 0, channelData[i + 1] = 0, 
        channelData[i + 2] = 0, channelData[i + 3] = data[i + 3], channelIndex >= 0 && channelIndex <= 2 && (channelData[i + channelIndex] = data[i + channelIndex]);
        return new ImageData(channelData, width, height);
    }
    static blendImageData(imageData1, imageData2, ratio) {
        const {data: data1, width: width, height: height} = imageData1, {data: data2} = imageData2, result = new Uint8ClampedArray(data1.length);
        for (let i = 0; i < data1.length; i += 4) result[i] = Math.round(this.lerp(data1[i], data2[i], ratio)), 
        result[i + 1] = Math.round(this.lerp(data1[i + 1], data2[i + 1], ratio)), result[i + 2] = Math.round(this.lerp(data1[i + 2], data2[i + 2], ratio)), 
        result[i + 3] = Math.round(this.lerp(data1[i + 3], data2[i + 3], ratio));
        return new ImageData(result, width, height);
    }
    static getLuminance(r, g, b) {
        return .299 * r + .587 * g + .114 * b;
    }
    static applySepiaToPixel(r, g, b) {
        return [ Math.min(255, .393 * r + .769 * g + .189 * b), Math.min(255, .349 * r + .686 * g + .168 * b), Math.min(255, .272 * r + .534 * g + .131 * b) ];
    }
    static calculateDynamicStrength(baseStrength, animationTime) {
        return baseStrength * (animationTime / (2 * Math.PI));
    }
}

export class ShaderLibrary {}

ShaderLibrary.STANDARD_VERTEX_SHADER = "\n    attribute vec2 a_position;\n    attribute vec2 a_texCoord;\n    varying vec2 v_texCoord;\n\n    void main() {\n      gl_Position = vec4(a_position, 0.0, 1.0);\n      v_texCoord = a_texCoord;\n    }\n  ", 
ShaderLibrary.SHADER_FUNCTIONS = "\n    // 亮度计算函数\n    float luminance(vec3 color) {\n      return dot(color, vec3(0.299, 0.587, 0.114));\n    }\n\n    // 褐色调函数\n    vec3 sepia(vec3 color) {\n      float r = color.r * 0.393 + color.g * 0.769 + color.b * 0.189;\n      float g = color.r * 0.349 + color.g * 0.686 + color.b * 0.168;\n      float b = color.r * 0.272 + color.g * 0.534 + color.b * 0.131;\n      return vec3(r, g, b);\n    }\n\n    // 线性插值函数\n    float lerp(float a, float b, float t) {\n      return a * (1.0 - t) + b * t;\n    }\n\n\n    // 简单噪声函数\n    float pixelNoise(vec2 coord, float pixelSize) {\n      vec2 gridCoord = floor(coord / pixelSize) * pixelSize;\n      return fract(sin(dot(gridCoord, vec2(12.9898, 78.233))) * 43758.5453123);\n    }\n\n    // 动态强度计算\n    float calculateDynamicStrength(float baseStrength, float time) {\n      return baseStrength * (time / 6.28318531); // 2π\n    }\n  ";
//# sourceMappingURL=ImageProcessUtils.js.map
