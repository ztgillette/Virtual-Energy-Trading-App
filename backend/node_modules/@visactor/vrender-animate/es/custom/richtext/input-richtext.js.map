{"version":3,"sources":["../src/custom/richtext/input-richtext.ts"],"names":[],"mappings":"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","file":"input-richtext.js","sourcesContent":["import { ACustomAnimate } from '../custom-animate';\nimport type {\n  IRichTextCharacter,\n  IRichTextParagraphCharacter,\n  IAnimate,\n  IStep,\n  EasingType\n} from '@visactor/vrender-core';\nimport { RichText } from '@visactor/vrender-core';\n\n/**\n * 富文本输入动画，实现类似打字机的字符逐个显示效果\n * 支持通过beforeText和afterText参数添加前缀和后缀\n * 支持通过showCursor参数显示光标，cursorChar自定义光标字符\n * 支持通过fadeInChars参数开启字符透明度渐变效果\n * 支持通过strokeFirst参数开启描边先于填充显示效果，使用文字自身颜色作为描边色\n */\nexport class InputRichText extends ACustomAnimate<{ textConfig: IRichTextCharacter[] }> {\n  declare valid: boolean;\n\n  private fromTextConfig: IRichTextCharacter[] = [];\n  private toTextConfig: IRichTextCharacter[] = [];\n  private originalTextConfig: IRichTextCharacter[] = [];\n  private showCursor: boolean = false;\n  private cursorChar: string = '|';\n  private blinkCursor: boolean = true;\n  private fadeInChars: boolean = false;\n  private fadeInDuration: number = 0.3; // 透明度渐变持续时间，以动画总时长的比例表示\n  private strokeFirst: boolean = false; // 是否开启描边先于填充显示效果\n  private strokeToFillRatio: number = 0.3; // 描边到填充的过渡比例，占总动画时长的比例\n\n  constructor(\n    from: { textConfig: IRichTextCharacter[] },\n    to: { textConfig: IRichTextCharacter[] },\n    duration: number,\n    easing: EasingType,\n    params?: {\n      showCursor?: boolean;\n      cursorChar?: string;\n      blinkCursor?: boolean;\n      beforeText?: string;\n      afterText?: string;\n      fadeInChars?: boolean;\n      fadeInDuration?: number;\n      strokeFirst?: boolean;\n      strokeToFillRatio?: number;\n    }\n  ) {\n    super(from, to, duration, easing, params);\n\n    // 配置光标相关选项\n    if (params?.showCursor !== undefined) {\n      this.showCursor = params.showCursor;\n    }\n    if (params?.cursorChar !== undefined) {\n      this.cursorChar = params.cursorChar;\n    }\n    if (params?.blinkCursor !== undefined) {\n      this.blinkCursor = params.blinkCursor;\n    }\n\n    // 配置字符透明度渐变效果\n    if (params?.fadeInChars !== undefined) {\n      this.fadeInChars = params.fadeInChars;\n    }\n    if (params?.fadeInDuration !== undefined) {\n      this.fadeInDuration = params.fadeInDuration;\n    }\n\n    // 配置描边先于填充显示效果\n    if (params?.strokeFirst !== undefined) {\n      this.strokeFirst = params.strokeFirst;\n    }\n    if (params?.strokeToFillRatio !== undefined) {\n      this.strokeToFillRatio = params.strokeToFillRatio;\n    }\n  }\n\n  onFirstRun(): void {\n    const fromProps = this.getLastProps();\n    const toProps = this.getEndProps();\n\n    // 存储原始配置\n    this.originalTextConfig = toProps.textConfig ? [...toProps.textConfig] : [];\n\n    // 初始化解析结果\n    this.valid = true;\n\n    // 确保to不为空\n    if (!this.originalTextConfig || this.originalTextConfig.length === 0) {\n      this.valid = false;\n      return;\n    }\n\n    // 将文本拆分为单个字符，使用RichText的静态方法\n    this.fromTextConfig =\n      fromProps.textConfig && fromProps.textConfig.length > 0\n        ? RichText.TransformTextConfig2SingleCharacter(fromProps.textConfig)\n        : [];\n\n    this.toTextConfig = RichText.TransformTextConfig2SingleCharacter(this.originalTextConfig);\n  }\n\n  onEnd(cb?: (animate: IAnimate, step: IStep) => void): void {\n    super.onEnd(cb);\n    if (!cb) {\n      // 动画结束时，恢复原始textConfig\n      this.target.setAttribute('textConfig', this.originalTextConfig);\n    }\n  }\n\n  onUpdate(end: boolean, ratio: number, out: Record<string, any>): void {\n    if (!this.valid) {\n      return;\n    }\n\n    // 计算当前应该显示的字符数量\n    const totalItems = this.toTextConfig.length;\n    const fromItems = this.fromTextConfig.length;\n\n    // 计算文本显示比例上限 - 如果有渐变效果，需要为尾部字符的渐变留出时间\n    // 例如，如果fadeInDuration为0.3，则文本显示部分最多占用动画时间的70%\n    const maxTextShowRatio = this.fadeInChars ? 1 - this.fadeInDuration : 1;\n\n    // 确定当前应该显示多少个项目\n    let currentLength: number;\n\n    // 如果fromItems比totalItems长，则是删除动画，否则是添加动画\n    if (fromItems > totalItems) {\n      // 删除文本动画（从多到少）\n      currentLength = Math.round(fromItems - (fromItems - totalItems) * ratio);\n    } else {\n      // 添加文本动画（从少到多）- 需要更快显示字符以便留出时间让最后的字符完成渐变\n      if (this.fadeInChars) {\n        // 当ratio达到maxTextShowRatio时，应该已经显示全部文本\n        const adjustedRatio = Math.min(1, ratio / maxTextShowRatio);\n        currentLength = Math.round(fromItems + (totalItems - fromItems) * adjustedRatio);\n      } else {\n        // 无渐变效果时，正常显示\n        currentLength = Math.round(fromItems + (totalItems - fromItems) * ratio);\n      }\n    }\n\n    // 构建当前要显示的textConfig\n    let currentTextConfig: IRichTextCharacter[];\n    if (fromItems > totalItems) {\n      // 删除动画：显示from的前currentLength项\n      currentTextConfig = this.fromTextConfig.slice(0, currentLength);\n    } else {\n      // 添加文本动画：显示to的前currentLength项，可能需要应用透明度和描边效果\n      currentTextConfig = this.toTextConfig.slice(0, currentLength).map((item, index) => {\n        // 如果是文本项并且需要应用效果\n        if ('text' in item) {\n          const newItem = { ...item };\n\n          // 如果启用了描边优先效果\n          if (this.strokeFirst) {\n            // 计算描边到填充的过渡进度\n            // 字符在特定时间点出现：出现时刻 = (index / totalItems) * maxTextShowRatio\n            const appearTime = (index / totalItems) * maxTextShowRatio;\n            const itemLifetime = Math.max(0, ratio - appearTime); // 当前字符已经存在的时间\n            const maxLifetime = 1 - appearTime; // 当前字符从出现到动画结束的最大时间\n            const fillProgress = Math.min(1, itemLifetime / (this.strokeToFillRatio * maxLifetime));\n\n            // 使用文本自身的填充颜色作为描边颜色\n            if ('fill' in newItem && newItem.fill) {\n              newItem.stroke = newItem.fill;\n              // 计算描边宽度，基于字体大小\n              // const fontSize = newItem.fontSize || 16;\n              // newItem.lineWidth = Math.max(1, fontSize * 0.05); // 线宽大约为字体大小的5%\n\n              // 如果还没到填充阶段，则将填充色透明度设为0\n              if (fillProgress < 1) {\n                newItem.fillOpacity = fillProgress;\n              }\n            }\n\n            // 如果也启用了透明度渐变\n            if (this.fadeInChars) {\n              const fadeProgress = Math.min(1, itemLifetime / (this.fadeInDuration * maxLifetime));\n              newItem.opacity = Math.max(0, Math.min(1, fadeProgress));\n            }\n          }\n          // 只启用了透明度渐变效果，没有启用描边优先\n          else if (this.fadeInChars) {\n            const appearTime = (index / totalItems) * maxTextShowRatio;\n            const fadeProgress = (ratio - appearTime) / this.fadeInDuration;\n            newItem.opacity = Math.max(0, Math.min(1, fadeProgress));\n          }\n\n          return newItem;\n        }\n        return item;\n      });\n    }\n\n    // 如果启用了光标\n    if (this.showCursor && currentLength < totalItems) {\n      // 判断是否应该显示光标\n      let shouldShowCursor = true;\n\n      if (this.blinkCursor) {\n        // 闪烁效果：在动画期间，光标每半个周期闪烁一次\n        const blinkRate = 0.1; // 光标闪烁频率（每10%动画进度闪烁一次）\n        shouldShowCursor = Math.floor(ratio / blinkRate) % 2 === 0;\n      }\n\n      if (shouldShowCursor && currentTextConfig.length > 0) {\n        // 找到最后一个文本项，在其后添加光标\n        const lastIndex = currentTextConfig.length - 1;\n        const lastItem = currentTextConfig[lastIndex];\n\n        if ('text' in lastItem) {\n          // 如果最后一项是文本，将光标添加到文本后面\n          currentTextConfig[lastIndex] = {\n            ...lastItem,\n            text: String(lastItem.text) + this.cursorChar\n          };\n        } else {\n          // 如果最后一项是非文本（如图片），添加一个只包含光标的新文本项\n          const cursorItem: IRichTextParagraphCharacter = {\n            text: this.cursorChar,\n            fontSize: 16 // 使用默认字体大小，或者从context获取\n          };\n          currentTextConfig.push(cursorItem);\n        }\n      }\n    }\n\n    // 更新富文本的textConfig属性\n    this.target.setAttribute('textConfig', currentTextConfig);\n  }\n}\n"]}