{"version":3,"sources":["../src/state/animation-state.ts"],"names":[],"mappings":"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","file":"animation-state.js","sourcesContent":["import type { IGraphic } from '@visactor/vrender-core';\nimport type { IAnimationState } from './types';\nimport { AnimationTransitionRegistry } from './animation-states-registry';\nimport type { IAnimationConfig } from '../executor/executor';\nimport { AnimateExecutor } from '../executor/animate-executor';\nimport { isArray } from '@visactor/vutils';\n\n// Standard animation state names\nexport const AnimationStates = {\n  APPEAR: 'appear',\n  DISAPPEAR: 'disappear',\n  UPDATE: 'update',\n  HIGHLIGHT: 'highlight',\n  UNHIGHLIGHT: 'unhighlight',\n  SELECT: 'select',\n  UNSELECT: 'unselect',\n  HOVER: 'hover',\n  UNHOVER: 'unhover',\n  ACTIVE: 'active',\n  INACTIVE: 'inactive'\n};\n\nexport class AnimationStateStore {\n  graphic: IGraphic;\n\n  constructor(graphic: IGraphic) {\n    this.graphic = graphic;\n  }\n\n  // 动画状态配置\n  // 并不是所有图元都有（只有mark才有），所以在应用状态的时候，需要额外传入\n  states?: Map<string, IAnimationState>;\n\n  registerState(state: IAnimationState): void {\n    if (!this.states) {\n      this.states = new Map();\n    }\n    this.states.set(state.name, state);\n  }\n\n  clearStates(): void {\n    this.states?.clear();\n  }\n}\n\n// 一个状态对应一个执行器，每个图元都有一一对应\ninterface IStateInfo {\n  state: string;\n  animationConfig: IAnimationConfig | IAnimationConfig[];\n  executor: AnimateExecutor;\n}\n\nexport class AnimationStateManager {\n  protected graphic: IGraphic;\n\n  // 当前状态\n  // TODO（注意，这里无法了解动画的顺序，既有串行也有并行，具体在执行的时候确定，执行之后就无法获取串行或并行配置了）\n  stateList: IStateInfo[] | null = null;\n\n  constructor(graphic: IGraphic) {\n    this.graphic = graphic;\n  }\n\n  // TODO 这里因为只有状态变更才会调用，所以代码写的比较宽松，如果有性能问题需要优化\n  /**\n   * 应用状态\n   * @param nextState 下一个状态数组，如果传入数组，那么状态是串行的。但是每次applyState都会立即执行动画，也就是applyState和applyState之间是并行\n   * @param animationConfig 动画配置\n   * @param callback 动画结束后的回调函数，参数empty为true表示没有动画需要执行直接调的回调\n   */\n  applyState(\n    nextState: string[],\n    animationConfig: (IAnimationState | IAnimationState[])[],\n    callback?: (empty?: boolean) => void\n  ): void {\n    const registry = AnimationTransitionRegistry.getInstance();\n\n    // TODO 这里指判断第一个状态，后续如果需要的话要循环判断\n    // 检查是否需要停止当前状态，以及下一个状态是否需要应用\n    const shouldStopState: IStateInfo[] = [];\n    const shouldApplyState: IStateInfo[] = [];\n    if (!(this.stateList && this.stateList.length)) {\n      nextState.forEach((state, index) => {\n        shouldApplyState.push({\n          state,\n          animationConfig: isArray(animationConfig[index])\n            ? (animationConfig[index] as IAnimationState[]).map(item => item.animation)\n            : (animationConfig[index] as IAnimationState).animation,\n          executor: new AnimateExecutor(this.graphic)\n        });\n      });\n    } else {\n      // const _stateList = this.stateList[0];\n      nextState.forEach((state, index) => {\n        // 遍历this.stateList，获取result，只要有一个是false，那这个result就是false\n        const result: { allowTransition: boolean; stopOriginalTransition: boolean } = {\n          allowTransition: true,\n          stopOriginalTransition: true\n        };\n        this.stateList.forEach(currState => {\n          const _result = registry.isTransitionAllowed(currState.state, state, this.graphic);\n          result.allowTransition = result.allowTransition && _result.allowTransition;\n        });\n        // 所有状态都允许过渡，则添加到shouldApplyState\n        if (result.allowTransition) {\n          shouldApplyState.push({\n            state,\n            animationConfig: isArray(animationConfig[index])\n              ? (animationConfig[index] as IAnimationState[]).map(item => item.animation)\n              : (animationConfig[index] as IAnimationState).animation,\n            executor: new AnimateExecutor(this.graphic)\n          });\n          // 允许过渡的话，需要重新遍历this.stateList，获取stopOriginalTransition\n          this.stateList.forEach(currState => {\n            const _result = registry.isTransitionAllowed(currState.state, state, this.graphic);\n            if (_result.stopOriginalTransition) {\n              shouldStopState.push(currState);\n            }\n          });\n        }\n      });\n    }\n\n    // 停止动画\n    shouldStopState.forEach(state => {\n      state.executor.stop();\n    });\n\n    // 立即应用动画，串行的应用\n    if (shouldApplyState.length) {\n      shouldApplyState[0].executor.execute(shouldApplyState[0].animationConfig);\n      // 如果下一个状态存在，那么下一个状态的动画在当前状态动画结束后立即执行\n      for (let i = 0; i < shouldApplyState.length; i++) {\n        const nextState = shouldApplyState[i + 1];\n        const currentState = shouldApplyState[i];\n        currentState.executor.onEnd(() => {\n          if (nextState) {\n            nextState.executor.execute(nextState.animationConfig);\n          }\n          // 删除这个状态\n          this.stateList = this.stateList.filter(state => state !== currentState);\n\n          // 如果是最后一个状态且有回调，则调用回调\n          if (i === shouldApplyState.length - 1 && callback) {\n            callback(false);\n          }\n        });\n      }\n    } else if (callback) {\n      // 如果没有需要应用的动画状态，直接调用回调\n      callback(true);\n    }\n\n    if (this.stateList) {\n      this.stateList = this.stateList.filter(state => !shouldStopState.includes(state));\n    } else {\n      this.stateList = [];\n    }\n    this.stateList.push(...shouldApplyState);\n  }\n\n  /**\n   * Apply a standard appear animation to the graphic\n   * @param animationConfig Animation configuration\n   * @param callback Callback to be called when animation ends\n   */\n  applyAppearState(animationConfig: IAnimationConfig, callback?: () => void): void {\n    this.applyState([AnimationStates.APPEAR], [{ name: AnimationStates.APPEAR, animation: animationConfig }], callback);\n  }\n\n  /**\n   * Apply a standard disappear animation to the graphic\n   * @param animationConfig Animation configuration\n   * @param callback Callback to be called when animation ends\n   */\n  applyDisappearState(animationConfig: IAnimationConfig, callback?: () => void): void {\n    this.applyState(\n      [AnimationStates.DISAPPEAR],\n      [{ name: AnimationStates.DISAPPEAR, animation: animationConfig }],\n      callback\n    );\n  }\n\n  /**\n   * Apply a standard update animation to the graphic\n   * @param animationConfig Animation configuration\n   * @param callback Callback to be called when animation ends\n   */\n  applyUpdateState(animationConfig: IAnimationConfig, callback?: () => void): void {\n    this.applyState([AnimationStates.UPDATE], [{ name: AnimationStates.UPDATE, animation: animationConfig }], callback);\n  }\n\n  /**\n   * Apply a standard highlight animation to the graphic\n   * @param animationConfig Animation configuration\n   * @param callback Callback to be called when animation ends\n   */\n  applyHighlightState(animationConfig: IAnimationConfig, callback?: () => void): void {\n    this.applyState(\n      [AnimationStates.HIGHLIGHT],\n      [{ name: AnimationStates.HIGHLIGHT, animation: animationConfig }],\n      callback\n    );\n  }\n\n  /**\n   * Apply a standard unhighlight animation to the graphic\n   * @param animationConfig Animation configuration\n   * @param callback Callback to be called when animation ends\n   */\n  applyUnhighlightState(animationConfig: IAnimationConfig, callback?: () => void): void {\n    this.applyState(\n      [AnimationStates.UNHIGHLIGHT],\n      [{ name: AnimationStates.UNHIGHLIGHT, animation: animationConfig }],\n      callback\n    );\n  }\n\n  stopState(state: string, type?: 'start' | 'end' | Record<string, any>): void {\n    const stateInfo = this.stateList?.find(stateInfo => stateInfo.state === state);\n    if (stateInfo) {\n      stateInfo.executor.stop(type);\n    }\n  }\n\n  clearState(): void {\n    // 清空状态\n    this.stateList?.forEach(state => {\n      state.executor.stop();\n    });\n    this.stateList = null;\n  }\n\n  reApplyState(state: string): void {\n    const stateInfo = this.stateList?.find(stateInfo => stateInfo.state === state);\n    // 只有当状态存在且动画正在运行时才重新应用\n    if (stateInfo && stateInfo.executor.started) {\n      // stop状态会改变stateList，但因为是reapply，所以保留原始的stateList\n      const stateList = this.stateList.slice();\n      stateInfo.executor.stop();\n      this.stateList = stateList;\n      stateInfo.executor.execute(stateInfo.animationConfig);\n    }\n  }\n\n  // getstateList(): string[] | null {\n  //   return this.stateList;\n  // }\n}\n"]}