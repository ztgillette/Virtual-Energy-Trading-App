import { interpolateColor, interpolatePureColorArrayToStr, pointsInterpolation } from "@visactor/vrender-core";

import { interpolateNumber } from "./number";

export class InterpolateUpdateStore {
    constructor() {
        this.opacity = (key, from, to, ratio, step, target) => {
            target.attribute.opacity = interpolateNumber(from, to, ratio);
        }, this.baseOpacity = (key, from, to, ratio, step, target) => {
            target.attribute.baseOpacity = interpolateNumber(from, to, ratio);
        }, this.fillOpacity = (key, from, to, ratio, step, target) => {
            target.attribute.fillOpacity = interpolateNumber(from, to, ratio);
        }, this.strokeOpacity = (key, from, to, ratio, step, target) => {
            target.attribute.strokeOpacity = interpolateNumber(from, to, ratio);
        }, this.zIndex = (key, from, to, ratio, step, target) => {
            target.attribute.zIndex = interpolateNumber(from, to, ratio);
        }, this.backgroundOpacity = (key, from, to, ratio, step, target) => {
            target.attribute.backgroundOpacity = interpolateNumber(from, to, ratio);
        }, this.shadowOffsetX = (key, from, to, ratio, step, target) => {
            target.attribute.shadowOffsetX = interpolateNumber(from, to, ratio);
        }, this.shadowOffsetY = (key, from, to, ratio, step, target) => {
            target.attribute.shadowOffsetY = interpolateNumber(from, to, ratio);
        }, this.shadowBlur = (key, from, to, ratio, step, target) => {
            target.attribute.shadowBlur = interpolateNumber(from, to, ratio);
        }, this.fill = (key, from, to, ratio, step, target) => {
            target.attribute.fill = interpolateColor(from, to, ratio, !1);
        }, this.fillPure = (key, from, to, ratio, step, target) => {
            target.attribute.fill = step.fromParsedProps.fill ? interpolatePureColorArrayToStr(step.fromParsedProps.fill, step.toParsedProps.fill, ratio) : step.toParsedProps.fill;
        }, this.stroke = (key, from, to, ratio, step, target) => {
            target.attribute.stroke = interpolateColor(from, to, ratio, !1);
        }, this.strokePure = (key, from, to, ratio, step, target) => {
            target.attribute.stroke = step.fromParsedProps.stroke ? interpolatePureColorArrayToStr(step.fromParsedProps.stroke, step.toParsedProps.stroke, ratio) : step.toParsedProps.stroke;
        }, this.width = (key, from, to, ratio, step, target) => {
            target.attribute.width = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
        }, this.height = (key, from, to, ratio, step, target) => {
            target.attribute.height = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
        }, this.x = (key, from, to, ratio, step, target) => {
            target.attribute.x = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), 
            target.addUpdatePositionTag();
        }, this.y = (key, from, to, ratio, step, target) => {
            target.attribute.y = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), 
            target.addUpdatePositionTag();
        }, this.dx = (key, from, to, ratio, step, target) => {
            target.attribute.dx = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), 
            target.addUpdatePositionTag();
        }, this.dy = (key, from, to, ratio, step, target) => {
            target.attribute.dy = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), 
            target.addUpdatePositionTag();
        }, this.angle = (key, from, to, ratio, step, target) => {
            target.attribute.angle = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), 
            target.addUpdatePositionTag();
        }, this.scaleX = (key, from, to, ratio, step, target) => {
            target.attribute.scaleX = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), 
            target.addUpdatePositionTag();
        }, this.scaleY = (key, from, to, ratio, step, target) => {
            target.attribute.scaleY = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), 
            target.addUpdatePositionTag();
        }, this.lineWidth = (key, from, to, ratio, step, target) => {
            target.attribute.lineWidth = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
        }, this.startAngle = (key, from, to, ratio, step, target) => {
            target.attribute.startAngle = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
        }, this.endAngle = (key, from, to, ratio, step, target) => {
            target.attribute.endAngle = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
        }, this.radius = (key, from, to, ratio, step, target) => {
            target.attribute.radius = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
        }, this.outerRadius = (key, from, to, ratio, step, target) => {
            target.attribute.outerRadius = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
        }, this.innerRadius = (key, from, to, ratio, step, target) => {
            target.attribute.innerRadius = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
        }, this.size = (key, from, to, ratio, step, target) => {
            target.attribute.size = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
        }, this.points = (key, from, to, ratio, step, target) => {
            target.attribute.points = pointsInterpolation(from, to, ratio), target.addUpdateBoundTag();
        };
    }
}

export const interpolateUpdateStore = new InterpolateUpdateStore;

export function commonInterpolateUpdate(key, from, to, ratio, step, target) {
    if (Number.isFinite(to) && Number.isFinite(from)) return target.attribute[key] = from + (to - from) * ratio, 
    !0;
    if (Array.isArray(to) && Array.isArray(from) && to.length === from.length) {
        const nextList = [];
        let valid = !0;
        for (let i = 0; i < to.length; i++) {
            const v = from[i], val = v + (to[i] - v) * ratio;
            if (!Number.isFinite(val)) {
                valid = !1;
                break;
            }
            nextList.push(val);
        }
        return valid && (target.attribute[key] = nextList), !0;
    }
    return !1;
}
//# sourceMappingURL=store.js.map