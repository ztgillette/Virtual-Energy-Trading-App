import { type IGraphic, type IAnimate, type IStep, type EasingType, type EasingTypeFunc, type IAnimateStepType } from '@visactor/vrender-core';
export declare class Step implements IStep {
    id: number;
    type: IAnimateStepType;
    prev?: IStep;
    duration: number;
    next?: IStep;
    props?: Record<string, any>;
    propKeys?: string[];
    interpolateUpdateFunctions?: ((key: string, from: number, to: number, ratio: number, step: IStep, target: IGraphic) => void)[];
    easing: EasingTypeFunc;
    animate: IAnimate;
    target: IGraphic;
    fromProps: Record<string, any>;
    fromParsedProps: Record<string, any>;
    toParsedProps: Record<string, any>;
    protected _startTime: number;
    _hasFirstRun: boolean;
    protected _endCb?: (animate: IAnimate, step: IStep) => void;
    syncAttributeUpdate: () => void;
    constructor(type: IAnimateStepType, props: Record<string, any>, duration: number, easing: EasingType);
    bind(target: IGraphic, animate: IAnimate): void;
    append(step: IStep): void;
    private updateDownstreamStartTimes;
    getLastProps(): any;
    setDuration(duration: number, updateDownstream?: boolean): void;
    getDuration(): number;
    determineInterpolateUpdateFunction(): void;
    setStartTime(time: number, updateDownstream?: boolean): void;
    getStartTime(): number;
    onBind(): void;
    _syncAttributeUpdate: () => void;
    onFirstRun(): void;
    onStart(): void;
    protected tryPreventConflict(): void;
    deleteSelfAttr(key: string): void;
    trySyncStartProps(): void;
    update(end: boolean, ratio: number, out: Record<string, any>): void;
    onUpdate(end: boolean, ratio: number, out: Record<string, any>): void;
    onEnd(cb?: (animate: IAnimate, step: IStep) => void): void;
    getEndProps(): Record<string, any>;
    getFromProps(): Record<string, any>;
    getMergedEndProps(): Record<string, any> | void;
    stop(): void;
    release(): void;
}
export declare class WaitStep extends Step {
    constructor(type: IAnimateStepType, props: Record<string, any>, duration: number, easing: EasingType);
    onStart(): void;
    update(end: boolean, ratio: number, out: Record<string, any>): void;
    determineInterpolateUpdateFunction(): void;
}
