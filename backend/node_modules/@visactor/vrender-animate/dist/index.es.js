import { interpolateColor, interpolatePureColorArrayToStr, pointsInterpolation, Generator, ColorStore, ColorType, AnimateStatus, AnimateStepType, PerformanceRAF, STATUS, application, CustomPath2D, CurveContext, Graphic, splitRect, splitArc, splitCircle, splitLine, splitPolygon, splitArea, splitPath, AttributeUpdateType, pathToBezierCurves, applyTransformOnBezierCurves, alignBezierCurves, findBestMorphingRotation, pointInterpolation, RichText, divideCubic, vglobal } from '@visactor/vrender-core';
import { pi2, isString, EventEmitter, isArray, isFunction, mixin, isNil, isValidNumber, clamp, Point, pi, isNumber, isValid, isNumberClose, PointService } from '@visactor/vutils';

class Easing {
    constructor() {
    }
    static linear(t) {
        return t;
    }
    static none() {
        return this.linear;
    }
    static get(amount) {
        if (amount < -1) {
            amount = -1;
        }
        else if (amount > 1) {
            amount = 1;
        }
        return function (t) {
            if (amount === 0) {
                return t;
            }
            if (amount < 0) {
                return t * (t * -amount + 1 + amount);
            }
            return t * ((2 - t) * amount + (1 - amount));
        };
    }
    static getPowIn(pow) {
        return function (t) {
            return Math.pow(t, pow);
        };
    }
    static getPowOut(pow) {
        return function (t) {
            return 1 - Math.pow(1 - t, pow);
        };
    }
    static getPowInOut(pow) {
        return function (t) {
            if ((t *= 2) < 1) {
                return 0.5 * Math.pow(t, pow);
            }
            return 1 - 0.5 * Math.abs(Math.pow(2 - t, pow));
        };
    }
    static getBackIn(amount) {
        return function (t) {
            return t * t * ((amount + 1) * t - amount);
        };
    }
    static getBackOut(amount) {
        return function (t) {
            return --t * t * ((amount + 1) * t + amount) + 1;
        };
    }
    static getBackInOut(amount) {
        amount *= 1.525;
        return function (t) {
            if ((t *= 2) < 1) {
                return 0.5 * (t * t * ((amount + 1) * t - amount));
            }
            return 0.5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
        };
    }
    static sineIn(t) {
        return 1 - Math.cos((t * Math.PI) / 2);
    }
    static sineOut(t) {
        return Math.sin((t * Math.PI) / 2);
    }
    static sineInOut(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
    }
    static expoIn(t) {
        return t === 0 ? 0 : Math.pow(2, 10 * t - 10);
    }
    static expoOut(t) {
        return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
    }
    static expoInOut(t) {
        return t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
    }
    static circIn(t) {
        return -(Math.sqrt(1 - t * t) - 1);
    }
    static circOut(t) {
        return Math.sqrt(1 - --t * t);
    }
    static circInOut(t) {
        if ((t *= 2) < 1) {
            return -0.5 * (Math.sqrt(1 - t * t) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
    }
    static bounceOut(t) {
        if (t < 1 / 2.75) {
            return 7.5625 * t * t;
        }
        else if (t < 2 / 2.75) {
            return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
        }
        else if (t < 2.5 / 2.75) {
            return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
        }
        return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    }
    static bounceIn(t) {
        return 1 - Easing.bounceOut(1 - t);
    }
    static bounceInOut(t) {
        if (t < 0.5) {
            return Easing.bounceIn(t * 2) * 0.5;
        }
        return Easing.bounceOut(t * 2 - 1) * 0.5 + 0.5;
    }
    static getElasticIn(amplitude, period) {
        return function (t) {
            if (t === 0 || t === 1) {
                return t;
            }
            const s = (period / pi2) * Math.asin(1 / amplitude);
            return -(amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * pi2) / period));
        };
    }
    static getElasticOut(amplitude, period) {
        return function (t) {
            if (t === 0 || t === 1) {
                return t;
            }
            const s = (period / pi2) * Math.asin(1 / amplitude);
            return amplitude * Math.pow(2, -10 * t) * Math.sin(((t - s) * pi2) / period) + 1;
        };
    }
    static getElasticInOut(amplitude, period) {
        return function (t) {
            const s = (period / pi2) * Math.asin(1 / amplitude);
            if ((t *= 2) < 1) {
                return -0.5 * (amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * pi2) / period));
            }
            return amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin(((t - s) * pi2) / period) * 0.5 + 1;
        };
    }
    static registerFunc(name, func) {
        Easing[name] = func;
    }
}
Easing.quadIn = Easing.getPowIn(2);
Easing.quadOut = Easing.getPowOut(2);
Easing.quadInOut = Easing.getPowInOut(2);
Easing.cubicIn = Easing.getPowIn(3);
Easing.cubicOut = Easing.getPowOut(3);
Easing.cubicInOut = Easing.getPowInOut(3);
Easing.quartIn = Easing.getPowIn(4);
Easing.quartOut = Easing.getPowOut(4);
Easing.quartInOut = Easing.getPowInOut(4);
Easing.quintIn = Easing.getPowIn(5);
Easing.quintOut = Easing.getPowOut(5);
Easing.quintInOut = Easing.getPowInOut(5);
Easing.backIn = Easing.getBackIn(1.7);
Easing.backOut = Easing.getBackOut(1.7);
Easing.backInOut = Easing.getBackInOut(1.7);
Easing.elasticIn = Easing.getElasticIn(1, 0.3);
Easing.elasticOut = Easing.getElasticOut(1, 0.3);
Easing.elasticInOut = Easing.getElasticInOut(1, 0.3 * 1.5);
Easing.easeInOutQuad = (t) => {
    if ((t /= 0.5) < 1) {
        return 0.5 * Math.pow(t, 2);
    }
    return -0.5 * ((t -= 2) * t - 2);
};
Easing.easeOutElastic = (x) => {
    const c4 = (2 * Math.PI) / 3;
    return x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1;
};
Easing.easeInOutElastic = (x) => {
    const c5 = (2 * Math.PI) / 4.5;
    return x === 0
        ? 0
        : x === 1
            ? 1
            : x < 0.5
                ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2
                : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) / 2 + 1;
};
function flicker(t, n) {
    const step = 1 / n;
    let flag = 1;
    while (t > step) {
        t -= step;
        flag *= -1;
    }
    const v = (flag * t) / step;
    return v > 0 ? v : 1 + v;
}
for (let i = 0; i < 10; i++) {
    Easing[`flicker${i}`] = (t) => flicker(t, i);
}
for (let i = 2; i < 10; i++) {
    Easing[`aIn${i}`] = (t) => i * t * t + (1 - i) * t;
}

function interpolateNumber(from, to, ratio) {
    return from + (to - from) * ratio;
}

class InterpolateUpdateStore {
    constructor() {
        this.opacity = (key, from, to, ratio, step, target) => {
            target.attribute.opacity = interpolateNumber(from, to, ratio);
        };
        this.baseOpacity = (key, from, to, ratio, step, target) => {
            target.attribute.baseOpacity = interpolateNumber(from, to, ratio);
        };
        this.fillOpacity = (key, from, to, ratio, step, target) => {
            target.attribute.fillOpacity = interpolateNumber(from, to, ratio);
        };
        this.strokeOpacity = (key, from, to, ratio, step, target) => {
            target.attribute.strokeOpacity = interpolateNumber(from, to, ratio);
        };
        this.zIndex = (key, from, to, ratio, step, target) => {
            target.attribute.zIndex = interpolateNumber(from, to, ratio);
        };
        this.backgroundOpacity = (key, from, to, ratio, step, target) => {
            target.attribute.backgroundOpacity = interpolateNumber(from, to, ratio);
        };
        this.shadowOffsetX = (key, from, to, ratio, step, target) => {
            target.attribute.shadowOffsetX = interpolateNumber(from, to, ratio);
        };
        this.shadowOffsetY = (key, from, to, ratio, step, target) => {
            target.attribute.shadowOffsetY = interpolateNumber(from, to, ratio);
        };
        this.shadowBlur = (key, from, to, ratio, step, target) => {
            target.attribute.shadowBlur = interpolateNumber(from, to, ratio);
        };
        this.fill = (key, from, to, ratio, step, target) => {
            target.attribute.fill = interpolateColor(from, to, ratio, false);
        };
        this.fillPure = (key, from, to, ratio, step, target) => {
            target.attribute.fill = step.fromParsedProps.fill
                ? interpolatePureColorArrayToStr(step.fromParsedProps.fill, step.toParsedProps.fill, ratio)
                : step.toParsedProps.fill;
        };
        this.stroke = (key, from, to, ratio, step, target) => {
            target.attribute.stroke = interpolateColor(from, to, ratio, false);
        };
        this.strokePure = (key, from, to, ratio, step, target) => {
            target.attribute.stroke = step.fromParsedProps.stroke
                ? interpolatePureColorArrayToStr(step.fromParsedProps.stroke, step.toParsedProps.stroke, ratio)
                : step.toParsedProps.stroke;
        };
        this.width = (key, from, to, ratio, step, target) => {
            target.attribute.width = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
        };
        this.height = (key, from, to, ratio, step, target) => {
            target.attribute.height = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
        };
        this.x = (key, from, to, ratio, step, target) => {
            target.attribute.x = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
            target.addUpdatePositionTag();
        };
        this.y = (key, from, to, ratio, step, target) => {
            target.attribute.y = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
            target.addUpdatePositionTag();
        };
        this.dx = (key, from, to, ratio, step, target) => {
            target.attribute.dx = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
            target.addUpdatePositionTag();
        };
        this.dy = (key, from, to, ratio, step, target) => {
            target.attribute.dy = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
            target.addUpdatePositionTag();
        };
        this.angle = (key, from, to, ratio, step, target) => {
            target.attribute.angle = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
            target.addUpdatePositionTag();
        };
        this.scaleX = (key, from, to, ratio, step, target) => {
            target.attribute.scaleX = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
            target.addUpdatePositionTag();
        };
        this.scaleY = (key, from, to, ratio, step, target) => {
            target.attribute.scaleY = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
            target.addUpdatePositionTag();
        };
        this.lineWidth = (key, from, to, ratio, step, target) => {
            target.attribute.lineWidth = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
        };
        this.startAngle = (key, from, to, ratio, step, target) => {
            target.attribute.startAngle = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
        };
        this.endAngle = (key, from, to, ratio, step, target) => {
            target.attribute.endAngle = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
        };
        this.radius = (key, from, to, ratio, step, target) => {
            target.attribute.radius = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
        };
        this.outerRadius = (key, from, to, ratio, step, target) => {
            target.attribute.outerRadius = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
        };
        this.innerRadius = (key, from, to, ratio, step, target) => {
            target.attribute.innerRadius = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
        };
        this.size = (key, from, to, ratio, step, target) => {
            target.attribute.size = interpolateNumber(from, to, ratio);
            target.addUpdateBoundTag();
        };
        this.points = (key, from, to, ratio, step, target) => {
            target.attribute.points = pointsInterpolation(from, to, ratio);
            target.addUpdateBoundTag();
        };
    }
}
const interpolateUpdateStore = new InterpolateUpdateStore();
function commonInterpolateUpdate(key, from, to, ratio, step, target) {
    if (Number.isFinite(to) && Number.isFinite(from)) {
        target.attribute[key] = from + (to - from) * ratio;
        return true;
    }
    else if (Array.isArray(to) && Array.isArray(from) && to.length === from.length) {
        const nextList = [];
        let valid = true;
        for (let i = 0; i < to.length; i++) {
            const v = from[i];
            const val = v + (to[i] - v) * ratio;
            if (!Number.isFinite(val)) {
                valid = false;
                break;
            }
            nextList.push(val);
        }
        if (valid) {
            target.attribute[key] = nextList;
        }
        return true;
    }
    return false;
}

function noop() {
}
class Step {
    constructor(type, props, duration, easing) {
        var _a;
        this._startTime = 0;
        this._hasFirstRun = false;
        this._syncAttributeUpdate = () => {
            this.target.setAttributes(this.target.attribute);
        };
        this.type = type;
        this.props = props;
        this.duration = duration;
        if (easing) {
            this.easing = typeof easing === 'function' ? easing : (_a = Easing[easing]) !== null && _a !== void 0 ? _a : Easing.linear;
        }
        else {
            this.easing = Easing.linear;
        }
        if (type === 'wait') {
            this.onUpdate = noop;
        }
        this.id = Generator.GenAutoIncrementId();
        this.syncAttributeUpdate = noop;
    }
    bind(target, animate) {
        this.target = target;
        this.animate = animate;
        this.onBind();
        this.syncAttributeUpdate();
    }
    append(step) {
        this.next = step;
        step.prev = this;
        step.setStartTime(this.getStartTime() + this.duration, false);
    }
    updateDownstreamStartTimes() {
        let currentStep = this.next;
        let currentStartTime = this._startTime + this.duration;
        while (currentStep) {
            currentStep.setStartTime(currentStartTime, false);
            currentStartTime += currentStep.duration;
            currentStep = currentStep.next;
        }
        this.animate.updateDuration();
    }
    getLastProps() {
        if (this.prev) {
            return this.prev.props || {};
        }
        return this.animate.getStartProps();
    }
    setDuration(duration, updateDownstream = true) {
        this.duration = duration;
        if (updateDownstream) {
            this.updateDownstreamStartTimes();
        }
    }
    getDuration() {
        return this.duration;
    }
    determineInterpolateUpdateFunction() {
        if (!this.props) {
            return;
        }
        const funcs = [];
        this.propKeys.forEach(key => {
            if (key === 'fill' || key === 'stroke') {
                const from = this.fromProps[key];
                const to = this.props[key];
                if (isString(from) && isString(to)) {
                    const fromArray = ColorStore.Get(from, ColorType.Color255);
                    const toArray = ColorStore.Get(to, ColorType.Color255);
                    if (!this.fromParsedProps) {
                        this.fromParsedProps = {};
                    }
                    if (!this.toParsedProps) {
                        this.toParsedProps = {};
                    }
                    this.fromParsedProps[key] = fromArray;
                    this.toParsedProps[key] = toArray;
                    funcs.push(interpolateUpdateStore[key === 'fill' ? 'fillPure' : 'strokePure']);
                }
                else if (interpolateUpdateStore[key]) {
                    funcs.push(interpolateUpdateStore[key]);
                }
                else {
                    funcs.push(commonInterpolateUpdate);
                }
            }
            else if (interpolateUpdateStore[key]) {
                funcs.push(interpolateUpdateStore[key]);
            }
            else {
                funcs.push(commonInterpolateUpdate);
            }
        });
        this.interpolateUpdateFunctions = funcs;
    }
    setStartTime(time, updateDownstream = true) {
        this._startTime = time;
        if (updateDownstream) {
            this.updateDownstreamStartTimes();
        }
    }
    getStartTime() {
        return this._startTime;
    }
    onBind() {
        if (this.target.type === 'glyph') {
            this.syncAttributeUpdate = this._syncAttributeUpdate;
        }
    }
    onFirstRun() {
    }
    onStart() {
        if (!this._hasFirstRun) {
            this._hasFirstRun = true;
            this.fromProps = this.getLastProps();
            const startProps = this.animate.getStartProps();
            this.propKeys &&
                this.propKeys.forEach(key => {
                    var _a;
                    this.fromProps[key] = (_a = this.fromProps[key]) !== null && _a !== void 0 ? _a : startProps[key];
                });
            this.determineInterpolateUpdateFunction();
            this.tryPreventConflict();
            this.trySyncStartProps();
            this.onFirstRun();
        }
    }
    tryPreventConflict() {
        const animate = this.animate;
        const target = this.target;
        target.animates.forEach((a) => {
            if (a === animate || a.priority > animate.priority || a.priority === Infinity) {
                return;
            }
            const fromProps = a.getStartProps();
            this.propKeys.forEach(key => {
                if (fromProps[key] != null) {
                    a.preventAttr(key);
                }
            });
        });
    }
    deleteSelfAttr(key) {
        var _a;
        delete this.props[key];
        this.fromProps && delete this.fromProps[key];
        const index = this.propKeys.indexOf(key);
        if (index !== -1) {
            this.propKeys.splice(index, 1);
            (_a = this.interpolateUpdateFunctions) === null || _a === void 0 ? void 0 : _a.splice(index, 1);
        }
    }
    trySyncStartProps() {
        this.propKeys.forEach(key => {
            this.fromProps[key] = this.animate.target.getComputedAttribute(key);
        });
    }
    update(end, ratio, out) {
        this.onStart();
        if (!this.props || !this.propKeys) {
            return;
        }
        const easedRatio = this.easing(ratio);
        this.animate.interpolateUpdateFunction
            ? this.animate.interpolateUpdateFunction(this.fromProps, this.props, easedRatio, this, this.target)
            : this.interpolateUpdateFunctions.forEach((func, index) => {
                if (!this.animate.validAttr(this.propKeys[index])) {
                    return;
                }
                const key = this.propKeys[index];
                const fromValue = this.fromProps[key];
                const toValue = this.props[key];
                func(key, fromValue, toValue, easedRatio, this, this.target);
            });
        this.onUpdate(end, easedRatio, out);
        this.syncAttributeUpdate();
    }
    onUpdate(end, ratio, out) {
    }
    onEnd(cb) {
        this.target.setAttributes(this.props);
        if (cb) {
            this._endCb = cb;
        }
        else if (this._endCb) {
            this._endCb(this.animate, this);
        }
    }
    getEndProps() {
        return this.props;
    }
    getFromProps() {
        return this.fromProps;
    }
    getMergedEndProps() {
        return this.getEndProps();
    }
    stop() {
    }
    release() {
    }
}
class WaitStep extends Step {
    constructor(type, props, duration, easing) {
        super(type, props, duration, easing);
    }
    onStart() {
        super.onStart();
        const fromProps = this.getFromProps();
        this.target.setAttributes(fromProps);
    }
    update(end, ratio, out) {
        this.onStart();
    }
    determineInterpolateUpdateFunction() {
        return;
    }
}

class DefaultTimeline extends EventEmitter {
    get animateCount() {
        return this._animateCount;
    }
    constructor() {
        super();
        this.head = null;
        this.tail = null;
        this.animateMap = new Map();
        this._animateCount = 0;
        this._playSpeed = 1;
        this._totalDuration = 0;
        this._startTime = 0;
        this._currentTime = 0;
        this._animationEndFlag = true;
        this.id = Generator.GenAutoIncrementId();
        this.paused = false;
    }
    isRunning() {
        return !this.paused && this._animateCount > 0;
    }
    forEachAccessAnimate(cb) {
        let current = this.head;
        let index = 0;
        while (current) {
            const next = current.next;
            cb(current.animate, index);
            index++;
            current = next;
        }
    }
    addAnimate(animate) {
        const newNode = {
            animate,
            next: null,
            prev: null
        };
        if (!this.head) {
            this.head = newNode;
            this.tail = newNode;
        }
        else {
            if (this.tail) {
                this.tail.next = newNode;
                newNode.prev = this.tail;
                this.tail = newNode;
            }
        }
        this.animateMap.set(animate, newNode);
        this._animateCount++;
        this._totalDuration = Math.max(this._totalDuration, animate.getStartTime() + animate.getDuration());
    }
    pause() {
        this.paused = true;
    }
    resume() {
        this.paused = false;
    }
    tick(delta) {
        if (this.paused) {
            return;
        }
        if (this._animationEndFlag) {
            this._animationEndFlag = false;
            this.emit('animationStart');
        }
        const scaledDelta = delta * this._playSpeed;
        this._currentTime += scaledDelta;
        this.forEachAccessAnimate((animate, i) => {
            if (animate.status === AnimateStatus.END) {
                this.removeAnimate(animate, true);
            }
            else if (animate.status === AnimateStatus.RUNNING || animate.status === AnimateStatus.INITIAL) {
                animate.advance(scaledDelta);
            }
        });
        if (this._animateCount === 0) {
            this._animationEndFlag = true;
            this.emit('animationEnd');
        }
    }
    clear() {
        this.forEachAccessAnimate(animate => {
            animate.release();
        });
        this.head = null;
        this.tail = null;
        this.animateMap.clear();
        this._animateCount = 0;
        this._totalDuration = 0;
    }
    removeAnimate(animate, release = true) {
        const node = this.animateMap.get(animate);
        if (!node) {
            return;
        }
        if (release) {
            animate._onRemove && animate._onRemove.forEach(cb => cb());
            animate.release();
        }
        if (node.prev) {
            node.prev.next = node.next;
        }
        else {
            this.head = node.next;
        }
        if (node.next) {
            node.next.prev = node.prev;
        }
        else {
            this.tail = node.prev;
        }
        this.animateMap.delete(animate);
        this._animateCount--;
        if (animate.getStartTime() + animate.getDuration() >= this._totalDuration) {
            this.recalculateTotalDuration();
        }
        return;
    }
    recalculateTotalDuration() {
        this._totalDuration = 0;
        this.forEachAccessAnimate(animate => {
            this._totalDuration = Math.max(this._totalDuration, animate.getStartTime() + animate.getDuration());
        });
    }
    getTotalDuration() {
        return this._totalDuration;
    }
    getPlaySpeed() {
        return this._playSpeed;
    }
    setPlaySpeed(speed) {
        this._playSpeed = speed;
    }
    getPlayState() {
        if (this.paused) {
            return 'paused';
        }
        if (this.animateCount === 0) {
            return 'stopped';
        }
        return 'playing';
    }
    setStartTime(time) {
        this._startTime = time;
    }
    getStartTime() {
        return this._startTime;
    }
    getCurrentTime() {
        return this._currentTime;
    }
    setCurrentTime(time) {
        this._currentTime = time;
    }
}
const defaultTimeline = new DefaultTimeline();
defaultTimeline.isGlobal = true;

class Animate {
    constructor(id = Generator.GenAutoIncrementId(), timeline = defaultTimeline, slience) {
        this.id = id;
        this.status = AnimateStatus.INITIAL;
        this._timeline = timeline;
        timeline.addAnimate(this);
        this.slience = slience;
        this._startTime = 0;
        this._duration = 0;
        this._totalDuration = 0;
        this._loopCount = 0;
        this._currentLoop = 0;
        this._bounce = false;
        this._firstStep = null;
        this._lastStep = null;
        this._startProps = {};
        this._endProps = {};
        this._preventAttrs = new Set();
        this.currentTime = 0;
        this.interpolateUpdateFunction = null;
        this.priority = 0;
    }
    getStartProps() {
        return this._startProps;
    }
    getEndProps() {
        return this._endProps;
    }
    setTimeline(timeline) {
        this._timeline = timeline;
    }
    getTimeline() {
        return this._timeline;
    }
    get timeline() {
        return this._timeline;
    }
    bind(target) {
        this.target = target;
        if (!this.target.animates) {
            this.target.animates = new Map();
        }
        this.target.animates.set(this.id, this);
        this.onRemove(() => {
            this.stop();
            this.target.animates.delete(this.id);
        });
        if (this.target.onAnimateBind && !this.slience) {
            this.target.onAnimateBind(this);
        }
        if (!this.target.animationAttribute) {
            this.target.animationAttribute = {};
        }
        return this;
    }
    to(props, duration = 300, easing = 'linear') {
        const step = new Step(AnimateStepType.to, props, duration, easing);
        step.bind(this.target, this);
        this.updateStepAfterAppend(step);
        return this;
    }
    wait(delay) {
        const step = new WaitStep(AnimateStepType.wait, {}, delay, 'linear');
        step.bind(this.target, this);
        this.updateStepAfterAppend(step);
        return this;
    }
    updateStepAfterAppend(step) {
        if (!this._firstStep) {
            this._firstStep = step;
            this._lastStep = step;
        }
        else {
            this._lastStep.append(step);
            this._lastStep = step;
        }
        this.parseStepProps(step);
        this.updateDuration();
    }
    parseStepProps(step) {
        if (!this._lastStep) {
            return;
        }
        step.propKeys = step.propKeys || Object.keys(step.props);
        Object.keys(this._endProps).forEach(key => {
            var _a;
            step.props[key] = (_a = step.props[key]) !== null && _a !== void 0 ? _a : this._endProps[key];
        });
        step.propKeys.forEach(key => {
            this._endProps[key] = step.props[key];
        });
    }
    reSyncProps() {
        if (!this._lastStep) {
            return;
        }
        this._endProps = {};
        let currentStep = this._firstStep;
        while (currentStep) {
            Object.keys(this._endProps).forEach(key => {
                var _a;
                currentStep.props[key] = (_a = currentStep.props[key]) !== null && _a !== void 0 ? _a : this._endProps[key];
            });
            currentStep.propKeys.forEach(key => {
                this._endProps[key] = currentStep.props[key];
            });
            currentStep = currentStep.next;
        }
    }
    from(props, duration = 300, easing = 'linear') {
        const step = new Step(AnimateStepType.from, props, duration, easing);
        if (!this._firstStep) {
            this._firstStep = step;
            this._lastStep = step;
        }
        else {
            this._lastStep.append(step);
            this._lastStep = step;
        }
        this.updateDuration();
        return this;
    }
    play(customAnimate) {
        customAnimate.bind(this.target, this);
        this.updateStepAfterAppend(customAnimate);
        return this;
    }
    pause() {
        if (this.status === AnimateStatus.RUNNING) {
            this.status = AnimateStatus.PAUSED;
        }
    }
    resume() {
        if (this.status === AnimateStatus.PAUSED) {
            this.status = AnimateStatus.RUNNING;
        }
    }
    onStart(cb) {
        var _a;
        if (cb) {
            if (!this._onStart) {
                this._onStart = [];
            }
            this._onStart.push(cb);
        }
        else {
            (_a = this._onStart) === null || _a === void 0 ? void 0 : _a.forEach(cb => cb());
            Object.keys(this._endProps).forEach(key => {
                this._startProps[key] = this.target.getComputedAttribute(key);
            });
        }
    }
    onEnd(cb) {
        var _a;
        if (cb) {
            if (!this._onEnd) {
                this._onEnd = [];
            }
            this._onEnd.push(cb);
        }
        else {
            (_a = this._onEnd) === null || _a === void 0 ? void 0 : _a.forEach(cb => cb());
        }
    }
    onFrame(cb) {
        if (cb) {
            if (!this._onFrame) {
                this._onFrame = [];
            }
            this._onFrame.push(cb);
        }
    }
    onRemove(cb) {
        var _a;
        if (cb) {
            if (!this._onRemove) {
                this._onRemove = [];
            }
            this._onRemove.push(cb);
        }
        else {
            (_a = this._onRemove) === null || _a === void 0 ? void 0 : _a.forEach(cb => cb());
        }
    }
    preventAttr(key) {
        this._preventAttrs.add(key);
        delete this._startProps[key];
        delete this._endProps[key];
        let step = this._firstStep;
        while (step) {
            step.deleteSelfAttr(key);
            step = step.next;
        }
    }
    preventAttrs(keys) {
        keys.forEach(key => this._preventAttrs.add(key));
    }
    validAttr(key) {
        return !this._preventAttrs.has(key);
    }
    runCb(cb) {
        var _a;
        (_a = this._lastStep) === null || _a === void 0 ? void 0 : _a.onEnd(cb);
        return this;
    }
    startAt(t) {
        this._startTime = t;
        return this;
    }
    customInterpolate(key, ratio, from, to, target, ret) {
        return false;
    }
    getFromValue() {
        return this._startProps;
    }
    getToValue() {
        return this._endProps;
    }
    stop(type) {
        let step = this._firstStep;
        while (step) {
            step.stop();
            step = step.next;
        }
        if (this.status !== AnimateStatus.END) {
            this.onEnd();
        }
        this.status = AnimateStatus.END;
        if (!this.target) {
            return;
        }
        if (type === 'start') {
            this.target.setAttributes(this._startProps);
        }
        else if (type === 'end') {
            this.target.setAttributes(this._endProps);
        }
        else if (type) {
            this.target.setAttributes(type);
        }
    }
    release() {
        this.status = AnimateStatus.END;
        if (this._onRemove) {
            this._onRemove.forEach(cb => cb());
        }
        this._onStart = [];
        this._onFrame = [];
        this._onEnd = [];
        this._onRemove = [];
        this.forEachStep(step => {
            step.release();
        });
    }
    getDuration() {
        return this._duration;
    }
    getStartTime() {
        return this._startTime;
    }
    afterAll(list) {
        if (!list || list.length === 0) {
            return this;
        }
        let maxEndTime = 0;
        list.forEach(animate => {
            const endTime = animate.getStartTime() + animate.getTotalDuration();
            maxEndTime = Math.max(maxEndTime, endTime);
        });
        return this.startAt(maxEndTime);
    }
    after(animate) {
        if (!animate) {
            return this;
        }
        const endTime = animate.getStartTime() + animate.getTotalDuration();
        return this.startAt(endTime);
    }
    parallel(animate) {
        if (!animate) {
            return this;
        }
        this.startAt(animate.getStartTime());
        return this;
    }
    loop(n) {
        if (n === true) {
            n = Infinity;
        }
        else if (n === false) {
            n = 0;
        }
        this._loopCount = n;
        this.updateDuration();
        return this;
    }
    bounce(b) {
        this._bounce = b;
        return this;
    }
    advance(delta) {
        var _a, _b, _c;
        if (this.status === AnimateStatus.END) {
            console.warn('aaa 动画已经结束，不能推进');
            return;
        }
        const nextTime = this.currentTime + delta;
        if (nextTime < this._startTime) {
            this.currentTime = nextTime;
            return;
        }
        if (nextTime >= this._startTime + this._totalDuration) {
            (_a = this._lastStep) === null || _a === void 0 ? void 0 : _a.onUpdate(true, 1, {});
            (_b = this._lastStep) === null || _b === void 0 ? void 0 : _b.onEnd();
            this.onEnd();
            this.status = AnimateStatus.END;
            return;
        }
        this.status = AnimateStatus.RUNNING;
        if (this.currentTime <= this._startTime) {
            this.onStart();
        }
        this.currentTime = nextTime;
        let cycleTime = nextTime - this._startTime;
        let newLoop = false;
        let bounceTime = false;
        if (this._loopCount > 0) {
            cycleTime = (nextTime - this._startTime) % this._duration;
            const currentLoop = Math.floor((nextTime - this._startTime) / this._duration);
            newLoop = currentLoop > this._currentLoop;
            this._currentLoop = currentLoop;
            bounceTime = this._bounce && currentLoop % 2 === 1;
            if (bounceTime) {
                cycleTime = this._duration - cycleTime;
            }
        }
        if (newLoop && !bounceTime) {
            this.target.setAttributes(this._startProps);
        }
        let targetStep = null;
        if (this._lastStep === this._firstStep) {
            targetStep = this._firstStep;
        }
        else {
            let currentStep = this._firstStep;
            while (currentStep) {
                const stepStartTime = currentStep.getStartTime();
                const stepDuration = currentStep.getDuration();
                const stepEndTime = stepStartTime + stepDuration;
                if (cycleTime >= stepStartTime && cycleTime <= stepEndTime) {
                    targetStep = currentStep;
                    break;
                }
                currentStep = currentStep.next;
            }
        }
        if (!targetStep) {
            return;
        }
        if (targetStep !== this.lastRunStep) {
            (_c = this.lastRunStep) === null || _c === void 0 ? void 0 : _c.onEnd();
        }
        this.lastRunStep = targetStep;
        const stepStartTime = targetStep.getStartTime();
        const stepDuration = targetStep.getDuration();
        const ratio = (cycleTime - stepStartTime) / stepDuration;
        const isEnd = ratio >= 1;
        targetStep.update(isEnd, ratio, {});
        if (isEnd) {
            targetStep.onEnd();
            this.lastRunStep = null;
        }
    }
    updateDuration() {
        if (!this._lastStep) {
            this._duration = 0;
            return;
        }
        this._duration = this._lastStep.getStartTime() + this._lastStep.getDuration();
        this._totalDuration = this._duration * (this._loopCount + 1);
    }
    getTotalDuration() {
        return this._totalDuration;
    }
    getLoop() {
        return this._loopCount;
    }
    forEachStep(cb) {
        let step = this._firstStep;
        while (step) {
            cb(step);
            step = step.next;
        }
    }
}

const performanceRAF = new PerformanceRAF();
class RAFTickHandler {
    constructor() {
        this.released = false;
    }
    tick(interval, cb) {
        performanceRAF.addAnimationFrameCb(() => {
            if (this.released) {
                return;
            }
            return cb(this);
        });
    }
    release() {
        this.released = true;
    }
    getTime() {
        return Date.now();
    }
}
class DefaultTicker extends EventEmitter {
    constructor(stage) {
        super();
        this.timelines = [];
        this.frameTimeHistory = [];
        this.handleTick = (handler, params) => {
            const { once = false } = params !== null && params !== void 0 ? params : {};
            if (this.ifCanStop()) {
                this.stop();
                return false;
            }
            const currentTime = handler.getTime();
            this._lastTickTime = currentTime;
            if (this.lastFrameTime < 0) {
                this.lastFrameTime = currentTime - this.interval + this.timeOffset;
                this.frameTimeHistory.push(this.lastFrameTime);
            }
            const delta = currentTime - this.lastFrameTime;
            const skip = this.checkSkip(delta);
            if (!skip) {
                this._handlerTick(delta);
                this.lastFrameTime = currentTime;
                this.frameTimeHistory.push(this.lastFrameTime);
            }
            if (!once) {
                handler.tick(this.interval, this.handleTick);
            }
            return !skip;
        };
        this._handlerTick = (delta) => {
            if (this.status !== STATUS.RUNNING) {
                return;
            }
            this.tickCounts++;
            this.timelines.forEach(timeline => {
                timeline.tick(delta);
            });
            this.emit('tick', delta);
        };
        this.init();
        this.lastFrameTime = -1;
        this.tickCounts = 0;
        this.stage = stage;
        this.autoStop = true;
        this.interval = 16;
        this.computeTimeOffsetAndJitter();
    }
    bindStage(stage) {
        this.stage = stage;
    }
    computeTimeOffsetAndJitter() {
        this.timeOffset = Math.floor(Math.random() * this.interval);
        this._jitter = Math.min(Math.max(this.interval * 0.2, 6), this.interval * 0.7);
    }
    init() {
        this.interval = 16;
        this.status = STATUS.INITIAL;
        application.global.hooks.onSetEnv.tap('graph-ticker', () => {
            this.initHandler(false);
        });
        if (application.global.env) {
            this.initHandler(false);
        }
    }
    addTimeline(timeline) {
        this.timelines.push(timeline);
    }
    remTimeline(timeline) {
        this.timelines = this.timelines.filter(t => t !== timeline);
    }
    getTimelines() {
        return this.timelines;
    }
    initHandler(force = false) {
        this.setupTickHandler(force);
    }
    setupTickHandler(force = false) {
        if (!force && this.tickerHandler) {
            return true;
        }
        const handler = new RAFTickHandler();
        if (this.tickerHandler) {
            this.tickerHandler.release();
        }
        this.tickerHandler = handler;
        return true;
    }
    setInterval(interval) {
        this.interval = interval;
        this.computeTimeOffsetAndJitter();
    }
    getInterval() {
        return this.interval;
    }
    setFPS(fps) {
        this.setInterval(Math.floor(1000 / fps));
    }
    getFPS() {
        return 1000 / this.interval;
    }
    tick(interval) {
        this.tickerHandler.tick(interval, (handler) => {
            return this.handleTick(handler, { once: true });
        });
    }
    tickTo(t) {
        if (!this.tickerHandler.tickTo) {
            return;
        }
        this.tickerHandler.tickTo(t, (handler) => {
            this.handleTick(handler, { once: true });
        });
    }
    pause() {
        if (this.status === STATUS.INITIAL) {
            return false;
        }
        this.status = STATUS.PAUSE;
        return true;
    }
    resume() {
        if (this.status === STATUS.INITIAL) {
            return false;
        }
        this.status = STATUS.RUNNING;
        return true;
    }
    ifCanStop() {
        if (this.autoStop) {
            if (!this.timelines.length) {
                return true;
            }
            if (this.timelines.every(timeline => !timeline.isRunning())) {
                return true;
            }
        }
        return false;
    }
    start(force = false) {
        if (this.status === STATUS.RUNNING) {
            return false;
        }
        if (!this.tickerHandler) {
            return false;
        }
        if (!force) {
            if (this.status === STATUS.PAUSE) {
                return false;
            }
            if (this.ifCanStop()) {
                return false;
            }
        }
        this.status = STATUS.RUNNING;
        this.tickerHandler.tick(0, this.handleTick);
        return true;
    }
    stop() {
        this.status = STATUS.INITIAL;
        this.setupTickHandler(true);
        this.lastFrameTime = -1;
    }
    trySyncTickStatus() {
        if (this.status === STATUS.INITIAL && this.timelines.some(timeline => timeline.isRunning())) {
            this.start();
        }
        else if (this.status === STATUS.RUNNING && this.timelines.every(timeline => !timeline.isRunning())) {
            this.stop();
        }
    }
    release() {
        var _a;
        this.stop();
        this.timelines = [];
        (_a = this.tickerHandler) === null || _a === void 0 ? void 0 : _a.release();
        this.tickerHandler = null;
        this.lastFrameTime = -1;
    }
    checkSkip(delta) {
        var _a, _b, _c;
        if (((_c = (_b = (_a = this.stage) === null || _a === void 0 ? void 0 : _a.params) === null || _b === void 0 ? void 0 : _b.optimize) === null || _c === void 0 ? void 0 : _c.tickRenderMode) === 'performance') {
            return false;
        }
        const skip = delta < this.interval + (Math.random() - 0.5) * 2 * this._jitter;
        return skip;
    }
}

class ManualTickHandler {
    constructor() {
        this.released = false;
        this.currentTime = -1;
    }
    tick(interval, cb) {
        if (this.currentTime < 0) {
            this.currentTime = 0;
        }
        this.currentTime += interval;
        cb(this);
    }
    release() {
        this.released = true;
    }
    getTime() {
        return this.currentTime;
    }
    tickTo(time, cb) {
        if (this.currentTime < 0) {
            this.currentTime = 0;
        }
        const interval = time - this.currentTime;
        this.tick(interval, cb);
    }
}
class ManualTicker extends DefaultTicker {
    constructor(stage) {
        super(stage);
        this.lastFrameTime = 0;
        this.status = STATUS.RUNNING;
    }
    setupTickHandler() {
        const handler = new ManualTickHandler();
        if (this.tickerHandler) {
            this.tickerHandler.release();
        }
        this.tickerHandler = handler;
        return true;
    }
    checkSkip(delta) {
        return false;
    }
    getTime() {
        return this.tickerHandler.getTime();
    }
    tickAt(time) {
        this.tickTo(time);
    }
    start(force = false) {
        if (this.status === STATUS.RUNNING) {
            return false;
        }
        if (!this.tickerHandler) {
            return false;
        }
        if (!force) {
            if (this.status === STATUS.PAUSE) {
                return false;
            }
            if (this.ifCanStop()) {
                return false;
            }
        }
        this.status = STATUS.RUNNING;
        return true;
    }
}

function generatorPathEasingFunc(path) {
    const customPath = new CustomPath2D();
    customPath.setCtx(new CurveContext(customPath));
    customPath.fromString(path, 0, 0, 1, 1);
    return (x) => {
        return customPath.getYAt(x);
    };
}

class AnimationTransitionRegistry {
    constructor() {
        this.transitions = new Map();
        this.registerDefaultTransitions();
    }
    static getInstance() {
        if (!AnimationTransitionRegistry.instance) {
            AnimationTransitionRegistry.instance = new AnimationTransitionRegistry();
        }
        return AnimationTransitionRegistry.instance;
    }
    registerDefaultTransitions() {
        this.registerTransition('appear', '*', () => ({
            allowTransition: true,
            stopOriginalTransition: false
        }));
        this.registerTransition('appear', 'appear', () => ({
            allowTransition: false,
            stopOriginalTransition: false
        }));
        this.registerTransition('appear', 'disappear', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
        this.registerTransition('appear', 'exit', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
        this.registerTransition('normal', '*', () => ({
            allowTransition: true,
            stopOriginalTransition: false
        }));
        this.registerTransition('normal', 'normal', () => ({
            allowTransition: false,
            stopOriginalTransition: false
        }));
        this.registerTransition('normal', 'disappear', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
        this.registerTransition('normal', 'exit', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
        this.registerTransition('exit', '*', () => ({
            allowTransition: false,
            stopOriginalTransition: false
        }));
        this.registerTransition('exit', 'disappear', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
        this.registerTransition('exit', 'enter', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
        this.registerTransition('exit', 'exit', () => ({
            allowTransition: false,
            stopOriginalTransition: false
        }));
        this.registerTransition('enter', '*', () => ({
            allowTransition: true,
            stopOriginalTransition: false
        }));
        this.registerTransition('enter', 'enter', () => ({
            allowTransition: false,
            stopOriginalTransition: false
        }));
        this.registerTransition('enter', 'disappear', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
        this.registerTransition('enter', 'exit', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
        this.registerTransition('disappear', '*', () => ({
            allowTransition: false,
            stopOriginalTransition: false
        }));
        this.registerTransition('disappear', 'appear', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
        this.registerTransition('update', '*', () => ({
            allowTransition: true,
            stopOriginalTransition: false
        }));
        this.registerTransition('update', 'disappear', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
        this.registerTransition('update', 'exit', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
        this.registerTransition('state', '*', () => ({
            allowTransition: true,
            stopOriginalTransition: false
        }));
        this.registerTransition('state', 'disappear', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
        this.registerTransition('state', 'exit', () => ({
            allowTransition: true,
            stopOriginalTransition: true
        }));
    }
    isTransitionAllowed(fromState, toState, graphic) {
        var _a, _b, _c, _d;
        let func = (_a = this.transitions.get(fromState)) === null || _a === void 0 ? void 0 : _a.get(toState);
        if (func) {
            return func(graphic, fromState);
        }
        func = (_b = this.transitions.get(fromState)) === null || _b === void 0 ? void 0 : _b.get('*');
        if (func) {
            return func(graphic, fromState);
        }
        func = (_c = this.transitions.get('*')) === null || _c === void 0 ? void 0 : _c.get(toState);
        if (func) {
            return func(graphic, fromState);
        }
        func = (_d = this.transitions.get('*')) === null || _d === void 0 ? void 0 : _d.get('*');
        if (func) {
            return func(graphic, fromState);
        }
        return {
            allowTransition: true,
            stopOriginalTransition: true
        };
    }
    registerTransition(fromState, toState, transition) {
        let fromStateMap = this.transitions.get(fromState);
        if (!fromStateMap) {
            fromStateMap = new Map();
            this.transitions.set(fromState, fromStateMap);
        }
        fromStateMap.set(toState, transition);
    }
}
const transitionRegistry = AnimationTransitionRegistry.getInstance();

class AnimateExecutor {
    static registerBuiltInAnimate(name, animate) {
        AnimateExecutor.builtInAnimateMap[name] = animate;
    }
    constructor(target) {
        this._animates = [];
        this._startCallbacks = [];
        this._endCallbacks = [];
        this._started = false;
        this._activeCount = 0;
        this._target = target;
    }
    get started() {
        return this._started;
    }
    onStart(cb) {
        if (cb) {
            this._startCallbacks.push(cb);
            if (this._started && this._activeCount > 0) {
                cb();
            }
        }
        else {
            this._startCallbacks.forEach(cb => {
                cb();
            });
        }
    }
    onEnd(cb) {
        if (cb) {
            this._endCallbacks.push(cb);
        }
        else {
            this._endCallbacks.forEach(cb => {
                cb();
            });
        }
    }
    _trackAnimation(animate) {
        this._animates.push(animate);
        this._activeCount++;
        if (this._activeCount === 1 && !this._started) {
            this._started = true;
            this.onStart();
        }
        animate.onEnd(() => {
            this._activeCount--;
            const index = this._animates.indexOf(animate);
            if (index >= 0) {
                this._animates.splice(index, 1);
            }
            if (this._activeCount === 0 && this._started) {
                this._started = false;
                this.onEnd();
            }
        });
    }
    parseParams(params, isTimeline, child) {
        var _a, _b;
        const totalTime = this.resolveValue(params.totalTime, undefined, undefined);
        const startTime = this.resolveValue(params.startTime, undefined, 0);
        const parsedParams = Object.assign({}, params);
        parsedParams.oneByOneDelay = 0;
        parsedParams.startTime = startTime;
        parsedParams.totalTime = totalTime;
        const oneByOne = this.resolveValue(params.oneByOne, child, false);
        if (isTimeline) {
            const timeSlices = parsedParams.timeSlices;
            if (!isArray(timeSlices)) {
                parsedParams.timeSlices = [timeSlices];
            }
            let sliceTime = 0;
            parsedParams.timeSlices = parsedParams.timeSlices.map(slice => {
                const delay = this.resolveValue(slice.delay, child, 0);
                const delayAfter = this.resolveValue(slice.delayAfter, child, 0);
                const duration = this.resolveValue(slice.duration, child, 300);
                sliceTime += delay + duration + delayAfter;
                return Object.assign(Object.assign({}, slice), { delay,
                    delayAfter,
                    duration });
            });
            let oneByOneDelay = 0;
            if (oneByOne) {
                oneByOneDelay = typeof oneByOne === 'number' ? oneByOne : oneByOne ? sliceTime : 0;
            }
            parsedParams.oneByOneDelay = oneByOneDelay;
            let scale = 1;
            if (totalTime) {
                const _totalTime = sliceTime + oneByOneDelay * (this._target.count - 2);
                scale = totalTime ? totalTime / _totalTime : 1;
            }
            parsedParams.timeSlices = parsedParams.timeSlices.map(slice => {
                let effects = slice.effects;
                if (!Array.isArray(effects)) {
                    effects = [effects];
                }
                return Object.assign(Object.assign({}, slice), { delay: slice.delay * scale, delayAfter: slice.delayAfter * scale, duration: slice.duration * scale, effects: effects.map(effect => {
                        var _a, _b;
                        const custom = (_a = effect.custom) !== null && _a !== void 0 ? _a : AnimateExecutor.builtInAnimateMap[(_b = effect.type) !== null && _b !== void 0 ? _b : 'fromTo'];
                        const customType = custom && isFunction(custom) ? (/^class\s/.test(Function.prototype.toString.call(custom)) ? 1 : 2) : 0;
                        return Object.assign(Object.assign({}, effect), { custom,
                            customType });
                    }) });
            });
            parsedParams.oneByOneDelay = oneByOneDelay * scale;
            parsedParams.startTime = startTime * scale;
        }
        else {
            const delay = this.resolveValue(params.delay, child, 0);
            const delayAfter = this.resolveValue(params.delayAfter, child, 0);
            const duration = this.resolveValue(params.duration, child, 300);
            const loopTime = delay + delayAfter + duration;
            let oneByOneDelay = 0;
            if (oneByOne) {
                oneByOneDelay = typeof oneByOne === 'number' ? oneByOne : oneByOne ? loopTime : 0;
            }
            parsedParams.oneByOneDelay = oneByOneDelay;
            parsedParams.custom =
                (_a = params.custom) !== null && _a !== void 0 ? _a : AnimateExecutor.builtInAnimateMap[(_b = params.type) !== null && _b !== void 0 ? _b : 'fromTo'];
            const customType = parsedParams.custom && isFunction(parsedParams.custom)
                ? /^class\s/.test(Function.prototype.toString.call(parsedParams.custom))
                    ? 1
                    : 2
                : 0;
            parsedParams.customType = customType;
            if (totalTime) {
                const _totalTime = delay + delayAfter + duration + oneByOneDelay * (this._target.count - 2);
                const scale = totalTime ? totalTime / _totalTime : 1;
                parsedParams.delay = delay * scale;
                parsedParams.delayAfter = delayAfter * scale;
                parsedParams.duration = duration * scale;
                parsedParams.oneByOneDelay = oneByOneDelay * scale;
                parsedParams.startTime = startTime;
            }
        }
        return parsedParams;
    }
    execute(params) {
        if (Array.isArray(params)) {
            params.forEach(param => this._execute(param));
        }
        else {
            this._execute(params);
        }
    }
    _execute(params) {
        if (params.selfOnly) {
            return this._executeItem(params, this._target, 0, 1);
        }
        const isTimeline = 'timeSlices' in params;
        let filteredChildren;
        if (isTimeline && params.partitioner) {
            filteredChildren = (filteredChildren !== null && filteredChildren !== void 0 ? filteredChildren : this._target.getChildren()).filter(child => {
                var _a, _b;
                return params.partitioner((_b = (_a = child.context) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b[0], child, {});
            });
        }
        if (isTimeline && params.sort) {
            filteredChildren = filteredChildren !== null && filteredChildren !== void 0 ? filteredChildren : this._target.getChildren();
            filteredChildren.sort((a, b) => {
                var _a, _b, _c, _d;
                return params.sort((_b = (_a = a.context) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b[0], (_d = (_c = b.context) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[0], a, b, {});
            });
        }
        const cb = isTimeline
            ? (child, index, count) => {
                const parsedParams = this.parseParams(params, isTimeline, child);
                const animate = this.executeTimelineItem(parsedParams, child, index, count);
                if (animate) {
                    this._trackAnimation(animate);
                }
            }
            : (child, index, count) => {
                const parsedParams = this.parseParams(params, isTimeline, child);
                const animate = this.executeTypeConfigItem(parsedParams, child, index, count);
                if (animate) {
                    this._trackAnimation(animate);
                }
            };
        if (filteredChildren) {
            filteredChildren.forEach((child, index) => cb(child, index, filteredChildren.length));
        }
        else if (this._target.count <= 1) {
            cb(this._target, 0, 1);
        }
        else {
            this._target.forEachChildren((child, index) => cb(child, index, this._target.count - 1));
        }
        return;
    }
    executeTypeConfigItem(params, graphic, index, count) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const { type = 'fromTo', channel, customParameters, easing = 'linear', delay = 0, delayAfter = 0, duration = 300, startTime = 0, oneByOneDelay = 0, loop, bounce, priority = 0, options, custom, customType, controlOptions } = params;
        const animate = graphic.animate();
        animate.priority = priority;
        const delayValue = isFunction(delay) ? delay((_b = (_a = graphic.context) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b[0], graphic, {}) : delay;
        const datum = (_d = (_c = graphic.context) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[0];
        const indexKey = (_e = graphic.context) === null || _e === void 0 ? void 0 : _e.indexKey;
        if (datum && indexKey) {
            index = (_f = datum[indexKey]) !== null && _f !== void 0 ? _f : index;
        }
        animate.startAt(startTime);
        const wait = index * oneByOneDelay + delayValue;
        wait > 0 && animate.wait(wait);
        let parsedFromProps = null;
        let props = params.to;
        let from = params.from;
        if (!props) {
            if (!parsedFromProps) {
                parsedFromProps = this.createPropsFromChannel(channel, graphic);
            }
            props = parsedFromProps.props;
        }
        if (!from) {
            if (!parsedFromProps) {
                parsedFromProps = this.createPropsFromChannel(channel, graphic);
            }
            from = parsedFromProps.from;
        }
        this._handleRunAnimate(animate, custom, customType, from, props, duration, easing, customParameters, controlOptions, options, type, graphic);
        let totalDelay = 0;
        if (oneByOneDelay) {
            totalDelay = oneByOneDelay * (count - index - 1);
        }
        const delayAfterValue = isFunction(delayAfter) ? delayAfter((_h = (_g = graphic.context) === null || _g === void 0 ? void 0 : _g.data) === null || _h === void 0 ? void 0 : _h[0], graphic, {}) : delayAfter;
        if (delayAfterValue > 0) {
            totalDelay += delayAfterValue;
        }
        if (totalDelay > 0) {
            animate.wait(totalDelay);
        }
        if (loop && loop > 0) {
            animate.loop(loop);
        }
        if (bounce) {
            animate.bounce(true);
        }
        return animate;
    }
    _handleRunAnimate(animate, custom, customType, from, props, duration, easing, customParameters, controlOptions, options, type, graphic) {
        var _a, _b, _c, _d, _e, _f;
        if (custom && customType) {
            const customParams = Object.assign({ width: ((_a = graphic.stage) === null || _a === void 0 ? void 0 : _a.width) || 0, height: ((_b = graphic.stage) === null || _b === void 0 ? void 0 : _b.height) || 0, group: this._target.parent }, this.resolveValue(customParameters, graphic));
            const objOptions = isFunction(options)
                ? options.call(null, (_d = (customParams && ((_c = customParams.data) === null || _c === void 0 ? void 0 : _c[0]))) !== null && _d !== void 0 ? _d : (_f = (_e = graphic.context) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f[0], graphic, customParams)
                : options;
            customParams.options = objOptions;
            customParams.controlOptions = controlOptions;
            if (customType === 1) {
                this.createCustomAnimation(animate, custom, from, props, duration, easing, customParams);
            }
            else if (customType === 2) {
                this.createCustomInterpolatorAnimation(animate, custom, props, duration, easing, customParams);
            }
        }
        else if (type === 'to') {
            animate.to(props, duration, easing);
        }
        else if (type === 'from') {
            animate.from(props, duration, easing);
        }
    }
    executeTimelineItem(params, graphic, index, count) {
        var _a, _b, _c, _d;
        const { timeSlices, startTime = 0, loop, bounce, oneByOneDelay, priority, controlOptions } = params;
        const datum = (_b = (_a = graphic.context) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b[0];
        const indexKey = (_c = graphic.context) === null || _c === void 0 ? void 0 : _c.indexKey;
        if (datum && indexKey) {
            index = (_d = datum[indexKey]) !== null && _d !== void 0 ? _d : index;
        }
        const animate = graphic.animate();
        animate.priority = priority;
        animate.startAt(startTime);
        animate.wait(index * oneByOneDelay);
        if (loop && loop > 0) {
            animate.loop(loop);
        }
        if (bounce) {
            animate.bounce(true);
        }
        const slices = Array.isArray(timeSlices) ? timeSlices : [timeSlices];
        slices.forEach(slice => {
            this.applyTimeSliceToAnimate(slice, animate, graphic, controlOptions);
        });
        if (oneByOneDelay) {
            animate.wait(oneByOneDelay * (count - index - 1));
        }
        return animate;
    }
    applyTimeSliceToAnimate(slice, animate, graphic, controlOptions) {
        var _a, _b, _c, _d;
        const { effects, duration = 300, delay = 0, delayAfter = 0 } = slice;
        const delayValue = isFunction(delay) ? delay((_b = (_a = graphic.context) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b[0], graphic, {}) : delay;
        const delayAfterValue = isFunction(delayAfter) ? delayAfter((_d = (_c = graphic.context) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[0], graphic, {}) : delayAfter;
        if (delayValue > 0) {
            animate.wait(delayValue);
        }
        const effectsArray = Array.isArray(effects) ? effects : [effects];
        effectsArray.forEach(effect => {
            var _a;
            const { type = 'fromTo', channel, customParameters, easing = 'linear', options } = effect;
            let parsedFromProps = null;
            let props = effect.to;
            let from = effect.from;
            if (!props) {
                if (!parsedFromProps) {
                    parsedFromProps = this.createPropsFromChannel(channel, graphic);
                }
                props = parsedFromProps.props;
            }
            if (!from) {
                if (!parsedFromProps) {
                    parsedFromProps = this.createPropsFromChannel(channel, graphic);
                }
                from = parsedFromProps.from;
            }
            const custom = (_a = effect.custom) !== null && _a !== void 0 ? _a : AnimateExecutor.builtInAnimateMap[type];
            const customType = effect.customType;
            this._handleRunAnimate(animate, custom, customType, from, props, duration, easing, customParameters, controlOptions, options, type, graphic);
        });
        if (delayAfterValue > 0) {
            animate.wait(delayAfterValue);
        }
    }
    createCustomInterpolatorAnimation(animate, interpolator, props, duration, easing, customParams) {
        const to = props;
        Object.keys(to).forEach(key => {
            animate.target.getComputedAttribute(key);
        });
        animate.interpolateUpdateFunction = (from, to, ratio, step, target) => {
            interpolator(ratio, from, to, step, target, animate.target, customParams);
        };
        animate.to(props, duration, easing);
    }
    createCustomAnimation(animate, CustomAnimateConstructor, from, props, duration, easing, customParams) {
        const to = props;
        const customAnimate = new CustomAnimateConstructor(from, to, duration, easing, customParams);
        animate.play(customAnimate);
    }
    createPropsFromChannel(channel, graphic) {
        const props = {};
        let from = null;
        if (!channel) {
            return {
                from,
                props
            };
        }
        if (!Array.isArray(channel)) {
            Object.keys(channel).forEach(key => {
                var _a, _b, _c, _d;
                const config = channel[key];
                if (config.to !== undefined) {
                    if (typeof config.to === 'function') {
                        props[key] = config.to((_b = (_a = graphic.context) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b[0], graphic, {});
                    }
                    else {
                        props[key] = config.to;
                    }
                }
                if (config.from !== undefined) {
                    if (!from) {
                        from = {};
                    }
                    if (typeof config.from === 'function') {
                        from[key] = config.from((_d = (_c = graphic.context) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[0], graphic, {});
                    }
                    else {
                        from[key] = config.from;
                    }
                }
            });
        }
        else {
            channel.forEach(key => {
                var _a, _b;
                const value = (_b = (_a = graphic.context) === null || _a === void 0 ? void 0 : _a.diffAttrs) === null || _b === void 0 ? void 0 : _b[key];
                if (value !== undefined) {
                    props[key] = value;
                }
            });
        }
        return {
            from,
            props
        };
    }
    resolveValue(value, graphic, defaultValue) {
        var _a, _b;
        if (value === undefined) {
            return defaultValue;
        }
        if (typeof value === 'function' && graphic) {
            return value((_b = (_a = graphic.context) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b[0], graphic, {});
        }
        return value;
    }
    executeItem(params, graphic, index = 0, count = 1) {
        if (Array.isArray(params)) {
            return params.map(param => this._executeItem(param, graphic, index, count)).filter(Boolean);
        }
        return [this._executeItem(params, graphic, index, count)].filter(Boolean);
    }
    _executeItem(params, graphic, index = 0, count = 1) {
        if (!graphic) {
            return null;
        }
        const isTimeline = 'timeSlices' in params;
        let animate = null;
        const parsedParams = this.parseParams(params, isTimeline);
        if (isTimeline) {
            animate = this.executeTimelineItem(parsedParams, graphic, index, count);
        }
        else {
            animate = this.executeTypeConfigItem(parsedParams, graphic, index, count);
        }
        if (animate) {
            this._trackAnimation(animate);
        }
        return animate;
    }
    stop(type) {
        while (this._animates.length > 0) {
            const animate = this._animates.pop();
            animate === null || animate === void 0 ? void 0 : animate.stop(type);
        }
        this._animates = [];
        this._activeCount = 0;
        if (this._started) {
            this._started = false;
            this.onEnd();
        }
    }
}
AnimateExecutor.builtInAnimateMap = {};

const AnimationStates = {
    APPEAR: 'appear',
    DISAPPEAR: 'disappear',
    UPDATE: 'update',
    HIGHLIGHT: 'highlight',
    UNHIGHLIGHT: 'unhighlight',
    SELECT: 'select',
    UNSELECT: 'unselect',
    HOVER: 'hover',
    UNHOVER: 'unhover',
    ACTIVE: 'active',
    INACTIVE: 'inactive'
};
class AnimationStateStore {
    constructor(graphic) {
        this.graphic = graphic;
    }
    registerState(state) {
        if (!this.states) {
            this.states = new Map();
        }
        this.states.set(state.name, state);
    }
    clearStates() {
        var _a;
        (_a = this.states) === null || _a === void 0 ? void 0 : _a.clear();
    }
}
class AnimationStateManager {
    constructor(graphic) {
        this.stateList = null;
        this.graphic = graphic;
    }
    applyState(nextState, animationConfig, callback) {
        const registry = AnimationTransitionRegistry.getInstance();
        const shouldStopState = [];
        const shouldApplyState = [];
        if (!(this.stateList && this.stateList.length)) {
            nextState.forEach((state, index) => {
                shouldApplyState.push({
                    state,
                    animationConfig: isArray(animationConfig[index])
                        ? animationConfig[index].map(item => item.animation)
                        : animationConfig[index].animation,
                    executor: new AnimateExecutor(this.graphic)
                });
            });
        }
        else {
            nextState.forEach((state, index) => {
                const result = {
                    allowTransition: true,
                    stopOriginalTransition: true
                };
                this.stateList.forEach(currState => {
                    const _result = registry.isTransitionAllowed(currState.state, state, this.graphic);
                    result.allowTransition = result.allowTransition && _result.allowTransition;
                });
                if (result.allowTransition) {
                    shouldApplyState.push({
                        state,
                        animationConfig: isArray(animationConfig[index])
                            ? animationConfig[index].map(item => item.animation)
                            : animationConfig[index].animation,
                        executor: new AnimateExecutor(this.graphic)
                    });
                    this.stateList.forEach(currState => {
                        const _result = registry.isTransitionAllowed(currState.state, state, this.graphic);
                        if (_result.stopOriginalTransition) {
                            shouldStopState.push(currState);
                        }
                    });
                }
            });
        }
        shouldStopState.forEach(state => {
            state.executor.stop();
        });
        if (shouldApplyState.length) {
            shouldApplyState[0].executor.execute(shouldApplyState[0].animationConfig);
            for (let i = 0; i < shouldApplyState.length; i++) {
                const nextState = shouldApplyState[i + 1];
                const currentState = shouldApplyState[i];
                currentState.executor.onEnd(() => {
                    if (nextState) {
                        nextState.executor.execute(nextState.animationConfig);
                    }
                    this.stateList = this.stateList.filter(state => state !== currentState);
                    if (i === shouldApplyState.length - 1 && callback) {
                        callback(false);
                    }
                });
            }
        }
        else if (callback) {
            callback(true);
        }
        if (this.stateList) {
            this.stateList = this.stateList.filter(state => !shouldStopState.includes(state));
        }
        else {
            this.stateList = [];
        }
        this.stateList.push(...shouldApplyState);
    }
    applyAppearState(animationConfig, callback) {
        this.applyState([AnimationStates.APPEAR], [{ name: AnimationStates.APPEAR, animation: animationConfig }], callback);
    }
    applyDisappearState(animationConfig, callback) {
        this.applyState([AnimationStates.DISAPPEAR], [{ name: AnimationStates.DISAPPEAR, animation: animationConfig }], callback);
    }
    applyUpdateState(animationConfig, callback) {
        this.applyState([AnimationStates.UPDATE], [{ name: AnimationStates.UPDATE, animation: animationConfig }], callback);
    }
    applyHighlightState(animationConfig, callback) {
        this.applyState([AnimationStates.HIGHLIGHT], [{ name: AnimationStates.HIGHLIGHT, animation: animationConfig }], callback);
    }
    applyUnhighlightState(animationConfig, callback) {
        this.applyState([AnimationStates.UNHIGHLIGHT], [{ name: AnimationStates.UNHIGHLIGHT, animation: animationConfig }], callback);
    }
    stopState(state, type) {
        var _a;
        const stateInfo = (_a = this.stateList) === null || _a === void 0 ? void 0 : _a.find(stateInfo => stateInfo.state === state);
        if (stateInfo) {
            stateInfo.executor.stop(type);
        }
    }
    clearState() {
        var _a;
        (_a = this.stateList) === null || _a === void 0 ? void 0 : _a.forEach(state => {
            state.executor.stop();
        });
        this.stateList = null;
    }
    reApplyState(state) {
        var _a;
        const stateInfo = (_a = this.stateList) === null || _a === void 0 ? void 0 : _a.find(stateInfo => stateInfo.state === state);
        if (stateInfo && stateInfo.executor.started) {
            const stateList = this.stateList.slice();
            stateInfo.executor.stop();
            this.stateList = stateList;
            stateInfo.executor.execute(stateInfo.animationConfig);
        }
    }
}

class GraphicStateExtension {
    _getAnimationStateManager(graphic) {
        if (!graphic._animationStateManager) {
            graphic._animationStateManager = new AnimationStateManager(graphic);
        }
        return graphic._animationStateManager;
    }
    _getAnimationStateStore(graphic) {
        if (!graphic._animationStateStore) {
            graphic._animationStateStore = new AnimationStateStore(graphic);
        }
        return graphic._animationStateStore;
    }
    registerAnimationState(state) {
        this._getAnimationStateStore(this).registerState(state);
        return this;
    }
    applyAnimationState(state, animationConfig, callback) {
        this._getAnimationStateManager(this).applyState(state, animationConfig, callback);
        return this;
    }
    applyAppearState(animationConfig, callback) {
        this._getAnimationStateManager(this).applyAppearState(animationConfig, callback);
        return this;
    }
    applyDisappearState(animationConfig, callback) {
        this._getAnimationStateManager(this).applyDisappearState(animationConfig, callback);
        return this;
    }
    applyUpdateState(animationConfig, callback) {
        this._getAnimationStateManager(this).applyUpdateState(animationConfig, callback);
        return this;
    }
    applyHighlightState(animationConfig, callback) {
        this._getAnimationStateManager(this).applyHighlightState(animationConfig, callback);
        return this;
    }
    applyUnhighlightState(animationConfig, callback) {
        this._getAnimationStateManager(this).applyUnhighlightState(animationConfig, callback);
        return this;
    }
    stopAnimationState(state, type, deep = false) {
        this._getAnimationStateManager(this).stopState(state, type);
        if (deep && this.isContainer) {
            this.forEachChildren((child) => {
                child.stopAnimationState(state, type, deep);
            });
        }
        return this;
    }
    clearAnimationStates() {
        const stateManager = this._animationStateManager;
        if (stateManager) {
            stateManager.clearState();
        }
        return this;
    }
    reApplyAnimationState(state, deep = false) {
        const stateManager = this._animationStateManager;
        if (stateManager) {
            stateManager.reApplyState(state);
        }
        if (deep && this.isContainer) {
            this.forEachChildren((child) => {
                child.reApplyAnimationState(state, deep);
            });
        }
        return this;
    }
    static extend(graphic) {
        const extension = new GraphicStateExtension();
        extension._getAnimationStateManager(graphic);
        return graphic;
    }
}

class AnimateExtension {
    getAttributes(final = false) {
        if (final && this.finalAttribute) {
            return this.finalAttribute;
        }
        return this.attribute;
    }
    animate(params) {
        var _a, _b, _c;
        const animate = new Animate(params === null || params === void 0 ? void 0 : params.id, (_b = (_a = params === null || params === void 0 ? void 0 : params.timeline) !== null && _a !== void 0 ? _a : (this.stage && this.stage.getTimeline())) !== null && _b !== void 0 ? _b : defaultTimeline, params === null || params === void 0 ? void 0 : params.slience);
        animate.bind(this);
        if (params) {
            const { onStart, onEnd, onRemove } = params;
            onStart != null && animate.onStart(onStart);
            onEnd != null && animate.onEnd(onEnd);
            onRemove != null && animate.onRemove(onRemove);
        }
        (_c = this.stage) === null || _c === void 0 ? void 0 : _c.ticker.start();
        return animate;
    }
    createTimeline() {
        return new DefaultTimeline();
    }
    createTicker(stage) {
        return new DefaultTicker(stage);
    }
    setFinalAttributes(finalAttribute) {
        if (!this.finalAttribute) {
            this.finalAttribute = {};
        }
        Object.assign(this.finalAttribute, finalAttribute);
    }
    initFinalAttributes(finalAttribute) {
        this.finalAttribute = finalAttribute;
    }
    initAnimateExecutor() {
        if (!this._animateExecutor) {
            this._animateExecutor = new AnimateExecutor(this);
        }
    }
    executeAnimation(config) {
        this.initAnimateExecutor();
        this._animateExecutor.execute(config);
        return this;
    }
    executeAnimations(configs) {
        this.initAnimateExecutor();
        configs.forEach(config => {
            this._animateExecutor.execute(config);
        });
        return this;
    }
    getFinalAttribute() {
        return this.finalAttribute;
    }
    getGraphicAttribute(key, prev = false) {
        if (!prev && this.finalAttribute) {
            return this.finalAttribute[key];
        }
        return this.attribute[key];
    }
    pauseAnimation(deep = false) {
        this.animates && this.animates.forEach(animate => animate.pause());
        if (deep && this.isContainer) {
            this.forEachChildren((child) => {
                child.pauseAnimation(deep);
            });
        }
    }
    resumeAnimation(deep = false) {
        this.animates && this.animates.forEach(animate => animate.resume());
        if (deep && this.isContainer) {
            this.forEachChildren((child) => {
                child.resumeAnimation(deep);
            });
        }
    }
    stopAnimation(deep = false) {
        this.animates && this.animates.forEach(animate => animate.stop());
        if (deep && this.isContainer) {
            this.forEachChildren((child) => {
                child.stopAnimation(deep);
            });
        }
    }
}

function registerAnimate() {
    mixin(Graphic, GraphicStateExtension);
    mixin(Graphic, AnimateExtension);
}

class ACustomAnimate extends Step {
    constructor(customFrom, customTo, duration, easing, params) {
        super('customAnimate', customTo, duration, easing);
        this.type = 'customAnimate';
        this.customFrom = customFrom;
        this.params = params;
        this.from = customFrom;
        this.to = customTo;
    }
    update(end, ratio, out) {
        this.onStart();
        if (!this.props || !this.propKeys) {
            return;
        }
        const easedRatio = this.easing(ratio);
        this.onUpdate(end, easedRatio, out);
        this.syncAttributeUpdate();
    }
    setProps(props) {
        this.props = props;
        this.propKeys = Object.keys(props);
        this.animate.reSyncProps();
    }
}
class AComponentAnimate extends ACustomAnimate {
    completeBind(animator) {
        this.setStartTime(0);
        this._animator && this._animator.start();
        this.setDuration(animator.getDuration());
    }
    stop() {
        this._animator && this._animator.stop();
    }
}
class AStageAnimate extends ACustomAnimate {
    constructor(customFrom, customTo, duration, easing, params) {
        super(customFrom, customTo, duration, easing, params);
        this.willCallBeforeStageRender = true;
        this.willCallAfterStageRender = true;
        this._beforeStageRender = () => {
            if (!this.willCallBeforeStageRender) {
                return;
            }
            this.willCallBeforeStageRender = false;
            const stage = this.target.stage;
            const canvas = stage.window.getContext().canvas.nativeCanvas;
            const outputCanvas = this.beforeStageRender(stage, canvas);
            if (outputCanvas) {
                this.renderToStage(stage, outputCanvas);
            }
        };
        this._afterStageRender = () => {
            if (!this.willCallAfterStageRender) {
                return;
            }
            this.willCallAfterStageRender = false;
            const stage = this.target.stage;
            const canvas = stage.window.getContext().canvas.nativeCanvas;
            const outputCanvas = this.afterStageRender(stage, canvas);
            if (outputCanvas) {
                this.renderToStage(stage, outputCanvas);
            }
        };
        this.props = {};
    }
    beforeStageRender(stage, canvas) {
        return false;
    }
    afterStageRender(stage, canvas) {
        return false;
    }
    onFirstRun() {
        super.onFirstRun();
        this.target.stage.setBeforeRender(this._beforeStageRender);
        this.target.stage.setAfterRender(this._afterStageRender);
        this.target.stage.disableDirtyBounds();
    }
    stop() {
        super.stop();
        this.target.stage.removeBeforeRender(this._beforeStageRender);
        this.target.stage.removeAfterRender(this._afterStageRender);
    }
    onUpdate(end, ratio, out) {
        super.onUpdate(end, ratio, out);
        this.willCallBeforeStageRender = true;
        this.willCallAfterStageRender = true;
    }
    renderToStage(stage, canvas) {
        const stageCanvas = stage.window.getContext().canvas.nativeCanvas;
        const ctx = stageCanvas.getContext('2d');
        if (!ctx) {
            return false;
        }
        ctx.clearRect(0, 0, stageCanvas.width, stageCanvas.height);
        ctx.drawImage(canvas, 0, 0);
        return stageCanvas;
    }
}

class ComponentAnimator {
    constructor(component) {
        this.tasks = [];
        this.started = false;
        this.completed = 0;
        this.totalDuration = 0;
        this.onStartCallbacks = [];
        this.onEndCallbacks = [];
        this.onUpdateCallbacks = [];
        this.component = component;
    }
    animate(graphic, config) {
        if (this.started) {
            console.warn('Cannot add animations after animation has started');
            return this;
        }
        this.tasks.push({
            graphic,
            config
        });
        return this;
    }
    onStart(callback) {
        this.onStartCallbacks.push(callback);
        return this;
    }
    onEnd(callback) {
        this.onEndCallbacks.push(callback);
        return this;
    }
    onUpdate(callback) {
        this.onUpdateCallbacks.push(callback);
        return this;
    }
    start() {
        if (this.started) {
            console.warn('Animation has already started');
            return this;
        }
        this.started = true;
        this.completed = 0;
        this.onStartCallbacks.forEach(callback => callback());
        if (this.tasks.length === 0) {
            setTimeout(() => {
                this.onEndCallbacks.forEach(callback => callback());
            }, 0);
            return this;
        }
        this.tasks.forEach(task => {
            const executor = new AnimateExecutor(task.graphic);
            executor.onEnd(() => {
                this.completed++;
                if (this.completed === this.tasks.length) {
                    this.onEndCallbacks.forEach(callback => callback());
                }
            });
            const animate = executor.executeItem(task.config, task.graphic);
            task.animate = animate;
            animate.forEach(animate => {
                this.totalDuration = Math.max(this.totalDuration, animate.getStartTime() + animate.getDuration());
            });
        });
        return this;
    }
    deleteSelfAttr(key) {
        this.tasks.forEach(task => {
            if (task.animate) {
                task.animate.forEach(animate => animate.preventAttr(key));
            }
        });
    }
    stop(type) {
        this.tasks.forEach(task => {
            if (task.animate) {
                task.animate.forEach(animate => animate.stop(type));
            }
        });
        if (this.started && this.completed !== this.tasks.length) {
            this.onEndCallbacks.forEach(callback => callback());
            this.completed = this.tasks.length;
        }
        return this;
    }
    getDuration() {
        return this.totalDuration;
    }
}
function createComponentAnimator(component) {
    return new ComponentAnimator(component);
}

class IncreaseCount extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.formatTemplate = null;
        this.decimalLength = params === null || params === void 0 ? void 0 : params.decimalLength;
        if ((params === null || params === void 0 ? void 0 : params.formatTemplate) && params.formatTemplate.includes('{{var}}')) {
            this.formatTemplate = params.formatTemplate;
        }
    }
    onFirstRun() {
        var _a, _b, _c;
        const fromProps = this.getLastProps();
        const toProps = this.getEndProps();
        const fromText = (_a = fromProps.text) !== null && _a !== void 0 ? _a : 0;
        const toText = (_b = toProps.text) !== null && _b !== void 0 ? _b : 0;
        this.valid = true;
        let fromNum = 0;
        let toNum = 0;
        let fromFormat = '';
        let toFormat = '';
        let maxDecimalLength = 0;
        if (typeof fromText === 'number') {
            fromNum = fromText;
            const str = fromText.toString();
            const decimalPart = str.split('.')[1] || '';
            maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length);
        }
        else if (typeof fromText === 'string') {
            if (fromText.endsWith('%')) {
                fromFormat = '%';
                const numStr = fromText.substring(0, fromText.length - 1);
                const cleanNumStr = numStr.replace(/,/g, '');
                fromNum = parseFloat(cleanNumStr) / 100;
                if (isNaN(fromNum)) {
                    this.valid = false;
                    return;
                }
                const decimalPart = cleanNumStr.split('.')[1] || '';
                maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length + 2);
            }
            else {
                const cleanNumStr = fromText.replace(/,/g, '');
                fromNum = parseFloat(cleanNumStr);
                if (isNaN(fromNum)) {
                    this.valid = false;
                    return;
                }
                if (fromText.includes(',')) {
                    fromFormat = ',';
                }
                const decimalPart = cleanNumStr.split('.')[1] || '';
                maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length);
            }
        }
        else {
            this.valid = false;
            return;
        }
        if (typeof toText === 'number') {
            toNum = toText;
            const str = toText.toString();
            const decimalPart = str.split('.')[1] || '';
            maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length);
        }
        else if (typeof toText === 'string') {
            if (toText.endsWith('%')) {
                toFormat = '%';
                const numStr = toText.substring(0, toText.length - 1);
                const cleanNumStr = numStr.replace(/,/g, '');
                toNum = parseFloat(cleanNumStr) / 100;
                if (isNaN(toNum)) {
                    this.valid = false;
                    return;
                }
                const decimalPart = cleanNumStr.split('.')[1] || '';
                maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length + 2);
            }
            else {
                const cleanNumStr = toText.replace(/,/g, '');
                toNum = parseFloat(cleanNumStr);
                if (isNaN(toNum)) {
                    this.valid = false;
                    return;
                }
                if (toText.includes(',')) {
                    toFormat = ',';
                }
                const decimalPart = cleanNumStr.split('.')[1] || '';
                maxDecimalLength = Math.max(maxDecimalLength, decimalPart.length);
            }
        }
        else {
            this.valid = false;
            return;
        }
        if ((_c = this.params) === null || _c === void 0 ? void 0 : _c.format) {
            switch (this.params.format) {
                case 'percent':
                    this.format = '%';
                    break;
                case 'thousandth':
                    this.format = ',';
                    break;
                case 'none':
                    this.format = '';
                    break;
                default:
                    this.format = toFormat || fromFormat;
            }
            if (this.format === '%' && toFormat !== '%' && fromFormat !== '%') {
                if (this.decimalLength === undefined) {
                    this.decimalLength = 2;
                }
            }
            if (this.format !== '%' && (toFormat === '%' || fromFormat === '%')) {
                fromNum = fromNum * 100;
                toNum = toNum * 100;
            }
        }
        else {
            this.format = toFormat || fromFormat;
        }
        this.fromNumber = fromNum;
        this.toNumber = toNum;
        if (this.decimalLength === undefined) {
            this.decimalLength = maxDecimalLength;
        }
    }
    onEnd(cb) {
        super.onEnd(cb);
        if (!cb) {
            this.props && this.target.setAttributes(this.props);
        }
    }
    onUpdate(end, ratio, out) {
        if (!this.valid) {
            return;
        }
        const currentNumber = this.fromNumber + (this.toNumber - this.fromNumber) * ratio;
        let formattedText = '';
        const format = this.format;
        const adjustedNumber = format === '%' ? currentNumber * 100 : currentNumber;
        const numberWithDecimals = adjustedNumber.toFixed(this.decimalLength);
        let formattedNumber = numberWithDecimals;
        if (parseFloat(numberWithDecimals) === Math.floor(parseFloat(numberWithDecimals))) {
            formattedNumber = Math.floor(parseFloat(numberWithDecimals));
        }
        let formattedWithBasicFormat;
        if (format === '%') {
            formattedWithBasicFormat = `${formattedNumber}%`;
        }
        else if (format === ',') {
            const parts = formattedNumber.toString().split('.');
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            formattedWithBasicFormat = parts.join('.');
        }
        else {
            formattedWithBasicFormat = formattedNumber;
        }
        if (this.formatTemplate) {
            formattedText = this.formatTemplate.replace('{{var}}', formattedWithBasicFormat.toString());
        }
        else {
            formattedText = formattedWithBasicFormat;
        }
        this.target.setAttribute('text', formattedText);
    }
}

const DefaultMorphingAnimateConfig = {
    duration: 1000,
    easing: 'quadInOut'
};

const transformKeys = [
    'x',
    'y',
    'dx',
    'dy',
    'scaleX',
    'scaleY',
    'angle',
    'anchor',
    'postMatrix',
    'scrollX',
    'scrollY'
];
const isTransformKey = (key) => {
    return transformKeys.includes(key);
};

const interpolateOtherAttrs = (attrs, out, ratio) => {
    attrs.forEach(entry => {
        if (Number.isFinite(entry.to)) {
            out[entry.key] = entry.from + (entry.to - entry.from) * ratio;
        }
        else if (entry.key === 'fill' || entry.key === 'stroke') {
            const color = interpolateColor(entry.from, entry.to, ratio, false);
            if (color) {
                out[entry.key] = color;
            }
        }
    });
};
const interpolateMorphingData = (morphingData, path, ratio) => {
    const tmpArr = [];
    const newCp = [];
    path.clear();
    for (let i = 0; i < morphingData.length; i++) {
        const item = morphingData[i];
        const from = item.from;
        const to = item.to;
        const angle = item.rotation * ratio;
        const fromCp = item.fromCp;
        const toCp = item.toCp;
        const sa = Math.sin(angle);
        const ca = Math.cos(angle);
        newCp[0] = fromCp[0] + (toCp[0] - fromCp[0]) * ratio;
        newCp[1] = fromCp[1] + (toCp[1] - fromCp[1]) * ratio;
        for (let m = 0; m < from.length; m += 2) {
            const x0 = from[m];
            const y0 = from[m + 1];
            const x1 = to[m];
            const y1 = to[m + 1];
            const x = x0 * (1 - ratio) + x1 * ratio;
            const y = y0 * (1 - ratio) + y1 * ratio;
            tmpArr[m] = x * ca - y * sa + newCp[0];
            tmpArr[m + 1] = x * sa + y * ca + newCp[1];
        }
        let x0 = tmpArr[0];
        let y0 = tmpArr[1];
        path.moveTo(x0, y0);
        for (let m = 2; m < from.length; m += 6) {
            const x1 = tmpArr[m];
            const y1 = tmpArr[m + 1];
            const x2 = tmpArr[m + 2];
            const y2 = tmpArr[m + 3];
            const x3 = tmpArr[m + 4];
            const y3 = tmpArr[m + 5];
            if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {
                path.lineTo(x3, y3);
            }
            else {
                path.bezierCurveTo(x1, y1, x2, y2, x3, y3);
            }
            x0 = x3;
            y0 = y3;
        }
    }
};
const parseMorphingData = (fromPath, toPath, config) => {
    const fromBezier = fromPath ? pathToBezierCurves(fromPath) : [];
    const toBezier = pathToBezierCurves(toPath);
    if (config && fromBezier) {
        config.fromTransform && applyTransformOnBezierCurves(fromBezier, config.fromTransform.clone().getInverse());
        applyTransformOnBezierCurves(fromBezier, config.toTransfrom);
    }
    const [fromBezierCurves, toBezierCurves] = alignBezierCurves(fromBezier, toBezier);
    return fromPath
        ? findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI)
        : toBezierCurves.map((to, index) => {
            return {
                from: fromBezierCurves[index],
                to,
                fromCp: [0, 0],
                toCp: [0, 0],
                rotation: 0
            };
        });
};
const validateOtherAttrs = [
    'fill',
    'fillOpacity',
    'shadowBlur',
    'shadowColor',
    'shadowOffsetX',
    'shadowOffsetY',
    'stroke',
    'strokeOpacity',
    'lineDashOffset'
];
const parseOtherAnimateAttrs = (fromAttrs, toAttrs) => {
    if (!fromAttrs || !toAttrs) {
        return null;
    }
    const res = [];
    let hasAttr = false;
    Object.keys(fromAttrs).forEach(fromKey => {
        if (!validateOtherAttrs.includes(fromKey)) {
            return;
        }
        const toValue = toAttrs[fromKey];
        if (!isNil(toValue) && !isNil(fromAttrs[fromKey]) && toValue !== fromAttrs[fromKey]) {
            if (fromKey === 'fill' || fromKey === 'stroke') {
                const parseColor = (color) => {
                    return typeof color === 'string' ? ColorStore.Get(color, ColorType.Color255) : color;
                };
                res.push({
                    from: isArray(fromAttrs[fromKey])
                        ? fromAttrs[fromKey].map(parseColor)
                        : parseColor(fromAttrs[fromKey]),
                    to: isArray(toValue) ? toValue.map(parseColor) : parseColor(toValue),
                    key: fromKey
                });
            }
            else {
                res.push({ from: fromAttrs[fromKey], to: toValue, key: fromKey });
            }
            hasAttr = true;
        }
    });
    return hasAttr ? res : null;
};
class MorphingPath extends ACustomAnimate {
    constructor(config, duration, easing) {
        super({}, {}, duration, easing);
        this.morphingData = config.morphingData;
        this.otherAttrs = config.otherAttrs;
        this.saveOnEnd = config.saveOnEnd;
    }
    getEndProps() {
        return {};
    }
    onBind() {
        this.target.createPathProxy();
        this.onUpdate(false, 0, this.target.attribute);
    }
    onEnd() {
        return;
    }
    onUpdate(end, ratio, out) {
        const target = this.target;
        const pathProxy = typeof target.pathProxy === 'function' ? target.pathProxy(target.attribute) : target.pathProxy;
        interpolateMorphingData(this.morphingData, pathProxy, ratio);
        if (this.otherAttrs && this.otherAttrs.length) {
            interpolateOtherAttrs(this.otherAttrs, out, ratio);
        }
        this.target.setAttributes(out);
        if (end && !this.saveOnEnd) {
            this.target.pathProxy = null;
        }
    }
}
const morphPath = (fromGraphic, toGraphic, animationConfig, fromGraphicTransform) => {
    var _a, _b, _c;
    if (fromGraphic && (!fromGraphic.valid || !fromGraphic.toCustomPath)) {
        if (__DEV__) {
            console.error(fromGraphic, ' is not validate');
        }
        return null;
    }
    if (!toGraphic.valid || !toGraphic.toCustomPath) {
        if (__DEV__) {
            console.error(toGraphic, ' is not validate');
        }
        return null;
    }
    let fromTransform = fromGraphic === null || fromGraphic === void 0 ? void 0 : fromGraphic.globalTransMatrix;
    if (fromGraphicTransform && fromTransform) {
        fromTransform = fromGraphicTransform
            .clone()
            .multiply(fromTransform.a, fromTransform.b, fromTransform.c, fromTransform.d, fromTransform.e, fromTransform.f);
    }
    const morphingData = parseMorphingData((_a = fromGraphic === null || fromGraphic === void 0 ? void 0 : fromGraphic.toCustomPath) === null || _a === void 0 ? void 0 : _a.call(fromGraphic), toGraphic.toCustomPath(), {
        fromTransform,
        toTransfrom: toGraphic.globalTransMatrix
    });
    const attrs = parseOtherAnimateAttrs(fromGraphic === null || fromGraphic === void 0 ? void 0 : fromGraphic.attribute, toGraphic.attribute);
    const animate = toGraphic.animate(animationConfig);
    if (animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.delay) {
        animate.wait(animationConfig.delay);
    }
    const morphingPath = new MorphingPath({ morphingData, otherAttrs: attrs }, (_b = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.duration) !== null && _b !== void 0 ? _b : DefaultMorphingAnimateConfig.duration, (_c = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.easing) !== null && _c !== void 0 ? _c : DefaultMorphingAnimateConfig.easing);
    animate.play(morphingPath);
    return animate;
};
const oneToMultiMorph = (fromGraphic, toGraphics, animationConfig) => {
    var _a;
    const validateToGraphics = toGraphics.filter(graphic => graphic && graphic.toCustomPath && graphic.valid);
    if (!validateToGraphics.length) {
        if (__DEV__) {
            console.error(validateToGraphics, ' is not validate');
        }
    }
    if (!fromGraphic.valid || !fromGraphic.toCustomPath) {
        if (__DEV__) {
            console.error(fromGraphic, ' is not validate');
        }
    }
    const childGraphics = ((animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.splitPath) === 'clone' ? cloneGraphic : (_a = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.splitPath) !== null && _a !== void 0 ? _a : splitGraphic)(fromGraphic, validateToGraphics.length, false);
    const oldOnEnd = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.onEnd;
    let count = validateToGraphics.length;
    const onEachEnd = () => {
        count--;
        if (count === 0 && oldOnEnd) {
            oldOnEnd();
        }
    };
    validateToGraphics.forEach((toChild, index) => {
        var _a;
        const fromChild = childGraphics[index];
        const delay = ((_a = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.delay) !== null && _a !== void 0 ? _a : 0) +
            ((animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.individualDelay)
                ? animationConfig.individualDelay(index, validateToGraphics.length, fromChild, toChild)
                : 0);
        morphPath(fromChild, toChild, Object.assign({}, animationConfig, { onEnd: onEachEnd, delay }), fromGraphic.globalTransMatrix);
    });
};
class MultiToOneMorphingPath extends ACustomAnimate {
    constructor(config, duration, easing) {
        super({}, {}, duration, easing);
        this.morphingData = config.morphingData;
        this.otherAttrs = config.otherAttrs;
    }
    getEndProps() {
        return {};
    }
    onBind() {
        this.addPathProxy();
    }
    addPathProxy() {
        const shadowRoot = this.target.shadowRoot;
        shadowRoot.forEachChildren(child => {
            child.createPathProxy();
        });
        this.onUpdate(false, 0, this.target.attribute);
    }
    clearPathProxy() {
        const shadowRoot = this.target.shadowRoot;
        shadowRoot.forEachChildren(child => {
            child.pathProxy = null;
        });
    }
    onEnd() {
        return;
    }
    onUpdate(end, ratio, out) {
        const shadowRoot = this.target.shadowRoot;
        shadowRoot.forEachChildren((child, index) => {
            var _a;
            interpolateMorphingData(this.morphingData[index], typeof child.pathProxy === 'function' ? child.pathProxy(child.attribute) : child.pathProxy, ratio);
            if (((_a = this.otherAttrs) === null || _a === void 0 ? void 0 : _a[index]) && this.otherAttrs[index].length) {
                interpolateOtherAttrs(this.otherAttrs[index], child.attribute, ratio);
            }
        });
        if (end) {
            this.clearPathProxy();
            this.morphingData = null;
        }
    }
}
const parseShadowChildAttrs = (graphicAttrs) => {
    const attrs = {};
    Object.keys(graphicAttrs).forEach(key => {
        if (!isTransformKey(key)) {
            attrs[key] = graphicAttrs[key];
        }
    });
    return attrs;
};
const appendShadowChildrenToGraphic = (graphic, children, count) => {
    const childAttrs = parseShadowChildAttrs(graphic.attribute);
    const shadowRoot = graphic.attachShadow();
    if (children.length) {
        shadowRoot.setTheme({
            [children[0].type]: childAttrs
        });
        children.forEach(element => {
            element.setAttributes({ pickable: false });
            shadowRoot.appendChild(element);
        });
    }
    else {
        const box = graphic.AABBBounds;
        const width = box.width();
        const height = box.height();
        shadowRoot.setTheme({
            rect: childAttrs
        });
        new Array(count).fill(0).forEach(el => {
            const child = application.graphicService.creator.rect({
                x: 0,
                y: 0,
                width,
                height: height,
                pickable: false
            });
            shadowRoot.appendChild(child);
            children.push(child);
        });
    }
};
const cloneGraphic = (graphic, count, needAppend) => {
    const children = [];
    const childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute);
    const path = graphic.toCustomPath();
    for (let i = 0; i < count; i++) {
        const element = {
            path: new CustomPath2D().fromCustomPath2D(path)
        };
        children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element)));
    }
    if (needAppend) {
        appendShadowChildrenToGraphic(graphic, children, count);
    }
    return children;
};
const splitGraphic = (graphic, count, needAppend) => {
    const children = [];
    const childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute);
    if (graphic.type === 'rect') {
        const childrenAttrs = splitRect(graphic, count);
        childrenAttrs.forEach(element => {
            children.push(application.graphicService.creator.rect(needAppend ? element : Object.assign({}, childAttrs, element)));
        });
    }
    else if (graphic.type === 'arc') {
        const childrenAttrs = splitArc(graphic, count);
        childrenAttrs.forEach(element => {
            children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
        });
    }
    else if (graphic.type === 'circle') {
        const childrenAttrs = splitCircle(graphic, count);
        childrenAttrs.forEach(element => {
            children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
        });
    }
    else if (graphic.type === 'line') {
        const childrenAttrs = splitLine(graphic, count);
        const defaultSymbol = { size: 10, symbolType: 'circle' };
        childrenAttrs.forEach(element => {
            children.push(application.graphicService.creator.symbol(needAppend ? Object.assign({}, element, defaultSymbol) : Object.assign({}, childAttrs, element, defaultSymbol)));
        });
    }
    else if (graphic.type === 'polygon') {
        const childrenAttrs = splitPolygon(graphic, count);
        childrenAttrs.forEach(element => {
            children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
        });
    }
    else if (graphic.type === 'area') {
        const childrenAttrs = splitArea(graphic, count);
        childrenAttrs.forEach(element => {
            children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
        });
    }
    else if (graphic.type === 'path') {
        const childrenAttrs = splitPath(graphic, count);
        childrenAttrs.forEach(element => {
            if ('path' in element) {
                children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element)));
            }
            else {
                children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
            }
        });
    }
    if (needAppend) {
        appendShadowChildrenToGraphic(graphic, children, count);
    }
    return children;
};
const multiToOneMorph = (fromGraphics, toGraphic, animationConfig) => {
    var _a, _b, _c;
    const validateFromGraphics = fromGraphics.filter(graphic => graphic.toCustomPath && graphic.valid);
    if (!validateFromGraphics.length) {
        if (__DEV__) {
            console.error(fromGraphics, ' is not validate');
        }
    }
    if (!toGraphic.valid || !toGraphic.toCustomPath) {
        if (__DEV__) {
            console.error(toGraphic, ' is not validate');
        }
    }
    const childGraphics = ((animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.splitPath) === 'clone' ? cloneGraphic : (_a = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.splitPath) !== null && _a !== void 0 ? _a : splitGraphic)(toGraphic, validateFromGraphics.length, true);
    const toAttrs = toGraphic.attribute;
    toGraphic.setAttribute('visible', false);
    const morphingData = validateFromGraphics.map((graphic, index) => {
        return parseMorphingData(graphic.toCustomPath(), childGraphics[index].toCustomPath(), {
            fromTransform: graphic.globalTransMatrix,
            toTransfrom: childGraphics[index].globalTransMatrix
        });
    });
    const otherAttrs = validateFromGraphics.map((graphic, index) => {
        return parseOtherAnimateAttrs(graphic.attribute, toAttrs);
    });
    if (animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.individualDelay) {
        const oldOnEnd = animationConfig.onEnd;
        let count = validateFromGraphics.length;
        const onEachEnd = () => {
            count--;
            if (count === 0) {
                toGraphic.setAttributes({ visible: true, ratio: null }, false, {
                    type: AttributeUpdateType.ANIMATE_END
                });
                toGraphic.detachShadow();
                if (oldOnEnd) {
                    oldOnEnd();
                }
            }
        };
        childGraphics.forEach((to, index) => {
            var _a, _b, _c;
            const delay = ((_a = animationConfig.delay) !== null && _a !== void 0 ? _a : 0) +
                animationConfig.individualDelay(index, validateFromGraphics.length, fromGraphics[index], to);
            const animate = to.animate(Object.assign({}, animationConfig, { onEnd: onEachEnd }));
            animate.wait(delay);
            animate.play(new MorphingPath({
                morphingData: morphingData[index],
                saveOnEnd: true,
                otherAttrs: otherAttrs[index]
            }, (_b = animationConfig.duration) !== null && _b !== void 0 ? _b : DefaultMorphingAnimateConfig.duration, (_c = animationConfig.easing) !== null && _c !== void 0 ? _c : DefaultMorphingAnimateConfig.easing));
        });
    }
    else {
        const oldOnEnd = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.onEnd;
        const config = animationConfig ? Object.assign({}, animationConfig) : {};
        config.onEnd = () => {
            toGraphic.setAttribute('visible', true, false, { type: AttributeUpdateType.ANIMATE_END });
            toGraphic.detachShadow();
            if (oldOnEnd) {
                oldOnEnd();
            }
        };
        const animate = toGraphic.animate(config);
        if (animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.delay) {
            animate.wait(animationConfig.delay);
        }
        animate.play(new MultiToOneMorphingPath({ morphingData, otherAttrs }, (_b = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.duration) !== null && _b !== void 0 ? _b : DefaultMorphingAnimateConfig.duration, (_c = animationConfig === null || animationConfig === void 0 ? void 0 : animationConfig.easing) !== null && _c !== void 0 ? _c : DefaultMorphingAnimateConfig.easing));
    }
};

class InputText extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.fromText = '';
        this.toText = '';
        this.showCursor = false;
        this.cursorChar = '|';
        this.blinkCursor = true;
        this.beforeText = '';
        this.afterText = '';
        if ((params === null || params === void 0 ? void 0 : params.showCursor) !== undefined) {
            this.showCursor = params.showCursor;
        }
        if ((params === null || params === void 0 ? void 0 : params.cursorChar) !== undefined) {
            this.cursorChar = params.cursorChar;
        }
        if ((params === null || params === void 0 ? void 0 : params.blinkCursor) !== undefined) {
            this.blinkCursor = params.blinkCursor;
        }
        if ((params === null || params === void 0 ? void 0 : params.beforeText) !== undefined) {
            this.beforeText = params.beforeText;
        }
        if ((params === null || params === void 0 ? void 0 : params.afterText) !== undefined) {
            this.afterText = params.afterText;
        }
    }
    onFirstRun() {
        var _a, _b;
        const fromProps = this.getLastProps();
        const toProps = this.getEndProps();
        const fromText = (_a = fromProps.text) !== null && _a !== void 0 ? _a : '';
        const toText = (_b = toProps.text) !== null && _b !== void 0 ? _b : '';
        this.valid = true;
        this.fromText = fromText.toString();
        this.toText = toText.toString();
        if (!this.toText && this.toText !== '') {
            this.valid = false;
            return;
        }
    }
    onEnd(cb) {
        super.onEnd(cb);
        if (!cb) {
            if (this.showCursor && !this.blinkCursor) {
                this.target.setAttribute('text', this.beforeText + this.toText + this.cursorChar + this.afterText);
            }
            else {
                this.target.setAttribute('text', this.beforeText + this.toText + this.afterText);
            }
        }
    }
    onUpdate(end, ratio, out) {
        if (!this.valid) {
            return;
        }
        const totalChars = this.toText.length;
        const fromChars = this.fromText.length;
        let currentLength;
        let currentText;
        if (fromChars > totalChars) {
            currentLength = Math.round(fromChars - (fromChars - totalChars) * ratio);
            currentText = this.fromText.substring(0, currentLength);
        }
        else {
            currentLength = Math.round(fromChars + (totalChars - fromChars) * ratio);
            if (this.toText.startsWith(this.fromText)) {
                currentText = this.toText.substring(0, currentLength);
            }
            else {
                if (currentLength <= fromChars) {
                    currentText = this.fromText.substring(0, currentLength);
                }
                else {
                    currentText = this.toText.substring(0, currentLength - fromChars + Math.min(fromChars, currentLength));
                }
            }
        }
        let displayText = this.beforeText + currentText + this.afterText;
        if (this.showCursor) {
            if (this.blinkCursor) {
                const blinkRate = 0.1;
                const showCursorNow = Math.floor(ratio / blinkRate) % 2 === 0;
                if (showCursorNow) {
                    displayText = this.beforeText + currentText + this.cursorChar + this.afterText;
                }
            }
            else {
                displayText = this.beforeText + currentText + this.cursorChar + this.afterText;
            }
        }
        this.target.setAttribute('text', displayText);
    }
}

class ClipGraphicAnimate extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(null, {}, duration, easing, params);
        this.clipFromAttribute = from;
        this.clipToAttribute = to;
        this._group = params === null || params === void 0 ? void 0 : params.group;
        this._clipGraphic = params === null || params === void 0 ? void 0 : params.clipGraphic;
    }
    onBind() {
        super.onBind();
        if (this._group && this._clipGraphic) {
            this._lastClip = this._group.attribute.clip;
            this._lastPath = this._group.attribute.path;
            this._group.setAttributes({
                clip: true,
                path: [this._clipGraphic]
            }, false, { type: AttributeUpdateType.ANIMATE_BIND });
        }
    }
    onEnd() {
        if (this._group) {
            this._group.setAttributes({
                clip: this._lastClip,
                path: this._lastPath
            }, false, { type: AttributeUpdateType.ANIMATE_END });
        }
        return;
    }
    onUpdate(end, ratio, out) {
        if (!this._clipGraphic) {
            return;
        }
        const res = {};
        Object.keys(this.clipFromAttribute).forEach(k => {
            res[k] = this.clipFromAttribute[k] + (this.clipToAttribute[k] - this.clipFromAttribute[k]) * ratio;
        });
        this._clipGraphic.setAttributes(res, false, {
            type: AttributeUpdateType.ANIMATE_UPDATE,
            animationState: { ratio, end }
        });
    }
}
class ClipAngleAnimate extends ClipGraphicAnimate {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const groupAttribute = (_b = (_a = params === null || params === void 0 ? void 0 : params.group) === null || _a === void 0 ? void 0 : _a.attribute) !== null && _b !== void 0 ? _b : {};
        const width = (_c = groupAttribute.width) !== null && _c !== void 0 ? _c : 0;
        const height = (_d = groupAttribute.height) !== null && _d !== void 0 ? _d : 0;
        const animationType = (_e = params === null || params === void 0 ? void 0 : params.animationType) !== null && _e !== void 0 ? _e : 'in';
        const startAngle = (_f = params === null || params === void 0 ? void 0 : params.startAngle) !== null && _f !== void 0 ? _f : 0;
        const orient = (_g = params === null || params === void 0 ? void 0 : params.orient) !== null && _g !== void 0 ? _g : 'clockwise';
        let arcStartAngle = 0;
        let arcEndAngle = 0;
        if (orient === 'anticlockwise') {
            arcEndAngle = animationType === 'in' ? startAngle + Math.PI * 2 : startAngle;
            arcEndAngle = startAngle + Math.PI * 2;
        }
        else {
            arcStartAngle = startAngle;
            arcEndAngle = animationType === 'out' ? startAngle + Math.PI * 2 : startAngle;
        }
        const arc = application.graphicService.creator.arc({
            x: (_j = (_h = params === null || params === void 0 ? void 0 : params.center) === null || _h === void 0 ? void 0 : _h.x) !== null && _j !== void 0 ? _j : width / 2,
            y: (_l = (_k = params === null || params === void 0 ? void 0 : params.center) === null || _k === void 0 ? void 0 : _k.y) !== null && _l !== void 0 ? _l : height / 2,
            outerRadius: (_m = params === null || params === void 0 ? void 0 : params.radius) !== null && _m !== void 0 ? _m : (width + height) / 2,
            innerRadius: 0,
            startAngle: arcStartAngle,
            endAngle: arcEndAngle,
            fill: true
        });
        let fromAttributes;
        let toAttributes;
        if (orient === 'anticlockwise') {
            fromAttributes = { startAngle: startAngle + Math.PI * 2 };
            toAttributes = { startAngle: startAngle };
        }
        else {
            fromAttributes = { endAngle: startAngle };
            toAttributes = { endAngle: startAngle + Math.PI * 2 };
        }
        super(animationType === 'in' ? fromAttributes : toAttributes, animationType === 'in' ? toAttributes : fromAttributes, duration, easing, { group: params === null || params === void 0 ? void 0 : params.group, clipGraphic: arc });
    }
}
class ClipRadiusAnimate extends ClipGraphicAnimate {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const groupAttribute = (_b = (_a = params === null || params === void 0 ? void 0 : params.group) === null || _a === void 0 ? void 0 : _a.attribute) !== null && _b !== void 0 ? _b : {};
        const width = (_c = groupAttribute.width) !== null && _c !== void 0 ? _c : 0;
        const height = (_d = groupAttribute.height) !== null && _d !== void 0 ? _d : 0;
        const animationType = (_e = params === null || params === void 0 ? void 0 : params.animationType) !== null && _e !== void 0 ? _e : 'in';
        const startRadius = (_f = params === null || params === void 0 ? void 0 : params.startRadius) !== null && _f !== void 0 ? _f : 0;
        const endRadius = (_g = params === null || params === void 0 ? void 0 : params.endRadius) !== null && _g !== void 0 ? _g : Math.sqrt((width / 2) ** 2 + (height / 2) ** 2);
        const arc = application.graphicService.creator.arc({
            x: (_j = (_h = params === null || params === void 0 ? void 0 : params.center) === null || _h === void 0 ? void 0 : _h.x) !== null && _j !== void 0 ? _j : width / 2,
            y: (_l = (_k = params === null || params === void 0 ? void 0 : params.center) === null || _k === void 0 ? void 0 : _k.y) !== null && _l !== void 0 ? _l : height / 2,
            outerRadius: animationType === 'out' ? endRadius : startRadius,
            innerRadius: 0,
            startAngle: 0,
            endAngle: Math.PI * 2,
            fill: true
        });
        const fromAttributes = { outerRadius: startRadius };
        const toAttributes = { outerRadius: endRadius };
        super(animationType === 'in' ? fromAttributes : toAttributes, animationType === 'in' ? toAttributes : fromAttributes, duration, easing, { group: params === null || params === void 0 ? void 0 : params.group, clipGraphic: arc });
    }
}
class ClipDirectionAnimate extends ClipGraphicAnimate {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const groupAttribute = (_b = (_a = params === null || params === void 0 ? void 0 : params.group) === null || _a === void 0 ? void 0 : _a.attribute) !== null && _b !== void 0 ? _b : {};
        const width = (_d = (_c = params === null || params === void 0 ? void 0 : params.width) !== null && _c !== void 0 ? _c : groupAttribute.width) !== null && _d !== void 0 ? _d : 0;
        const height = (_f = (_e = params === null || params === void 0 ? void 0 : params.height) !== null && _e !== void 0 ? _e : groupAttribute.height) !== null && _f !== void 0 ? _f : 0;
        const animationType = (_g = params === null || params === void 0 ? void 0 : params.animationType) !== null && _g !== void 0 ? _g : 'in';
        const direction = (_h = params === null || params === void 0 ? void 0 : params.direction) !== null && _h !== void 0 ? _h : 'x';
        const orient = (_j = params === null || params === void 0 ? void 0 : params.orient) !== null && _j !== void 0 ? _j : 'positive';
        const rect = application.graphicService.creator.rect({
            x: 0,
            y: 0,
            width: animationType === 'in' && direction === 'x' ? 0 : width,
            height: animationType === 'in' && direction === 'y' ? 0 : height,
            fill: true
        });
        let fromAttributes = {};
        let toAttributes = {};
        if (direction === 'y') {
            if (orient === 'negative') {
                fromAttributes = { y: height, height: 0 };
                toAttributes = { y: 0, height: height };
            }
            else {
                fromAttributes = { height: 0 };
                toAttributes = { height: height };
            }
        }
        else {
            if (orient === 'negative') {
                fromAttributes = { x: width, width: 0 };
                toAttributes = { x: 0, width: width };
            }
            else {
                fromAttributes = { width: 0 };
                toAttributes = { width: width };
            }
        }
        super(animationType === 'in' ? fromAttributes : toAttributes, animationType === 'in' ? toAttributes : fromAttributes, duration, easing, { group: params === null || params === void 0 ? void 0 : params.group, clipGraphic: rect });
    }
}

class TagPointsUpdate extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        var _a, _b;
        super(from, to, duration, easing, params);
        this.newPointAnimateType = (_a = params === null || params === void 0 ? void 0 : params.newPointAnimateType) !== null && _a !== void 0 ? _a : 'grow';
        this.clipRangeByDimension = (_b = params === null || params === void 0 ? void 0 : params.clipRangeByDimension) !== null && _b !== void 0 ? _b : 'x';
    }
    getPoints(attribute, cache = false) {
        if (attribute.points) {
            return attribute.points;
        }
        if (attribute.segments) {
            const points = [];
            if (!this.segmentsCache) {
                this.segmentsCache = [];
            }
            attribute.segments.map((segment) => {
                var _a, _b;
                if (segment.points) {
                    points.push(...segment.points);
                }
                if (cache) {
                    this.segmentsCache.push((_b = (_a = segment.points) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
                }
            });
            return points;
        }
        return [];
    }
    onBind() {
        super.onBind();
        const { points, segments } = this.target.attribute;
        const { points: pointsTo, segments: segmentsTo } = this.target.getFinalAttribute();
        this.from = { points, segments };
        this.to = { points: pointsTo, segments: segmentsTo };
        this.props = this.to;
        const originFromPoints = this.getPoints(this.from);
        const originToPoints = this.getPoints(this.to, true);
        this.fromPoints = !originFromPoints ? [] : !Array.isArray(originFromPoints) ? [originFromPoints] : originFromPoints;
        this.toPoints = !originToPoints ? [] : !Array.isArray(originToPoints) ? [originToPoints] : originToPoints;
        const tagMap = new Map();
        this.fromPoints.forEach(point => {
            if (point.context) {
                tagMap.set(point.context, point);
            }
        });
        let firstMatchedIndex = Infinity;
        let lastMatchedIndex = -Infinity;
        let firstMatchedPoint;
        let lastMatchedPoint;
        for (let i = 0; i < this.toPoints.length; i += 1) {
            if (tagMap.has(this.toPoints[i].context)) {
                firstMatchedIndex = i;
                firstMatchedPoint = tagMap.get(this.toPoints[i].context);
                break;
            }
        }
        for (let i = this.toPoints.length - 1; i >= 0; i -= 1) {
            if (tagMap.has(this.toPoints[i].context)) {
                lastMatchedIndex = i;
                lastMatchedPoint = tagMap.get(this.toPoints[i].context);
                break;
            }
        }
        if (this.newPointAnimateType === 'clip') {
            if (this.toPoints.length !== 0) {
                if (Number.isFinite(lastMatchedIndex)) {
                    this.clipRange =
                        this.toPoints[lastMatchedIndex][this.clipRangeByDimension] /
                            this.toPoints[this.toPoints.length - 1][this.clipRangeByDimension];
                    if (this.clipRange === 1) {
                        this.shrinkClipRange =
                            this.toPoints[lastMatchedIndex][this.clipRangeByDimension] /
                                this.fromPoints[this.fromPoints.length - 1][this.clipRangeByDimension];
                    }
                    if (!isValidNumber(this.clipRange)) {
                        this.clipRange = 0;
                    }
                    else {
                        this.clipRange = clamp(this.clipRange, 0, 1);
                    }
                }
                else {
                    this.clipRange = 0;
                }
            }
        }
        let prevMatchedPoint = this.toPoints[0];
        this.interpolatePoints = this.toPoints.map((point, index) => {
            const matchedPoint = tagMap.get(point.context);
            if (matchedPoint) {
                prevMatchedPoint = matchedPoint;
                return [matchedPoint, point];
            }
            if (this.newPointAnimateType === 'appear' || this.newPointAnimateType === 'clip') {
                return [point, point];
            }
            if (index < firstMatchedIndex && firstMatchedPoint) {
                return [firstMatchedPoint, point];
            }
            else if (index > lastMatchedIndex && lastMatchedPoint) {
                return [lastMatchedPoint, point];
            }
            return [prevMatchedPoint, point];
        });
        this.points = this.interpolatePoints.map(interpolate => {
            const fromPoint = interpolate[0];
            const toPoint = interpolate[1];
            const newPoint = new Point(fromPoint.x, fromPoint.y, fromPoint.x1, fromPoint.y1);
            newPoint.defined = toPoint.defined;
            newPoint.context = toPoint.context;
            return newPoint;
        });
    }
    onFirstRun() {
        const lastClipRange = this.target.attribute.clipRange;
        if (isValidNumber(lastClipRange * this.clipRange)) {
            this.clipRange *= lastClipRange;
        }
    }
    onUpdate(end, ratio, out) {
        if (end) {
            Object.keys(this.to).forEach(k => {
                this.target.attribute[k] = this.to[k];
            });
            this.target.addUpdatePositionTag();
            this.target.addUpdateShapeAndBoundsTag();
            return;
        }
        this.points = this.points.map((point, index) => {
            const newPoint = pointInterpolation(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);
            newPoint.context = point.context;
            return newPoint;
        });
        if (this.clipRange) {
            if (this.shrinkClipRange) {
                if (!end) {
                    out.points = this.fromPoints;
                    out.clipRange = this.clipRange - (this.clipRange - this.shrinkClipRange) * ratio;
                }
                else {
                    out.points = this.toPoints;
                    out.clipRange = 1;
                }
                return;
            }
            this.target.setAttributes({ clipRange: this.clipRange + (1 - this.clipRange) * ratio });
        }
        if (this.segmentsCache && this.to.segments) {
            let start = 0;
            const segments = this.to.segments.map((segment, index) => {
                const end = start + this.segmentsCache[index];
                const points = this.points.slice(start, end);
                start = end;
                return Object.assign(Object.assign({}, segment), { points });
            });
            this.target.attribute.segments = segments;
        }
        else {
            this.target.attribute.points = this.points;
        }
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}

class CommonIn extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c;
        super.onBind();
        const attrs = this.target.getFinalAttribute();
        const fromAttrs = (_a = this.target.attribute) !== null && _a !== void 0 ? _a : {};
        const to = {};
        const from = (_b = this.from) !== null && _b !== void 0 ? _b : {};
        this.keys.forEach(key => {
            var _a, _b, _c;
            to[key] = (_a = attrs === null || attrs === void 0 ? void 0 : attrs[key]) !== null && _a !== void 0 ? _a : 1;
            from[key] = (_c = (_b = from[key]) !== null && _b !== void 0 ? _b : fromAttrs[key]) !== null && _c !== void 0 ? _c : 0;
        });
        const finalAttribute = this.target.getFinalAttribute();
        if (finalAttribute) {
            this.target.setAttributes(finalAttribute);
        }
        this.props = to;
        this.propKeys = this.keys;
        this.from = from;
        this.to = to;
        if (((_c = this.params.controlOptions) === null || _c === void 0 ? void 0 : _c.immediatelyApply) !== false) {
            this.target.setAttributes(from);
        }
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class CommonOut extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        super.onBind();
        const attrs = this.target.attribute;
        const to = {};
        const from = {};
        this.keys.forEach(key => {
            var _a;
            to[key] = 0;
            from[key] = (_a = attrs[key]) !== null && _a !== void 0 ? _a : 1;
        });
        this.props = to;
        this.propKeys = this.keys;
        this.from = from;
        this.to = to;
        Object.assign(this.target.attribute, from);
        this.target.addUpdatePositionTag();
        this.target.addUpdateBoundTag();
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}

class GroupFadeIn extends CommonIn {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.keys = ['baseOpacity'];
        this.from = { baseOpacity: 0 };
    }
}
class GroupFadeOut extends CommonOut {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.keys = ['baseOpacity'];
    }
}

class RotateBySphereAnimate extends ACustomAnimate {
    onBind() {
        super.onBind();
        this.propKeys = ['x', 'y', 'z', 'alpha', 'zIndex'];
    }
    onFirstRun() {
        super.onFirstRun();
        const finalAttribute = this.target.getFinalAttribute();
        if (finalAttribute) {
            this.target.setAttributes(finalAttribute);
        }
    }
    onStart() {
        super.onStart();
        const { center, r } = typeof this.params === 'function' ? this.params() : this.params;
        const startX = this.target.finalAttribute.x;
        const startY = this.target.finalAttribute.y;
        const startZ = this.target.finalAttribute.z;
        const phi = Math.acos((startY - center.y) / r);
        let theta = Math.acos((startX - center.x) / r / Math.sin(phi));
        if (startZ - center.z < 0) {
            theta = pi2 - theta;
        }
        this.theta = theta;
        this.phi = phi;
    }
    onEnd() {
        return;
    }
    onUpdate(end, ratio, out) {
        if (this.phi == null || this.theta == null) {
            return;
        }
        const target = this.target;
        const { center, r, cb } = typeof this.params === 'function' ? this.params() : this.params;
        const deltaAngle = Math.PI * 2 * ratio;
        const theta = this.theta + deltaAngle;
        const phi = this.phi;
        const x = r * Math.sin(phi) * Math.cos(theta) + center.x;
        const y = r * Math.cos(phi) + center.y;
        const z = r * Math.sin(phi) * Math.sin(theta) + center.z;
        target.attribute.x = x;
        target.attribute.y = y;
        target.attribute.z = z;
        target.attribute.alpha = theta + pi / 2;
        while (target.attribute.alpha > pi2) {
            target.attribute.alpha -= pi2;
        }
        target.attribute.alpha = pi2 - target.attribute.alpha;
        target.attribute.zIndex = target.attribute.z * -10000;
        cb && cb(out);
    }
}

class ClipIn extends CommonIn {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.keys = ['clipRange'];
        this.from = { clipRange: 0 };
    }
    onFirstRun() {
        var _a;
        super.onFirstRun();
        const { clipDimension } = ((_a = this.params) === null || _a === void 0 ? void 0 : _a.options) || {};
        if (clipDimension) {
            this.target.attribute.clipRangeByDimension = clipDimension;
        }
    }
}
class ClipOut extends CommonOut {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.keys = ['clipRange'];
    }
}

class FadeIn extends CommonIn {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.keys = ['opacity', 'fillOpacity', 'strokeOpacity'];
        this.from = { opacity: 0, fillOpacity: 0, strokeOpacity: 0 };
    }
}
class FadeOut extends CommonOut {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.keys = ['opacity', 'fillOpacity', 'strokeOpacity'];
    }
}

const growAngleInIndividual = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    if (options && options.orient === 'anticlockwise') {
        return {
            from: { startAngle: attrs === null || attrs === void 0 ? void 0 : attrs.endAngle },
            to: { startAngle: attrs === null || attrs === void 0 ? void 0 : attrs.startAngle }
        };
    }
    return {
        from: { endAngle: attrs === null || attrs === void 0 ? void 0 : attrs.startAngle },
        to: { endAngle: attrs === null || attrs === void 0 ? void 0 : attrs.endAngle }
    };
};
const growAngleInOverall = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    if (options && options.orient === 'anticlockwise') {
        const overallValue = isNumber(options.overall) ? options.overall : Math.PI * 2;
        return {
            from: {
                startAngle: overallValue,
                endAngle: overallValue
            },
            to: {
                startAngle: attrs === null || attrs === void 0 ? void 0 : attrs.startAngle,
                endAngle: attrs === null || attrs === void 0 ? void 0 : attrs.endAngle
            }
        };
    }
    const overallValue = isNumber(options === null || options === void 0 ? void 0 : options.overall) ? options.overall : 0;
    return {
        from: {
            startAngle: overallValue,
            endAngle: overallValue
        },
        to: {
            startAngle: attrs === null || attrs === void 0 ? void 0 : attrs.startAngle,
            endAngle: attrs === null || attrs === void 0 ? void 0 : attrs.endAngle
        }
    };
};
const growAngleIn = (graphic, options, animationParameters) => {
    var _a;
    return ((_a = options === null || options === void 0 ? void 0 : options.overall) !== null && _a !== void 0 ? _a : false) !== false
        ? growAngleInOverall(graphic, options)
        : growAngleInIndividual(graphic, options);
};
const growAngleOutIndividual = (graphic, options, animationParameters) => {
    const attrs = graphic.attribute;
    if (options && options.orient === 'anticlockwise') {
        return {
            from: { startAngle: attrs.startAngle },
            to: { startAngle: attrs === null || attrs === void 0 ? void 0 : attrs.endAngle }
        };
    }
    return {
        from: { endAngle: attrs.endAngle },
        to: { endAngle: attrs === null || attrs === void 0 ? void 0 : attrs.startAngle }
    };
};
const growAngleOutOverall = (graphic, options, animationParameters) => {
    const attrs = graphic.attribute;
    if (options && options.orient === 'anticlockwise') {
        const overallValue = isNumber(options.overall) ? options.overall : Math.PI * 2;
        return {
            from: {
                startAngle: attrs.startAngle,
                endAngle: attrs.endAngle
            },
            to: {
                startAngle: overallValue,
                endAngle: overallValue
            }
        };
    }
    const overallValue = isNumber(options === null || options === void 0 ? void 0 : options.overall) ? options.overall : 0;
    return {
        from: {
            startAngle: attrs.startAngle,
            endAngle: attrs.endAngle
        },
        to: {
            startAngle: overallValue,
            endAngle: overallValue
        }
    };
};
const growAngleOut = (graphic, options, animationParameters) => {
    var _a;
    return ((_a = options === null || options === void 0 ? void 0 : options.overall) !== null && _a !== void 0 ? _a : false) !== false
        ? growAngleOutOverall(graphic, options)
        : growAngleOutIndividual(graphic, options);
};
class GrowAngleBase extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    determineUpdateFunction() {
        if (!this.propKeys) {
            this.valid = false;
        }
        else if (this.propKeys && this.propKeys.length > 1) {
            this._updateFunction = this.updateAngle;
        }
        else if (this.propKeys[0] === 'startAngle') {
            this._updateFunction = this.updateStartAngle;
        }
        else if (this.propKeys[0] === 'endAngle') {
            this._updateFunction = this.updateEndAngle;
        }
        else {
            this.valid = false;
        }
    }
    deleteSelfAttr(key) {
        delete this.props[key];
        this.fromProps && delete this.fromProps[key];
        const index = this.propKeys.indexOf(key);
        if (index !== -1) {
            this.propKeys.splice(index, 1);
        }
        if (this.propKeys && this.propKeys.length > 1) {
            this._updateFunction = this.updateAngle;
        }
        else if (this.propKeys[0] === 'startAngle') {
            this._updateFunction = this.updateStartAngle;
        }
        else if (this.propKeys[0] === 'endAngle') {
            this._updateFunction = this.updateEndAngle;
        }
        else {
            this._updateFunction = null;
        }
    }
    updateStartAngle(ratio) {
        this.target.attribute.startAngle =
            this.from.startAngle + (this.to.startAngle - this.from.startAngle) * ratio;
    }
    updateEndAngle(ratio) {
        this.target.attribute.endAngle = this.from.endAngle + (this.to.endAngle - this.from.endAngle) * ratio;
    }
    updateAngle(ratio) {
        this.updateStartAngle(ratio);
        this.updateEndAngle(ratio);
    }
    onUpdate(end, ratio, out) {
        if (this._updateFunction) {
            this._updateFunction(ratio);
            this.target.addUpdateShapeAndBoundsTag();
        }
    }
}
class GrowAngleIn extends GrowAngleBase {
    onBind() {
        var _a, _b, _c;
        super.onBind();
        const { from, to } = growAngleIn(this.target, this.params.options, this.params);
        const fromAttrs = (_b = (_a = this.target.context) === null || _a === void 0 ? void 0 : _a.lastAttrs) !== null && _b !== void 0 ? _b : from;
        this.props = to;
        this.propKeys = Object.keys(to).filter(key => to[key] != null);
        this.from = fromAttrs;
        this.to = to;
        const finalAttribute = this.target.getFinalAttribute();
        if (finalAttribute) {
            this.target.setAttributes(finalAttribute);
        }
        if (((_c = this.params.controlOptions) === null || _c === void 0 ? void 0 : _c.immediatelyApply) !== false) {
            this.target.setAttributes(fromAttrs);
        }
        this.determineUpdateFunction();
    }
}
class GrowAngleOut extends GrowAngleBase {
    onBind() {
        super.onBind();
        const { from, to } = growAngleOut(this.target, this.params.options, this.params);
        const fromAttrs = from;
        this.props = to;
        this.propKeys = Object.keys(to).filter(key => to[key] != null);
        this.from = fromAttrs !== null && fromAttrs !== void 0 ? fromAttrs : this.target.attribute;
        this.to = to;
        this.determineUpdateFunction();
    }
}

const growCenterIn = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    switch (options === null || options === void 0 ? void 0 : options.direction) {
        case 'x': {
            const x = attrs.x;
            const x1 = attrs.x1;
            const width = attrs.width;
            return {
                from: isValid(width)
                    ? {
                        x: x + width / 2,
                        x1: undefined,
                        width: 0
                    }
                    : {
                        x: (x + x1) / 2,
                        x1: (x + x1) / 2,
                        width: undefined
                    },
                to: { x, x1, width }
            };
        }
        case 'y': {
            const y = attrs.y;
            const y1 = attrs.y1;
            const height = attrs.height;
            return {
                from: isValid(height)
                    ? {
                        y: y + height / 2,
                        y1: undefined,
                        height: 0
                    }
                    : {
                        y: (y + y1) / 2,
                        y1: (y + y1) / 2,
                        height: undefined
                    },
                to: { y, y1, height }
            };
        }
        case 'xy':
        default: {
            const x = attrs.x;
            const x1 = attrs.x1;
            const width = attrs.width;
            const y = attrs.y;
            const y1 = attrs.y1;
            const height = attrs.height;
            const from = {};
            if (isValid(width)) {
                from.x = x + width / 2;
                from.width = 0;
                from.x1 = undefined;
            }
            else {
                from.x = (x + x1) / 2;
                from.x1 = (x + x1) / 2;
                from.width = undefined;
            }
            if (isValid(height)) {
                from.y = y + height / 2;
                from.height = 0;
                from.y1 = undefined;
            }
            else {
                from.y = (y + y1) / 2;
                from.y1 = (y + y1) / 2;
                from.height = undefined;
            }
            return {
                from,
                to: { x, y, x1, y1, width, height }
            };
        }
    }
};
const growCenterOut = (graphic, options, animationParameters) => {
    const attrs = graphic.attribute;
    switch (options === null || options === void 0 ? void 0 : options.direction) {
        case 'x': {
            const x = attrs.x;
            const x1 = attrs.x1;
            const width = attrs.width;
            return {
                to: isValid(width)
                    ? {
                        x: x + width / 2,
                        x1: undefined,
                        width: 0
                    }
                    : {
                        x: (x + x1) / 2,
                        x1: (x + x1) / 2,
                        width: undefined
                    }
            };
        }
        case 'y': {
            const y = attrs.y;
            const y1 = attrs.y1;
            const height = attrs.height;
            return {
                to: isValid(height)
                    ? {
                        y: y + height / 2,
                        y1: undefined,
                        height: 0
                    }
                    : {
                        y: (y + y1) / 2,
                        y1: (y + y1) / 2,
                        height: undefined
                    }
            };
        }
        case 'xy':
        default: {
            const x = attrs.x;
            const y = attrs.y;
            const x1 = attrs.x1;
            const y1 = attrs.y1;
            const width = attrs.width;
            const height = attrs.height;
            const to = {};
            if (isValid(width)) {
                to.x = x + width / 2;
                to.width = 0;
                to.x1 = undefined;
            }
            else {
                to.x = (x + x1) / 2;
                to.x1 = (x + x1) / 2;
                to.width = undefined;
            }
            if (isValid(height)) {
                to.y = y + height / 2;
                to.height = 0;
                to.y1 = undefined;
            }
            else {
                to.y = (y + y1) / 2;
                to.y1 = (y + y1) / 2;
                to.height = undefined;
            }
            return {
                to
            };
        }
    }
};
class GrowCenterIn extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c;
        super.onBind();
        const { from, to } = growCenterIn(this.target, this.params.options, this.params);
        const fromAttrs = (_b = (_a = this.target.context) === null || _a === void 0 ? void 0 : _a.lastAttrs) !== null && _b !== void 0 ? _b : from;
        this.props = to;
        this.propKeys = Object.keys(to).filter(key => to[key] != null);
        this.from = fromAttrs;
        this.to = to;
        const finalAttribute = this.target.getFinalAttribute();
        if (finalAttribute) {
            this.target.setAttributes(finalAttribute);
        }
        if (((_c = this.params.controlOptions) === null || _c === void 0 ? void 0 : _c.immediatelyApply) !== false) {
            this.target.setAttributes(fromAttrs);
        }
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class GrowCenterOut extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        super.onBind();
        const { from, to } = growCenterOut(this.target, this.params.options, this.params);
        this.props = to;
        this.propKeys = Object.keys(to).filter(key => to[key] != null);
        this.from = from !== null && from !== void 0 ? from : this.target.attribute;
        this.to = to;
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}

function growHeightInIndividual(graphic, options, animationParameters) {
    const attrs = graphic.getFinalAttribute();
    const y = attrs.y;
    const y1 = attrs.y1;
    const height = attrs.height;
    if (options && options.orient === 'negative') {
        const computedY1 = isValid(height) ? Math.max(y, y + height) : Math.max(y, y1);
        return {
            from: { y: computedY1, y1: isNil(y1) ? undefined : computedY1, height: isNil(height) ? undefined : 0 },
            to: { y: y, y1: y1, height: height }
        };
    }
    const computedY = isValid(height) ? Math.min(y, y + height) : Math.min(y, y1);
    return {
        from: { y: computedY, y1: isNil(y1) ? undefined : computedY, height: isNil(height) ? undefined : 0 },
        to: { y: y, y1: y1, height: height }
    };
}
function growHeightInOverall(graphic, options, animationParameters) {
    var _a, _b, _c;
    const attrs = graphic.getFinalAttribute();
    const y = attrs.y;
    const y1 = attrs.y1;
    const height = attrs.height;
    let overallValue;
    if (options && options.orient === 'negative') {
        if (isNumber(options.overall)) {
            overallValue = options.overall;
        }
        else if (animationParameters.group) {
            overallValue =
                (_c = (_a = animationParameters.groupHeight) !== null && _a !== void 0 ? _a : (_b = options.layoutRect) === null || _b === void 0 ? void 0 : _b.height) !== null && _c !== void 0 ? _c : animationParameters.group.getBounds().height();
            animationParameters.groupHeight = overallValue;
        }
        else {
            overallValue = animationParameters.height;
        }
    }
    else {
        overallValue = isNumber(options === null || options === void 0 ? void 0 : options.overall) ? options.overall : 0;
    }
    return {
        from: { y: overallValue, y1: isNil(y1) ? undefined : overallValue, height: isNil(height) ? undefined : 0 },
        to: { y: y, y1: y1, height: height }
    };
}
const growHeightIn = (graphic, options, animationParameters) => {
    var _a;
    return ((_a = options === null || options === void 0 ? void 0 : options.overall) !== null && _a !== void 0 ? _a : false) !== false
        ? growHeightInOverall(graphic, options, animationParameters)
        : growHeightInIndividual(graphic, options);
};
class GrowHeightIn extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c;
        super.onBind();
        const { from, to } = growHeightIn(this.target, this.params.options, this.params);
        const fromAttrs = (_b = (_a = this.target.context) === null || _a === void 0 ? void 0 : _a.lastAttrs) !== null && _b !== void 0 ? _b : from;
        this.props = to;
        this.propKeys = Object.keys(to).filter(key => to[key] != null);
        this.from = fromAttrs;
        this.to = to;
        const finalAttribute = this.target.getFinalAttribute();
        if (finalAttribute) {
            this.target.setAttributes(finalAttribute);
        }
        if (((_c = this.params.controlOptions) === null || _c === void 0 ? void 0 : _c.immediatelyApply) !== false) {
            this.target.setAttributes(fromAttrs);
        }
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
function growHeightOutIndividual(graphic, options, animationParameters) {
    const attrs = graphic.getFinalAttribute();
    const y = attrs.y;
    const y1 = attrs.y1;
    const height = attrs.height;
    if (options && options.orient === 'negative') {
        const computedY1 = isValid(height) ? Math.max(y, y + height) : Math.max(y, y1);
        return {
            to: { y: computedY1, y1: isNil(y1) ? undefined : computedY1, height: isNil(height) ? undefined : 0 }
        };
    }
    const computedY = isValid(height) ? Math.min(y, y + height) : Math.min(y, y1);
    return {
        to: { y: computedY, y1: isNil(y1) ? undefined : computedY, height: isNil(height) ? undefined : 0 }
    };
}
function growHeightOutOverall(graphic, options, animationParameters) {
    var _a, _b, _c;
    const attrs = graphic.getFinalAttribute();
    const y1 = attrs.y1;
    const height = attrs.height;
    let overallValue;
    if (options && options.orient === 'negative') {
        if (isNumber(options.overall)) {
            overallValue = options.overall;
        }
        else if (animationParameters.group) {
            overallValue =
                (_c = (_a = animationParameters.groupHeight) !== null && _a !== void 0 ? _a : (_b = options.layoutRect) === null || _b === void 0 ? void 0 : _b.height) !== null && _c !== void 0 ? _c : animationParameters.group.getBounds().height();
            animationParameters.groupHeight = overallValue;
        }
        else {
            overallValue = animationParameters.height;
        }
    }
    else {
        overallValue = isNumber(options === null || options === void 0 ? void 0 : options.overall) ? options.overall : 0;
    }
    return {
        to: { y: overallValue, y1: isNil(y1) ? undefined : overallValue, height: isNil(height) ? undefined : 0 }
    };
}
const growHeightOut = (graphic, options, animationParameters) => {
    var _a;
    return ((_a = options === null || options === void 0 ? void 0 : options.overall) !== null && _a !== void 0 ? _a : false) !== false
        ? growHeightOutOverall(graphic, options, animationParameters)
        : growHeightOutIndividual(graphic, options);
};
class GrowHeightOut extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        super.onBind();
        const { from, to } = growHeightOut(this.target, this.params.options, this.params);
        this.props = to;
        this.propKeys = Object.keys(to).filter(key => to[key] != null);
        this.from = from !== null && from !== void 0 ? from : this.target.attribute;
        this.to = to;
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}

const getCenterPoints = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    const points = attrs.points;
    const center = { x: 0, y: 0 };
    points.forEach(point => {
        center.x += point.x;
        center.y += point.y;
    });
    center.x /= points.length;
    center.y /= points.length;
    if (options && options.center) {
        if (isValidNumber(options.center.x)) {
            center.x = options.center.x;
        }
        if (isValidNumber(options.center.y)) {
            center.y = options.center.y;
        }
    }
    if (graphic.type === 'area') {
        center.x1 = center.x;
        center.y1 = center.y;
    }
    return points.map(point => Object.assign({}, point, center));
};
const growPointsIn = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    return {
        from: { points: getCenterPoints(graphic, options) },
        to: { points: attrs.points }
    };
};
const growPointsOut = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    return {
        from: { points: attrs.points },
        to: { points: getCenterPoints(graphic, options) }
    };
};
class GworPointsBase extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onUpdate(end, ratio, out) {
        var _a, _b;
        const fromPoints = (_a = this.from) === null || _a === void 0 ? void 0 : _a.points;
        const toPoints = (_b = this.to) === null || _b === void 0 ? void 0 : _b.points;
        if (!fromPoints || !toPoints) {
            return;
        }
        this.target.attribute.points = fromPoints.map((point, index) => {
            const newPoint = pointInterpolation(fromPoints[index], toPoints[index], ratio);
            return newPoint;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class GrowPointsIn extends GworPointsBase {
    onBind() {
        var _a;
        super.onBind();
        if (['area', 'line', 'polygon'].includes(this.target.type)) {
            const { from, to } = growPointsIn(this.target, this.params.options, this.params);
            this.props = to;
            this.propKeys = Object.keys(to).filter(key => to[key] != null);
            this.from = from;
            this.to = to;
            const finalAttribute = this.target.getFinalAttribute();
            if (finalAttribute) {
                this.target.setAttributes(finalAttribute);
            }
            if (((_a = this.params.controlOptions) === null || _a === void 0 ? void 0 : _a.immediatelyApply) !== false) {
                this.target.setAttributes(from);
            }
        }
        else {
            this.valid = false;
        }
    }
}
class GrowPointsOut extends GworPointsBase {
    onBind() {
        super.onBind();
        if (['area', 'line'].includes(this.target.type)) {
            const attrs = this.target.getFinalAttribute();
            const { from, to } = growPointsOut(this.target, this.params.options, this.params);
            this.props = to;
            this.propKeys = Object.keys(to).filter(key => to[key] != null);
            this.from = from || attrs;
            this.to = to;
        }
        else {
            this.valid = false;
        }
    }
}
const changePointsX = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    const points = attrs.points;
    return points.map((point) => {
        if (options && options.orient === 'negative') {
            let groupRight = graphic.stage.viewWidth;
            if (graphic.parent.parent.parent) {
                groupRight = graphic.parent.parent.parent.AABBBounds.width();
            }
            return Object.assign(Object.assign({}, point), { x: groupRight, y: point.y, x1: groupRight, y1: point.y1, defined: point.defined !== false });
        }
        return Object.assign(Object.assign({}, point), { x: 0, y: point.y, x1: 0, y1: point.y1, defined: point.defined !== false });
    });
};
const growPointsXIn = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    return {
        from: { points: changePointsX(graphic, options) },
        to: { points: attrs.points }
    };
};
const growPointsXOut = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    return {
        from: { points: attrs.points },
        to: { points: changePointsX(graphic, options) }
    };
};
class GrowPointsXIn extends GworPointsBase {
    onBind() {
        var _a;
        super.onBind();
        if (['area', 'line', 'polygon'].includes(this.target.type)) {
            const { from, to } = growPointsXIn(this.target, this.params.options, this.params);
            this.props = to;
            this.propKeys = Object.keys(to).filter(key => to[key] != null);
            this.from = from;
            this.to = to;
            const finalAttribute = this.target.getFinalAttribute();
            if (finalAttribute) {
                this.target.setAttributes(finalAttribute);
            }
            if (((_a = this.params.controlOptions) === null || _a === void 0 ? void 0 : _a.immediatelyApply) !== false) {
                this.target.setAttributes(from);
            }
        }
        else {
            this.valid = false;
        }
    }
}
class GrowPointsXOut extends GworPointsBase {
    onBind() {
        super.onBind();
        if (['area', 'line'].includes(this.target.type)) {
            const attrs = this.target.getFinalAttribute();
            const { from, to } = growPointsXOut(this.target, this.params.options, this.params);
            this.props = to;
            this.propKeys = Object.keys(to).filter(key => to[key] != null);
            this.from = from || attrs;
            this.to = to;
        }
        else {
            this.valid = false;
        }
    }
}
const changePointsY = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    const points = attrs.points;
    return points.map((point) => {
        if (options && options.orient === 'negative') {
            let groupBottom = graphic.stage.viewHeight;
            if (graphic.parent.parent.parent) {
                groupBottom = graphic.parent.parent.parent.AABBBounds.height();
            }
            return Object.assign(Object.assign({}, point), { x: point.x, y: groupBottom, x1: point.x1, y1: groupBottom, defined: point.defined !== false });
        }
        return Object.assign(Object.assign({}, point), { x: point.x, y: 0, x1: point.x1, y1: 0, defined: point.defined !== false });
    });
};
const growPointsYIn = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    return {
        from: { points: changePointsY(graphic, options) },
        to: { points: attrs.points }
    };
};
const growPointsYOut = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    return {
        from: { points: attrs.points },
        to: { points: changePointsY(graphic, options) }
    };
};
class GrowPointsYIn extends GworPointsBase {
    onBind() {
        var _a;
        super.onBind();
        if (['area', 'line', 'polygon'].includes(this.target.type)) {
            const { from, to } = growPointsYIn(this.target, this.params.options, this.params);
            this.props = to;
            this.propKeys = Object.keys(to).filter(key => to[key] != null);
            this.from = from;
            this.to = to;
            const finalAttribute = this.target.getFinalAttribute();
            if (finalAttribute) {
                this.target.setAttributes(finalAttribute);
            }
            if (((_a = this.params.controlOptions) === null || _a === void 0 ? void 0 : _a.immediatelyApply) !== false) {
                this.target.setAttributes(from);
            }
        }
        else {
            this.valid = false;
        }
    }
}
class GrowPointsYOut extends GworPointsBase {
    onBind() {
        super.onBind();
        if (['area', 'line', 'polygon'].includes(this.target.type)) {
            const { from, to } = growPointsYOut(this.target, this.params.options, this.params);
            this.props = to;
            this.propKeys = Object.keys(to).filter(key => to[key] != null);
            this.from = from !== null && from !== void 0 ? from : this.target.attribute;
            this.to = to;
        }
        else {
            this.valid = false;
        }
    }
}

const growRadiusInIndividual = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    if (options && options.orient === 'inside') {
        return {
            from: { innerRadius: attrs === null || attrs === void 0 ? void 0 : attrs.outerRadius },
            to: { innerRadius: attrs === null || attrs === void 0 ? void 0 : attrs.innerRadius }
        };
    }
    return {
        from: { outerRadius: attrs === null || attrs === void 0 ? void 0 : attrs.innerRadius },
        to: { outerRadius: attrs === null || attrs === void 0 ? void 0 : attrs.outerRadius }
    };
};
const growRadiusInOverall = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    const overallValue = isNumber(options === null || options === void 0 ? void 0 : options.overall) ? options.overall : 0;
    return {
        from: {
            innerRadius: overallValue,
            outerRadius: overallValue
        },
        to: {
            innerRadius: attrs === null || attrs === void 0 ? void 0 : attrs.innerRadius,
            outerRadius: attrs === null || attrs === void 0 ? void 0 : attrs.outerRadius
        }
    };
};
const growRadiusIn = (graphic, options, animationParameters) => {
    var _a;
    return ((_a = options === null || options === void 0 ? void 0 : options.overall) !== null && _a !== void 0 ? _a : false) !== false
        ? growRadiusInOverall(graphic, options)
        : growRadiusInIndividual(graphic, options);
};
const growRadiusOutIndividual = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    if (options && options.orient === 'inside') {
        return {
            from: { innerRadius: attrs === null || attrs === void 0 ? void 0 : attrs.innerRadius },
            to: { innerRadius: attrs === null || attrs === void 0 ? void 0 : attrs.outerRadius }
        };
    }
    return {
        from: { outerRadius: attrs === null || attrs === void 0 ? void 0 : attrs.outerRadius },
        to: { outerRadius: attrs === null || attrs === void 0 ? void 0 : attrs.innerRadius }
    };
};
const growRadiusOutOverall = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    const overallValue = isNumber(options === null || options === void 0 ? void 0 : options.overall) ? options.overall : 0;
    return {
        from: {
            innerRadius: attrs === null || attrs === void 0 ? void 0 : attrs.innerRadius,
            outerRadius: attrs === null || attrs === void 0 ? void 0 : attrs.outerRadius
        },
        to: {
            innerRadius: overallValue,
            outerRadius: overallValue
        }
    };
};
const growRadiusOut = (graphic, options, animationParameters) => {
    var _a;
    return ((_a = options === null || options === void 0 ? void 0 : options.overall) !== null && _a !== void 0 ? _a : false) !== false
        ? growRadiusOutOverall(graphic, options)
        : growRadiusOutIndividual(graphic, options);
};
class GrowPointsBase extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class GrowRadiusIn extends GrowPointsBase {
    onBind() {
        var _a, _b, _c;
        super.onBind();
        const { from, to } = growRadiusIn(this.target, this.params.options, this.params);
        const fromAttrs = (_b = (_a = this.target.context) === null || _a === void 0 ? void 0 : _a.lastAttrs) !== null && _b !== void 0 ? _b : from;
        this.props = to;
        this.propKeys = Object.keys(to).filter(key => to[key] != null);
        this.from = fromAttrs;
        this.to = to;
        const finalAttribute = this.target.getFinalAttribute();
        if (finalAttribute) {
            this.target.setAttributes(finalAttribute);
        }
        if (((_c = this.params.controlOptions) === null || _c === void 0 ? void 0 : _c.immediatelyApply) !== false) {
            this.target.setAttributes(fromAttrs);
        }
    }
}
class GrowRadiusOut extends GrowPointsBase {
    onBind() {
        super.onBind();
        const { to } = growRadiusOut(this.target, this.params.options, this.params);
        this.props = to;
        this.propKeys = Object.keys(to).filter(key => to[key] != null);
        this.from = this.target.attribute;
        this.to = to;
    }
}

function growWidthInIndividual(graphic, options, animationParameters) {
    const attrs = graphic.getFinalAttribute();
    const x = attrs.x;
    const x1 = attrs.x1;
    const width = attrs.width;
    if (options && options.orient === 'negative') {
        const computedX1 = isValid(width) ? Math.max(x, x + width) : Math.max(x, x1);
        return {
            from: { x: computedX1, x1: isNil(x1) ? undefined : computedX1, width: isNil(width) ? undefined : 0 },
            to: { x: x, x1: x1, width: width }
        };
    }
    const computedX = isValid(width) ? Math.min(x, x + width) : Math.min(x, x1);
    return {
        from: { x: computedX, x1: isNil(x1) ? undefined : computedX, width: isNil(width) ? undefined : 0 },
        to: { x: x, x1: x1, width: width }
    };
}
function growWidthInOverall(graphic, options, animationParameters) {
    var _a;
    const attrs = graphic.getFinalAttribute();
    const x = attrs.x;
    const x1 = attrs.x1;
    const width = attrs.width;
    let overallValue;
    if (options && options.orient === 'negative') {
        if (isNumber(options.overall)) {
            overallValue = options.overall;
        }
        else if (animationParameters.group) {
            overallValue = (_a = animationParameters.groupWidth) !== null && _a !== void 0 ? _a : animationParameters.group.getBounds().width();
            animationParameters.groupWidth = overallValue;
        }
        else {
            overallValue = animationParameters.width;
        }
    }
    else {
        overallValue = isNumber(options === null || options === void 0 ? void 0 : options.overall) ? options === null || options === void 0 ? void 0 : options.overall : 0;
    }
    return {
        from: { x: overallValue, x1: isNil(x1) ? undefined : overallValue, width: isNil(width) ? undefined : 0 },
        to: { x: x, x1: x1, width: width }
    };
}
const growWidthIn = (graphic, options, animationParameters) => {
    var _a;
    return ((_a = options === null || options === void 0 ? void 0 : options.overall) !== null && _a !== void 0 ? _a : false) !== false
        ? growWidthInOverall(graphic, options, animationParameters)
        : growWidthInIndividual(graphic, options);
};
function growWidthOutIndividual(graphic, options, animationParameters) {
    const attrs = graphic.getFinalAttribute();
    const x = attrs.x;
    const x1 = attrs.x1;
    const width = attrs.width;
    if (options && options.orient === 'negative') {
        const computedX1 = isValid(width) ? Math.max(x, x + width) : Math.max(x, x1);
        return {
            to: { x: computedX1, x1: isNil(x1) ? undefined : computedX1, width: isNil(width) ? undefined : 0 }
        };
    }
    const computedX = isValid(width) ? Math.min(x, x + width) : Math.min(x, x1);
    return {
        to: { x: computedX, x1: isNil(x1) ? undefined : computedX, width: isNil(width) ? undefined : 0 }
    };
}
function growWidthOutOverall(graphic, options, animationParameters) {
    var _a;
    const attrs = graphic.getFinalAttribute();
    const x1 = attrs.x1;
    const width = attrs.width;
    let overallValue;
    if (options && options.orient === 'negative') {
        if (isNumber(options.overall)) {
            overallValue = options.overall;
        }
        else if (animationParameters.group) {
            overallValue = (_a = animationParameters.groupWidth) !== null && _a !== void 0 ? _a : animationParameters.group.getBounds().width();
            animationParameters.groupWidth = overallValue;
        }
        else {
            overallValue = animationParameters.width;
        }
    }
    else {
        overallValue = isNumber(options === null || options === void 0 ? void 0 : options.overall) ? options.overall : 0;
    }
    return {
        to: { x: overallValue, x1: isNil(x1) ? undefined : overallValue, width: isNil(width) ? undefined : 0 }
    };
}
const growWidthOut = (graphic, options, animationParameters) => {
    var _a;
    return ((_a = options === null || options === void 0 ? void 0 : options.overall) !== null && _a !== void 0 ? _a : false) !== false
        ? growWidthOutOverall(graphic, options, animationParameters)
        : growWidthOutIndividual(graphic, options);
};
class GrowWidthIn extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c;
        super.onBind();
        const { from, to } = growWidthIn(this.target, this.params.options, this.params);
        const fromAttrs = (_b = (_a = this.target.context) === null || _a === void 0 ? void 0 : _a.lastAttrs) !== null && _b !== void 0 ? _b : from;
        this.props = to;
        this.propKeys = Object.keys(to).filter(key => to[key] != null);
        this.from = fromAttrs;
        this.to = to;
        const finalAttribute = this.target.getFinalAttribute();
        if (finalAttribute) {
            this.target.setAttributes(finalAttribute);
        }
        if (((_c = this.params.controlOptions) === null || _c === void 0 ? void 0 : _c.immediatelyApply) !== false) {
            this.target.setAttributes(fromAttrs);
        }
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class GrowWidthOut extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        super.onBind();
        const { from, to } = growWidthOut(this.target, this.params.options, this.params);
        this.props = to;
        this.propKeys = Object.keys(to).filter(key => to[key] != null);
        this.from = from !== null && from !== void 0 ? from : this.target.attribute;
        this.to = to;
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}

class LabelItemAppear extends AComponentAnimate {
    onBind() {
        super.onBind();
        const animator = createComponentAnimator(this.target);
        this._animator = animator;
        const duration = this.duration;
        const easing = this.easing;
        const target = this.target;
        const { symbolStartOuterType = 'scale', titleType = 'typewriter', titlePanelType = 'scale' } = this.params;
        const symbolTime = duration / 10;
        target._symbolStart.setAttributes({ scaleX: 0, scaleY: 0 });
        animator.animate(target._symbolStart, {
            type: 'to',
            to: { scaleX: 1, scaleY: 1 },
            duration: symbolTime * 5,
            easing
        });
        let symbolStartOuterFrom;
        let symbolStartOuterTo;
        if (symbolStartOuterType === 'scale') {
            symbolStartOuterFrom = { scaleX: 0, scaleY: 0 };
            symbolStartOuterTo = { scaleX: 1, scaleY: 1 };
        }
        else {
            symbolStartOuterFrom = { clipRange: 0 };
            symbolStartOuterTo = { clipRange: 1 };
        }
        target._symbolStartOuter.setAttributes(symbolStartOuterFrom);
        animator.animate(target._symbolStartOuter, {
            type: 'to',
            to: symbolStartOuterTo,
            duration: symbolTime * 5,
            easing
        });
        target._symbolEnd.setAttributes({ scaleX: 0, scaleY: 0 });
        animator.animate(target._symbolEnd, {
            type: 'to',
            to: { scaleX: 1, scaleY: 1 },
            duration: symbolTime * 2,
            delay: symbolTime * 8,
            easing
        });
        target._line.setAttributes({ clipRange: 0 });
        animator.animate(target._line, {
            type: 'to',
            to: { clipRange: 1 },
            duration: symbolTime * 9,
            easing
        });
        if (titleType === 'typewriter') {
            const titleTopText = target._titleTop.attribute.text;
            target._titleTop.setAttributes({ text: '' });
            animator.animate(target._titleTop, {
                type: 'custom',
                delay: symbolTime * 5,
                duration: symbolTime * 4,
                easing: 'linear',
                to: { text: titleTopText },
                custom: InputText
            });
            const titleBottomText = target._titleBottom.attribute.text;
            target._titleBottom.setAttributes({ text: '' });
            animator.animate(target._titleBottom, {
                type: 'custom',
                delay: symbolTime * 5,
                duration: symbolTime * 4,
                easing: 'linear',
                to: { text: titleBottomText },
                custom: InputText
            });
        }
        else {
            target._titleTop.setAttributes({ dy: target._titleTop.AABBBounds.height() + 10 });
            animator.animate(target._titleTop, {
                type: 'to',
                to: {
                    dy: 0
                },
                delay: symbolTime * 5,
                duration: symbolTime * 4,
                easing: 'linear'
            });
            target._titleBottom.setAttributes({ dy: -(10 + target._titleBottom.AABBBounds.height()) });
            animator.animate(target._titleBottom, {
                type: 'to',
                to: {
                    dy: 0
                },
                delay: symbolTime * 5,
                duration: symbolTime * 4,
                easing: 'linear'
            });
        }
        if (titlePanelType === 'scale') {
            [target._titleTopPanel, target._titleBottomPanel].forEach(panel => {
                var _a;
                const scaleX = (_a = panel.attribute.scaleX) !== null && _a !== void 0 ? _a : 1;
                panel.setAttributes({ scaleX: 0 });
                animator.animate(panel, {
                    type: 'to',
                    to: {
                        scaleX
                    },
                    duration,
                    easing
                });
            });
        }
        else if (titlePanelType === 'stroke') {
            [target._titleTopPanel, target._titleBottomPanel].forEach(panel => {
                const b = panel.AABBBounds;
                const totalLen = (b.width() + b.height()) * 2;
                panel.setAttributes({ lineDash: [0, totalLen * 10] });
                animator.animate(panel, {
                    type: 'to',
                    to: {
                        lineDash: [totalLen, totalLen * 10]
                    },
                    duration,
                    easing
                });
            });
        }
        this.completeBind(animator);
    }
}
class LabelItemDisappear extends AComponentAnimate {
    onBind() {
        super.onBind();
        const animator = createComponentAnimator(this.target);
        this._animator = animator;
        const duration = this.duration;
        const easing = this.easing;
        const target = this.target;
        const { mode } = this.params;
        if (mode === 'scale') {
            animator.animate(target._symbolStart, {
                type: 'to',
                to: { scaleX: 0, scaleY: 0 },
                duration,
                easing
            });
        }
        else {
            animator.animate(target._line, {
                type: 'to',
                to: { clipRange: 0 },
                duration,
                easing
            });
            animator.animate(target._symbolStart, {
                type: 'to',
                to: { scaleX: 0, scaleY: 0 },
                duration: duration / 2,
                delay: duration / 2,
                easing
            });
            animator.animate(target._symbolEnd, {
                type: 'to',
                to: { scaleX: 0, scaleY: 0 },
                duration,
                easing
            });
            animator.animate(target._titleTop, {
                type: 'to',
                to: { dy: target._titleTop.AABBBounds.height() + 10 },
                duration: duration / 2,
                easing
            });
            animator.animate(target._titleBottom, {
                type: 'to',
                to: { dy: -(10 + target._titleBottom.AABBBounds.height()) },
                duration: duration / 2,
                easing
            });
            animator.animate(target._symbolStartOuter, {
                type: 'to',
                to: { clipRange: 0 },
                duration: duration / 2,
                delay: duration / 2,
                easing
            });
            animator.animate(target._titleTopPanel, {
                type: 'to',
                to: { scaleX: 0 },
                duration,
                easing
            });
            animator.animate(target._titleBottomPanel, {
                type: 'to',
                to: { scaleX: 0 },
                duration,
                easing
            });
        }
        this.completeBind(animator);
    }
}

class PoptipAppear extends AComponentAnimate {
    onBind() {
        super.onBind();
        const animator = createComponentAnimator(this.target);
        this._animator = animator;
        const duration = this.duration;
        const easing = this.easing;
        const target = this.target;
        const { wave } = this.params;
        target.setAttributes({ scaleX: 0, scaleY: 0 });
        animator.animate(target, {
            type: 'to',
            to: { scaleX: 1, scaleY: 1 },
            duration: (duration / 3) * 2,
            easing
        });
        target.titleShape &&
            animator.animate(target.titleShape, {
                type: 'custom',
                to: { text: target.titleShape.attribute.text },
                duration,
                easing,
                custom: InputText
            });
        target.contentShape &&
            animator.animate(target.contentShape, {
                type: 'custom',
                to: { text: target.contentShape.attribute.text },
                duration,
                easing,
                custom: InputText
            });
        if (wave) {
            const dur = duration / 6;
            animator.animate(target.group, {
                timeSlices: [
                    {
                        duration: dur,
                        effects: {
                            type: 'to',
                            to: { angle: wave },
                            easing
                        }
                    },
                    {
                        duration: dur * 2,
                        effects: {
                            type: 'to',
                            to: { angle: -wave },
                            easing
                        }
                    },
                    {
                        duration: dur * 2,
                        effects: {
                            type: 'to',
                            to: { angle: wave },
                            easing
                        }
                    },
                    {
                        duration: dur,
                        effects: {
                            type: 'to',
                            to: { angle: 0 },
                            easing
                        }
                    }
                ]
            });
        }
        this.completeBind(animator);
    }
}
class PoptipDisappear extends AComponentAnimate {
    onBind() {
        super.onBind();
        const animator = createComponentAnimator(this.target);
        this._animator = animator;
        const duration = this.duration;
        const easing = this.easing;
        const target = this.target;
        animator.animate(target, {
            type: 'to',
            to: { scaleX: 0, scaleY: 0 },
            duration,
            easing
        });
        this.completeBind(animator);
    }
}

class InputRichText extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.fromTextConfig = [];
        this.toTextConfig = [];
        this.originalTextConfig = [];
        this.showCursor = false;
        this.cursorChar = '|';
        this.blinkCursor = true;
        this.fadeInChars = false;
        this.fadeInDuration = 0.3;
        this.strokeFirst = false;
        this.strokeToFillRatio = 0.3;
        if ((params === null || params === void 0 ? void 0 : params.showCursor) !== undefined) {
            this.showCursor = params.showCursor;
        }
        if ((params === null || params === void 0 ? void 0 : params.cursorChar) !== undefined) {
            this.cursorChar = params.cursorChar;
        }
        if ((params === null || params === void 0 ? void 0 : params.blinkCursor) !== undefined) {
            this.blinkCursor = params.blinkCursor;
        }
        if ((params === null || params === void 0 ? void 0 : params.fadeInChars) !== undefined) {
            this.fadeInChars = params.fadeInChars;
        }
        if ((params === null || params === void 0 ? void 0 : params.fadeInDuration) !== undefined) {
            this.fadeInDuration = params.fadeInDuration;
        }
        if ((params === null || params === void 0 ? void 0 : params.strokeFirst) !== undefined) {
            this.strokeFirst = params.strokeFirst;
        }
        if ((params === null || params === void 0 ? void 0 : params.strokeToFillRatio) !== undefined) {
            this.strokeToFillRatio = params.strokeToFillRatio;
        }
    }
    onFirstRun() {
        const fromProps = this.getLastProps();
        const toProps = this.getEndProps();
        this.originalTextConfig = toProps.textConfig ? [...toProps.textConfig] : [];
        this.valid = true;
        if (!this.originalTextConfig || this.originalTextConfig.length === 0) {
            this.valid = false;
            return;
        }
        this.fromTextConfig =
            fromProps.textConfig && fromProps.textConfig.length > 0
                ? RichText.TransformTextConfig2SingleCharacter(fromProps.textConfig)
                : [];
        this.toTextConfig = RichText.TransformTextConfig2SingleCharacter(this.originalTextConfig);
    }
    onEnd(cb) {
        super.onEnd(cb);
        if (!cb) {
            this.target.setAttribute('textConfig', this.originalTextConfig);
        }
    }
    onUpdate(end, ratio, out) {
        if (!this.valid) {
            return;
        }
        const totalItems = this.toTextConfig.length;
        const fromItems = this.fromTextConfig.length;
        const maxTextShowRatio = this.fadeInChars ? 1 - this.fadeInDuration : 1;
        let currentLength;
        if (fromItems > totalItems) {
            currentLength = Math.round(fromItems - (fromItems - totalItems) * ratio);
        }
        else {
            if (this.fadeInChars) {
                const adjustedRatio = Math.min(1, ratio / maxTextShowRatio);
                currentLength = Math.round(fromItems + (totalItems - fromItems) * adjustedRatio);
            }
            else {
                currentLength = Math.round(fromItems + (totalItems - fromItems) * ratio);
            }
        }
        let currentTextConfig;
        if (fromItems > totalItems) {
            currentTextConfig = this.fromTextConfig.slice(0, currentLength);
        }
        else {
            currentTextConfig = this.toTextConfig.slice(0, currentLength).map((item, index) => {
                if ('text' in item) {
                    const newItem = Object.assign({}, item);
                    if (this.strokeFirst) {
                        const appearTime = (index / totalItems) * maxTextShowRatio;
                        const itemLifetime = Math.max(0, ratio - appearTime);
                        const maxLifetime = 1 - appearTime;
                        const fillProgress = Math.min(1, itemLifetime / (this.strokeToFillRatio * maxLifetime));
                        if ('fill' in newItem && newItem.fill) {
                            newItem.stroke = newItem.fill;
                            if (fillProgress < 1) {
                                newItem.fillOpacity = fillProgress;
                            }
                        }
                        if (this.fadeInChars) {
                            const fadeProgress = Math.min(1, itemLifetime / (this.fadeInDuration * maxLifetime));
                            newItem.opacity = Math.max(0, Math.min(1, fadeProgress));
                        }
                    }
                    else if (this.fadeInChars) {
                        const appearTime = (index / totalItems) * maxTextShowRatio;
                        const fadeProgress = (ratio - appearTime) / this.fadeInDuration;
                        newItem.opacity = Math.max(0, Math.min(1, fadeProgress));
                    }
                    return newItem;
                }
                return item;
            });
        }
        if (this.showCursor && currentLength < totalItems) {
            let shouldShowCursor = true;
            if (this.blinkCursor) {
                const blinkRate = 0.1;
                shouldShowCursor = Math.floor(ratio / blinkRate) % 2 === 0;
            }
            if (shouldShowCursor && currentTextConfig.length > 0) {
                const lastIndex = currentTextConfig.length - 1;
                const lastItem = currentTextConfig[lastIndex];
                if ('text' in lastItem) {
                    currentTextConfig[lastIndex] = Object.assign(Object.assign({}, lastItem), { text: String(lastItem.text) + this.cursorChar });
                }
                else {
                    const cursorItem = {
                        text: this.cursorChar,
                        fontSize: 16
                    };
                    currentTextConfig.push(cursorItem);
                }
            }
        }
        this.target.setAttribute('textConfig', currentTextConfig);
    }
}

class OutputRichText extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.fromTextConfig = [];
        this.toTextConfig = [];
        this.originalTextConfig = [];
        this.showCursor = false;
        this.cursorChar = '|';
        this.blinkCursor = true;
        this.beforeText = '';
        this.afterText = '';
        this.fadeOutChars = false;
        this.fadeOutDuration = 0.3;
        this.direction = 'backward';
        if ((params === null || params === void 0 ? void 0 : params.showCursor) !== undefined) {
            this.showCursor = params.showCursor;
        }
        if ((params === null || params === void 0 ? void 0 : params.cursorChar) !== undefined) {
            this.cursorChar = params.cursorChar;
        }
        if ((params === null || params === void 0 ? void 0 : params.blinkCursor) !== undefined) {
            this.blinkCursor = params.blinkCursor;
        }
        if ((params === null || params === void 0 ? void 0 : params.beforeText) !== undefined) {
            this.beforeText = params.beforeText;
        }
        if ((params === null || params === void 0 ? void 0 : params.afterText) !== undefined) {
            this.afterText = params.afterText;
        }
        if ((params === null || params === void 0 ? void 0 : params.fadeOutChars) !== undefined) {
            this.fadeOutChars = params.fadeOutChars;
        }
        if ((params === null || params === void 0 ? void 0 : params.fadeOutDuration) !== undefined) {
            this.fadeOutDuration = params.fadeOutDuration;
        }
        if ((params === null || params === void 0 ? void 0 : params.direction) !== undefined) {
            this.direction = params.direction;
        }
        this.propKeys = ['textConfig'];
    }
    onFirstRun() {
        const fromProps = this.getLastProps();
        const toProps = this.getEndProps();
        this.originalTextConfig = fromProps.textConfig ? [...fromProps.textConfig] : [];
        this.valid = true;
        if (!this.originalTextConfig || this.originalTextConfig.length === 0) {
            this.valid = false;
            return;
        }
        this.fromTextConfig = RichText.TransformTextConfig2SingleCharacter(this.originalTextConfig);
        this.toTextConfig =
            toProps.textConfig && toProps.textConfig.length > 0
                ? RichText.TransformTextConfig2SingleCharacter(toProps.textConfig)
                : [];
    }
    onEnd(cb) {
        super.onEnd(cb);
        if (!cb) {
            if (this.toTextConfig.length > 0) {
                this.target.setAttribute('textConfig', this.toTextConfig);
            }
            else {
                this.target.setAttribute('textConfig', []);
            }
        }
    }
    onUpdate(end, ratio, out) {
        if (!this.valid) {
            return;
        }
        const fromItems = this.fromTextConfig.length;
        const maxTextHideRatio = this.fadeOutChars ? 1 - this.fadeOutDuration : 1;
        let displayedLength;
        if (this.direction === 'forward') {
            if (this.fadeOutChars) {
                const adjustedRatio = Math.min(1, ratio / maxTextHideRatio);
                displayedLength = Math.round(fromItems * (1 - adjustedRatio));
            }
            else {
                displayedLength = Math.round(fromItems * (1 - ratio));
            }
            let currentTextConfig = this.direction === 'forward'
                ? this.fromTextConfig.slice(fromItems - displayedLength)
                : this.fromTextConfig.slice(0, displayedLength);
            if (this.fadeOutChars) {
                currentTextConfig = this.applyFadeEffect(currentTextConfig, ratio, fromItems, displayedLength);
            }
            if (this.showCursor && displayedLength > 0) {
                currentTextConfig = this.addCursor(currentTextConfig, ratio);
            }
            this.target.setAttribute('textConfig', currentTextConfig);
        }
        else {
            if (this.fadeOutChars) {
                const adjustedRatio = Math.min(1, ratio / maxTextHideRatio);
                displayedLength = Math.round(fromItems * (1 - adjustedRatio));
            }
            else {
                displayedLength = Math.round(fromItems * (1 - ratio));
            }
            let currentTextConfig = this.fromTextConfig.slice(0, displayedLength);
            if (this.fadeOutChars) {
                currentTextConfig = this.applyFadeEffect(currentTextConfig, ratio, fromItems, displayedLength);
            }
            if (this.showCursor && displayedLength > 0) {
                currentTextConfig = this.addCursor(currentTextConfig, ratio);
            }
            this.target.setAttribute('textConfig', currentTextConfig);
        }
    }
    applyFadeEffect(textConfig, ratio, totalItems, displayedLength) {
        if (this.direction === 'forward') ;
        const fadeProgress = (ratio - (1 - this.fadeOutDuration)) / this.fadeOutDuration;
        const fadeOpacity = Math.max(0, 1 - Math.min(1, fadeProgress));
        return textConfig.map((item, index) => {
            if (this.direction === 'forward') {
                if (index === 0 && 'text' in item) {
                    return Object.assign(Object.assign({}, item), { opacity: fadeOpacity });
                }
            }
            else {
                if (index === textConfig.length - 1 && 'text' in item) {
                    return Object.assign(Object.assign({}, item), { opacity: fadeOpacity });
                }
            }
            return item;
        });
    }
    addCursor(textConfig, ratio) {
        let shouldShowCursor = true;
        if (this.blinkCursor) {
            const blinkRate = 0.1;
            shouldShowCursor = Math.floor(ratio / blinkRate) % 2 === 0;
        }
        if (shouldShowCursor && textConfig.length > 0) {
            const cursorIndex = this.direction === 'forward' ? 0 : textConfig.length - 1;
            const cursorItem = textConfig[cursorIndex];
            if ('text' in cursorItem) {
                const result = [...textConfig];
                if (this.direction === 'forward') {
                    result[cursorIndex] = Object.assign(Object.assign({}, cursorItem), { text: this.cursorChar + String(cursorItem.text) });
                }
                else {
                    result[cursorIndex] = Object.assign(Object.assign({}, cursorItem), { text: String(cursorItem.text) + this.cursorChar });
                }
                return result;
            }
        }
        return textConfig;
    }
}

class SlideRichText extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.fromTextConfig = [];
        this.toTextConfig = [];
        this.originalTextConfig = [];
        this.singleCharConfig = [];
        this.fadeInDuration = 0.3;
        this.slideDirection = 'right';
        this.slideDistance = 30;
        this.wordByWord = false;
        this.wordRegex = /[a-zA-Z]+(-[a-zA-Z]+)*|[\u4e00-\u9fa5]+|[0-9]+|[^\s\w\u4e00-\u9fa5]/g;
        this.wordGroups = [];
        if ((params === null || params === void 0 ? void 0 : params.fadeInDuration) !== undefined) {
            this.fadeInDuration = params.fadeInDuration;
        }
        if ((params === null || params === void 0 ? void 0 : params.slideDirection) !== undefined) {
            this.slideDirection = params.slideDirection;
        }
        if ((params === null || params === void 0 ? void 0 : params.slideDistance) !== undefined) {
            this.slideDistance = params.slideDistance;
        }
        if ((params === null || params === void 0 ? void 0 : params.wordByWord) !== undefined) {
            this.wordByWord = params.wordByWord;
        }
        if ((params === null || params === void 0 ? void 0 : params.wordRegex) !== undefined) {
            this.wordRegex = params.wordRegex;
        }
    }
    onFirstRun() {
        const fromProps = this.getLastProps();
        const toProps = this.getEndProps();
        this.originalTextConfig = toProps.textConfig ? [...toProps.textConfig] : [];
        this.valid = true;
        if (!this.originalTextConfig || this.originalTextConfig.length === 0) {
            this.valid = false;
            return;
        }
        this.fromTextConfig =
            fromProps.textConfig && fromProps.textConfig.length > 0
                ? RichText.TransformTextConfig2SingleCharacter(fromProps.textConfig)
                : [];
        this.toTextConfig = RichText.TransformTextConfig2SingleCharacter(this.originalTextConfig);
        this.singleCharConfig = this.toTextConfig.map(item => {
            if ('text' in item) {
                return Object.assign(Object.assign({}, item), { opacity: 0, dx: this.getInitialDx(), dy: this.getInitialDy() });
            }
            return Object.assign(Object.assign({}, item), { opacity: 0 });
        });
        if (this.wordByWord) {
            this.calculateWordGroups();
        }
    }
    calculateWordGroups() {
        this.wordGroups = [];
        let fullText = '';
        const charMap = {};
        let fullTextIndex = 0;
        this.toTextConfig.forEach((item, configIndex) => {
            if ('text' in item) {
                const text = String(item.text);
                fullText += text;
                charMap[fullTextIndex] = configIndex;
                fullTextIndex++;
            }
        });
        let match;
        this.wordRegex.lastIndex = 0;
        while ((match = this.wordRegex.exec(fullText)) !== null) {
            const wordStart = match.index;
            const wordEnd = match.index + match[0].length;
            const wordIndices = [];
            for (let i = wordStart; i < wordEnd; i++) {
                if (charMap[i] !== undefined) {
                    wordIndices.push(charMap[i]);
                }
            }
            if (wordIndices.length > 0) {
                this.wordGroups.push(wordIndices);
            }
        }
        const allocatedIndices = new Set();
        this.wordGroups.forEach(group => {
            group.forEach(index => allocatedIndices.add(index));
        });
        for (let i = 0; i < this.toTextConfig.length; i++) {
            if ('text' in this.toTextConfig[i] && !allocatedIndices.has(i)) {
                this.wordGroups.push([i]);
            }
        }
    }
    getInitialDx() {
        switch (this.slideDirection) {
            case 'left':
                return -this.slideDistance;
            case 'right':
                return this.slideDistance;
            default:
                return 0;
        }
    }
    getInitialDy() {
        switch (this.slideDirection) {
            case 'up':
                return -this.slideDistance;
            case 'down':
                return this.slideDistance;
            default:
                return 0;
        }
    }
    onEnd(cb) {
        super.onEnd(cb);
        if (!cb) {
            this.target.setAttribute('textConfig', this.originalTextConfig);
        }
    }
    onUpdate(end, ratio, out) {
        if (!this.valid) {
            return;
        }
        const maxTextShowRatio = 1 - this.fadeInDuration;
        let updatedTextConfig;
        if (this.wordByWord && this.wordGroups.length > 0) {
            updatedTextConfig = this.updateByWord(ratio, maxTextShowRatio);
        }
        else {
            updatedTextConfig = this.updateByCharacter(ratio, maxTextShowRatio);
        }
        this.target.setAttribute('textConfig', updatedTextConfig);
    }
    updateByWord(ratio, maxTextShowRatio) {
        const totalGroups = this.wordGroups.length;
        const updatedTextConfig = [...this.singleCharConfig];
        for (let groupIndex = 0; groupIndex < this.wordGroups.length; groupIndex++) {
            let appearTime;
            if (this.slideDirection === 'left') {
                appearTime = ((totalGroups - 1 - groupIndex) / totalGroups) * maxTextShowRatio;
            }
            else {
                appearTime = (groupIndex / totalGroups) * maxTextShowRatio;
            }
            if (ratio < appearTime) {
                for (const charIndex of this.wordGroups[groupIndex]) {
                    const item = updatedTextConfig[charIndex];
                    if ('text' in item) {
                        updatedTextConfig[charIndex] = Object.assign(Object.assign({}, item), { opacity: 0, dx: this.getInitialDx(), dy: this.getInitialDy() });
                    }
                }
                continue;
            }
            const animProgress = (ratio - appearTime) / this.fadeInDuration;
            const progress = Math.max(0, Math.min(1, animProgress));
            const dx = this.getInitialDx() * (1 - progress);
            const dy = this.getInitialDy() * (1 - progress);
            for (const charIndex of this.wordGroups[groupIndex]) {
                const item = updatedTextConfig[charIndex];
                if ('text' in item) {
                    updatedTextConfig[charIndex] = Object.assign(Object.assign({}, item), { opacity: progress, dx,
                        dy });
                }
            }
        }
        return updatedTextConfig;
    }
    updateByCharacter(ratio, maxTextShowRatio) {
        const totalItems = this.toTextConfig.length;
        const updatedTextConfig = [...this.singleCharConfig];
        for (let index = 0; index < updatedTextConfig.length; index++) {
            const item = updatedTextConfig[index];
            if ('text' in item) {
                let appearTime;
                if (this.slideDirection === 'left') {
                    appearTime = ((totalItems - 1 - index) / totalItems) * maxTextShowRatio;
                }
                else {
                    appearTime = (index / totalItems) * maxTextShowRatio;
                }
                if (ratio < appearTime) {
                    updatedTextConfig[index] = Object.assign(Object.assign({}, item), { opacity: 0, dx: this.getInitialDx(), dy: this.getInitialDy() });
                    continue;
                }
                const animProgress = (ratio - appearTime) / this.fadeInDuration;
                const progress = Math.max(0, Math.min(1, animProgress));
                const dx = this.getInitialDx() * (1 - progress);
                const dy = this.getInitialDy() * (1 - progress);
                updatedTextConfig[index] = Object.assign(Object.assign({}, item), { opacity: progress, dx,
                    dy });
            }
        }
        return updatedTextConfig;
    }
}

class SlideOutRichText extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.fromTextConfig = [];
        this.toTextConfig = [];
        this.originalTextConfig = [];
        this.singleCharConfig = [];
        this.fadeOutDuration = 0.3;
        this.slideDirection = 'right';
        this.slideDistance = 30;
        this.wordByWord = false;
        this.wordRegex = /[a-zA-Z]+(-[a-zA-Z]+)*|[\u4e00-\u9fa5]+|[0-9]+|[^\s\w\u4e00-\u9fa5]/g;
        this.wordGroups = [];
        this.reverseOrder = false;
        if ((params === null || params === void 0 ? void 0 : params.fadeOutDuration) !== undefined) {
            this.fadeOutDuration = params.fadeOutDuration;
        }
        if ((params === null || params === void 0 ? void 0 : params.slideDirection) !== undefined) {
            this.slideDirection = params.slideDirection;
        }
        if ((params === null || params === void 0 ? void 0 : params.slideDistance) !== undefined) {
            this.slideDistance = params.slideDistance;
        }
        if ((params === null || params === void 0 ? void 0 : params.wordByWord) !== undefined) {
            this.wordByWord = params.wordByWord;
        }
        if ((params === null || params === void 0 ? void 0 : params.wordRegex) !== undefined) {
            this.wordRegex = params.wordRegex;
        }
        if ((params === null || params === void 0 ? void 0 : params.reverseOrder) !== undefined) {
            this.reverseOrder = params.reverseOrder;
        }
        this.propKeys = ['textConfig'];
    }
    onFirstRun() {
        const fromProps = this.getLastProps();
        const toProps = this.getEndProps();
        this.originalTextConfig = fromProps.textConfig ? [...fromProps.textConfig] : [];
        this.valid = true;
        if (!this.originalTextConfig || this.originalTextConfig.length === 0) {
            this.valid = false;
            return;
        }
        this.fromTextConfig = RichText.TransformTextConfig2SingleCharacter(this.originalTextConfig);
        this.toTextConfig =
            toProps.textConfig && toProps.textConfig.length > 0
                ? RichText.TransformTextConfig2SingleCharacter(toProps.textConfig)
                : [];
        this.singleCharConfig = this.fromTextConfig.map(item => {
            if ('text' in item) {
                return Object.assign(Object.assign({}, item), { opacity: 1, dx: 0, dy: 0 });
            }
            return Object.assign(Object.assign({}, item), { opacity: 1 });
        });
        if (this.wordByWord) {
            this.calculateWordGroups();
        }
    }
    calculateWordGroups() {
        this.wordGroups = [];
        let fullText = '';
        const charMap = {};
        let fullTextIndex = 0;
        this.fromTextConfig.forEach((item, configIndex) => {
            if ('text' in item) {
                const text = String(item.text);
                fullText += text;
                charMap[fullTextIndex] = configIndex;
                fullTextIndex++;
            }
        });
        let match;
        this.wordRegex.lastIndex = 0;
        while ((match = this.wordRegex.exec(fullText)) !== null) {
            const wordStart = match.index;
            const wordEnd = match.index + match[0].length;
            const wordIndices = [];
            for (let i = wordStart; i < wordEnd; i++) {
                if (charMap[i] !== undefined) {
                    wordIndices.push(charMap[i]);
                }
            }
            if (wordIndices.length > 0) {
                this.wordGroups.push(wordIndices);
            }
        }
        const allocatedIndices = new Set();
        this.wordGroups.forEach(group => {
            group.forEach(index => allocatedIndices.add(index));
        });
        for (let i = 0; i < this.fromTextConfig.length; i++) {
            if ('text' in this.fromTextConfig[i] && !allocatedIndices.has(i)) {
                this.wordGroups.push([i]);
            }
        }
    }
    getTargetDx() {
        switch (this.slideDirection) {
            case 'left':
                return -this.slideDistance;
            case 'right':
                return this.slideDistance;
            default:
                return 0;
        }
    }
    getTargetDy() {
        switch (this.slideDirection) {
            case 'up':
                return -this.slideDistance;
            case 'down':
                return this.slideDistance;
            default:
                return 0;
        }
    }
    onEnd(cb) {
        super.onEnd(cb);
        if (!cb) {
            if (this.toTextConfig.length > 0) {
                this.target.setAttribute('textConfig', this.toTextConfig);
            }
            else {
                this.target.setAttribute('textConfig', []);
            }
        }
    }
    onUpdate(end, ratio, out) {
        if (!this.valid) {
            return;
        }
        const maxTextShowRatio = 1 - this.fadeOutDuration;
        let updatedTextConfig;
        if (this.wordByWord && this.wordGroups.length > 0) {
            updatedTextConfig = this.updateByWord(ratio, maxTextShowRatio);
        }
        else {
            updatedTextConfig = this.updateByCharacter(ratio, maxTextShowRatio);
        }
        this.target.setAttribute('textConfig', updatedTextConfig);
    }
    updateByWord(ratio, maxTextShowRatio) {
        const totalGroups = this.wordGroups.length;
        const updatedTextConfig = [...this.singleCharConfig];
        for (let groupIndex = 0; groupIndex < this.wordGroups.length; groupIndex++) {
            let disappearTime;
            if (this.reverseOrder) {
                if (this.slideDirection === 'left') {
                    disappearTime = (groupIndex / totalGroups) * maxTextShowRatio;
                }
                else {
                    disappearTime = ((totalGroups - 1 - groupIndex) / totalGroups) * maxTextShowRatio;
                }
            }
            else {
                if (this.slideDirection === 'left') {
                    disappearTime = ((totalGroups - 1 - groupIndex) / totalGroups) * maxTextShowRatio;
                }
                else {
                    disappearTime = (groupIndex / totalGroups) * maxTextShowRatio;
                }
            }
            if (ratio < disappearTime) {
                for (const charIndex of this.wordGroups[groupIndex]) {
                    const item = updatedTextConfig[charIndex];
                    if ('text' in item) {
                        updatedTextConfig[charIndex] = Object.assign(Object.assign({}, item), { opacity: 1, dx: 0, dy: 0 });
                    }
                }
                continue;
            }
            const animProgress = (ratio - disappearTime) / this.fadeOutDuration;
            const progress = Math.max(0, Math.min(1, animProgress));
            const dx = this.getTargetDx() * progress;
            const dy = this.getTargetDy() * progress;
            const opacity = 1 - progress;
            for (const charIndex of this.wordGroups[groupIndex]) {
                const item = updatedTextConfig[charIndex];
                if ('text' in item) {
                    updatedTextConfig[charIndex] = Object.assign(Object.assign({}, item), { opacity,
                        dx,
                        dy });
                }
            }
        }
        return updatedTextConfig;
    }
    updateByCharacter(ratio, maxTextShowRatio) {
        const totalItems = this.fromTextConfig.length;
        const updatedTextConfig = [...this.singleCharConfig];
        for (let index = 0; index < updatedTextConfig.length; index++) {
            const item = updatedTextConfig[index];
            if ('text' in item) {
                let disappearTime;
                if (this.reverseOrder) {
                    if (this.slideDirection === 'left') {
                        disappearTime = (index / totalItems) * maxTextShowRatio;
                    }
                    else {
                        disappearTime = ((totalItems - 1 - index) / totalItems) * maxTextShowRatio;
                    }
                }
                else {
                    if (this.slideDirection === 'left') {
                        disappearTime = ((totalItems - 1 - index) / totalItems) * maxTextShowRatio;
                    }
                    else {
                        disappearTime = (index / totalItems) * maxTextShowRatio;
                    }
                }
                if (ratio < disappearTime) {
                    updatedTextConfig[index] = Object.assign(Object.assign({}, item), { opacity: 1, dx: 0, dy: 0 });
                    continue;
                }
                const animProgress = (ratio - disappearTime) / this.fadeOutDuration;
                const progress = Math.max(0, Math.min(1, animProgress));
                const dx = this.getTargetDx() * progress;
                const dy = this.getTargetDy() * progress;
                const opacity = 1 - progress;
                updatedTextConfig[index] = Object.assign(Object.assign({}, item), { opacity,
                    dx,
                    dy });
            }
        }
        return updatedTextConfig;
    }
}

class ScaleIn extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        super.onBind();
        let from;
        let to;
        const attrs = this.target.getFinalAttribute();
        const fromAttrs = (_a = this.target.attribute) !== null && _a !== void 0 ? _a : {};
        switch ((_b = this.params) === null || _b === void 0 ? void 0 : _b.direction) {
            case 'x':
                from = { scaleX: (_c = fromAttrs.scaleX) !== null && _c !== void 0 ? _c : 0 };
                to = { scaleX: (_d = attrs === null || attrs === void 0 ? void 0 : attrs.scaleX) !== null && _d !== void 0 ? _d : 1 };
                this._updateFunction = this.updateX;
                break;
            case 'y':
                from = { scaleY: (_e = fromAttrs.scaleY) !== null && _e !== void 0 ? _e : 0 };
                to = { scaleY: (_f = attrs === null || attrs === void 0 ? void 0 : attrs.scaleY) !== null && _f !== void 0 ? _f : 1 };
                this._updateFunction = this.updateY;
                break;
            case 'xy':
            default:
                from = { scaleX: (_g = fromAttrs.scaleX) !== null && _g !== void 0 ? _g : 0, scaleY: (_h = fromAttrs.scaleY) !== null && _h !== void 0 ? _h : 0 };
                to = {
                    scaleX: (_j = attrs === null || attrs === void 0 ? void 0 : attrs.scaleX) !== null && _j !== void 0 ? _j : 1,
                    scaleY: (_k = attrs === null || attrs === void 0 ? void 0 : attrs.scaleY) !== null && _k !== void 0 ? _k : 1
                };
                this._updateFunction = this.updateXY;
        }
        const finalAttribute = this.target.getFinalAttribute();
        if (finalAttribute) {
            this.target.setAttributes(finalAttribute);
        }
        this.props = to;
        this.from = from;
        this.to = to;
        if (((_l = this.params.controlOptions) === null || _l === void 0 ? void 0 : _l.immediatelyApply) !== false) {
            this.target.setAttributes(from);
        }
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    updateX(ratio) {
        this.target.attribute.scaleX = this.from.scaleX + (this.to.scaleX - this.from.scaleX) * ratio;
    }
    updateY(ratio) {
        this.target.attribute.scaleY = this.from.scaleY + (this.to.scaleY - this.from.scaleY) * ratio;
    }
    updateXY(ratio) {
        this.updateX(ratio);
        this.updateY(ratio);
    }
    deleteSelfAttr(key) {
        delete this.props[key];
        this.fromProps && delete this.fromProps[key];
        const index = this.propKeys.indexOf(key);
        if (index !== -1) {
            this.propKeys.splice(index, 1);
        }
        if (this.propKeys && this.propKeys.length > 1) {
            this._updateFunction = this.updateXY;
        }
        else if (this.propKeys[0] === 'scaleX') {
            this._updateFunction = this.updateX;
        }
        else if (this.propKeys[0] === 'scaleY') {
            this._updateFunction = this.updateY;
        }
        else {
            this._updateFunction = null;
        }
    }
    onUpdate(end, ratio, out) {
        if (this._updateFunction) {
            this._updateFunction(ratio);
            this.target.addUpdatePositionTag();
            this.target.addUpdateBoundTag();
        }
    }
}
class ScaleOut extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c, _d, _e;
        super.onBind();
        let from;
        let to;
        const attrs = this.target.attribute;
        switch ((_a = this.params) === null || _a === void 0 ? void 0 : _a.direction) {
            case 'x':
                from = { scaleX: (_b = attrs === null || attrs === void 0 ? void 0 : attrs.scaleX) !== null && _b !== void 0 ? _b : 1 };
                to = { scaleX: 0 };
                break;
            case 'y':
                from = { scaleY: (_c = attrs === null || attrs === void 0 ? void 0 : attrs.scaleY) !== null && _c !== void 0 ? _c : 1 };
                to = { scaleY: 0 };
                break;
            case 'xy':
            default:
                from = { scaleX: (_d = attrs === null || attrs === void 0 ? void 0 : attrs.scaleX) !== null && _d !== void 0 ? _d : 1, scaleY: (_e = attrs === null || attrs === void 0 ? void 0 : attrs.scaleY) !== null && _e !== void 0 ? _e : 1 };
                to = {
                    scaleX: 0,
                    scaleY: 0
                };
        }
        this.props = to;
        this.from = from;
        this.to = to;
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateBoundTag();
    }
}

class State extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    update(end, ratio, out) {
        this.onStart();
        if (!this.props || !this.propKeys) {
            return;
        }
        const easedRatio = this.easing(ratio);
        this.animate.interpolateUpdateFunction
            ? this.animate.interpolateUpdateFunction(this.fromProps, this.props, easedRatio, this, this.target)
            : this.interpolateUpdateFunctions.forEach((func, index) => {
                if (!this.animate.validAttr(this.propKeys[index])) {
                    return;
                }
                const key = this.propKeys[index];
                const fromValue = this.fromProps[key];
                const toValue = this.props[key];
                func(key, fromValue, toValue, easedRatio, this, this.target);
            });
        this.onUpdate(end, easedRatio, out);
        this.syncAttributeUpdate();
    }
}

class SlideIn extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        super.onBind();
        const attrs = this.target.getFinalAttribute();
        const direction = ((_a = this.params) === null || _a === void 0 ? void 0 : _a.direction) || 'right';
        const distance = ((_b = this.params) === null || _b === void 0 ? void 0 : _b.distance) || 50;
        const fromOpacity = (_d = (_c = this.params) === null || _c === void 0 ? void 0 : _c.fromOpacity) !== null && _d !== void 0 ? _d : 0;
        const from = { opacity: fromOpacity, baseOpacity: fromOpacity };
        const to = { opacity: 1, baseOpacity: 1 };
        if (direction === 'top') {
            from.y = ((_e = attrs.y) !== null && _e !== void 0 ? _e : 0) - distance;
            to.y = (_f = attrs.y) !== null && _f !== void 0 ? _f : 0;
            this.propKeys = ['opacity', 'baseOpacity', 'y'];
        }
        else if (direction === 'bottom') {
            from.y = ((_g = attrs.y) !== null && _g !== void 0 ? _g : 0) + distance;
            to.y = (_h = attrs.y) !== null && _h !== void 0 ? _h : 0;
            this.propKeys = ['opacity', 'baseOpacity', 'y'];
        }
        else if (direction === 'left') {
            from.x = ((_j = attrs.x) !== null && _j !== void 0 ? _j : 0) - distance;
            to.x = (_k = attrs.x) !== null && _k !== void 0 ? _k : 0;
            this.propKeys = ['opacity', 'baseOpacity', 'x'];
        }
        else {
            from.x = ((_l = attrs.x) !== null && _l !== void 0 ? _l : 0) + distance;
            to.x = (_m = attrs.x) !== null && _m !== void 0 ? _m : 0;
            this.propKeys = ['opacity', 'baseOpacity', 'x'];
        }
        this.from = from;
        this.to = to;
        this.props = to;
        this.target.setAttributes(from);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class GrowIn extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c, _d, _e, _f, _g;
        super.onBind();
        const attrs = this.target.getFinalAttribute();
        const fromScale = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.fromScale) !== null && _b !== void 0 ? _b : 0;
        const direction = ((_c = this.params) === null || _c === void 0 ? void 0 : _c.direction) || 'xy';
        const fromOpacity = (_e = (_d = this.params) === null || _d === void 0 ? void 0 : _d.fromOpacity) !== null && _e !== void 0 ? _e : 0;
        const from = { opacity: fromOpacity, baseOpacity: fromOpacity };
        const to = { opacity: 1, baseOpacity: 1 };
        this.propKeys = ['opacity', 'baseOpacity'];
        if (direction === 'x' || direction === 'xy') {
            from.scaleX = fromScale;
            to.scaleX = (_f = attrs.scaleX) !== null && _f !== void 0 ? _f : 1;
            this.propKeys.push('scaleX');
        }
        if (direction === 'y' || direction === 'xy') {
            from.scaleY = fromScale;
            to.scaleY = (_g = attrs.scaleY) !== null && _g !== void 0 ? _g : 1;
            this.propKeys.push('scaleY');
        }
        this.from = from;
        this.to = to;
        this.props = to;
        this.target.setAttributes(from);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class SpinIn extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        super.onBind();
        const attrs = this.target.getFinalAttribute();
        const fromAngle = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.fromAngle) !== null && _b !== void 0 ? _b : Math.PI * 2;
        const fromScale = (_d = (_c = this.params) === null || _c === void 0 ? void 0 : _c.fromScale) !== null && _d !== void 0 ? _d : 0;
        const fromOpacity = (_f = (_e = this.params) === null || _e === void 0 ? void 0 : _e.fromOpacity) !== null && _f !== void 0 ? _f : 0;
        const from = {
            opacity: fromOpacity,
            baseOpacity: fromOpacity,
            angle: fromAngle,
            scaleX: fromScale,
            scaleY: fromScale
        };
        const to = {
            opacity: 1,
            baseOpacity: 1,
            angle: (_g = attrs.angle) !== null && _g !== void 0 ? _g : 0,
            scaleX: (_h = attrs.scaleX) !== null && _h !== void 0 ? _h : 1,
            scaleY: (_j = attrs.scaleY) !== null && _j !== void 0 ? _j : 1
        };
        this.propKeys = ['opacity', 'baseOpacity', 'angle', 'scaleX', 'scaleY'];
        this.from = from;
        this.to = to;
        this.props = to;
        this.target.setAttributes(from);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class StrokeIn extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.perimeter = 0;
        this.originalAttributes = {};
    }
    onBind() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
        super.onBind();
        this.originalAttributes = Object.assign({}, this.target.getAttributes());
        if (this.target.type === 'rect') {
            const attr = this.target.attribute;
            const width = (_a = attr.width) !== null && _a !== void 0 ? _a : 100;
            const height = (_b = attr.height) !== null && _b !== void 0 ? _b : 100;
            this.perimeter = 2 * (width + height);
        }
        else if (this.target.type === 'circle') {
            const attr = this.target.attribute;
            const radius = (_c = attr.radius) !== null && _c !== void 0 ? _c : 50;
            this.perimeter = 2 * Math.PI * radius;
        }
        else if (this.target.type === 'ellipse') {
            const attr = this.target.attribute;
            const radiusX = (_d = attr.radiusX) !== null && _d !== void 0 ? _d : 50;
            const radiusY = (_e = attr.radiusY) !== null && _e !== void 0 ? _e : 50;
            this.perimeter = 2 * Math.PI * Math.sqrt((radiusX * radiusX + radiusY * radiusY) / 2);
        }
        else {
            this.perimeter = 1000;
        }
        const lineWidth = (_g = (_f = this.params) === null || _f === void 0 ? void 0 : _f.lineWidth) !== null && _g !== void 0 ? _g : 2;
        const strokeColor = (_j = (_h = this.params) === null || _h === void 0 ? void 0 : _h.strokeColor) !== null && _j !== void 0 ? _j : 'black';
        const fromOpacity = (_l = (_k = this.params) === null || _k === void 0 ? void 0 : _k.fromOpacity) !== null && _l !== void 0 ? _l : 1;
        const dashLength = (_o = (_m = this.params) === null || _m === void 0 ? void 0 : _m.dashLength) !== null && _o !== void 0 ? _o : this.perimeter;
        const showFill = (_q = (_p = this.params) === null || _p === void 0 ? void 0 : _p.showFill) !== null && _q !== void 0 ? _q : false;
        const fillOpacity = (_s = (_r = this.params) === null || _r === void 0 ? void 0 : _r.fillOpacity) !== null && _s !== void 0 ? _s : 0;
        this.from = {
            lineDash: [dashLength, dashLength],
            lineDashOffset: dashLength,
            lineWidth,
            stroke: strokeColor,
            strokeOpacity: fromOpacity
        };
        this.to = {
            lineDash: [dashLength, dashLength],
            lineDashOffset: 0,
            lineWidth,
            stroke: strokeColor,
            strokeOpacity: fromOpacity
        };
        if (showFill) {
            this.from.fillOpacity = fillOpacity;
            this.to.fillOpacity = (_t = this.originalAttributes.fillOpacity) !== null && _t !== void 0 ? _t : 1;
        }
        else {
            this.from.fillOpacity = 0;
            this.to.fillOpacity = 0;
        }
        this.propKeys = ['lineDash', 'lineDashOffset', 'lineWidth', 'stroke', 'strokeOpacity', 'fillOpacity'];
        this.props = this.to;
        this.target.setAttributes(this.from);
    }
    onUpdate(end, ratio, out) {
        var _a;
        const attribute = this.target.attribute;
        attribute.lineDashOffset = this.from.lineDashOffset + (this.to.lineDashOffset - this.from.lineDashOffset) * ratio;
        if ((_a = this.params) === null || _a === void 0 ? void 0 : _a.showFill) {
            attribute.fillOpacity = this.from.fillOpacity + (this.to.fillOpacity - this.from.fillOpacity) * ratio;
        }
    }
    onEnd() {
        var _a;
        super.onEnd();
        if (!((_a = this.params) === null || _a === void 0 ? void 0 : _a.showFill)) {
            const originalAttrs = Object.assign({}, this.originalAttributes);
            originalAttrs.fillOpacity = 0;
            this.target.setAttributes(originalAttrs);
        }
    }
}
class StrokeOut extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.perimeter = 0;
        this.originalAttributes = {};
    }
    onFirstRun() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        this.originalAttributes = Object.assign({}, this.target.getAttributes());
        if (this.target.type === 'rect') {
            const attr = this.target.attribute;
            const width = (_a = attr.width) !== null && _a !== void 0 ? _a : 100;
            const height = (_b = attr.height) !== null && _b !== void 0 ? _b : 100;
            this.perimeter = 2 * (width + height);
        }
        else if (this.target.type === 'circle') {
            const attr = this.target.attribute;
            const radius = (_c = attr.radius) !== null && _c !== void 0 ? _c : 50;
            this.perimeter = 2 * Math.PI * radius;
        }
        else if (this.target.type === 'ellipse') {
            const attr = this.target.attribute;
            const radiusX = (_d = attr.radiusX) !== null && _d !== void 0 ? _d : 50;
            const radiusY = (_e = attr.radiusY) !== null && _e !== void 0 ? _e : 50;
            this.perimeter = 2 * Math.PI * Math.sqrt((radiusX * radiusX + radiusY * radiusY) / 2);
        }
        else {
            this.perimeter = 1000;
        }
        const lineWidth = (_g = (_f = this.params) === null || _f === void 0 ? void 0 : _f.lineWidth) !== null && _g !== void 0 ? _g : 2;
        const strokeColor = (_j = (_h = this.params) === null || _h === void 0 ? void 0 : _h.strokeColor) !== null && _j !== void 0 ? _j : 'black';
        const fromOpacity = (_l = (_k = this.params) === null || _k === void 0 ? void 0 : _k.fromOpacity) !== null && _l !== void 0 ? _l : 1;
        const dashLength = (_o = (_m = this.params) === null || _m === void 0 ? void 0 : _m.dashLength) !== null && _o !== void 0 ? _o : this.perimeter;
        const showFill = (_q = (_p = this.params) === null || _p === void 0 ? void 0 : _p.showFill) !== null && _q !== void 0 ? _q : false;
        this.from = {
            lineDash: [dashLength, dashLength],
            lineDashOffset: 0,
            lineWidth,
            stroke: strokeColor,
            strokeOpacity: fromOpacity
        };
        this.to = {
            lineDash: [dashLength, dashLength],
            lineDashOffset: -dashLength,
            lineWidth,
            stroke: strokeColor,
            strokeOpacity: fromOpacity
        };
        if (showFill) {
            this.from.fillOpacity = (_r = this.originalAttributes.fillOpacity) !== null && _r !== void 0 ? _r : 1;
            this.to.fillOpacity = 0;
        }
        else {
            this.from.fillOpacity = 0;
            this.to.fillOpacity = 0;
        }
        this.propKeys = ['lineDash', 'lineDashOffset', 'lineWidth', 'stroke', 'strokeOpacity', 'fillOpacity'];
        this.props = this.to;
        this.target.setAttributes(this.from);
    }
    onUpdate(end, ratio, out) {
        var _a;
        const attribute = this.target.attribute;
        attribute.lineDashOffset = this.from.lineDashOffset + (this.to.lineDashOffset - this.from.lineDashOffset) * ratio;
        if ((_a = this.params) === null || _a === void 0 ? void 0 : _a.showFill) {
            attribute.fillOpacity = this.from.fillOpacity + (this.to.fillOpacity - this.from.fillOpacity) * ratio;
        }
    }
}
class MoveScaleIn extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        var _a;
        super(from, to, duration, easing, params);
        const slideRatio = (_a = params === null || params === void 0 ? void 0 : params.slideRatio) !== null && _a !== void 0 ? _a : 0.5;
        this.slideInDuration = duration * slideRatio;
        this.growInDuration = duration * (1 - slideRatio);
    }
    onBind() {
        var _a, _b, _c, _d, _e, _f;
        super.onBind();
        const executor = new AnimateExecutor(this.target);
        executor.execute({
            type: 'custom',
            custom: SlideIn,
            customParameters: {
                direction: ((_a = this.params) === null || _a === void 0 ? void 0 : _a.slideDirection) || 'right',
                distance: ((_b = this.params) === null || _b === void 0 ? void 0 : _b.slideDistance) || 50,
                fromOpacity: (_d = (_c = this.params) === null || _c === void 0 ? void 0 : _c.fromOpacity) !== null && _d !== void 0 ? _d : 0
            },
            duration: this.slideInDuration,
            easing: this.easing
        });
        executor.execute({
            type: 'custom',
            custom: GrowIn,
            customParameters: {
                fromScale: ((_e = this.params) === null || _e === void 0 ? void 0 : _e.fromScale) || 0.5,
                direction: ((_f = this.params) === null || _f === void 0 ? void 0 : _f.scaleDirection) || 'xy',
                fromOpacity: 1
            },
            duration: this.growInDuration,
            easing: this.easing,
            delay: this.slideInDuration
        });
    }
    onUpdate(end, ratio, out) {
    }
}
class MoveRotateIn extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        var _a;
        super(from, to, duration, easing, params);
        const slideRatio = (_a = params === null || params === void 0 ? void 0 : params.slideRatio) !== null && _a !== void 0 ? _a : 0.5;
        this.slideInDuration = duration * slideRatio;
        this.spinInDuration = duration * (1 - slideRatio);
    }
    onBind() {
        var _a, _b, _c, _d, _e, _f;
        super.onBind();
        const executor = new AnimateExecutor(this.target);
        executor.execute({
            type: 'custom',
            custom: SlideIn,
            customParameters: {
                direction: ((_a = this.params) === null || _a === void 0 ? void 0 : _a.slideDirection) || 'right',
                distance: ((_b = this.params) === null || _b === void 0 ? void 0 : _b.slideDistance) || 50,
                fromOpacity: (_d = (_c = this.params) === null || _c === void 0 ? void 0 : _c.fromOpacity) !== null && _d !== void 0 ? _d : 0
            },
            duration: this.slideInDuration,
            easing: this.easing
        });
        executor.execute({
            type: 'custom',
            custom: SpinIn,
            customParameters: {
                fromAngle: ((_e = this.params) === null || _e === void 0 ? void 0 : _e.fromAngle) || Math.PI,
                fromScale: ((_f = this.params) === null || _f === void 0 ? void 0 : _f.fromScale) || 0.5,
                fromOpacity: 1
            },
            duration: this.spinInDuration,
            easing: this.easing,
            delay: this.slideInDuration
        });
    }
    onUpdate(end, ratio, out) {
    }
}
class SlideOut extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onFirstRun() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        const attrs = this.target.getAttributes();
        const direction = ((_a = this.params) === null || _a === void 0 ? void 0 : _a.direction) || 'right';
        const distance = ((_b = this.params) === null || _b === void 0 ? void 0 : _b.distance) || 50;
        const fromOpacity = (_d = (_c = this.params) === null || _c === void 0 ? void 0 : _c.fromOpacity) !== null && _d !== void 0 ? _d : 1;
        const toOpacity = (_f = (_e = this.params) === null || _e === void 0 ? void 0 : _e.toOpacity) !== null && _f !== void 0 ? _f : 0;
        const from = { opacity: fromOpacity, baseOpacity: fromOpacity };
        const to = { opacity: toOpacity, baseOpacity: toOpacity };
        if (direction === 'top') {
            from.y = (_g = attrs.y) !== null && _g !== void 0 ? _g : 0;
            to.y = ((_h = attrs.y) !== null && _h !== void 0 ? _h : 0) - distance;
            this.propKeys = ['opacity', 'baseOpacity', 'y'];
        }
        else if (direction === 'bottom') {
            from.y = (_j = attrs.y) !== null && _j !== void 0 ? _j : 0;
            to.y = ((_k = attrs.y) !== null && _k !== void 0 ? _k : 0) + distance;
            this.propKeys = ['opacity', 'baseOpacity', 'y'];
        }
        else if (direction === 'left') {
            from.x = (_l = attrs.x) !== null && _l !== void 0 ? _l : 0;
            to.x = ((_m = attrs.x) !== null && _m !== void 0 ? _m : 0) - distance;
            this.propKeys = ['opacity', 'baseOpacity', 'x'];
        }
        else {
            from.x = (_o = attrs.x) !== null && _o !== void 0 ? _o : 0;
            to.x = ((_p = attrs.x) !== null && _p !== void 0 ? _p : 0) + distance;
            this.propKeys = ['opacity', 'baseOpacity', 'x'];
        }
        this.from = from;
        this.to = to;
        this.props = to;
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class GrowOut extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onFirstRun() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const attrs = this.target.getAttributes();
        const toScale = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.fromScale) !== null && _b !== void 0 ? _b : 0;
        const direction = ((_c = this.params) === null || _c === void 0 ? void 0 : _c.direction) || 'xy';
        const fromOpacity = (_e = (_d = this.params) === null || _d === void 0 ? void 0 : _d.fromOpacity) !== null && _e !== void 0 ? _e : 1;
        const toOpacity = (_g = (_f = this.params) === null || _f === void 0 ? void 0 : _f.toOpacity) !== null && _g !== void 0 ? _g : 0;
        const from = { opacity: fromOpacity, baseOpacity: fromOpacity };
        const to = { opacity: toOpacity, baseOpacity: toOpacity };
        this.propKeys = ['opacity', 'baseOpacity'];
        if (direction === 'x' || direction === 'xy') {
            from.scaleX = (_h = attrs.scaleX) !== null && _h !== void 0 ? _h : 1;
            to.scaleX = toScale;
            this.propKeys.push('scaleX');
        }
        if (direction === 'y' || direction === 'xy') {
            from.scaleY = (_j = attrs.scaleY) !== null && _j !== void 0 ? _j : 1;
            to.scaleY = toScale;
            this.propKeys.push('scaleY');
        }
        this.from = from;
        this.to = to;
        this.props = to;
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class SpinOut extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onFirstRun() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const attrs = this.target.getAttributes();
        const toAngle = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.fromAngle) !== null && _b !== void 0 ? _b : Math.PI * 2;
        const toScale = (_d = (_c = this.params) === null || _c === void 0 ? void 0 : _c.fromScale) !== null && _d !== void 0 ? _d : 0;
        const fromOpacity = (_f = (_e = this.params) === null || _e === void 0 ? void 0 : _e.fromOpacity) !== null && _f !== void 0 ? _f : 1;
        const toOpacity = (_h = (_g = this.params) === null || _g === void 0 ? void 0 : _g.toOpacity) !== null && _h !== void 0 ? _h : 0;
        const from = {
            opacity: fromOpacity,
            baseOpacity: fromOpacity,
            angle: (_j = attrs.angle) !== null && _j !== void 0 ? _j : 0,
            scaleX: (_k = attrs.scaleX) !== null && _k !== void 0 ? _k : 1,
            scaleY: (_l = attrs.scaleY) !== null && _l !== void 0 ? _l : 1
        };
        const to = {
            opacity: toOpacity,
            baseOpacity: toOpacity,
            angle: toAngle,
            scaleX: toScale,
            scaleY: toScale
        };
        this.propKeys = ['opacity', 'baseOpacity', 'angle', 'scaleX', 'scaleY'];
        this.from = from;
        this.to = to;
        this.props = to;
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class MoveScaleOut extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        var _a;
        super(from, to, duration, easing, params);
        const slideRatio = (_a = params === null || params === void 0 ? void 0 : params.slideRatio) !== null && _a !== void 0 ? _a : 0.5;
        this.growOutDuration = duration * (1 - slideRatio);
        this.slideOutDuration = duration * slideRatio;
    }
    onFirstRun() {
        var _a, _b, _c, _d;
        const executor = new AnimateExecutor(this.target);
        executor.execute({
            type: 'custom',
            custom: GrowOut,
            customParameters: {
                fromScale: ((_a = this.params) === null || _a === void 0 ? void 0 : _a.fromScale) || 0.5,
                direction: ((_b = this.params) === null || _b === void 0 ? void 0 : _b.scaleDirection) || 'xy',
                fromOpacity: 1,
                toOpacity: 1
            },
            duration: this.growOutDuration,
            easing: this.easing
        });
        executor.execute({
            type: 'custom',
            custom: SlideOut,
            customParameters: {
                direction: ((_c = this.params) === null || _c === void 0 ? void 0 : _c.slideDirection) || 'right',
                distance: ((_d = this.params) === null || _d === void 0 ? void 0 : _d.slideDistance) || 50,
                fromOpacity: 1
            },
            duration: this.slideOutDuration,
            easing: this.easing,
            delay: this.growOutDuration
        });
    }
    onUpdate(end, ratio, out) {
    }
}
class MoveRotateOut extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        var _a;
        super(from, to, duration, easing, params);
        const slideRatio = (_a = params === null || params === void 0 ? void 0 : params.slideRatio) !== null && _a !== void 0 ? _a : 0.5;
        this.spinOutDuration = duration * (1 - slideRatio);
        this.slideOutDuration = duration * slideRatio;
    }
    onFirstRun() {
        var _a, _b, _c, _d;
        const executor = new AnimateExecutor(this.target);
        executor.execute({
            type: 'custom',
            custom: SpinOut,
            customParameters: {
                fromAngle: ((_a = this.params) === null || _a === void 0 ? void 0 : _a.fromAngle) || Math.PI,
                fromScale: ((_b = this.params) === null || _b === void 0 ? void 0 : _b.fromScale) || 0.5,
                fromOpacity: 1,
                toOpacity: 1
            },
            duration: this.spinOutDuration,
            easing: this.easing
        });
        executor.execute({
            type: 'custom',
            custom: SlideOut,
            customParameters: {
                direction: ((_c = this.params) === null || _c === void 0 ? void 0 : _c.slideDirection) || 'right',
                distance: ((_d = this.params) === null || _d === void 0 ? void 0 : _d.slideDistance) || 50,
                fromOpacity: 1
            },
            duration: this.slideOutDuration,
            easing: this.easing,
            delay: this.spinOutDuration
        });
    }
    onUpdate(end, ratio, out) {
    }
}
class PulseAnimate extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.originalAttributes = {};
        this.pulseCount = 3;
        this.pulseOpacity = 0.3;
        this.pulseScale = 1.05;
        this.pulseColor = null;
        this.pulseColorIntensity = 0.2;
        this.strokeOnly = false;
        this.fillOnly = false;
        this.useScale = true;
        this.useOpacity = true;
        this.useStroke = true;
        this.useFill = true;
        this.useColor = false;
        this.originalFill = null;
        this.originalStroke = null;
        if ((params === null || params === void 0 ? void 0 : params.pulseCount) !== undefined) {
            this.pulseCount = params.pulseCount;
        }
        if ((params === null || params === void 0 ? void 0 : params.pulseScale) !== undefined) {
            this.pulseScale = params.pulseScale;
        }
        if ((params === null || params === void 0 ? void 0 : params.pulseColor) !== undefined) {
            this.pulseColor = params.pulseColor;
        }
        if ((params === null || params === void 0 ? void 0 : params.pulseColorIntensity) !== undefined) {
            this.pulseColorIntensity = params.pulseColorIntensity;
        }
        if ((params === null || params === void 0 ? void 0 : params.strokeOnly) !== undefined) {
            this.strokeOnly = params.strokeOnly;
        }
        if ((params === null || params === void 0 ? void 0 : params.fillOnly) !== undefined) {
            this.fillOnly = params.fillOnly;
        }
        if ((params === null || params === void 0 ? void 0 : params.useScale) !== undefined) {
            this.useScale = params.useScale;
        }
        if ((params === null || params === void 0 ? void 0 : params.useOpacity) !== undefined) {
            this.useOpacity = params.useOpacity;
        }
        if ((params === null || params === void 0 ? void 0 : params.useStroke) !== undefined) {
            this.useStroke = params.useStroke;
        }
        if ((params === null || params === void 0 ? void 0 : params.useFill) !== undefined) {
            this.useFill = params.useFill;
        }
        if ((params === null || params === void 0 ? void 0 : params.useColor) !== undefined) {
            this.useColor = params.useColor;
        }
    }
    onBind() {
        super.onBind();
        this.originalAttributes = Object.assign({}, this.target.getAttributes());
        if (this.useColor) {
            this.originalFill = this.originalAttributes.fill || null;
            this.originalStroke = this.originalAttributes.stroke || null;
            if (!this.pulseColor) {
                if (this.fillOnly && this.originalFill) {
                    this.pulseColor = this.originalFill;
                }
                else if (this.strokeOnly && this.originalStroke) {
                    this.pulseColor = this.originalStroke;
                }
                else if (this.originalFill) {
                    this.pulseColor = this.originalFill;
                }
                else if (this.originalStroke) {
                    this.pulseColor = this.originalStroke;
                }
                else {
                    this.pulseColor = '#FFFFFF';
                }
            }
        }
    }
    onUpdate(end, ratio, out) {
        const angle = ratio * Math.PI * this.pulseCount;
        const pulseValue = Math.abs(Math.sin(angle));
        const attribute = this.target.attribute;
        if (this.useOpacity) {
            const opacity = 1 + (this.pulseOpacity - 1) * pulseValue;
            if (this.useStroke) {
                attribute.strokeOpacity = (this.originalAttributes.strokeOpacity || 1) * opacity;
            }
            if (this.useFill) {
                attribute.fillOpacity = (this.originalAttributes.fillOpacity || 1) * opacity;
            }
        }
        if (this.useScale) {
            const scale = 1 + (this.pulseScale - 1) * pulseValue;
            attribute.scaleX = (this.originalAttributes.scaleX || 1) * scale;
            attribute.scaleY = (this.originalAttributes.scaleY || 1) * scale;
        }
        if (this.useColor && this.pulseColor) {
            this.applyColorPulse(attribute, pulseValue);
        }
        this.target.addUpdateShapeAndBoundsTag();
        this.target.addUpdatePositionTag();
    }
    applyColorPulse(attribute, pulseValue) {
        const colorRatio = this.pulseColorIntensity * pulseValue;
        if (this.useFill && this.originalFill && this.pulseColor) {
            attribute.fill = interpolateColor(this.originalFill, this.pulseColor, colorRatio, true);
        }
        if (this.useStroke && this.originalStroke && this.pulseColor) {
            attribute.stroke = interpolateColor(this.originalStroke, this.pulseColor, colorRatio, true);
        }
    }
    onEnd() {
        super.onEnd();
        this.target.setAttributes(this.originalAttributes);
    }
}

class Update extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b;
        super.onBind();
        let { diffAttrs = {} } = (_a = this.target.context) !== null && _a !== void 0 ? _a : {};
        const { options } = this.params;
        diffAttrs = Object.assign({}, diffAttrs);
        if ((_b = options === null || options === void 0 ? void 0 : options.excludeChannels) === null || _b === void 0 ? void 0 : _b.length) {
            options.excludeChannels.forEach((channel) => {
                delete diffAttrs[channel];
            });
        }
        this.props = diffAttrs;
    }
    update(end, ratio, out) {
        this.onStart();
        if (!this.props || !this.propKeys) {
            return;
        }
        const easedRatio = this.easing(ratio);
        this.animate.interpolateUpdateFunction
            ? this.animate.interpolateUpdateFunction(this.fromProps, this.props, easedRatio, this, this.target)
            : this.interpolateUpdateFunctions.forEach((func, index) => {
                if (!this.animate.validAttr(this.propKeys[index])) {
                    return;
                }
                const key = this.propKeys[index];
                const fromValue = this.fromProps[key];
                const toValue = this.props[key];
                func(key, fromValue, toValue, easedRatio, this, this.target);
            });
        this.onUpdate(end, easedRatio, out);
    }
}

const moveIn = (graphic, options, animationParameters) => {
    var _a, _b, _c, _d;
    const { offset = 0, orient, direction, point: pointOpt, excludeChannels = [], layoutRect = {} } = options !== null && options !== void 0 ? options : {};
    let changedX = 0;
    let changedY = 0;
    if (orient === 'negative') {
        changedX = (_a = layoutRect.width) !== null && _a !== void 0 ? _a : graphic.stage.viewWidth;
        changedY = (_b = layoutRect.height) !== null && _b !== void 0 ? _b : graphic.stage.viewHeight;
    }
    changedX += offset;
    changedY += offset;
    const point = isFunction(pointOpt)
        ? pointOpt.call(null, (_d = (_c = graphic.context) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[0], graphic, animationParameters)
        : pointOpt;
    const finalAttrsX = graphic.getGraphicAttribute('x');
    const finalAttrsY = graphic.getGraphicAttribute('y');
    const fromX = excludeChannels.includes('x') ? finalAttrsX : point && isValidNumber(point.x) ? point.x : changedX;
    const fromY = excludeChannels.includes('y') ? finalAttrsY : point && isValidNumber(point.y) ? point.y : changedY;
    switch (direction) {
        case 'x':
            return {
                from: { x: excludeChannels.includes('x') ? finalAttrsX : fromX },
                to: { x: finalAttrsX }
            };
        case 'y':
            return {
                from: { y: fromY },
                to: { y: finalAttrsY }
            };
        case 'xy':
        default:
            return {
                from: { x: fromX, y: fromY },
                to: {
                    x: finalAttrsX,
                    y: finalAttrsY
                }
            };
    }
};
const moveOut = (graphic, options, animationParameters) => {
    var _a, _b, _c, _d;
    const { offset = 0, orient, direction, point: pointOpt } = options !== null && options !== void 0 ? options : {};
    const groupBounds = animationParameters.group ? animationParameters.group.AABBBounds : null;
    const groupWidth = (_a = groupBounds.width()) !== null && _a !== void 0 ? _a : animationParameters.width;
    const groupHeight = (_b = groupBounds.height()) !== null && _b !== void 0 ? _b : animationParameters.height;
    const changedX = (orient === 'negative' ? groupWidth : 0) + offset;
    const changedY = (orient === 'negative' ? groupHeight : 0) + offset;
    const point = isFunction(pointOpt)
        ? pointOpt.call(null, (_d = (_c = graphic.context) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[0], graphic, animationParameters)
        : pointOpt;
    const fromX = point && isValidNumber(point.x) ? point.x : changedX;
    const fromY = point && isValidNumber(point.y) ? point.y : changedY;
    switch (direction) {
        case 'x':
            return {
                from: { x: graphic.getGraphicAttribute('x') },
                to: { x: fromX }
            };
        case 'y':
            return {
                from: { y: graphic.getGraphicAttribute('y') },
                to: { y: fromY }
            };
        case 'xy':
        default:
            return {
                from: {
                    x: graphic.getGraphicAttribute('x'),
                    y: graphic.getGraphicAttribute('y')
                },
                to: { x: fromX, y: fromY }
            };
    }
};
class MoveBase extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class MoveIn extends MoveBase {
    onBind() {
        var _a;
        super.onBind();
        const { from, to } = moveIn(this.target, this.params.options, this.params);
        this.props = to;
        this.propKeys = Object.keys(to).filter(key => to[key] != null);
        this.from = from;
        this.to = to;
        const finalAttribute = this.target.getFinalAttribute();
        if (finalAttribute) {
            this.target.setAttributes(finalAttribute);
        }
        if (((_a = this.params.controlOptions) === null || _a === void 0 ? void 0 : _a.immediatelyApply) !== false) {
            this.target.setAttributes(from);
        }
    }
}
class MoveOut extends MoveBase {
    onBind() {
        super.onBind();
        const { from, to } = moveOut(this.target, this.params.options, this.params);
        this.props = to;
        this.propKeys = Object.keys(to).filter(key => to[key] != null);
        this.from = from;
        this.to = to;
    }
}

const rotateIn = (graphic, options) => {
    var _a;
    const finalAttrs = graphic.getFinalAttribute();
    const attributeAngle = (_a = finalAttrs.angle) !== null && _a !== void 0 ? _a : 0;
    let angle = 0;
    if (isNumberClose(attributeAngle / (Math.PI * 2), 0)) {
        angle = Math.round(attributeAngle / (Math.PI * 2)) * Math.PI * 2;
    }
    else if (isValidNumber(options === null || options === void 0 ? void 0 : options.angle)) {
        angle = options.angle;
    }
    else if ((options === null || options === void 0 ? void 0 : options.orient) === 'anticlockwise') {
        angle = Math.ceil(attributeAngle / (Math.PI * 2)) * Math.PI * 2;
    }
    else {
        angle = Math.floor(attributeAngle / (Math.PI * 2)) * Math.PI * 2;
    }
    return {
        from: { angle },
        to: { angle: attributeAngle }
    };
};
const rotateOut = (graphic, options) => {
    var _a;
    const finalAttrs = graphic.getFinalAttribute();
    const finalAngle = (_a = finalAttrs.angle) !== null && _a !== void 0 ? _a : 0;
    let angle = 0;
    if (isNumberClose(finalAngle / (Math.PI * 2), 0)) {
        angle = Math.round(finalAngle / (Math.PI * 2)) * Math.PI * 2;
    }
    else if (isValidNumber(options === null || options === void 0 ? void 0 : options.angle)) {
        angle = options.angle;
    }
    else if ((options === null || options === void 0 ? void 0 : options.orient) === 'anticlockwise') {
        angle = Math.ceil(finalAngle / (Math.PI * 2)) * Math.PI * 2;
    }
    else {
        angle = Math.floor(finalAngle / (Math.PI * 2)) * Math.PI * 2;
    }
    return {
        from: { angle: finalAngle },
        to: { angle }
    };
};
class RotateBase extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach(key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        });
        this.target.addUpdatePositionTag();
        this.target.addUpdateShapeAndBoundsTag();
    }
}
class RotateIn extends RotateBase {
    onBind() {
        var _a;
        super.onBind();
        const { from, to } = rotateIn(this.target, this.params.options);
        this.props = to;
        this.propKeys = ['angle'];
        this.from = from;
        this.to = to;
        const finalAttribute = this.target.getFinalAttribute();
        if (finalAttribute) {
            this.target.setAttributes(finalAttribute);
        }
        if (((_a = this.params.controlOptions) === null || _a === void 0 ? void 0 : _a.immediatelyApply) !== false) {
            this.target.setAttributes(from);
        }
    }
}
class RotateOut extends RotateBase {
    onBind() {
        super.onBind();
        const { from, to } = rotateOut(this.target, this.params.options);
        this.props = to;
        this.propKeys = ['angle'];
        this.from = from;
        this.to = to;
    }
}

class MotionPath extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        var _a;
        super(from, to, duration, easing, params);
        if (params) {
            this.pathLength = params.path.getLength();
            this.path = params.path;
            this.distance = params.distance;
            this.totalLength = this.distance * this.pathLength;
            this.initAngle = (_a = params.initAngle) !== null && _a !== void 0 ? _a : 0;
            this.changeAngle = !!params.changeAngle;
            this.cb = params.cb;
        }
    }
    onBind() {
        this.from = { x: 0, y: 0 };
        this.to = this.path.getAttrAt(this.totalLength).pos;
        this.props = this.to;
    }
    onUpdate(end, ratio, out) {
        const attrs = {};
        const at = this.totalLength * ratio;
        const { pos, angle } = this.path.getAttrAt(at);
        attrs.x = pos.x;
        attrs.y = pos.y;
        if (this.changeAngle) {
            attrs.angle = angle + this.initAngle;
        }
        this.cb && this.cb(this.from, this.to, ratio, this.target);
        this.target.setAttributes(attrs);
    }
}

class FromTo extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.from = from !== null && from !== void 0 ? from : {};
    }
    onBind() {
        var _a, _b;
        super.onBind();
        Object.keys(this.from).forEach(key => {
            if (this.props[key] == null) {
                this.props[key] = this.target.getGraphicAttribute(key);
            }
        });
        const finalAttribute = this.target.getFinalAttribute();
        if (((_a = this.target.context) === null || _a === void 0 ? void 0 : _a.animationState) === 'appear') {
            if (finalAttribute) {
                this.target.setAttributes(finalAttribute);
            }
        }
        if (((_b = this.params.controlOptions) === null || _b === void 0 ? void 0 : _b.immediatelyApply) !== false) {
            this.target.setAttributes(this.from);
        }
    }
    onFirstRun() {
        this.from = Object.assign(Object.assign({}, this.getLastProps()), this.from);
        const startProps = this.animate.getStartProps();
        this.propKeys &&
            this.propKeys.forEach(key => {
                var _a;
                this.from[key] = (_a = this.from[key]) !== null && _a !== void 0 ? _a : startProps[key];
            });
        this.target.setAttributes(this.from);
    }
    deleteSelfAttr(key) {
        super.deleteSelfAttr(key);
        delete this.from[key];
    }
    update(end, ratio, out) {
        this.onStart();
        if (!this.props || !this.propKeys) {
            return;
        }
        const easedRatio = this.easing(ratio);
        this.animate.interpolateUpdateFunction
            ? this.animate.interpolateUpdateFunction(this.from, this.props, easedRatio, this, this.target)
            : this.interpolateUpdateFunctions.forEach((func, index) => {
                if (!this.animate.validAttr(this.propKeys[index])) {
                    return;
                }
                const key = this.propKeys[index];
                const fromValue = this.from[key];
                const toValue = this.props[key];
                func(key, fromValue, toValue, easedRatio, this, this.target);
            });
        this.onUpdate(end, easedRatio, out);
        this.syncAttributeUpdate();
    }
}

class StreamLight extends ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    getEndProps() {
        return {};
    }
    onStart() {
        if (!this.target) {
            return;
        }
        if (this.target.type === 'rect') {
            this.onStartRect();
        }
        else if (this.target.type === 'line') {
            this.onStartLineOrArea('line');
        }
        else if (this.target.type === 'area') {
            this.onStartLineOrArea('area');
        }
    }
    onStartLineOrArea(type) {
        var _a;
        const root = this.target.attachShadow();
        const line = application.graphicService.creator[type](Object.assign({}, (_a = this.params) === null || _a === void 0 ? void 0 : _a.attribute));
        this[type] = line;
        line.pathProxy = new CustomPath2D();
        root.add(line);
    }
    onStartRect() {
        var _a, _b, _c;
        const root = this.target.attachShadow();
        const isHorizontal = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.isHorizontal) !== null && _b !== void 0 ? _b : true;
        const sizeAttr = isHorizontal ? 'height' : 'width';
        const otherSizeAttr = isHorizontal ? 'width' : 'height';
        const size = this.target.AABBBounds[sizeAttr]();
        const y = isHorizontal ? 0 : this.target.AABBBounds.y1;
        const rect = application.graphicService.creator.rect(Object.assign(Object.assign({ [sizeAttr]: size, fill: '#bcdeff', shadowBlur: 30, shadowColor: '#bcdeff' }, (_c = this.params) === null || _c === void 0 ? void 0 : _c.attribute), { x: 0, y, [otherSizeAttr]: 0 }));
        this.rect = rect;
        root.add(rect);
    }
    onBind() {
        return;
    }
    onEnd() {
        this.target.detachShadow();
    }
    onUpdate(end, ratio, out) {
        if (this.rect) {
            return this.onUpdateRect(end, ratio, out);
        }
        else if (this.line || this.area) {
            return this.onUpdateLineOrArea(end, ratio, out);
        }
    }
    onUpdateRect(end, ratio, out) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        const isHorizontal = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.isHorizontal) !== null && _b !== void 0 ? _b : true;
        const parentAttr = this.target.attribute;
        if (isHorizontal) {
            const parentWidth = (_d = (_c = parentAttr.width) !== null && _c !== void 0 ? _c : Math.abs(parentAttr.x1 - parentAttr.x)) !== null && _d !== void 0 ? _d : 250;
            const streamLength = (_f = (_e = this.params) === null || _e === void 0 ? void 0 : _e.streamLength) !== null && _f !== void 0 ? _f : parentWidth;
            const maxLength = (_j = (_h = (_g = this.params) === null || _g === void 0 ? void 0 : _g.attribute) === null || _h === void 0 ? void 0 : _h.width) !== null && _j !== void 0 ? _j : 60;
            const startX = -maxLength;
            const currentX = startX + (streamLength - startX) * ratio;
            const x = Math.max(currentX, 0);
            const w = Math.min(Math.min(currentX + maxLength, maxLength), streamLength - currentX);
            const width = w + x > parentWidth ? Math.max(parentWidth - x, 0) : w;
            this.rect.setAttributes({
                x: x + Math.min(parentAttr.x1 - parentAttr.x, 0),
                width
            }, false, {
                type: AttributeUpdateType.ANIMATE_PLAY,
                animationState: {
                    ratio,
                    end
                }
            });
        }
        else {
            const parentHeight = (_l = (_k = parentAttr.height) !== null && _k !== void 0 ? _k : Math.abs(parentAttr.y1 - parentAttr.y)) !== null && _l !== void 0 ? _l : 250;
            const streamLength = (_o = (_m = this.params) === null || _m === void 0 ? void 0 : _m.streamLength) !== null && _o !== void 0 ? _o : parentHeight;
            const maxLength = (_r = (_q = (_p = this.params) === null || _p === void 0 ? void 0 : _p.attribute) === null || _q === void 0 ? void 0 : _q.height) !== null && _r !== void 0 ? _r : 60;
            const startY = parentHeight;
            const currentY = startY - (streamLength + maxLength) * ratio;
            let y = Math.min(currentY, parentHeight);
            const h = Math.min(parentHeight - currentY, maxLength);
            let height;
            if (y <= 0) {
                height = Math.max(y + h, 0);
                y = 0;
            }
            else {
                height = h;
            }
            this.rect.setAttributes({
                y: y + Math.min(parentAttr.y1 - parentAttr.y, 0),
                height
            }, false, {
                type: AttributeUpdateType.ANIMATE_PLAY,
                animationState: {
                    ratio,
                    end
                }
            });
        }
    }
    onUpdateLineOrArea(end, ratio, out) {
        const target = this.line || this.area;
        if (!target) {
            return;
        }
        const customPath = target.pathProxy;
        const targetLine = this.target;
        if (targetLine.cache || targetLine.cacheArea) {
            this._onUpdateLineOrAreaWithCache(customPath, targetLine, end, ratio, out);
        }
        else {
            this._onUpdateLineWithoutCache(customPath, targetLine, end, ratio, out);
        }
        const targetAttrs = targetLine.attribute;
        target.setAttributes(Object.assign({ stroke: targetAttrs.stroke }, target.attribute));
        target.addUpdateBoundTag();
    }
    _onUpdateLineOrAreaWithCache(customPath, g, end, ratio, out) {
        var _a, _b;
        customPath.clear();
        if (g.type === 'line') {
            let cache = g.cache;
            if (!Array.isArray(cache)) {
                cache = [cache];
            }
            const totalLen = cache.reduce((l, c) => l + c.getLength(), 0);
            const curves = [];
            cache.forEach((c) => {
                c.curves.forEach((ci) => curves.push(ci));
            });
            return this._updateCurves(customPath, curves, totalLen, ratio);
        }
        else if (g.type === 'area' && ((_b = (_a = g.cacheArea) === null || _a === void 0 ? void 0 : _a.top) === null || _b === void 0 ? void 0 : _b.curves)) {
            const cache = g.cacheArea;
            const totalLen = cache.top.curves.reduce((a, b) => a + b.getLength(), 0);
            return this._updateCurves(customPath, cache.top.curves, totalLen, ratio);
        }
    }
    _updateCurves(customPath, curves, totalLen, ratio) {
        var _a, _b;
        const startLen = totalLen * ratio;
        const endLen = Math.min(startLen + ((_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.streamLength) !== null && _b !== void 0 ? _b : 10), totalLen);
        let lastLen = 0;
        let start = false;
        for (let i = 0; i < curves.length; i++) {
            if (curves[i].defined !== false) {
                const curveItem = curves[i];
                const len = curveItem.getLength();
                const startPercent = 1 - (lastLen + len - startLen) / len;
                let endPercent = 1 - (lastLen + len - endLen) / len;
                let curveForStart;
                if (lastLen < startLen && lastLen + len > startLen) {
                    start = true;
                    if (curveItem.p2 && curveItem.p3) {
                        const [_, curve2] = divideCubic(curveItem, startPercent);
                        customPath.moveTo(curve2.p0.x, curve2.p0.y);
                        curveForStart = curve2;
                    }
                    else {
                        const p = curveItem.getPointAt(startPercent);
                        customPath.moveTo(p.x, p.y);
                    }
                }
                if (lastLen < endLen && lastLen + len > endLen) {
                    if (curveItem.p2 && curveItem.p3) {
                        if (curveForStart) {
                            endPercent = (endLen - startLen) / curveForStart.getLength();
                        }
                        const [curve1] = divideCubic(curveForStart || curveItem, endPercent);
                        customPath.bezierCurveTo(curve1.p1.x, curve1.p1.y, curve1.p2.x, curve1.p2.y, curve1.p3.x, curve1.p3.y);
                    }
                    else {
                        const p = curveItem.getPointAt(endPercent);
                        customPath.lineTo(p.x, p.y);
                    }
                    break;
                }
                else if (start) {
                    if (curveItem.p2 && curveItem.p3) {
                        const curve = curveForStart || curveItem;
                        customPath.bezierCurveTo(curve.p1.x, curve.p1.y, curve.p2.x, curve.p2.y, curve.p3.x, curve.p3.y);
                    }
                    else {
                        customPath.lineTo(curveItem.p1.x, curveItem.p1.y);
                    }
                }
                lastLen += len;
            }
        }
    }
    _onUpdateLineWithoutCache(customPath, line, end, ratio, out) {
        var _a, _b;
        const { points, curveType } = line.attribute;
        if (!points || points.length < 2 || curveType !== 'linear') {
            return;
        }
        let totalLen = 0;
        for (let i = 1; i < points.length; i++) {
            totalLen += PointService.distancePP(points[i], points[i - 1]);
        }
        const startLen = totalLen * ratio;
        const endLen = Math.min(startLen + ((_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.streamLength) !== null && _b !== void 0 ? _b : 10), totalLen);
        const nextPoints = [];
        let lastLen = 0;
        for (let i = 1; i < points.length; i++) {
            const len = PointService.distancePP(points[i], points[i - 1]);
            if (lastLen < startLen && lastLen + len > startLen) {
                nextPoints.push(PointService.pointAtPP(points[i - 1], points[i], 1 - (lastLen + len - startLen) / len));
            }
            if (lastLen < endLen && lastLen + len > endLen) {
                nextPoints.push(PointService.pointAtPP(points[i - 1], points[i], 1 - (lastLen + len - endLen) / len));
                break;
            }
            else if (nextPoints.length) {
                nextPoints.push(points[i]);
            }
            lastLen += len;
        }
        if (!nextPoints.length || nextPoints.length < 2) {
            return;
        }
        customPath.clear();
        customPath.moveTo(nextPoints[0].x, nextPoints[0].y);
        for (let i = 1; i < nextPoints.length; i++) {
            customPath.lineTo(nextPoints[i].x, nextPoints[i].y);
        }
    }
}

class DisappearAnimateBase extends AStageAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
        this.webglCanvas = null;
        this.gl = null;
        this.program = null;
        this.currentAnimationRatio = 0;
        this.animationTime = 0;
    }
    onUpdate(end, ratio, out) {
        super.onUpdate(end, ratio, out);
        this.currentAnimationRatio = ratio;
        this.animationTime = ratio * Math.PI * 2;
    }
    getAnimationTime() {
        if (this.currentAnimationRatio > 0) {
            return this.animationTime;
        }
        return Date.now() / 1000.0;
    }
    getDurationFromParent() {
        return this.duration || 1000;
    }
    initWebGL(canvas) {
        try {
            this.webglCanvas = vglobal.createCanvas({
                width: canvas.width,
                height: canvas.height,
                dpr: vglobal.devicePixelRatio
            });
            if (!this.webglCanvas) {
                console.warn('WebGL canvas creation failed');
                return false;
            }
            this.webglCanvas.style.width = canvas.style.width || `${canvas.width}px`;
            this.webglCanvas.style.height = canvas.style.height || `${canvas.height}px`;
            let glContext = null;
            try {
                glContext = this.webglCanvas.getContext('webgl');
                if (!glContext) {
                    glContext = this.webglCanvas.getContext('experimental-webgl');
                }
            }
            catch (e) {
                console.warn('Failed to get WebGL context:', e);
            }
            this.gl = glContext;
            if (!this.gl) {
                console.warn('WebGL not supported');
                return false;
            }
            const shaders = this.getShaderSources();
            this.program = this.createShaderProgram(shaders.vertex, shaders.fragment);
            return this.program !== null;
        }
        catch (error) {
            console.warn('Failed to initialize WebGL:', error);
            return false;
        }
    }
    createShaderProgram(vertexSource, fragmentSource) {
        if (!this.gl) {
            return null;
        }
        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
        if (!vertexShader || !fragmentShader) {
            return null;
        }
        const program = this.gl.createProgram();
        if (!program) {
            return null;
        }
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        this.gl.linkProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            console.error('Shader program link error:', this.gl.getProgramInfoLog(program));
            return null;
        }
        return program;
    }
    createShader(type, source) {
        if (!this.gl) {
            return null;
        }
        const shader = this.gl.createShader(type);
        if (!shader) {
            return null;
        }
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
            this.gl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    setupWebGLState(canvas) {
        if (!this.gl || !this.webglCanvas) {
            return;
        }
        if (this.webglCanvas.width !== canvas.width || this.webglCanvas.height !== canvas.height) {
            this.webglCanvas.width = canvas.width;
            this.webglCanvas.height = canvas.height;
        }
        this.gl.viewport(0, 0, this.webglCanvas.width, this.webglCanvas.height);
        this.gl.clearColor(0.0, 0.0, 0.0, 0.0);
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    }
    createFullScreenQuad() {
        if (!this.gl) {
            return null;
        }
        const vertices = new Float32Array([
            -1,
            -1,
            0,
            1,
            1,
            -1,
            1,
            1,
            -1,
            1,
            0,
            0,
            1,
            1,
            1,
            0
        ]);
        const vertexBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexBuffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
        return vertexBuffer;
    }
    createTextureFromCanvas(canvas) {
        if (!this.gl) {
            return null;
        }
        const texture = this.gl.createTexture();
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, canvas);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        return texture;
    }
    setupVertexAttributes() {
        if (!this.gl || !this.program) {
            return;
        }
        const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
        const texCoordLocation = this.gl.getAttribLocation(this.program, 'a_texCoord');
        this.gl.enableVertexAttribArray(positionLocation);
        this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 16, 0);
        this.gl.enableVertexAttribArray(texCoordLocation);
        this.gl.vertexAttribPointer(texCoordLocation, 2, this.gl.FLOAT, false, 16, 8);
    }
    createOutputCanvas(canvas) {
        const outputCanvas = vglobal.createCanvas({
            width: canvas.width,
            height: canvas.height,
            dpr: vglobal.devicePixelRatio
        });
        const ctx = outputCanvas.getContext('2d');
        if (!ctx) {
            return null;
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(canvas, 0, 0);
        return { canvas: outputCanvas, ctx };
    }
    getShaderSources() {
        return null;
    }
    applyWebGLEffect(canvas) {
        return null;
    }
    applyCanvas2DEffect(canvas) {
        return null;
    }
    supportsWebGL() {
        return this.getShaderSources() !== null;
    }
    supportsCanvas2D() {
        return this.applyCanvas2DEffect !== DisappearAnimateBase.prototype.applyCanvas2DEffect;
    }
    release() {
        super.release();
        if (this.gl) {
            if (this.program) {
                this.gl.deleteProgram(this.program);
                this.program = null;
            }
            this.gl = null;
        }
        if (this.webglCanvas) {
            this.webglCanvas = null;
        }
        this.currentAnimationRatio = 0;
        this.animationTime = 0;
    }
    afterStageRender(stage, canvas) {
        let result = null;
        if (this.supportsWebGL()) {
            if (!this.gl && !this.initWebGL(canvas)) {
                console.warn('WebGL初始化失败，尝试Canvas 2D回退');
            }
            if (this.gl) {
                result = this.applyWebGLEffect(canvas);
                if (result) {
                    return result;
                }
                console.warn('WebGL特效执行失败，尝试Canvas 2D回退');
            }
        }
        if (this.supportsCanvas2D()) {
            result = this.applyCanvas2DEffect(canvas);
            if (result) {
                return result;
            }
            console.warn('Canvas 2D特效执行失败');
        }
        if (!this.supportsWebGL() && !this.supportsCanvas2D()) {
            console.error(`特效类 ${this.constructor.name} 未实现任何渲染方法。请实现 applyWebGLEffect 或 applyCanvas2DEffect 方法。`);
        }
        return canvas;
    }
}

class Canvas2DEffectBase extends DisappearAnimateBase {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    getShaderSources() {
        return null;
    }
    applyWebGLEffect(canvas) {
        return null;
    }
}
class HybridEffectBase extends DisappearAnimateBase {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    getShaderSources() {
        return null;
    }
    applyWebGLEffect(canvas) {
        return null;
    }
    applyCanvas2DEffect(canvas) {
        return null;
    }
    supportsWebGL() {
        return this.getShaderSources !== HybridEffectBase.prototype.getShaderSources && this.getShaderSources() !== null;
    }
    supportsCanvas2D() {
        return this.applyCanvas2DEffect !== HybridEffectBase.prototype.applyCanvas2DEffect;
    }
    afterStageRender(stage, canvas) {
        var _a, _b;
        let result = null;
        if (((_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.useWebGL) !== false) {
            if (this.supportsWebGL()) {
                if (!this.gl && !this.initWebGL(canvas)) {
                    console.warn('WebGL初始化失败，尝试Canvas 2D回退');
                }
                if (this.gl) {
                    result = this.applyWebGLEffect(canvas);
                    if (result) {
                        return result;
                    }
                    console.warn('WebGL特效执行失败，尝试Canvas 2D回退');
                }
            }
            if (this.supportsCanvas2D()) {
                result = this.applyCanvas2DEffect(canvas);
                if (result) {
                    return result;
                }
                console.warn('Canvas 2D特效执行失败');
            }
        }
        else {
            if (this.supportsCanvas2D()) {
                result = this.applyCanvas2DEffect(canvas);
                if (result) {
                    return result;
                }
                console.warn('Canvas 2D特效执行失败');
            }
            else {
                console.warn(`${this.constructor.name}: useWebGL=false 但未实现Canvas 2D方法`);
            }
        }
        if (!this.supportsWebGL() && !this.supportsCanvas2D()) {
            console.error(`特效类 ${this.constructor.name} 未实现任何渲染方法。请实现 applyWebGLEffect 或 applyCanvas2DEffect 方法。`);
        }
        return canvas;
    }
}

class ImageProcessUtils {
    static createTempCanvas(width, height, dpr) {
        return vglobal.createCanvas({
            width,
            height,
            dpr: dpr || vglobal.devicePixelRatio
        });
    }
    static cloneImageData(imageData) {
        const clonedData = new Uint8ClampedArray(imageData.data);
        return new ImageData(clonedData, imageData.width, imageData.height);
    }
    static lerp(start, end, t) {
        return start * (1 - t) + end * t;
    }
    static smoothstep(edge0, edge1, x) {
        const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
        return t * t * (3 - 2 * t);
    }
    static distance(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        return Math.sqrt(dx * dx + dy * dy);
    }
    static normalizeAngle(angle) {
        return (angle + Math.PI) / (2 * Math.PI);
    }
    static pixelNoise(x, y, pixelSize) {
        if (pixelSize <= 0) {
            return 0;
        }
        const gridX = Math.floor(x / pixelSize) * pixelSize;
        const gridY = Math.floor(y / pixelSize) * pixelSize;
        const n = Math.sin(gridX * 12.9898 + gridY * 78.233) * 43758.5453;
        return n - Math.floor(n);
    }
    static generateNoiseTexture(width, height) {
        const data = new Uint8Array(width * height);
        for (let i = 0; i < data.length; i++) {
            data[i] = Math.floor(Math.random() * 256);
        }
        return data;
    }
    static applyCSSFilter(canvas, filter) {
        const outputCanvas = this.createTempCanvas(canvas.width, canvas.height);
        const ctx = outputCanvas.getContext('2d');
        if (!ctx) {
            return canvas;
        }
        ctx.filter = filter;
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = 'none';
        return outputCanvas;
    }
    static extractChannel(imageData, channelIndex) {
        const { data, width, height } = imageData;
        const channelData = new Uint8ClampedArray(data.length);
        for (let i = 0; i < data.length; i += 4) {
            channelData[i] = 0;
            channelData[i + 1] = 0;
            channelData[i + 2] = 0;
            channelData[i + 3] = data[i + 3];
            if (channelIndex >= 0 && channelIndex <= 2) {
                channelData[i + channelIndex] = data[i + channelIndex];
            }
        }
        return new ImageData(channelData, width, height);
    }
    static blendImageData(imageData1, imageData2, ratio) {
        const { data: data1, width, height } = imageData1;
        const { data: data2 } = imageData2;
        const result = new Uint8ClampedArray(data1.length);
        for (let i = 0; i < data1.length; i += 4) {
            result[i] = Math.round(this.lerp(data1[i], data2[i], ratio));
            result[i + 1] = Math.round(this.lerp(data1[i + 1], data2[i + 1], ratio));
            result[i + 2] = Math.round(this.lerp(data1[i + 2], data2[i + 2], ratio));
            result[i + 3] = Math.round(this.lerp(data1[i + 3], data2[i + 3], ratio));
        }
        return new ImageData(result, width, height);
    }
    static getLuminance(r, g, b) {
        return r * 0.299 + g * 0.587 + b * 0.114;
    }
    static applySepiaToPixel(r, g, b) {
        const sepiaR = Math.min(255, r * 0.393 + g * 0.769 + b * 0.189);
        const sepiaG = Math.min(255, r * 0.349 + g * 0.686 + b * 0.168);
        const sepiaB = Math.min(255, r * 0.272 + g * 0.534 + b * 0.131);
        return [sepiaR, sepiaG, sepiaB];
    }
    static calculateDynamicStrength(baseStrength, animationTime) {
        return baseStrength * (animationTime / (Math.PI * 2));
    }
}
class ShaderLibrary {
}
ShaderLibrary.STANDARD_VERTEX_SHADER = `
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;

    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texCoord = a_texCoord;
    }
  `;
ShaderLibrary.SHADER_FUNCTIONS = `
    // 亮度计算函数
    float luminance(vec3 color) {
      return dot(color, vec3(0.299, 0.587, 0.114));
    }

    // 褐色调函数
    vec3 sepia(vec3 color) {
      float r = color.r * 0.393 + color.g * 0.769 + color.b * 0.189;
      float g = color.r * 0.349 + color.g * 0.686 + color.b * 0.168;
      float b = color.r * 0.272 + color.g * 0.534 + color.b * 0.131;
      return vec3(r, g, b);
    }

    // 线性插值函数
    float lerp(float a, float b, float t) {
      return a * (1.0 - t) + b * t;
    }


    // 简单噪声函数
    float pixelNoise(vec2 coord, float pixelSize) {
      vec2 gridCoord = floor(coord / pixelSize) * pixelSize;
      return fract(sin(dot(gridCoord, vec2(12.9898, 78.233))) * 43758.5453123);
    }

    // 动态强度计算
    float calculateDynamicStrength(float baseStrength, float time) {
      return baseStrength * (time / 6.28318531); // 2π
    }
  `;

class Dissolve extends HybridEffectBase {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c, _d;
        super(from, to, duration, easing, params);
        this.noiseData = null;
        const rawNoiseScale = (_a = params === null || params === void 0 ? void 0 : params.options) === null || _a === void 0 ? void 0 : _a.noiseScale;
        const clampedNoiseScale = rawNoiseScale !== undefined ? Math.max(0, Math.floor(rawNoiseScale)) : 8;
        this.dissolveConfig = {
            dissolveType: ((_b = params === null || params === void 0 ? void 0 : params.options) === null || _b === void 0 ? void 0 : _b.dissolveType) || 'outward',
            useWebGL: ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.useWebGL) !== undefined ? params.options.useWebGL : true,
            noiseScale: clampedNoiseScale,
            fadeEdge: ((_d = params === null || params === void 0 ? void 0 : params.options) === null || _d === void 0 ? void 0 : _d.fadeEdge) !== undefined ? params.options.fadeEdge : true
        };
    }
    getShaderSources() {
        const vertexShader = ShaderLibrary.STANDARD_VERTEX_SHADER;
        const fragmentShader = `
      precision mediump float;
      uniform sampler2D u_texture;
      uniform sampler2D u_noiseTexture;
      uniform float u_time;
      uniform int u_dissolveType;
      uniform vec2 u_resolution;
      uniform float u_noiseScale;
      uniform bool u_fadeEdge;
      varying vec2 v_texCoord;

      ${ShaderLibrary.SHADER_FUNCTIONS}

      // 向外溶解函数
      float outwardDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {
        vec2 center = vec2(0.5, 0.5);
        float distFromCenter = length(uv - center);
        float maxDist = length(vec2(0.5, 0.5));

        // 归一化距离 (0为中心，1为边缘)
        float normalizedDist = distFromCenter / maxDist;

        // 向外溶解：从边缘开始溶解，time控制溶解进度
        // 增加安全边距，确保动画结束时完全溶解
        float edgeThreshold = 1.2 - time * 1.5;

        // 当pixelSize > 0时添加颗粒效果
        if (pixelSize > 0.0) {
          // 添加基于像素大小的噪声，让边缘呈现颗粒状
          vec2 pixelCoord = uv * resolution; // 转换为像素坐标
          float noiseValue = pixelNoise(pixelCoord, pixelSize);
          float noiseInfluence = (noiseValue - 0.5) * 0.4; // 增强噪声影响
          edgeThreshold += noiseInfluence;
          return normalizedDist > edgeThreshold ? 0.0 : 1.0;
        } else {
          // 平滑溶解：根据fadeEdge决定是否使用渐变
          if (u_fadeEdge) {
            // 柔和边缘：返回渐变值
            float fadeWidth = 0.15; // 渐变宽度
            return 1.0 - smoothstep(edgeThreshold - fadeWidth, edgeThreshold, normalizedDist);
          } else {
            // 硬边缘：返回0或1
            return normalizedDist > edgeThreshold ? 0.0 : 1.0;
          }
        }
      }

      // 向内溶解函数
      float inwardDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {
        vec2 center = vec2(0.5, 0.5);
        float distFromCenter = length(uv - center);
        float maxDist = length(vec2(0.5, 0.5));

        float normalizedDist = distFromCenter / maxDist;

        // 向内溶解：从中心开始溶解，time控制溶解进度
        // 增加系数，确保动画结束时完全溶解
        float centerThreshold = time * 1.4;

        // 当pixelSize > 0时添加颗粒效果
        if (pixelSize > 0.0) {
          vec2 pixelCoord = uv * resolution;
          float noiseValue = pixelNoise(pixelCoord, pixelSize);
          float noiseInfluence = (noiseValue - 0.5) * 0.4;
          centerThreshold += noiseInfluence;
          return normalizedDist < centerThreshold ? 0.0 : 1.0;
        } else {
          // 平滑溶解：根据fadeEdge决定是否使用渐变
          if (u_fadeEdge) {
            // 柔和边缘：返回渐变值
            float fadeWidth = 0.15; // 渐变宽度
            return smoothstep(centerThreshold, centerThreshold + fadeWidth, normalizedDist);
          } else {
            // 硬边缘：返回0或1
            return normalizedDist < centerThreshold ? 0.0 : 1.0;
          }
        }
      }

      // 径向溶解函数
      float radialDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {
        vec2 center = vec2(0.5, 0.5);
        float angle = atan(uv.y - center.y, uv.x - center.x);
        float normalizedAngle = (angle + 3.14159) / (2.0 * 3.14159);

        // 径向溶解：按角度顺序溶解，time控制溶解进度
        // 增加系数，确保动画结束时完全溶解
        float angleThreshold = time * 1.2;

        // 当pixelSize > 0时添加颗粒效果
        if (pixelSize > 0.0) {
          vec2 pixelCoord = uv * resolution;
          float noiseValue = pixelNoise(pixelCoord, pixelSize);
          float noiseInfluence = (noiseValue - 0.5) * 0.3;
          angleThreshold += noiseInfluence;
          return normalizedAngle < angleThreshold ? 0.0 : 1.0;
        } else {
          // 平滑溶解：根据fadeEdge决定是否使用渐变
          if (u_fadeEdge) {
            // 柔和边缘：返回渐变值
            float fadeWidth = 0.08; // 渐变宽度
            return smoothstep(angleThreshold, angleThreshold + fadeWidth, normalizedAngle);
          } else {
            // 硬边缘：返回0或1
            return normalizedAngle < angleThreshold ? 0.0 : 1.0;
          }
        }
      }

      // 从左到右溶解函数
      float leftToRightDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {
        // 左到右溶解：从x=0开始向x=1溶解
        float dissolvePosition = time * 1.2; // 增加系数确保完全溶解

        // 当pixelSize > 0时添加颗粒效果
        if (pixelSize > 0.0) {
          vec2 pixelCoord = uv * resolution;
          float noiseValue = pixelNoise(pixelCoord, pixelSize);
          float noiseInfluence = (noiseValue - 0.5) * 0.3;
          dissolvePosition += noiseInfluence;
          return uv.x < dissolvePosition ? 0.0 : 1.0;
        } else {
          // 平滑溶解：根据fadeEdge决定是否使用渐变
          if (u_fadeEdge) {
            // 柔和边缘：返回渐变值
            float fadeWidth = 0.08; // 渐变宽度
            return smoothstep(dissolvePosition, dissolvePosition + fadeWidth, uv.x);
          } else {
            // 硬边缘：返回0或1
            return uv.x < dissolvePosition ? 0.0 : 1.0;
          }
        }
      }

      // 从右到左溶解函数
      float rightToLeftDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {
        // 右到左溶解：从x=1开始向x=0溶解
        float dissolvePosition = 1.0 - time * 1.2; // 增加系数确保完全溶解

        // 当pixelSize > 0时添加颗粒效果
        if (pixelSize > 0.0) {
          vec2 pixelCoord = uv * resolution;
          float noiseValue = pixelNoise(pixelCoord, pixelSize);
          float noiseInfluence = (noiseValue - 0.5) * 0.3;
          dissolvePosition += noiseInfluence;
          return uv.x > dissolvePosition ? 0.0 : 1.0;
        } else {
          // 平滑溶解：根据fadeEdge决定是否使用渐变
          if (u_fadeEdge) {
            // 柔和边缘：返回渐变值
            float fadeWidth = 0.08; // 渐变宽度
            return smoothstep(dissolvePosition - fadeWidth, dissolvePosition, uv.x);
          } else {
            // 硬边缘：返回0或1
            return uv.x > dissolvePosition ? 0.0 : 1.0;
          }
        }
      }

      // 从上到下溶解函数
      float topToBottomDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {
        // 上到下溶解：从y=0开始向y=1溶解
        float dissolvePosition = time * 1.2; // 增加系数确保完全溶解

        // 当pixelSize > 0时添加颗粒效果
        if (pixelSize > 0.0) {
          vec2 pixelCoord = uv * resolution;
          float noiseValue = pixelNoise(pixelCoord, pixelSize);
          float noiseInfluence = (noiseValue - 0.5) * 0.3;
          dissolvePosition += noiseInfluence;
          return uv.y < dissolvePosition ? 0.0 : 1.0;
        } else {
          // 平滑溶解：根据fadeEdge决定是否使用渐变
          if (u_fadeEdge) {
            // 柔和边缘：返回渐变值
            float fadeWidth = 0.08; // 渐变宽度
            return smoothstep(dissolvePosition, dissolvePosition + fadeWidth, uv.y);
          } else {
            // 硬边缘：返回0或1
            return uv.y < dissolvePosition ? 0.0 : 1.0;
          }
        }
      }

      // 从下到上溶解函数
      float bottomToTopDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {
        // 下到上溶解：从y=1开始向y=0溶解
        float dissolvePosition = 1.0 - time * 1.2; // 增加系数确保完全溶解

        // 当pixelSize > 0时添加颗粒效果
        if (pixelSize > 0.0) {
          vec2 pixelCoord = uv * resolution;
          float noiseValue = pixelNoise(pixelCoord, pixelSize);
          float noiseInfluence = (noiseValue - 0.5) * 0.3;
          dissolvePosition += noiseInfluence;
          return uv.y > dissolvePosition ? 0.0 : 1.0;
        } else {
          // 平滑溶解：根据fadeEdge决定是否使用渐变
          if (u_fadeEdge) {
            // 柔和边缘：返回渐变值
            float fadeWidth = 0.08; // 渐变宽度
            return smoothstep(dissolvePosition - fadeWidth, dissolvePosition, uv.y);
          } else {
            // 硬边缘：返回0或1
            return uv.y > dissolvePosition ? 0.0 : 1.0;
          }
        }
      }

      void main() {
        vec2 uv = v_texCoord;
        vec4 texColor = texture2D(u_texture, uv);

        float alpha = 1.0;

        // 根据溶解类型选择对应的溶解函数
        if (u_dissolveType == 0) {
          alpha = outwardDissolve(uv, u_time, u_noiseScale, u_resolution);
        } else if (u_dissolveType == 1) {
          alpha = inwardDissolve(uv, u_time, u_noiseScale, u_resolution);
        } else if (u_dissolveType == 2) {
          alpha = radialDissolve(uv, u_time, u_noiseScale, u_resolution);
        } else if (u_dissolveType == 3) {
          alpha = leftToRightDissolve(uv, u_time, u_noiseScale, u_resolution);
        } else if (u_dissolveType == 4) {
          alpha = rightToLeftDissolve(uv, u_time, u_noiseScale, u_resolution);
        } else if (u_dissolveType == 5) {
          alpha = topToBottomDissolve(uv, u_time, u_noiseScale, u_resolution);
        } else if (u_dissolveType == 6) {
          alpha = bottomToTopDissolve(uv, u_time, u_noiseScale, u_resolution);
        }

        gl_FragColor = vec4(texColor.rgb, texColor.a * alpha);
      }
    `;
        return { vertex: vertexShader, fragment: fragmentShader };
    }
    applyWebGLEffect(canvas) {
        if (!this.gl || !this.program || !this.webglCanvas) {
            return canvas;
        }
        this.setupWebGLState(canvas);
        const texture = this.createTextureFromCanvas(canvas);
        if (!texture) {
            return canvas;
        }
        if (!this.noiseData) {
            this.noiseData = ImageProcessUtils.generateNoiseTexture(256, 256);
        }
        const noiseTexture = this.gl.createTexture();
        this.gl.activeTexture(this.gl.TEXTURE1);
        this.gl.bindTexture(this.gl.TEXTURE_2D, noiseTexture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, 256, 256, 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, this.noiseData);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        const vertexBuffer = this.createFullScreenQuad();
        if (!vertexBuffer) {
            return canvas;
        }
        this.gl.useProgram(this.program);
        this.setupVertexAttributes();
        this.setUniforms();
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
        this.gl.deleteTexture(texture);
        this.gl.deleteTexture(noiseTexture);
        this.gl.deleteBuffer(vertexBuffer);
        return this.webglCanvas;
    }
    setUniforms() {
        if (!this.gl || !this.program || !this.webglCanvas) {
            return;
        }
        const textureLocation = this.gl.getUniformLocation(this.program, 'u_texture');
        const noiseTextureLocation = this.gl.getUniformLocation(this.program, 'u_noiseTexture');
        const timeLocation = this.gl.getUniformLocation(this.program, 'u_time');
        const dissolveTypeLocation = this.gl.getUniformLocation(this.program, 'u_dissolveType');
        const resolutionLocation = this.gl.getUniformLocation(this.program, 'u_resolution');
        const noiseScaleLocation = this.gl.getUniformLocation(this.program, 'u_noiseScale');
        const fadeEdgeLocation = this.gl.getUniformLocation(this.program, 'u_fadeEdge');
        this.gl.uniform1i(textureLocation, 0);
        this.gl.uniform1i(noiseTextureLocation, 1);
        this.gl.uniform1f(timeLocation, this.currentAnimationRatio);
        this.gl.uniform2f(resolutionLocation, this.webglCanvas.width, this.webglCanvas.height);
        this.gl.uniform1f(noiseScaleLocation, this.dissolveConfig.noiseScale);
        this.gl.uniform1i(fadeEdgeLocation, this.dissolveConfig.fadeEdge ? 1 : 0);
        const dissolveTypeMap = {
            outward: 0,
            inward: 1,
            radial: 2,
            leftToRight: 3,
            rightToLeft: 4,
            topToBottom: 5,
            bottomToTop: 6
        };
        this.gl.uniform1i(dissolveTypeLocation, dissolveTypeMap[this.dissolveConfig.dissolveType] || 0);
    }
    applyCanvas2DEffect(canvas) {
        const outputCanvas = this.createOutputCanvas(canvas);
        if (!outputCanvas) {
            return canvas;
        }
        const { canvas: outputCanvasElement, ctx } = outputCanvas;
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const progress = this.currentAnimationRatio;
        let dissolvedImageData;
        switch (this.dissolveConfig.dissolveType) {
            case 'outward':
                dissolvedImageData = this.applyOutwardDissolve(imageData, progress);
                break;
            case 'inward':
                dissolvedImageData = this.applyInwardDissolve(imageData, progress);
                break;
            case 'radial':
                dissolvedImageData = this.applyRadialDissolve(imageData, progress);
                break;
            case 'leftToRight':
                dissolvedImageData = this.applyLeftToRightDissolve(imageData, progress);
                break;
            case 'rightToLeft':
                dissolvedImageData = this.applyRightToLeftDissolve(imageData, progress);
                break;
            case 'topToBottom':
                dissolvedImageData = this.applyTopToBottomDissolve(imageData, progress);
                break;
            case 'bottomToTop':
                dissolvedImageData = this.applyBottomToTopDissolve(imageData, progress);
                break;
            default:
                dissolvedImageData = imageData;
        }
        ctx.putImageData(dissolvedImageData, 0, 0);
        return outputCanvasElement;
    }
    applyOutwardDissolve(imageData, progress) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data.length);
        result.set(data);
        const centerX = width / 2;
        const centerY = height / 2;
        const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
        const pixelSize = this.dissolveConfig.noiseScale;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const dx = x - centerX;
                const dy = y - centerY;
                const distFromCenter = Math.sqrt(dx * dx + dy * dy);
                const normalizedDist = distFromCenter / maxDist;
                let dissolveThreshold = 1.2 - progress * 1.4;
                let alpha = 1.0;
                if (pixelSize > 0) {
                    const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);
                    const noiseInfluence = (noiseValue - 0.5) * 0.4;
                    dissolveThreshold += noiseInfluence;
                    alpha = normalizedDist > dissolveThreshold ? 0.0 : 1.0;
                }
                else {
                    if (this.dissolveConfig.fadeEdge) {
                        const fadeWidth = 0.15;
                        const fadeStart = dissolveThreshold - fadeWidth;
                        const fadeEnd = dissolveThreshold;
                        if (normalizedDist < fadeStart) {
                            alpha = 1.0;
                        }
                        else if (normalizedDist > fadeEnd) {
                            alpha = 0.0;
                        }
                        else {
                            alpha = 1.0 - (normalizedDist - fadeStart) / (fadeEnd - fadeStart);
                        }
                    }
                    else {
                        alpha = normalizedDist > dissolveThreshold ? 0.0 : 1.0;
                    }
                }
                const index = (y * width + x) * 4;
                result[index + 3] = Math.floor(result[index + 3] * alpha);
            }
        }
        return new ImageData(result, width, height);
    }
    applyInwardDissolve(imageData, progress) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data.length);
        result.set(data);
        const centerX = width / 2;
        const centerY = height / 2;
        const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
        const pixelSize = this.dissolveConfig.noiseScale;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const dx = x - centerX;
                const dy = y - centerY;
                const distFromCenter = Math.sqrt(dx * dx + dy * dy);
                const normalizedDist = distFromCenter / maxDist;
                let dissolveThreshold = progress * 1.4;
                let alpha = 1.0;
                if (pixelSize > 0) {
                    const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);
                    const noiseInfluence = (noiseValue - 0.5) * 0.4;
                    dissolveThreshold += noiseInfluence;
                    alpha = normalizedDist < dissolveThreshold ? 0.0 : 1.0;
                }
                else {
                    if (this.dissolveConfig.fadeEdge) {
                        const fadeWidth = 0.15;
                        const fadeStart = dissolveThreshold;
                        const fadeEnd = dissolveThreshold + fadeWidth;
                        if (normalizedDist < fadeStart) {
                            alpha = 0.0;
                        }
                        else if (normalizedDist > fadeEnd) {
                            alpha = 1.0;
                        }
                        else {
                            alpha = (normalizedDist - fadeStart) / (fadeEnd - fadeStart);
                        }
                    }
                    else {
                        alpha = normalizedDist < dissolveThreshold ? 0.0 : 1.0;
                    }
                }
                const index = (y * width + x) * 4;
                result[index + 3] = Math.floor(result[index + 3] * alpha);
            }
        }
        return new ImageData(result, width, height);
    }
    applyRadialDissolve(imageData, progress) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data.length);
        result.set(data);
        const centerX = width / 2;
        const centerY = height / 2;
        const pixelSize = this.dissolveConfig.noiseScale;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const dx = x - centerX;
                const dy = y - centerY;
                const angle = Math.atan2(dy, dx);
                const normalizedAngle = (angle + Math.PI) / (2 * Math.PI);
                let dissolveThreshold = progress * 1.2;
                let alpha = 1.0;
                if (pixelSize > 0) {
                    const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);
                    const noiseInfluence = (noiseValue - 0.5) * 0.3;
                    dissolveThreshold += noiseInfluence;
                    alpha = normalizedAngle < dissolveThreshold ? 0.0 : 1.0;
                }
                else {
                    if (this.dissolveConfig.fadeEdge) {
                        const fadeWidth = 0.08;
                        const fadeStart = dissolveThreshold;
                        const fadeEnd = dissolveThreshold + fadeWidth;
                        if (normalizedAngle < fadeStart) {
                            alpha = 0.0;
                        }
                        else if (normalizedAngle > fadeEnd) {
                            alpha = 1.0;
                        }
                        else {
                            alpha = (normalizedAngle - fadeStart) / (fadeEnd - fadeStart);
                        }
                    }
                    else {
                        alpha = normalizedAngle < dissolveThreshold ? 0.0 : 1.0;
                    }
                }
                const index = (y * width + x) * 4;
                result[index + 3] = Math.floor(result[index + 3] * alpha);
            }
        }
        return new ImageData(result, width, height);
    }
    applyLeftToRightDissolve(imageData, progress) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data.length);
        result.set(data);
        const pixelSize = this.dissolveConfig.noiseScale;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const normalizedX = x / width;
                let dissolveThreshold = progress * 1.2;
                let alpha = 1.0;
                if (pixelSize > 0) {
                    const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);
                    const noiseInfluence = (noiseValue - 0.5) * 0.3;
                    dissolveThreshold += noiseInfluence;
                    alpha = normalizedX < dissolveThreshold ? 0.0 : 1.0;
                }
                else {
                    if (this.dissolveConfig.fadeEdge) {
                        const fadeWidth = 0.08;
                        const fadeStart = dissolveThreshold;
                        const fadeEnd = dissolveThreshold + fadeWidth;
                        if (normalizedX < fadeStart) {
                            alpha = 0.0;
                        }
                        else if (normalizedX > fadeEnd) {
                            alpha = 1.0;
                        }
                        else {
                            alpha = (normalizedX - fadeStart) / (fadeEnd - fadeStart);
                        }
                    }
                    else {
                        alpha = normalizedX < dissolveThreshold ? 0.0 : 1.0;
                    }
                }
                const index = (y * width + x) * 4;
                result[index + 3] = Math.floor(result[index + 3] * alpha);
            }
        }
        return new ImageData(result, width, height);
    }
    applyRightToLeftDissolve(imageData, progress) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data.length);
        result.set(data);
        const pixelSize = this.dissolveConfig.noiseScale;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const normalizedX = x / width;
                let dissolveThreshold = 1.0 - progress * 1.2;
                let alpha = 1.0;
                if (pixelSize > 0) {
                    const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);
                    const noiseInfluence = (noiseValue - 0.5) * 0.3;
                    dissolveThreshold += noiseInfluence;
                    alpha = normalizedX > dissolveThreshold ? 0.0 : 1.0;
                }
                else {
                    if (this.dissolveConfig.fadeEdge) {
                        const fadeWidth = 0.08;
                        const fadeStart = dissolveThreshold - fadeWidth;
                        const fadeEnd = dissolveThreshold;
                        if (normalizedX < fadeStart) {
                            alpha = 1.0;
                        }
                        else if (normalizedX > fadeEnd) {
                            alpha = 0.0;
                        }
                        else {
                            alpha = 1.0 - (normalizedX - fadeStart) / (fadeEnd - fadeStart);
                        }
                    }
                    else {
                        alpha = normalizedX > dissolveThreshold ? 0.0 : 1.0;
                    }
                }
                const index = (y * width + x) * 4;
                result[index + 3] = Math.floor(result[index + 3] * alpha);
            }
        }
        return new ImageData(result, width, height);
    }
    applyTopToBottomDissolve(imageData, progress) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data.length);
        result.set(data);
        const pixelSize = this.dissolveConfig.noiseScale;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const normalizedY = y / height;
                let dissolveThreshold = progress * 1.2;
                let alpha = 1.0;
                if (pixelSize > 0) {
                    const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);
                    const noiseInfluence = (noiseValue - 0.5) * 0.3;
                    dissolveThreshold += noiseInfluence;
                    alpha = normalizedY < dissolveThreshold ? 0.0 : 1.0;
                }
                else {
                    if (this.dissolveConfig.fadeEdge) {
                        const fadeWidth = 0.08;
                        const fadeStart = dissolveThreshold;
                        const fadeEnd = dissolveThreshold + fadeWidth;
                        if (normalizedY < fadeStart) {
                            alpha = 0.0;
                        }
                        else if (normalizedY > fadeEnd) {
                            alpha = 1.0;
                        }
                        else {
                            alpha = (normalizedY - fadeStart) / (fadeEnd - fadeStart);
                        }
                    }
                    else {
                        alpha = normalizedY < dissolveThreshold ? 0.0 : 1.0;
                    }
                }
                const index = (y * width + x) * 4;
                result[index + 3] = Math.floor(result[index + 3] * alpha);
            }
        }
        return new ImageData(result, width, height);
    }
    applyBottomToTopDissolve(imageData, progress) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data.length);
        result.set(data);
        const pixelSize = this.dissolveConfig.noiseScale;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const normalizedY = y / height;
                let dissolveThreshold = 1.0 - progress * 1.2;
                let alpha = 1.0;
                if (pixelSize > 0) {
                    const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);
                    const noiseInfluence = (noiseValue - 0.5) * 0.3;
                    dissolveThreshold += noiseInfluence;
                    alpha = normalizedY > dissolveThreshold ? 0.0 : 1.0;
                }
                else {
                    if (this.dissolveConfig.fadeEdge) {
                        const fadeWidth = 0.08;
                        const fadeStart = dissolveThreshold - fadeWidth;
                        const fadeEnd = dissolveThreshold;
                        if (normalizedY < fadeStart) {
                            alpha = 1.0;
                        }
                        else if (normalizedY > fadeEnd) {
                            alpha = 0.0;
                        }
                        else {
                            alpha = 1.0 - (normalizedY - fadeStart) / (fadeEnd - fadeStart);
                        }
                    }
                    else {
                        alpha = normalizedY > dissolveThreshold ? 0.0 : 1.0;
                    }
                }
                const index = (y * width + x) * 4;
                result[index + 3] = Math.floor(result[index + 3] * alpha);
            }
        }
        return new ImageData(result, width, height);
    }
}

class Grayscale extends HybridEffectBase {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c;
        super(from, to, duration, easing, params);
        const rawStrength = ((_a = params === null || params === void 0 ? void 0 : params.options) === null || _a === void 0 ? void 0 : _a.strength) !== undefined ? params.options.strength : 1.0;
        const clampedStrength = Math.max(0, Math.min(1, rawStrength));
        this.colorConfig = {
            effectType: ((_b = params === null || params === void 0 ? void 0 : params.options) === null || _b === void 0 ? void 0 : _b.effectType) || 'grayscale',
            strength: clampedStrength,
            useWebGL: ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.useWebGL) !== undefined ? params.options.useWebGL : true
        };
    }
    getShaderSources() {
        const vertexShader = ShaderLibrary.STANDARD_VERTEX_SHADER;
        const fragmentShader = `
      precision mediump float;
      uniform sampler2D u_texture;
      uniform float u_time;
      uniform float u_strength;
      uniform int u_effectType;
      uniform vec2 u_resolution;
      varying vec2 v_texCoord;

      ${ShaderLibrary.SHADER_FUNCTIONS}

      void main() {
        vec2 uv = v_texCoord;
        vec4 originalColor = texture2D(u_texture, uv);
        vec3 color = originalColor.rgb;

        // 计算动态强度
        float dynamicStrength = calculateDynamicStrength(u_strength, u_time);

        if (u_effectType == 0) {
          // 灰度效果
          float gray = luminance(color);
          vec3 grayColor = vec3(gray);
          color = mix(color, grayColor, dynamicStrength);
        } else if (u_effectType == 1) {
          // 褐色调效果
          vec3 sepiaColor = sepia(color);
          color = mix(color, sepiaColor, dynamicStrength);
        }

        gl_FragColor = vec4(color, originalColor.a);
      }
    `;
        return { vertex: vertexShader, fragment: fragmentShader };
    }
    applyWebGLEffect(canvas) {
        if (!this.gl || !this.program || !this.webglCanvas) {
            return null;
        }
        this.setupWebGLState(canvas);
        const texture = this.createTextureFromCanvas(canvas);
        if (!texture) {
            return null;
        }
        const vertexBuffer = this.createFullScreenQuad();
        if (!vertexBuffer) {
            this.gl.deleteTexture(texture);
            return null;
        }
        try {
            this.gl.useProgram(this.program);
            this.setupVertexAttributes();
            this.setColorUniforms();
            this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            return this.webglCanvas;
        }
        finally {
            this.gl.deleteTexture(texture);
            this.gl.deleteBuffer(vertexBuffer);
        }
    }
    setColorUniforms() {
        if (!this.gl || !this.program) {
            return;
        }
        const currentTime = this.getAnimationTime();
        const timeLocation = this.gl.getUniformLocation(this.program, 'u_time');
        const strengthLocation = this.gl.getUniformLocation(this.program, 'u_strength');
        const effectTypeLocation = this.gl.getUniformLocation(this.program, 'u_effectType');
        const resolutionLocation = this.gl.getUniformLocation(this.program, 'u_resolution');
        this.gl.uniform1f(timeLocation, currentTime);
        this.gl.uniform1f(strengthLocation, this.colorConfig.strength);
        this.gl.uniform2f(resolutionLocation, this.webglCanvas.width, this.webglCanvas.height);
        const effectTypeMap = {
            grayscale: 0,
            sepia: 1
        };
        this.gl.uniform1i(effectTypeLocation, effectTypeMap[this.colorConfig.effectType] || 0);
    }
    applyCanvas2DEffect(canvas) {
        if (this.colorConfig.strength <= 0) {
            const outputCanvas = this.createOutputCanvas(canvas);
            return outputCanvas ? outputCanvas.canvas : null;
        }
        if (this.canUseCSSFilter()) {
            return this.applyCSSFilter(canvas);
        }
        const outputCanvas = this.createOutputCanvas(canvas);
        if (!outputCanvas) {
            return null;
        }
        const { ctx } = outputCanvas;
        try {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const currentTime = this.getAnimationTime();
            let processedImageData;
            switch (this.colorConfig.effectType) {
                case 'grayscale':
                    processedImageData = this.applyGrayscaleEffect(imageData, this.colorConfig.strength, currentTime);
                    break;
                case 'sepia':
                    processedImageData = this.applySepiaEffect(imageData, this.colorConfig.strength, currentTime);
                    break;
                default:
                    processedImageData = this.applyGrayscaleEffect(imageData, this.colorConfig.strength, currentTime);
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.putImageData(processedImageData, 0, 0);
            return outputCanvas.canvas;
        }
        catch (error) {
            console.warn('Canvas 2D color effect failed:', error);
            return null;
        }
    }
    canUseCSSFilter() {
        var _a;
        return !!window.useFilterAPI && typeof CSS !== 'undefined' && ((_a = CSS.supports) === null || _a === void 0 ? void 0 : _a.call(CSS, 'filter', 'grayscale(1)'));
    }
    applyCSSFilter(canvas) {
        try {
            const outputCanvas = ImageProcessUtils.createTempCanvas(canvas.width, canvas.height);
            const ctx = outputCanvas.getContext('2d');
            if (!ctx) {
                return null;
            }
            const currentTime = this.getAnimationTime();
            const dynamicStrength = ImageProcessUtils.calculateDynamicStrength(this.colorConfig.strength, currentTime);
            let filterValue = '';
            if (this.colorConfig.effectType === 'grayscale') {
                filterValue = `grayscale(${Math.min(1, dynamicStrength)})`;
            }
            else if (this.colorConfig.effectType === 'sepia') {
                filterValue = `sepia(${Math.min(1, dynamicStrength)})`;
            }
            ctx.filter = filterValue;
            ctx.drawImage(canvas, 0, 0);
            ctx.filter = 'none';
            return outputCanvas;
        }
        catch (error) {
            console.warn('CSS Filter API failed, falling back to pixel processing:', error);
            return null;
        }
    }
    applyGrayscaleEffect(imageData, strength, time) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data.length);
        const dynamicStrength = ImageProcessUtils.calculateDynamicStrength(strength, time);
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];
            const gray = ImageProcessUtils.getLuminance(r, g, b);
            result[i] = Math.round(ImageProcessUtils.lerp(r, gray, dynamicStrength));
            result[i + 1] = Math.round(ImageProcessUtils.lerp(g, gray, dynamicStrength));
            result[i + 2] = Math.round(ImageProcessUtils.lerp(b, gray, dynamicStrength));
            result[i + 3] = a;
        }
        return new ImageData(result, width, height);
    }
    applySepiaEffect(imageData, strength, time) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data.length);
        const dynamicStrength = ImageProcessUtils.calculateDynamicStrength(strength, time);
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            const a = data[i + 3];
            const [sepiaR, sepiaG, sepiaB] = ImageProcessUtils.applySepiaToPixel(r, g, b);
            result[i] = Math.round(ImageProcessUtils.lerp(r, sepiaR, dynamicStrength));
            result[i + 1] = Math.round(ImageProcessUtils.lerp(g, sepiaG, dynamicStrength));
            result[i + 2] = Math.round(ImageProcessUtils.lerp(b, sepiaB, dynamicStrength));
            result[i + 3] = a;
        }
        return new ImageData(result, width, height);
    }
    afterStageRender(stage, canvas) {
        if (this.canUseCSSFilter() && this.colorConfig.strength > 0) {
            const cssResult = this.applyCSSFilter(canvas);
            if (cssResult) {
                return cssResult;
            }
        }
        return super.afterStageRender(stage, canvas);
    }
}

class Distortion extends HybridEffectBase {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c;
        super(from, to, duration, easing, params);
        this.distortionConfig = {
            distortionType: ((_a = params === null || params === void 0 ? void 0 : params.options) === null || _a === void 0 ? void 0 : _a.distortionType) || 'wave',
            strength: ((_b = params === null || params === void 0 ? void 0 : params.options) === null || _b === void 0 ? void 0 : _b.strength) || 0.3,
            useWebGL: ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.useWebGL) !== undefined ? params.options.useWebGL : true
        };
    }
    getShaderSources() {
        const vertexShader = `
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      varying vec2 v_texCoord;

      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texCoord = a_texCoord;
      }
    `;
        const fragmentShader = `
      precision mediump float;
      uniform sampler2D u_texture;
      uniform float u_time;
      uniform float u_strength;
      uniform int u_distortionType;
      uniform vec2 u_resolution;
      varying vec2 v_texCoord;

      // 波浪扭曲函数
      vec2 wave(vec2 uv, float time, float strength) {
        float waveX = sin(uv.y * 10.0 + time * 3.0) * strength * 0.1;
        float waveY = sin(uv.x * 10.0 + time * 2.0) * strength * 0.1;
        return uv + vec2(waveX, waveY);
      }

      // 涟漪扭曲函数
      vec2 ripple(vec2 uv, float time, float strength) {
        vec2 center = vec2(0.5, 0.5);
        float distance = length(uv - center);
        float ripple = sin(distance * 20.0 - time * 5.0) * strength * 0.1;
        vec2 direction = normalize(uv - center);
        return uv + direction * ripple;
      }

      // 漩涡扭曲函数
      vec2 swirl(vec2 uv, float time, float strength) {
        vec2 center = vec2(0.5, 0.5);
        vec2 delta = uv - center;
        float dist = length(delta);
        float originalAngle = atan(delta.y, delta.x);
        float rotationAngle = dist * strength * time * 2.0;
        float finalAngle = originalAngle + rotationAngle;
        return center + dist * vec2(cos(finalAngle), sin(finalAngle));
      }

      void main() {
        vec2 uv = v_texCoord;

        // 根据扭曲类型应用相应变换
        if (u_distortionType == 0) {
          uv = wave(uv, u_time, u_strength);
        } else if (u_distortionType == 1) {
          uv = ripple(uv, u_time, u_strength);
        } else if (u_distortionType == 2) {
          uv = swirl(uv, u_time, u_strength);
        }

        // 边界检查
        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        } else {
          gl_FragColor = texture2D(u_texture, uv);
        }
      }
    `;
        return { vertex: vertexShader, fragment: fragmentShader };
    }
    applyWebGLEffect(canvas) {
        if (!this.gl || !this.program || !this.webglCanvas) {
            return null;
        }
        this.setupWebGLState(canvas);
        const texture = this.createTextureFromCanvas(canvas);
        if (!texture) {
            return null;
        }
        const vertexBuffer = this.createFullScreenQuad();
        if (!vertexBuffer) {
            this.gl.deleteTexture(texture);
            return null;
        }
        try {
            this.gl.useProgram(this.program);
            this.setupVertexAttributes();
            this.setDistortionUniforms();
            this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
            return this.webglCanvas;
        }
        finally {
            this.gl.deleteTexture(texture);
            this.gl.deleteBuffer(vertexBuffer);
        }
    }
    setDistortionUniforms() {
        if (!this.gl || !this.program) {
            return;
        }
        const currentTime = this.getAnimationTime();
        const timeLocation = this.gl.getUniformLocation(this.program, 'u_time');
        const strengthLocation = this.gl.getUniformLocation(this.program, 'u_strength');
        const distortionTypeLocation = this.gl.getUniformLocation(this.program, 'u_distortionType');
        const resolutionLocation = this.gl.getUniformLocation(this.program, 'u_resolution');
        this.gl.uniform1f(timeLocation, currentTime);
        this.gl.uniform1f(strengthLocation, this.distortionConfig.strength);
        this.gl.uniform2f(resolutionLocation, this.webglCanvas.width, this.webglCanvas.height);
        const distortionTypeMap = {
            wave: 0,
            ripple: 1,
            swirl: 2
        };
        this.gl.uniform1i(distortionTypeLocation, distortionTypeMap[this.distortionConfig.distortionType] || 0);
    }
    applyCanvas2DEffect(canvas) {
        const outputCanvas = this.createOutputCanvas(canvas);
        if (!outputCanvas) {
            return null;
        }
        const { ctx } = outputCanvas;
        try {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const currentTime = this.getAnimationTime();
            let distortedImageData;
            switch (this.distortionConfig.distortionType) {
                case 'wave':
                    distortedImageData = this.applyWaveDistortion(imageData, this.distortionConfig.strength, currentTime);
                    break;
                case 'ripple':
                    distortedImageData = this.applyRippleDistortion(imageData, this.distortionConfig.strength, currentTime);
                    break;
                case 'swirl':
                    distortedImageData = this.applySwirlDistortion(imageData, this.distortionConfig.strength, currentTime);
                    break;
                default:
                    distortedImageData = imageData;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.putImageData(distortedImageData, 0, 0);
            return outputCanvas.canvas;
        }
        catch (error) {
            console.warn('Canvas 2D distortion effect failed:', error);
            return null;
        }
    }
    applyWaveDistortion(imageData, strength, time) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data.length);
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const waveX = Math.sin(y * 0.1 + time * 3) * strength * 20;
                const waveY = Math.sin(x * 0.1 + time * 2) * strength * 20;
                const sourceX = Math.round(x - waveX);
                const sourceY = Math.round(y - waveY);
                const targetIndex = (y * width + x) * 4;
                if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {
                    const sourceIndex = (sourceY * width + sourceX) * 4;
                    result[targetIndex] = data[sourceIndex];
                    result[targetIndex + 1] = data[sourceIndex + 1];
                    result[targetIndex + 2] = data[sourceIndex + 2];
                    result[targetIndex + 3] = data[sourceIndex + 3];
                }
                else {
                    result[targetIndex + 3] = 0;
                }
            }
        }
        return new ImageData(result, width, height);
    }
    applyRippleDistortion(imageData, strength, time) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data.length);
        const centerX = width / 2;
        const centerY = height / 2;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const ripple = Math.sin(distance * 0.2 - time * 5) * strength * 10;
                const angle = Math.atan2(dy, dx);
                const sourceX = Math.round(x - Math.cos(angle) * ripple);
                const sourceY = Math.round(y - Math.sin(angle) * ripple);
                const targetIndex = (y * width + x) * 4;
                if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {
                    const sourceIndex = (sourceY * width + sourceX) * 4;
                    result[targetIndex] = data[sourceIndex];
                    result[targetIndex + 1] = data[sourceIndex + 1];
                    result[targetIndex + 2] = data[sourceIndex + 2];
                    result[targetIndex + 3] = data[sourceIndex + 3];
                }
                else {
                    result[targetIndex + 3] = 0;
                }
            }
        }
        return new ImageData(result, width, height);
    }
    applySwirlDistortion(imageData, strength, time) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data.length);
        const centerX = width / 2;
        const centerY = height / 2;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const originalAngle = Math.atan2(dy, dx);
                const rotationAngle = distance * strength * time * 0.02;
                const finalAngle = originalAngle + rotationAngle;
                const sourceX = Math.round(centerX + distance * Math.cos(finalAngle));
                const sourceY = Math.round(centerY + distance * Math.sin(finalAngle));
                const targetIndex = (y * width + x) * 4;
                if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {
                    const sourceIndex = (sourceY * width + sourceX) * 4;
                    result[targetIndex] = data[sourceIndex];
                    result[targetIndex + 1] = data[sourceIndex + 1];
                    result[targetIndex + 2] = data[sourceIndex + 2];
                    result[targetIndex + 3] = data[sourceIndex + 3];
                }
                else {
                    result[targetIndex + 3] = 0;
                }
            }
        }
        return new ImageData(result, width, height);
    }
    afterStageRender(stage, canvas) {
        if (this.distortionConfig.strength <= 0) {
            return canvas;
        }
        return super.afterStageRender(stage, canvas);
    }
}

class Particle extends HybridEffectBase {
    constructor(from, to, duration, easing, params) {
        var _a, _b, _c, _d, _e;
        super(from, to, duration, easing, params);
        this.particles = [];
        this.positionBuffer = null;
        this.colorBuffer = null;
        this.particleConfig = {
            effectType: ((_a = params === null || params === void 0 ? void 0 : params.options) === null || _a === void 0 ? void 0 : _a.effectType) || 'gravity',
            count: ((_b = params === null || params === void 0 ? void 0 : params.options) === null || _b === void 0 ? void 0 : _b.count) || 4000,
            size: ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.size) || 20,
            strength: ((_d = params === null || params === void 0 ? void 0 : params.options) === null || _d === void 0 ? void 0 : _d.strength) || 1.5,
            useWebGL: ((_e = params === null || params === void 0 ? void 0 : params.options) === null || _e === void 0 ? void 0 : _e.useWebGL) !== undefined ? params.options.useWebGL : true
        };
    }
    getShaderSources() {
        const vertexShader = `
      attribute vec2 a_position;
      attribute vec4 a_color;
      attribute float a_size;

      uniform vec2 u_resolution;
      uniform float u_time;
      uniform float u_forceStrength;
      uniform int u_effectType;

      varying vec4 v_color;

      void main() {
        // 将像素坐标转换为剪辑空间坐标
        vec2 clipSpace = ((a_position / u_resolution) * 2.0) - 1.0;
        clipSpace.y = -clipSpace.y; // 翻转Y轴

        gl_Position = vec4(clipSpace, 0.0, 1.0);
        gl_PointSize = a_size;
        v_color = a_color;
      }
    `;
        const fragmentShader = `
      precision mediump float;
      varying vec4 v_color;

      void main() {
        // 创建圆形粒子
        vec2 coord = gl_PointCoord - vec2(0.5);
        float distance = length(coord);

        if (distance > 0.5) {
          discard;
        }

        // 保持原始颜色，只调整透明度渐变
        gl_FragColor = vec4(v_color.rgb, v_color.a);
      }
    `;
        return { vertex: vertexShader, fragment: fragmentShader };
    }
    applyWebGLEffect(canvas) {
        if (!this.gl || !this.program || !this.webglCanvas) {
            return null;
        }
        this.setupWebGLState(canvas);
        if (this.particles.length === 0) {
            this.extractParticles(canvas);
        }
        this.updateParticles(canvas);
        const gl = this.gl;
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.useProgram(this.program);
        this.prepareAndDrawParticles(gl);
        return this.webglCanvas;
    }
    applyCanvas2DEffect(canvas) {
        const output = this.createOutputCanvas(canvas);
        if (!output) {
            return null;
        }
        const { canvas: outputCanvas, ctx } = output;
        const progress = this.currentAnimationRatio;
        switch (this.particleConfig.effectType) {
            case 'explode':
                this.applyCanvas2DExplode(ctx, canvas, progress);
                break;
            case 'gravity':
                this.applyCanvas2DGravity(ctx, canvas, progress);
                break;
            case 'vortex':
                this.applyCanvas2DVortex(ctx, canvas, progress);
                break;
            default:
                ctx.globalAlpha = Math.max(0, 1 - progress);
                ctx.drawImage(canvas, 0, 0);
        }
        return outputCanvas;
    }
    extractParticles(canvas) {
        const tempCanvas = ImageProcessUtils.createTempCanvas(canvas.width, canvas.height, 1);
        const tempCtx = tempCanvas.getContext('2d');
        if (!tempCtx) {
            return;
        }
        tempCtx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imageData.data;
        this.particles = [];
        const step = Math.max(1, Math.floor(Math.sqrt((tempCanvas.width * tempCanvas.height) / (this.particleConfig.count * 1.5))));
        for (let y = 0; y < tempCanvas.height; y += step) {
            for (let x = 0; x < tempCanvas.width; x += step) {
                const index = (y * tempCanvas.width + x) * 4;
                const r = data[index];
                const g = data[index + 1];
                const b = data[index + 2];
                const a = data[index + 3];
                if (a > 5) {
                    const realX = (x / tempCanvas.width) * canvas.width;
                    const realY = (y / tempCanvas.height) * canvas.height;
                    const particle = {
                        x: realX,
                        y: realY,
                        originX: realX,
                        originY: realY,
                        vx: 0,
                        vy: 0,
                        r: r / 255,
                        g: g / 255,
                        b: b / 255,
                        a: Math.max(0.6, a / 255),
                        life: 1.0,
                        size: this.particleConfig.size * (1 + Math.random() * 0.5)
                    };
                    this.particles.push(particle);
                }
            }
        }
    }
    updateParticles(canvas) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const progress = this.currentAnimationRatio;
        const duration = this.getDurationFromParent();
        const isShortAnimation = duration < 2000;
        const timeMultiplier = isShortAnimation ? Math.max(1.5, 3000 / duration) : 1.0;
        const intensityBoost = isShortAnimation ? Math.min(2.0, 2000 / duration) : 1.0;
        this.particles.forEach(particle => {
            const dx = particle.x - centerX;
            const dy = particle.y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            this.applyParticleForces(particle, angle, distance, progress, intensityBoost, canvas);
            this.updateParticleProperties(particle, progress, isShortAnimation, timeMultiplier, intensityBoost);
        });
    }
    applyParticleForces(particle, angle, distance, progress, intensityBoost, canvas) {
        const time = this.getAnimationTime();
        switch (this.particleConfig.effectType) {
            case 'explode':
                const explodeIntensity = progress * this.particleConfig.strength * intensityBoost * 5;
                particle.vx += Math.cos(angle) * explodeIntensity;
                particle.vy += Math.sin(angle) * explodeIntensity;
                break;
            case 'gravity':
                this.applyGravityEffect(particle, progress, intensityBoost, canvas, time);
                break;
            case 'vortex':
                this.applyVortexEffect(particle, progress, intensityBoost, canvas, angle, distance);
                break;
        }
    }
    applyGravityEffect(particle, progress, intensityBoost, canvas, time) {
        const gravityThreshold = ((particle.originX + particle.originY * 0.7) / (canvas.width + canvas.height)) * 0.8;
        if (progress > gravityThreshold) {
            const gravityProgress = (progress - gravityThreshold) / (1 - gravityThreshold);
            const gravityForce = this.particleConfig.strength * gravityProgress * gravityProgress * 12 * intensityBoost;
            particle.vy += gravityForce;
            const turbulence = Math.sin(time * 3 + particle.originX * 0.02) * Math.cos(time * 2 + particle.originY * 0.015);
            particle.vx += turbulence * this.particleConfig.strength * 2 * intensityBoost;
        }
    }
    applyVortexEffect(particle, progress, intensityBoost, canvas, angle, distance) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const spiralAngle = angle + progress * Math.PI * 0.8;
        const targetRadius = distance + progress * Math.max(canvas.width, canvas.height) * 0.7 * 1.8;
        const targetX = centerX + Math.cos(spiralAngle) * targetRadius;
        const targetY = centerY + Math.sin(spiralAngle) * targetRadius;
        const baseForce = progress * this.particleConfig.strength * 0.08 * intensityBoost;
        particle.vx += (targetX - particle.x) * baseForce;
        particle.vy += (targetY - particle.y) * baseForce;
    }
    updateParticleProperties(particle, progress, isShortAnimation, timeMultiplier, intensityBoost) {
        const dragCoeff = isShortAnimation ? 0.99 : 0.98;
        particle.vx *= dragCoeff;
        particle.vy *= dragCoeff;
        particle.x += particle.vx;
        particle.y += particle.vy;
        if (isShortAnimation) {
            const lifeDecayRate = Math.max(0.1, 0.5 / timeMultiplier);
            particle.life = Math.max(0, 1 - progress * lifeDecayRate);
            particle.a = Math.max(0.2, particle.life * Math.min(1, particle.a * 1.2));
            particle.size = Math.max(this.particleConfig.size * 0.7, this.particleConfig.size * (0.5 + particle.life * 0.5));
        }
        else {
            particle.life = Math.max(0, 1 - progress * 0.2);
            particle.a = Math.max(0.1, particle.life * Math.min(1, particle.a * 1.5));
            particle.size = Math.max(this.particleConfig.size * 0.5, this.particleConfig.size * (0.3 + particle.life * 0.7));
        }
    }
    prepareAndDrawParticles(gl) {
        const positions = new Float32Array(this.particles.length * 2);
        const colors = new Float32Array(this.particles.length * 4);
        const sizes = new Float32Array(this.particles.length);
        this.particles.forEach((particle, i) => {
            positions[i * 2] = particle.x;
            positions[i * 2 + 1] = particle.y;
            colors[i * 4] = particle.r;
            colors[i * 4 + 1] = particle.g;
            colors[i * 4 + 2] = particle.b;
            colors[i * 4 + 3] = Math.max(0.1, particle.a);
            sizes[i] = Math.max(6, particle.size * 1.5);
        });
        this.updateParticleBuffers(gl, positions, colors, sizes);
        this.setParticleUniforms(gl);
        gl.drawArrays(gl.POINTS, 0, this.particles.length);
        this.cleanupTempBuffers(gl);
    }
    updateParticleBuffers(gl, positions, colors, sizes) {
        if (!this.positionBuffer) {
            this.positionBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);
        const positionLocation = gl.getAttribLocation(this.program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        if (!this.colorBuffer) {
            this.colorBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.DYNAMIC_DRAW);
        const colorLocation = gl.getAttribLocation(this.program, 'a_color');
        gl.enableVertexAttribArray(colorLocation);
        gl.vertexAttribPointer(colorLocation, 4, gl.FLOAT, false, 0, 0);
        const sizeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, sizes, gl.DYNAMIC_DRAW);
        const sizeLocation = gl.getAttribLocation(this.program, 'a_size');
        gl.enableVertexAttribArray(sizeLocation);
        gl.vertexAttribPointer(sizeLocation, 1, gl.FLOAT, false, 0, 0);
        this._tempSizeBuffer = sizeBuffer;
    }
    setParticleUniforms(gl) {
        const resolutionLocation = gl.getUniformLocation(this.program, 'u_resolution');
        const timeLocation = gl.getUniformLocation(this.program, 'u_time');
        const forceStrengthLocation = gl.getUniformLocation(this.program, 'u_forceStrength');
        const effectTypeLocation = gl.getUniformLocation(this.program, 'u_effectType');
        gl.uniform2f(resolutionLocation, this.webglCanvas.width, this.webglCanvas.height);
        gl.uniform1f(timeLocation, this.getAnimationTime());
        gl.uniform1f(forceStrengthLocation, this.particleConfig.strength);
        const effectTypeMap = {
            explode: 0,
            vortex: 1,
            gravity: 2
        };
        gl.uniform1i(effectTypeLocation, effectTypeMap[this.particleConfig.effectType] || 0);
    }
    cleanupTempBuffers(gl) {
        const tempSizeBuffer = this._tempSizeBuffer;
        if (tempSizeBuffer) {
            gl.deleteBuffer(tempSizeBuffer);
            delete this._tempSizeBuffer;
        }
    }
    applyCanvas2DExplode(ctx, canvas, progress) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        ctx.save();
        ctx.globalAlpha = Math.max(0, 1 - progress);
        ctx.translate(centerX, centerY);
        const scale = 1 + progress * 0.5;
        ctx.scale(scale, scale);
        ctx.translate(-centerX, -centerY);
        ctx.drawImage(canvas, 0, 0);
        ctx.restore();
    }
    applyCanvas2DGravity(ctx, canvas, progress) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, 1 - progress);
        const offsetY = progress * canvas.height * 0.3;
        ctx.drawImage(canvas, 0, offsetY);
        ctx.restore();
    }
    applyCanvas2DVortex(ctx, canvas, progress) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        ctx.save();
        ctx.globalAlpha = Math.max(0, 1 - progress);
        ctx.translate(centerX, centerY);
        ctx.rotate(progress * Math.PI * 2);
        ctx.translate(-centerX, -centerY);
        ctx.drawImage(canvas, 0, 0);
        ctx.restore();
    }
}

class Glitch extends Canvas2DEffectBase {
    constructor(from, to, duration, easing, params) {
        var _a, _b;
        super(from, to, duration, easing, params);
        this.glitchConfig = {
            effectType: ((_a = params === null || params === void 0 ? void 0 : params.options) === null || _a === void 0 ? void 0 : _a.effectType) || 'rgb-shift',
            intensity: ((_b = params === null || params === void 0 ? void 0 : params.options) === null || _b === void 0 ? void 0 : _b.intensity) !== undefined ? params.options.intensity : 0.5
        };
    }
    applyCanvas2DEffect(canvas) {
        if (this.glitchConfig.intensity <= 0) {
            const outputCanvas = this.createOutputCanvas(canvas);
            return outputCanvas ? outputCanvas.canvas : null;
        }
        try {
            switch (this.glitchConfig.effectType) {
                case 'rgb-shift':
                    return this.applyRGBShiftGlitch(canvas);
                case 'digital-distortion':
                    return this.applyDigitalDistortionGlitch(canvas);
                case 'scan-lines':
                    return this.applyScanLineGlitch(canvas);
                case 'data-corruption':
                    return this.applyDataCorruptionGlitch(canvas);
                default:
                    return this.applyRGBShiftGlitch(canvas);
            }
        }
        catch (error) {
            console.warn('Glitch effect failed:', error);
            return null;
        }
    }
    applyRGBShiftGlitch(canvas) {
        const outputCanvas = this.createOutputCanvas(canvas);
        if (!outputCanvas) {
            return null;
        }
        const { ctx } = outputCanvas;
        try {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const dynamicIntensity = ImageProcessUtils.calculateDynamicStrength(this.glitchConfig.intensity, this.getAnimationTime());
            const maxOffset = Math.floor(dynamicIntensity * 20);
            const redOffset = this.generateRandomOffset(maxOffset);
            const greenOffset = this.generateRandomOffset(maxOffset, 0.3);
            const blueOffset = this.generateRandomOffset(-maxOffset);
            const tempCanvas = ImageProcessUtils.createTempCanvas(canvas.width, canvas.height);
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0);
            const originalImageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            const redChannelData = ImageProcessUtils.extractChannel(originalImageData, 0);
            const greenChannelData = ImageProcessUtils.extractChannel(originalImageData, 1);
            const blueChannelData = ImageProcessUtils.extractChannel(originalImageData, 2);
            ctx.globalCompositeOperation = 'screen';
            tempCtx.clearRect(0, 0, canvas.width, canvas.height);
            tempCtx.putImageData(redChannelData, 0, 0);
            ctx.drawImage(tempCanvas, redOffset.x, redOffset.y);
            tempCtx.clearRect(0, 0, canvas.width, canvas.height);
            tempCtx.putImageData(greenChannelData, 0, 0);
            ctx.drawImage(tempCanvas, greenOffset.x, greenOffset.y);
            tempCtx.clearRect(0, 0, canvas.width, canvas.height);
            tempCtx.putImageData(blueChannelData, 0, 0);
            ctx.drawImage(tempCanvas, blueOffset.x, blueOffset.y);
            ctx.globalCompositeOperation = 'source-over';
            return outputCanvas.canvas;
        }
        catch (error) {
            console.warn('RGB shift glitch failed:', error);
            return null;
        }
    }
    applyDigitalDistortionGlitch(canvas) {
        const outputCanvas = this.createOutputCanvas(canvas);
        if (!outputCanvas) {
            return null;
        }
        const { ctx } = outputCanvas;
        try {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const dynamicIntensity = ImageProcessUtils.calculateDynamicStrength(this.glitchConfig.intensity, this.getAnimationTime());
            const distortedImageData = this.processDigitalDistortion(imageData, dynamicIntensity);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.putImageData(distortedImageData, 0, 0);
            return outputCanvas.canvas;
        }
        catch (error) {
            console.warn('Digital distortion glitch failed:', error);
            return null;
        }
    }
    applyScanLineGlitch(canvas) {
        const outputCanvas = this.createOutputCanvas(canvas);
        if (!outputCanvas) {
            return null;
        }
        const { ctx } = outputCanvas;
        try {
            const dynamicIntensity = ImageProcessUtils.calculateDynamicStrength(this.glitchConfig.intensity, this.getAnimationTime());
            const lineSpacing = Math.max(2, Math.floor(10 - dynamicIntensity * 8));
            ctx.globalCompositeOperation = 'multiply';
            for (let y = 0; y < canvas.height; y += lineSpacing) {
                if (Math.random() < dynamicIntensity) {
                    const opacity = 0.1 + dynamicIntensity * 0.4;
                    ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
                    ctx.fillRect(0, y, canvas.width, 1);
                }
            }
            ctx.globalCompositeOperation = 'screen';
            const brightLineCount = Math.floor(dynamicIntensity * 20);
            for (let i = 0; i < brightLineCount; i++) {
                const y = Math.random() * canvas.height;
                const opacity = dynamicIntensity * 0.3;
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.fillRect(0, Math.floor(y), canvas.width, 1);
            }
            ctx.globalCompositeOperation = 'source-over';
            return outputCanvas.canvas;
        }
        catch (error) {
            console.warn('Scan line glitch failed:', error);
            return null;
        }
    }
    applyDataCorruptionGlitch(canvas) {
        const outputCanvas = this.createOutputCanvas(canvas);
        if (!outputCanvas) {
            return null;
        }
        const { ctx } = outputCanvas;
        try {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const dynamicIntensity = ImageProcessUtils.calculateDynamicStrength(this.glitchConfig.intensity, this.getAnimationTime());
            const corruptedImageData = this.processDataCorruption(imageData, dynamicIntensity);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.putImageData(corruptedImageData, 0, 0);
            return outputCanvas.canvas;
        }
        catch (error) {
            console.warn('Data corruption glitch failed:', error);
            return null;
        }
    }
    generateRandomOffset(maxOffset, scale = 1) {
        return {
            x: (Math.random() - 0.5) * maxOffset,
            y: (Math.random() - 0.5) * maxOffset * scale
        };
    }
    processDigitalDistortion(imageData, intensity) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data);
        const sliceCount = Math.floor(intensity * 20) + 5;
        const sliceHeight = Math.floor(height / sliceCount);
        for (let i = 0; i < sliceCount; i++) {
            if (Math.random() < intensity) {
                const y = i * sliceHeight;
                const sliceEnd = Math.min(y + sliceHeight, height);
                const offset = Math.floor((Math.random() - 0.5) * width * intensity * 0.1);
                this.shiftSliceHorizontal(result, width, height, y, sliceEnd, offset);
            }
        }
        const noiseIntensity = intensity * 0.3;
        for (let i = 0; i < data.length; i += 4) {
            if (Math.random() < noiseIntensity) {
                result[i] = Math.random() * 255;
                result[i + 1] = Math.random() * 255;
                result[i + 2] = Math.random() * 255;
            }
        }
        return new ImageData(result, width, height);
    }
    shiftSliceHorizontal(data, width, height, startY, endY, offset) {
        const tempRow = new Uint8ClampedArray(width * 4);
        for (let y = startY; y < endY; y++) {
            const rowStart = y * width * 4;
            for (let x = 0; x < width * 4; x++) {
                tempRow[x] = data[rowStart + x];
            }
            for (let x = 0; x < width; x++) {
                const sourceX = (x - offset + width) % width;
                const targetIndex = rowStart + x * 4;
                const sourceIndex = sourceX * 4;
                data[targetIndex] = tempRow[sourceIndex];
                data[targetIndex + 1] = tempRow[sourceIndex + 1];
                data[targetIndex + 2] = tempRow[sourceIndex + 2];
                data[targetIndex + 3] = tempRow[sourceIndex + 3];
            }
        }
    }
    processDataCorruption(imageData, intensity) {
        const { data, width, height } = imageData;
        const result = new Uint8ClampedArray(data);
        const stripeCount = Math.floor(intensity * 15) + 5;
        for (let i = 0; i < stripeCount; i++) {
            if (Math.random() < intensity) {
                const x = Math.floor(Math.random() * width);
                const stripeWidth = Math.floor(Math.random() * 5) + 1;
                const color = Math.random() < 0.5 ? 0 : 255;
                for (let y = 0; y < height; y++) {
                    for (let dx = 0; dx < stripeWidth && x + dx < width; dx++) {
                        const index = (y * width + x + dx) * 4;
                        result[index] = color;
                        result[index + 1] = color;
                        result[index + 2] = color;
                    }
                }
            }
        }
        const corruptionCount = Math.floor(intensity * 20);
        for (let i = 0; i < corruptionCount; i++) {
            const blockX = Math.floor(Math.random() * width);
            const blockY = Math.floor(Math.random() * height);
            const blockW = Math.floor(Math.random() * 20) + 5;
            const blockH = Math.floor(Math.random() * 10) + 2;
            this.corruptBlock(result, width, height, blockX, blockY, blockW, blockH);
        }
        return new ImageData(result, width, height);
    }
    corruptBlock(data, width, height, x, y, w, h) {
        for (let dy = 0; dy < h && y + dy < height; dy++) {
            for (let dx = 0; dx < w && x + dx < width; dx++) {
                const index = ((y + dy) * width + (x + dx)) * 4;
                if (Math.random() < 0.7) {
                    data[index] = Math.random() * 255;
                    data[index + 1] = Math.random() * 255;
                    data[index + 2] = Math.random() * 255;
                }
            }
        }
    }
}

class GaussianBlur extends AStageAnimate {
    constructor(from, to, duration, easing, params) {
        var _a, _b;
        super(from, to, duration, easing, params);
        this.blurConfig = {
            blurRadius: ((_a = params === null || params === void 0 ? void 0 : params.options) === null || _a === void 0 ? void 0 : _a.blurRadius) || 8,
            useOptimizedBlur: ((_b = params === null || params === void 0 ? void 0 : params.options) === null || _b === void 0 ? void 0 : _b.useOptimizedBlur) !== undefined ? params.options.useOptimizedBlur : true
        };
    }
    applyCSSBlur(canvas, radius) {
        const c = vglobal.createCanvas({
            width: canvas.width,
            height: canvas.height,
            dpr: vglobal.devicePixelRatio
        });
        const ctx = c.getContext('2d');
        if (!ctx) {
            return canvas;
        }
        ctx.filter = `blur(${radius}px)`;
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = 'none';
        return c;
    }
    applyDownsampleBlur(imageData, radius) {
        const { width, height } = imageData;
        const downsample = Math.max(1, Math.floor(radius / 2));
        const smallWidth = Math.floor(width / downsample);
        const smallHeight = Math.floor(height / downsample);
        const tempCanvas = vglobal.createCanvas({
            width: smallWidth,
            height: smallHeight,
            dpr: 1
        });
        const tempCtx = tempCanvas.getContext('2d');
        if (!tempCtx) {
            return imageData;
        }
        const originalCanvas = vglobal.createCanvas({
            width: width,
            height: height,
            dpr: 1
        });
        const originalCtx = originalCanvas.getContext('2d');
        if (!originalCtx) {
            return imageData;
        }
        originalCtx.putImageData(imageData, 0, 0);
        tempCtx.drawImage(originalCanvas, 0, 0, smallWidth, smallHeight);
        tempCtx.filter = `blur(${radius / downsample}px)`;
        tempCtx.drawImage(tempCanvas, 0, 0);
        tempCtx.filter = 'none';
        originalCtx.clearRect(0, 0, width, height);
        originalCtx.drawImage(tempCanvas, 0, 0, width, height);
        return originalCtx.getImageData(0, 0, width, height);
    }
    afterStageRender(stage, canvas) {
        if (this.blurConfig.blurRadius <= 0) {
            return canvas;
        }
        let result;
        if (this.blurConfig.useOptimizedBlur) {
            result = this.applyCSSBlur(canvas, this.blurConfig.blurRadius);
        }
        else {
            const c = vglobal.createCanvas({
                width: canvas.width,
                height: canvas.height,
                dpr: vglobal.devicePixelRatio
            });
            const ctx = c.getContext('2d');
            if (!ctx) {
                return false;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(canvas, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const blurredImageData = this.applyDownsampleBlur(imageData, this.blurConfig.blurRadius);
            ctx.putImageData(blurredImageData, 0, 0);
            result = c;
        }
        const ctx = result.getContext('2d');
        if (ctx) {
            ctx.globalCompositeOperation = 'overlay';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, result.width, result.height);
            ctx.globalCompositeOperation = 'source-over';
        }
        return result;
    }
}

class Pixelation extends DisappearAnimateBase {
    constructor(from, to, duration, easing, params) {
        var _a, _b;
        super(from, to, duration, easing, params);
        this.pixelationConfig = {
            maxPixelSize: ((_a = params === null || params === void 0 ? void 0 : params.options) === null || _a === void 0 ? void 0 : _a.maxPixelSize) || 20,
            method: ((_b = params === null || params === void 0 ? void 0 : params.options) === null || _b === void 0 ? void 0 : _b.method) || 'out'
        };
    }
    applyDownsamplePixelation(canvas, pixelSize) {
        if (pixelSize <= 1) {
            return canvas;
        }
        const { width, height } = canvas;
        const smallWidth = Math.ceil(width / pixelSize);
        const smallHeight = Math.ceil(height / pixelSize);
        const smallCanvas = vglobal.createCanvas({
            width: smallWidth,
            height: smallHeight,
            dpr: 1
        });
        const smallCtx = smallCanvas.getContext('2d');
        if (!smallCtx) {
            return canvas;
        }
        const outputCanvas = vglobal.createCanvas({
            width: width,
            height: height,
            dpr: vglobal.devicePixelRatio
        });
        const outputCtx = outputCanvas.getContext('2d');
        if (!outputCtx) {
            return canvas;
        }
        smallCtx.imageSmoothingEnabled = false;
        outputCtx.imageSmoothingEnabled = false;
        smallCtx.drawImage(canvas, 0, 0, smallWidth, smallHeight);
        outputCtx.drawImage(smallCanvas, 0, 0, width, height);
        return outputCanvas;
    }
    updateAnimationProgress() {
        if (this.pixelationConfig.method === 'in') {
            const currentPixelSize = this.pixelationConfig.maxPixelSize - this.currentAnimationRatio * (this.pixelationConfig.maxPixelSize - 1);
            return currentPixelSize;
        }
        const currentPixelSize = 1 + this.currentAnimationRatio * (this.pixelationConfig.maxPixelSize - 1);
        return currentPixelSize;
    }
    afterStageRender(stage, canvas) {
        const currentPixelSize = this.updateAnimationProgress();
        if (currentPixelSize <= 1) {
            return canvas;
        }
        const result = this.applyDownsamplePixelation(canvas, currentPixelSize);
        return result;
    }
}

const registerCustomAnimate = () => {
    AnimateExecutor.registerBuiltInAnimate('increaseCount', IncreaseCount);
    AnimateExecutor.registerBuiltInAnimate('fromTo', FromTo);
    AnimateExecutor.registerBuiltInAnimate('scaleIn', ScaleIn);
    AnimateExecutor.registerBuiltInAnimate('scaleOut', ScaleOut);
    AnimateExecutor.registerBuiltInAnimate('growHeightIn', GrowHeightIn);
    AnimateExecutor.registerBuiltInAnimate('growHeightOut', GrowHeightOut);
    AnimateExecutor.registerBuiltInAnimate('growWidthIn', GrowWidthIn);
    AnimateExecutor.registerBuiltInAnimate('growWidthOut', GrowWidthOut);
    AnimateExecutor.registerBuiltInAnimate('growCenterIn', GrowCenterIn);
    AnimateExecutor.registerBuiltInAnimate('growCenterOut', GrowCenterOut);
    AnimateExecutor.registerBuiltInAnimate('clipIn', ClipIn);
    AnimateExecutor.registerBuiltInAnimate('clipOut', ClipOut);
    AnimateExecutor.registerBuiltInAnimate('fadeIn', FadeIn);
    AnimateExecutor.registerBuiltInAnimate('fadeOut', FadeOut);
    AnimateExecutor.registerBuiltInAnimate('growPointsIn', GrowPointsIn);
    AnimateExecutor.registerBuiltInAnimate('growPointsOut', GrowPointsOut);
    AnimateExecutor.registerBuiltInAnimate('growPointsXIn', GrowPointsXIn);
    AnimateExecutor.registerBuiltInAnimate('growPointsXOut', GrowPointsXOut);
    AnimateExecutor.registerBuiltInAnimate('growPointsYIn', GrowPointsYIn);
    AnimateExecutor.registerBuiltInAnimate('growPointsYOut', GrowPointsYOut);
    AnimateExecutor.registerBuiltInAnimate('growAngleIn', GrowAngleIn);
    AnimateExecutor.registerBuiltInAnimate('growAngleOut', GrowAngleOut);
    AnimateExecutor.registerBuiltInAnimate('growRadiusIn', GrowRadiusIn);
    AnimateExecutor.registerBuiltInAnimate('growRadiusOut', GrowRadiusOut);
    AnimateExecutor.registerBuiltInAnimate('moveIn', MoveIn);
    AnimateExecutor.registerBuiltInAnimate('moveOut', MoveOut);
    AnimateExecutor.registerBuiltInAnimate('rotateIn', RotateIn);
    AnimateExecutor.registerBuiltInAnimate('rotateOut', RotateOut);
    AnimateExecutor.registerBuiltInAnimate('update', Update);
    AnimateExecutor.registerBuiltInAnimate('state', State);
    AnimateExecutor.registerBuiltInAnimate('labelItemAppear', LabelItemAppear);
    AnimateExecutor.registerBuiltInAnimate('labelItemDisappear', LabelItemDisappear);
    AnimateExecutor.registerBuiltInAnimate('poptipAppear', PoptipAppear);
    AnimateExecutor.registerBuiltInAnimate('poptipDisappear', PoptipDisappear);
    AnimateExecutor.registerBuiltInAnimate('inputText', InputText);
    AnimateExecutor.registerBuiltInAnimate('inputRichText', InputRichText);
    AnimateExecutor.registerBuiltInAnimate('outputRichText', OutputRichText);
    AnimateExecutor.registerBuiltInAnimate('slideRichText', SlideRichText);
    AnimateExecutor.registerBuiltInAnimate('slideOutRichText', SlideOutRichText);
    AnimateExecutor.registerBuiltInAnimate('slideIn', SlideIn);
    AnimateExecutor.registerBuiltInAnimate('growIn', GrowIn);
    AnimateExecutor.registerBuiltInAnimate('spinIn', SpinIn);
    AnimateExecutor.registerBuiltInAnimate('moveScaleIn', MoveScaleIn);
    AnimateExecutor.registerBuiltInAnimate('moveRotateIn', MoveRotateIn);
    AnimateExecutor.registerBuiltInAnimate('strokeIn', StrokeIn);
    AnimateExecutor.registerBuiltInAnimate('slideOut', SlideOut);
    AnimateExecutor.registerBuiltInAnimate('growOut', GrowOut);
    AnimateExecutor.registerBuiltInAnimate('spinOut', SpinOut);
    AnimateExecutor.registerBuiltInAnimate('moveScaleOut', MoveScaleOut);
    AnimateExecutor.registerBuiltInAnimate('moveRotateOut', MoveRotateOut);
    AnimateExecutor.registerBuiltInAnimate('strokeOut', StrokeOut);
    AnimateExecutor.registerBuiltInAnimate('pulse', PulseAnimate);
    AnimateExecutor.registerBuiltInAnimate('MotionPath', MotionPath);
    AnimateExecutor.registerBuiltInAnimate('streamLight', StreamLight);
    AnimateExecutor.registerBuiltInAnimate('dissolve', Dissolve);
    AnimateExecutor.registerBuiltInAnimate('grayscale', Grayscale);
    AnimateExecutor.registerBuiltInAnimate('distortion', Distortion);
    AnimateExecutor.registerBuiltInAnimate('particle', Particle);
    AnimateExecutor.registerBuiltInAnimate('glitch', Glitch);
    AnimateExecutor.registerBuiltInAnimate('gaussianBlur', GaussianBlur);
    AnimateExecutor.registerBuiltInAnimate('pixelation', Pixelation);
};

export { AComponentAnimate, ACustomAnimate, AStageAnimate, Animate, AnimateExecutor, Step as AnimateStep, AnimationStateManager, AnimationStateStore, AnimationStates, AnimationTransitionRegistry, ClipAngleAnimate, ClipDirectionAnimate, ClipGraphicAnimate, ClipIn, ClipOut, ClipRadiusAnimate, ComponentAnimator, DefaultTicker, DefaultTimeline, Dissolve, Distortion, Easing, FadeIn, FadeOut, FromTo, GaussianBlur, Glitch, GraphicStateExtension, Grayscale, GroupFadeIn, GroupFadeOut, GrowAngleIn, GrowAngleOut, GrowCenterIn, GrowCenterOut, GrowHeightIn, GrowHeightOut, GrowIn, GrowOut, GrowPointsIn, GrowPointsOut, GrowPointsXIn, GrowPointsXOut, GrowPointsYIn, GrowPointsYOut, GrowRadiusIn, GrowRadiusOut, GrowWidthIn, GrowWidthOut, IncreaseCount, InputRichText, InputText, LabelItemAppear, LabelItemDisappear, ManualTicker, MorphingPath, MotionPath, MoveIn, MoveOut, MoveRotateIn, MoveRotateOut, MoveScaleIn, MoveScaleOut, MultiToOneMorphingPath, OutputRichText, Particle, Pixelation, PoptipAppear, PoptipDisappear, PulseAnimate, RotateBySphereAnimate, RotateIn, RotateOut, ScaleIn, ScaleOut, SlideIn, SlideOut, SlideOutRichText, SlideRichText, SpinIn, SpinOut, State, StreamLight, StrokeIn, StrokeOut, TagPointsUpdate, Update, createComponentAnimator, generatorPathEasingFunc, morphPath, multiToOneMorph, oneToMultiMorph, registerAnimate, registerCustomAnimate, transitionRegistry };
