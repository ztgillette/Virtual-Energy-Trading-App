"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createComponentAnimator = exports.ComponentAnimator = void 0;

const animate_executor_1 = require("../executor/animate-executor");

class ComponentAnimator {
    constructor(component) {
        this.tasks = [], this.started = !1, this.completed = 0, this.totalDuration = 0, 
        this.onStartCallbacks = [], this.onEndCallbacks = [], this.onUpdateCallbacks = [], 
        this.component = component;
    }
    animate(graphic, config) {
        return this.started ? (console.warn("Cannot add animations after animation has started"), 
        this) : (this.tasks.push({
            graphic: graphic,
            config: config
        }), this);
    }
    onStart(callback) {
        return this.onStartCallbacks.push(callback), this;
    }
    onEnd(callback) {
        return this.onEndCallbacks.push(callback), this;
    }
    onUpdate(callback) {
        return this.onUpdateCallbacks.push(callback), this;
    }
    start() {
        return this.started ? (console.warn("Animation has already started"), this) : (this.started = !0, 
        this.completed = 0, this.onStartCallbacks.forEach((callback => callback())), 0 === this.tasks.length ? (setTimeout((() => {
            this.onEndCallbacks.forEach((callback => callback()));
        }), 0), this) : (this.tasks.forEach((task => {
            const executor = new animate_executor_1.AnimateExecutor(task.graphic);
            executor.onEnd((() => {
                this.completed++, this.completed === this.tasks.length && this.onEndCallbacks.forEach((callback => callback()));
            }));
            const animate = executor.executeItem(task.config, task.graphic);
            task.animate = animate, animate.forEach((animate => {
                this.totalDuration = Math.max(this.totalDuration, animate.getStartTime() + animate.getDuration());
            }));
        })), this));
    }
    deleteSelfAttr(key) {
        this.tasks.forEach((task => {
            task.animate && task.animate.forEach((animate => animate.preventAttr(key)));
        }));
    }
    stop(type) {
        return this.tasks.forEach((task => {
            task.animate && task.animate.forEach((animate => animate.stop(type)));
        })), this.started && this.completed !== this.tasks.length && (this.onEndCallbacks.forEach((callback => callback())), 
        this.completed = this.tasks.length), this;
    }
    getDuration() {
        return this.totalDuration;
    }
}

function createComponentAnimator(component) {
    return new ComponentAnimator(component);
}

exports.ComponentAnimator = ComponentAnimator, exports.createComponentAnimator = createComponentAnimator;
//# sourceMappingURL=component-animator.js.map