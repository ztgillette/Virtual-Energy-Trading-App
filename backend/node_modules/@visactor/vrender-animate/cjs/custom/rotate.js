"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.RotateOut = exports.RotateIn = exports.RotateBase = exports.rotateOut = exports.rotateIn = void 0;

const vutils_1 = require("@visactor/vutils"), custom_animate_1 = require("./custom-animate"), rotateIn = (graphic, options) => {
    var _a;
    const attributeAngle = null !== (_a = graphic.getFinalAttribute().angle) && void 0 !== _a ? _a : 0;
    let angle = 0;
    return angle = (0, vutils_1.isNumberClose)(attributeAngle / (2 * Math.PI), 0) ? Math.round(attributeAngle / (2 * Math.PI)) * Math.PI * 2 : (0, 
    vutils_1.isValidNumber)(null == options ? void 0 : options.angle) ? options.angle : "anticlockwise" === (null == options ? void 0 : options.orient) ? Math.ceil(attributeAngle / (2 * Math.PI)) * Math.PI * 2 : Math.floor(attributeAngle / (2 * Math.PI)) * Math.PI * 2, 
    {
        from: {
            angle: angle
        },
        to: {
            angle: attributeAngle
        }
    };
};

exports.rotateIn = rotateIn;

const rotateOut = (graphic, options) => {
    var _a;
    const finalAngle = null !== (_a = graphic.getFinalAttribute().angle) && void 0 !== _a ? _a : 0;
    let angle = 0;
    return angle = (0, vutils_1.isNumberClose)(finalAngle / (2 * Math.PI), 0) ? Math.round(finalAngle / (2 * Math.PI)) * Math.PI * 2 : (0, 
    vutils_1.isValidNumber)(null == options ? void 0 : options.angle) ? options.angle : "anticlockwise" === (null == options ? void 0 : options.orient) ? Math.ceil(finalAngle / (2 * Math.PI)) * Math.PI * 2 : Math.floor(finalAngle / (2 * Math.PI)) * Math.PI * 2, 
    {
        from: {
            angle: finalAngle
        },
        to: {
            angle: angle
        }
    };
};

exports.rotateOut = rotateOut;

class RotateBase extends custom_animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach((key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        })), this.target.addUpdatePositionTag(), this.target.addUpdateShapeAndBoundsTag();
    }
}

exports.RotateBase = RotateBase;

class RotateIn extends RotateBase {
    onBind() {
        var _a;
        super.onBind();
        const {from: from, to: to} = (0, exports.rotateIn)(this.target, this.params.options);
        this.props = to, this.propKeys = [ "angle" ], this.from = from, this.to = to;
        const finalAttribute = this.target.getFinalAttribute();
        finalAttribute && this.target.setAttributes(finalAttribute), !1 !== (null === (_a = this.params.controlOptions) || void 0 === _a ? void 0 : _a.immediatelyApply) && this.target.setAttributes(from);
    }
}

exports.RotateIn = RotateIn;

class RotateOut extends RotateBase {
    onBind() {
        super.onBind();
        const {from: from, to: to} = (0, exports.rotateOut)(this.target, this.params.options);
        this.props = to, this.propKeys = [ "angle" ], this.from = from, this.to = to;
    }
}

exports.RotateOut = RotateOut;
//# sourceMappingURL=rotate.js.map