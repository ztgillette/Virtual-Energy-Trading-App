"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.TagPointsUpdate = void 0;

const vutils_1 = require("@visactor/vutils"), vrender_core_1 = require("@visactor/vrender-core"), custom_animate_1 = require("./custom-animate");

class TagPointsUpdate extends custom_animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        var _a, _b;
        super(from, to, duration, easing, params), this.newPointAnimateType = null !== (_a = null == params ? void 0 : params.newPointAnimateType) && void 0 !== _a ? _a : "grow", 
        this.clipRangeByDimension = null !== (_b = null == params ? void 0 : params.clipRangeByDimension) && void 0 !== _b ? _b : "x";
    }
    getPoints(attribute, cache = !1) {
        if (attribute.points) return attribute.points;
        if (attribute.segments) {
            const points = [];
            return this.segmentsCache || (this.segmentsCache = []), attribute.segments.map((segment => {
                var _a, _b;
                segment.points && points.push(...segment.points), cache && this.segmentsCache.push(null !== (_b = null === (_a = segment.points) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0);
            })), points;
        }
        return [];
    }
    onBind() {
        super.onBind();
        const {points: points, segments: segments} = this.target.attribute, {points: pointsTo, segments: segmentsTo} = this.target.getFinalAttribute();
        this.from = {
            points: points,
            segments: segments
        }, this.to = {
            points: pointsTo,
            segments: segmentsTo
        }, this.props = this.to;
        const originFromPoints = this.getPoints(this.from), originToPoints = this.getPoints(this.to, !0);
        this.fromPoints = originFromPoints ? Array.isArray(originFromPoints) ? originFromPoints : [ originFromPoints ] : [], 
        this.toPoints = originToPoints ? Array.isArray(originToPoints) ? originToPoints : [ originToPoints ] : [];
        const tagMap = new Map;
        this.fromPoints.forEach((point => {
            point.context && tagMap.set(point.context, point);
        }));
        let firstMatchedPoint, lastMatchedPoint, firstMatchedIndex = 1 / 0, lastMatchedIndex = -1 / 0;
        for (let i = 0; i < this.toPoints.length; i += 1) if (tagMap.has(this.toPoints[i].context)) {
            firstMatchedIndex = i, firstMatchedPoint = tagMap.get(this.toPoints[i].context);
            break;
        }
        for (let i = this.toPoints.length - 1; i >= 0; i -= 1) if (tagMap.has(this.toPoints[i].context)) {
            lastMatchedIndex = i, lastMatchedPoint = tagMap.get(this.toPoints[i].context);
            break;
        }
        "clip" === this.newPointAnimateType && 0 !== this.toPoints.length && (Number.isFinite(lastMatchedIndex) ? (this.clipRange = this.toPoints[lastMatchedIndex][this.clipRangeByDimension] / this.toPoints[this.toPoints.length - 1][this.clipRangeByDimension], 
        1 === this.clipRange && (this.shrinkClipRange = this.toPoints[lastMatchedIndex][this.clipRangeByDimension] / this.fromPoints[this.fromPoints.length - 1][this.clipRangeByDimension]), 
        (0, vutils_1.isValidNumber)(this.clipRange) ? this.clipRange = (0, vutils_1.clamp)(this.clipRange, 0, 1) : this.clipRange = 0) : this.clipRange = 0);
        let prevMatchedPoint = this.toPoints[0];
        this.interpolatePoints = this.toPoints.map(((point, index) => {
            const matchedPoint = tagMap.get(point.context);
            return matchedPoint ? (prevMatchedPoint = matchedPoint, [ matchedPoint, point ]) : "appear" === this.newPointAnimateType || "clip" === this.newPointAnimateType ? [ point, point ] : index < firstMatchedIndex && firstMatchedPoint ? [ firstMatchedPoint, point ] : index > lastMatchedIndex && lastMatchedPoint ? [ lastMatchedPoint, point ] : [ prevMatchedPoint, point ];
        })), this.points = this.interpolatePoints.map((interpolate => {
            const fromPoint = interpolate[0], toPoint = interpolate[1], newPoint = new vutils_1.Point(fromPoint.x, fromPoint.y, fromPoint.x1, fromPoint.y1);
            return newPoint.defined = toPoint.defined, newPoint.context = toPoint.context, newPoint;
        }));
    }
    onFirstRun() {
        const lastClipRange = this.target.attribute.clipRange;
        (0, vutils_1.isValidNumber)(lastClipRange * this.clipRange) && (this.clipRange *= lastClipRange);
    }
    onUpdate(end, ratio, out) {
        if (end) return Object.keys(this.to).forEach((k => {
            this.target.attribute[k] = this.to[k];
        })), this.target.addUpdatePositionTag(), void this.target.addUpdateShapeAndBoundsTag();
        if (this.points = this.points.map(((point, index) => {
            const newPoint = (0, vrender_core_1.pointInterpolation)(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);
            return newPoint.context = point.context, newPoint;
        })), this.clipRange) {
            if (this.shrinkClipRange) return void (end ? (out.points = this.toPoints, out.clipRange = 1) : (out.points = this.fromPoints, 
            out.clipRange = this.clipRange - (this.clipRange - this.shrinkClipRange) * ratio));
            this.target.setAttributes({
                clipRange: this.clipRange + (1 - this.clipRange) * ratio
            });
        }
        if (this.segmentsCache && this.to.segments) {
            let start = 0;
            const segments = this.to.segments.map(((segment, index) => {
                const end = start + this.segmentsCache[index], points = this.points.slice(start, end);
                return start = end, Object.assign(Object.assign({}, segment), {
                    points: points
                });
            }));
            this.target.attribute.segments = segments;
        } else this.target.attribute.points = this.points;
        this.target.addUpdatePositionTag(), this.target.addUpdateShapeAndBoundsTag();
    }
}

exports.TagPointsUpdate = TagPointsUpdate;
//# sourceMappingURL=tag-points.js.map