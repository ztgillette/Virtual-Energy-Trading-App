{"version":3,"sources":["../src/custom/disappear/dissolve.ts"],"names":[],"mappings":"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","file":"dissolve.js","sourcesContent":["import type { EasingType } from '@visactor/vrender-core';\nimport { HybridEffectBase } from './base/CustomEffectBase';\nimport { ImageProcessUtils, ShaderLibrary } from './base/ImageProcessUtils';\n\n// 向外溶解效果配置接口\nexport interface DissolveConfig {\n  dissolveType?: 'outward' | 'inward' | 'radial' | 'leftToRight' | 'rightToLeft' | 'topToBottom' | 'bottomToTop'; // 溶解效果类型\n  useWebGL?: boolean; // 是否使用WebGL实现\n  noiseScale?: number; // 溶解颗粒大小(像素值，0为平滑溶解，1-20为颗粒溶解)\n  fadeEdge?: boolean; // 是否启用边缘渐变\n}\n\n/**\n * 溶解效果类 - 使用HybridEffectBase重构\n * 支持多种溶解模式：向外、向内、径向、方向性溶解等\n */\nexport class Dissolve extends HybridEffectBase {\n  // 溶解配置，参数验证并设置默认值\n  private dissolveConfig: Required<DissolveConfig>;\n\n  // WebGL噪声纹理缓存\n  private noiseData: Uint8Array | null = null;\n\n  constructor(from: null, to: null, duration: number, easing: EasingType, params: any) {\n    super(from, to, duration, easing, params);\n\n    // 初始化溶解配置，使用传入的参数或默认值，并进行参数验证\n    const rawNoiseScale = params?.options?.noiseScale;\n    const clampedNoiseScale = rawNoiseScale !== undefined ? Math.max(0, Math.floor(rawNoiseScale)) : 8;\n\n    this.dissolveConfig = {\n      dissolveType: params?.options?.dissolveType || 'outward',\n      useWebGL: params?.options?.useWebGL !== undefined ? params.options.useWebGL : true,\n      noiseScale: clampedNoiseScale, // 确保是非负整数，默认8px颗粒，0为平滑\n      fadeEdge: params?.options?.fadeEdge !== undefined ? params.options.fadeEdge : true\n    };\n  }\n\n  /**\n   * WebGL着色器源码\n   */\n  protected getShaderSources(): { vertex: string; fragment: string } {\n    const vertexShader = ShaderLibrary.STANDARD_VERTEX_SHADER;\n\n    const fragmentShader = `\n      precision mediump float;\n      uniform sampler2D u_texture;\n      uniform sampler2D u_noiseTexture;\n      uniform float u_time;\n      uniform int u_dissolveType;\n      uniform vec2 u_resolution;\n      uniform float u_noiseScale;\n      uniform bool u_fadeEdge;\n      varying vec2 v_texCoord;\n\n      ${ShaderLibrary.SHADER_FUNCTIONS}\n\n      // 向外溶解函数\n      float outwardDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {\n        vec2 center = vec2(0.5, 0.5);\n        float distFromCenter = length(uv - center);\n        float maxDist = length(vec2(0.5, 0.5));\n\n        // 归一化距离 (0为中心，1为边缘)\n        float normalizedDist = distFromCenter / maxDist;\n\n        // 向外溶解：从边缘开始溶解，time控制溶解进度\n        // 增加安全边距，确保动画结束时完全溶解\n        float edgeThreshold = 1.2 - time * 1.5;\n\n        // 当pixelSize > 0时添加颗粒效果\n        if (pixelSize > 0.0) {\n          // 添加基于像素大小的噪声，让边缘呈现颗粒状\n          vec2 pixelCoord = uv * resolution; // 转换为像素坐标\n          float noiseValue = pixelNoise(pixelCoord, pixelSize);\n          float noiseInfluence = (noiseValue - 0.5) * 0.4; // 增强噪声影响\n          edgeThreshold += noiseInfluence;\n          return normalizedDist > edgeThreshold ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (u_fadeEdge) {\n            // 柔和边缘：返回渐变值\n            float fadeWidth = 0.15; // 渐变宽度\n            return 1.0 - smoothstep(edgeThreshold - fadeWidth, edgeThreshold, normalizedDist);\n          } else {\n            // 硬边缘：返回0或1\n            return normalizedDist > edgeThreshold ? 0.0 : 1.0;\n          }\n        }\n      }\n\n      // 向内溶解函数\n      float inwardDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {\n        vec2 center = vec2(0.5, 0.5);\n        float distFromCenter = length(uv - center);\n        float maxDist = length(vec2(0.5, 0.5));\n\n        float normalizedDist = distFromCenter / maxDist;\n\n        // 向内溶解：从中心开始溶解，time控制溶解进度\n        // 增加系数，确保动画结束时完全溶解\n        float centerThreshold = time * 1.4;\n\n        // 当pixelSize > 0时添加颗粒效果\n        if (pixelSize > 0.0) {\n          vec2 pixelCoord = uv * resolution;\n          float noiseValue = pixelNoise(pixelCoord, pixelSize);\n          float noiseInfluence = (noiseValue - 0.5) * 0.4;\n          centerThreshold += noiseInfluence;\n          return normalizedDist < centerThreshold ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (u_fadeEdge) {\n            // 柔和边缘：返回渐变值\n            float fadeWidth = 0.15; // 渐变宽度\n            return smoothstep(centerThreshold, centerThreshold + fadeWidth, normalizedDist);\n          } else {\n            // 硬边缘：返回0或1\n            return normalizedDist < centerThreshold ? 0.0 : 1.0;\n          }\n        }\n      }\n\n      // 径向溶解函数\n      float radialDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {\n        vec2 center = vec2(0.5, 0.5);\n        float angle = atan(uv.y - center.y, uv.x - center.x);\n        float normalizedAngle = (angle + 3.14159) / (2.0 * 3.14159);\n\n        // 径向溶解：按角度顺序溶解，time控制溶解进度\n        // 增加系数，确保动画结束时完全溶解\n        float angleThreshold = time * 1.2;\n\n        // 当pixelSize > 0时添加颗粒效果\n        if (pixelSize > 0.0) {\n          vec2 pixelCoord = uv * resolution;\n          float noiseValue = pixelNoise(pixelCoord, pixelSize);\n          float noiseInfluence = (noiseValue - 0.5) * 0.3;\n          angleThreshold += noiseInfluence;\n          return normalizedAngle < angleThreshold ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (u_fadeEdge) {\n            // 柔和边缘：返回渐变值\n            float fadeWidth = 0.08; // 渐变宽度\n            return smoothstep(angleThreshold, angleThreshold + fadeWidth, normalizedAngle);\n          } else {\n            // 硬边缘：返回0或1\n            return normalizedAngle < angleThreshold ? 0.0 : 1.0;\n          }\n        }\n      }\n\n      // 从左到右溶解函数\n      float leftToRightDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {\n        // 左到右溶解：从x=0开始向x=1溶解\n        float dissolvePosition = time * 1.2; // 增加系数确保完全溶解\n\n        // 当pixelSize > 0时添加颗粒效果\n        if (pixelSize > 0.0) {\n          vec2 pixelCoord = uv * resolution;\n          float noiseValue = pixelNoise(pixelCoord, pixelSize);\n          float noiseInfluence = (noiseValue - 0.5) * 0.3;\n          dissolvePosition += noiseInfluence;\n          return uv.x < dissolvePosition ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (u_fadeEdge) {\n            // 柔和边缘：返回渐变值\n            float fadeWidth = 0.08; // 渐变宽度\n            return smoothstep(dissolvePosition, dissolvePosition + fadeWidth, uv.x);\n          } else {\n            // 硬边缘：返回0或1\n            return uv.x < dissolvePosition ? 0.0 : 1.0;\n          }\n        }\n      }\n\n      // 从右到左溶解函数\n      float rightToLeftDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {\n        // 右到左溶解：从x=1开始向x=0溶解\n        float dissolvePosition = 1.0 - time * 1.2; // 增加系数确保完全溶解\n\n        // 当pixelSize > 0时添加颗粒效果\n        if (pixelSize > 0.0) {\n          vec2 pixelCoord = uv * resolution;\n          float noiseValue = pixelNoise(pixelCoord, pixelSize);\n          float noiseInfluence = (noiseValue - 0.5) * 0.3;\n          dissolvePosition += noiseInfluence;\n          return uv.x > dissolvePosition ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (u_fadeEdge) {\n            // 柔和边缘：返回渐变值\n            float fadeWidth = 0.08; // 渐变宽度\n            return smoothstep(dissolvePosition - fadeWidth, dissolvePosition, uv.x);\n          } else {\n            // 硬边缘：返回0或1\n            return uv.x > dissolvePosition ? 0.0 : 1.0;\n          }\n        }\n      }\n\n      // 从上到下溶解函数\n      float topToBottomDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {\n        // 上到下溶解：从y=0开始向y=1溶解\n        float dissolvePosition = time * 1.2; // 增加系数确保完全溶解\n\n        // 当pixelSize > 0时添加颗粒效果\n        if (pixelSize > 0.0) {\n          vec2 pixelCoord = uv * resolution;\n          float noiseValue = pixelNoise(pixelCoord, pixelSize);\n          float noiseInfluence = (noiseValue - 0.5) * 0.3;\n          dissolvePosition += noiseInfluence;\n          return uv.y < dissolvePosition ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (u_fadeEdge) {\n            // 柔和边缘：返回渐变值\n            float fadeWidth = 0.08; // 渐变宽度\n            return smoothstep(dissolvePosition, dissolvePosition + fadeWidth, uv.y);\n          } else {\n            // 硬边缘：返回0或1\n            return uv.y < dissolvePosition ? 0.0 : 1.0;\n          }\n        }\n      }\n\n      // 从下到上溶解函数\n      float bottomToTopDissolve(vec2 uv, float time, float pixelSize, vec2 resolution) {\n        // 下到上溶解：从y=1开始向y=0溶解\n        float dissolvePosition = 1.0 - time * 1.2; // 增加系数确保完全溶解\n\n        // 当pixelSize > 0时添加颗粒效果\n        if (pixelSize > 0.0) {\n          vec2 pixelCoord = uv * resolution;\n          float noiseValue = pixelNoise(pixelCoord, pixelSize);\n          float noiseInfluence = (noiseValue - 0.5) * 0.3;\n          dissolvePosition += noiseInfluence;\n          return uv.y > dissolvePosition ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (u_fadeEdge) {\n            // 柔和边缘：返回渐变值\n            float fadeWidth = 0.08; // 渐变宽度\n            return smoothstep(dissolvePosition - fadeWidth, dissolvePosition, uv.y);\n          } else {\n            // 硬边缘：返回0或1\n            return uv.y > dissolvePosition ? 0.0 : 1.0;\n          }\n        }\n      }\n\n      void main() {\n        vec2 uv = v_texCoord;\n        vec4 texColor = texture2D(u_texture, uv);\n\n        float alpha = 1.0;\n\n        // 根据溶解类型选择对应的溶解函数\n        if (u_dissolveType == 0) {\n          alpha = outwardDissolve(uv, u_time, u_noiseScale, u_resolution);\n        } else if (u_dissolveType == 1) {\n          alpha = inwardDissolve(uv, u_time, u_noiseScale, u_resolution);\n        } else if (u_dissolveType == 2) {\n          alpha = radialDissolve(uv, u_time, u_noiseScale, u_resolution);\n        } else if (u_dissolveType == 3) {\n          alpha = leftToRightDissolve(uv, u_time, u_noiseScale, u_resolution);\n        } else if (u_dissolveType == 4) {\n          alpha = rightToLeftDissolve(uv, u_time, u_noiseScale, u_resolution);\n        } else if (u_dissolveType == 5) {\n          alpha = topToBottomDissolve(uv, u_time, u_noiseScale, u_resolution);\n        } else if (u_dissolveType == 6) {\n          alpha = bottomToTopDissolve(uv, u_time, u_noiseScale, u_resolution);\n        }\n\n        gl_FragColor = vec4(texColor.rgb, texColor.a * alpha);\n      }\n    `;\n\n    return { vertex: vertexShader, fragment: fragmentShader };\n  }\n\n  /**\n   * WebGL溶解效果实现\n   */\n  protected applyWebGLEffect(canvas: HTMLCanvasElement): HTMLCanvasElement {\n    if (!this.gl || !this.program || !this.webglCanvas) {\n      return canvas;\n    }\n\n    // 设置WebGL状态\n    this.setupWebGLState(canvas);\n\n    // 创建主纹理\n    const texture = this.createTextureFromCanvas(canvas);\n    if (!texture) {\n      return canvas;\n    }\n\n    // 创建噪声纹理\n    if (!this.noiseData) {\n      this.noiseData = ImageProcessUtils.generateNoiseTexture(256, 256);\n    }\n    const noiseTexture = this.gl.createTexture();\n    this.gl.activeTexture(this.gl.TEXTURE1);\n    this.gl.bindTexture(this.gl.TEXTURE_2D, noiseTexture);\n    this.gl.texImage2D(\n      this.gl.TEXTURE_2D,\n      0,\n      this.gl.LUMINANCE,\n      256,\n      256,\n      0,\n      this.gl.LUMINANCE,\n      this.gl.UNSIGNED_BYTE,\n      this.noiseData\n    );\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n\n    // 创建顶点缓冲区\n    const vertexBuffer = this.createFullScreenQuad();\n    if (!vertexBuffer) {\n      return canvas;\n    }\n\n    // 使用着色器程序并设置属性\n    this.gl.useProgram(this.program);\n    this.setupVertexAttributes();\n\n    // 设置uniform变量\n    this.setUniforms();\n\n    // 启用混合以支持透明度\n    this.gl.enable(this.gl.BLEND);\n    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n\n    // 绘制\n    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n\n    // 清理资源\n    this.gl.deleteTexture(texture);\n    this.gl.deleteTexture(noiseTexture);\n    this.gl.deleteBuffer(vertexBuffer);\n\n    return this.webglCanvas;\n  }\n\n  /**\n   * 设置WebGL uniform变量\n   */\n  private setUniforms(): void {\n    if (!this.gl || !this.program || !this.webglCanvas) {\n      return;\n    }\n\n    const textureLocation = this.gl.getUniformLocation(this.program, 'u_texture');\n    const noiseTextureLocation = this.gl.getUniformLocation(this.program, 'u_noiseTexture');\n    const timeLocation = this.gl.getUniformLocation(this.program, 'u_time');\n    const dissolveTypeLocation = this.gl.getUniformLocation(this.program, 'u_dissolveType');\n    const resolutionLocation = this.gl.getUniformLocation(this.program, 'u_resolution');\n    const noiseScaleLocation = this.gl.getUniformLocation(this.program, 'u_noiseScale');\n    const fadeEdgeLocation = this.gl.getUniformLocation(this.program, 'u_fadeEdge');\n\n    this.gl.uniform1i(textureLocation, 0);\n    this.gl.uniform1i(noiseTextureLocation, 1);\n    this.gl.uniform1f(timeLocation, this.currentAnimationRatio);\n    this.gl.uniform2f(resolutionLocation, this.webglCanvas.width, this.webglCanvas.height);\n    this.gl.uniform1f(noiseScaleLocation, this.dissolveConfig.noiseScale);\n    this.gl.uniform1i(fadeEdgeLocation, this.dissolveConfig.fadeEdge ? 1 : 0);\n\n    // 设置溶解类型映射\n    const dissolveTypeMap: { [key: string]: number } = {\n      outward: 0,\n      inward: 1,\n      radial: 2,\n      leftToRight: 3,\n      rightToLeft: 4,\n      topToBottom: 5,\n      bottomToTop: 6\n    };\n    this.gl.uniform1i(dissolveTypeLocation, dissolveTypeMap[this.dissolveConfig.dissolveType] || 0);\n  }\n\n  /**\n   * Canvas 2D溶解效果实现\n   */\n  protected applyCanvas2DEffect(canvas: HTMLCanvasElement): HTMLCanvasElement {\n    const outputCanvas = this.createOutputCanvas(canvas);\n    if (!outputCanvas) {\n      return canvas;\n    }\n\n    const { canvas: outputCanvasElement, ctx } = outputCanvas;\n\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const progress = this.currentAnimationRatio;\n\n    let dissolvedImageData: ImageData;\n\n    // 根据溶解类型应用不同的溶解算法\n    switch (this.dissolveConfig.dissolveType) {\n      case 'outward':\n        dissolvedImageData = this.applyOutwardDissolve(imageData, progress);\n        break;\n      case 'inward':\n        dissolvedImageData = this.applyInwardDissolve(imageData, progress);\n        break;\n      case 'radial':\n        dissolvedImageData = this.applyRadialDissolve(imageData, progress);\n        break;\n      case 'leftToRight':\n        dissolvedImageData = this.applyLeftToRightDissolve(imageData, progress);\n        break;\n      case 'rightToLeft':\n        dissolvedImageData = this.applyRightToLeftDissolve(imageData, progress);\n        break;\n      case 'topToBottom':\n        dissolvedImageData = this.applyTopToBottomDissolve(imageData, progress);\n        break;\n      case 'bottomToTop':\n        dissolvedImageData = this.applyBottomToTopDissolve(imageData, progress);\n        break;\n      default:\n        dissolvedImageData = imageData;\n    }\n\n    ctx.putImageData(dissolvedImageData, 0, 0);\n    return outputCanvasElement;\n  }\n\n  // Canvas 2D 实现 - 向外溶解\n  private applyOutwardDissolve(imageData: ImageData, progress: number): ImageData {\n    const { data, width, height } = imageData;\n    const result = new Uint8ClampedArray(data.length);\n    result.set(data);\n\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);\n\n    // 直接使用noiseScale作为像素颗粒大小\n    const pixelSize = this.dissolveConfig.noiseScale;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const dx = x - centerX;\n        const dy = y - centerY;\n        const distFromCenter = Math.sqrt(dx * dx + dy * dy);\n        const normalizedDist = distFromCenter / maxDist;\n\n        // 向外溶解：从边缘开始，增加安全边距确保完全溶解\n        let dissolveThreshold = 1.2 - progress * 1.4;\n        let alpha = 1.0;\n\n        if (pixelSize > 0) {\n          // 颗粒效果：使用基于像素网格的噪声，产生颗粒状效果\n          const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);\n          const noiseInfluence = (noiseValue - 0.5) * 0.4; // 增强噪声影响\n          dissolveThreshold += noiseInfluence;\n\n          alpha = normalizedDist > dissolveThreshold ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (this.dissolveConfig.fadeEdge) {\n            // 柔和边缘：使用渐变值\n            const fadeWidth = 0.15; // 渐变宽度\n            const fadeStart = dissolveThreshold - fadeWidth;\n            const fadeEnd = dissolveThreshold;\n\n            if (normalizedDist < fadeStart) {\n              alpha = 1.0;\n            } else if (normalizedDist > fadeEnd) {\n              alpha = 0.0;\n            } else {\n              // 线性插值产生渐变\n              alpha = 1.0 - (normalizedDist - fadeStart) / (fadeEnd - fadeStart);\n            }\n          } else {\n            // 硬边缘：使用0或1\n            alpha = normalizedDist > dissolveThreshold ? 0.0 : 1.0;\n          }\n        }\n\n        const index = (y * width + x) * 4;\n        result[index + 3] = Math.floor(result[index + 3] * alpha);\n      }\n    }\n\n    return new ImageData(result, width, height);\n  }\n\n  // Canvas 2D 实现 - 向内溶解\n  private applyInwardDissolve(imageData: ImageData, progress: number): ImageData {\n    const { data, width, height } = imageData;\n    const result = new Uint8ClampedArray(data.length);\n    result.set(data);\n\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);\n\n    const pixelSize = this.dissolveConfig.noiseScale;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const dx = x - centerX;\n        const dy = y - centerY;\n        const distFromCenter = Math.sqrt(dx * dx + dy * dy);\n        const normalizedDist = distFromCenter / maxDist;\n\n        // 向内溶解：从中心开始，增加系数确保完全溶解\n        let dissolveThreshold = progress * 1.4;\n        let alpha = 1.0;\n\n        if (pixelSize > 0) {\n          // 颗粒效果\n          const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);\n          const noiseInfluence = (noiseValue - 0.5) * 0.4;\n          dissolveThreshold += noiseInfluence;\n\n          alpha = normalizedDist < dissolveThreshold ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (this.dissolveConfig.fadeEdge) {\n            // 柔和边缘：使用渐变值\n            const fadeWidth = 0.15; // 渐变宽度\n            const fadeStart = dissolveThreshold;\n            const fadeEnd = dissolveThreshold + fadeWidth;\n\n            if (normalizedDist < fadeStart) {\n              alpha = 0.0;\n            } else if (normalizedDist > fadeEnd) {\n              alpha = 1.0;\n            } else {\n              // 线性插值产生渐变\n              alpha = (normalizedDist - fadeStart) / (fadeEnd - fadeStart);\n            }\n          } else {\n            // 硬边缘：使用0或1\n            alpha = normalizedDist < dissolveThreshold ? 0.0 : 1.0;\n          }\n        }\n\n        const index = (y * width + x) * 4;\n        result[index + 3] = Math.floor(result[index + 3] * alpha);\n      }\n    }\n\n    return new ImageData(result, width, height);\n  }\n\n  // Canvas 2D 实现 - 径向溶解\n  private applyRadialDissolve(imageData: ImageData, progress: number): ImageData {\n    const { data, width, height } = imageData;\n    const result = new Uint8ClampedArray(data.length);\n    result.set(data);\n\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const pixelSize = this.dissolveConfig.noiseScale;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const dx = x - centerX;\n        const dy = y - centerY;\n        const angle = Math.atan2(dy, dx);\n        const normalizedAngle = (angle + Math.PI) / (2 * Math.PI);\n\n        // 径向溶解：按角度顺序，增加系数确保完全溶解\n        let dissolveThreshold = progress * 1.2;\n        let alpha = 1.0;\n\n        if (pixelSize > 0) {\n          // 颗粒效果\n          const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);\n          const noiseInfluence = (noiseValue - 0.5) * 0.3;\n          dissolveThreshold += noiseInfluence;\n\n          alpha = normalizedAngle < dissolveThreshold ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (this.dissolveConfig.fadeEdge) {\n            // 柔和边缘：使用渐变值\n            const fadeWidth = 0.08; // 渐变宽度\n            const fadeStart = dissolveThreshold;\n            const fadeEnd = dissolveThreshold + fadeWidth;\n\n            if (normalizedAngle < fadeStart) {\n              alpha = 0.0;\n            } else if (normalizedAngle > fadeEnd) {\n              alpha = 1.0;\n            } else {\n              // 线性插值产生渐变\n              alpha = (normalizedAngle - fadeStart) / (fadeEnd - fadeStart);\n            }\n          } else {\n            // 硬边缘：使用0或1\n            alpha = normalizedAngle < dissolveThreshold ? 0.0 : 1.0;\n          }\n        }\n\n        const index = (y * width + x) * 4;\n        result[index + 3] = Math.floor(result[index + 3] * alpha);\n      }\n    }\n\n    return new ImageData(result, width, height);\n  }\n\n  // Canvas 2D 实现 - 从左到右溶解\n  private applyLeftToRightDissolve(imageData: ImageData, progress: number): ImageData {\n    const { data, width, height } = imageData;\n    const result = new Uint8ClampedArray(data.length);\n    result.set(data);\n\n    const pixelSize = this.dissolveConfig.noiseScale;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const normalizedX = x / width;\n\n        // 从左到右溶解：增加系数确保完全溶解\n        let dissolveThreshold = progress * 1.2;\n        let alpha = 1.0;\n\n        if (pixelSize > 0) {\n          // 颗粒效果\n          const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);\n          const noiseInfluence = (noiseValue - 0.5) * 0.3;\n          dissolveThreshold += noiseInfluence;\n\n          alpha = normalizedX < dissolveThreshold ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (this.dissolveConfig.fadeEdge) {\n            // 柔和边缘：使用渐变值\n            const fadeWidth = 0.08; // 渐变宽度\n            const fadeStart = dissolveThreshold;\n            const fadeEnd = dissolveThreshold + fadeWidth;\n\n            if (normalizedX < fadeStart) {\n              alpha = 0.0;\n            } else if (normalizedX > fadeEnd) {\n              alpha = 1.0;\n            } else {\n              // 线性插值产生渐变\n              alpha = (normalizedX - fadeStart) / (fadeEnd - fadeStart);\n            }\n          } else {\n            // 硬边缘：使用0或1\n            alpha = normalizedX < dissolveThreshold ? 0.0 : 1.0;\n          }\n        }\n\n        const index = (y * width + x) * 4;\n        result[index + 3] = Math.floor(result[index + 3] * alpha);\n      }\n    }\n\n    return new ImageData(result, width, height);\n  }\n\n  // Canvas 2D 实现 - 从右到左溶解\n  private applyRightToLeftDissolve(imageData: ImageData, progress: number): ImageData {\n    const { data, width, height } = imageData;\n    const result = new Uint8ClampedArray(data.length);\n    result.set(data);\n\n    const pixelSize = this.dissolveConfig.noiseScale;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const normalizedX = x / width;\n\n        // 从右到左溶解：增加系数确保完全溶解\n        let dissolveThreshold = 1.0 - progress * 1.2;\n        let alpha = 1.0;\n\n        if (pixelSize > 0) {\n          // 颗粒效果\n          const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);\n          const noiseInfluence = (noiseValue - 0.5) * 0.3;\n          dissolveThreshold += noiseInfluence;\n\n          alpha = normalizedX > dissolveThreshold ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (this.dissolveConfig.fadeEdge) {\n            // 柔和边缘：使用渐变值\n            const fadeWidth = 0.08; // 渐变宽度\n            const fadeStart = dissolveThreshold - fadeWidth;\n            const fadeEnd = dissolveThreshold;\n\n            if (normalizedX < fadeStart) {\n              alpha = 1.0;\n            } else if (normalizedX > fadeEnd) {\n              alpha = 0.0;\n            } else {\n              // 线性插值产生渐变\n              alpha = 1.0 - (normalizedX - fadeStart) / (fadeEnd - fadeStart);\n            }\n          } else {\n            // 硬边缘：使用0或1\n            alpha = normalizedX > dissolveThreshold ? 0.0 : 1.0;\n          }\n        }\n\n        const index = (y * width + x) * 4;\n        result[index + 3] = Math.floor(result[index + 3] * alpha);\n      }\n    }\n\n    return new ImageData(result, width, height);\n  }\n\n  // Canvas 2D 实现 - 从上到下溶解\n  private applyTopToBottomDissolve(imageData: ImageData, progress: number): ImageData {\n    const { data, width, height } = imageData;\n    const result = new Uint8ClampedArray(data.length);\n    result.set(data);\n\n    const pixelSize = this.dissolveConfig.noiseScale;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const normalizedY = y / height;\n\n        // 从上到下溶解：增加系数确保完全溶解\n        let dissolveThreshold = progress * 1.2;\n        let alpha = 1.0;\n\n        if (pixelSize > 0) {\n          // 颗粒效果\n          const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);\n          const noiseInfluence = (noiseValue - 0.5) * 0.3;\n          dissolveThreshold += noiseInfluence;\n\n          alpha = normalizedY < dissolveThreshold ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (this.dissolveConfig.fadeEdge) {\n            // 柔和边缘：使用渐变值\n            const fadeWidth = 0.08; // 渐变宽度\n            const fadeStart = dissolveThreshold;\n            const fadeEnd = dissolveThreshold + fadeWidth;\n\n            if (normalizedY < fadeStart) {\n              alpha = 0.0;\n            } else if (normalizedY > fadeEnd) {\n              alpha = 1.0;\n            } else {\n              // 线性插值产生渐变\n              alpha = (normalizedY - fadeStart) / (fadeEnd - fadeStart);\n            }\n          } else {\n            // 硬边缘：使用0或1\n            alpha = normalizedY < dissolveThreshold ? 0.0 : 1.0;\n          }\n        }\n\n        const index = (y * width + x) * 4;\n        result[index + 3] = Math.floor(result[index + 3] * alpha);\n      }\n    }\n\n    return new ImageData(result, width, height);\n  }\n\n  // Canvas 2D 实现 - 从下到上溶解\n  private applyBottomToTopDissolve(imageData: ImageData, progress: number): ImageData {\n    const { data, width, height } = imageData;\n    const result = new Uint8ClampedArray(data.length);\n    result.set(data);\n\n    const pixelSize = this.dissolveConfig.noiseScale;\n\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const normalizedY = y / height;\n\n        // 从下到上溶解：增加系数确保完全溶解\n        let dissolveThreshold = 1.0 - progress * 1.2;\n        let alpha = 1.0;\n\n        if (pixelSize > 0) {\n          // 颗粒效果\n          const noiseValue = ImageProcessUtils.pixelNoise(x, y, pixelSize);\n          const noiseInfluence = (noiseValue - 0.5) * 0.3;\n          dissolveThreshold += noiseInfluence;\n\n          alpha = normalizedY > dissolveThreshold ? 0.0 : 1.0;\n        } else {\n          // 平滑溶解：根据fadeEdge决定是否使用渐变\n          if (this.dissolveConfig.fadeEdge) {\n            // 柔和边缘：使用渐变值\n            const fadeWidth = 0.08; // 渐变宽度\n            const fadeStart = dissolveThreshold - fadeWidth;\n            const fadeEnd = dissolveThreshold;\n\n            if (normalizedY < fadeStart) {\n              alpha = 1.0;\n            } else if (normalizedY > fadeEnd) {\n              alpha = 0.0;\n            } else {\n              // 线性插值产生渐变\n              alpha = 1.0 - (normalizedY - fadeStart) / (fadeEnd - fadeStart);\n            }\n          } else {\n            // 硬边缘：使用0或1\n            alpha = normalizedY > dissolveThreshold ? 0.0 : 1.0;\n          }\n        }\n\n        const index = (y * width + x) * 4;\n        result[index + 3] = Math.floor(result[index + 3] * alpha);\n      }\n    }\n\n    return new ImageData(result, width, height);\n  }\n}\n"]}