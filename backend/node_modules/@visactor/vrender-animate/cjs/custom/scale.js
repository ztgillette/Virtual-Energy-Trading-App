"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.ScaleOut = exports.ScaleIn = void 0;

const custom_animate_1 = require("./custom-animate");

class ScaleIn extends custom_animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        let from, to;
        super.onBind();
        const attrs = this.target.getFinalAttribute(), fromAttrs = null !== (_a = this.target.attribute) && void 0 !== _a ? _a : {};
        switch (null === (_b = this.params) || void 0 === _b ? void 0 : _b.direction) {
          case "x":
            from = {
                scaleX: null !== (_c = fromAttrs.scaleX) && void 0 !== _c ? _c : 0
            }, to = {
                scaleX: null !== (_d = null == attrs ? void 0 : attrs.scaleX) && void 0 !== _d ? _d : 1
            }, this._updateFunction = this.updateX;
            break;

          case "y":
            from = {
                scaleY: null !== (_e = fromAttrs.scaleY) && void 0 !== _e ? _e : 0
            }, to = {
                scaleY: null !== (_f = null == attrs ? void 0 : attrs.scaleY) && void 0 !== _f ? _f : 1
            }, this._updateFunction = this.updateY;
            break;

          default:
            from = {
                scaleX: null !== (_g = fromAttrs.scaleX) && void 0 !== _g ? _g : 0,
                scaleY: null !== (_h = fromAttrs.scaleY) && void 0 !== _h ? _h : 0
            }, to = {
                scaleX: null !== (_j = null == attrs ? void 0 : attrs.scaleX) && void 0 !== _j ? _j : 1,
                scaleY: null !== (_k = null == attrs ? void 0 : attrs.scaleY) && void 0 !== _k ? _k : 1
            }, this._updateFunction = this.updateXY;
        }
        const finalAttribute = this.target.getFinalAttribute();
        finalAttribute && this.target.setAttributes(finalAttribute), this.props = to, this.from = from, 
        this.to = to, !1 !== (null === (_l = this.params.controlOptions) || void 0 === _l ? void 0 : _l.immediatelyApply) && this.target.setAttributes(from);
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    updateX(ratio) {
        this.target.attribute.scaleX = this.from.scaleX + (this.to.scaleX - this.from.scaleX) * ratio;
    }
    updateY(ratio) {
        this.target.attribute.scaleY = this.from.scaleY + (this.to.scaleY - this.from.scaleY) * ratio;
    }
    updateXY(ratio) {
        this.updateX(ratio), this.updateY(ratio);
    }
    deleteSelfAttr(key) {
        delete this.props[key], this.fromProps && delete this.fromProps[key];
        const index = this.propKeys.indexOf(key);
        -1 !== index && this.propKeys.splice(index, 1), this.propKeys && this.propKeys.length > 1 ? this._updateFunction = this.updateXY : "scaleX" === this.propKeys[0] ? this._updateFunction = this.updateX : "scaleY" === this.propKeys[0] ? this._updateFunction = this.updateY : this._updateFunction = null;
    }
    onUpdate(end, ratio, out) {
        this._updateFunction && (this._updateFunction(ratio), this.target.addUpdatePositionTag(), 
        this.target.addUpdateBoundTag());
    }
}

exports.ScaleIn = ScaleIn;

class ScaleOut extends custom_animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c, _d, _e;
        let from, to;
        super.onBind();
        const attrs = this.target.attribute;
        switch (null === (_a = this.params) || void 0 === _a ? void 0 : _a.direction) {
          case "x":
            from = {
                scaleX: null !== (_b = null == attrs ? void 0 : attrs.scaleX) && void 0 !== _b ? _b : 1
            }, to = {
                scaleX: 0
            };
            break;

          case "y":
            from = {
                scaleY: null !== (_c = null == attrs ? void 0 : attrs.scaleY) && void 0 !== _c ? _c : 1
            }, to = {
                scaleY: 0
            };
            break;

          default:
            from = {
                scaleX: null !== (_d = null == attrs ? void 0 : attrs.scaleX) && void 0 !== _d ? _d : 1,
                scaleY: null !== (_e = null == attrs ? void 0 : attrs.scaleY) && void 0 !== _e ? _e : 1
            }, to = {
                scaleX: 0,
                scaleY: 0
            };
        }
        this.props = to, this.from = from, this.to = to;
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach((key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        })), this.target.addUpdatePositionTag(), this.target.addUpdateBoundTag();
    }
}

exports.ScaleOut = ScaleOut;