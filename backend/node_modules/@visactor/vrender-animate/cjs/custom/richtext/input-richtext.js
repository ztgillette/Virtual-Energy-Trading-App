"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.InputRichText = void 0;

const custom_animate_1 = require("../custom-animate"), vrender_core_1 = require("@visactor/vrender-core");

class InputRichText extends custom_animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params), this.fromTextConfig = [], this.toTextConfig = [], 
        this.originalTextConfig = [], this.showCursor = !1, this.cursorChar = "|", this.blinkCursor = !0, 
        this.fadeInChars = !1, this.fadeInDuration = .3, this.strokeFirst = !1, this.strokeToFillRatio = .3, 
        void 0 !== (null == params ? void 0 : params.showCursor) && (this.showCursor = params.showCursor), 
        void 0 !== (null == params ? void 0 : params.cursorChar) && (this.cursorChar = params.cursorChar), 
        void 0 !== (null == params ? void 0 : params.blinkCursor) && (this.blinkCursor = params.blinkCursor), 
        void 0 !== (null == params ? void 0 : params.fadeInChars) && (this.fadeInChars = params.fadeInChars), 
        void 0 !== (null == params ? void 0 : params.fadeInDuration) && (this.fadeInDuration = params.fadeInDuration), 
        void 0 !== (null == params ? void 0 : params.strokeFirst) && (this.strokeFirst = params.strokeFirst), 
        void 0 !== (null == params ? void 0 : params.strokeToFillRatio) && (this.strokeToFillRatio = params.strokeToFillRatio);
    }
    onFirstRun() {
        const fromProps = this.getLastProps(), toProps = this.getEndProps();
        this.originalTextConfig = toProps.textConfig ? [ ...toProps.textConfig ] : [], this.valid = !0, 
        this.originalTextConfig && 0 !== this.originalTextConfig.length ? (this.fromTextConfig = fromProps.textConfig && fromProps.textConfig.length > 0 ? vrender_core_1.RichText.TransformTextConfig2SingleCharacter(fromProps.textConfig) : [], 
        this.toTextConfig = vrender_core_1.RichText.TransformTextConfig2SingleCharacter(this.originalTextConfig)) : this.valid = !1;
    }
    onEnd(cb) {
        super.onEnd(cb), cb || this.target.setAttribute("textConfig", this.originalTextConfig);
    }
    onUpdate(end, ratio, out) {
        if (!this.valid) return;
        const totalItems = this.toTextConfig.length, fromItems = this.fromTextConfig.length, maxTextShowRatio = this.fadeInChars ? 1 - this.fadeInDuration : 1;
        let currentLength, currentTextConfig;
        if (fromItems > totalItems) currentLength = Math.round(fromItems - (fromItems - totalItems) * ratio); else if (this.fadeInChars) {
            const adjustedRatio = Math.min(1, ratio / maxTextShowRatio);
            currentLength = Math.round(fromItems + (totalItems - fromItems) * adjustedRatio);
        } else currentLength = Math.round(fromItems + (totalItems - fromItems) * ratio);
        if (currentTextConfig = fromItems > totalItems ? this.fromTextConfig.slice(0, currentLength) : this.toTextConfig.slice(0, currentLength).map(((item, index) => {
            if ("text" in item) {
                const newItem = Object.assign({}, item);
                if (this.strokeFirst) {
                    const appearTime = index / totalItems * maxTextShowRatio, itemLifetime = Math.max(0, ratio - appearTime), maxLifetime = 1 - appearTime, fillProgress = Math.min(1, itemLifetime / (this.strokeToFillRatio * maxLifetime));
                    if ("fill" in newItem && newItem.fill && (newItem.stroke = newItem.fill, fillProgress < 1 && (newItem.fillOpacity = fillProgress)), 
                    this.fadeInChars) {
                        const fadeProgress = Math.min(1, itemLifetime / (this.fadeInDuration * maxLifetime));
                        newItem.opacity = Math.max(0, Math.min(1, fadeProgress));
                    }
                } else if (this.fadeInChars) {
                    const fadeProgress = (ratio - index / totalItems * maxTextShowRatio) / this.fadeInDuration;
                    newItem.opacity = Math.max(0, Math.min(1, fadeProgress));
                }
                return newItem;
            }
            return item;
        })), this.showCursor && currentLength < totalItems) {
            let shouldShowCursor = !0;
            if (this.blinkCursor) {
                const blinkRate = .1;
                shouldShowCursor = Math.floor(ratio / blinkRate) % 2 == 0;
            }
            if (shouldShowCursor && currentTextConfig.length > 0) {
                const lastIndex = currentTextConfig.length - 1, lastItem = currentTextConfig[lastIndex];
                if ("text" in lastItem) currentTextConfig[lastIndex] = Object.assign(Object.assign({}, lastItem), {
                    text: String(lastItem.text) + this.cursorChar
                }); else {
                    const cursorItem = {
                        text: this.cursorChar,
                        fontSize: 16
                    };
                    currentTextConfig.push(cursorItem);
                }
            }
        }
        this.target.setAttribute("textConfig", currentTextConfig);
    }
}

exports.InputRichText = InputRichText;
//# sourceMappingURL=input-richtext.js.map
