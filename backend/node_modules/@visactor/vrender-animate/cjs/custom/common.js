"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CommonOut = exports.CommonIn = void 0;

const custom_animate_1 = require("./custom-animate");

class CommonIn extends custom_animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        var _a, _b, _c;
        super.onBind();
        const attrs = this.target.getFinalAttribute(), fromAttrs = null !== (_a = this.target.attribute) && void 0 !== _a ? _a : {}, to = {}, from = null !== (_b = this.from) && void 0 !== _b ? _b : {};
        this.keys.forEach((key => {
            var _a, _b, _c;
            to[key] = null !== (_a = null == attrs ? void 0 : attrs[key]) && void 0 !== _a ? _a : 1, 
            from[key] = null !== (_c = null !== (_b = from[key]) && void 0 !== _b ? _b : fromAttrs[key]) && void 0 !== _c ? _c : 0;
        }));
        const finalAttribute = this.target.getFinalAttribute();
        finalAttribute && this.target.setAttributes(finalAttribute), this.props = to, this.propKeys = this.keys, 
        this.from = from, this.to = to, !1 !== (null === (_c = this.params.controlOptions) || void 0 === _c ? void 0 : _c.immediatelyApply) && this.target.setAttributes(from);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach((key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        })), this.target.addUpdatePositionTag(), this.target.addUpdateShapeAndBoundsTag();
    }
}

exports.CommonIn = CommonIn;

class CommonOut extends custom_animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onBind() {
        super.onBind();
        const attrs = this.target.attribute, to = {}, from = {};
        this.keys.forEach((key => {
            var _a;
            to[key] = 0, from[key] = null !== (_a = attrs[key]) && void 0 !== _a ? _a : 1;
        })), this.props = to, this.propKeys = this.keys, this.from = from, this.to = to, 
        Object.assign(this.target.attribute, from), this.target.addUpdatePositionTag(), 
        this.target.addUpdateBoundTag();
    }
    onEnd(cb) {
        super.onEnd(cb);
    }
    onUpdate(end, ratio, out) {
        const attribute = this.target.attribute;
        this.propKeys.forEach((key => {
            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
        })), this.target.addUpdatePositionTag(), this.target.addUpdateShapeAndBoundsTag();
    }
}

exports.CommonOut = CommonOut;
//# sourceMappingURL=common.js.map