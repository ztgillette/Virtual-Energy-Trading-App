"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.AStageAnimate = exports.AComponentAnimate = exports.ACustomAnimate = void 0;

const step_1 = require("../step");

class ACustomAnimate extends step_1.Step {
    constructor(customFrom, customTo, duration, easing, params) {
        super("customAnimate", customTo, duration, easing), this.type = "customAnimate", 
        this.customFrom = customFrom, this.params = params, this.from = customFrom, this.to = customTo;
    }
    update(end, ratio, out) {
        if (this.onStart(), !this.props || !this.propKeys) return;
        const easedRatio = this.easing(ratio);
        this.onUpdate(end, easedRatio, out), this.syncAttributeUpdate();
    }
    setProps(props) {
        this.props = props, this.propKeys = Object.keys(props), this.animate.reSyncProps();
    }
}

exports.ACustomAnimate = ACustomAnimate;

class AComponentAnimate extends ACustomAnimate {
    completeBind(animator) {
        this.setStartTime(0), this._animator && this._animator.start(), this.setDuration(animator.getDuration());
    }
    stop() {
        this._animator && this._animator.stop();
    }
}

exports.AComponentAnimate = AComponentAnimate;

class AStageAnimate extends ACustomAnimate {
    constructor(customFrom, customTo, duration, easing, params) {
        super(customFrom, customTo, duration, easing, params), this.willCallBeforeStageRender = !0, 
        this.willCallAfterStageRender = !0, this._beforeStageRender = () => {
            if (!this.willCallBeforeStageRender) return;
            this.willCallBeforeStageRender = !1;
            const stage = this.target.stage, canvas = stage.window.getContext().canvas.nativeCanvas, outputCanvas = this.beforeStageRender(stage, canvas);
            outputCanvas && this.renderToStage(stage, outputCanvas);
        }, this._afterStageRender = () => {
            if (!this.willCallAfterStageRender) return;
            this.willCallAfterStageRender = !1;
            const stage = this.target.stage, canvas = stage.window.getContext().canvas.nativeCanvas, outputCanvas = this.afterStageRender(stage, canvas);
            outputCanvas && this.renderToStage(stage, outputCanvas);
        }, this.props = {};
    }
    beforeStageRender(stage, canvas) {
        return !1;
    }
    afterStageRender(stage, canvas) {
        return !1;
    }
    onFirstRun() {
        super.onFirstRun(), this.target.stage.setBeforeRender(this._beforeStageRender), 
        this.target.stage.setAfterRender(this._afterStageRender), this.target.stage.disableDirtyBounds();
    }
    stop() {
        super.stop(), this.target.stage.removeBeforeRender(this._beforeStageRender), this.target.stage.removeAfterRender(this._afterStageRender);
    }
    onUpdate(end, ratio, out) {
        super.onUpdate(end, ratio, out), this.willCallBeforeStageRender = !0, this.willCallAfterStageRender = !0;
    }
    renderToStage(stage, canvas) {
        const stageCanvas = stage.window.getContext().canvas.nativeCanvas, ctx = stageCanvas.getContext("2d");
        return !!ctx && (ctx.clearRect(0, 0, stageCanvas.width, stageCanvas.height), ctx.drawImage(canvas, 0, 0), 
        stageCanvas);
    }
}

exports.AStageAnimate = AStageAnimate;
//# sourceMappingURL=custom-animate.js.map