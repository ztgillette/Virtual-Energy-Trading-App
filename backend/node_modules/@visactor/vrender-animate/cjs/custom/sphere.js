"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.RotateBySphereAnimate = void 0;

const vutils_1 = require("@visactor/vutils"), custom_animate_1 = require("./custom-animate");

class RotateBySphereAnimate extends custom_animate_1.ACustomAnimate {
    onBind() {
        super.onBind(), this.propKeys = [ "x", "y", "z", "alpha", "zIndex" ];
    }
    onFirstRun() {
        super.onFirstRun();
        const finalAttribute = this.target.getFinalAttribute();
        finalAttribute && this.target.setAttributes(finalAttribute);
    }
    onStart() {
        super.onStart();
        const {center: center, r: r} = "function" == typeof this.params ? this.params() : this.params, startX = this.target.finalAttribute.x, startY = this.target.finalAttribute.y, startZ = this.target.finalAttribute.z, phi = Math.acos((startY - center.y) / r);
        let theta = Math.acos((startX - center.x) / r / Math.sin(phi));
        startZ - center.z < 0 && (theta = vutils_1.pi2 - theta), this.theta = theta, this.phi = phi;
    }
    onEnd() {}
    onUpdate(end, ratio, out) {
        if (null == this.phi || null == this.theta) return;
        const target = this.target, {center: center, r: r, cb: cb} = "function" == typeof this.params ? this.params() : this.params, deltaAngle = 2 * Math.PI * ratio, theta = this.theta + deltaAngle, phi = this.phi, x = r * Math.sin(phi) * Math.cos(theta) + center.x, y = r * Math.cos(phi) + center.y, z = r * Math.sin(phi) * Math.sin(theta) + center.z;
        for (target.attribute.x = x, target.attribute.y = y, target.attribute.z = z, target.attribute.alpha = theta + vutils_1.pi / 2; target.attribute.alpha > vutils_1.pi2; ) target.attribute.alpha -= vutils_1.pi2;
        target.attribute.alpha = vutils_1.pi2 - target.attribute.alpha, target.attribute.zIndex = -1e4 * target.attribute.z, 
        cb && cb(out);
    }
}

exports.RotateBySphereAnimate = RotateBySphereAnimate;
//# sourceMappingURL=sphere.js.map