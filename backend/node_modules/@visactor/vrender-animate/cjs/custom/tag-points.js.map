{"version":3,"sources":["../src/custom/tag-points.ts"],"names":[],"mappings":"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","file":"tag-points.js","sourcesContent":["import { clamp, isValidNumber, Point, type IPointLike } from '@visactor/vutils';\nimport type { ISegment, ILineAttribute, EasingType } from '@visactor/vrender-core';\nimport { pointInterpolation } from '@visactor/vrender-core';\nimport { ACustomAnimate } from './custom-animate';\n\nexport class TagPointsUpdate extends ACustomAnimate<{ points?: IPointLike[]; segments?: ISegment[] }> {\n  protected fromPoints: IPointLike[];\n  protected toPoints: IPointLike[];\n  protected points: IPointLike[];\n  protected interpolatePoints: [IPointLike, IPointLike][];\n  protected newPointAnimateType: 'grow' | 'appear' | 'clip';\n  protected clipRange: number;\n  protected shrinkClipRange: number;\n  protected clipRangeByDimension: 'x' | 'y';\n  protected segmentsCache: number[];\n\n  constructor(\n    from: any,\n    to: any,\n    duration: number,\n    easing: EasingType,\n    params?: { newPointAnimateType?: 'grow' | 'appear' | 'clip'; clipRangeByDimension?: 'x' | 'y' }\n  ) {\n    super(from, to, duration, easing, params);\n    this.newPointAnimateType = params?.newPointAnimateType ?? 'grow';\n    this.clipRangeByDimension = params?.clipRangeByDimension ?? 'x';\n  }\n\n  private getPoints(attribute: typeof this.from, cache = false): IPointLike[] {\n    if (attribute.points) {\n      return attribute.points;\n    }\n\n    if (attribute.segments) {\n      const points = [] as IPointLike[];\n      if (!this.segmentsCache) {\n        this.segmentsCache = [];\n      }\n      attribute.segments.map((segment: any) => {\n        if (segment.points) {\n          points.push(...segment.points);\n        }\n        if (cache) {\n          this.segmentsCache.push(segment.points?.length ?? 0);\n        }\n      });\n      return points;\n    }\n    return [];\n  }\n\n  onBind(): void {\n    super.onBind();\n    const { points, segments } = this.target.attribute as any;\n    const { points: pointsTo, segments: segmentsTo } = this.target.getFinalAttribute() as any;\n\n    this.from = { points, segments };\n    this.to = { points: pointsTo, segments: segmentsTo };\n    this.props = this.to;\n\n    const originFromPoints = this.getPoints(this.from);\n    const originToPoints = this.getPoints(this.to, true);\n    this.fromPoints = !originFromPoints ? [] : !Array.isArray(originFromPoints) ? [originFromPoints] : originFromPoints;\n    this.toPoints = !originToPoints ? [] : !Array.isArray(originToPoints) ? [originToPoints] : originToPoints;\n\n    const tagMap = new Map<string, IPointLike>();\n    this.fromPoints.forEach(point => {\n      if (point.context) {\n        tagMap.set(point.context, point);\n      }\n    });\n    let firstMatchedIndex = Infinity;\n    let lastMatchedIndex = -Infinity;\n    let firstMatchedPoint: IPointLike;\n    let lastMatchedPoint: IPointLike;\n    for (let i = 0; i < this.toPoints.length; i += 1) {\n      if (tagMap.has(this.toPoints[i].context)) {\n        firstMatchedIndex = i;\n        firstMatchedPoint = tagMap.get(this.toPoints[i].context);\n        break;\n      }\n    }\n    for (let i = this.toPoints.length - 1; i >= 0; i -= 1) {\n      if (tagMap.has(this.toPoints[i].context)) {\n        lastMatchedIndex = i;\n        lastMatchedPoint = tagMap.get(this.toPoints[i].context);\n        break;\n      }\n    }\n\n    if (this.newPointAnimateType === 'clip') {\n      if (this.toPoints.length !== 0) {\n        if (Number.isFinite(lastMatchedIndex)) {\n          this.clipRange =\n            this.toPoints[lastMatchedIndex][this.clipRangeByDimension] /\n            this.toPoints[this.toPoints.length - 1][this.clipRangeByDimension];\n          if (this.clipRange === 1) {\n            this.shrinkClipRange =\n              this.toPoints[lastMatchedIndex][this.clipRangeByDimension] /\n              this.fromPoints[this.fromPoints.length - 1][this.clipRangeByDimension];\n          }\n          if (!isValidNumber(this.clipRange)) {\n            this.clipRange = 0;\n          } else {\n            this.clipRange = clamp(this.clipRange, 0, 1);\n          }\n        } else {\n          this.clipRange = 0;\n        }\n      }\n    }\n    // TODO: shrink removed points\n    // if no point is matched, animation should start from toPoint[0]\n    let prevMatchedPoint = this.toPoints[0];\n    this.interpolatePoints = this.toPoints.map((point, index) => {\n      const matchedPoint = tagMap.get(point.context);\n      if (matchedPoint) {\n        prevMatchedPoint = matchedPoint;\n        return [matchedPoint, point];\n      }\n      // appear new point\n      if (this.newPointAnimateType === 'appear' || this.newPointAnimateType === 'clip') {\n        return [point, point];\n      }\n      // grow new point\n      if (index < firstMatchedIndex && firstMatchedPoint) {\n        return [firstMatchedPoint, point];\n      } else if (index > lastMatchedIndex && lastMatchedPoint) {\n        return [lastMatchedPoint, point];\n      }\n      return [prevMatchedPoint, point];\n    });\n    this.points = this.interpolatePoints.map(interpolate => {\n      const fromPoint = interpolate[0];\n      const toPoint = interpolate[1];\n      const newPoint = new Point(fromPoint.x, fromPoint.y, fromPoint.x1, fromPoint.y1);\n      newPoint.defined = toPoint.defined;\n      newPoint.context = toPoint.context;\n      return newPoint;\n    });\n  }\n\n  onFirstRun(): void {\n    const lastClipRange = (this.target.attribute as any).clipRange;\n    if (isValidNumber(lastClipRange * this.clipRange)) {\n      this.clipRange *= lastClipRange;\n    }\n  }\n\n  onUpdate(end: boolean, ratio: number, out: Record<string, any>): void {\n    if (end) {\n      Object.keys(this.to).forEach(k => {\n        (this.target.attribute as any)[k] = (this.to as any)[k];\n      });\n      this.target.addUpdatePositionTag();\n      this.target.addUpdateShapeAndBoundsTag();\n      return;\n    }\n    // if not create new points, multi points animation might not work well.\n    this.points = this.points.map((point, index) => {\n      const newPoint = pointInterpolation(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);\n      newPoint.context = point.context;\n      return newPoint;\n    });\n    if (this.clipRange) {\n      if (this.shrinkClipRange) {\n        // 折线变短\n        if (!end) {\n          out.points = this.fromPoints;\n          out.clipRange = this.clipRange - (this.clipRange - this.shrinkClipRange) * ratio;\n        } else {\n          out.points = this.toPoints;\n          out.clipRange = 1;\n        }\n        return;\n      }\n      this.target.setAttributes({ clipRange: this.clipRange + (1 - this.clipRange) * ratio } as any);\n    }\n    if (this.segmentsCache && this.to.segments) {\n      let start = 0;\n      const segments = this.to.segments.map((segment: any, index: any) => {\n        const end = start + this.segmentsCache[index];\n        const points = this.points.slice(start, end);\n        start = end;\n        return {\n          ...segment,\n          points\n        };\n      });\n      (this.target.attribute as ILineAttribute).segments = segments;\n    } else {\n      (this.target.attribute as ILineAttribute).points = this.points;\n    }\n    this.target.addUpdatePositionTag();\n    this.target.addUpdateShapeAndBoundsTag();\n  }\n}\n"]}