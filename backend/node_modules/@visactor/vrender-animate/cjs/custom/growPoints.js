"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.GrowPointsYOut = exports.GrowPointsYIn = exports.GrowPointsXOut = exports.GrowPointsXIn = exports.GrowPointsOut = exports.GrowPointsIn = exports.GworPointsBase = exports.growPointsOut = exports.growPointsIn = void 0;

const vrender_core_1 = require("@visactor/vrender-core"), vutils_1 = require("@visactor/vutils"), custom_animate_1 = require("./custom-animate"), getCenterPoints = (graphic, options, animationParameters) => {
    const points = graphic.getFinalAttribute().points, center = {
        x: 0,
        y: 0
    };
    return points.forEach((point => {
        center.x += point.x, center.y += point.y;
    })), center.x /= points.length, center.y /= points.length, options && options.center && ((0, 
    vutils_1.isValidNumber)(options.center.x) && (center.x = options.center.x), (0, 
    vutils_1.isValidNumber)(options.center.y) && (center.y = options.center.y)), "area" === graphic.type && (center.x1 = center.x, 
    center.y1 = center.y), points.map((point => Object.assign({}, point, center)));
}, growPointsIn = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    return {
        from: {
            points: getCenterPoints(graphic, options)
        },
        to: {
            points: attrs.points
        }
    };
};

exports.growPointsIn = growPointsIn;

const growPointsOut = (graphic, options, animationParameters) => ({
    from: {
        points: graphic.getFinalAttribute().points
    },
    to: {
        points: getCenterPoints(graphic, options)
    }
});

exports.growPointsOut = growPointsOut;

class GworPointsBase extends custom_animate_1.ACustomAnimate {
    constructor(from, to, duration, easing, params) {
        super(from, to, duration, easing, params);
    }
    onUpdate(end, ratio, out) {
        var _a, _b;
        const fromPoints = null === (_a = this.from) || void 0 === _a ? void 0 : _a.points, toPoints = null === (_b = this.to) || void 0 === _b ? void 0 : _b.points;
        fromPoints && toPoints && (this.target.attribute.points = fromPoints.map(((point, index) => (0, 
        vrender_core_1.pointInterpolation)(fromPoints[index], toPoints[index], ratio))), 
        this.target.addUpdatePositionTag(), this.target.addUpdateShapeAndBoundsTag());
    }
}

exports.GworPointsBase = GworPointsBase;

class GrowPointsIn extends GworPointsBase {
    onBind() {
        var _a;
        if (super.onBind(), [ "area", "line", "polygon" ].includes(this.target.type)) {
            const {from: from, to: to} = (0, exports.growPointsIn)(this.target, this.params.options, this.params);
            this.props = to, this.propKeys = Object.keys(to).filter((key => null != to[key])), 
            this.from = from, this.to = to;
            const finalAttribute = this.target.getFinalAttribute();
            finalAttribute && this.target.setAttributes(finalAttribute), !1 !== (null === (_a = this.params.controlOptions) || void 0 === _a ? void 0 : _a.immediatelyApply) && this.target.setAttributes(from);
        } else this.valid = !1;
    }
}

exports.GrowPointsIn = GrowPointsIn;

class GrowPointsOut extends GworPointsBase {
    onBind() {
        if (super.onBind(), [ "area", "line" ].includes(this.target.type)) {
            const attrs = this.target.getFinalAttribute(), {from: from, to: to} = (0, exports.growPointsOut)(this.target, this.params.options, this.params);
            this.props = to, this.propKeys = Object.keys(to).filter((key => null != to[key])), 
            this.from = from || attrs, this.to = to;
        } else this.valid = !1;
    }
}

exports.GrowPointsOut = GrowPointsOut;

const changePointsX = (graphic, options, animationParameters) => graphic.getFinalAttribute().points.map((point => {
    if (options && "negative" === options.orient) {
        let groupRight = graphic.stage.viewWidth;
        return graphic.parent.parent.parent && (groupRight = graphic.parent.parent.parent.AABBBounds.width()), 
        Object.assign(Object.assign({}, point), {
            x: groupRight,
            y: point.y,
            x1: groupRight,
            y1: point.y1,
            defined: !1 !== point.defined
        });
    }
    return Object.assign(Object.assign({}, point), {
        x: 0,
        y: point.y,
        x1: 0,
        y1: point.y1,
        defined: !1 !== point.defined
    });
})), growPointsXIn = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    return {
        from: {
            points: changePointsX(graphic, options)
        },
        to: {
            points: attrs.points
        }
    };
}, growPointsXOut = (graphic, options, animationParameters) => ({
    from: {
        points: graphic.getFinalAttribute().points
    },
    to: {
        points: changePointsX(graphic, options)
    }
});

class GrowPointsXIn extends GworPointsBase {
    onBind() {
        var _a;
        if (super.onBind(), [ "area", "line", "polygon" ].includes(this.target.type)) {
            const {from: from, to: to} = growPointsXIn(this.target, this.params.options, this.params);
            this.props = to, this.propKeys = Object.keys(to).filter((key => null != to[key])), 
            this.from = from, this.to = to;
            const finalAttribute = this.target.getFinalAttribute();
            finalAttribute && this.target.setAttributes(finalAttribute), !1 !== (null === (_a = this.params.controlOptions) || void 0 === _a ? void 0 : _a.immediatelyApply) && this.target.setAttributes(from);
        } else this.valid = !1;
    }
}

exports.GrowPointsXIn = GrowPointsXIn;

class GrowPointsXOut extends GworPointsBase {
    onBind() {
        if (super.onBind(), [ "area", "line" ].includes(this.target.type)) {
            const attrs = this.target.getFinalAttribute(), {from: from, to: to} = (graphic = this.target, 
            options = this.params.options, this.params, {
                from: {
                    points: graphic.getFinalAttribute().points
                },
                to: {
                    points: changePointsX(graphic, options)
                }
            });
            this.props = to, this.propKeys = Object.keys(to).filter((key => null != to[key])), 
            this.from = from || attrs, this.to = to;
        } else this.valid = !1;
        var graphic, options;
    }
}

exports.GrowPointsXOut = GrowPointsXOut;

const changePointsY = (graphic, options, animationParameters) => graphic.getFinalAttribute().points.map((point => {
    if (options && "negative" === options.orient) {
        let groupBottom = graphic.stage.viewHeight;
        return graphic.parent.parent.parent && (groupBottom = graphic.parent.parent.parent.AABBBounds.height()), 
        Object.assign(Object.assign({}, point), {
            x: point.x,
            y: groupBottom,
            x1: point.x1,
            y1: groupBottom,
            defined: !1 !== point.defined
        });
    }
    return Object.assign(Object.assign({}, point), {
        x: point.x,
        y: 0,
        x1: point.x1,
        y1: 0,
        defined: !1 !== point.defined
    });
})), growPointsYIn = (graphic, options, animationParameters) => {
    const attrs = graphic.getFinalAttribute();
    return {
        from: {
            points: changePointsY(graphic, options)
        },
        to: {
            points: attrs.points
        }
    };
}, growPointsYOut = (graphic, options, animationParameters) => ({
    from: {
        points: graphic.getFinalAttribute().points
    },
    to: {
        points: changePointsY(graphic, options)
    }
});

class GrowPointsYIn extends GworPointsBase {
    onBind() {
        var _a;
        if (super.onBind(), [ "area", "line", "polygon" ].includes(this.target.type)) {
            const {from: from, to: to} = growPointsYIn(this.target, this.params.options, this.params);
            this.props = to, this.propKeys = Object.keys(to).filter((key => null != to[key])), 
            this.from = from, this.to = to;
            const finalAttribute = this.target.getFinalAttribute();
            finalAttribute && this.target.setAttributes(finalAttribute), !1 !== (null === (_a = this.params.controlOptions) || void 0 === _a ? void 0 : _a.immediatelyApply) && this.target.setAttributes(from);
        } else this.valid = !1;
    }
}

exports.GrowPointsYIn = GrowPointsYIn;

class GrowPointsYOut extends GworPointsBase {
    onBind() {
        if (super.onBind(), [ "area", "line", "polygon" ].includes(this.target.type)) {
            const {from: from, to: to} = (graphic = this.target, options = this.params.options, 
            this.params, {
                from: {
                    points: graphic.getFinalAttribute().points
                },
                to: {
                    points: changePointsY(graphic, options)
                }
            });
            this.props = to, this.propKeys = Object.keys(to).filter((key => null != to[key])), 
            this.from = null != from ? from : this.target.attribute, this.to = to;
        } else this.valid = !1;
        var graphic, options;
    }
}

exports.GrowPointsYOut = GrowPointsYOut;
//# sourceMappingURL=growPoints.js.map