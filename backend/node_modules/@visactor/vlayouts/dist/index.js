(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VUtils = {}));
})(this, (function (exports) { 'use strict';

  var eventemitter3 = {exports: {}};

  (function (module) {

    var has = Object.prototype.hasOwnProperty,
      prefix = '~';

    /**
     * Constructor to create a storage for our `EE` objects.
     * An `Events` instance is a plain object whose properties are event names.
     *
     * @constructor
     * @private
     */
    function Events() {}

    //
    // We try to not inherit from `Object.prototype`. In some engines creating an
    // instance in this way is faster than calling `Object.create(null)` directly.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // character to make sure that the built-in object properties are not
    // overridden or used as an attack vector.
    //
    if (Object.create) {
      Events.prototype = Object.create(null);

      //
      // This hack is needed because the `__proto__` property is still inherited in
      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
      //
      if (!new Events().__proto__) prefix = false;
    }

    /**
     * Representation of a single event listener.
     *
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
     * @constructor
     * @private
     */
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }

    /**
     * Add a listener for a given event.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} once Specify if the listener is a one-time listener.
     * @returns {EventEmitter}
     * @private
     */
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== 'function') {
        throw new TypeError('The listener must be a function');
      }
      var listener = new EE(fn, context || emitter, once),
        evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }

    /**
     * Clear event by name.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} evt The Event name.
     * @private
     */
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
    }

    /**
     * Minimal `EventEmitter` interface that is molded against the Node.js
     * `EventEmitter` interface.
     *
     * @constructor
     * @public
     */
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }

    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @public
     */
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [],
        events,
        name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };

    /**
     * Return the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Array} The registered listeners.
     * @public
     */
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event,
        handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };

    /**
     * Return the number of listeners listening to a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Number} The number of listeners.
     * @public
     */
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event,
        listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };

    /**
     * Calls each of the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Boolean} `true` if the event had listeners, else `false`.
     * @public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt],
        len = arguments.length,
        args,
        i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length,
          j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };

    /**
     * Add a listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };

    /**
     * Add a one-time listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };

    /**
     * Remove the listeners of a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn Only remove the listeners that match this function.
     * @param {*} context Only remove the listeners that have this context.
     * @param {Boolean} once Only remove one-time listeners.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }

        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
      }
      return this;
    };

    /**
     * Remove all listeners, or those of the specified event.
     *
     * @param {(String|Symbol)} [event] The event name.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };

    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;

    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;

    //
    // Allow `EventEmitter` to be imported as module namespace.
    //
    EventEmitter.EventEmitter = EventEmitter;

    //
    // Expose the module.
    //
    {
      module.exports = EventEmitter;
    }
  })(eventemitter3);

  const isType = (value, type) => Object.prototype.toString.call(value) === `[object ${type}]`;
  var isType$1 = isType;

  const isBoolean = function (value) {
    let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    return fuzzy ? "boolean" == typeof value : !0 === value || !1 === value || isType$1(value, "Boolean");
  };
  var isBoolean$1 = isBoolean;

  const isFunction = value => "function" == typeof value;
  var isFunction$1 = isFunction;

  const isNil = value => null == value;
  var isNil$1 = isNil;

  const isValid = value => null != value;
  var isValid$1 = isValid;

  const isObject = value => {
    const type = typeof value;
    return null !== value && "object" === type || "function" === type;
  };
  var isObject$1 = isObject;

  const isObjectLike = value => "object" == typeof value && null !== value;
  var isObjectLike$1 = isObjectLike;

  const isPlainObject = function (value) {
    if (!isObjectLike$1(value) || !isType$1(value, "Object")) return !1;
    if (null === Object.getPrototypeOf(value)) return !0;
    let proto = value;
    for (; null !== Object.getPrototypeOf(proto);) proto = Object.getPrototypeOf(proto);
    return Object.getPrototypeOf(value) === proto;
  };
  var isPlainObject$1 = isPlainObject;

  const isString = function (value) {
    let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    const type = typeof value;
    return fuzzy ? "string" === type : "string" === type || isType$1(value, "String");
  };
  var isString$1 = isString;

  const isArray = value => Array.isArray ? Array.isArray(value) : isType$1(value, "Array");
  var isArray$1 = isArray;

  const isArrayLike = function (value) {
    return null !== value && "function" != typeof value && Number.isFinite(value.length);
  };
  var isArrayLike$1 = isArrayLike;

  const isNumber = function (value) {
    let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    const type = typeof value;
    return fuzzy ? "number" === type : "number" === type || isType$1(value, "Number");
  };
  var isNumber$1 = isNumber;

  const isValidNumber = value => isNumber$1(value) && Number.isFinite(value);
  var isValidNumber$1 = isValidNumber;

  const isValidUrl = value => new RegExp(/^(http(s)?:\/\/)\w+[^\s]+(\.[^\s]+){1,}$/).test(value);
  var isValidUrl$1 = isValidUrl;

  const isBase64 = value => new RegExp(/^data:image\/(?:gif|png|jpeg|bmp|webp|svg\+xml)(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}/g).test(value);
  var isBase64$1 = isBase64;

  const getType = value => ({}).toString.call(value).replace(/^\[object /, "").replace(/]$/, "");
  var getType$1 = getType;

  const objectProto = Object.prototype,
    isPrototype = function (value) {
      const Ctor = value && value.constructor;
      return value === ("function" == typeof Ctor && Ctor.prototype || objectProto);
    };
  var isPrototype$1 = isPrototype;

  const hasOwnProperty = Object.prototype.hasOwnProperty;
  function isEmpty(value) {
    if (isNil$1(value)) return !0;
    if (isArrayLike$1(value)) return !value.length;
    const type = getType$1(value);
    if ("Map" === type || "Set" === type) return !value.size;
    if (isPrototype$1(value)) return !Object.keys(value).length;
    for (const key in value) if (hasOwnProperty.call(value, key)) return !1;
    return !0;
  }

  const get = (obj, path, defaultValue) => {
    const paths = isString$1(path) ? path.split(".") : path;
    for (let p = 0; p < paths.length; p++) obj = obj ? obj[paths[p]] : void 0;
    return void 0 === obj ? defaultValue : obj;
  };
  var get$1 = get;

  function baseMerge(target, source) {
    let shallowArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    let skipTargetArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    if (source) {
      if (target === source) return;
      if (isValid$1(source) && "object" == typeof source) {
        const iterable = Object(source),
          props = [];
        for (const key in iterable) props.push(key);
        let {
            length: length
          } = props,
          propIndex = -1;
        for (; length--;) {
          const key = props[++propIndex];
          !isValid$1(iterable[key]) || "object" != typeof iterable[key] || skipTargetArray && isArray$1(target[key]) ? assignMergeValue(target, key, iterable[key]) : baseMergeDeep(target, source, key, shallowArray, skipTargetArray);
        }
      }
    }
  }
  function baseMergeDeep(target, source, key) {
    let shallowArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    let skipTargetArray = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    const objValue = target[key],
      srcValue = source[key];
    let newValue = source[key],
      isCommon = !0;
    if (isArray$1(srcValue)) {
      if (shallowArray) newValue = [];else if (isArray$1(objValue)) newValue = objValue;else if (isArrayLike$1(objValue)) {
        newValue = new Array(objValue.length);
        let index = -1;
        const length = objValue.length;
        for (; ++index < length;) newValue[index] = objValue[index];
      }
    } else isPlainObject$1(srcValue) ? (newValue = null != objValue ? objValue : {}, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = !1;
    isCommon && baseMerge(newValue, srcValue, shallowArray, skipTargetArray), assignMergeValue(target, key, newValue);
  }
  function assignMergeValue(target, key, value) {
    (void 0 !== value && !eq(target[key], value) || void 0 === value && !(key in target)) && (target[key] = value);
  }
  function eq(value, other) {
    return value === other || Number.isNaN(value) && Number.isNaN(other);
  }
  function merge(target) {
    let sourceIndex = -1;
    const length = arguments.length <= 1 ? 0 : arguments.length - 1;
    for (; ++sourceIndex < length;) {
      baseMerge(target, sourceIndex + 1 < 1 || arguments.length <= sourceIndex + 1 ? undefined : arguments[sourceIndex + 1], !0);
    }
    return target;
  }

  function pickWithout(obj, keys) {
    if (!obj || !isPlainObject$1(obj)) return obj;
    const result = {};
    return Object.keys(obj).forEach(k => {
      const v = obj[k];
      let match = !1;
      keys.forEach(itKey => {
        (isString$1(itKey) && itKey === k || itKey instanceof RegExp && k.match(itKey)) && (match = !0);
      }), match || (result[k] = v);
    }), result;
  }

  function array(arr) {
    return isValid$1(arr) ? isArray$1(arr) ? arr : [arr] : [];
  }
  const maxInArray = (arr, compareFn) => {
    var _a;
    if (0 === arr.length) return;
    let max = arr[0];
    for (let i = 1; i < arr.length; i++) {
      const value = arr[i];
      (null !== (_a = null == compareFn ? void 0 : compareFn(value, max)) && void 0 !== _a ? _a : value - max) > 0 && (max = value);
    }
    return max;
  };
  const minInArray = (arr, compareFn) => {
    var _a;
    if (0 === arr.length) return;
    let min = arr[0];
    for (let i = 1; i < arr.length; i++) {
      const value = arr[i];
      (null !== (_a = null == compareFn ? void 0 : compareFn(value, min)) && void 0 !== _a ? _a : value - min) < 0 && (min = value);
    }
    return min;
  };
  function shuffleArray(arr) {
    let random = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.random;
    let j,
      x,
      i = arr.length;
    for (; i;) j = Math.floor(random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x;
    return arr;
  }

  function range(start, stop, step) {
    isValid$1(stop) || (stop = start, start = 0), isValid$1(step) || (step = 1);
    let i = -1;
    const n = 0 | Math.max(0, Math.ceil((stop - start) / step)),
      range = new Array(n);
    for (; ++i < n;) range[i] = start + i * step;
    return range;
  }

  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  function toNumber(a) {
    return Number(a);
  }

  const hasConsole = "undefined" != typeof console;
  function log(method, level, input) {
    const args = [level].concat([].slice.call(input));
    hasConsole && console[method].apply(console, args);
  }
  var LoggerLevel;
  !function (LoggerLevel) {
    LoggerLevel[LoggerLevel.None = 0] = "None", LoggerLevel[LoggerLevel.Error = 1] = "Error", LoggerLevel[LoggerLevel.Warn = 2] = "Warn", LoggerLevel[LoggerLevel.Info = 3] = "Info", LoggerLevel[LoggerLevel.Debug = 4] = "Debug";
  }(LoggerLevel || (LoggerLevel = {}));
  class Logger {
    static getInstance(level, method) {
      return Logger._instance && isNumber$1(level) ? Logger._instance.level(level) : Logger._instance || (Logger._instance = new Logger(level, method)), Logger._instance;
    }
    static setInstance(logger) {
      return Logger._instance = logger;
    }
    static setInstanceLevel(level) {
      Logger._instance ? Logger._instance.level(level) : Logger._instance = new Logger(level);
    }
    static clearInstance() {
      Logger._instance = null;
    }
    constructor() {
      let level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LoggerLevel.None;
      let method = arguments.length > 1 ? arguments[1] : undefined;
      this._onErrorHandler = [], this._level = level, this._method = method;
    }
    addErrorHandler(handler) {
      this._onErrorHandler.find(h => h === handler) || this._onErrorHandler.push(handler);
    }
    removeErrorHandler(handler) {
      const index = this._onErrorHandler.findIndex(h => h === handler);
      index < 0 || this._onErrorHandler.splice(index, 1);
    }
    callErrorHandler() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      this._onErrorHandler.forEach(h => h(...args));
    }
    canLogInfo() {
      return this._level >= LoggerLevel.Info;
    }
    canLogDebug() {
      return this._level >= LoggerLevel.Debug;
    }
    canLogError() {
      return this._level >= LoggerLevel.Error;
    }
    canLogWarn() {
      return this._level >= LoggerLevel.Warn;
    }
    level(levelValue) {
      return arguments.length ? (this._level = +levelValue, this) : this._level;
    }
    error() {
      var _a;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this._level >= LoggerLevel.Error && (this._onErrorHandler.length ? this.callErrorHandler(...args) : log(null !== (_a = this._method) && void 0 !== _a ? _a : "error", "ERROR", args)), this;
    }
    warn() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this._level >= LoggerLevel.Warn && log(this._method || "warn", "WARN", args), this;
    }
    info() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this._level >= LoggerLevel.Info && log(this._method || "log", "INFO", args), this;
    }
    debug() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return this._level >= LoggerLevel.Debug && log(this._method || "log", "DEBUG", args), this;
    }
  }
  Logger._instance = null;

  function bisect(a, x) {
    let lo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let hi = arguments.length > 3 ? arguments[3] : undefined;
    for (isNil$1(hi) && (hi = a.length); lo < hi;) {
      const mid = lo + hi >>> 1;
      ascending(a[mid], x) > 0 ? hi = mid : lo = mid + 1;
    }
    return lo;
  }
  function findZeroOfFunction(f, a, b, parameters) {
    var _a, _b;
    const maxIterations = null !== (_a = null == parameters ? void 0 : parameters.maxIterations) && void 0 !== _a ? _a : 100,
      tolerance = null !== (_b = null == parameters ? void 0 : parameters.tolerance) && void 0 !== _b ? _b : 1e-10,
      fA = f(a),
      fB = f(b);
    let delta = b - a;
    if (fA * fB > 0) {
      return Logger.getInstance().error("Initial bisect points must have opposite signs"), NaN;
    }
    if (0 === fA) return a;
    if (0 === fB) return b;
    for (let i = 0; i < maxIterations; ++i) {
      delta /= 2;
      const mid = a + delta,
        fMid = f(mid);
      if (fMid * fA >= 0 && (a = mid), Math.abs(delta) < tolerance || 0 === fMid) return mid;
    }
    return a + delta;
  }

  const memoize = func => {
    let lastArgs = null,
      lastResult = null;
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return lastArgs && args.every((val, i) => val === lastArgs[i]) || (lastArgs = args, lastResult = func(...args)), lastResult;
    };
  };

  const clamp = function (input, min, max) {
    return input < min ? min : input > max ? max : input;
  };
  var clamp$1 = clamp;

  function clamper(a, b) {
    let t;
    return a > b && (t = a, a = b, b = t), x => Math.max(a, Math.min(b, x));
  }

  function interpolateNumber(a, b) {
    return t => a * (1 - t) + b * t;
  }
  function interpolateNumberRound(a, b) {
    return function (t) {
      return Math.round(a * (1 - t) + b * t);
    };
  }
  function interpolateDate(a, b) {
    const aVal = a.valueOf(),
      bVal = b.valueOf(),
      d = new Date();
    return t => (d.setTime(aVal * (1 - t) + bVal * t), d);
  }

  function toValidNumber(v) {
    if (isValidNumber$1(v)) return v;
    const value = +v;
    return isValidNumber$1(value) ? value : 0;
  }

  function seedRandom(seed) {
    return parseFloat("0." + Math.sin(seed).toString().substring(6));
  }
  const a = 1664525,
    c = 1013904223,
    m = 4294967296;
  function randomLCG() {
    let initS = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    let s = initS;
    return () => (s = (a * s + c) % m) / m;
  }
  const fakeRandom = () => {
    let i = -1;
    const arr = [0, .1, .2, .3, .4, .5, .6, .7, .8, .9];
    return () => (i = (i + 1) % arr.length, arr[i]);
  };

  const getter = path => obj => get$1(obj, path);
  const fieldSingle = function (fieldStr) {
    let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (isFunction$1(fieldStr)) return fieldStr;
    const path = [fieldStr];
    return (opt && opt.get || getter)(path);
  };
  const field$1 = function (fieldStr) {
    let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (isArray$1(fieldStr)) {
      const funcs = fieldStr.map(entry => fieldSingle(entry, opt));
      return datum => funcs.map(func => func(datum));
    }
    return fieldSingle(fieldStr, opt);
  };
  const simpleField = option => option ? "string" == typeof option || "number" == typeof option ? () => option : isFunction$1(option) ? option : datum => datum[option.field] : null;

  const toPercent = (percent, total) => isNil$1(percent) ? total : isString$1(percent) ? total * parseFloat(percent) / 100 : percent;

  const zero = _ => 0;

  const extent$2 = (array, func) => {
    const valueGetter = isFunction$1(func) ? func : val => val;
    let min, max;
    if (array && array.length) {
      const n = array.length;
      for (let i = 0; i < n; i += 1) {
        let value = valueGetter(array[i]);
        isNil$1(value) || !isNumber$1(value = +value) || Number.isNaN(value) || (isNil$1(min) ? (min = value, max = value) : (min = Math.min(min, value), max = Math.max(max, value)));
      }
      return [min, max];
    }
    return [min, max];
  };

  const sqrt$2 = Math.sqrt;
  const pow = Math.pow;
  function crossProduct(dir1, dir2) {
    return dir1[0] * dir2[1] - dir1[1] * dir2[0];
  }
  function dotProduct(a, b) {
    let ret = 0;
    for (let i = 0; i < a.length; ++i) ret += a[i] * b[i];
    return ret;
  }

  class Point {
    constructor() {
      let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      let x1 = arguments.length > 2 ? arguments[2] : undefined;
      let y1 = arguments.length > 3 ? arguments[3] : undefined;
      this.x = 0, this.y = 0, this.x = x, this.y = y, this.x1 = x1, this.y1 = y1;
    }
    clone() {
      return new Point(this.x, this.y);
    }
    copyFrom(p) {
      return this.x = p.x, this.y = p.y, this.x1 = p.x1, this.y1 = p.y1, this.defined = p.defined, this.context = p.context, this;
    }
    set(x, y) {
      return this.x = x, this.y = y, this;
    }
    add(point) {
      return isNumber$1(point) ? (this.x += point, void (this.y += point)) : (this.x += point.x, this.y += point.y, this);
    }
    sub(point) {
      return isNumber$1(point) ? (this.x -= point, void (this.y -= point)) : (this.x -= point.x, this.y -= point.y, this);
    }
    multi(point) {
      throw new Error("暂不支持");
    }
    div(point) {
      throw new Error("暂不支持");
    }
  }
  class PointService {
    static distancePP(p1, p2) {
      return sqrt$2(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
    }
    static distanceNN(x, y, x1, y1) {
      return sqrt$2(pow(x - x1, 2) + pow(y - y1, 2));
    }
    static distancePN(point, x, y) {
      return sqrt$2(pow(x - point.x, 2) + pow(y - point.y, 2));
    }
    static pointAtPP(p1, p2, t) {
      return new Point((p2.x - p1.x) * t + p1.x, (p2.y - p1.y) * t + p1.y);
    }
  }

  function degreeToRadian(degree) {
    return degree * (Math.PI / 180);
  }
  function polarToCartesian(center, radius, angleInRadian) {
    return radius ? {
      x: center.x + radius * Math.cos(angleInRadian),
      y: center.y + radius * Math.sin(angleInRadian)
    } : {
      x: center.x,
      y: center.y
    };
  }

  function hslToRgb(h, s, l) {
    s /= 100, l /= 100;
    const c = (1 - Math.abs(2 * l - 1)) * s,
      x = c * (1 - Math.abs(h / 60 % 2 - 1)),
      m = l - c / 2;
    let r = 0,
      g = 0,
      b = 0;
    return 0 <= h && h < 60 ? (r = c, g = x, b = 0) : 60 <= h && h < 120 ? (r = x, g = c, b = 0) : 120 <= h && h < 180 ? (r = 0, g = c, b = x) : 180 <= h && h < 240 ? (r = 0, g = x, b = c) : 240 <= h && h < 300 ? (r = x, g = 0, b = c) : 300 <= h && h < 360 && (r = c, g = 0, b = x), r = Math.round(255 * (r + m)), g = Math.round(255 * (g + m)), b = Math.round(255 * (b + m)), {
      r: r,
      g: g,
      b: b
    };
  }

  function rgbToHsl(r, g, b) {
    r /= 255, g /= 255, b /= 255;
    const cMin = Math.min(r, g, b),
      cMax = Math.max(r, g, b),
      delta = cMax - cMin;
    let h = 0,
      s = 0,
      l = 0;
    return h = 0 === delta ? 0 : cMax === r ? (g - b) / delta % 6 : cMax === g ? (b - r) / delta + 2 : (r - g) / delta + 4, h = Math.round(60 * h), h < 0 && (h += 360), l = (cMax + cMin) / 2, s = 0 === delta ? 0 : delta / (1 - Math.abs(2 * l - 1)), s = +(100 * s).toFixed(1), l = +(100 * l).toFixed(1), {
      h: h,
      s: s,
      l: l
    };
  }

  const REG_HEX = /^#([0-9a-f]{3,8})$/,
    DEFAULT_COLORS_OPACITY = {
      transparent: 4294967040
    };
  const DEFAULT_COLORS = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  function hex(value) {
    return ((value = Math.max(0, Math.min(255, Math.round(value) || 0))) < 16 ? "0" : "") + value.toString(16);
  }
  function rgb(value) {
    return isNumber$1(value) ? new RGB(value >> 16, value >> 8 & 255, 255 & value, 1) : isArray$1(value) ? new RGB(value[0], value[1], value[2]) : new RGB(255, 255, 255);
  }
  function rgba(value) {
    return isNumber$1(value) ? new RGB(value >>> 24, value >>> 16 & 255, value >>> 8 & 255, 255 & value) : isArray$1(value) ? new RGB(value[0], value[1], value[2], value[3]) : new RGB(255, 255, 255, 1);
  }
  function SRGBToLinear(c) {
    return c < .04045 ? .0773993808 * c : Math.pow(.9478672986 * c + .0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < .0031308 ? 12.92 * c : 1.055 * Math.pow(c, .41666) - .055;
  }
  const setHex = (formatValue, forceHex) => {
    const isHex = REG_HEX.exec(formatValue);
    if (forceHex || isHex) {
      const hex = parseInt(isHex[1], 16),
        hexLength = isHex[1].length;
      return 3 === hexLength ? new RGB((hex >> 8 & 15) + ((hex >> 8 & 15) << 4), (hex >> 4 & 15) + ((hex >> 4 & 15) << 4), (15 & hex) + ((15 & hex) << 4), 1) : 6 === hexLength ? rgb(hex) : 8 === hexLength ? new RGB(hex >> 24 & 255, hex >> 16 & 255, hex >> 8 & 255, (255 & hex) / 255) : null;
    }
  };
  class Color {
    static Brighter(source) {
      let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return 1 === b ? source : new Color(source).brighter(b).toRGBA();
    }
    static SetOpacity(source) {
      let o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return 1 === o ? source : new Color(source).setOpacity(o).toRGBA();
    }
    static getColorBrightness(source) {
      let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hsl";
      const color = source instanceof Color ? source : new Color(source);
      switch (model) {
        case "hsv":
        default:
          return color.getHSVBrightness();
        case "hsl":
          return color.getHSLBrightness();
        case "lum":
          return color.getLuminance();
        case "lum2":
          return color.getLuminance2();
        case "lum3":
          return color.getLuminance3();
        case "wcag":
          return color.getLuminanceWCAG();
      }
    }
    static parseColorString(value) {
      if (isValid$1(DEFAULT_COLORS_OPACITY[value])) return rgba(DEFAULT_COLORS_OPACITY[value]);
      if (isValid$1(DEFAULT_COLORS[value])) return rgb(DEFAULT_COLORS[value]);
      const formatValue = `${value}`.trim().toLowerCase(),
        hexRes = setHex(formatValue);
      if (void 0 !== hexRes) return hexRes;
      if (/^(rgb|RGB|rgba|RGBA)/.test(formatValue)) {
        const aColor = formatValue.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
        return new RGB(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10), parseFloat(aColor[3]));
      }
      if (/^(hsl|HSL|hsla|HSLA)/.test(formatValue)) {
        const aColor = formatValue.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","),
          rgb = hslToRgb(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10));
        return new RGB(rgb.r, rgb.g, rgb.b, parseFloat(aColor[3]));
      }
    }
    constructor(value) {
      const color = Color.parseColorString(value);
      color ? this.color = color : (console.warn(`Warn: 传入${value}无法解析为Color`), this.color = new RGB(255, 255, 255));
    }
    toRGBA() {
      return this.color.formatRgb();
    }
    toString() {
      return this.color.formatRgb();
    }
    toHex() {
      return this.color.formatHex();
    }
    toHsl() {
      return this.color.formatHsl();
    }
    brighter(k) {
      const {
        r: r,
        g: g,
        b: b
      } = this.color;
      return this.color.r = Math.max(0, Math.min(255, Math.floor(r * k))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * k))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * k))), this;
    }
    add(color) {
      const {
        r: r,
        g: g,
        b: b
      } = this.color;
      return this.color.r += Math.min(255, r + color.color.r), this.color.g += Math.min(255, g + color.color.g), this.color.b += Math.min(255, b + color.color.b), this;
    }
    sub(color) {
      return this.color.r = Math.max(0, this.color.r - color.color.r), this.color.g = Math.max(0, this.color.g - color.color.g), this.color.b = Math.max(0, this.color.b - color.color.b), this;
    }
    multiply(color) {
      const {
        r: r,
        g: g,
        b: b
      } = this.color;
      return this.color.r = Math.max(0, Math.min(255, Math.floor(r * color.color.r))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * color.color.g))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * color.color.b))), this;
    }
    getHSVBrightness() {
      return Math.max(this.color.r, this.color.g, this.color.b) / 255;
    }
    getHSLBrightness() {
      return .5 * (Math.max(this.color.r, this.color.g, this.color.b) / 255 + Math.min(this.color.r, this.color.g, this.color.b) / 255);
    }
    setHsl(h, s, l) {
      const opacity = this.color.opacity,
        hsl = rgbToHsl(this.color.r, this.color.g, this.color.b),
        rgb = hslToRgb(isNil$1(h) ? hsl.h : clamp$1(h, 0, 360), isNil$1(s) ? hsl.s : s >= 0 && s <= 1 ? 100 * s : s, isNil$1(l) ? hsl.l : l <= 1 && l >= 0 ? 100 * l : l);
      return this.color = new RGB(rgb.r, rgb.g, rgb.b, opacity), this;
    }
    setRGB(r, g, b) {
      return !isNil$1(r) && (this.color.r = r), !isNil$1(g) && (this.color.g = g), !isNil$1(b) && (this.color.b = b), this;
    }
    setHex(value) {
      const formatValue = `${value}`.trim().toLowerCase(),
        res = setHex(formatValue, !0);
      return null != res ? res : this;
    }
    setColorName(name) {
      const hex = DEFAULT_COLORS[name.toLowerCase()];
      return void 0 !== hex ? this.setHex(hex) : console.warn("THREE.Color: Unknown color " + name), this;
    }
    setScalar(scalar) {
      return this.color.r = scalar, this.color.g = scalar, this.color.b = scalar, this;
    }
    setOpacity() {
      let o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return this.color.opacity = o, this;
    }
    getLuminance() {
      return (.2126 * this.color.r + .7152 * this.color.g + .0722 * this.color.b) / 255;
    }
    getLuminance2() {
      return (.2627 * this.color.r + .678 * this.color.g + .0593 * this.color.b) / 255;
    }
    getLuminance3() {
      return (.299 * this.color.r + .587 * this.color.g + .114 * this.color.b) / 255;
    }
    getLuminanceWCAG() {
      const RsRGB = this.color.r / 255,
        GsRGB = this.color.g / 255,
        BsRGB = this.color.b / 255;
      let R, G, B;
      R = RsRGB <= .03928 ? RsRGB / 12.92 : Math.pow((RsRGB + .055) / 1.055, 2.4), G = GsRGB <= .03928 ? GsRGB / 12.92 : Math.pow((GsRGB + .055) / 1.055, 2.4), B = BsRGB <= .03928 ? BsRGB / 12.92 : Math.pow((BsRGB + .055) / 1.055, 2.4);
      return .2126 * R + .7152 * G + .0722 * B;
    }
    clone() {
      return new Color(this.color.toString());
    }
    copyGammaToLinear(color) {
      let gammaFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      return this.color.r = Math.pow(color.color.r, gammaFactor), this.color.g = Math.pow(color.color.g, gammaFactor), this.color.b = Math.pow(color.color.b, gammaFactor), this;
    }
    copyLinearToGamma(color) {
      let gammaFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
      return this.color.r = Math.pow(color.color.r, safeInverse), this.color.g = Math.pow(color.color.g, safeInverse), this.color.b = Math.pow(color.color.b, safeInverse), this;
    }
    convertGammaToLinear(gammaFactor) {
      return this.copyGammaToLinear(this, gammaFactor), this;
    }
    convertLinearToGamma(gammaFactor) {
      return this.copyLinearToGamma(this, gammaFactor), this;
    }
    copySRGBToLinear(color) {
      return this.color.r = SRGBToLinear(color.color.r), this.color.g = SRGBToLinear(color.color.g), this.color.b = SRGBToLinear(color.color.b), this;
    }
    copyLinearToSRGB(color) {
      return this.color.r = LinearToSRGB(color.color.r), this.color.g = LinearToSRGB(color.color.g), this.color.b = LinearToSRGB(color.color.b), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
  }
  class RGB {
    constructor(r, g, b, opacity) {
      this.r = isNaN(+r) ? 255 : Math.max(0, Math.min(255, +r)), this.g = isNaN(+g) ? 255 : Math.max(0, Math.min(255, +g)), this.b = isNaN(+b) ? 255 : Math.max(0, Math.min(255, +b)), isValid$1(opacity) ? this.opacity = isNaN(+opacity) ? 1 : Math.max(0, Math.min(1, +opacity)) : this.opacity = 1;
    }
    formatHex() {
      return `#${hex(this.r) + hex(this.g) + hex(this.b) + (1 === this.opacity ? "" : hex(255 * this.opacity))}`;
    }
    formatRgb() {
      const opacity = this.opacity;
      return `${1 === opacity ? "rgb(" : "rgba("}${this.r},${this.g},${this.b}${1 === opacity ? ")" : `,${opacity})`}`;
    }
    formatHsl() {
      const opacity = this.opacity,
        {
          h: h,
          s: s,
          l: l
        } = rgbToHsl(this.r, this.g, this.b);
      return `${1 === opacity ? "hsl(" : "hsla("}${h},${s}%,${l}%${1 === opacity ? ")" : `,${opacity})`}`;
    }
    toString() {
      return this.formatHex();
    }
  }

  function hexToRgb(str) {
    let r = "",
      g = "",
      b = "";
    const strtIndex = "#" === str[0] ? 1 : 0;
    for (let i = strtIndex; i < str.length; i++) "#" !== str[i] && (i < strtIndex + 2 ? r += str[i] : i < strtIndex + 4 ? g += str[i] : i < strtIndex + 6 && (b += str[i]));
    return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
  }

  function rgbToHex(r, g, b) {
    return Number((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  function interpolateRgb$1(colorA, colorB) {
    const redA = colorA.r,
      redB = colorB.r,
      greenA = colorA.g,
      greenB = colorB.g,
      blueA = colorA.b,
      blueB = colorB.b,
      opacityA = colorA.opacity,
      opacityB = colorB.opacity;
    return t => {
      const r = Math.round(redA * (1 - t) + redB * t),
        g = Math.round(greenA * (1 - t) + greenB * t),
        b = Math.round(blueA * (1 - t) + blueB * t);
      return new RGB(r, g, b, opacityA * (1 - t) + opacityB * t);
    };
  }

  var ColorUtil = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Color: Color,
    DEFAULT_COLORS: DEFAULT_COLORS,
    RGB: RGB,
    hexToRgb: hexToRgb,
    hslToRgb: hslToRgb,
    interpolateRgb: interpolateRgb$1,
    rgbToHex: rgbToHex,
    rgbToHsl: rgbToHsl
  });

  const SMALL = 1e-10;

  function intersectionArea(circles, stats) {
    const intersectionPoints = getIntersectionPoints(circles),
      innerPoints = intersectionPoints.filter(function (p) {
        return containedInCircles(p, circles);
      });
    let arcArea = 0,
      polygonArea = 0;
    const arcs = [];
    if (innerPoints.length > 1) {
      const center = getCenter(innerPoints);
      for (let i = 0; i < innerPoints.length; ++i) {
        const p = innerPoints[i];
        p.angle = Math.atan2(p.x - center.x, p.y - center.y);
      }
      innerPoints.sort(function (a, b) {
        return b.angle - a.angle;
      });
      let p2 = innerPoints[innerPoints.length - 1];
      for (let i = 0; i < innerPoints.length; ++i) {
        const p1 = innerPoints[i];
        polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
        const midPoint = {
          x: (p1.x + p2.x) / 2,
          y: (p1.y + p2.y) / 2
        };
        let arc = null;
        for (let j = 0; j < p1.parentIndex.length; ++j) if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
          const circle = circles[p1.parentIndex[j]],
            a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),
            a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);
          let angleDiff = a2 - a1;
          angleDiff < 0 && (angleDiff += 2 * Math.PI);
          const a = a2 - angleDiff / 2;
          let width = PointService.distancePP(midPoint, {
            x: circle.x + circle.radius * Math.sin(a),
            y: circle.y + circle.radius * Math.cos(a)
          });
          width > 2 * circle.radius && (width = 2 * circle.radius), (null === arc || arc.width > width) && (arc = {
            circle: circle,
            width: width,
            p1: p1,
            p2: p2
          });
        }
        null !== arc && (arcs.push(arc), arcArea += circleArea(arc.circle.radius, arc.width), p2 = p1);
      }
    } else {
      let smallest = circles[0];
      for (let i = 1; i < circles.length; ++i) circles[i].radius < smallest.radius && (smallest = circles[i]);
      let disjoint = !1;
      for (let i = 0; i < circles.length; ++i) if (PointService.distancePP(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
        disjoint = !0;
        break;
      }
      disjoint ? arcArea = polygonArea = 0 : (arcArea = smallest.radius * smallest.radius * Math.PI, arcs.push({
        circle: smallest,
        p1: {
          x: smallest.x,
          y: smallest.y + smallest.radius
        },
        p2: {
          x: smallest.x - SMALL,
          y: smallest.y + smallest.radius
        },
        width: 2 * smallest.radius
      }));
    }
    return polygonArea /= 2, stats && (stats.area = arcArea + polygonArea, stats.arcArea = arcArea, stats.polygonArea = polygonArea, stats.arcs = arcs, stats.innerPoints = innerPoints, stats.intersectionPoints = intersectionPoints), arcArea + polygonArea;
  }
  function containedInCircles(point, circles) {
    for (let i = 0; i < circles.length; ++i) if (PointService.distancePP(point, circles[i]) > circles[i].radius + SMALL) return !1;
    return !0;
  }
  function getIntersectionPoints(circles) {
    const ret = [];
    for (let i = 0; i < circles.length; ++i) for (let j = i + 1; j < circles.length; ++j) {
      const intersect = circleCircleIntersection(circles[i], circles[j]);
      for (let k = 0; k < intersect.length; ++k) {
        const p = intersect[k];
        p.parentIndex = [i, j], ret.push(p);
      }
    }
    return ret;
  }
  function circleArea(r, width) {
    return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
  }
  function circleOverlap(r1, r2, d) {
    if (d >= r1 + r2) return 0;
    if (d <= Math.abs(r1 - r2)) return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
    const w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
    return circleArea(r1, r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d)) + circleArea(r2, w2);
  }
  function circleCircleIntersection(p1, p2) {
    const d = PointService.distancePP(p1, p2),
      r1 = p1.radius,
      r2 = p2.radius;
    if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) return [];
    const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),
      h = Math.sqrt(r1 * r1 - a * a),
      x0 = p1.x + a * (p2.x - p1.x) / d,
      y0 = p1.y + a * (p2.y - p1.y) / d,
      rx = -(p2.y - p1.y) * (h / d),
      ry = -(p2.x - p1.x) * (h / d);
    return [{
      x: x0 + rx,
      y: y0 - ry
    }, {
      x: x0 - rx,
      y: y0 + ry
    }];
  }
  function getCenter(points) {
    const center = {
      x: 0,
      y: 0
    };
    for (let i = 0; i < points.length; ++i) center.x += points[i].x, center.y += points[i].y;
    return center.x /= points.length, center.y /= points.length, center;
  }

  function zeros(x) {
    const r = new Array(x);
    for (let i = 0; i < x; ++i) r[i] = 0;
    return r;
  }
  function zerosM(x, y) {
    return zeros(x).map(function () {
      return zeros(y);
    });
  }
  function norm2(a) {
    return Math.sqrt(dotProduct(a, a));
  }
  function scale(ret, value, c) {
    for (let i = 0; i < value.length; ++i) ret[i] = value[i] * c;
  }
  function weightedSum(ret, w1, v1, w2, v2) {
    for (let j = 0; j < ret.length; ++j) ret[j] = w1 * v1[j] + w2 * v2[j];
  }

  function nelderMead(f, x0, parameters) {
    const maxIterations = (parameters = parameters || {}).maxIterations || 200 * x0.length,
      nonZeroDelta = parameters.nonZeroDelta || 1.05,
      zeroDelta = parameters.zeroDelta || .001,
      minErrorDelta = parameters.minErrorDelta || 1e-6,
      minTolerance = parameters.minErrorDelta || 1e-5,
      rho = void 0 !== parameters.rho ? parameters.rho : 1,
      chi = void 0 !== parameters.chi ? parameters.chi : 2,
      psi = void 0 !== parameters.psi ? parameters.psi : -.5,
      sigma = void 0 !== parameters.sigma ? parameters.sigma : .5;
    let maxDiff;
    const N = x0.length,
      simplex = new Array(N + 1);
    simplex[0] = x0, simplex[0].fx = f(x0), simplex[0].id = 0;
    for (let i = 0; i < N; ++i) {
      const point = x0.slice();
      point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta, simplex[i + 1] = point, simplex[i + 1].fx = f(point), simplex[i + 1].id = i + 1;
    }
    function updateSimplex(value) {
      for (let i = 0; i < value.length; i++) simplex[N][i] = value[i];
      simplex[N].fx = value.fx;
    }
    const sortOrder = function (a, b) {
        return a.fx - b.fx;
      },
      centroid = x0.slice(),
      reflected = x0.slice(),
      contracted = x0.slice(),
      expanded = x0.slice();
    for (let iteration = 0; iteration < maxIterations; ++iteration) {
      if (simplex.sort(sortOrder), parameters.history) {
        const sortedSimplex = simplex.map(function (x) {
          const state = x.slice();
          return state.fx = x.fx, state.id = x.id, state;
        });
        sortedSimplex.sort(function (a, b) {
          return a.id - b.id;
        }), parameters.history.push({
          x: simplex[0].slice(),
          fx: simplex[0].fx,
          simplex: sortedSimplex
        });
      }
      maxDiff = 0;
      for (let i = 0; i < N; ++i) maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
      if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) break;
      for (let i = 0; i < N; ++i) {
        centroid[i] = 0;
        for (let j = 0; j < N; ++j) centroid[i] += simplex[j][i];
        centroid[i] /= N;
      }
      const worst = simplex[N];
      if (weightedSum(reflected, 1 + rho, centroid, -rho, worst), reflected.fx = f(reflected), reflected.fx < simplex[0].fx) weightedSum(expanded, 1 + chi, centroid, -chi, worst), expanded.fx = f(expanded), expanded.fx < reflected.fx ? updateSimplex(expanded) : updateSimplex(reflected);else if (reflected.fx >= simplex[N - 1].fx) {
        let shouldReduce = !1;
        if (reflected.fx > worst.fx ? (weightedSum(contracted, 1 + psi, centroid, -psi, worst), contracted.fx = f(contracted), contracted.fx < worst.fx ? updateSimplex(contracted) : shouldReduce = !0) : (weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst), contracted.fx = f(contracted), contracted.fx < reflected.fx ? updateSimplex(contracted) : shouldReduce = !0), shouldReduce) {
          if (sigma >= 1) break;
          for (let i = 1; i < simplex.length; ++i) weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]), simplex[i].fx = f(simplex[i]);
        }
      } else updateSimplex(reflected);
    }
    return simplex.sort(sortOrder), {
      fx: simplex[0].fx,
      x: simplex[0]
    };
  }

  function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
    const phi0 = current.fx,
      phiPrime0 = dotProduct(current.fxprime, pk);
    let phi = phi0,
      phi_old = phi0,
      phiPrime = phiPrime0,
      a0 = 0;
    function zoom(a_lo, a_high, phi_lo) {
      for (let iteration = 0; iteration < 16; ++iteration) if (a = (a_lo + a_high) / 2, weightedSum(next.x, 1, current.x, a, pk), phi = next.fx = f(next.x, next.fxprime), phiPrime = dotProduct(next.fxprime, pk), phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) a_high = a;else {
        if (Math.abs(phiPrime) <= -c2 * phiPrime0) return a;
        phiPrime * (a_high - a_lo) >= 0 && (a_high = a_lo), a_lo = a, phi_lo = phi;
      }
      return 0;
    }
    a = a || 1, c1 = c1 || 1e-6, c2 = c2 || .1;
    for (let iteration = 0; iteration < 10; ++iteration) {
      if (weightedSum(next.x, 1, current.x, a, pk), phi = next.fx = f(next.x, next.fxprime), phiPrime = dotProduct(next.fxprime, pk), phi > phi0 + c1 * a * phiPrime0 || iteration && phi >= phi_old) return zoom(a0, a, phi_old);
      if (Math.abs(phiPrime) <= -c2 * phiPrime0) return a;
      if (phiPrime >= 0) return zoom(a, a0, phi);
      phi_old = phi, a0 = a, a *= 2;
    }
    return a;
  }

  function conjugateGradient(f, initial, params) {
    let current = {
        x: initial.slice(),
        fx: 0,
        fxprime: initial.slice()
      },
      next = {
        x: initial.slice(),
        fx: 0,
        fxprime: initial.slice()
      };
    const yk = initial.slice();
    let temp,
      a = 1;
    const maxIterations = (params = params || {}).maxIterations || 20 * initial.length;
    current.fx = f(current.x, current.fxprime);
    const pk = current.fxprime.slice();
    scale(pk, current.fxprime, -1);
    for (let i = 0; i < maxIterations; ++i) {
      if (a = wolfeLineSearch(f, pk, current, next, a), params.history && params.history.push({
        x: current.x.slice(),
        fx: current.fx,
        fxprime: current.fxprime.slice(),
        alpha: a
      }), a) {
        weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
        const delta_k = dotProduct(current.fxprime, current.fxprime),
          beta_k = Math.max(0, dotProduct(yk, next.fxprime) / delta_k);
        weightedSum(pk, beta_k, pk, -1, next.fxprime), temp = current, current = next, next = temp;
      } else scale(pk, current.fxprime, -1);
      if (norm2(current.fxprime) <= 1e-5) break;
    }
    return params.history && params.history.push({
      x: current.x.slice(),
      fx: current.fx,
      fxprime: current.fxprime.slice(),
      alpha: a
    }), current;
  }

  const calculateNodeValue$1 = (subTree, output, depth = 0, flattenIndex = -1, parent, getNodeKey, valueField = 'value') => {
      let sum = 0;
      let prevFlattenIndex = flattenIndex !== null && flattenIndex !== void 0 ? flattenIndex : -1;
      let maxDepth = depth;
      subTree.forEach((datum, index) => {
          var _a, _b;
          const node = {
              flattenIndex: ++prevFlattenIndex,
              key: getNodeKey ? getNodeKey(datum) : `${(_a = parent === null || parent === void 0 ? void 0 : parent.key) !== null && _a !== void 0 ? _a : ''}-${index}`,
              maxDepth: -1,
              depth,
              index,
              value: datum[valueField],
              isLeaf: true,
              datum: parent ? parent.datum.concat(datum) : [datum],
              parentKey: parent === null || parent === void 0 ? void 0 : parent.key
          };
          if ((_b = datum.children) === null || _b === void 0 ? void 0 : _b.length) {
              node.children = [];
              node.isLeaf = false;
              const res = calculateNodeValue$1(datum.children, node.children, depth + 1, prevFlattenIndex, node, getNodeKey, valueField);
              node.value = isNil$1(datum[valueField])
                  ? res.sum
                  : Math.max(res.sum, toValidNumber(datum[valueField]));
              prevFlattenIndex = res.flattenIndex;
              maxDepth = Math.max(res.maxDepth, maxDepth);
          }
          else {
              node.isLeaf = true;
              node.value = toValidNumber(datum[valueField]);
          }
          sum += Math.abs(node.value);
          output.push(node);
      });
      return { sum, maxDepth, flattenIndex: prevFlattenIndex };
  };
  const eachBefore = (subTree, callback, parent, ctx) => {
      let ctxRes = ctx;
      subTree.forEach((node, index) => {
          var _a;
          ctxRes = callback(node, index, parent, ctxRes);
          if ((_a = node.children) === null || _a === void 0 ? void 0 : _a.length) {
              ctxRes = eachBefore(node.children, callback, node, ctxRes);
          }
      });
      return ctx;
  };
  const eachAfter = (subTree, callback, parent, ctx) => {
      let ctxRes = ctx;
      subTree.forEach((node, index) => {
          var _a;
          if ((_a = node.children) === null || _a === void 0 ? void 0 : _a.length) {
              ctxRes = eachAfter(node.children, callback, node, ctxRes);
          }
          ctxRes = callback(node, index, parent, ctxRes);
      });
      return ctxRes;
  };
  const flattenNodes = (nodes, output = [], options) => {
      const hasMaxDepth = (options === null || options === void 0 ? void 0 : options.maxDepth) >= 0;
      nodes.forEach(node => {
          if (!hasMaxDepth || node.depth <= options.maxDepth) {
              output.push((options === null || options === void 0 ? void 0 : options.callback) ? options.callback(node) : node);
              if (node.children) {
                  if (hasMaxDepth && node.depth === options.maxDepth) {
                      node.children = null;
                      node.isLeaf = true;
                  }
                  else {
                      flattenNodes(node.children, output, options);
                  }
              }
          }
      });
      return output;
  };

  function packEncloseRandom(circles, random) {
      let i = 0;
      const sCircles = shuffleArray(Array.from(circles), random);
      const n = sCircles.length;
      let B = [];
      let p;
      let e;
      while (i < n) {
          p = sCircles[i];
          if (e && enclosesWeak(e, p)) {
              ++i;
          }
          else {
              B = extendBasis(B, p);
              e = encloseBasis(B);
              i = 0;
          }
      }
      return e;
  }
  function extendBasis(B, p) {
      let i;
      let j;
      if (enclosesWeakAll(p, B)) {
          return [p];
      }
      for (i = 0; i < B.length; ++i) {
          if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
              return [B[i], p];
          }
      }
      for (i = 0; i < B.length - 1; ++i) {
          for (j = i + 1; j < B.length; ++j) {
              if (enclosesNot(encloseBasis2(B[i], B[j]), p) &&
                  enclosesNot(encloseBasis2(B[i], p), B[j]) &&
                  enclosesNot(encloseBasis2(B[j], p), B[i]) &&
                  enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
                  return [B[i], B[j], p];
              }
          }
      }
      Logger.getInstance().error('error when packEncloseRandom');
  }
  function enclosesNot(a, b) {
      const dr = a.radius - b.radius;
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
  }
  function enclosesWeak(a, b) {
      const dr = a.radius - b.radius + Math.max(a.radius, b.radius, 1) * 1e-9;
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
  }
  function enclosesWeakAll(a, B) {
      for (let i = 0; i < B.length; ++i) {
          if (!enclosesWeak(a, B[i])) {
              return false;
          }
      }
      return true;
  }
  function encloseBasis(B) {
      switch (B.length) {
          case 1:
              return encloseBasis1(B[0]);
          case 2:
              return encloseBasis2(B[0], B[1]);
          case 3:
              return encloseBasis3(B[0], B[1], B[2]);
      }
  }
  function encloseBasis1(a) {
      return {
          x: a.x,
          y: a.y,
          radius: a.radius
      };
  }
  function encloseBasis2(a, b) {
      const x1 = a.x;
      const y1 = a.y;
      const r1 = a.radius;
      const x2 = b.x;
      const y2 = b.y;
      const r2 = b.radius;
      const x21 = x2 - x1;
      const y21 = y2 - y1;
      const r21 = r2 - r1;
      const l = Math.sqrt(x21 * x21 + y21 * y21);
      return {
          x: (x1 + x2 + (x21 / l) * r21) / 2,
          y: (y1 + y2 + (y21 / l) * r21) / 2,
          radius: (l + r1 + r2) / 2
      };
  }
  function encloseBasis3(a, b, c) {
      const x1 = a.x;
      const y1 = a.y;
      const r1 = a.radius;
      const x2 = b.x;
      const y2 = b.y;
      const r2 = b.radius;
      const x3 = c.x;
      const y3 = c.y;
      const r3 = c.radius;
      const a2 = x1 - x2;
      const a3 = x1 - x3;
      const b2 = y1 - y2;
      const b3 = y1 - y3;
      const c2 = r2 - r1;
      const c3 = r3 - r1;
      const d1 = x1 * x1 + y1 * y1 - r1 * r1;
      const d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2;
      const d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3;
      const ab = a3 * b2 - a2 * b3;
      const xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1;
      const xb = (b3 * c2 - b2 * c3) / ab;
      const ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1;
      const yb = (a2 * c3 - a3 * c2) / ab;
      const A = xb * xb + yb * yb - 1;
      const B = 2 * (r1 + xa * xb + ya * yb);
      const C = xa * xa + ya * ya - r1 * r1;
      const r = -(Math.abs(A) > 1e-6 ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
      return {
          x: x1 + xa + xb * r,
          y: y1 + ya + yb * r,
          radius: r
      };
  }

  function place$1(b, a, c) {
      const dx = b.x - a.x;
      let x;
      let a2;
      const dy = b.y - a.y;
      let y;
      let b2;
      const d2 = dx * dx + dy * dy;
      if (d2) {
          a2 = a.radius + c.radius;
          a2 *= a2;
          b2 = b.radius + c.radius;
          b2 *= b2;
          if (a2 > b2) {
              x = (d2 + b2 - a2) / (2 * d2);
              y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
              c.x = b.x - x * dx - y * dy;
              c.y = b.y - x * dy + y * dx;
          }
          else {
              x = (d2 + a2 - b2) / (2 * d2);
              y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
              c.x = a.x + x * dx - y * dy;
              c.y = a.y + x * dy + y * dx;
          }
      }
      else {
          c.x = a.x + c.radius;
          c.y = a.y;
      }
  }
  function intersects(a, b) {
      const dr = a.radius + b.radius - 1e-6;
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
  }
  function score(node) {
      const a = node._;
      const b = node.next._;
      const ab = a.radius + b.radius;
      const dx = (a.x * b.radius + b.x * a.radius) / ab;
      const dy = (a.y * b.radius + b.y * a.radius) / ab;
      return dx * dx + dy * dy;
  }
  function getCicleNode(circle) {
      return {
          _: circle,
          next: null,
          prev: null
      };
  }
  function packSiblingsRandom(circles, random) {
      circles = array(circles);
      const n = circles.length;
      if (!n) {
          return 0;
      }
      let a = circles[0];
      a.x = 0;
      a.y = 0;
      if (n === 1) {
          return a.radius;
      }
      const b = circles[1];
      a.x = -b.radius;
      b.x = a.radius;
      b.y = 0;
      if (n === 2) {
          return a.radius + b.radius;
      }
      let c = circles[2];
      place$1(b, a, c);
      let aNode = getCicleNode(a);
      let bNode = getCicleNode(b);
      let cNode = getCicleNode(c);
      aNode.next = bNode;
      cNode.prev = bNode;
      bNode.next = cNode;
      aNode.prev = cNode;
      cNode.next = aNode;
      bNode.prev = aNode;
      let j;
      let k;
      let sj;
      let sk;
      let aa;
      let ca;
      let isContinue;
      for (let i = 3; i < n; ++i) {
          isContinue = false;
          c = circles[i];
          place$1(aNode._, bNode._, c);
          cNode = getCicleNode(c);
          j = bNode.next;
          k = aNode.prev;
          sj = bNode._.radius;
          sk = aNode._.radius;
          do {
              if (sj <= sk) {
                  if (intersects(j._, cNode._)) {
                      bNode = j;
                      aNode.next = bNode;
                      bNode.prev = aNode;
                      --i;
                      isContinue = true;
                      break;
                  }
                  sj += j._.radius;
                  j = j.next;
              }
              else {
                  if (intersects(k._, cNode._)) {
                      aNode = k;
                      aNode.next = bNode;
                      bNode.prev = aNode;
                      --i;
                      isContinue = true;
                      break;
                  }
                  sk += k._.radius;
                  k = k.prev;
              }
          } while (j !== k.next);
          if (isContinue) {
              continue;
          }
          cNode.prev = aNode;
          cNode.next = bNode;
          aNode.next = bNode.prev = bNode = cNode;
          aa = score(aNode);
          cNode = cNode.next;
          while (cNode !== bNode) {
              ca = score(cNode);
              if (ca < aa) {
                  aNode = cNode;
                  aa = ca;
              }
              cNode = cNode.next;
          }
          bNode = aNode.next;
      }
      const aCircles = [bNode._];
      cNode = bNode.next;
      while (cNode !== bNode) {
          aCircles.push(cNode._);
          cNode = cNode.next;
      }
      c = packEncloseRandom(aCircles, random);
      for (let i = 0; i < n; ++i) {
          a = circles[i];
          a.x -= c.x;
          a.y -= c.y;
      }
      return c.radius;
  }

  function radiusLeaf(radius) {
      return function (node) {
          if (!node.children) {
              node.radius = Math.max(0, +radius(node) || 0);
          }
      };
  }
  function packChildrenRandom(padding, k, random) {
      return function (node) {
          const children = node === null || node === void 0 ? void 0 : node.children;
          if (children) {
              let i;
              const n = children.length;
              const r = padding(node) * k || 0;
              if (r) {
                  for (i = 0; i < n; ++i) {
                      children[i].radius += r;
                  }
              }
              const e = packSiblingsRandom(children, random);
              if (r) {
                  for (i = 0; i < n; ++i) {
                      children[i].radius -= r;
                  }
              }
              node.radius = e + r;
          }
      };
  }
  function translateChild(k, maxDepth) {
      return function (node, index, parent) {
          node.radius *= k;
          node.maxDepth = maxDepth;
          if (parent) {
              node.x = parent.x + k * node.x;
              node.y = parent.y + k * node.y;
          }
      };
  }
  class CirclePackingLayout {
      constructor(options) {
          this.options = options;
          const keyOption = options === null || options === void 0 ? void 0 : options.nodeKey;
          const keyFunc = isFunction$1(keyOption) ? keyOption : keyOption ? field$1(keyOption) : null;
          this._getNodeKey = keyFunc;
          this._getPadding = isNumber$1(options === null || options === void 0 ? void 0 : options.padding)
              ? (node) => options.padding
              : isArray$1(options === null || options === void 0 ? void 0 : options.padding)
                  ? (node) => { var _a; return (_a = options.padding[node.depth + 1]) !== null && _a !== void 0 ? _a : 0; }
                  : () => 0;
          this._maxDepth = -1;
      }
      layout(data, config) {
          var _a;
          const viewBox = 'width' in config
              ? { x0: 0, x1: config.width, y0: 0, y1: config.height, width: config.width, height: config.height }
              : {
                  x0: Math.min(config.x0, config.x1),
                  x1: Math.max(config.x0, config.x1),
                  y0: Math.min(config.y0, config.y1),
                  y1: Math.max(config.y0, config.y1),
                  width: Math.abs(config.x1 - config.x0),
                  height: Math.abs(config.y1 - config.y0)
              };
          if (!data || !data.length) {
              return [];
          }
          const nodes = [];
          const res = calculateNodeValue$1(data, nodes, 0, -1, null, this._getNodeKey);
          this._maxDepth = res.maxDepth;
          const random = randomLCG();
          const root = {
              flattenIndex: -1,
              maxDepth: -1,
              key: 'root',
              depth: -1,
              index: -1,
              value: res.sum,
              datum: null,
              children: nodes,
              x: viewBox.x0 + viewBox.width / 2,
              y: viewBox.y0 + viewBox.height / 2
          };
          const { nodeSort, setRadius, padding, includeRoot } = (_a = this.options) !== null && _a !== void 0 ? _a : {};
          if (nodeSort !== false) {
              const sort = (isFunction$1(nodeSort) ? this.options.nodeKey : CirclePackingLayout.defaultOpionts.nodeSort);
              eachBefore([root], (node) => {
                  if (node.children && node.children.length) {
                      node.children.sort(sort);
                  }
              });
          }
          if (setRadius) {
              eachBefore([root], radiusLeaf(setRadius));
              eachAfter([root], packChildrenRandom(this._getPadding, 0.5, random));
              eachBefore([root], translateChild(1, this._maxDepth));
          }
          else {
              const size = Math.min(viewBox.width, viewBox.height);
              eachBefore([root], radiusLeaf(CirclePackingLayout.defaultOpionts.setRadius));
              eachAfter([root], packChildrenRandom(zero, 1, random));
              if (padding) {
                  eachAfter([root], packChildrenRandom(this._getPadding, root.radius / size, random));
              }
              eachBefore([root], translateChild(size / (2 * root.radius), this._maxDepth));
          }
          return includeRoot ? [root] : nodes;
      }
  }
  CirclePackingLayout.defaultOpionts = {
      setRadius: (node) => {
          return Math.sqrt(node.value);
      },
      padding: 0,
      nodeSort: (a, b) => b.value - a.value
  };

  const transform$8 = (options, upstreamData) => {
      const layout = new CirclePackingLayout(options);
      const res = layout.layout(upstreamData, 'width' in options
          ? {
              width: options.width,
              height: options.height
          }
          : {
              x0: options.x0,
              x1: options.x1,
              y0: options.y0,
              y1: options.y1
          });
      if (options.flatten) {
          const nodes = [];
          flattenNodes(res, nodes, { maxDepth: options === null || options === void 0 ? void 0 : options.maxDepth });
          return nodes;
      }
      return res;
  };

  const calculateNodeValue = (subTree) => {
      let sum = 0;
      subTree.forEach((node, index) => {
          var _a;
          if (isNil$1(node.value)) {
              if ((_a = node.children) === null || _a === void 0 ? void 0 : _a.length) {
                  node.value = calculateNodeValue(node.children);
              }
              else {
                  node.value = 0;
              }
          }
          sum += Math.abs(node.value);
      });
      return sum;
  };
  function makeHierarchicNodes(originalNodes, nodeKeyFunc, nodes = [], nodeMap = {}, originalLinks) {
      calculateNodeValue(originalNodes);
      const doSubTree = (subTree, depth, parents) => {
          subTree.forEach((node, index) => {
              const nodeKey = nodeKeyFunc
                  ? nodeKeyFunc(node)
                  : parents
                      ? `${parents[parents.length - 1].key}-${index}`
                      : `${depth}-${index}`;
              const nodeValue = (isNil$1(node.value) ? 0 : toValidNumber(node.value));
              if (nodeMap[nodeKey]) {
                  nodeMap[nodeKey].value = undefined;
              }
              else {
                  const nodeElement = {
                      depth,
                      datum: node,
                      index: index,
                      key: nodeKey,
                      value: nodeValue,
                      sourceLinks: [],
                      targetLinks: []
                  };
                  nodeMap[nodeKey] = nodeElement;
                  nodes.push(nodeElement);
              }
              if (parents && originalLinks) {
                  originalLinks.push({
                      source: parents[parents.length - 1].key,
                      target: nodeKey,
                      value: nodeValue,
                      parents
                  });
              }
              if (node.children && node.children.length) {
                  doSubTree(node.children, depth + 1, parents ? parents.concat([nodeMap[nodeKey]]) : [nodeMap[nodeKey]]);
              }
          });
      };
      doSubTree(originalNodes, 0, null);
      return nodes;
  }
  function computeHierarchicNodeLinks(originalNodes, nodeKeyFunc) {
      const nodes = [];
      const links = [];
      const nodeMap = {};
      const linkMap = {};
      const originalLinks = [];
      makeHierarchicNodes(originalNodes, nodeKeyFunc, nodes, nodeMap, originalLinks);
      originalLinks.forEach((link, index) => {
          const key = `${link.source}-${link.target}`;
          const linkDatum = pickWithout(link, ['parents']);
          linkDatum.parents = link.parents.map(node => {
              return pickWithout(node, ['sourceLinks', 'targetLinks']);
          });
          if (linkMap[key]) {
              linkMap[key].value += toValidNumber(link.value);
              linkMap[key].datum.push(linkDatum);
              return;
          }
          const linkElement = {
              index,
              key: `${link.source}-${link.target}`,
              source: link.source,
              target: link.target,
              datum: [linkDatum],
              value: link.value,
              parents: link.parents.map(parent => parent.key)
          };
          links.push(linkElement);
          nodeMap[link.source].sourceLinks.push(linkElement);
          nodeMap[link.target].targetLinks.push(linkElement);
          linkMap[key] = linkElement;
      });
      return { nodes, links, nodeMap };
  }
  function computeNodeValues(nodes) {
      for (let i = 0, len = nodes.length; i < len; i++) {
          const node = nodes[i];
          node.value = Math.max(isNil$1(node.value) ? 0 : toValidNumber(node.value), node.sourceLinks.reduce((sum, link) => {
              var _a;
              return sum + ((_a = toValidNumber(link.value)) !== null && _a !== void 0 ? _a : 0);
          }, 0), node.targetLinks.reduce((sum, link) => {
              var _a;
              return sum + ((_a = toValidNumber(link.value)) !== null && _a !== void 0 ? _a : 0);
          }, 0));
      }
  }

  function left(node) {
      return node.depth;
  }
  function right(node, maxDepth) {
      return maxDepth - 1 - node.endDepth;
  }
  function justify(node, maxDepth) {
      return node.sourceLinks.length ? node.depth : maxDepth - 1;
  }
  function center(node, maxDepth, nodeMap) {
      return node.targetLinks.length
          ? node.depth
          : node.sourceLinks.length
              ? minInArray(node.sourceLinks.map(link => nodeMap[link.target].depth)) - 1
              : 0;
  }
  const ascendingNodeBreadth = (a, b) => {
      return (a === null || a === void 0 ? void 0 : a.y0) - (b === null || b === void 0 ? void 0 : b.y0);
  };
  const calcDivideValue = (node, isTarget) => {
      if (isNil$1(node.value)) {
          return null;
      }
      const res = (isTarget ? node.targetLinks : node.sourceLinks).reduce((res, sLink) => {
          if (isNil$1(sLink.value)) {
              res.count += 1;
          }
          else {
              res.sum += sLink.value;
          }
          return res;
      }, { sum: 0, count: 0 });
      return res.count > 0 ? (node.value - res.sum) / res.count : null;
  };
  const alignFunctions = {
      left,
      right,
      justify,
      center,
      start: left,
      end: right
  };
  const linkClampe = clamper(0, 1);
  class SankeyLayout {
      constructor(options) {
          this._ascendingSourceBreadth = (a, b) => {
              return ascendingNodeBreadth(this._nodeMap[a.source], this._nodeMap[b.source]) || a.index - b.index;
          };
          this._ascendingTargetBreadth = (a, b) => {
              return ascendingNodeBreadth(this._nodeMap[a.target], this._nodeMap[b.target]) || a.index - b.index;
          };
          this.options = Object.assign({}, SankeyLayout.defaultOptions, options);
          const keyOption = this.options.nodeKey;
          const keyFunc = isFunction$1(keyOption) ? keyOption : keyOption ? field$1(keyOption) : null;
          this._getNodeKey = keyFunc;
          this._logger = Logger.getInstance();
          this._alignFunc = isFunction$1(this.options.setNodeLayer)
              ? (node) => {
                  return this.options.setNodeLayer(node.datum);
              }
              : alignFunctions[this.options.nodeAlign];
      }
      layout(data, config) {
          if (!data) {
              return null;
          }
          const viewBox = 'width' in config
              ? { x0: 0, x1: config.width, y0: 0, y1: config.height, width: config.width, height: config.height }
              : {
                  x0: Math.min(config.x0, config.x1),
                  x1: Math.max(config.x0, config.x1),
                  y0: Math.min(config.y0, config.y1),
                  y1: Math.max(config.y0, config.y1),
                  width: Math.abs(config.x1 - config.x0),
                  height: Math.abs(config.y1 - config.y0)
              };
          if (this.options.direction === 'vertical') {
              this._viewBox = {
                  x0: viewBox.y0,
                  x1: viewBox.y1,
                  y0: viewBox.x0,
                  y1: viewBox.x1,
                  width: viewBox.height,
                  height: viewBox.width
              };
          }
          else {
              this._viewBox = viewBox;
          }
          const result = this.computeNodeLinks(data);
          const nodes = result.nodes;
          let links = result.links;
          this._nodeMap = result.nodeMap;
          this.computeNodeValues(nodes);
          this.computeNodeDepths(nodes);
          if (['right', 'end', 'justify'].includes(this.options.nodeAlign)) {
              this.computeNodeEndDepths(nodes);
          }
          if (this._maxDepth <= 0) {
              return null;
          }
          const columns = this.computeNodeBreadths(nodes);
          this.computeLinkBreadths(nodes);
          nodes.forEach(node => {
              node.sourceLinks = node.sourceLinks.filter(link => !isNil$1(link.source) && !isNil$1(link.target));
              node.targetLinks = node.targetLinks.filter(link => !isNil$1(link.source) && !isNil$1(link.target));
          });
          links = links.filter(link => !isNil$1(link.source) && !isNil$1(link.target));
          if (this.options.direction === 'vertical') {
              if (this.options.inverse) {
                  const viewY1 = this._viewBox.x1;
                  nodes.forEach(node => {
                      const { y0, y1, x0, x1 } = node;
                      node.y0 = viewY1 - x1;
                      node.y1 = viewY1 - x0;
                      node.x0 = y0;
                      node.x1 = y1;
                  });
                  links.forEach(link => {
                      link.vertical = true;
                      const { x0, x1, y0, y1 } = link;
                      link.x0 = y0;
                      link.x1 = y1;
                      link.y0 = viewY1 - x0;
                      link.y1 = viewY1 - x1;
                  });
              }
              else {
                  nodes.forEach(node => {
                      const { y0, y1 } = node;
                      node.y0 = node.x0;
                      node.y1 = node.x1;
                      node.x0 = y0;
                      node.x1 = y1;
                  });
                  links.forEach(link => {
                      link.vertical = true;
                      const x0 = link.x0;
                      const x1 = link.x1;
                      link.x0 = link.y0;
                      link.x1 = link.y1;
                      link.y0 = x0;
                      link.y1 = x1;
                  });
              }
          }
          else if (this.options.inverse) {
              nodes.forEach(node => {
                  const { x0, x1 } = node;
                  node.x0 = viewBox.x1 - x1;
                  node.x1 = viewBox.x1 - x0;
              });
              links.forEach(link => {
                  link.x0 = viewBox.x1 - link.x0;
                  link.x1 = viewBox.x1 - link.x1;
              });
          }
          links.forEach(link => {
              const sourceNode = this._nodeMap[link.source];
              const targetNode = this._nodeMap[link.target];
              link.sourceRect = { x0: sourceNode.x0, x1: sourceNode.x1, y0: sourceNode.y0, y1: sourceNode.y1 };
              link.targetRect = { x0: targetNode.x0, x1: targetNode.x1, y1: targetNode.y1, y0: targetNode.y0 };
          });
          return { nodes, links, columns };
      }
      computeHierarchicNodeLinks(originalNodes) {
          return computeHierarchicNodeLinks(originalNodes, this._getNodeKey);
      }
      computeSourceTargetNodeLinks(data) {
          const nodes = [];
          const links = [];
          const nodeMap = {};
          if (data.nodes) {
              data.nodes.forEach((node, index) => {
                  const nodeElement = {
                      depth: -1,
                      datum: node,
                      index,
                      key: this._getNodeKey ? this._getNodeKey(node) : index,
                      value: node.value,
                      sourceLinks: [],
                      targetLinks: []
                  };
                  nodeMap[nodeElement.key] = nodeElement;
                  nodes.push(nodeElement);
              });
          }
          const invalidLinks = [];
          data.links.forEach((link, index) => {
              const hasSource = !isNil$1(link.source);
              const hasTarget = !isNil$1(link.target);
              if (data.nodes && (!nodeMap[link.source] || !nodeMap[link.target])) {
                  return;
              }
              if (!data.nodes && hasSource && !nodeMap[link.source]) {
                  nodeMap[link.source] = {
                      value: undefined,
                      depth: -1,
                      index: nodes.length,
                      key: link.source,
                      datum: null,
                      sourceLinks: [],
                      targetLinks: []
                  };
                  nodes.push(nodeMap[link.source]);
              }
              if (!data.nodes && hasTarget && !nodeMap[link.target]) {
                  nodeMap[link.target] = {
                      value: undefined,
                      depth: -1,
                      index: nodes.length,
                      key: link.target,
                      datum: null,
                      sourceLinks: [],
                      targetLinks: []
                  };
                  nodes.push(nodeMap[link.target]);
              }
              const linkElement = {
                  index,
                  source: link.source,
                  target: link.target,
                  datum: link,
                  value: link.value
              };
              if (this.options.divideNodeValueToLink && isNil$1(link.value)) {
                  invalidLinks.push(linkElement);
              }
              links.push(linkElement);
              if (hasSource) {
                  nodeMap[link.source].sourceLinks.push(linkElement);
              }
              if (hasTarget) {
                  nodeMap[link.target].targetLinks.push(linkElement);
              }
          });
          if (this.options.divideNodeValueToLink && invalidLinks.length) {
              invalidLinks.forEach(link => {
                  const values = [calcDivideValue(nodeMap[link.source]), calcDivideValue(nodeMap[link.target], true)].filter(entry => !isNil$1(entry));
                  if (values.length) {
                      link.value = minInArray(values);
                  }
              });
          }
          return { nodeMap, nodes, links };
      }
      computeNodeLinks(data) {
          let res;
          if (!('links' in data)) {
              this._isHierarchic = true;
              res = this.computeHierarchicNodeLinks(data.nodes);
          }
          else {
              res = this.computeSourceTargetNodeLinks(data);
          }
          let nodes = res.nodes;
          const links = res.links;
          if (this.options.linkSortBy) {
              for (let i = 0, len = nodes.length; i < len; i++) {
                  nodes[i].sourceLinks.sort(this.options.linkSortBy);
                  nodes[i].targetLinks.sort(this.options.linkSortBy);
              }
          }
          if (this.options.dropIsolatedNode) {
              nodes = nodes.filter(node => node.targetLinks.length || node.sourceLinks.length);
          }
          return { nodes, links, nodeMap: res.nodeMap };
      }
      computeNodeValues(nodes) {
          return computeNodeValues(nodes);
      }
      computeNodeDepths(nodes) {
          var _a;
          const n = nodes.length;
          let current = nodes;
          let next;
          let nextMap;
          let depth = 0;
          let maxDepth = -1;
          const setNodeLayer = isFunction$1(this.options.setNodeLayer) ? this.options.setNodeLayer : null;
          while (current.length && depth < n) {
              next = [];
              nextMap = {};
              for (let i = 0, curLen = current.length; i < curLen; i++) {
                  const node = current[i];
                  if (node) {
                      node.depth = setNodeLayer ? (_a = setNodeLayer(node.datum)) !== null && _a !== void 0 ? _a : depth : depth;
                      if (setNodeLayer) {
                          maxDepth = Math.max(node.depth, maxDepth);
                      }
                      if (node.sourceLinks && node.sourceLinks.length) {
                          for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
                              const link = node.sourceLinks[j];
                              if (!nextMap[link.target]) {
                                  next.push(this._nodeMap[link.target]);
                                  nextMap[link.target] = true;
                              }
                          }
                      }
                  }
              }
              current = next;
              depth += 1;
          }
          if (depth > n) {
              this._logger.warn('Error: there is a circular link');
          }
          this._maxDepth = setNodeLayer ? maxDepth + 1 : depth;
      }
      computeNodeEndDepths(nodes) {
          const n = nodes.length;
          let current = nodes;
          let next;
          let nextMap;
          let depth = 0;
          while (current.length && depth < n) {
              next = [];
              nextMap = {};
              for (let i = 0, curLen = current.length; i < curLen; i++) {
                  const node = current[i];
                  if (node) {
                      node.endDepth = depth;
                      for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
                          const link = node.targetLinks[j];
                          if (!nextMap[link.source]) {
                              next.push(this._nodeMap[link.source]);
                              nextMap[link.source] = true;
                          }
                      }
                  }
              }
              current = next;
              depth += 1;
          }
          if (depth > n) {
              this._logger.warn('Error: there is a circular link');
          }
      }
      computeNodeLayers(nodes) {
          const nodeWidthOption = this.options.nodeWidth;
          const linkWidthOption = this.options.linkWidth;
          const minStepWidth = this.options.minStepWidth;
          const width = this._viewBox.width;
          let nodeWidth = null;
          let linkWidth = null;
          let isEvenWidth = false;
          if (isString$1(nodeWidthOption)) {
              const ratio = clamp$1(parseFloat(nodeWidthOption.replace('%', '')) / 100, 0, 1);
              let stepWidth = width / (this._maxDepth - 1 + ratio);
              if (minStepWidth > 0) {
                  stepWidth = Math.max(minStepWidth, stepWidth);
              }
              nodeWidth = stepWidth * ratio;
              linkWidth = stepWidth * (1 - ratio);
              isEvenWidth = true;
          }
          else if (isNumber$1(nodeWidthOption)) {
              nodeWidth = nodeWidthOption;
              if (isNumber$1(linkWidthOption)) {
                  linkWidth = linkWidthOption;
              }
              else if (isNil$1(linkWidthOption)) {
                  let stepWidth = (width - nodeWidthOption) / (this._maxDepth - 1);
                  if (minStepWidth > 0) {
                      stepWidth = Math.max(minStepWidth, stepWidth);
                  }
                  linkWidth = stepWidth - nodeWidthOption;
              }
              isEvenWidth = true;
          }
          else if (isFunction$1(nodeWidthOption) && isNumber$1(linkWidthOption)) {
              linkWidth = linkWidthOption;
          }
          const columns = [];
          for (let i = 0, len = nodes.length; i < len; i++) {
              const node = nodes[i];
              node.layer = this._isHierarchic
                  ? node.depth
                  : clamp$1(Math.floor(this._alignFunc(node, this._maxDepth, this._nodeMap)), 0, this._maxDepth - 1);
              const layer = node.layer;
              if (layer === this._maxDepth - 1) {
                  node.isLastLayer = true;
              }
              if (isEvenWidth) {
                  node.x0 = this._viewBox.x0 + layer * (nodeWidth + linkWidth);
                  node.x1 = node.x0 + nodeWidth;
              }
              if (columns[layer]) {
                  columns[layer].push(node);
              }
              else {
                  columns[layer] = [node];
              }
          }
          if (this.options.nodeSortBy) {
              for (let j = 0, colLen = columns.length; j < colLen; j++) {
                  columns[j].sort(this.options.nodeSortBy);
              }
          }
          if (!isEvenWidth && isFunction$1(nodeWidthOption)) {
              let curLayerX = this._viewBox.x0;
              for (let i = 0; i < this._maxDepth; i++) {
                  const column = columns[i];
                  let maxNodeWidth = 0;
                  let maxLinkWidth = 0;
                  for (let j = 0, colLen = column && column.length; j < colLen; j++) {
                      const node = column[j];
                      const curNodeWidth = nodeWidthOption(node);
                      node.x0 = curLayerX;
                      node.x1 = curLayerX + curNodeWidth;
                      maxNodeWidth = Math.max(nodeWidth, curNodeWidth);
                      const sourceLinks = node.sourceLinks;
                      for (let k = 0, linkLen = sourceLinks.length; k < linkLen; k++) {
                          const link = sourceLinks[k];
                          const curLinkWidth = isFunction$1(linkWidthOption) ? linkWidthOption(link, this._viewBox) : linkWidth;
                          maxLinkWidth = Math.max(maxLinkWidth, curLinkWidth);
                      }
                  }
                  curLayerX += maxNodeWidth + maxLinkWidth;
              }
          }
          return columns;
      }
      initializeNodeBreadths(columns) {
          var _a, _b, _c;
          const minLinkHeight = (_a = this.options.minLinkHeight) !== null && _a !== void 0 ? _a : 0;
          let minNodeHeight = (_b = this.options.minNodeHeight) !== null && _b !== void 0 ? _b : 0;
          const maxNodeHeight = (_c = this.options.maxNodeHeight) !== null && _c !== void 0 ? _c : Infinity;
          let maxLinkHeight = this.options.maxLinkHeight;
          if (isNil$1(minNodeHeight) || minNodeHeight < minLinkHeight) {
              minNodeHeight = minLinkHeight;
          }
          if (isNil$1(maxLinkHeight) || maxLinkHeight > maxNodeHeight) {
              maxLinkHeight = maxNodeHeight;
          }
          let ky = 0;
          let getGapY = null;
          let forceNodeHeight = null;
          if (isFunction$1(this.options.nodeGap)) {
              getGapY = this.options.nodeGap;
              ky = columns.reduce((val, column) => {
                  const sumValue = column.reduce((sum, node) => {
                      return sum + node.value;
                  }, 0);
                  const sumGapY = column.reduce((sum, node) => {
                      return sum + this.options.nodeGap(node);
                  }, 0);
                  return Math.min(val, (this._viewBox.height - sumGapY) / sumValue);
              }, Infinity);
          }
          else {
              const maxRowCount = columns.reduce((cnt, column) => {
                  return Math.max(cnt, column.length);
              }, 0);
              const maxStepHeight = this._viewBox.height / maxRowCount;
              let gapY = Math.min(this.options.nodeGap, maxStepHeight);
              if (minNodeHeight + gapY > maxStepHeight) {
                  gapY = minNodeHeight >= maxStepHeight ? maxStepHeight / 2 : (maxStepHeight - minNodeHeight) / 2;
                  minNodeHeight = Math.min(maxStepHeight - gapY, minNodeHeight);
              }
              getGapY = () => gapY;
              this._gapY = gapY;
              if (this.options.equalNodeHeight) {
                  forceNodeHeight = this._viewBox.height / maxRowCount - gapY;
              }
              else {
                  const calGapY = minNodeHeight > 0 ? Math.max(gapY, minNodeHeight) : gapY;
                  ky = columns.reduce((val, column) => {
                      const sumValue = column.reduce((sum, node) => {
                          return sum + node.value;
                      }, 0);
                      return Math.min(val, (this._viewBox.height - ((column.length - 1) * calGapY + minNodeHeight)) / sumValue);
                  }, Infinity);
              }
          }
          const isStartGap = this.options.gapPosition === 'start';
          const isMiddleGap = !isStartGap && this.options.gapPosition !== 'end';
          const getNodeHeight = isNumber$1(this.options.nodeHeight)
              ? (node) => this.options.nodeHeight
              : isFunction$1(this.options.nodeHeight)
                  ? this.options.nodeHeight
                  : forceNodeHeight > 0
                      ? (node) => {
                          return forceNodeHeight;
                      }
                      : (node) => {
                          return Math.max(node.value * ky, 0);
                      };
          const getLinkHeight = isNumber$1(this.options.linkHeight)
              ? () => this.options.linkHeight
              : isFunction$1(this.options.linkHeight)
                  ? this.options.linkHeight
                  : (link, sourceNode, sourceNodeHeight) => {
                      return Math.min(Math.max(sourceNode.value ? sourceNodeHeight * linkClampe(link.value / sourceNode.value) : 0, minLinkHeight, 0), maxLinkHeight);
                  };
          for (let i = 0, columnCount = columns.length; i < columnCount; i++) {
              const nodes = columns[i];
              if (!nodes || !nodes.length) {
                  continue;
              }
              let y = this._viewBox.y0;
              let gapY = 0;
              let nodeHeight = 0;
              let calculatedNodeHeight = 0;
              for (let j = 0, len = nodes.length; j < len; j++) {
                  const node = nodes[j];
                  gapY = getGapY(node);
                  if (isStartGap) {
                      y += gapY;
                  }
                  calculatedNodeHeight = getNodeHeight(node);
                  nodeHeight = Math.min(Math.max(calculatedNodeHeight, minNodeHeight), maxNodeHeight);
                  node.y0 = y;
                  node.y1 = y + nodeHeight;
                  y = isStartGap ? node.y1 : node.y1 + gapY;
                  for (let k = 0, linkLen = node.sourceLinks.length; k < linkLen; k++) {
                      const link = node.sourceLinks[k];
                      link.thickness = getLinkHeight(link, node, calculatedNodeHeight);
                  }
              }
              let deltaY = this._viewBox.y1 - y + (isMiddleGap ? gapY : 0);
              if (deltaY > 0) {
                  if (this.options.crossNodeAlign === 'start') ;
                  else if (this.options.crossNodeAlign === 'end') {
                      for (let j = 0, len = nodes.length; j < len; ++j) {
                          const node = nodes[j];
                          node.y0 += deltaY;
                          node.y1 += deltaY;
                      }
                  }
                  else if (this.options.crossNodeAlign === 'parent') {
                      const sourceNodes = nodes.reduce((res, node) => {
                          if (node.targetLinks && node.targetLinks.length) {
                              node.targetLinks.forEach(link => {
                                  res[link.source] = true;
                              });
                          }
                          return res;
                      }, {});
                      if (Object.keys(sourceNodes).length && columns[i - 1] && columns[i - 1].length) {
                          const prevSourceNodes = columns[i - 1].filter(node => sourceNodes[node.key]);
                          if (prevSourceNodes && prevSourceNodes.length && prevSourceNodes[0].y0 !== nodes[0].y0) {
                              const startY = prevSourceNodes[0].y0;
                              const newDeltaY = startY - nodes[0].y0;
                              for (let j = 0, len = nodes.length; j < len; ++j) {
                                  const node = nodes[j];
                                  node.y0 += newDeltaY;
                                  node.y1 += newDeltaY;
                              }
                          }
                      }
                  }
                  else {
                      deltaY = deltaY / (nodes.length + 1);
                      for (let j = 0, len = nodes.length; j < len; ++j) {
                          const node = nodes[j];
                          node.y0 += deltaY * (j + 1);
                          node.y1 += deltaY * (j + 1);
                      }
                  }
              }
              else if (deltaY < 0 && nodes.length > 1) {
                  deltaY = deltaY / (nodes.length - 1);
                  if (gapY + deltaY >= 0) {
                      gapY += deltaY;
                      this._gapY = Math.min(gapY);
                      for (let j = 1, len = nodes.length; j < len; ++j) {
                          const node = nodes[j];
                          node.y0 += deltaY * j;
                          node.y1 += deltaY * j;
                      }
                  }
              }
              this.reorderLinks(nodes);
          }
      }
      computeNodeBreadths(nodes) {
          const columns = this.computeNodeLayers(nodes);
          this.initializeNodeBreadths(columns);
          const iterations = this.options.iterations;
          if (!this._isHierarchic && !isFunction$1(this.options.setNodeLayer) && !isFunction$1(this.options.nodeGap)) {
              for (let i = 0; i < iterations; ++i) {
                  const alpha = Math.pow(0.99, i);
                  const beta = Math.max(1 - alpha, (i + 1) / iterations);
                  this.relaxRightToLeft(columns, alpha, beta);
                  this.relaxLeftToRight(columns, alpha, beta);
              }
          }
          return columns;
      }
      relaxLeftToRight(columns, alpha, beta) {
          for (let i = 1, n = columns.length; i < n; ++i) {
              const column = columns[i];
              for (let j = 0, colLen = column.length; j < colLen; j++) {
                  const target = column[j];
                  let y = 0;
                  let w = 0;
                  for (let k = 0, linkLen = target.targetLinks.length; k < linkLen; k++) {
                      const link = target.targetLinks[k];
                      const v = link.value * (target.layer - this._nodeMap[link.source].layer);
                      y += this.targetTop(this._nodeMap[link.source], target) * v;
                      w += v;
                  }
                  if (!(w > 0)) {
                      continue;
                  }
                  const dy = (y / w - target.y0) * alpha;
                  target.y0 += dy;
                  target.y1 += dy;
                  this.reorderNodeLinks(target);
              }
              if (isNil$1(this.options.nodeSortBy)) {
                  column.sort(ascendingNodeBreadth);
              }
              this.resolveCollisions(column, beta);
          }
      }
      relaxRightToLeft(columns, alpha, beta) {
          for (let n = columns.length, i = n - 2; i >= 0; --i) {
              const column = columns[i];
              for (let j = 0, colLen = column.length; j < colLen; j++) {
                  const source = column[j];
                  let y = 0;
                  let w = 0;
                  for (let k = 0, linkLen = source.sourceLinks.length; k < linkLen; k++) {
                      const link = source.sourceLinks[k];
                      const v = link.value * (this._nodeMap[link.target].layer - source.layer);
                      y += this.sourceTop(source, this._nodeMap[link.target]) * v;
                      w += v;
                  }
                  if (!(w > 0)) {
                      continue;
                  }
                  const dy = (y / w - source.y0) * alpha;
                  source.y0 += dy;
                  source.y1 += dy;
                  this.reorderNodeLinks(source);
              }
              if (this.options.nodeSortBy === undefined) {
                  column.sort(ascendingNodeBreadth);
              }
              this.resolveCollisions(column, beta);
          }
      }
      resolveCollisions(nodes, alpha) {
          const i = nodes.length >> 1;
          const subject = nodes[i];
          this.resolveCollisionsBottomToTop(nodes, subject.y0 - this._gapY, i - 1, alpha);
          this.resolveCollisionsTopToBottom(nodes, subject.y1 + this._gapY, i + 1, alpha);
          this.resolveCollisionsBottomToTop(nodes, this._viewBox.y1, nodes.length - 1, alpha);
          this.resolveCollisionsTopToBottom(nodes, this._viewBox.y0, 0, alpha);
      }
      resolveCollisionsTopToBottom(nodes, y, i, alpha) {
          for (; i < nodes.length; ++i) {
              const node = nodes[i];
              const dy = (y - node.y0) * alpha;
              if (dy > 1e-6) {
                  (node.y0 += dy), (node.y1 += dy);
              }
              y = node.y1 + this._gapY;
          }
      }
      resolveCollisionsBottomToTop(nodes, y, i, alpha) {
          for (; i >= 0; --i) {
              const node = nodes[i];
              const dy = (node.y1 - y) * alpha;
              if (dy > 1e-6) {
                  node.y0 -= dy;
                  node.y1 -= dy;
              }
              y = node.y0 - this._gapY;
          }
      }
      targetTop(source, target) {
          let y = source.y0 - ((source.sourceLinks.length - 1) * this._gapY) / 2;
          let i;
          let len;
          let link;
          for (i = 0, len = source.sourceLinks.length; i < len; i++) {
              link = source.sourceLinks[i];
              if (link.target === target.key) {
                  break;
              }
              y += link.thickness + this._gapY;
          }
          for (i = 0, len = target.targetLinks.length; i < len; i++) {
              link = target.targetLinks[i];
              if (link.source === source.key) {
                  break;
              }
              y -= link.thickness;
          }
          return y;
      }
      sourceTop(source, target) {
          let y = target.y0 - ((target.targetLinks.length - 1) * this._gapY) / 2;
          let i;
          let len;
          let link;
          for (i = 0, len = target.targetLinks.length; i < len; i++) {
              link = target.targetLinks[i];
              if (link.source === source.key) {
                  break;
              }
              y += link.thickness + this._gapY;
          }
          for (i = 0, len = source.sourceLinks.length; i < len; i++) {
              link = source.sourceLinks[i];
              if (link.target === target.key) {
                  break;
              }
              y -= link.thickness;
          }
          return y;
      }
      computeLinkBreadthsNoOverlap(nodes) {
          for (let i = 0, len = nodes.length; i < len; i++) {
              const node = nodes[i];
              let y0 = node.y0;
              let reachBottom = false;
              for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
                  const link = node.sourceLinks[j];
                  if (!reachBottom) {
                      link.y0 = y0 + link.thickness / 2;
                  }
                  link.x0 = node.x1;
                  if (y0 + link.thickness > node.y1 || reachBottom) {
                      link.y0 = node.y1 - link.thickness / 2;
                      reachBottom = true;
                  }
                  else {
                      y0 += link.thickness;
                  }
              }
              let y1 = node.y0;
              reachBottom = false;
              for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
                  const link = node.targetLinks[j];
                  if (!reachBottom) {
                      link.y1 = y1 + link.thickness / 2;
                  }
                  link.x1 = node.x0;
                  if (y1 + link.thickness > node.y1 || reachBottom) {
                      link.y1 = node.y1 - link.thickness / 2;
                      reachBottom = true;
                  }
                  else {
                      y1 += link.thickness;
                  }
              }
          }
      }
      computeLinkBreadthsOverlap(nodes) {
          const linkOverlap = this.options.linkOverlap;
          for (let i = 0, len = nodes.length; i < len; i++) {
              const node = nodes[i];
              const pos = linkOverlap === 'start' ? node.y0 : linkOverlap === 'end' ? node.y1 : (node.y0 + node.y1) / 2;
              const sign = linkOverlap === 'start' ? 0.5 : linkOverlap === 'end' ? -0.5 : 0;
              for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
                  const link = node.sourceLinks[j];
                  link.y0 = pos + sign * link.thickness;
                  link.x0 = node.x1;
              }
              for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
                  const link = node.targetLinks[j];
                  link.y1 = pos + sign * link.thickness;
                  link.x1 = node.x0;
              }
          }
      }
      computeLinkBreadths(nodes) {
          if (this.options.linkOverlap) {
              this.computeLinkBreadthsOverlap(nodes);
          }
          else {
              this.computeLinkBreadthsNoOverlap(nodes);
          }
      }
      reorderNodeLinks(node) {
          if (isNil$1(this.options.linkSortBy)) {
              const targetLinks = node.targetLinks;
              const sourceLinks = node.sourceLinks;
              for (let j = 0, linkLen = targetLinks.length; j < linkLen; j++) {
                  const link = targetLinks[j];
                  this._nodeMap[link.source].sourceLinks.sort(this._ascendingTargetBreadth);
              }
              for (let j = 0, linkLen = sourceLinks.length; j < linkLen; j++) {
                  const link = sourceLinks[j];
                  this._nodeMap[link.target].targetLinks.sort(this._ascendingSourceBreadth);
              }
          }
      }
      reorderLinks(nodes) {
          if (isNil$1(this.options.linkSortBy)) {
              for (let i = 0, len = nodes.length; i < len; i++) {
                  const node = nodes[i];
                  node.sourceLinks.sort(this._ascendingTargetBreadth);
                  node.targetLinks.sort(this._ascendingSourceBreadth);
              }
          }
      }
  }
  SankeyLayout.defaultOptions = {
      iterations: 6,
      nodeAlign: 'justify',
      direction: 'horizontal',
      nodeWidth: 24,
      nodeGap: 8,
      crossNodeAlign: 'middle',
      dropIsolatedNode: true
  };

  const transform$7 = (options, upstreamData) => {
      const layout = new SankeyLayout(options);
      const res = layout.layout(Array.isArray(upstreamData) ? upstreamData[0] : upstreamData, 'width' in options
          ? {
              width: options.width,
              height: options.height
          }
          : {
              x0: options.x0,
              x1: options.x1,
              y0: options.y0,
              y1: options.y1
          });
      return res ? [res] : [];
  };

  const formatNodeRect = (nodes) => {
      return nodes.map(node => {
          return Object.assign({}, node, {
              x: node.x0,
              y: node.y0,
              width: node.x1 - node.x0,
              height: node.y1 - node.y0
          });
      });
  };
  const formatLinkPolygon = (links) => {
      var _a;
      const isVertical = !isNil$1((_a = links === null || links === void 0 ? void 0 : links[0]) === null || _a === void 0 ? void 0 : _a.vertical);
      if (isVertical) {
          return links.map(link => {
              const half = link.thickness / 2;
              const points = [
                  {
                      x: link.x0 - half,
                      y: link.y0
                  },
                  {
                      x: link.x1 - half,
                      y: link.y1
                  },
                  {
                      x: link.x1 + half,
                      y: link.y1
                  },
                  {
                      x: link.x0 + half,
                      y: link.y0
                  }
              ];
              return Object.assign({}, link, { points: points });
          });
      }
      return links.map(link => {
          const half = link.thickness / 2;
          const points = [
              {
                  x: link.x0,
                  y: link.y0 - half
              },
              {
                  x: link.x1,
                  y: link.y1 - half
              },
              {
                  x: link.x1,
                  y: link.y1 + half
              },
              {
                  x: link.x0,
                  y: link.y0 + half
              }
          ];
          return Object.assign({}, link, { points: points });
      });
  };
  const formatLinkPath = (links, round = true) => {
      var _a;
      const isVertical = !isNil$1((_a = links === null || links === void 0 ? void 0 : links[0]) === null || _a === void 0 ? void 0 : _a.vertical);
      if (isVertical) {
          return links.map(link => {
              const half = link.thickness / 2;
              let y0 = link.y0;
              let y1 = link.y1;
              let midY = (y0 + y1) / 2;
              let x00 = link.x0 - half;
              let x01 = link.x0 + half;
              let x10 = link.x1 - half;
              let x11 = link.x1 + half;
              if (round) {
                  y0 = Math.round(y0);
                  y1 = Math.round(y1);
                  midY = Math.round(midY);
                  x00 = Math.round(x00);
                  x01 = Math.round(x01);
                  x10 = Math.round(x10);
                  x11 = Math.round(x11);
              }
              return Object.assign({}, link, {
                  path: `
            M${x00},${y0}
            C${x00},${midY},${x10},${midY},${x10},${y1}
            L${x11},${y1}
            C${x11},${midY},${x01},${midY},${x01},${y0}
            Z
            `
              });
          });
      }
      return links.map(link => {
          const half = link.thickness / 2;
          let x0 = link.x0;
          let x1 = link.x1;
          let midX = (x0 + x1) / 2;
          let y00 = link.y0 - half;
          let y01 = link.y0 + half;
          let y10 = link.y1 - half;
          let y11 = link.y1 + half;
          if (round) {
              x0 = Math.round(x0);
              x1 = Math.round(x1);
              midX = Math.round(midX);
              y00 = Math.round(y00);
              y01 = Math.round(y01);
              y10 = Math.round(y10);
              y11 = Math.round(y11);
          }
          return Object.assign({}, link, {
              path: `
          M${x0},${y00}
          C${midX},${y00},${midX},${y10},${x1},${y10}
          L${x1},${y11}
          C${midX},${y11},${midX},${y01},${x0},${y01}
          Z`
          });
      });
  };
  const getBoundsOfNodes = (nodes) => {
      let x0 = Infinity;
      let x1 = -Infinity;
      let y0 = Infinity;
      let y1 = -Infinity;
      nodes.forEach(node => {
          x0 = Math.min(node.x0, x0);
          x1 = Math.max(node.x1, x1);
          y0 = Math.min(node.y0, y0);
          y1 = Math.max(node.y1, y1);
      });
      return {
          x0,
          x1,
          y0,
          y1,
          width: x1 - x0,
          height: y1 - y0
      };
  };
  const isNodeVertical = (node) => {
      if (node.sourceLinks && node.sourceLinks.length) {
          return !isNil$1(node.sourceLinks[0].x0);
      }
      if (node.targetLinks && node.targetLinks.length) {
          return !isNil$1(node.targetLinks[0].x0);
      }
      return false;
  };
  const getAlignStartTexts = (nodes, offset = 0) => {
      const isVertical = isNodeVertical(nodes[0]);
      if (isVertical) {
          return nodes.map((node) => {
              return {
                  y: node.y1,
                  x: (node.x0 + node.x1) / 2,
                  datum: node.datum,
                  key: node.key
              };
          });
      }
      return nodes.map((node) => {
          return {
              x: node.x1,
              y: (node.y0 + node.y1) / 2,
              datum: node.datum,
              key: node.key
          };
      });
  };
  const getAlignEndTexts = (nodes, offset = 0) => {
      const isVertical = isNodeVertical(nodes[0]);
      if (isVertical) {
          return nodes.map((node) => {
              return {
                  y: node.y1 - offset,
                  x: (node.x0 + node.x1) / 2,
                  datum: node.datum,
                  key: node.key
              };
          });
      }
      return nodes.map((node) => {
          return {
              x: node.x0 - offset,
              y: (node.y0 + node.y1) / 2,
              datum: node.datum,
              key: node.key
          };
      });
  };

  const sankeyTransform = transform$7;

  function dice (parent, x0, y0, x1, y1, keyMap = { x0: 'x0', x1: 'x1', y0: 'y0', y1: 'y1' }) {
      const nodes = parent.children;
      let node;
      let i = -1;
      const n = nodes.length;
      const k = parent.value && (x1 - x0) / parent.value;
      while (++i < n) {
          node = nodes[i];
          node[keyMap.y0] = y0;
          node[keyMap.y1] = y1;
          node[keyMap.x0] = x0;
          node[keyMap.x1] = x0 += node.value * k;
      }
  }

  const keyMap = {
      x0: 'startAngle',
      x1: 'endAngle',
      y0: 'innerRadius',
      y1: 'outerRadius'
  };
  class SunburstLayout {
      constructor(options) {
          this._layoutNode = (parent) => {
              parent.maxDepth = this._maxDepth;
              if (parent.children) {
                  const ir = this._parsedInnerRadius[parent.depth + 1];
                  const or = this._parsedOutterRadius[parent.depth + 1];
                  dice(parent, parent.startAngle, Math.min(ir, or), parent.endAngle, Math.max(ir, or), keyMap);
                  const labelOption = isArray$1(this.options.label) ? this.options.label[parent.depth + 1] : this.options.label;
                  parent.children.forEach(child => {
                      child.x = this._parsedCenter[0];
                      child.y = this._parsedCenter[1];
                      if (labelOption) {
                          return this._layoutLabel(child, isBoolean$1(labelOption) ? { align: 'center', rotate: 'radial' } : labelOption);
                      }
                  });
              }
          };
          this.options = options
              ? Object.assign({}, SunburstLayout.defaultOpionts, options)
              : Object.assign({}, SunburstLayout.defaultOpionts);
          const keyOption = this.options.nodeKey;
          const keyFunc = isFunction$1(keyOption) ? keyOption : keyOption ? field$1(keyOption) : null;
          this._getNodeKey = keyFunc;
          this._maxDepth = -1;
      }
      _parseRadius(viewBox, maxDepth) {
          const cx = viewBox.x0 + toPercent(this.options.center[0], viewBox.width);
          const cy = viewBox.y0 + toPercent(this.options.center[1], viewBox.height);
          const maxRadius = Math.min(viewBox.width / 2, viewBox.height / 2);
          const innerRadius = this.options.innerRadius;
          const outerRadius = this.options.outerRadius;
          const isInnerArray = isArray$1(innerRadius);
          const parsedInnerRadius = isInnerArray
              ? innerRadius.map(entry => toPercent(entry, maxRadius))
              : toPercent(innerRadius, maxRadius);
          const isOuterArray = isArray$1(outerRadius);
          const gapRadius = this.options.gapRadius;
          const parsedOuterRadius = isOuterArray
              ? outerRadius.map(entry => toPercent(entry, maxRadius))
              : toPercent(outerRadius, maxRadius);
          const rangeArr = range(0, maxDepth + 1);
          if (isInnerArray) {
              this._parsedInnerRadius = rangeArr.map((entry, index) => {
                  const ir = parsedInnerRadius[index];
                  return isNil$1(ir) ? maxRadius : ir;
              });
              this._parsedOutterRadius = rangeArr.map((entry, index) => {
                  var _a, _b;
                  return isOuterArray
                      ? (_a = parsedOuterRadius[index]) !== null && _a !== void 0 ? _a : maxRadius
                      : index < maxDepth
                          ? this._parsedInnerRadius[index + 1] - (isArray$1(gapRadius) ? (_b = gapRadius[index]) !== null && _b !== void 0 ? _b : 0 : gapRadius)
                          : parsedOuterRadius;
              });
          }
          else if (isOuterArray) {
              this._parsedOutterRadius = rangeArr.map((entry, index) => {
                  return isNil$1(parsedOuterRadius[index]) ? maxRadius : parsedOuterRadius[index];
              });
              this._parsedInnerRadius = rangeArr.map((entry, index) => {
                  var _a;
                  return index === 0
                      ? parsedInnerRadius
                      : this._parsedOutterRadius[index - 1] - (isArray$1(gapRadius) ? (_a = gapRadius[index]) !== null && _a !== void 0 ? _a : 0 : gapRadius);
              });
          }
          else {
              const ir = toPercent(innerRadius, maxRadius);
              const or = parsedOuterRadius;
              const step = (or - ir) / (maxDepth + 1);
              this._parsedInnerRadius = rangeArr.map((entry, index) => {
                  return ir + index * step;
              });
              this._parsedOutterRadius = rangeArr.map((entry, index) => {
                  var _a;
                  return this._parsedInnerRadius[index] + step - (isArray$1(gapRadius) ? (_a = gapRadius[index]) !== null && _a !== void 0 ? _a : 0 : gapRadius);
              });
          }
          this._parsedCenter = [cx, cy];
          this._maxRadius = maxRadius;
      }
      layout(data, config) {
          const viewBox = 'width' in config
              ? { x0: 0, x1: config.width, y0: 0, y1: config.height, width: config.width, height: config.height }
              : {
                  x0: Math.min(config.x0, config.x1),
                  x1: Math.max(config.x0, config.x1),
                  y0: Math.min(config.y0, config.y1),
                  y1: Math.max(config.y0, config.y1),
                  width: Math.abs(config.x1 - config.x0),
                  height: Math.abs(config.y1 - config.y0)
              };
          if (!data || !data.length) {
              return [];
          }
          const nodes = [];
          const res = calculateNodeValue$1(data, nodes, 0, -1, null, this._getNodeKey);
          this._parseRadius(viewBox, res.maxDepth);
          this._maxDepth = res.maxDepth;
          this._layout(nodes, {
              flattenIndex: -1,
              maxDepth: -1,
              key: '-1',
              depth: -1,
              index: -1,
              value: res.sum,
              datum: null,
              children: nodes,
              startAngle: this.options.startAngle,
              endAngle: this.options.endAngle
          });
          return nodes;
      }
      _layout(nodes, parent) {
          this._layoutNode(parent);
          nodes.forEach(node => {
              var _a;
              if ((_a = node === null || node === void 0 ? void 0 : node.children) === null || _a === void 0 ? void 0 : _a.length) {
                  this._layout(node.children, node);
              }
              else {
                  this._layoutNode(node);
              }
          });
      }
      _layoutLabel(child, labelOption) {
          var _a;
          const angle = (child.startAngle + child.endAngle) / 2;
          const r = (labelOption.align === 'start'
              ? child.innerRadius
              : labelOption.align === 'end'
                  ? child.outerRadius
                  : (child.innerRadius + child.outerRadius) / 2) + ((_a = labelOption.offset) !== null && _a !== void 0 ? _a : 0);
          const pos = polarToCartesian({ x: this._parsedCenter[0], y: this._parsedCenter[1] }, r, angle);
          child.label = {
              x: pos.x,
              y: pos.y,
              textBaseline: 'middle'
          };
          if (labelOption.rotate === 'tangential') {
              child.label.angle = angle - Math.PI / 2;
              child.label.textAlign = 'center';
              child.label.maxLineWidth = Math.abs(child.endAngle - child.startAngle) * r;
          }
          else {
              const uniformAngle = angle % (Math.PI * 2);
              const formatAngle = uniformAngle < 0 ? uniformAngle + Math.PI * 2 : uniformAngle;
              if (formatAngle > Math.PI / 2 && formatAngle < Math.PI * 1.5) {
                  child.label.angle = formatAngle + Math.PI;
                  child.label.textAlign =
                      labelOption.align === 'start' ? 'end' : labelOption.align === 'end' ? 'start' : 'center';
              }
              else {
                  child.label.angle = formatAngle;
                  child.label.textAlign = labelOption.align;
              }
              child.label.maxLineWidth = child.isLeaf ? undefined : Math.abs(child.outerRadius - child.innerRadius);
          }
      }
  }
  SunburstLayout.defaultOpionts = {
      startAngle: Math.PI / 2,
      endAngle: (-3 * Math.PI) / 2,
      center: ['50%', '50%'],
      gapRadius: 0,
      innerRadius: 0,
      outerRadius: '70%'
  };

  const transform$6 = (options, upstreamData) => {
      const layout = new SunburstLayout(options);
      const res = layout.layout(upstreamData, 'width' in options
          ? {
              width: options.width,
              height: options.height
          }
          : {
              x0: options.x0,
              x1: options.x1,
              y0: options.y0,
              y1: options.y1
          });
      if (options.flatten) {
          const nodes = [];
          flattenNodes(res, nodes, { maxDepth: options === null || options === void 0 ? void 0 : options.maxDepth });
          return nodes;
      }
      return res;
  };

  const flattenTreeLinks = (nodes, output = [], options) => {
      const hasMaxDepth = (options === null || options === void 0 ? void 0 : options.maxDepth) >= 0;
      nodes.forEach(node => {
          if (!hasMaxDepth || node.depth <= options.maxDepth - 1) {
              if (node.children) {
                  node.children.forEach(child => {
                      var _a;
                      const link = {
                          source: node,
                          target: child,
                          x0: node.x,
                          y0: node.y,
                          x1: child.x,
                          y1: child.y,
                          key: `${node.key}~${child.key}`
                      };
                      output.push((options === null || options === void 0 ? void 0 : options.callback) ? options.callback(link) : link);
                      if ((_a = child.children) === null || _a === void 0 ? void 0 : _a.length) {
                          flattenTreeLinks([child], output, options);
                      }
                  });
              }
          }
      });
      return output;
  };

  function defaultSeparation$1(a, b) {
      return a.parentKey === b.parentKey ? 1 : 2;
  }
  function meanX(children) {
      return (children.reduce((x, c) => {
          return x + c.x;
      }, 0) / children.length);
  }
  function maxY(children) {
      return (1 +
          children.reduce((y, c) => {
              return Math.max(y, c.y);
          }, 0));
  }
  function leafLeft(node) {
      let children = node.children;
      while (children) {
          node = children[0];
          children = node.children;
      }
      return node;
  }
  function leafRight(node) {
      let children = node.children;
      while (children) {
          node = children[children.length - 1];
          children = node.children;
      }
      return node;
  }
  function clusterTree(root, viewBox, minNodeGap, linkWidth, separation = defaultSeparation$1) {
      let previousNode;
      let x = 0;
      eachAfter([root], node => {
          const children = node.children;
          if (children) {
              node.x = meanX(children);
              node.y = maxY(children);
          }
          else {
              node.x = previousNode ? (x += separation(node, previousNode)) : 0;
              node.y = 0;
              previousNode = node;
          }
      });
      if (isNumber$1(minNodeGap) && isNumber$1(linkWidth)) {
          eachAfter([root], node => {
              node.x = viewBox.x0 + (node.x - root.x) * minNodeGap;
              node.y = viewBox.y0 + (root.y - node.y) * linkWidth;
          });
      }
      else {
          const left = leafLeft(root);
          const right = leafRight(root);
          const x0 = left.x - separation(left, right) / 2;
          const x1 = right.x + separation(right, left) / 2;
          const kx = isNumber$1(minNodeGap) ? minNodeGap : viewBox.width / (x1 - x0);
          eachAfter([root], node => {
              node.x = viewBox.x0 + (node.x - x0) * kx;
              node.y = viewBox.y0 + (1 - (root.y ? node.y / root.y : 1)) * viewBox.height;
          });
      }
      return root;
  }

  function defaultSeparation(a, b) {
      return a.parentKey === b.parentKey ? 1 : 2;
  }
  function nextLeft(v) {
      const children = v.children;
      return children ? children[0] : v.t;
  }
  function nextRight(v) {
      const children = v.children;
      return children ? children[children.length - 1] : v.t;
  }
  function moveSubtree(wm, wp, shift) {
      const change = shift / (wp.i - wm.i);
      wp.c -= change;
      wp.s += shift;
      wm.c += change;
      wp.z += shift;
      wp.m += shift;
  }
  function executeShifts(v) {
      let shift = 0;
      let change = 0;
      const children = v.children;
      let i = children.length;
      let w;
      while (--i >= 0) {
          w = children[i];
          w.z += shift;
          w.m += shift;
          shift += w.s + (change += w.c);
      }
  }
  function nextAncestor(vim, v, ancestor) {
      var _a;
      const vimAncestor = (_a = vim.a) !== null && _a !== void 0 ? _a : vim;
      return vimAncestor.parent === v.parent ? vimAncestor : ancestor;
  }
  function createTreeNode(node, i) {
      return {
          _: node,
          i,
          parent: null,
          A: null,
          a: null,
          z: 0,
          m: 0,
          c: 0,
          s: 0,
          t: null
      };
  }
  function treeRoot(root) {
      const tree = createTreeNode(root, 0);
      const nodes = [tree];
      let child;
      let children;
      let i;
      let n;
      let node = nodes.pop();
      while (node) {
          children = node._.children;
          if (children) {
              n = children.length;
              node.children = new Array(n);
              for (i = n - 1; i >= 0; --i) {
                  child = createTreeNode(children[i], i);
                  node.children[i] = child;
                  nodes.push(child);
                  child.parent = node;
              }
          }
          node = nodes.pop();
      }
      tree.parent = createTreeNode(null, 0);
      tree.parent.children = [tree];
      return tree;
  }
  function tidyTree(root, viewBox, minNodeGap, linkWidth, separation = defaultSeparation) {
      const firstWalk = (v) => {
          const children = v.children;
          const siblings = v.parent.children;
          const w = v.i ? siblings[v.i - 1] : null;
          if (children) {
              executeShifts(v);
              const midpoint = (children[0].z + children[children.length - 1].z) / 2;
              if (w) {
                  v.z = w.z + separation(v._, w._);
                  v.m = v.z - midpoint;
              }
              else {
                  v.z = midpoint;
              }
          }
          else if (w) {
              v.z = w.z + separation(v._, w._);
          }
          v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
      };
      const secondWalk = (v) => {
          v._.x = v.z + v.parent.m;
          v.m += v.parent.m;
      };
      const apportion = (v, w, ancestor) => {
          if (w) {
              let vip = v;
              let vop = v;
              let vim = w;
              let vom = vip.parent.children[0];
              let sip = vip.m;
              let sop = vop.m;
              let sim = vim.m;
              let som = vom.m;
              let shift;
              vim = nextRight(vim);
              vip = nextLeft(vip);
              while (vim && vip) {
                  vom = nextLeft(vom);
                  vop = nextRight(vop);
                  vop.a = v;
                  shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                  if (shift > 0) {
                      moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
                      sip += shift;
                      sop += shift;
                  }
                  sim += vim.m;
                  sip += vip.m;
                  som += vom.m;
                  sop += vop.m;
                  vim = nextRight(vim);
                  vip = nextLeft(vip);
              }
              if (vim && !nextRight(vop)) {
                  vop.t = vim;
                  vop.m += sim - sop;
              }
              if (vip && !nextLeft(vom)) {
                  vom.t = vip;
                  vom.m += sip - som;
                  ancestor = v;
              }
          }
          return ancestor;
      };
      const t = treeRoot(root);
      eachAfter([t], firstWalk);
      t.parent.m = -t.z;
      eachBefore([t], secondWalk);
      let getY;
      if (isNumber$1(linkWidth)) {
          getY = (node) => {
              return node.depth * linkWidth;
          };
      }
      else if (isArray$1(linkWidth) && linkWidth.length) {
          const sumed = linkWidth.reduce((res, entry, index) => {
              res[index] = index === 0 ? entry : res[index - 1] + entry;
              return res;
          }, []);
          getY = (node) => {
              var _a;
              return (_a = sumed[node.depth]) !== null && _a !== void 0 ? _a : sumed[sumed.length - 1];
          };
      }
      if (isNumber$1(minNodeGap) && getY) {
          const setSizeOfNode = (node) => {
              node.x = viewBox.x0 + viewBox.width / 2 + node.x * minNodeGap;
              node.y = viewBox.y0 + getY(node);
          };
          eachBefore([root], setSizeOfNode);
      }
      else {
          let left = root;
          let right = root;
          let bottom = root;
          eachBefore([root], node => {
              if (node.x < left.x) {
                  left = node;
              }
              if (node.x > right.x) {
                  right = node;
              }
              if (node.depth > bottom.depth) {
                  bottom = node;
              }
          });
          const s = left === right ? 1 : separation(left, right) / 2;
          const tx = s - left.x;
          const kx = isNumber$1(minNodeGap) ? minNodeGap : viewBox.width / (right.x + s + tx);
          const ky = viewBox.height / (bottom.depth || 1);
          eachBefore([root], node => {
              node.x = viewBox.x0 + (node.x + tx) * kx;
              node.y = viewBox.y0 + (getY ? getY(node) : node.depth * ky);
          });
      }
      return root;
  }

  class TreeLayout {
      constructor(options) {
          this.options = Object.assign({}, TreeLayout.defaultOpionts, options);
          const keyOption = options === null || options === void 0 ? void 0 : options.nodeKey;
          const keyFunc = isFunction$1(keyOption) ? keyOption : keyOption ? field$1(keyOption) : null;
          this._getNodeKey = keyFunc;
          this._maxDepth = -1;
      }
      layout(data, config) {
          const formattedData = array(data);
          if (!formattedData.length) {
              return [];
          }
          const viewBox = 'width' in config
              ? { x0: 0, x1: config.width, y0: 0, y1: config.height, width: config.width, height: config.height }
              : {
                  x0: Math.min(config.x0, config.x1),
                  x1: Math.max(config.x0, config.x1),
                  y0: Math.min(config.y0, config.y1),
                  y1: Math.max(config.y0, config.y1),
                  width: Math.abs(config.x1 - config.x0),
                  height: Math.abs(config.y1 - config.y0)
              };
          const nodes = [];
          const res = calculateNodeValue$1(formattedData, nodes, 0, -1, null, this._getNodeKey);
          this._maxDepth = res.maxDepth;
          const isVertical = ['vertical', 'TB', 'BT'].includes(this.options.direction);
          const vb = this.options.layoutType === 'radial'
              ? {
                  x0: 0,
                  y0: 0,
                  x1: Math.PI * 2,
                  y1: Math.min(viewBox.width, viewBox.height) / 2,
                  width: Math.PI * 2,
                  height: Math.min(viewBox.width, viewBox.height) / 2
              }
              : isVertical
                  ? viewBox
                  : {
                      x0: viewBox.y0,
                      y0: viewBox.x0,
                      x1: viewBox.y1,
                      y1: viewBox.x1,
                      width: viewBox.height,
                      height: viewBox.width
                  };
          if (this.options.alignType === 'leaf') {
              clusterTree(nodes[0], vb, this.options.minNodeGap, this.options.linkWidth);
          }
          else {
              tidyTree(nodes[0], vb, this.options.minNodeGap, this.options.linkWidth);
          }
          if (this.options.layoutType === 'radial') {
              const center = {
                  x: (viewBox.x0 + viewBox.x1) / 2,
                  y: (viewBox.y0 + viewBox.y1) / 2
              };
              eachBefore(nodes, node => {
                  const angle = node.x;
                  const radius = node.y;
                  const res = polarToCartesian(center, radius, angle);
                  node.x = res.x;
                  node.y = res.y;
                  node.maxDepth = this._maxDepth;
              });
          }
          else {
              if (['BT', 'RL'].includes(this.options.direction)) {
                  eachBefore(nodes, node => {
                      node.y = vb.y0 + vb.y1 - node.y;
                      node.maxDepth = this._maxDepth;
                  });
              }
              else {
                  eachBefore(nodes, node => {
                      node.maxDepth = this._maxDepth;
                  });
              }
              if (!isVertical) {
                  eachBefore(nodes, node => {
                      [node.x, node.y] = [node.y, node.x];
                  });
              }
          }
          return nodes;
      }
  }
  TreeLayout.defaultOpionts = {
      direction: 'horizontal',
      alignType: 'depth',
      layoutType: 'orthogonal'
  };

  const transform$5 = (options, upstreamData) => {
      const layout = new TreeLayout(options);
      const res = layout.layout(upstreamData, 'width' in options
          ? {
              width: options.width,
              height: options.height
          }
          : {
              x0: options.x0,
              x1: options.x1,
              y0: options.y0,
              y1: options.y1
          });
      if (options.flatten) {
          const { maxDepth } = options !== null && options !== void 0 ? options : {};
          const nodes = [];
          flattenNodes(res, nodes, { maxDepth });
          const links = [];
          flattenTreeLinks(res, links, { maxDepth });
          return { nodes, links };
      }
      return res;
  };

  function binary (parent, x0, y0, x1, y1) {
      const nodes = parent.children;
      const n = nodes.length;
      let sum = 0;
      const sums = new Array(n + 1);
      sums[0] = 0;
      for (let i = 0; i < n; ++i) {
          sum += nodes[i].value;
          sums[i + 1] = sum;
      }
      const partition = (i, j, value, x0, y0, x1, y1) => {
          if (i >= j - 1) {
              const node = nodes[i];
              node.x0 = x0;
              node.y0 = y0;
              node.x1 = x1;
              node.y1 = y1;
              return;
          }
          const valueOffset = sums[i];
          const valueTarget = value / 2 + valueOffset;
          let k = i + 1;
          let hi = j - 1;
          while (k < hi) {
              const mid = (k + hi) >>> 1;
              if (sums[mid] < valueTarget) {
                  k = mid + 1;
              }
              else {
                  hi = mid;
              }
          }
          if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i + 1 < k) {
              --k;
          }
          const valueLeft = sums[k] - valueOffset;
          const valueRight = value - valueLeft;
          if (x1 - x0 > y1 - y0) {
              const xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
              partition(i, k, valueLeft, x0, y0, xk, y1);
              partition(k, j, valueRight, xk, y0, x1, y1);
          }
          else {
              const yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
              partition(i, k, valueLeft, x0, y0, x1, yk);
              partition(k, j, valueRight, x0, yk, x1, y1);
          }
      };
      partition(0, n, parent.value, x0, y0, x1, y1);
  }

  function slice (parent, x0, y0, x1, y1) {
      const nodes = parent.children;
      let node;
      let i = -1;
      const n = nodes.length;
      const k = parent.value && (y1 - y0) / parent.value;
      while (++i < n) {
          node = nodes[i];
          node.x0 = x0;
          node.x1 = x1;
          node.y0 = y0;
          y0 += node.value * k;
          node.y1 = y0;
      }
  }

  function sliceDice (parent, x0, y0, x1, y1) {
      (parent.depth % 2 === 1 ? slice : dice)(parent, x0, y0, x1, y1);
  }

  function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
      const rows = [];
      const nodes = parent.children;
      let row;
      let nodeValue;
      let i0 = 0;
      let i1 = 0;
      const n = nodes.length;
      let dx;
      let dy;
      let value = parent.value;
      let sumValue;
      let minValue;
      let maxValue;
      let newRatio;
      let minRatio;
      let alpha;
      let beta;
      while (i0 < n) {
          dx = x1 - x0;
          dy = y1 - y0;
          do {
              sumValue = nodes[i1++].value;
          } while (!sumValue && i1 < n);
          minValue = sumValue;
          maxValue = sumValue;
          alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
          beta = sumValue * sumValue * alpha;
          minRatio = Math.max(maxValue / beta, beta / minValue);
          for (; i1 < n; ++i1) {
              nodeValue = nodes[i1].value;
              sumValue += nodeValue;
              if (nodeValue < minValue) {
                  minValue = nodeValue;
              }
              if (nodeValue > maxValue) {
                  maxValue = nodeValue;
              }
              beta = sumValue * sumValue * alpha;
              newRatio = Math.max(maxValue / beta, beta / minValue);
              if (newRatio > minRatio) {
                  sumValue -= nodeValue;
                  break;
              }
              minRatio = newRatio;
          }
          row = Object.assign({}, parent, { value: sumValue, children: nodes.slice(i0, i1) });
          rows.push(row);
          if (dx < dy) {
              dice(row, x0, y0, x1, value ? (y0 += (dy * sumValue) / value) : y1);
          }
          else {
              slice(row, x0, y0, value ? (x0 += (dx * sumValue) / value) : x1, y1);
          }
          value -= sumValue;
          i0 = i1;
      }
      return rows;
  }
  const generateSquarify = (ratio) => {
      return (parent, x0, y0, x1, y1) => {
          squarifyRatio(ratio, parent, x0, y0, x1, y1);
      };
  };

  const algorithms = { binary, dice, slice, sliceDice };
  class TreemapLayout {
      constructor(options) {
          var _a;
          this._filterByArea = (node, ratio) => {
              var _a;
              const minArea = this._getMinAreaByDepth(node.depth);
              if (minArea > 0 && node.value * ratio < minArea) {
                  return false;
              }
              else if ((_a = node.children) === null || _a === void 0 ? void 0 : _a.length) {
                  const newChildren = node.children.filter(child => {
                      return this._filterByArea(child, ratio);
                  });
                  if (!newChildren.length) {
                      node.isLeaf = true;
                      node.children = null;
                  }
                  else if (newChildren.length !== node.children.length) {
                      node.children = newChildren;
                  }
              }
              return true;
          };
          this._getMinAreaByDepth = (depth) => {
              var _a;
              if (depth < 0) {
                  return 0;
              }
              return ((_a = (isArray$1(this.options.minVisibleArea) ? this.options.minVisibleArea[depth] : this.options.minVisibleArea)) !== null && _a !== void 0 ? _a : 0);
          };
          this._getGapWidthByDepth = (depth) => {
              var _a;
              if (depth < 0) {
                  return 0;
              }
              return (_a = (isArray$1(this.options.gapWidth) ? this.options.gapWidth[depth] : this.options.gapWidth)) !== null && _a !== void 0 ? _a : 0;
          };
          this._getPaddingByDepth = (depth) => {
              var _a;
              if (depth < 0) {
                  return 0;
              }
              return (_a = (isArray$1(this.options.padding) ? this.options.padding[depth] : this.options.padding)) !== null && _a !== void 0 ? _a : 0;
          };
          this._getLabelPaddingByDepth = (depth) => {
              var _a;
              if (depth < 0) {
                  return 0;
              }
              return (_a = (isArray$1(this.options.labelPadding) ? this.options.labelPadding[depth] : this.options.labelPadding)) !== null && _a !== void 0 ? _a : 0;
          };
          this._layoutNode = (parent) => {
              const gapWidth = this._getGapWidthByDepth(parent.depth);
              let x0 = parent.x0;
              let y0 = parent.y0;
              let x1 = parent.x1;
              let y1 = parent.y1;
              parent.maxDepth = this._maxDepth;
              if (gapWidth > 0) {
                  x0 += gapWidth / 2;
                  x1 -= gapWidth / 2;
                  y0 += gapWidth / 2;
                  y1 -= gapWidth / 2;
                  if (x0 > x1) {
                      x0 = (x0 + x1) / 2;
                      x1 = x0;
                  }
                  if (y0 > y1) {
                      y0 = (y0 + y1) / 2;
                      y1 = y0;
                  }
                  parent.x0 = x0;
                  parent.x1 = x1;
                  parent.y0 = y0;
                  parent.y1 = y1;
              }
              if (parent.children) {
                  const labelPadding = this._getLabelPaddingByDepth(parent.depth);
                  const padding = this._getPaddingByDepth(parent.depth);
                  if (padding > 0) {
                      if (padding < Math.min(x1 - x0, y1 - y0) / 2) {
                          y0 += padding;
                          y1 -= padding;
                          x0 += padding;
                          x1 -= padding;
                      }
                  }
                  if (labelPadding > 0) {
                      if (this.options.labelPosition === 'top' && y0 + labelPadding < y1) {
                          parent.labelRect = { x0: x0, y0: y0, x1, y1: y0 + labelPadding };
                          y0 += labelPadding;
                      }
                      else if (this.options.labelPosition === 'bottom' && y1 - labelPadding > y0) {
                          parent.labelRect = { x0: x0, y0: y1 - labelPadding, x1, y1: y1 };
                          y1 -= labelPadding;
                      }
                      else if (this.options.labelPosition === 'left' && x0 + labelPadding < x1) {
                          parent.labelRect = { x0: x0, y0: y0, x1: x0 + labelPadding, y1 };
                          x0 += labelPadding;
                      }
                      else if (this.options.labelPosition === 'right' && x1 - labelPadding > x0) {
                          parent.labelRect = { x0: x1 - labelPadding, y0: y0, x1: x1, y1 };
                          x1 -= labelPadding;
                      }
                  }
                  const childGapWidth = this._getGapWidthByDepth(parent.depth + 1);
                  if (childGapWidth > 0) {
                      x0 -= childGapWidth / 2;
                      x1 += childGapWidth / 2;
                      y0 -= childGapWidth / 2;
                      y1 += childGapWidth / 2;
                  }
                  this._splitNode(parent, x0, y0, x1, y1);
              }
          };
          this.options = Object.assign({}, TreemapLayout.defaultOpionts, options);
          const keyOption = this.options.nodeKey;
          const keyFunc = isFunction$1(keyOption) ? keyOption : keyOption ? field$1(keyOption) : null;
          this._getNodeKey = keyFunc;
          this._splitNode =
              this.options.splitType === 'squarify'
                  ? generateSquarify(this.options.aspectRatio)
                  : (_a = algorithms[this.options.splitType]) !== null && _a !== void 0 ? _a : algorithms.binary;
          this._maxDepth = -1;
      }
      layout(data, config) {
          var _a;
          if (!data || !data.length) {
              return [];
          }
          const viewBox = 'width' in config
              ? { x0: 0, x1: config.width, y0: 0, y1: config.height, width: config.width, height: config.height }
              : {
                  x0: Math.min(config.x0, config.x1),
                  x1: Math.max(config.x0, config.x1),
                  y0: Math.min(config.y0, config.y1),
                  y1: Math.max(config.y0, config.y1),
                  width: Math.abs(config.x1 - config.x0),
                  height: Math.abs(config.y1 - config.y0)
              };
          const nodes = [];
          const res = calculateNodeValue$1(data, nodes, 0, -1, null, this._getNodeKey, this.options.valueField);
          this._maxDepth = res.maxDepth;
          if (res.sum <= 0) {
              return [];
          }
          const root = {
              flattenIndex: -1,
              maxDepth: -1,
              key: '-1',
              depth: -1,
              index: -1,
              value: res.sum,
              datum: null,
              x0: viewBox.x0,
              x1: viewBox.x1,
              y0: viewBox.y0,
              y1: viewBox.y1,
              children: nodes
          };
          const areaRatio = (viewBox.width * viewBox.height) / res.sum;
          this._filterByArea(root, areaRatio);
          this._layout(root);
          return (_a = root.children) !== null && _a !== void 0 ? _a : [];
      }
      _filterChildren(node) {
          const maxDepth = this.options.maxDepth;
          if (isNumber$1(maxDepth) && maxDepth >= 0 && node.depth >= maxDepth) {
              return false;
          }
          const minChildrenVisibleArea = this.options.minChildrenVisibleArea;
          if (isNumber$1(minChildrenVisibleArea) &&
              Math.abs((node.x1 - node.x0) * (node.y1 - node.y0)) < minChildrenVisibleArea) {
              return false;
          }
          const minChildrenVisibleSize = this.options.minChildrenVisibleSize;
          if (isNumber$1(minChildrenVisibleSize) &&
              (Math.abs(node.x1 - node.x0) < minChildrenVisibleSize || Math.abs(node.y1 - node.y0) < minChildrenVisibleSize)) {
              return false;
          }
          return true;
      }
      _layout(parent) {
          var _a;
          if (!this._filterChildren(parent)) {
              parent.children = null;
              parent.isLeaf = true;
          }
          this._layoutNode(parent);
          if ((_a = parent.children) === null || _a === void 0 ? void 0 : _a.length) {
              parent.children.forEach(child => {
                  var _a;
                  if ((_a = child === null || child === void 0 ? void 0 : child.children) === null || _a === void 0 ? void 0 : _a.length) {
                      this._layout(child);
                  }
                  else {
                      this._layoutNode(child);
                  }
              });
          }
      }
  }
  TreemapLayout.defaultOpionts = {
      aspectRatio: (1 + Math.sqrt(5)) / 2,
      gapWidth: 0,
      labelPadding: 0,
      labelPosition: 'top',
      splitType: 'binary',
      minVisibleArea: 10
  };

  const transform$4 = (options, upstreamData) => {
      const layout = new TreemapLayout(options);
      const res = layout.layout(upstreamData, 'width' in options
          ? {
              width: options.width,
              height: options.height
          }
          : {
              x0: options.x0,
              x1: options.x1,
              y0: options.y0,
              y1: options.y1
          });
      if (options.flatten) {
          const nodes = [];
          flattenNodes(res, nodes, { maxDepth: options === null || options === void 0 ? void 0 : options.maxDepth });
          return nodes;
      }
      return res;
  };

  function distanceFromIntersectArea(r1, r2, overlap) {
      if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL) {
          return Math.abs(r1 - r2);
      }
      return findZeroOfFunction(function (distance) {
          return circleOverlap(r1, r2, distance) - overlap;
      }, 0, r1 + r2);
  }
  function getDistanceMatrices(areas, sets, setIds) {
      const distances = zerosM(sets.length, sets.length);
      const constraints = zerosM(sets.length, sets.length);
      areas
          .filter(function (x) {
          return x.sets.length === 2;
      })
          .map(current => {
          const left = setIds[current.sets[0]];
          const right = setIds[current.sets[1]];
          const r1 = Math.sqrt(sets[left].size / Math.PI);
          const r2 = Math.sqrt(sets[right].size / Math.PI);
          const distance = distanceFromIntersectArea(r1, r2, current.size);
          distances[left][right] = distances[right][left] = distance;
          let c = 0;
          if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {
              c = 1;
          }
          else if (current.size <= 1e-10) {
              c = -1;
          }
          constraints[left][right] = constraints[right][left] = c;
      });
      return { distances, constraints };
  }

  function constrainedMDSLayout(areas, params) {
      params = params || {};
      const restarts = params.restarts || 10;
      const sets = [];
      const setIds = {};
      let i;
      for (i = 0; i < areas.length; ++i) {
          const area = areas[i];
          if (area.sets.length === 1) {
              setIds[area.sets[0]] = sets.length;
              sets.push(area);
          }
      }
      const matrices = getDistanceMatrices(areas, sets, setIds);
      let distances = matrices.distances;
      const constraints = matrices.constraints;
      const norm = norm2(distances.map(norm2)) / distances.length;
      distances = distances.map((row) => {
          return row.map(value => {
              return value / norm;
          });
      });
      const obj = function (x, fxPrime) {
          return constrainedMDSGradient(x, fxPrime, distances, constraints);
      };
      let best;
      let current;
      for (i = 0; i < restarts; ++i) {
          const initial = zeros(distances.length * 2).map((entry, i) => seedRandom(i));
          current = conjugateGradient(obj, initial, params);
          if (!best || current.fx < best.fx) {
              best = current;
          }
      }
      const positions = best.x;
      const circles = {};
      for (i = 0; i < sets.length; ++i) {
          const set = sets[i];
          circles[set.sets[0]] = {
              x: positions[2 * i] * norm,
              y: positions[2 * i + 1] * norm,
              radius: Math.sqrt(set.size / Math.PI)
          };
      }
      if (params.history) {
          for (i = 0; i < params.history.length; ++i) {
              scale(params.history[i].x, norm);
          }
      }
      return circles;
  }
  function constrainedMDSGradient(x, fxPrime, distances, constraints) {
      let loss = 0;
      let i;
      for (i = 0; i < fxPrime.length; ++i) {
          fxPrime[i] = 0;
      }
      for (i = 0; i < distances.length; ++i) {
          const xi = x[2 * i];
          const yi = x[2 * i + 1];
          for (let j = i + 1; j < distances.length; ++j) {
              const xj = x[2 * j];
              const yj = x[2 * j + 1];
              const dij = distances[i][j];
              const constraint = constraints[i][j];
              const squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi);
              const distance = Math.sqrt(squaredDistance);
              const delta = squaredDistance - dij * dij;
              if ((constraint > 0 && distance <= dij) || (constraint < 0 && distance >= dij)) {
                  continue;
              }
              loss += 2 * delta * delta;
              fxPrime[2 * i] += 4 * delta * (xi - xj);
              fxPrime[2 * i + 1] += 4 * delta * (yi - yj);
              fxPrime[2 * j] += 4 * delta * (xj - xi);
              fxPrime[2 * j + 1] += 4 * delta * (yj - yi);
          }
      }
      return loss;
  }

  function lossFunction(sets, overlaps) {
      let output = 0;
      function getCircles(indices) {
          return indices.map(function (i) {
              return sets[i];
          });
      }
      for (let i = 0; i < overlaps.length; ++i) {
          const area = overlaps[i];
          let overlap;
          if (area.sets.length === 1) {
              continue;
          }
          else if (area.sets.length === 2) {
              const left = sets[area.sets[0]];
              const right = sets[area.sets[1]];
              overlap = circleOverlap(left.radius, right.radius, PointService.distancePP(left, right));
          }
          else {
              overlap = intersectionArea(getCircles(area.sets));
          }
          const weight = area.hasOwnProperty('weight') ? area.weight : 1.0;
          output += weight * (overlap - area.size) * (overlap - area.size);
      }
      return output;
  }

  function greedyLayout(areas, params) {
      const loss = params && params.lossFunction ? params.lossFunction : lossFunction;
      const circles = {};
      const setOverlaps = {};
      for (let i = 0; i < areas.length; ++i) {
          const area = areas[i];
          if (area.sets.length === 1) {
              const set = area.sets[0];
              circles[set] = {
                  x: 1e10,
                  y: 1e10,
                  size: area.size,
                  radius: Math.sqrt(area.size / Math.PI),
                  setId: set
              };
              setOverlaps[set] = [];
          }
      }
      areas = areas.filter(function (a) {
          return a.sets.length === 2;
      });
      for (let i = 0; i < areas.length; ++i) {
          const current = areas[i];
          let weight = current.hasOwnProperty('weight') ? current.weight : 1.0;
          const left = current.sets[0];
          const right = current.sets[1];
          if (current.size + SMALL >= Math.min(circles[left].size, circles[right].size)) {
              weight = 0;
          }
          setOverlaps[left].push({ set: right, size: current.size, weight: weight });
          setOverlaps[right].push({ set: left, size: current.size, weight: weight });
      }
      const mostOverlapped = [];
      for (const set in setOverlaps) {
          if (setOverlaps.hasOwnProperty(set)) {
              let size = 0;
              for (let i = 0; i < setOverlaps[set].length; ++i) {
                  size += setOverlaps[set][i].size * setOverlaps[set][i].weight;
              }
              mostOverlapped.push({ set, size });
          }
      }
      function sortOrder(a, b) {
          return b.size - a.size;
      }
      mostOverlapped.sort(sortOrder);
      const positioned = {};
      function isPositioned(element) {
          return element.set in positioned;
      }
      function positionSet(point, index) {
          circles[index].x = point.x;
          circles[index].y = point.y;
          positioned[index] = true;
      }
      positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
      for (let i = 1; i < mostOverlapped.length; ++i) {
          const setIndex = mostOverlapped[i].set;
          const overlap = setOverlaps[setIndex].filter(isPositioned);
          const set = circles[setIndex];
          overlap.sort(sortOrder);
          if (overlap.length === 0) {
              throw 'ERROR: missing pairwise overlap information';
          }
          const points = [];
          for (let j = 0; j < overlap.length; ++j) {
              const p1 = circles[overlap[j].set];
              const d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size);
              points.push({ x: p1.x + d1, y: p1.y });
              points.push({ x: p1.x - d1, y: p1.y });
              points.push({ y: p1.y + d1, x: p1.x });
              points.push({ y: p1.y - d1, x: p1.x });
              for (let k = j + 1; k < overlap.length; ++k) {
                  const p2 = circles[overlap[k].set];
                  const d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);
                  const extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p2.x, y: p2.y, radius: d2 });
                  for (let l = 0; l < extraPoints.length; ++l) {
                      points.push(extraPoints[l]);
                  }
              }
          }
          let bestLoss = 1e50;
          let bestPoint = points[0];
          for (let j = 0; j < points.length; ++j) {
              circles[setIndex].x = points[j].x;
              circles[setIndex].y = points[j].y;
              const localLoss = loss(circles, areas);
              if (localLoss < bestLoss) {
                  bestLoss = localLoss;
                  bestPoint = points[j];
              }
          }
          positionSet(bestPoint, setIndex);
      }
      return circles;
  }

  function venn(areas, parameters) {
      parameters = parameters || {};
      parameters.maxIterations = parameters.maxIterations || 500;
      const initialLayout = parameters.initialLayout || bestInitialLayout;
      const loss = parameters.lossFunction || lossFunction;
      areas = addMissingAreas(areas);
      const circles = initialLayout(areas, parameters);
      const initial = [];
      const setIds = [];
      for (const setId in circles) {
          if (circles.hasOwnProperty(setId)) {
              initial.push(circles[setId].x);
              initial.push(circles[setId].y);
              setIds.push(setId);
          }
      }
      const solution = nelderMead(function (values) {
          const current = {};
          for (let i = 0; i < setIds.length; ++i) {
              const setId = setIds[i];
              current[setId] = {
                  x: values[2 * i],
                  y: values[2 * i + 1],
                  radius: circles[setId].radius
              };
          }
          return loss(current, areas);
      }, initial, parameters);
      const positions = solution.x;
      for (let i = 0; i < setIds.length; ++i) {
          const setId = setIds[i];
          circles[setId].x = positions[2 * i];
          circles[setId].y = positions[2 * i + 1];
      }
      return circles;
  }
  function addMissingAreas(areas) {
      areas = areas.slice();
      const ids = [];
      const pairs = {};
      for (let i = 0; i < areas.length; ++i) {
          const area = areas[i];
          if (area.sets.length === 1) {
              ids.push(area.sets[0]);
          }
          else if (area.sets.length === 2) {
              const a = area.sets[0];
              const b = area.sets[1];
              pairs[[a, b].toString()] = true;
              pairs[[b, a].toString()] = true;
          }
      }
      ids.sort(function (a, b) {
          return +(a > b);
      });
      for (let i = 0; i < ids.length; ++i) {
          const a = ids[i];
          for (let j = i + 1; j < ids.length; ++j) {
              const b = ids[j];
              if (!([a, b].toString() in pairs)) {
                  areas.push({ sets: [a, b], size: 0 });
              }
          }
      }
      return areas;
  }
  function bestInitialLayout(areas, params) {
      let initial = greedyLayout(areas, params);
      const loss = params.lossFunction || lossFunction;
      if (areas.length >= 8) {
          const constrained = constrainedMDSLayout(areas, params);
          const constrainedLoss = loss(constrained, areas);
          const greedyLoss = loss(initial, areas);
          if (constrainedLoss + 1e-8 < greedyLoss) {
              initial = constrained;
          }
      }
      return initial;
  }

  function orientateCircles(circles, orientation, orientationOrder) {
      if (orientationOrder === null) {
          circles.sort(function (a, b) {
              return b.radius - a.radius;
          });
      }
      else {
          circles.sort(orientationOrder);
      }
      let i;
      if (circles.length > 0) {
          const largestX = circles[0].x;
          const largestY = circles[0].y;
          for (i = 0; i < circles.length; ++i) {
              circles[i].x -= largestX;
              circles[i].y -= largestY;
          }
      }
      if (circles.length === 2) {
          const dist = PointService.distancePP(circles[0], circles[1]);
          if (dist < Math.abs(circles[1].radius - circles[0].radius)) {
              circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;
              circles[1].y = circles[0].y;
          }
      }
      if (circles.length > 1) {
          const rotation = Math.atan2(circles[1].x, circles[1].y) - orientation;
          const c = Math.cos(rotation);
          const s = Math.sin(rotation);
          let x;
          let y;
          for (i = 0; i < circles.length; ++i) {
              x = circles[i].x;
              y = circles[i].y;
              circles[i].x = c * x - s * y;
              circles[i].y = s * x + c * y;
          }
      }
      if (circles.length > 2) {
          let angle = Math.atan2(circles[2].x, circles[2].y) - orientation;
          while (angle < 0) {
              angle += 2 * Math.PI;
          }
          while (angle > 2 * Math.PI) {
              angle -= 2 * Math.PI;
          }
          if (angle > Math.PI) {
              const slope = circles[1].y / (1e-10 + circles[1].x);
              for (i = 0; i < circles.length; ++i) {
                  const d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope);
                  circles[i].x = 2 * d - circles[i].x;
                  circles[i].y = 2 * d * slope - circles[i].y;
              }
          }
      }
  }
  function disjointCluster(circles) {
      circles.map(function (circle) {
          circle.parent = circle;
      });
      function find(circle) {
          if (circle.parent !== circle) {
              circle.parent = find(circle.parent);
          }
          return circle.parent;
      }
      function union(x, y) {
          const xRoot = find(x);
          const yRoot = find(y);
          xRoot.parent = yRoot;
      }
      for (let i = 0; i < circles.length; ++i) {
          for (let j = i + 1; j < circles.length; ++j) {
              const maxDistance = circles[i].radius + circles[j].radius;
              if (PointService.distancePP(circles[i], circles[j]) + 1e-10 < maxDistance) {
                  union(circles[j], circles[i]);
              }
          }
      }
      const disjointClusters = {};
      let setId;
      for (let i = 0; i < circles.length; ++i) {
          setId = find(circles[i]).parent.setId;
          if (!(setId in disjointClusters)) {
              disjointClusters[setId] = [];
          }
          disjointClusters[setId].push(circles[i]);
      }
      circles.map(function (circle) {
          delete circle.parent;
      });
      const ret = [];
      for (setId in disjointClusters) {
          if (disjointClusters.hasOwnProperty(setId)) {
              ret.push(disjointClusters[setId]);
          }
      }
      return ret;
  }
  function getBoundingBox(circles) {
      const minMax = function (d) {
          const hi = Math.max.apply(null, circles.map(function (c) {
              return c[d] + c.radius;
          }));
          const lo = Math.min.apply(null, circles.map(function (c) {
              return c[d] - c.radius;
          }));
          return { max: hi, min: lo };
      };
      return { xRange: minMax('x'), yRange: minMax('y') };
  }

  function normalizeSolution(solution, orientation, orientationOrder) {
      if (orientation === null) {
          orientation = Math.PI / 2;
      }
      let circles = [];
      for (const setId in solution) {
          if (solution.hasOwnProperty(setId)) {
              const previous = solution[setId];
              circles.push({ x: previous.x, y: previous.y, radius: previous.radius, setId });
          }
      }
      const clusters = disjointCluster(circles);
      for (let i = 0; i < clusters.length; ++i) {
          orientateCircles(clusters[i], orientation, orientationOrder);
          const bounds = getBoundingBox(clusters[i]);
          clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);
          clusters[i].bounds = bounds;
      }
      clusters.sort(function (a, b) {
          return b.size - a.size;
      });
      circles = clusters[0];
      let returnBounds = circles.bounds;
      const spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;
      function addCluster(cluster, right, bottom) {
          if (!cluster) {
              return;
          }
          const bounds = cluster.bounds;
          let xOffset;
          let yOffset;
          let centering;
          if (right) {
              xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;
          }
          else {
              xOffset = returnBounds.xRange.max - bounds.xRange.max;
              centering = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;
              if (centering < 0) {
                  xOffset += centering;
              }
          }
          if (bottom) {
              yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;
          }
          else {
              yOffset = returnBounds.yRange.max - bounds.yRange.max;
              centering = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;
              if (centering < 0) {
                  yOffset += centering;
              }
          }
          for (let j = 0; j < cluster.length; ++j) {
              cluster[j].x += xOffset;
              cluster[j].y += yOffset;
              circles.push(cluster[j]);
          }
      }
      let index = 1;
      while (index < clusters.length) {
          addCluster(clusters[index], true, false);
          addCluster(clusters[index + 1], false, true);
          addCluster(clusters[index + 2], true, true);
          index += 3;
          returnBounds = getBoundingBox(circles);
      }
      const ret = {};
      for (let i = 0; i < circles.length; ++i) {
          ret[circles[i].setId] = circles[i];
      }
      return ret;
  }

  function scaleSolution(solution, width, height, x0, y0, hasEmptySet = false) {
      width = Math.max(width, 1);
      height = Math.max(height, 1);
      const circles = [];
      const setIds = [];
      for (const setId in solution) {
          if (solution.hasOwnProperty(setId)) {
              setIds.push(setId);
              circles.push(solution[setId]);
          }
      }
      const bounds = getBoundingBox(circles);
      const xRange = bounds.xRange;
      const yRange = bounds.yRange;
      if (xRange.max === xRange.min || yRange.max === yRange.min) {
          console.log('not scaling solution: zero size detected');
          return solution;
      }
      const xScaling = width / (xRange.max - xRange.min);
      const yScaling = height / (yRange.max - yRange.min);
      let scaling;
      if (hasEmptySet) {
          const containerRadius = Math.min(width, height) / 2;
          const centerX = (xRange.min + xRange.max) / 2;
          const centerY = (yRange.min + yRange.max) / 2;
          let diagramRadius = 0;
          for (const circle of circles) {
              const distanceToCenter = Math.sqrt(Math.pow(circle.x - centerX, 2) + Math.pow(circle.y - centerY, 2));
              const maxDistanceForThisCircle = distanceToCenter + circle.radius;
              diagramRadius = Math.max(diagramRadius, maxDistanceForThisCircle);
          }
          scaling = containerRadius / diagramRadius;
      }
      else {
          scaling = Math.min(yScaling, xScaling);
      }
      const xOffset = (width - (xRange.max - xRange.min) * scaling) / 2;
      const yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
      const scaled = {};
      for (let i = 0; i < circles.length; ++i) {
          const circle = circles[i];
          scaled[setIds[i]] = {
              radius: scaling * circle.radius,
              x: x0 + xOffset + (circle.x - xRange.min) * scaling,
              y: y0 + yOffset + (circle.y - yRange.min) * scaling,
              setId: circle.setId
          };
      }
      return scaled;
  }

  function computeTextCenters(circles, areas) {
      const ret = {};
      const overlapped = getOverlappingCircles(circles);
      for (let i = 0; i < areas.length; ++i) {
          const area = areas[i].sets;
          const areaIds = {};
          const exclude = {};
          for (let j = 0; j < area.length; ++j) {
              areaIds[area[j]] = true;
              const overlaps = overlapped[area[j]];
              for (let k = 0; k < overlaps.length; ++k) {
                  exclude[overlaps[k]] = true;
              }
          }
          const interior = [];
          const exterior = [];
          for (const setId in circles) {
              if (setId in areaIds) {
                  interior.push(circles[setId]);
              }
              else if (!(setId in exclude)) {
                  exterior.push(circles[setId]);
              }
          }
          const center = computeTextCenter(interior, exterior);
          ret[area.toString()] = center;
          if (center.disjoint && areas[i].size > 0) {
              const logger = Logger.getInstance();
              logger.error('Area ' + area + ' not represented on screen');
          }
      }
      return ret;
  }
  function getOverlappingCircles(circles) {
      const ret = {};
      const circleIds = [];
      for (const circleId in circles) {
          circleIds.push(circleId);
          ret[circleId] = [];
      }
      for (let i = 0; i < circleIds.length; i++) {
          const a = circles[circleIds[i]];
          for (let j = i + 1; j < circleIds.length; ++j) {
              const b = circles[circleIds[j]];
              const d = PointService.distancePP(a, b);
              if (d + b.radius <= a.radius + 1e-10) {
                  ret[circleIds[j]].push(circleIds[i]);
              }
              else if (d + a.radius <= b.radius + 1e-10) {
                  ret[circleIds[i]].push(circleIds[j]);
              }
          }
      }
      return ret;
  }
  function computeTextCenter(interior, exterior) {
      const points = [];
      for (let i = 0; i < interior.length; ++i) {
          const c = interior[i];
          points.push({ x: c.x, y: c.y });
          points.push({ x: c.x + c.radius / 2, y: c.y });
          points.push({ x: c.x - c.radius / 2, y: c.y });
          points.push({ x: c.x, y: c.y + c.radius / 2 });
          points.push({ x: c.x, y: c.y - c.radius / 2 });
      }
      let initial = points[0];
      let margin = circleMargin(points[0], interior, exterior);
      for (let i = 1; i < points.length; ++i) {
          const m = circleMargin(points[i], interior, exterior);
          if (m >= margin) {
              initial = points[i];
              margin = m;
          }
      }
      const solution = nelderMead(function (p) {
          return -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior);
      }, [initial.x, initial.y], { maxIterations: 500, minErrorDelta: 1e-10 }).x;
      let ret = { x: solution[0], y: solution[1] };
      let valid = true;
      for (let i = 0; i < interior.length; ++i) {
          if (PointService.distancePP(ret, interior[i]) > interior[i].radius) {
              valid = false;
              break;
          }
      }
      for (let i = 0; i < exterior.length; ++i) {
          if (PointService.distancePP(ret, exterior[i]) < exterior[i].radius) {
              valid = false;
              break;
          }
      }
      if (!valid) {
          if (interior.length === 1) {
              ret = { x: interior[0].x, y: interior[0].y };
          }
          else {
              const areaStats = {};
              intersectionArea(interior, areaStats);
              if (areaStats.arcs.length === 0) {
                  ret = { x: 0, y: -1000, disjoint: true };
              }
              else if (areaStats.arcs.length === 1) {
                  ret = { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };
              }
              else if (exterior.length) {
                  ret = computeTextCenter(interior, []);
              }
              else {
                  ret = getCenter(areaStats.arcs.map(function (a) {
                      return a.p1;
                  }));
              }
          }
      }
      return ret;
  }
  function circleMargin(current, interior, exterior) {
      let margin = interior[0].radius - PointService.distancePP(interior[0], current);
      let i;
      let m;
      for (i = 1; i < interior.length; ++i) {
          m = interior[i].radius - PointService.distancePP(interior[i], current);
          if (m <= margin) {
              margin = m;
          }
      }
      for (i = 0; i < exterior.length; ++i) {
          m = PointService.distancePP(exterior[i], current) - exterior[i].radius;
          if (m <= margin) {
              margin = m;
          }
      }
      return margin;
  }

  const getArcsFromCircles = (circles) => {
      const areaStats = {};
      const circleList = Object.values(circles);
      if (!circleList.length) {
          return [];
      }
      intersectionArea(circleList, areaStats);
      const arcs = areaStats.arcs.map(({ p1, p2, circle, width }) => ({
          p1,
          p2,
          radius: circle.radius,
          setId: circle.setId,
          largeArcFlag: width > circle.radius
      }));
      const result = [];
      let i = 0;
      let arc = arcs[0];
      while (i < arcs.length && arc) {
          const { p2 } = arc;
          result.push(arc);
          arc = arcs.find(a => PointService.distancePP(a.p1, p2) < SMALL);
          i++;
      }
      return result;
  };
  const getPathFromArcs = (arcs) => {
      if (!(arcs === null || arcs === void 0 ? void 0 : arcs.length)) {
          return '';
      }
      let i = 0;
      let arc = arcs[0];
      const { p1 } = arc;
      let path = `M${p1.x},${p1.y}`;
      while (arc) {
          const { p2, radius, largeArcFlag } = arc;
          path += `A${radius},${radius} 0 ${largeArcFlag ? 1 : 0},0 ${p2.x},${p2.y}`;
          arc = arcs[++i];
      }
      path += ' Z';
      return path;
  };
  const getArcsFromPath = (path) => {
      const arcs = [];
      const segments = path.split('A');
      const m = segments[0];
      let i = m.indexOf(',');
      arcs.push({
          p1: { x: +m.slice(1, i), y: +m.slice(i + 1) }
      });
      for (i = 1; i < segments.length; i++) {
          const s = segments[i].split(',');
          arcs[i - 1].radius = +s[0];
          const p2x = +s[2].slice(2);
          const p2y = +s[3].split(' ')[0];
          arcs[i - 1].p2 = { x: p2x, y: p2y };
          arcs[i - 1].largeArcFlag = s[1][s[1].length - 1] === '1';
          if (i < segments.length - 1) {
              arcs.push({
                  p1: { x: p2x, y: p2y }
              });
          }
      }
      return arcs;
  };
  const getCirclesFromArcs = (arcs) => {
      var _a;
      return ((_a = arcs === null || arcs === void 0 ? void 0 : arcs.map(arc => {
          const { p1, p2, radius, largeArcFlag, setId } = arc;
          const { x: x1, y: y1 } = p1;
          const { x: x2, y: y2 } = p2;
          const d = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5;
          const mX = (x1 + x2) / 2;
          const mY = (y1 + y2) / 2;
          const h = (radius ** 2 - (d / 2) ** 2) ** 0.5;
          let x = mX + (h * (y2 - y1)) / d;
          let y = mY - (h * (x2 - x1)) / d;
          if (crossProduct([x2 - x1, y2 - y1], [x - x1, y - y1]) > 0 || largeArcFlag) {
              x = mX - (h * (y2 - y1)) / d;
              y = mY + (h * (x2 - x1)) / d;
          }
          return { x, y, radius, setId };
      })) !== null && _a !== void 0 ? _a : []);
  };

  const transform$3 = (options, upstreamData) => {
      const { x0, x1, y0, y1, setField = 'sets', valueField = 'size', orientation = Math.PI / 2, orientationOrder = null, emptySetKey } = options;
      let circles = {};
      let textCenters = {};
      const hasEmptySet = upstreamData.some(area => {
          const sets = array(area[setField]);
          return !sets || sets.length === 0;
      });
      const nonEmptyData = hasEmptySet ? upstreamData.filter(area => !isEmpty(array(area[setField]))) : upstreamData;
      if (nonEmptyData.length > 0) {
          const vennData = nonEmptyData.map(area => ({
              sets: array(area[setField]),
              size: area[valueField]
          }));
          let solution = venn(vennData, options);
          solution = normalizeSolution(solution, orientation, orientationOrder);
          circles = scaleSolution(solution, x1 - x0, y1 - y0, x0, y0, hasEmptySet);
          textCenters = computeTextCenters(circles, vennData);
      }
      const data = upstreamData.map(area => {
          const sets = array(area[setField]);
          if (!sets || sets.length === 0) {
              return Object.assign(Object.assign({}, area), { datum: area, sets, key: emptySetKey || 'others', size: area[valueField], labelX: undefined, labelY: undefined, type: 'circle', x: x0 + (x1 - x0) / 2, y: y0 + (y1 - y0) / 2, radius: Math.min(x1 - x0, y1 - y0) / 2 });
          }
          const key = sets.toString();
          const textCenter = textCenters[key];
          const basicDatum = Object.assign(Object.assign({}, area), { datum: area, sets,
              key, size: area[valueField], labelX: textCenter === null || textCenter === void 0 ? void 0 : textCenter.x, labelY: textCenter === null || textCenter === void 0 ? void 0 : textCenter.y });
          const circle = circles[key];
          if (circle) {
              return Object.assign(Object.assign({}, basicDatum), { type: 'circle', x: circle.x, y: circle.y, radius: circle.radius });
          }
          const arcs = getArcsFromCircles(sets.map(name => circles[name]));
          return Object.assign(Object.assign({}, basicDatum), { type: 'overlap', x: 0, y: 0, path: getPathFromArcs(arcs), arcs });
      });
      return data;
  };
  const transformMark = (options, upstreamData) => {
      return upstreamData.filter(datum => datum.type === options.datumType);
  };

  const vennTransform = transform$3;
  const vennMarkTransform = transformMark;

  const shapes = {
      triangleForward: triangleForward,
      triangleUpright: triangle,
      triangle,
      diamond,
      square: square$1,
      star,
      cardioid,
      circle,
      pentagon
  };
  function diamond() {
      return function (theta) {
          const thetaPrime = theta % ((2 * Math.PI) / 4);
          return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));
      };
  }
  function star() {
      return function (theta) {
          const thetaPrime = (theta + 0.955) % ((2 * Math.PI) / 10);
          if (((theta + 0.955) % ((2 * Math.PI) / 5)) - (2 * Math.PI) / 10 >= 0) {
              return 1 / (Math.cos((2 * Math.PI) / 10 - thetaPrime) + 3.07768 * Math.sin((2 * Math.PI) / 10 - thetaPrime));
          }
          return 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));
      };
  }
  function square$1() {
      return function (theta) {
          return Math.min(1 / Math.abs(Math.cos(theta)), 1 / Math.abs(Math.sin(theta)));
      };
  }
  function triangle() {
      return function (theta) {
          const thetaPrime = (theta + (Math.PI * 3) / 2) % ((2 * Math.PI) / 3);
          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));
      };
  }
  function triangleForward() {
      return function (theta) {
          const thetaPrime = theta % ((2 * Math.PI) / 3);
          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));
      };
  }
  function cardioid() {
      return function (theta) {
          return 1 + Math.sin(theta);
      };
  }
  function circle() {
      return function () {
          return 1;
      };
  }
  function pentagon() {
      return function (theta) {
          const thetaPrime = (theta + 0.955) % ((2 * Math.PI) / 5);
          return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));
      };
  }
  function getMaxRadiusAndCenter(shape, size) {
      const w = size[0];
      const h = size[1];
      let maxRadius = 1;
      const center = [size[0] >> 1, size[1] >> 1];
      switch (shape) {
          case 'cardioid':
              center[1] = ~~((h / 2.7) * 0.4);
              maxRadius = Math.floor(Math.min(w / 2.3, h / 2.6));
              break;
          case 'triangleForward':
              maxRadius = h / Math.sqrt(0.75) > w ? Math.floor(w / 2) : Math.floor(h / (2 * Math.sqrt(0.75)));
              break;
          case 'triangle':
          case 'triangleUpright':
              center[1] = ~~(h / 1.5);
              maxRadius = Math.floor(Math.min(h / 1.5, w / 2));
              break;
          case 'circle':
          case 'diamond':
          case 'square':
          case 'star':
          case 'pentagon':
              maxRadius = Math.floor(Math.min(w / 2, h / 2));
              break;
          case 'rect':
          default:
              maxRadius = Math.floor(Math.max(w / 2, h / 2));
              break;
      }
      return { maxRadius, center };
  }
  const getShapeFunction = (type) => {
      if (shapes[type]) {
          return shapes[type]();
      }
      return shapes.circle();
  };

  const randomHslColor = (min, max) => {
      return ('hsl(' +
          (Math.random() * 360).toFixed() +
          ',' +
          (Math.random() * 30 + 70).toFixed() +
          '%,' +
          (Math.random() * (max - min) + min).toFixed() +
          '%)');
  };
  function functor$1(d) {
      return isFunction$1(d)
          ? d
          : function () {
              return d;
          };
  }

  class BaseLayout {
      constructor(options) {
          var _a, _b;
          this.options = merge({}, BaseLayout.defaultOptions, options);
          if (isFunction$1(this.options.shape)) {
              this.shape = this.options.shape;
          }
          else {
              this.shape = getShapeFunction(this.options.shape);
          }
          this.getText = (_a = functor$1(this.options.text)) !== null && _a !== void 0 ? _a : ((d) => d);
          this.getTextFontWeight = functor$1(this.options.fontWeight);
          this.getTextFontSize = functor$1(this.options.fontSize);
          this.getTextFontStyle = functor$1(this.options.fontStyle);
          this.getTextFontFamily = functor$1(this.options.fontFamily);
          this.outputCallback = (_b = this.options.outputCallback) !== null && _b !== void 0 ? _b : ((res) => res);
          switch (this.options.color) {
              case 'random-dark':
                  this.getTextColor = () => {
                      return randomHslColor(10, 50);
                  };
                  break;
              case 'random-light':
                  this.getTextColor = () => {
                      return randomHslColor(50, 90);
                  };
                  break;
              default:
                  this.getTextColor = functor$1(this.options.color);
                  break;
          }
          if (!isNil$1(this.options.rotate)) {
              this.getTextRotate = isFunction$1(this.options.rotate)
                  ? (d) => { var _a; return degreeToRadian((_a = this.options.rotate(d)) !== null && _a !== void 0 ? _a : 0); }
                  : (d, i) => {
                      const rotates = array(this.options.rotate);
                      const random = this.options.random ? Math.random() : seedRandom(i);
                      return degreeToRadian(rotates[Math.floor(random * rotates.length)]);
                  };
          }
          else if (this.options.useRandomRotate) {
              const rotationRange = Math.abs(this.options.maxRotation - this.options.minRotation);
              const rotationSteps = Math.abs(Math.floor(this.options.rotationSteps));
              const minRotation = Math.min(this.options.maxRotation, this.options.minRotation);
              this.getTextRotate = () => {
                  if (this.options.rotateRatio === 0) {
                      return 0;
                  }
                  if (Math.random() > this.options.rotateRatio) {
                      return 0;
                  }
                  if (rotationRange === 0) {
                      return minRotation;
                  }
                  if (rotationSteps > 0) {
                      return minRotation + (Math.floor(Math.random() * rotationSteps) * rotationRange) / (rotationSteps - 1);
                  }
                  return minRotation + Math.random() * rotationRange;
              };
          }
          else {
              this.getTextRotate = () => 0;
          }
      }
      canRepeat() {
          return false;
      }
      exceedTime() {
          var _a;
          if (this.options.progressiveStep > 0) {
              return this.progressiveIndex >= (((_a = this.currentStepIndex) !== null && _a !== void 0 ? _a : -1) + 1) * this.options.progressiveStep;
          }
          return this.options.progressiveTime > 0 && new Date().getTime() - this.escapeTime > this.options.progressiveTime;
      }
      progressiveRun() {
          var _a;
          if (this.options.progressiveStep > 0) {
              this.currentStepIndex = ((_a = this.currentStepIndex) !== null && _a !== void 0 ? _a : -1) + 1;
          }
          else if (this.options.progressiveTime > 0) {
              this.escapeTime = Date.now();
          }
          if (this.data && this.progressiveIndex < this.data.length) {
              this.progressiveResult = [];
              let i = this.progressiveIndex;
              let curWordTryCount = 0;
              const maxSingleWordTryCount = this.options.maxSingleWordTryCount;
              const maxFailCount = Math.min(this.options.maxFailCount, this.originalData.length);
              while (i < this.data.length && this.failCount < maxFailCount) {
                  const drawn = this.layoutWord(i);
                  curWordTryCount++;
                  if (drawn || curWordTryCount > maxSingleWordTryCount) {
                      i++;
                      curWordTryCount = 0;
                      this.failCount = drawn ? 0 : this.failCount + 1;
                  }
                  this.progressiveIndex = i;
                  if (this.exceedTime()) {
                      break;
                  }
                  else if (i === this.data.length &&
                      this.failCount < maxFailCount &&
                      this.options.repeatFill &&
                      this.canRepeat()) {
                      this.data = [
                          ...this.data,
                          ...this.originalData.map(entry => {
                              return Object.assign(Object.assign({}, entry), { isFill: true });
                          })
                      ];
                      this.isTryRepeatFill = true;
                  }
              }
              return this.progressiveResult;
          }
          return this.result;
      }
      initProgressive() {
          this.failCount = 0;
          this.progressiveIndex = 0;
          if (this.options.progressiveStep > 0) {
              this.currentStepIndex = -1;
          }
          else if (this.options.progressiveTime > 0) {
              this.escapeTime = Date.now();
          }
          this.progressiveResult = [];
      }
      output() {
          return this.result ? this.outputCallback(this.result) : null;
      }
      progressiveOutput() {
          return this.progressiveResult ? this.outputCallback(this.progressiveResult) : null;
      }
      unfinished() {
          return this.data && this.data.length && !isNil$1(this.progressiveIndex) && this.progressiveIndex < this.data.length;
      }
      release() {
          this.data = null;
          this.result = null;
          this.progressiveIndex = null;
          this.progressiveResult = null;
      }
  }
  BaseLayout.defaultOptions = {
      fontFamily: '"Trebuchet MS", "Heiti TC", "微軟正黑體", ' + '"Arial Unicode MS", "Droid Fallback Sans", sans-serif',
      fontWeight: 'normal',
      color: 'random-dark',
      fontStyle: 'normal',
      minFontSize: 12,
      drawOutOfBound: false,
      shrink: false,
      minRotation: -Math.PI / 2,
      maxRotation: Math.PI / 2,
      rotationSteps: 0,
      rotateRatio: 0.1,
      random: false,
      shape: 'circle',
      progressiveTime: 0,
      progressiveStep: 0,
      repeatFill: false,
      fillTextFontSize: 12,
      maxFailCount: 20
  };

  const spirals = {
      archimedean: archimedeanSpiral$1,
      rectangular: rectangularSpiral
  };
  function archimedeanSpiral$1(size) {
      const e = size[0] / size[1];
      return (t) => {
          return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
      };
  }
  function rectangularSpiral(size) {
      const dy = 4;
      const dx = (dy * size[0]) / size[1];
      let x = 0;
      let y = 0;
      return (t) => {
          const sign = t < 0 ? -1 : 1;
          switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {
              case 0:
                  x += dx;
                  break;
              case 1:
                  y += dy;
                  break;
              case 2:
                  x -= dx;
                  break;
              default:
                  y -= dy;
                  break;
          }
          return [x, y];
      };
  }

  const MAX_ARGUMENTS_LENGTH = 60000;
  class CloudLayout extends BaseLayout {
      constructor(options) {
          var _a;
          super(merge({}, CloudLayout.defaultOptions, options));
          this.cw = (1 << 11) >> 5;
          this.ch = 1 << 11;
          this._size = [256, 256];
          this._isBoardExpandCompleted = false;
          this._placeStatus = 0;
          this._tTemp = null;
          this._dtTemp = null;
          this._dy = 0;
          this.cacheMap = new Map();
          if (this.options.minFontSize <= CloudLayout.defaultOptions.minFontSize) {
              this.options.minFontSize = CloudLayout.defaultOptions.minFontSize;
          }
          this.spiral = isString$1(this.options.spiral)
              ? (_a = spirals[this.options.spiral]) !== null && _a !== void 0 ? _a : spirals.archimedean
              : this.options.spiral;
          this.random = this.options.random ? Math.random : () => 1;
          this.getTextPadding = functor$1(this.options.padding);
      }
      zoomRatio() {
          return this._originSize[0] / this._size[0];
      }
      dy() {
          return this._dy;
      }
      layoutWord(index) {
          const d = this.data[index];
          if (('' + d.text).trim() === '') {
              return true;
          }
          const { maxRadius, center } = getMaxRadiusAndCenter(this.options.shape, this._size);
          d.x = center[0];
          d.y = center[1];
          cloudSprite(this.contextAndRatio, d, this.data, index, this.cw, this.ch);
          this._placeStatus = 0;
          if (d.hasText && this.place(this._board, d, this._bounds, maxRadius)) {
              this.result.push(d);
              if (this._bounds) {
                  cloudBounds(this._bounds, d);
              }
              else {
                  this._bounds = [
                      { x: d.x + d.x0, y: d.y + d.y0 },
                      { x: d.x + d.x1, y: d.y + d.y1 }
                  ];
              }
              d.x -= this._size[0] >> 1;
              d.y -= this._size[1] >> 1;
              this._tTemp = null;
              this._dtTemp = null;
              return true;
          }
          this.updateBoardExpandStatus(d.fontSize);
          if (d.hasText && this.shouldShrinkContinue()) {
              if (this._placeStatus === 1) {
                  const maxSize0 = (d.fontSize * this._originSize[0]) / this.options.minFontSize;
                  const distSize0 = Math.max(d.width, d.height);
                  if (distSize0 <= maxSize0) {
                      this.expandBoard(this._board, this._bounds, distSize0 / this._size[0]);
                  }
                  else if (this.options.clip) {
                      this.expandBoard(this._board, this._bounds, maxSize0 / this._size[0]);
                  }
                  else {
                      return true;
                  }
              }
              else if (this._placeStatus === 3) {
                  this.expandBoard(this._board, this._bounds);
              }
              else {
                  this.expandBoard(this._board, this._bounds);
              }
              this.updateBoardExpandStatus(d.fontSize);
              return false;
          }
          this._tTemp = null;
          this._dtTemp = null;
          return true;
      }
      layout(words, config) {
          this.initProgressive();
          this.result = [];
          this._size = [config.width, config.height];
          this.clearCache();
          this._originSize = [...this._size];
          const contextAndRatio = this.getContext(this.options.createCanvas({ width: 1, height: 1 }));
          this.contextAndRatio = contextAndRatio;
          this._board = new Array((this._size[0] >> 5) * this._size[1]).fill(0);
          this._bounds = null;
          words.length;
          this.result = [];
          const data = words
              .map((d, i) => {
              return {
                  text: this.getText(d),
                  fontFamily: this.getTextFontFamily(d),
                  fontStyle: this.getTextFontStyle(d),
                  fontWeight: this.getTextFontWeight(d),
                  angle: this.getTextRotate(d, i),
                  fontSize: ~~this.getTextFontSize(d),
                  padding: this.getTextPadding(d),
                  xoff: 0,
                  yoff: 0,
                  x1: 0,
                  y1: 0,
                  x0: 0,
                  y0: 0,
                  hasText: false,
                  sprite: null,
                  datum: d,
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
              };
          })
              .sort(function (a, b) {
              return b.fontSize - a.fontSize;
          });
          this.originalData = data;
          this.data = data;
          this.progressiveRun();
          if (!this.options.clip && this.options.enlarge && this._bounds) {
              this.shrinkBoard(this._bounds);
          }
          if (this._bounds && ['cardioid', 'triangle', 'triangle-upright'].includes(this.options.shape)) {
              const currentCenterY = (this._bounds[0].y + this._bounds[1].y) / 2;
              this._dy = -(currentCenterY - this._originSize[1] / 2);
          }
          return this.result;
      }
      formatTagItem(words) {
          const size = this._size;
          const zoomRatio = this.zoomRatio();
          const globalDy = this.dy();
          const dx = size[0] >> 1;
          const dy = size[1] >> 1;
          const n = words.length;
          const result = [];
          let w;
          let t;
          for (let i = 0; i < n; ++i) {
              w = words[i];
              t = {};
              t.datum = w.datum;
              t.x = (w.x + dx) * zoomRatio;
              t.y = (w.y + dy + globalDy) * zoomRatio;
              t.fontFamily = w.fontFamily;
              t.fontSize = w.fontSize * zoomRatio;
              t.fontStyle = w.fontStyle;
              t.fontWeight = w.fontWeight;
              t.angle = w.angle;
              result.push(t);
          }
          return result;
      }
      output() {
          return this.outputCallback ? this.outputCallback(this.formatTagItem(this.result)) : this.formatTagItem(this.result);
      }
      progressiveOutput() {
          return this.outputCallback
              ? this.outputCallback(this.formatTagItem(this.progressiveResult))
              : this.formatTagItem(this.progressiveResult);
      }
      updateBoardExpandStatus(fontSize) {
          this._isBoardExpandCompleted = fontSize * (this._originSize[0] / this._size[0]) < this.options.minFontSize;
      }
      shouldShrinkContinue() {
          return !this.options.clip && this.options.shrink && !this._isBoardExpandCompleted;
      }
      shrinkBoard(bounds) {
          const leftTopPoint = bounds[0];
          const rightBottomPoint = bounds[1];
          if (rightBottomPoint.x >= this._size[0] || rightBottomPoint.y >= this._size[1]) {
              return;
          }
          const minXValue = Math.min(leftTopPoint.x, this._size[0] - rightBottomPoint.x);
          const minYValue = Math.min(leftTopPoint.y, this._size[1] - rightBottomPoint.y);
          const minRatio = Math.min(minXValue / this._size[0], minYValue / this._size[1]) * 2;
          this._size = this._size.map(v => v * (1 - minRatio));
      }
      expandBoard(board, bounds, factor) {
          const expandedLeftWidth = (this._size[0] * (factor || 1.1) - this._size[0]) >> 5;
          let diffWidth = expandedLeftWidth * 2 > 2 ? expandedLeftWidth : 2;
          if (diffWidth % 2 !== 0) {
              diffWidth++;
          }
          let diffHeight = Math.ceil((this._size[1] * (diffWidth << 5)) / this._size[0]);
          if (diffHeight % 2 !== 0) {
              diffHeight++;
          }
          const w = this._size[0];
          const h = this._size[1];
          const widthArr = new Array(diffWidth).fill(0);
          const heightArr = new Array((diffHeight / 2) * (diffWidth + (w >> 5))).fill(0);
          this.insertZerosToArray(board, h * (w >> 5), heightArr.length + diffWidth / 2);
          for (let i = h - 1; i > 0; i--) {
              this.insertZerosToArray(board, i * (w >> 5), widthArr.length);
          }
          this.insertZerosToArray(board, 0, heightArr.length + diffWidth / 2);
          this._size = [w + (diffWidth << 5), h + diffHeight];
          if (bounds) {
              bounds[0].x += (diffWidth << 5) / 2;
              bounds[0].y += diffHeight / 2;
              bounds[1].x += (diffWidth << 5) / 2;
              bounds[1].y += diffHeight / 2;
          }
      }
      insertZerosToArray(array, index, length) {
          if (this.options.customInsertZerosToArray) {
              return this.options.customInsertZerosToArray(array, index, length);
          }
          const len = Math.floor(length / MAX_ARGUMENTS_LENGTH);
          const restLen = length % MAX_ARGUMENTS_LENGTH;
          for (let i = 0; i < len; i++) {
              array.splice(index + i * MAX_ARGUMENTS_LENGTH, 0, ...new Array(MAX_ARGUMENTS_LENGTH).fill(0));
          }
          array.splice(index + len * MAX_ARGUMENTS_LENGTH, 0, ...new Array(restLen).fill(0));
      }
      getContext(canvas) {
          canvas.width = 1;
          canvas.height = 1;
          const tempContext = canvas.getContext('2d', { willReadFrequently: true });
          const imageData = tempContext.getImageData(0, 0, 1, 1);
          const ratio = Math.sqrt(imageData.data.length >> 2);
          canvas.width = (this.cw << 5) / ratio;
          canvas.height = this.ch / ratio;
          const context = canvas.getContext('2d', { willReadFrequently: true });
          context.fillStyle = context.strokeStyle = 'red';
          context.textAlign = 'center';
          return { context: context, ratio: ratio, canvas };
      }
      place(board, tag, bounds, maxRadius) {
          let isCollide = false;
          if (this.shouldShrinkContinue() && (tag.width > this._size[0] || tag.height > this._size[1])) {
              this._placeStatus = 1;
              return false;
          }
          const dt = this.random() < 0.5 ? 1 : -1;
          if (!this.shouldShrinkContinue() && this.isSizeLargerThanMax(tag, dt)) {
              return null;
          }
          const startX = tag.x;
          const startY = tag.y;
          const maxDelta = Math.sqrt(this._size[0] * this._size[0] + this._size[1] * this._size[1]);
          const s = this.spiral(this._size);
          let t = -dt;
          let dxdy;
          let dx;
          let dy;
          let _tag;
          this._tTemp = null;
          this._dtTemp = null;
          while ((dxdy = s((t += dt)))) {
              dx = dxdy[0];
              dy = dxdy[1];
              const radius = Math.sqrt(dx ** 2 + dy ** 2);
              let rad = Math.atan(dy / dx);
              if (dx < 0) {
                  rad += Math.PI;
              }
              else if (dy < 0) {
                  rad = 2 * Math.PI + rad;
              }
              const rx = this.shape(rad);
              if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) {
                  break;
              }
              if (radius >= maxRadius) {
                  if (isCollide && this._tTemp === null) {
                      this._tTemp = t;
                      this._dtTemp = dt;
                  }
                  continue;
              }
              tag.x = startX + ~~(radius * rx * Math.cos(-rad));
              tag.y = startY + ~~(radius * rx * Math.sin(-rad));
              _tag = tag;
              if (this.options.clip) {
                  if (!this.shouldShrinkContinue()) {
                      if (isFullOutside(_tag, this._size)) {
                          if (isCollide && this._tTemp === null) {
                              this._tTemp = t;
                              this._dtTemp = dt;
                          }
                          continue;
                      }
                      else if (isPartOutside(_tag, this._size)) {
                          _tag = clipInnerTag(_tag, this._size);
                      }
                  }
                  else {
                      if (isPartOutside(_tag, this._size)) {
                          if (isCollide && this._tTemp === null) {
                              this._tTemp = t;
                              this._dtTemp = dt;
                          }
                          continue;
                      }
                  }
              }
              else if (isPartOutside(_tag, this._size)) {
                  if (isCollide && this._tTemp === null) {
                      this._tTemp = t;
                      this._dtTemp = dt;
                  }
                  continue;
              }
              isCollide = true;
              if (!bounds || collideRects(_tag, bounds)) {
                  if (!bounds || !cloudCollide(_tag, board, this._size)) {
                      const sprite = _tag.sprite;
                      const w = _tag.width >> 5;
                      const sw = this._size[0] >> 5;
                      const lx = _tag.x - (w << 4);
                      const sx = lx & 0x7f;
                      const msx = 32 - sx;
                      const h = _tag.y1 - _tag.y0;
                      let x = (_tag.y + _tag.y0) * sw + (lx >> 5);
                      let last;
                      for (let j = 0; j < h; j++) {
                          last = 0;
                          for (let i = 0; i <= w; i++) {
                              board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
                          }
                          x += sw;
                      }
                      tag.sprite = null;
                      _tag.sprite = null;
                      return true;
                  }
              }
          }
          if (this._tTemp !== null) {
              this._placeStatus = 3;
          }
          !this.shouldShrinkContinue() && this.setCache(_tag, dt);
          return false;
      }
      clearCache() {
          this.cacheMap.clear();
      }
      setCache(tag, dt) {
          const cacheKey = `${tag.angle}-${dt}`;
          const w = tag.x1 - tag.x0;
          const h = tag.y1 - tag.y0;
          if (!this.cacheMap.has(cacheKey)) {
              this.cacheMap.set(cacheKey, {
                  width: w,
                  height: h
              });
              return;
          }
          const { width, height } = this.cacheMap.get(cacheKey);
          if ((w < width && h < height) || (w <= width && h < height)) {
              this.cacheMap.set(cacheKey, {
                  width: w,
                  height: h
              });
          }
      }
      isSizeLargerThanMax(tag, dt) {
          const cacheKey = `${tag.angle}-${dt}`;
          if (!this.cacheMap.has(cacheKey)) {
              return false;
          }
          const { width, height } = this.cacheMap.get(cacheKey);
          const w = tag.x1 - tag.x0;
          const h = tag.y1 - tag.y0;
          return w >= width && h >= height;
      }
  }
  CloudLayout.defaultOptions = {
      enlarge: false,
      minFontSize: 2,
      maxSingleWordTryCount: 2
  };
  function cloudSprite(contextAndRatio, d, data, di, cw, ch) {
      if (d.sprite) {
          return;
      }
      const c = contextAndRatio.context;
      const ratio = contextAndRatio.ratio;
      c.setTransform(ratio, 0, 0, ratio, 0, 0);
      c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
      let x = 0;
      let y = 0;
      let maxh = 0;
      const n = data.length;
      let w;
      let w32;
      let h;
      let i;
      let j;
      --di;
      while (++di < n) {
          d = data[di];
          c.save();
          c.font = d.fontStyle + ' ' + d.fontWeight + ' ' + ~~((d.fontSize + 1) / ratio) + 'px ' + d.fontFamily;
          w = c.measureText(d.text + 'm').width * ratio;
          h = d.fontSize << 1;
          if (d.angle) {
              const sr = Math.sin(d.angle);
              const cr = Math.cos(d.angle);
              const wcr = w * cr;
              const wsr = w * sr;
              const hcr = h * cr;
              const hsr = h * sr;
              w = ((Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31) >> 5) << 5;
              h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
          }
          else {
              w = ((w + 31) >> 5) << 5;
          }
          if (h > maxh) {
              maxh = h;
          }
          if (x + w >= cw << 5) {
              x = 0;
              y += maxh;
              maxh = 0;
          }
          if (y + h >= ch) {
              break;
          }
          c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
          if (d.angle) {
              c.rotate(d.angle);
          }
          c.fillText(d.text, 0, 0);
          if (d.padding) {
              c.lineWidth = 2 * d.padding;
              c.strokeText(d.text, 0, 0);
          }
          c.restore();
          d.width = w;
          d.height = h;
          d.xoff = x;
          d.yoff = y;
          d.x1 = w >> 1;
          d.y1 = h >> 1;
          d.x0 = -d.x1;
          d.y0 = -d.y1;
          d.hasText = true;
          x += w;
      }
      const pixelsImageData = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio);
      const pixels = pixelsImageData.data;
      const sprite = [];
      while (--di >= 0) {
          d = data[di];
          if (!d.hasText) {
              continue;
          }
          w = d.width;
          w32 = w >> 5;
          h = d.y1 - d.y0;
          for (i = 0; i < h * w32; i++) {
              sprite[i] = 0;
          }
          x = d.xoff;
          if (x == null) {
              return;
          }
          y = d.yoff;
          let seen = 0;
          let seenRow = -1;
          for (j = 0; j < h; j++) {
              for (i = 0; i < w; i++) {
                  const k = w32 * j + (i >> 5);
                  const m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;
                  sprite[k] |= m;
                  seen |= m;
              }
              if (seen) {
                  seenRow = j;
              }
              else {
                  d.y0++;
                  h--;
                  j--;
                  y++;
              }
          }
          d.y1 = d.y0 + seenRow;
          d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
      }
  }
  function cloudCollide(tag, board, size) {
      const sw = size[0] >> 5;
      const sprite = tag.sprite;
      const w = tag.width >> 5;
      const lx = tag.x - (w << 4);
      const sx = lx & 0x7f;
      const msx = 32 - sx;
      const h = tag.y1 - tag.y0;
      let x = (tag.y + tag.y0) * sw + (lx >> 5);
      let last;
      for (let j = 0; j < h; j++) {
          last = 0;
          for (let i = 0; i <= w; i++) {
              if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) {
                  return true;
              }
          }
          x += sw;
      }
      return false;
  }
  function cloudBounds(bounds, d) {
      const b0 = bounds[0];
      const b1 = bounds[1];
      if (d.x + d.x0 < b0.x) {
          b0.x = d.x + d.x0;
      }
      if (d.y + d.y0 < b0.y) {
          b0.y = d.y + d.y0;
      }
      if (d.x + d.x1 > b1.x) {
          b1.x = d.x + d.x1;
      }
      if (d.y + d.y1 > b1.y) {
          b1.y = d.y + d.y1;
      }
  }
  function collideRects(a, b) {
      return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
  }
  const isFullOutside = (tag, size) => {
      return tag.x + tag.x0 > size[0] || tag.y + tag.y0 > size[0] || tag.x + tag.x1 < 0 || tag.y + tag.y1 < 0;
  };
  const isPartOutside = (tag, size) => {
      return tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1];
  };
  function clipInnerTag(tag, size) {
      const sprite = tag.sprite;
      const h = tag.y1 - tag.y0;
      const w = tag.width >> 5;
      let x = 0;
      const _sprite = [];
      const js = Math.max(-(tag.y0 + tag.y), 0);
      const je = Math.min(h + (size[1] - (tag.y1 + tag.y)), h);
      const is = Math.max(-(tag.x0 + tag.x), 0) >> 5;
      const ie = Math.min(w + ((size[0] - (tag.x1 + tag.x)) >> 5) + 1, w);
      for (let j = 0; j < h; j++) {
          for (let i = 0; i < w; i++) {
              if (j < js || je <= j || i < is || ie <= i) ;
              else {
                  _sprite.push(sprite[x + i]);
              }
          }
          x += w;
      }
      const xl = is << 5;
      const xr = (w - ie) << 5;
      const yb = js;
      const yt = h - je;
      return Object.assign(Object.assign({}, tag), { width: tag.width - xl - xr, height: tag.height - yb - yt, x0: tag.x0 + xl, x1: tag.x1 - xr, y0: tag.y0 + yb, y1: tag.y1 - yt, x: tag.x + xl / 2 - xr / 2, sprite: _sprite });
  }

  const generateIsEmptyPixel = (backgroundColor, options, createCanvas) => {
      const { threshold, invert = false } = options !== null && options !== void 0 ? options : {};
      if (!backgroundColor || backgroundColor === '#fff') {
          return (imageData, y, x) => {
              const width = imageData.width;
              if (imageData.data[y * width * 4 + x * 4 + 3] === 0) {
                  return !invert;
              }
              const r = imageData.data[y * width * 4 + x * 4 + 0];
              const g = imageData.data[y * width * 4 + x * 4 + 1];
              const b = imageData.data[y * width * 4 + x * 4 + 2];
              if (r === 255 && g === 255 && b === 255) {
                  return !invert;
              }
              if (isValidNumber$1(threshold)) {
                  const grayValue = 0.3 * r + 0.59 * g + 0.11 * b;
                  return invert ? grayValue <= threshold : grayValue >= threshold;
              }
              return false;
          };
      }
      const bctx = createCanvas({ width: 1, height: 1 }).getContext('2d', { willReadFrequently: true });
      bctx.fillStyle = backgroundColor;
      bctx.fillRect(0, 0, 1, 1);
      const bgPixel = bctx.getImageData(0, 0, 1, 1).data;
      return (imageData, y, x) => {
          const width = imageData.width;
          return [0, 1, 2, 3].every(i => {
              return invert
                  ? imageData.data[(y * width + x) * 4 + i] !== bgPixel[i]
                  : imageData.data[(y * width + x) * 4 + i] === bgPixel[i];
          });
      };
  };
  const generateMaskCanvas = (shape, width, height, cacheCanvas, invert = false, createCanvas) => {
      let { backgroundColor = '#fff' } = shape;
      let { fill: foregroundColor = '#000' } = shape;
      if (invert) {
          [backgroundColor, foregroundColor] = [foregroundColor, backgroundColor];
      }
      const maskCanvas = cacheCanvas ||
          createCanvas({
              width,
              height,
              dpr: 1
          });
      const tempContext = maskCanvas.getContext('2d', { willReadFrequently: true });
      if (cacheCanvas) {
          const prevWidth = cacheCanvas.width;
          const prevHeight = cacheCanvas.height;
          tempContext.clearRect(0, 0, prevWidth, prevHeight);
          cacheCanvas.style.width = `${width}px`;
          cacheCanvas.style.height = `${height}px`;
          cacheCanvas.width = width;
          cacheCanvas.height = height;
      }
      tempContext.fillStyle = backgroundColor;
      tempContext.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
      if (shape.type === 'text') {
          drawTextMask(shape, foregroundColor, maskCanvas.width, maskCanvas.height, tempContext);
      }
      else if (shape.type === 'geometric') {
          drawGeometricMask(shape, foregroundColor, maskCanvas.width, maskCanvas.height, tempContext);
      }
      return maskCanvas;
  };
  const drawTextMask = (shape, fillColor, width, height, ctx) => {
      const { fontFamily = 'sans-serif', fontWeight = 'normal', fontStyle = 'normal', fontVariant = 'normal', text, hollow } = shape;
      let baseFontSize = 12;
      ctx.font = `${fontStyle} ${fontVariant} ${fontWeight} ${baseFontSize}px ${fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = fillColor;
      const textMetrics = ctx.measureText(text);
      const scale = fontStyle !== 'normal' ? 1.1 : 1;
      const actualWidth = isValid$1(textMetrics.actualBoundingBoxRight) && isValid$1(textMetrics.actualBoundingBoxLeft)
          ? Math.ceil(scale * (Math.abs(textMetrics.actualBoundingBoxRight) + Math.abs(textMetrics.actualBoundingBoxLeft)))
          : 0;
      const textWidth = Math.max(Math.ceil(textMetrics.width), actualWidth, baseFontSize);
      if (hollow) {
          ctx.globalCompositeOperation = 'xor';
      }
      if (textWidth > width) {
          const scale = Math.min(width / textWidth, height / baseFontSize);
          ctx.fillText(text, width / 2, height / 2);
          ctx.scale(scale, scale);
      }
      else {
          baseFontSize = Math.floor((baseFontSize * width) / textWidth);
          baseFontSize = Math.min(baseFontSize, height);
          ctx.font = `${fontStyle} ${fontVariant} ${fontWeight} ${baseFontSize}px ${fontFamily}`;
          ctx.fillText(text, Math.floor(width / 2), Math.floor(height / 2));
      }
  };
  const generatePoints = (center, radius, startAngle = 0, count) => {
      const angle = (2 * Math.PI) / count;
      return new Array(count).fill(0).map((entry, index) => {
          return polarToCartesian(center, radius, startAngle + index * angle);
      });
  };
  const generateCardioidPoints = (center, radius, startAngle = 0, count) => {
      const angle = (2 * Math.PI) / count;
      const func = getShapeFunction('cardioid');
      return new Array(count).fill(0).map((entry, index) => {
          const theta = startAngle + index * angle;
          const r = radius * func(theta);
          const res = polarToCartesian(center, r, theta);
          return res;
      });
  };
  const drawRegularPolygon = (ctx, points) => {
      ctx.beginPath();
      points.forEach((p, index) => {
          if (index === 0) {
              ctx.moveTo(p.x, p.y);
          }
          else {
              ctx.lineTo(p.x, p.y);
          }
      });
      ctx.closePath();
      ctx.fill();
  };
  const drawCardioid = (ctx, points) => {
      ctx.beginPath();
      let prev;
      points.forEach((p, index) => {
          if (index === 0) {
              ctx.moveTo(p.x, p.y);
          }
          else {
              ctx.bezierCurveTo(p.x, p.y, prev.x, prev.y, p.x, p.y);
          }
          prev = p;
      });
      ctx.closePath();
      ctx.fill();
  };
  const drawGeometricMask = (shape, fillColor, width, height, ctx) => {
      const { hollow } = shape;
      const { center, maxRadius } = getMaxRadiusAndCenter(shape.shape, [width, height]);
      ctx.fillStyle = fillColor;
      if (hollow) {
          ctx.globalCompositeOperation = 'xor';
      }
      const cx = center[0];
      const cy = center[1];
      if (shape.shape === 'cardioid') {
          drawCardioid(ctx, generateCardioidPoints({ x: cx, y: cy }, maxRadius, 0, 100));
      }
      else if (shape.shape === 'circle') {
          ctx.beginPath();
          ctx.arc(cx, cy, maxRadius, 0, 2 * Math.PI, true);
          ctx.fill();
      }
      else if (shape.shape === 'diamond') {
          drawRegularPolygon(ctx, generatePoints({ x: cx, y: cy }, maxRadius, -Math.PI / 2, 4));
      }
      else if (shape.shape === 'square') {
          drawRegularPolygon(ctx, generatePoints({ x: cx, y: cy }, maxRadius, -Math.PI / 4, 4));
      }
      else if (shape.shape === 'pentagon') {
          drawRegularPolygon(ctx, generatePoints({ x: cx, y: cy }, maxRadius, Math.PI / 2, 5));
      }
      else if (shape.shape === 'triangle' || shape.shape === 'triangleUpright') {
          drawRegularPolygon(ctx, generatePoints({ x: cx, y: cy }, maxRadius, -Math.PI / 2, 3));
      }
      else if (shape.shape === 'triangleForward') {
          drawRegularPolygon(ctx, generatePoints({ x: cx, y: cy }, maxRadius, 0, 3));
      }
      else if (shape.shape === 'star') {
          const outterPoints = generatePoints({ x: cx, y: cy }, maxRadius, -Math.PI / 2, 5);
          const innerPoints = generatePoints({ x: cx, y: cy }, maxRadius / (2 * Math.cos(Math.PI / 5)), -Math.PI / 2 + Math.PI / 5, 5);
          const points = [];
          for (let i = 0; i < 5; i++) {
              points.push(outterPoints[i]);
              points.push(innerPoints[i]);
          }
          drawRegularPolygon(ctx, points);
      }
      else {
          ctx.fillRect(0, 0, width, height);
      }
  };
  function segmentation(segmentationInput) {
      const { size, maskCanvas } = segmentationInput;
      const ctx = maskCanvas.getContext('2d', { willReadFrequently: true });
      const imageData = ctx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
      const labels = new Array(size[0] * size[1]).fill(0);
      let curLabel = 1;
      const offset = [
          [0, 1],
          [1, 0],
          [-1, 0],
          [0, -1]
      ];
      let queue = [];
      for (let i = 0; i < size[1]; i++) {
          for (let j = 0; j < size[0]; j++) {
              if (labels[i * size[0] + j] !== 0 || segmentationInput.isEmptyPixel(imageData, i, j)) {
                  continue;
              }
              labels[i * size[0] + j] = curLabel;
              queue.push([i, j]);
              for (let k = 0; k < queue.length; k++) {
                  for (let m = 0; m < 4; m++) {
                      let row = queue[k][0] + offset[m][0];
                      let col = queue[k][1] + offset[m][1];
                      row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row;
                      col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col;
                      if (labels[row * size[0] + col] === 0 && !segmentationInput.isEmptyPixel(imageData, row, col)) {
                          labels[row * size[0] + col] = curLabel;
                          queue.push([row, col]);
                      }
                  }
              }
              curLabel++;
              queue = [];
          }
      }
      const boundaries = {};
      const areas = {};
      const centers = {};
      const maxPoints = {};
      const maxR = {};
      const ratios = {};
      const shapeBounds = {
          x1: Infinity,
          x2: -Infinity,
          y1: Infinity,
          y2: -Infinity,
          width: 0,
          height: 0
      };
      const boundaryPixels = [];
      for (let i = 0; i < size[1]; i++) {
          for (let j = 0; j < size[0]; j++) {
              const label = labels[i * size[0] + j];
              if (label === 0) {
                  continue;
              }
              if (isBoundaryPixel(i, j)) {
                  boundaryPixels.push([i, j]);
                  boundaries[label] = boundaries[label] || [];
                  boundaries[label].push([j, i]);
                  if (!maxPoints[label]) {
                      maxPoints[label] = [Infinity, -Infinity, Infinity, -Infinity];
                  }
                  if (i < maxPoints[label][0]) {
                      maxPoints[label][0] = i;
                  }
                  if (i > maxPoints[label][1]) {
                      maxPoints[label][1] = i;
                  }
                  if (j < maxPoints[label][2]) {
                      maxPoints[label][2] = j;
                  }
                  if (j > maxPoints[label][3]) {
                      maxPoints[label][3] = j;
                  }
                  if (j < shapeBounds.x1) {
                      shapeBounds.x1 = j;
                  }
                  if (j > shapeBounds.x2) {
                      shapeBounds.x2 = j;
                  }
                  if (i < shapeBounds.y1) {
                      shapeBounds.y1 = i;
                  }
                  if (i > shapeBounds.y2) {
                      shapeBounds.y2 = i;
                  }
              }
              areas[label] = (areas[label] || 0) + 1;
          }
      }
      const allBoundaries = [];
      for (const label in boundaries) {
          const boundary = boundaries[label];
          const x = ~~(boundary.reduce((acc, cur) => acc + cur[0], 0) / boundary.length);
          const y = ~~(boundary.reduce((acc, cur) => acc + cur[1], 0) / boundary.length);
          centers[label] = [x, y];
          allBoundaries.push(...boundary);
          const [yMin, yMax, xMin, xMax] = maxPoints[label];
          maxR[label] = ~~Math.max(Math.sqrt((x - xMin) ** 2 + (y - yMin) ** 2), Math.sqrt((x - xMax) ** 2 + (y - yMax) ** 2), Math.sqrt((x - xMin) ** 2 + (y - yMax) ** 2), Math.sqrt((x - xMax) ** 2 + (y - yMin) ** 2));
          ratios[label] = (xMax - xMin) / (yMax - yMin);
      }
      const regions = Object.keys(centers).map((key) => ({
          label: key - 1,
          boundary: boundaries[key],
          area: areas[key],
          center: centers[key],
          maxPoint: maxPoints[key],
          maxR: maxR[key],
          ratio: ratios[key]
      }));
      shapeBounds.width = shapeBounds.x2 - shapeBounds.x1 + 1;
      shapeBounds.height = shapeBounds.y2 - shapeBounds.y1 + 1;
      const x = ~~(allBoundaries.reduce((acc, cur) => acc + cur[0], 0) / allBoundaries.length);
      const y = ~~(allBoundaries.reduce((acc, cur) => acc + cur[1], 0) / allBoundaries.length);
      const shapeMaxR = ~~Math.max(Math.sqrt((x - shapeBounds.x1) ** 2 + (y - shapeBounds.y1) ** 2), Math.sqrt((x - shapeBounds.x2) ** 2 + (y - shapeBounds.y2) ** 2), Math.sqrt((x - shapeBounds.x1) ** 2 + (y - shapeBounds.y2) ** 2), Math.sqrt((x - shapeBounds.x2) ** 2 + (y - shapeBounds.y1) ** 2));
      const shapeRatio = shapeBounds.width / shapeBounds.height;
      const shapeArea = Object.keys(areas).reduce((acc, key) => (acc += areas[key]), 0);
      const segmentation = {
          regions,
          labels,
          labelNumber: curLabel - 1
      };
      if (segmentationInput.blur) {
          const blur = segmentationInput.blur;
          const blurredLabels = gaussianBlur(labels, size[0], size[1], blur);
          const edgeMask = drawContour(labels, boundaryPixels, size[0], size[1], Math.ceil(blur / 2));
          edgeMask.forEach((value, index) => {
              if (value === 1) {
                  labels[index] = blurredLabels[index];
              }
          });
      }
      return Object.assign(segmentationInput, {
          segmentation,
          shapeBounds,
          shapeMaxR,
          shapeRatio,
          shapeCenter: [x, y],
          shapeArea
      });
      function isBoundaryPixel(i, j) {
          const offset = [
              [0, 1],
              [1, 0],
              [-1, 0],
              [0, -1]
          ];
          if (i === 0 || j === 0 || i === size[1] - 1 || j === size[0] - 1) {
              return true;
          }
          for (let k = 0; k < 4; k++) {
              let row = i + offset[k][0];
              let col = j + offset[k][1];
              row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row;
              col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col;
              if (labels[row * size[0] + col] === 0) {
                  return true;
              }
          }
          return false;
      }
  }
  function generateGaussianKernel1D(size, sigma) {
      const kernel = new Array(size * 2 + 1).fill(0);
      const center = size;
      let sum = 0;
      for (let x = -size; x <= size; x++) {
          const g = Math.exp(-(x * x) / (2 * sigma * sigma));
          kernel[x + center] = g;
          sum += g;
      }
      for (let i = 0; i < kernel.length; i++) {
          kernel[i] /= sum;
      }
      return kernel;
  }
  function gaussianBlur(labels, width, height, blur) {
      const sigma = blur / 3;
      const size = Math.ceil(blur / 2);
      const kernel = generateGaussianKernel1D(size, sigma);
      const temp = new Array(labels.length).fill(0);
      const result = new Array(labels.length).fill(0);
      for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
              let sum = 0;
              for (let i = -size; i <= size; i++) {
                  const curX = Math.min(Math.max(x + i, 0), width - 1);
                  sum += labels[y * width + curX] * kernel[i + size];
              }
              temp[y * width + x] = sum;
          }
      }
      for (let x = 0; x < width; x++) {
          for (let y = 0; y < height; y++) {
              let sum = 0;
              for (let i = -size; i <= size; i++) {
                  const curY = Math.min(Math.max(y + i, 0), height - 1);
                  sum += temp[curY * width + x] * kernel[i + size];
              }
              result[y * width + x] = Math.max(0, Math.min(1, sum));
          }
      }
      return result;
  }
  function drawContour(labels, boundaryPixels, width, height, thickness = 1) {
      const result = new Array(labels.length).fill(0);
      for (const [i, j] of boundaryPixels) {
          result[i * width + j] = 1;
          if (thickness > 1) {
              for (let di = -thickness + 1; di <= thickness - 1; di++) {
                  for (let dj = -thickness + 1; dj <= thickness - 1; dj++) {
                      const distance = Math.sqrt(di * di + dj * dj);
                      if (distance < thickness) {
                          const ni = i + di;
                          const nj = j + dj;
                          if (ni >= 0 && ni < height && nj >= 0 && nj < width) {
                              result[ni * width + nj] = 1;
                          }
                      }
                  }
              }
          }
      }
      return result;
  }
  function removeBorder(image, canvas, isEmptyPixel) {
      canvas.width = image.width;
      canvas.height = image.height;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0);
      const width = canvas.width;
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let top = 0;
      let bottom = imageData.height;
      let left = 0;
      let right = imageData.width;
      const rowBlank = (width, y) => {
          for (let x = 0; x < width; ++x) {
              if (!isEmptyPixel(imageData, y, x)) {
                  return false;
              }
          }
          return true;
      };
      const columnBlank = (x, y0, y1) => {
          for (let y = y0; y < y1; ++y) {
              if (!isEmptyPixel(imageData, y, x)) {
                  return false;
              }
          }
          return true;
      };
      while (top < bottom && rowBlank(width, top)) {
          ++top;
      }
      while (bottom - 1 > top && rowBlank(width, bottom - 1)) {
          --bottom;
      }
      while (left < right && columnBlank(left, top, bottom)) {
          ++left;
      }
      while (right - 1 > left && columnBlank(right - 1, top, bottom)) {
          --right;
      }
      const trimmed = ctx.getImageData(left, top, right - left, bottom - top);
      canvas.width = trimmed.width;
      canvas.height = trimmed.height;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.putImageData(trimmed, 0, 0);
      return canvas;
  }
  function scaleAndMiddleShape(image, size) {
      const width = image.width;
      const height = image.height;
      let scale = size[0] / width;
      if (height * scale > size[1]) {
          scale = size[1] / height;
      }
      const newWidth = Math.floor(scale * width);
      const newHeight = Math.floor(scale * height);
      const x = (size[0] - newWidth) / 2;
      const y = (size[1] - newHeight) / 2;
      return {
          x,
          y,
          width: newWidth,
          height: newHeight,
          scale
      };
  }

  /*!
   * wordcloud2.js
   * http://timdream.org/wordcloud2.js/
   *
   * Copyright 2011 - 2019 Tim Guan-tin Chien and contributors.
   * Released under the MIT license
   */
  let GridLayout$1 = class GridLayout extends BaseLayout {
      constructor(options) {
          super(merge({}, GridLayout.defaultOptions, options));
          this.fillGridAt = (x, y) => {
              if (x >= this.ngx || y >= this.ngy || x < 0 || y < 0) {
                  return;
              }
              this.grid[x][y] = false;
          };
          this.updateGrid = (gx, gy, gw, gh, info) => {
              const occupied = info.occupied;
              let i = occupied.length;
              while (i--) {
                  const px = gx + occupied[i][0];
                  const py = gy + occupied[i][1];
                  if (px >= this.ngx || py >= this.ngy || px < 0 || py < 0) {
                      continue;
                  }
                  this.fillGridAt(px, py);
              }
          };
          this.gridSize = Math.max(Math.floor(this.options.gridSize), 4);
      }
      getPointsAtRadius(radius) {
          if (this.pointsAtRadius[radius]) {
              return this.pointsAtRadius[radius];
          }
          const T = radius * 8;
          let t = T;
          const points = [];
          if (radius === 0) {
              points.push([this.center[0], this.center[1], 0]);
          }
          while (t--) {
              const rx = this.shape((t / T) * 2 * Math.PI);
              points.push([
                  this.center[0] + radius * rx * Math.cos((-t / T) * 2 * Math.PI),
                  this.center[1] + radius * rx * Math.sin((-t / T) * 2 * Math.PI) * this.options.ellipticity,
                  (t / T) * 2 * Math.PI
              ]);
          }
          this.pointsAtRadius[radius] = points;
          return points;
      }
      getTextInfo(item, shrinkRatio = 1, index) {
          var _a;
          const sizeShrinkRatio = this.options.clip ? 1 : shrinkRatio;
          const fontSize = Math.max(Math.floor((this.isTryRepeatFill ? this.options.fillTextFontSize : this.getTextFontSize(item)) * sizeShrinkRatio), this.options.minFontSize);
          let word = this.getText(item) + '';
          if (this.options.clip) {
              word = word.slice(0, Math.ceil(word.length * shrinkRatio));
          }
          if (!word) {
              return null;
          }
          const fontWeight = this.getTextFontWeight(item);
          const fontStyle = this.getTextFontStyle(item);
          const angle = this.getTextRotate ? (_a = this.getTextRotate(item, index)) !== null && _a !== void 0 ? _a : 0 : 0;
          const fontFamily = this.getTextFontFamily(item);
          const fcanvas = this.options.createCanvas({ width: 1, height: 1 });
          const fctx = fcanvas.getContext('2d', { willReadFrequently: true });
          fctx.font = fontStyle + ' ' + fontWeight + ' ' + fontSize.toString(10) + 'px ' + fontFamily;
          const fw = fctx.measureText(word).width;
          const fh = Math.max(fontSize, fctx.measureText('m').width, fctx.measureText('\uFF37').width);
          let boxWidth = fw + fh * 2;
          let boxHeight = fh * 3;
          const fgw = Math.ceil(boxWidth / this.gridSize);
          const fgh = Math.ceil(boxHeight / this.gridSize);
          boxWidth = fgw * this.gridSize;
          boxHeight = fgh * this.gridSize;
          const fillTextOffsetX = -fw / 2;
          const fillTextOffsetY = -fh * 0.4;
          const cgh = Math.ceil((boxWidth * Math.abs(Math.sin(angle)) + boxHeight * Math.abs(Math.cos(angle))) / this.gridSize);
          const cgw = Math.ceil((boxWidth * Math.abs(Math.cos(angle)) + boxHeight * Math.abs(Math.sin(angle))) / this.gridSize);
          const width = cgw * this.gridSize;
          const height = cgh * this.gridSize;
          fcanvas.setAttribute('width', '' + width);
          fcanvas.setAttribute('height', '' + height);
          fctx.scale(1, 1);
          fctx.translate(width / 2, height / 2);
          fctx.rotate(-angle);
          fctx.font = fontStyle + ' ' + fontWeight + ' ' + fontSize.toString(10) + 'px ' + fontFamily;
          fctx.fillStyle = '#000';
          fctx.textBaseline = 'middle';
          fctx.fillText(word, fillTextOffsetX, fillTextOffsetY);
          const imageData = fctx.getImageData(0, 0, width, height).data;
          if (this.exceedTime()) {
              return null;
          }
          const occupied = [];
          let gx = cgw;
          let gy;
          const bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];
          const singleGridLoop = (gx, gy, out) => {
              let y = this.gridSize;
              while (y--) {
                  let x = this.gridSize;
                  while (x--) {
                      if (imageData[((gy * this.gridSize + y) * width + (gx * this.gridSize + x)) * 4 + 3]) {
                          out.push([gx, gy]);
                          if (gx < bounds[3]) {
                              bounds[3] = gx;
                          }
                          if (gx > bounds[1]) {
                              bounds[1] = gx;
                          }
                          if (gy < bounds[0]) {
                              bounds[0] = gy;
                          }
                          if (gy > bounds[2]) {
                              bounds[2] = gy;
                          }
                          return;
                      }
                  }
              }
          };
          while (gx--) {
              gy = cgh;
              while (gy--) {
                  singleGridLoop(gx, gy, occupied);
              }
          }
          return {
              datum: item,
              occupied: occupied,
              bounds: bounds,
              gw: cgw,
              gh: cgh,
              fillTextOffsetX: fillTextOffsetX,
              fillTextOffsetY: fillTextOffsetY,
              fillTextWidth: fw,
              fillTextHeight: fh,
              fontSize,
              fontStyle,
              fontWeight,
              fontFamily,
              angle,
              text: word
          };
      }
      calculateEmptyRate() {
          const totalCount = this.ngx * this.ngy;
          let emptyCount = 0;
          for (let gx = 0; gx < this.ngx; gx++) {
              for (let gy = 0; gy < this.ngy; gy++) {
                  if (this.grid[gx][gy]) {
                      emptyCount++;
                  }
              }
          }
          return emptyCount / totalCount;
      }
      canFitText(gx, gy, gw, gh, occupied) {
          let i = occupied.length;
          while (i--) {
              const px = gx + occupied[i][0];
              const py = gy + occupied[i][1];
              if (px >= this.ngx || py >= this.ngy || px < 0 || py < 0) {
                  if (!this.options.drawOutOfBound) {
                      return false;
                  }
                  continue;
              }
              if (!this.grid[px][py]) {
                  return false;
              }
          }
          return true;
      }
      layoutWord(index, shrinkRatio = 1) {
          const item = this.data[index];
          const info = this.getTextInfo(item, shrinkRatio, index);
          if (!info) {
              return false;
          }
          if (this.exceedTime()) {
              return false;
          }
          if (!this.options.drawOutOfBound &&
              (!this.options.shrink || info.fontSize <= this.options.minFontSize) &&
              !this.options.clip) {
              const bounds = info.bounds;
              if (bounds[1] - bounds[3] + 1 > this.ngx || bounds[2] - bounds[0] + 1 > this.ngy) {
                  return false;
              }
          }
          let r = this.maxRadius + 1;
          const tryToPutWordAtPoint = (gxy) => {
              const gx = Math.floor(gxy[0] - info.gw / 2);
              const gy = Math.floor(gxy[1] - info.gh / 2);
              const gw = info.gw;
              const gh = info.gh;
              if (!this.canFitText(gx, gy, gw, gh, info.occupied)) {
                  return false;
              }
              info.distance = this.maxRadius - r;
              info.theta = gxy[2];
              this.outputText(gx, gy, info);
              this.updateGrid(gx, gy, gw, gh, info);
              return true;
          };
          while (r--) {
              let points = this.getPointsAtRadius(this.maxRadius - r);
              if (this.options.random) {
                  points = [].concat(points);
                  shuffleArray(points);
              }
              const drawn = points.some(tryToPutWordAtPoint);
              if (drawn) {
                  return true;
              }
          }
          if (this.options.clip) {
              return this.layoutWord(index, shrinkRatio * 0.75);
          }
          else if (this.options.shrink && info.fontSize > this.options.minFontSize) {
              return this.layoutWord(index, shrinkRatio * 0.75);
          }
          return false;
      }
      outputText(gx, gy, info) {
          const color = this.getTextColor(info);
          const output = {
              text: info.text,
              datum: info.datum,
              color,
              fontStyle: info.fontStyle,
              fontWeight: info.fontWeight,
              fontFamily: info.fontFamily,
              angle: info.angle,
              width: info.fillTextWidth,
              height: info.fillTextHeight,
              x: (gx + info.gw / 2) * this.gridSize,
              y: (gy + info.gh / 2) * this.gridSize + info.fillTextOffsetY + info.fontSize * 0.5,
              fontSize: info.fontSize
          };
          this.result.push(output);
          if (this.progressiveResult) {
              this.progressiveResult.push(output);
          }
      }
      initGrid(config) {
          this.grid = [];
          const shape = this.options.shape;
          if (isObject$1(shape)) {
              const canvas = generateMaskCanvas(shape, config.width, config.height, undefined, false, this.options.createCanvas);
              let imageData = canvas.getContext('2d').getImageData(0, 0, this.ngx * this.gridSize, this.ngy * this.gridSize);
              if (this.options.onUpdateMaskCanvas) {
                  this.options.onUpdateMaskCanvas(canvas);
              }
              let isEmptyPixel = generateIsEmptyPixel(shape.backgroundColor, undefined, this.options.createCanvas);
              const singleGridLoop = (gx, gy) => {
                  let y = this.gridSize;
                  while (y--) {
                      let x = this.gridSize;
                      while (x--) {
                          if (!isEmptyPixel(imageData, gy * this.gridSize + y, gx * this.gridSize + x)) {
                              this.grid[gx][gy] = true;
                              return;
                          }
                      }
                  }
                  this.grid[gx][gy] = false;
              };
              let gx = this.ngx;
              while (gx--) {
                  this.grid[gx] = [];
                  let gy = this.ngy;
                  while (gy--) {
                      singleGridLoop(gx, gy);
                      if (this.grid[gx][gy] !== false) {
                          this.grid[gx][gy] = true;
                      }
                  }
              }
              imageData = isEmptyPixel = undefined;
          }
          else {
              let gx = this.ngx;
              while (gx--) {
                  this.grid[gx] = [];
                  let gy = this.ngy;
                  while (gy--) {
                      this.grid[gx][gy] = true;
                  }
              }
          }
      }
      canRepeat() {
          return this.calculateEmptyRate() > 1e-3;
      }
      layout(data, config) {
          this.initProgressive();
          this.drawnCount = 0;
          this.isTryRepeatFill = false;
          this.originalData = data;
          this.data = data;
          this.pointsAtRadius = [];
          this.ngx = Math.floor(config.width / this.gridSize);
          this.ngy = Math.floor(config.height / this.gridSize);
          const { center, maxRadius } = getMaxRadiusAndCenter(this.options.shape, [config.width, config.height]);
          this.center = config.origin
              ? [config.origin[0] / this.gridSize, config.origin[1] / this.gridSize]
              : [center[0] / this.gridSize, center[1] / this.gridSize];
          this.maxRadius = Math.floor(maxRadius / this.gridSize);
          this.initGrid(config);
          this.result = [];
          return this.progressiveRun();
      }
  };
  GridLayout$1.defaultOptions = {
      gridSize: 8,
      ellipticity: 1,
      maxSingleWordTryCount: 1
  };

  class FastLayout extends BaseLayout {
      constructor(options) {
          super(merge({}, FastLayout.defaultOptions, options));
          this.random = this.options.random ? Math.random : () => 0;
          this.aspectRatio = 1;
      }
      fit(word) {
          for (let i = 0, len = this.result.length; i < len; i++) {
              if (isOverlap$1(word, this.result[i])) {
                  return false;
              }
          }
          return true;
      }
      getTextInfo(datum, index) {
          const info = {
              datum,
              fontSize: this.getTextFontSize(datum),
              fontWeight: this.getTextFontWeight(datum),
              fontStyle: this.getTextFontStyle(datum),
              fontFamily: this.getTextFontFamily(datum),
              angle: this.getTextRotate(datum, index),
              text: this.getText(datum) + '',
              x: this.center[0],
              y: this.center[1]
          };
          const bounds = this.options.getTextBounds(info);
          info.width = bounds.width();
          info.height = bounds.height();
          info.top = this.center[1] - info.height + info.height * 0.21;
          info.left = this.center[0] - info.width / 2;
          return info;
      }
      layoutWord(index) {
          const step = 0.5;
          const info = this.getTextInfo(this.data[index], index);
          let angle = 2 * Math.PI;
          let radius = 0;
          let left = info.left;
          let top = info.top;
          const width = info.width;
          const height = info.height;
          let rx = 1;
          let isFit = this.fit(info);
          while (!isFit && radius < this.maxRadius) {
              radius += step;
              rx = this.shape((radius / this.maxRadius) * 2 * Math.PI);
              angle += (this.options.random ? (this.random() > 0.5 ? 1 : -1) : index % 2 === 0 ? 1 : -1) * step;
              left = this.center[0] - width / 2 + radius * rx * Math.cos(angle) * this.aspectRatio;
              top = this.center[1] - height / 2 + radius * rx * Math.sin(angle);
              info.left = left;
              info.top = top;
              info.x = left + width / 2;
              info.y = top + height / 2;
              isFit = this.fit(info);
          }
          if (!isFit) {
              return false;
          }
          if (this.options.clip ||
              (info.left >= 0 && info.left + info.width <= this.width && info.top >= 0 && info.top + info.height <= this.height)) {
              this.result.push(info);
              return true;
          }
          return false;
      }
      layout(data, config) {
          if (!(data === null || data === void 0 ? void 0 : data.length)) {
              return [];
          }
          this.initProgressive();
          this.result = [];
          this.maxRadius = Math.sqrt(config.width * config.width + config.height * config.height) / 2;
          this.center = [config.width / 2, config.height / 2];
          this.width = config.width;
          this.height = config.height;
          this.data = data.sort((a, b) => {
              return this.getTextFontSize(b) - this.getTextFontSize(a);
          });
          let i = 0;
          while (i < data.length) {
              this.layoutWord(i);
              i++;
              this.progressiveIndex = i;
              if (this.exceedTime()) {
                  break;
              }
          }
          return this.result;
      }
  }
  FastLayout.defaultOptions = {
      enlarge: false
  };
  function isOverlap$1(a, b) {
      if (a.left + a.width < b.left || a.top + a.height < b.top || a.left > b.left + b.width || a.top > b.top + b.height) {
          return false;
      }
      return true;
  }

  const OUTPUT$1 = {
      x: 'x',
      y: 'y',
      z: 'z',
      fontFamily: 'fontFamily',
      fontSize: 'fontSize',
      fontStyle: 'fontStyle',
      fontWeight: 'fontWeight',
      angle: 'angle'
  };
  const transform$2 = (options, upstreamData) => {
      var _a, _b, _c, _d, _e, _f;
      if (options.size && (options.size[0] <= 0 || options.size[1] <= 0)) {
          const logger = Logger.getInstance();
          logger.info('Wordcloud size dimensions must be greater than 0');
          return [];
      }
      const data = upstreamData;
      const canvasSize = ((_a = options.size) !== null && _a !== void 0 ? _a : [500, 500]).slice();
      canvasSize[0] = Math.floor(canvasSize[0]);
      canvasSize[1] = Math.floor(canvasSize[1]);
      const fontFamily = options.fontFamily ? field(options.fontFamily) : 'sans-serif';
      const fontStyle = options.fontStyle ? field(options.fontStyle) : 'normal';
      const fontWeight = options.fontWeight ? field(options.fontWeight) : 'normal';
      const rotate = options.rotate ? field(options.rotate) : 0;
      const text = field(options.text);
      const spiral = (_b = options.spiral) !== null && _b !== void 0 ? _b : 'archimedean';
      const padding = options.padding ? field(options.padding) : 1;
      const shape = (_c = options.shape) !== null && _c !== void 0 ? _c : 'square';
      const shrink = (_d = options.shrink) !== null && _d !== void 0 ? _d : false;
      const enlarge = (_e = options.enlarge) !== null && _e !== void 0 ? _e : false;
      const clip = (_f = options.clip) !== null && _f !== void 0 ? _f : false;
      const minFontSize = options.minFontSize;
      const randomVisible = options.randomVisible;
      const as = options.as ? Object.assign(Object.assign({}, OUTPUT$1), options.as) : OUTPUT$1;
      const depth_3d = options.depth_3d;
      const postProjection = options.postProjection;
      let fontSize = options.fontSize ? field(options.fontSize) : 14;
      const fontSizeRange = options.fontSizeRange;
      if (fontSizeRange && !isNumber$1(fontSize)) {
          const fsize = fontSize;
          const fontSizeSqrtScale = generateScale(extent$1(fsize, data), fontSizeRange);
          fontSize = datum => {
              return fontSizeSqrtScale(fsize(datum));
          };
      }
      let Layout = CloudLayout;
      if (options.layoutType === 'fast') {
          Layout = FastLayout;
      }
      else if (options.layoutType === 'grid') {
          Layout = GridLayout$1;
      }
      const layout = new Layout(Object.assign(Object.assign({}, options), { text,
          padding,
          spiral,
          shape,
          rotate,
          fontFamily,
          fontStyle,
          fontWeight,
          fontSize,
          shrink,
          clip,
          enlarge,
          minFontSize, random: randomVisible, outputCallback: (words) => {
              const res = [];
              let t;
              let w;
              for (let i = 0, len = words.length; i < len; i++) {
                  w = words[i];
                  t = w.datum;
                  t[as.x] = w.x;
                  t[as.y] = w.y;
                  t[as.fontFamily] = w.fontFamily;
                  t[as.fontSize] = w.fontSize;
                  t[as.fontStyle] = w.fontStyle;
                  t[as.fontWeight] = w.fontWeight;
                  t[as.angle] = w.angle;
                  if (postProjection === 'StereographicProjection') {
                      stereographicProjection(canvasSize, w, t, as, depth_3d);
                  }
                  if (options.dataIndexKey) {
                      t[options.dataIndexKey] = `${i}`;
                  }
                  res.push(t);
              }
              return res;
          } }));
      layout.layout(data, {
          width: canvasSize[0],
          height: canvasSize[1]
      });
      if (options.progressiveStep > 0 || options.progressiveTime > 0) {
          return {
              progressive: layout
          };
      }
      return layout.output();
  };
  const field = (option) => {
      if (isString$1(option) || isNumber$1(option) || isFunction$1(option) || isArray$1(option)) {
          return option;
      }
      return (datum) => datum[option.field];
  };
  const sqrt$1 = (x) => {
      return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
  };
  const generateScale = (domain, range, type) => {
      if (domain[0] === domain[1]) {
          return (datum) => range[0];
      }
      const s0 = sqrt$1(domain[0]);
      const s1 = sqrt$1(domain[1]);
      const min = Math.min(s0, s1);
      const max = Math.max(s0, s1);
      return (datum) => ((sqrt$1(datum) - min) / (max - min)) * (range[1] - range[0]) + range[0];
  };
  const extent$1 = (field, data) => {
      let min = +Infinity;
      let max = -Infinity;
      const n = data.length;
      let v;
      for (let i = 0; i < n; ++i) {
          v = toNumber(field(data[i]));
          if (v < min) {
              min = v;
          }
          if (v > max) {
              max = v;
          }
      }
      if (data.length === 1 && min === max) {
          min -= 10000;
      }
      return [min, max];
  };
  function stereographicProjection(canvasSize, w, t, as, depth_3d) {
      const maxSize = Math.max(canvasSize[0], canvasSize[1]);
      const r = maxSize / 2;
      const out = _StereographicProjection(canvasSize[0], canvasSize[1], r, { x: r, y: r, z: depth_3d !== null && depth_3d !== void 0 ? depth_3d : r }, w);
      t[as.x] = out.x;
      t[as.y] = out.y;
      t[as.z] = out.z;
  }
  function _StereographicProjection(w, h, r, center, word) {
      const { x, y } = word;
      const theta = (x / w) * Math.PI * 2;
      let phi = Math.PI - (y / h) * Math.PI;
      phi += ((phi < Math.PI / 2 ? 1 : -1) * Math.pow(Math.min(phi - Math.PI / 2, 1), 2)) / 5;
      const nx = r * Math.sin(phi) * Math.cos(theta) + center.x;
      const ny = r * Math.cos(phi) + center.y;
      const nz = r * Math.sin(phi) * Math.sin(theta) + center.z;
      return {
          x: nx,
          y: ny,
          z: nz
      };
  }

  exports.WORDCLOUD_SHAPE_HOOK_EVENT = void 0;
  (function (WORDCLOUD_SHAPE_HOOK_EVENT) {
      WORDCLOUD_SHAPE_HOOK_EVENT["BEFORE_WORDCLOUD_SHAPE_LAYOUT"] = "beforeWordcloudShapeLayout";
      WORDCLOUD_SHAPE_HOOK_EVENT["AFTER_WORDCLOUD_SHAPE_LAYOUT"] = "afterWordcloudShapeLayout";
      WORDCLOUD_SHAPE_HOOK_EVENT["AFTER_WORDCLOUD_SHAPE_DRAW"] = "afterWordcloudShapeDraw";
  })(exports.WORDCLOUD_SHAPE_HOOK_EVENT || (exports.WORDCLOUD_SHAPE_HOOK_EVENT = {}));
  const colorListEqual = (arr0, arr1) => {
      if (arr1.length === 1 && arr1[0] === '#537EF5') {
          return true;
      }
      if (!Array.isArray(arr0) || !Array.isArray(arr1) || arr0.length !== arr1.length) {
          return false;
      }
      for (let i = 0; i < arr0.length; i++) {
          if (arr0[i] !== arr1[i]) {
              return false;
          }
      }
      return true;
  };
  const isChinese = (text) => {
      return /^[\u4e00-\u9fa5]+$/.test(text);
  };
  const calTextLength = (text, textLengthLimit) => {
      if (isNil$1(text)) {
          return 0;
      }
      let length = 0;
      for (const char of text) {
          isChinese(char) ? (length += 1) : (length += 0.53);
      }
      return length;
  };
  function functor(d) {
      return typeof d === 'function'
          ? d
          : function () {
              return d;
          };
  }

  function allocateWords(words, segmentationOutput) {
      const { segmentation: { regions } } = segmentationOutput;
      let areaMax = -Infinity;
      let totalArea = 0;
      let areaMaxIndex = 0;
      regions.forEach((region, index) => {
          const area = region.area;
          if (area > areaMax) {
              areaMax = area;
              areaMaxIndex = index;
          }
          totalArea += area;
      });
      let wordsSum = 0;
      regions.forEach((region) => {
          const area = region.area;
          const regionNum = Math.ceil((area / totalArea) * words.length);
          const regionWeight = area / areaMax;
          region.words = [];
          region.regionNum = regionNum;
          region.regionWeight = regionWeight;
          wordsSum += regionNum;
      });
      if (wordsSum < words.length) {
          regions[areaMaxIndex].wordsNum += words.length - wordsSum;
      }
      let currIndex = areaMaxIndex;
      const regionNums = regions.map((region) => region.regionNum);
      words.forEach((word) => {
          let failCounter = 0;
          let updateCounter = 0;
          word.regionIndex = -1;
          do {
              if (regionNums[currIndex] > 0 && word.weight <= regions[currIndex].regionWeight) {
                  word.regionIndex = currIndex;
                  regions[currIndex].words.push(word);
                  regionNums[currIndex]--;
                  currIndex = (currIndex + 1) % regions.length;
                  break;
              }
              currIndex = (currIndex + 1) % regions.length;
              failCounter++;
              updateCounter++;
              if (updateCounter > regions.length + 1) {
                  regions.forEach((region) => {
                      region.regionWeight += 0.15;
                  });
                  updateCounter = 0;
              }
          } while (word.regionIndex === -1 && failCounter < regions.length * 3);
          if (word.regionIndex === -1) {
              word.regionIndex = areaMaxIndex;
              regions[areaMaxIndex].words.push(word);
              regionNums[areaMaxIndex]--;
          }
      });
      regions.forEach((region) => {
          region.words.sort((a, b) => b.weight - a.weight);
      });
  }

  function layout(words, layoutConfig, segmentationOutput) {
      const { size, stepFactor } = layoutConfig;
      const { segmentation: { regions }, tempCanvas: canvas, boardSize, shapeCenter, shapeMaxR, shapeRatio } = segmentationOutput;
      const board = initBoardWithShape(segmentationOutput);
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      for (const region of regions) {
          const { words: regionWords, center, maxR, ratio } = region;
          for (let i = 0; i < regionWords.length; i++) {
              measureSprite(canvas, ctx, words, i);
              const word = regionWords[i];
              word.x = center[0];
              word.y = center[1];
              if (word.hasText && word.sprite && place(board, word, maxR, ratio, size, boardSize, stepFactor)) {
                  word.hasPlaced = true;
              }
          }
      }
      for (let _ = 0; _ < layoutConfig.textLayoutTimes; _++) {
          const failedWords = words.filter((word) => {
              if (!word.hasPlaced) {
                  word.hasText = false;
                  word.sprite = null;
                  word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize);
              }
              return !word.hasPlaced;
          });
          if (failedWords.length === 0) {
              break;
          }
          for (let i = 0; i < failedWords.length; i++) {
              const word = failedWords[i];
              measureSprite(canvas, ctx, failedWords, i);
              word.x = shapeCenter[0];
              word.y = shapeCenter[1];
              if (word.hasText && place(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor)) {
                  word.hasPlaced = true;
              }
          }
      }
      layoutConfig.board = board;
  }
  function layoutGlobalShrink(words, layoutConfig, segmentationOutput) {
      const { stepFactor, importantWordCount, globalShinkLimit } = layoutConfig;
      const { size, segmentation: { regions }, tempCanvas: canvas, boardSize, shapeCenter, shapeMaxR, shapeRatio } = segmentationOutput;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const boardOrigin = initBoardWithShape(segmentationOutput);
      let board = boardOrigin.slice(0);
      const fontFactor = layoutConfig.fontSizeShrinkFactor;
      let id = null;
      let idIntialFactor = 1;
      let globalShinkFactor = 1;
      const importantCount = importantWordCount;
      let weightStd = 0;
      if (words.length > importantCount) {
          const wordWeights = words.sort((word0, word1) => {
              return word1.weight - word0.weight;
          });
          weightStd = wordWeights[importantCount].weight;
      }
      for (let k = 0; k < regions.length; k++) {
          const region = regions[k];
          const { words: regionWords, center, maxR, ratio } = region;
          let restartTag = false;
          for (let i = 0; i < regionWords.length; i++) {
              measureSprite(canvas, ctx, words, i);
              const word = regionWords[i];
              word.x = center[0];
              word.y = center[1];
              if (!word.skip && word.hasText && word.sprite && place(board, word, maxR, ratio, size, boardSize, stepFactor)) {
                  word.hasPlaced = true;
              }
              else if (!word.skip && word.weight > weightStd && globalShinkFactor > globalShinkLimit) {
                  const wordId = word.datum[Symbol.for('vGrammar_id')];
                  if (wordId !== id) {
                      id = wordId;
                      idIntialFactor = globalShinkFactor;
                  }
                  globalShinkFactor = globalShinkFactor * fontFactor;
                  words.forEach(word => {
                      word.hasText = false;
                      word.sprite = null;
                      word.fontSize = word.fontSize * fontFactor;
                  });
                  board = boardOrigin.slice(0);
                  restartTag = true;
                  break;
              }
              else if (!word.skip && word.datum[Symbol.for('vGrammar_id')] === id) {
                  words.forEach(word => {
                      word.hasText = false;
                      word.sprite = null;
                      word.fontSize = word.fontSize / globalShinkFactor;
                  });
                  word.skip = true;
                  globalShinkFactor = idIntialFactor;
                  id = null;
                  board = boardOrigin.slice(0);
                  restartTag = true;
                  break;
              }
          }
          if (restartTag) {
              k = -1;
              continue;
          }
      }
      for (let _ = 0; _ < layoutConfig.textLayoutTimes; _++) {
          const failedWords = words.filter(word => {
              if (!word.hasPlaced) {
                  word.hasText = false;
                  word.sprite = null;
                  word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize);
              }
              return !word.hasPlaced;
          });
          if (failedWords.length === 0) {
              break;
          }
          for (let i = 0; i < failedWords.length; i++) {
              const word = failedWords[i];
              measureSprite(canvas, ctx, failedWords, i);
              word.x = shapeCenter[0];
              word.y = shapeCenter[1];
              if (word.hasText && place(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor)) {
                  word.hasPlaced = true;
              }
          }
      }
      layoutConfig.board = board;
  }
  function layoutSelfEnlarge(words, layoutConfig, segmentationOutput) {
      const { size, stepFactor, importantWordCount } = layoutConfig;
      const { segmentation: { regions }, tempCanvas: canvas, boardSize, shapeCenter, shapeMaxR, shapeRatio } = segmentationOutput;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const boardOrigin = initBoardWithShape(segmentationOutput);
      let board = boardOrigin.slice(0);
      const fontFactor = layoutConfig.fontSizeEnlargeFactor;
      const importantCount = Math.min(importantWordCount, words.length);
      let weightStd = 0;
      if (words.length > importantCount) {
          const wordWeights = words.sort((word0, word1) => {
              return word1.weight - word0.weight;
          });
          weightStd = wordWeights[importantCount - 1].weight;
      }
      let importantWordSuccessedNum = 0;
      let globalEnlargeFactor = 1;
      let layoutFinish = false;
      for (let k = 0; k < regions.length; k++) {
          const region = regions[k];
          const { words: regionWords, center, maxR, ratio } = region;
          let restartTag = false;
          for (let i = 0; i < regionWords.length; i++) {
              measureSprite(canvas, ctx, words, i);
              const word = regionWords[i];
              word.x = center[0];
              word.y = center[1];
              if (word.hasText && word.sprite && place(board, word, maxR, ratio, size, boardSize, stepFactor)) {
                  word.hasPlaced = true;
                  if (word.weight >= weightStd) {
                      importantWordSuccessedNum++;
                  }
                  if (importantWordSuccessedNum >= importantCount && !layoutFinish) {
                      globalEnlargeFactor = globalEnlargeFactor * fontFactor;
                      words.forEach(word => {
                          word.hasText = false;
                          word.sprite = null;
                          word.fontSize = word.fontSize * fontFactor;
                      });
                      board = boardOrigin.slice(0);
                      restartTag = true;
                      importantWordSuccessedNum = 0;
                      break;
                  }
              }
              else if (word.weight >= weightStd && globalEnlargeFactor > 1) {
                  words.forEach(word => {
                      word.hasText = false;
                      word.sprite = null;
                      word.fontSize = word.fontSize / fontFactor;
                  });
                  globalEnlargeFactor = globalEnlargeFactor / fontFactor;
                  layoutFinish = true;
                  board = boardOrigin.slice(0);
                  restartTag = true;
                  break;
              }
              else if (word.weight >= weightStd) {
                  return layoutGlobalShrink(words, layoutConfig, segmentationOutput);
              }
          }
          if (restartTag) {
              k = -1;
              continue;
          }
      }
      for (let _ = 0; _ < layoutConfig.textLayoutTimes; _++) {
          const failedWords = words.filter(word => {
              if (!word.hasPlaced) {
                  word.hasText = false;
                  word.sprite = null;
                  word.fontSize = Math.max(~~(word.fontSize * layoutConfig.fontSizeShrinkFactor), layoutConfig.minFontSize);
              }
              return !word.hasPlaced;
          });
          if (failedWords.length === 0) {
              break;
          }
          for (let i = 0; i < failedWords.length; i++) {
              const word = failedWords[i];
              measureSprite(canvas, ctx, failedWords, i);
              word.x = shapeCenter[0];
              word.y = shapeCenter[1];
              if (word.hasText && place(board, word, shapeMaxR, shapeRatio, size, boardSize, stepFactor)) {
                  word.hasPlaced = true;
              }
          }
      }
      layoutConfig.board = board;
  }
  function place(board, word, maxR, ratio, size, boardSize, stepFactor) {
      const startX = word.x;
      const startY = word.y;
      const spiral = archimedeanSpiral(ratio);
      const dt = 1 * stepFactor;
      let dxdy;
      let dx;
      let dy;
      let t = -dt;
      while ((dxdy = spiral((t += dt)))) {
          const { wordSize, bounds: { dTop, dBottom, dLeft, dRight } } = word;
          dx = dxdy[0];
          dy = dxdy[1];
          if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxR) {
              break;
          }
          word.x = ~~(startX + dx);
          word.y = ~~(startY + dy);
          if (word.x - dLeft < 0 || word.x + dRight > size[0] || word.y - dTop < 0 || word.y + dBottom > size[1]) {
              continue;
          }
          if (!isCollideWithBoard(word, board, boardSize)) {
              placeWordOnBoard(word, board, boardSize);
              return true;
          }
      }
      return false;
  }
  function placeWordOnBoard(word, board, boardSize) {
      const { wordSize } = word;
      const sprite = word.sprite;
      const w = wordSize[0] >> 5;
      const sw = boardSize[0] >> 5;
      const lx = word.x - (w << 4);
      const sx = lx % 32;
      const msx = 32 - sx;
      const h = wordSize[1];
      let x = (word.y - (wordSize[1] >> 1)) * sw + (lx >> 5);
      let last;
      if (sx === 0) {
          for (let j = 0; j < h; j++) {
              for (let i = 0; i < w; i++) {
                  board[x + i] |= sprite[j * w + i];
              }
              x += sw;
          }
      }
      else {
          for (let j = 0; j < h; j++) {
              last = 0;
              for (let i = 0; i <= w; i++) {
                  board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
              }
              x += sw;
          }
      }
  }
  function isCollideWithBoard(word, board, boardSize) {
      const { sprite, wordSize } = word;
      const sw = boardSize[0] >> 5;
      const w = wordSize[0] >> 5;
      const lx = word.x - (w << 4);
      const sx = lx % 32;
      const msx = 32 - sx;
      const h = wordSize[1];
      let last;
      let x = (word.y - (wordSize[1] >> 1)) * sw + (lx >> 5);
      if (sx === 0) {
          for (let j = 0; j < h; j++) {
              for (let i = 0; i < w; i++) {
                  if (board[x + i] & sprite[j * w + i]) {
                      return true;
                  }
              }
              x += sw;
          }
      }
      else {
          for (let j = 0; j < h; j++) {
              last = 0;
              for (let i = 0; i <= w; i++) {
                  if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) {
                      return true;
                  }
              }
              x += sw;
          }
      }
      return false;
  }
  function archimedeanSpiral(ratio) {
      return function (t) {
          return [ratio * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
      };
  }
  function measureSprite(canvas, ctx, words, wi) {
      if (words[wi].sprite || words[wi].fontSize === 0) {
          return;
      }
      const cw = 2048;
      const ch = 2048;
      const radians = Math.PI / 180;
      const n = words.length;
      canvas.width = cw;
      canvas.height = ch;
      ctx.clearRect(0, 0, cw, ch);
      ctx.textAlign = 'center';
      let x = 0;
      let y = 0;
      let maxHeight = 0;
      let wordW;
      let wordH;
      let yMax = 0;
      const wiDist = wi;
      --wi;
      while (++wi < n) {
          const word = words[wi];
          const fontSize = Math.max(word.fontSize, 2);
          ctx.save();
          ctx.font = word.fontStyle + ' ' + word.fontWeight + ' ' + fontSize + 'px ' + word.fontFamily;
          wordW = ctx.measureText(word.text + 'm').width + word.padding * 2;
          wordH = fontSize * 2 + word.padding * 2;
          if (word.rotate !== 0) {
              const sr = Math.sin(word.rotate * radians);
              const cr = Math.cos(word.rotate * radians);
              const wcr = wordW * cr;
              const wsr = wordW * sr;
              const hcr = wordH * cr;
              const hsr = wordH * sr;
              wordW = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr));
              wordH = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
          }
          wordW = ((wordW + 31) >> 5) << 5;
          wordH = Math.ceil(wordH);
          if (wordH > maxHeight) {
              maxHeight = wordH;
          }
          if (x + wordW >= cw) {
              x = 0;
              y += maxHeight;
              maxHeight = wordH;
          }
          if (y + wordH >= ch) {
              if (y === 0) {
                  word.hasText = false;
                  continue;
              }
              else {
                  break;
              }
          }
          if (y + wordH >= yMax) {
              yMax = y + wordH;
          }
          ctx.translate(x + (wordW >> 1), y + (wordH >> 1));
          if (word.rotate !== 0) {
              ctx.rotate(word.rotate * radians);
          }
          ctx.fillText(word.text, 0, 0);
          if (word.padding) {
              ctx.lineWidth = 2 * word.padding;
              ctx.strokeText(word.text, 0, 0);
          }
          ctx.restore();
          word.LT = [x, y];
          word.wordSize = [wordW, wordH];
          word.hasText = true;
          x += wordW;
      }
      if (yMax === 0) {
          return;
      }
      const pixels = ctx.getImageData(0, 0, cw, yMax).data;
      let i;
      let j;
      while (--wi >= wiDist) {
          const word = words[wi];
          if (!word.hasText) {
              word.bounds = {
                  dTop: Infinity,
                  dBottom: -Infinity,
                  dLeft: Infinity,
                  dRight: -Infinity
              };
              break;
          }
          const { LT = [0, 0], wordSize } = word;
          [x, y] = LT;
          const w32 = wordSize[0] >> 5;
          const sprite = new Array(w32 * wordSize[1]).fill(0);
          let [dTop, dBottom, dLeft, dRight] = [Infinity, -Infinity, Infinity, -Infinity];
          for (j = 0; j < wordSize[1]; j++) {
              let seen;
              for (i = 0; i < wordSize[0]; i++) {
                  if (pixels[((y + j) * cw + (x + i)) * 4 + 3] > 0) {
                      const k = w32 * j + (i >> 5);
                      const m = 1 << (31 - (i % 32));
                      sprite[k] |= m;
                      if (i < dLeft) {
                          dLeft = i;
                      }
                      if (i > dRight) {
                          dRight = i;
                      }
                      seen |= m;
                  }
              }
              if (seen) {
                  if (j < dTop) {
                      dTop = j;
                  }
                  if (j > dBottom) {
                      dBottom = j;
                  }
              }
          }
          word.bounds = {
              dTop: (wordSize[1] >> 1) - dTop,
              dBottom: dBottom - (wordSize[1] >> 1),
              dLeft: (wordSize[0] >> 1) - dLeft,
              dRight: dRight - (wordSize[0] >> 1)
          };
          word.sprite = sprite;
          delete word.LT;
      }
  }
  function initBoardWithShape(segmentationOutput) {
      const { segmentation: { labels }, boardSize, size } = segmentationOutput;
      const w32 = boardSize[0] >> 5;
      const board = new Array(w32 * size[1]).fill(0);
      for (let i = 0; i < size[1]; i++) {
          for (let j = 0; j < size[0]; j++) {
              const label = labels[i * size[0] + j];
              if (label === 0) {
                  const k = w32 * i + (j >> 5);
                  const m = 1 << (31 - (j % 32));
                  board[k] |= m;
              }
          }
      }
      if (boardSize[0] > size[0]) {
          const width = boardSize[0] - size[0];
          const m = (1 << width) - 1;
          for (let y = 0; y < size[1]; y++) {
              const k = w32 * y + w32 - 1;
              board[k] |= m;
          }
      }
      return board;
  }

  function filling(words, layoutConfig, segmentationOutput) {
      const { size, fillingTimes, fillingXStep, fillingYStep, getFillingFontStyle, getFillingFontWeight, getFillingFontFamily, fillingInitialFontSize, fillingDeltaFontSize, fillingInitialOpacity, fillingDeltaOpacity, fillingRotateList, getFillingPadding, random, board, minFillFontSize } = layoutConfig;
      const { boardSize, shapeBounds, tempCanvas: canvas, randomGenerator } = segmentationOutput;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      let fontSize = fillingInitialFontSize;
      let opacity = fillingInitialOpacity;
      const placedFillingWords = [];
      for (let i = 0; i < fillingTimes; i++) {
          filling1Time(fontSize, opacity);
          fontSize = Math.max(fontSize > fillingDeltaFontSize ? fontSize - fillingDeltaFontSize : fillingDeltaFontSize, minFillFontSize);
          opacity = opacity > fillingDeltaOpacity ? opacity - fillingDeltaOpacity : fillingDeltaOpacity;
      }
      return placedFillingWords;
      function filling1Time(fontSize, opacity) {
          const fillingWords = words.map(word => {
              const { text, color, fillingColor, hasPlaced, datum } = word;
              return {
                  x: 0,
                  y: 0,
                  weight: 0,
                  text,
                  fontFamily: getFillingFontFamily(datum),
                  fontStyle: getFillingFontStyle(datum),
                  fontWeight: getFillingFontWeight(datum),
                  fontSize,
                  rotate: fillingRotateList[~~(randomGenerator() * fillingRotateList.length)],
                  padding: getFillingPadding(datum),
                  opacity,
                  visible: true,
                  color,
                  fillingColor,
                  hasPlaced,
                  datum
              };
          });
          randomArray(fillingWords);
          let wi = 0;
          const { x1, y1, x2, y2 } = shapeBounds;
          const [startX, startY] = [
              x1 + ~~(randomGenerator() * fillingXStep * 2),
              y1 + ~~(randomGenerator() * fillingYStep * 2)
          ];
          for (let y = startY; y <= y2; y += fillingYStep) {
              for (let x = startX; x <= x2; x += fillingXStep) {
                  measureSprite(canvas, ctx, fillingWords, wi);
                  const word = fillingWords[wi];
                  word.x = x;
                  word.y = y;
                  const { wordSize, bounds, hasPlaced } = word;
                  if (!hasPlaced || !bounds) {
                      if (++wi === fillingWords.length) {
                          wi = 0;
                          if (random) {
                              randomArray(fillingWords);
                          }
                      }
                      continue;
                  }
                  const { dTop, dBottom, dLeft, dRight } = bounds;
                  if (word.x - dLeft < 0 || word.x + dRight > size[0] || word.y - dTop < 0 || word.y + dBottom > size[1]) {
                      continue;
                  }
                  if (word.hasText && word.sprite && !isCollideWithBoard(word, board, boardSize)) {
                      placeWordOnBoard(word, board, boardSize);
                      placedFillingWords.push(Object.assign({}, word));
                      if (++wi === fillingWords.length) {
                          wi = 0;
                          if (random) {
                              randomArray(fillingWords);
                          }
                      }
                  }
              }
          }
      }
      function randomArray(words) {
          return words.sort(() => randomGenerator() - 0.5);
      }
  }

  function cloud (words, layoutConfig, segmentationOutput) {
      allocateWords(words, segmentationOutput);
      if (layoutConfig.layoutMode === 'ensureMapping') {
          layoutGlobalShrink(words, layoutConfig, segmentationOutput);
      }
      else if (layoutConfig.layoutMode === 'ensureMappingEnlarge') {
          layoutSelfEnlarge(words, layoutConfig, segmentationOutput);
      }
      else {
          layout(words, layoutConfig, segmentationOutput);
      }
      const fillingWords = filling(words, layoutConfig, segmentationOutput);
      const failedWords = [];
      const successedWords = [];
      for (let i = 0; i < words.length; i++) {
          if (words[i].hasPlaced) {
              successedWords.push(words[i]);
          }
          else {
              failedWords.push(words[i]);
          }
      }
      failedWords.forEach(word => (word.visible = false));
      return {
          fillingWords,
          successedWords,
          failedWords
      };
  }

  function loadImage(url, createImage) {
      if (!url || (!isValidUrl$1(url) && !isBase64$1(url) && !url.startsWith('<svg'))) {
          return null;
      }
      return new Promise((resolve, reject) => {
          var _a;
          const imageMark = createImage({ image: url });
          const imgData = (_a = imageMark.resources) === null || _a === void 0 ? void 0 : _a.get(url);
          if (imgData && imgData.state === 'success' && imgData.data) {
              resolve(imgData.data);
              return;
          }
          imageMark.successCallback = () => {
              var _a;
              if (imageMark) {
                  const imgData = (_a = imageMark.resources) === null || _a === void 0 ? void 0 : _a.get(url);
                  if (imgData && imgData.state === 'success' && imgData.data) {
                      resolve(imgData.data);
                  }
                  else {
                      reject(new Error('image load failed: ' + url));
                  }
              }
              else {
                  reject(new Error('image load failed: ' + url));
              }
          };
          imageMark.failCallback = () => {
              reject(new Error('image load failed: ' + url));
          };
      });
  }
  function loadImages(urls, createImage) {
      return Promise.allSettled(urls.map(url => loadImage(url, createImage)));
  }

  var ScaleEnum;
  !function (ScaleEnum) {
    ScaleEnum.Identity = "identity", ScaleEnum.Linear = "linear", ScaleEnum.Log = "log", ScaleEnum.Pow = "pow", ScaleEnum.Sqrt = "sqrt", ScaleEnum.Symlog = "symlog", ScaleEnum.Time = "time", ScaleEnum.Quantile = "quantile", ScaleEnum.Quantize = "quantize", ScaleEnum.Threshold = "threshold", ScaleEnum.Ordinal = "ordinal", ScaleEnum.Point = "point", ScaleEnum.Band = "band";
  }(ScaleEnum || (ScaleEnum = {}));
  Object.values(ScaleEnum).forEach(v => {
  });

  function identity(x) {
    return x;
  }
  const sqrt = x => x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
  const square = x => x < 0 ? -x * x : x * x;
  function normalize(a, b) {
    if (a = Number(a), b = Number(b), b -= a) return x => (x - a) / b;
    const result = Number.isNaN(b) ? NaN : .5;
    return () => result;
  }
  function bimap(domain, range, interpolate) {
    const d0 = domain[0],
      d1 = domain[1],
      r0 = range[0],
      r1 = range[1];
    let d0Fuc, r0Fuc;
    return d1 < d0 ? (d0Fuc = normalize(d1, d0), r0Fuc = interpolate(r1, r0)) : (d0Fuc = normalize(d0, d1), r0Fuc = interpolate(r0, r1)), x => r0Fuc(d0Fuc(x));
  }
  function calculateWholeRangeFromRangeFactor(range, rangeFactor) {
    const k = (range[1] - range[0]) / (rangeFactor[1] - rangeFactor[0]),
      b = range[0] - k * rangeFactor[0];
    return [b, k + b];
  }
  function polymap(domain, range, interpolate) {
    const j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j);
    let i = -1;
    for (domain[j] < domain[0] && (domain = domain.slice().reverse(), range = range.slice().reverse()); ++i < j;) d[i] = normalize(domain[i], domain[i + 1]), r[i] = interpolate(range[i], range[i + 1]);
    return function (x) {
      const i = bisect(domain, x, 1, j) - 1;
      return r[i](d[i](x));
    };
  }

  class BaseScale {
    constructor() {
      this._rangeFactorStart = null, this._rangeFactorEnd = null;
    }
    _calculateWholeRange(range) {
      return this._wholeRange ? this._wholeRange : isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && 2 === range.length ? (this._wholeRange = calculateWholeRangeFromRangeFactor(range, [this._rangeFactorStart, this._rangeFactorEnd]), this._wholeRange) : range;
    }
    rangeFactor(_, slience, clear) {
      return _ ? (2 === _.length && _.every(r => r >= 0 && r <= 1) && (this._wholeRange = null, 0 === _[0] && 1 === _[1] ? (this._rangeFactorStart = null, this._rangeFactorEnd = null) : (this._rangeFactorStart = _[0], this._rangeFactorEnd = _[1])), this) : clear ? (this._wholeRange = null, this._rangeFactorStart = null, this._rangeFactorEnd = null, this) : isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) ? [this._rangeFactorStart, this._rangeFactorEnd] : null;
    }
    rangeFactorStart(_, slience) {
      var _a;
      return isNil$1(_) ? this._rangeFactorStart : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil$1(this._rangeFactorEnd) && 1 !== this._rangeFactorEnd ? (this._rangeFactorStart = _, this._rangeFactorEnd = null !== (_a = this._rangeFactorEnd) && void 0 !== _a ? _a : 1) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
    }
    rangeFactorEnd(_, slience) {
      var _a;
      return isNil$1(_) ? this._rangeFactorEnd : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil$1(this._rangeFactorStart) && 0 !== this._rangeFactorStart ? (this._rangeFactorEnd = _, this._rangeFactorStart = null !== (_a = this._rangeFactorStart) && void 0 !== _a ? _a : 0) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
    }
    generateFishEyeTransform() {
      var _a;
      if (!this._fishEyeOptions) return void (this._fishEyeTransform = null);
      const {
          distortion = 2,
          radiusRatio = .1,
          radius: radius
        } = this._fishEyeOptions,
        range = this.range(),
        first = range[0],
        last = range[range.length - 1],
        min = Math.min(first, last),
        max = Math.max(first, last),
        focus = clamp$1(null !== (_a = this._fishEyeOptions.focus) && void 0 !== _a ? _a : 0, min, max),
        rangeRadius = isNil$1(radius) ? (max - min) * radiusRatio : radius;
      let k0 = Math.exp(distortion);
      k0 = k0 / (k0 - 1) * rangeRadius;
      const k1 = distortion / rangeRadius;
      this._fishEyeTransform = output => {
        const delta = Math.abs(output - focus);
        if (delta >= rangeRadius) return output;
        if (delta <= 1e-6) return focus;
        const k = k0 * (1 - Math.exp(-delta * k1)) / delta * .75 + .25;
        return focus + (output - focus) * k;
      };
    }
    unknown(_) {
      return arguments.length ? (this._unknown = _, this) : this._unknown;
    }
    get(key, defaultValue) {
      var _a;
      return null !== (_a = null == this ? void 0 : this[key]) && void 0 !== _a ? _a : defaultValue;
    }
  }

  const implicit = Symbol("implicit");
  class OrdinalScale extends BaseScale {
    specified(_) {
      var _a;
      return _ ? (this._specified = Object.assign(null !== (_a = this._specified) && void 0 !== _a ? _a : {}, _), this) : Object.assign({}, this._specified);
    }
    _getSpecifiedValue(input) {
      if (this._specified) return this._specified[input];
    }
    constructor() {
      super(), this.type = ScaleEnum.Ordinal, this._index = new Map(), this._domain = [], this._ordinalRange = [], this._unknown = implicit;
    }
    clone() {
      const s = new OrdinalScale().domain(this._domain).range(this._ordinalRange).unknown(this._unknown);
      return this._specified && s.specified(this._specified), s;
    }
    calculateVisibleDomain(range) {
      if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && 2 === range.length) {
        return [this.invert(range[0]), this.invert(range[1])];
      }
      return this._domain;
    }
    scale(d) {
      const key = `${d}`,
        special = this._getSpecifiedValue(key);
      if (void 0 !== special) return special;
      let i = this._index.get(key);
      if (!i) {
        if (this._unknown !== implicit) return this._unknown;
        i = this._domain.push(d), this._index.set(key, i);
      }
      const output = this._ordinalRange[(i - 1) % this._ordinalRange.length];
      return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
    }
    invert(d) {
      let i = 0;
      for (; i < this._ordinalRange.length && this._ordinalRange[i] !== d;) i++;
      return this._domain[(i - 1) % this._domain.length];
    }
    domain(_) {
      if (!_) return this._domain.slice();
      this._domain = [], this._index = new Map();
      for (const value of _) {
        const key = `${value}`;
        this._index.has(key) || this._index.set(key, this._domain.push(value));
      }
      return this;
    }
    range(_) {
      if (!_) return this._ordinalRange.slice();
      const nextRange = Array.from(_);
      return this._ordinalRange = nextRange, this;
    }
    index(x) {
      var _a;
      return this._index && null !== (_a = this._index.get(`${x}`)) && void 0 !== _a ? _a : -1;
    }
  }

  const {
    interpolateRgb: interpolateRgb
  } = ColorUtil;
  function interpolate(a, b) {
    const t = typeof b;
    let c;
    if (isNil$1(b) || "boolean" === t) return () => b;
    if ("number" === t) return interpolateNumber(a, b);
    if ("string" === t) {
      if (c = Color.parseColorString(b)) {
        const rgb = interpolateRgb(Color.parseColorString(a), c);
        return t => rgb(t).formatRgb();
      }
      return interpolateNumber(Number(a), Number(b));
    }
    return b instanceof RGB ? interpolateRgb(a, b) : b instanceof Color ? interpolateRgb(a.color, b.color) : b instanceof Date ? interpolateDate(a, b) : interpolateNumber(Number(a), Number(b));
  }

  class ContinuousScale extends BaseScale {
    constructor() {
      let transformer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;
      let untransformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
      super(), this._unknown = void 0, this.transformer = transformer, this.untransformer = untransformer, this._forceAlign = !0, this._domain = [0, 1], this._range = [0, 1], this._clamp = identity, this._piecewise = bimap, this._interpolate = interpolate;
    }
    calculateVisibleDomain(range) {
      var _a;
      if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && 2 === range.length) {
        return [this.invert(range[0]), this.invert(range[1])];
      }
      return null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain;
    }
    fishEye(options, slience, clear) {
      return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
    }
    scale(x) {
      var _a;
      if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
      this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
      const output = this._output(this.transformer(this._clamp(x)));
      return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
    }
    invert(y) {
      var _a;
      return this._input || (this._input = this._piecewise(this._calculateWholeRange(this._range), (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), interpolateNumber)), this._clamp(this.untransformer(this._input(y)));
    }
    domain(_, slience) {
      var _a;
      if (!_) return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).slice();
      this._domainValidator = null, this._niceType = null, this._niceDomain = null;
      const nextDomain = Array.from(_, toNumber);
      return this._domain = nextDomain, this.rescale(slience);
    }
    range(_, slience) {
      if (!_) return this._range.slice();
      const nextRange = Array.from(_);
      return this._range = nextRange, this.rescale(slience);
    }
    rangeRound(_, slience) {
      const nextRange = Array.from(_);
      return this._range = nextRange, this._interpolate = interpolateNumberRound, this.rescale(slience);
    }
    rescale(slience) {
      var _a;
      if (slience) return this;
      const domain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain,
        domainLength = domain.length,
        rangeLength = this._range.length;
      let n = Math.min(domainLength, rangeLength);
      if (domainLength && domainLength < rangeLength && this._forceAlign) {
        const deltaStep = rangeLength - domainLength + 1,
          last = domain[domainLength - 1],
          delta = domainLength >= 2 ? (last - domain[domainLength - 2]) / deltaStep : 0;
        for (let i = 1; i <= deltaStep; i++) domain[domainLength - 2 + i] = last - delta * (deltaStep - i);
        n = rangeLength;
      }
      return this._autoClamp && (this._clamp = clamper(domain[0], domain[n - 1])), this._piecewise = n > 2 ? polymap : bimap, this._output = this._input = null, this._wholeRange = null, this.generateFishEyeTransform(), this;
    }
    clamp(_, f, slience) {
      return arguments.length ? (f ? (this._autoClamp = !1, this._clamp = f) : (this._autoClamp = !!_, this._clamp = _ ? void 0 : identity), this.rescale(slience)) : this._clamp !== identity;
    }
    interpolate(_, slience) {
      return arguments.length ? (this._interpolate = _, this.rescale(slience)) : this._interpolate;
    }
    ticks() {
      return [];
    }
    tickData() {
      let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      const ticks = this.ticks(count);
      return (null != ticks ? ticks : []).map((tick, index) => ({
        index: index,
        tick: tick,
        value: (this.scale(tick) - this._range[0]) / (this._range[1] - this._range[0])
      }));
    }
    rangeFactor(_, slience) {
      return _ ? (super.rangeFactor(_), this._output = this._input = null, this) : super.rangeFactor();
    }
    rangeFactorStart(_, slience) {
      return isNil$1(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this._output = this._input = null, this);
    }
    rangeFactorEnd(_, slience) {
      return isNil$1(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this._output = this._input = null, this);
    }
    forceAlignDomainRange(forceAlign) {
      return arguments.length ? (this._forceAlign = forceAlign, this) : this._forceAlign;
    }
  }

  const e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2),
    niceNumbers = [1, 2, 5, 10];
  const calculateTicksOfSingleValue = (value, tickCount, noDecimals) => {
    let step = 1,
      start = value;
    const middleIndex = Math.floor((tickCount - 1) / 2),
      absVal = Math.abs(value);
    return value >= 0 && value <= Number.MIN_VALUE ? start = 0 : value < 0 && value >= -Number.MIN_VALUE ? start = -(tickCount - 1) : !noDecimals && absVal < 1 ? step = getNickStep(absVal).step : (noDecimals || absVal > 1) && (start = Math.floor(value) - middleIndex * step), step > 0 ? (value > 0 ? start = Math.max(start, 0) : value < 0 && (start = Math.min(start, -(tickCount - 1) * step)), range(0, tickCount).map(index => start + index * step)) : value > 0 ? calculateTicksByStep(0, -(tickCount - 1) / step, step) : calculateTicksByStep((tickCount - 1) / step, 0, step);
  };
  const d3Ticks = memoize((start, stop, count, options) => {
    let reverse,
      n,
      ticks,
      step,
      i = -1;
    if (count = +count, (start = +start) === (stop = +stop)) return [start];
    if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return [start];
    if ((reverse = stop < start) && (n = start, start = stop, stop = n), step = tickIncrement(start, stop, count).step, !isFinite(step)) return [];
    if (step > 0) {
      let r0 = Math.round(start / step),
        r1 = Math.round(stop / step);
      for (r0 * step < start && ++r0, r1 * step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) * step;
    } else if (step < 0 && (null == options ? void 0 : options.noDecimals)) {
      step = 1;
      const r0 = Math.ceil(start),
        r1 = Math.floor(stop);
      if (!(r0 <= r1)) return [];
      for (ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = r0 + i;
    } else {
      step = -step;
      let r0 = Math.round(start * step),
        r1 = Math.round(stop * step);
      for (r0 / step < start && ++r0, r1 / step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) / step;
    }
    return reverse && ticks.reverse(), ticks;
  });
  const calculateTicksByStep = (start, stop, step) => {
    let n,
      ticks,
      i = -1;
    if (step > 0) {
      let r0 = Math.floor(start / step),
        r1 = Math.ceil(stop / step);
      for ((r0 + 1) * step < start && ++r0, (r1 - 1) * step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) * step;
    } else {
      step = -step;
      let r0 = Math.floor(start * step),
        r1 = Math.ceil(stop * step);
      for ((r0 + 1) / step < start && ++r0, (r1 - 1) / step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) / step;
    }
    return ticks;
  };
  const appendTicksToCount = (ticks, count, step) => {
    let n;
    const firstTick = ticks[0],
      lastTick = ticks[ticks.length - 1],
      appendCount = count - ticks.length;
    if (lastTick <= 0) {
      const headTicks = [];
      for (n = appendCount; n >= 1; n--) headTicks.push(firstTick - n * step);
      return headTicks.concat(ticks);
    }
    if (firstTick >= 0) {
      for (n = 1; n <= appendCount; n++) ticks.push(lastTick + n * step);
      return ticks;
    }
    let headTicks = [];
    const tailTicks = [];
    for (n = 1; n <= appendCount; n++) n % 2 == 0 ? headTicks = [firstTick - Math.floor(n / 2) * step].concat(headTicks) : tailTicks.push(lastTick + Math.ceil(n / 2) * step);
    return headTicks.concat(ticks).concat(tailTicks);
  };
  const ticks = memoize((start, stop, count, options) => {
    let reverse, ticks, n;
    if (count = +count, (start = +start) === (stop = +stop)) return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
    if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
    (reverse = stop < start) && (n = start, start = stop, stop = n);
    const stepRes = tickIncrement(start, stop, count);
    let step = stepRes.step;
    if (!isFinite(step)) return [];
    if (step > 0) {
      let cur = 1;
      const {
          power: power,
          gap: gap
        } = stepRes,
        delatStep = 10 === gap ? 2 * 10 ** power : 1 * 10 ** power;
      for (; cur <= 5 && (ticks = calculateTicksByStep(start, stop, step), ticks.length > count + 1) && count > 2;) step += delatStep, cur += 1;
      count > 2 && ticks.length < count - 1 && (ticks = appendTicksToCount(ticks, count, step));
    } else (null == options ? void 0 : options.noDecimals) && step < 0 && (step = 1), ticks = calculateTicksByStep(start, stop, step);
    return reverse && ticks.reverse(), ticks;
  });
  const getNickStep = step => {
    const power = Math.floor(Math.log(step) / Math.LN10),
      error = step / 10 ** power;
    let gap = niceNumbers[0];
    return error >= e10 ? gap = niceNumbers[3] : error >= e5 ? gap = niceNumbers[2] : error >= e2 && (gap = niceNumbers[1]), power >= 0 ? {
      step: gap * 10 ** power,
      gap: gap,
      power: power
    } : {
      step: -(10 ** -power) / gap,
      gap: gap,
      power: power
    };
  };
  function tickIncrement(start, stop, count) {
    const step = (stop - start) / Math.max(0, count);
    return getNickStep(step);
  }
  function forceTicks(start, stop, count) {
    let step;
    if (count = +count, (start = +start) === (stop = +stop) && count > 0) return [start];
    if (count <= 0 || 0 === (step = forceTickIncrement(start, stop, count)) || !isFinite(step)) return [];
    const ticks = new Array(count);
    for (let i = 0; i < count; i++) ticks[i] = start + i * step;
    return ticks;
  }
  function forceTickIncrement(start, stop, count) {
    return (stop - start) / Math.max(1, count - 1);
  }
  function stepTicks(start, stop, step) {
    let n,
      reverse,
      i = -1;
    if (step = +step, (reverse = (stop = +stop) < (start = +start)) && (n = start, start = stop, stop = n), !isFinite(step) || stop - start <= step) return [start];
    const count = Math.floor((stop - start) / step + 1),
      ticks = new Array(count);
    for (; ++i < count;) ticks[i] = start + i * step;
    return reverse && ticks.reverse(), ticks;
  }
  function niceLinear(d) {
    let count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    let prestep,
      step,
      i0 = 0,
      i1 = d.length - 1,
      start = d[i0],
      stop = d[i1],
      maxIter = 10;
    for (stop < start && (step = start, start = stop, stop = step, step = i0, i0 = i1, i1 = step); maxIter-- > 0;) {
      if (step = tickIncrement(start, stop, count).step, step === prestep) return d[i0] = start, d[i1] = stop, d;
      if (step > 0) start = Math.floor(start / step) * step, stop = Math.ceil(stop / step) * step;else {
        if (!(step < 0)) break;
        start = Math.ceil(start * step) / step, stop = Math.floor(stop * step) / step;
      }
      prestep = step;
    }
  }
  function parseNiceOptions(originalDomain, option) {
    const hasForceMin = isNumber$1(option.forceMin),
      hasForceMax = isNumber$1(option.forceMax);
    let niceType = null;
    const niceMinMax = [];
    let niceDomain = null;
    const domainValidator = hasForceMin && hasForceMax ? x => x >= option.forceMin && x <= option.forceMax : hasForceMin ? x => x >= option.forceMin : hasForceMax ? x => x <= option.forceMax : null;
    return hasForceMin ? niceMinMax[0] = option.forceMin : isNumber$1(option.min) && option.min <= Math.min(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[0] = option.min), hasForceMax ? niceMinMax[1] = option.forceMax : isNumber$1(option.max) && option.max >= Math.max(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[1] = option.max), isNumber$1(niceMinMax[0]) && isNumber$1(niceMinMax[1]) ? (niceDomain = originalDomain.slice(), niceDomain[0] = niceMinMax[0], niceDomain[niceDomain.length - 1] = niceMinMax[1]) : niceType = isNumber$1(niceMinMax[0]) || isNumber$1(niceMinMax[1]) ? isNumber$1(niceMinMax[0]) ? "max" : "min" : "all", {
      niceType: niceType,
      niceDomain: niceDomain,
      niceMinMax: niceMinMax,
      domainValidator: domainValidator
    };
  }

  class LinearScale extends ContinuousScale {
    constructor() {
      super(...arguments), this.type = ScaleEnum.Linear;
    }
    clone() {
      var _a;
      const scale = new LinearScale();
      return scale.domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate), this._niceType && (scale._niceType = this._niceType, scale._domainValidator = this._domainValidator, scale._niceDomain = null === (_a = this._niceDomain) || void 0 === _a ? void 0 : _a.slice()), scale;
    }
    tickFormat() {
      return () => {};
    }
    d3Ticks() {
      let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      let options = arguments.length > 1 ? arguments[1] : undefined;
      const d = this.calculateVisibleDomain(this._range);
      return d3Ticks(d[0], d[d.length - 1], count, options);
    }
    ticks() {
      let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      let options = arguments.length > 1 ? arguments[1] : undefined;
      var _a;
      if (isFunction$1(null == options ? void 0 : options.customTicks)) return options.customTicks(this, count);
      if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && (this._rangeFactorStart > 0 || this._rangeFactorEnd < 1) && 2 === this._range.length || !this._niceType) return this.d3Ticks(count, options);
      const curNiceDomain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain,
        originalDomain = this._domain,
        start = curNiceDomain[0],
        stop = curNiceDomain[curNiceDomain.length - 1];
      let ticksResult = ticks(originalDomain[0], originalDomain[originalDomain.length - 1], count, options);
      if (!ticksResult.length) return ticksResult;
      if (this._domainValidator) ticksResult = ticksResult.filter(this._domainValidator);else if ((ticksResult[0] !== start || ticksResult[ticksResult.length - 1] !== stop) && this._niceType) {
        const newNiceDomain = curNiceDomain.slice();
        if ("all" === this._niceType ? (newNiceDomain[0] = ticksResult[0], newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()) : "min" === this._niceType && ticksResult[0] !== start ? (newNiceDomain[0] = ticksResult[0], this._niceDomain = newNiceDomain, this.rescale()) : "max" === this._niceType && ticksResult[ticksResult.length - 1] !== stop && (newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()), "all" !== this._niceType) {
          const min = Math.min(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]),
            max = Math.max(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]);
          ticksResult = ticksResult.filter(entry => entry >= min && entry <= max);
        }
      }
      return ticksResult;
    }
    forceTicks() {
      let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      const d = this.calculateVisibleDomain(this._range);
      return forceTicks(d[0], d[d.length - 1], count);
    }
    stepTicks(step) {
      const d = this.calculateVisibleDomain(this._range);
      return stepTicks(d[0], d[d.length - 1], step);
    }
    nice() {
      let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      let option = arguments.length > 1 ? arguments[1] : undefined;
      var _a, _b;
      const originalDomain = this._domain;
      let niceMinMax = [];
      if (option) {
        const res = parseNiceOptions(originalDomain, option);
        if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, this._niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
      } else this._niceType = "all";
      if (this._niceType) {
        const niceDomain = niceLinear(originalDomain.slice(), count);
        "min" === this._niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === this._niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale();
      }
      return this;
    }
    niceMin() {
      let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      this._niceType = "min";
      const maxD = this._domain[this._domain.length - 1],
        niceDomain = niceLinear(this.domain(), count);
      return niceDomain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
    }
    niceMax() {
      let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      this._niceType = "max";
      const minD = this._domain[0],
        niceDomain = niceLinear(this._domain.slice(), count);
      return niceDomain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
    }
  }

  class SqrtScale extends LinearScale {
    constructor() {
      super(sqrt, square), this.type = ScaleEnum.Sqrt;
    }
    clone() {
      return new SqrtScale().domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate);
    }
  }

  const OUTPUT = {
      x: 'x',
      y: 'y',
      fontFamily: 'fontFamily',
      fontSize: 'fontSize',
      fontStyle: 'fontStyle',
      fontWeight: 'fontWeight',
      angle: 'angle',
      opacity: 'opacity',
      visible: 'visible',
      isFillingWord: 'isFillingWord',
      color: 'color'
  };
  let Layout$1 = class Layout {
      constructor(options) {
          this.progressiveResult = [];
          this.options = options;
      }
      layout(data) {
          this.data = data;
          const options = this.options;
          const segmentationInput = {
              shapeUrl: options.shape,
              size: options.size,
              ratio: options.ratio || 0.8,
              tempCanvas: undefined,
              boardSize: [0, 0],
              random: false,
              randomGenerator: undefined
          };
          const tempCanvas = this.options.createCanvas({ width: options.size[0], height: options.size[1] });
          const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
          tempCtx.textAlign = 'center';
          tempCtx.textBaseline = 'middle';
          segmentationInput.tempCanvas = tempCanvas;
          const boardW = ((options.size[0] + 31) >> 5) << 5;
          segmentationInput.boardSize = [boardW, options.size[1]];
          if (segmentationInput.random) {
              segmentationInput.randomGenerator = Math.random;
          }
          else {
              segmentationInput.randomGenerator = fakeRandom();
          }
          this.segmentationInput = segmentationInput;
          if (isString$1(segmentationInput.shapeUrl)) {
              segmentationInput.isEmptyPixel = generateIsEmptyPixel(undefined, undefined, this.options.createCanvas);
              const imagePromise = loadImage(segmentationInput.shapeUrl, this.options.createImage);
              if (imagePromise) {
                  this.isImageFinished = false;
                  this.isLayoutFinished = false;
                  imagePromise
                      .then(shapeImage => {
                      this.isImageFinished = true;
                      const maskCanvas = this.options.createCanvas({
                          width: options.size[0],
                          height: options.size[1],
                          dpr: 1
                      });
                      segmentationInput.maskCanvas = maskCanvas;
                      const ctx = maskCanvas.getContext('2d');
                      if (options.removeWhiteBorder) {
                          removeBorder(shapeImage, maskCanvas, segmentationInput.isEmptyPixel);
                      }
                      const shapeConfig = scaleAndMiddleShape(shapeImage, options.size);
                      ctx.clearRect(0, 0, options.size[0], options.size[1]);
                      ctx.drawImage(shapeImage, shapeConfig.x, shapeConfig.y, shapeConfig.width, shapeConfig.height);
                      if (this.options.onUpdateMaskCanvas) {
                          this.options.onUpdateMaskCanvas(segmentationInput.maskCanvas);
                      }
                  })
                      .catch(error => {
                      this.isImageFinished = true;
                  });
              }
              else {
                  this.isImageFinished = true;
                  this.isLayoutFinished = true;
              }
          }
          else if (segmentationInput.shapeUrl &&
              (segmentationInput.shapeUrl.type === 'text' || segmentationInput.shapeUrl.type === 'geometric')) {
              segmentationInput.isEmptyPixel = generateIsEmptyPixel(segmentationInput.shapeUrl.backgroundColor, undefined, this.options.createCanvas);
              const maskCanvas = generateMaskCanvas(segmentationInput.shapeUrl, options.size[0], options.size[1], undefined, false, this.options.createCanvas);
              segmentationInput.maskCanvas = maskCanvas;
              if (this.options.onUpdateMaskCanvas) {
                  this.options.onUpdateMaskCanvas(maskCanvas);
              }
              this.doLayout();
              this.isImageFinished = true;
              this.isLayoutFinished = true;
          }
      }
      canAnimate() {
          return true;
      }
      unfinished() {
          return !this.isLayoutFinished;
      }
      output() {
          return this.progressiveResult;
      }
      progressiveRun() {
          if (!this.isImageFinished || this.isLayoutFinished) {
              return;
          }
          if (this.segmentationInput.maskCanvas) {
              this.doLayout();
          }
          this.isLayoutFinished = true;
      }
      progressiveOutput() {
          return this.progressiveResult;
      }
      doLayout() {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w;
          const segmentationInput = this.segmentationInput;
          const segmentationOutput = segmentation(segmentationInput);
          if (!segmentationOutput.segmentation.regions.length) {
              return;
          }
          const options = this.options;
          const data = this.data;
          const colorMode = options.colorMode || 'ordinal';
          const wordsConfig = {
              getText: simpleField(options.text),
              getFontSize: simpleField(options.fontSize),
              fontSizeRange: options.fontSizeRange,
              colorMode: colorMode,
              getColor: options.colorField ? simpleField(options.colorField) : simpleField(options.text),
              getFillingColor: simpleField(options.fillingColorField),
              colorList: options.colorList ||
                  (colorMode === 'ordinal' ? ['#2E62F1'] : ['#537EF5', '#2E62F1', '#2358D8', '#184FBF', '#0C45A6', '#013B8E']),
              getColorHex: simpleField(options.colorHexField),
              getFontFamily: simpleField(options.fontFamily || 'sans-serif'),
              rotateList: options.rotateList || [0],
              getPadding: simpleField(options.padding || 1),
              getFontStyle: simpleField(options.fontStyle || 'normal'),
              getFontWeight: simpleField(options.fontWeight || 'normal'),
              getFontOpacity: options.fontOpacity ? simpleField(options.fontOpacity) : () => 1
          };
          initFontSizeScale(data, wordsConfig, segmentationOutput);
          const layoutConfig = {
              size: options.size,
              ratio: options.ratio || 0.8,
              shapeUrl: options.shape,
              random: typeof options.random === 'undefined' ? true : options.random,
              textLayoutTimes: (_a = options.textLayoutTimes) !== null && _a !== void 0 ? _a : 3,
              removeWhiteBorder: options.removeWhiteBorder,
              layoutMode: (_b = options.layoutMode) !== null && _b !== void 0 ? _b : 'default',
              fontSizeShrinkFactor: (_c = options.fontSizeShrinkFactor) !== null && _c !== void 0 ? _c : 0.8,
              stepFactor: (_d = options.stepFactor) !== null && _d !== void 0 ? _d : 1,
              importantWordCount: (_e = options.importantWordCount) !== null && _e !== void 0 ? _e : 10,
              globalShinkLimit: options.globalShinkLimit || 0.2,
              fontSizeEnlargeFactor: (_f = options.fontSizeEnlargeFactor) !== null && _f !== void 0 ? _f : 1.5,
              fillingRatio: (_g = options.fillingRatio) !== null && _g !== void 0 ? _g : 0.7,
              fillingTimes: (_h = options.fillingTimes) !== null && _h !== void 0 ? _h : 4,
              fillingXStep: options.fillingXRatioStep
                  ? Math.max(Math.floor(options.size[0] * options.fillingXRatioStep), 1)
                  : (_j = options.fillingXStep) !== null && _j !== void 0 ? _j : 4,
              fillingYStep: options.fillingYRatioStep
                  ? Math.max(Math.floor(options.size[1] * options.fillingYRatioStep), 1)
                  : (_k = options.fillingYStep) !== null && _k !== void 0 ? _k : 4,
              fillingInitialFontSize: options.fillingInitialFontSize,
              fillingDeltaFontSize: options.fillingDeltaFontSize,
              fillingInitialOpacity: (_l = options.fillingInitialOpacity) !== null && _l !== void 0 ? _l : 0.8,
              fillingDeltaOpacity: (_m = options.fillingDeltaOpacity) !== null && _m !== void 0 ? _m : 0.05,
              getFillingFontFamily: simpleField(options.fillingFontFamily || 'sans-serif'),
              getFillingFontStyle: simpleField(options.fillingFontStyle || 'normal'),
              getFillingFontWeight: simpleField(options.fillingFontWeight || 'normal'),
              getFillingPadding: simpleField((_o = options.fillingPadding) !== null && _o !== void 0 ? _o : 0.4),
              fillingRotateList: (_p = options.fillingRotateList) !== null && _p !== void 0 ? _p : [0, 90],
              fillingDeltaFontSizeFactor: (_q = options.fillingDeltaFontSizeFactor) !== null && _q !== void 0 ? _q : 0.2,
              fillingColorList: options.fillingColorList || ['#537EF5'],
              sameColorList: false,
              minInitFontSize: (_r = options.minInitFontSize) !== null && _r !== void 0 ? _r : 10,
              minFontSize: (_s = options.minFontSize) !== null && _s !== void 0 ? _s : 4,
              minFillFontSize: (_t = options.minFillFontSize) !== null && _t !== void 0 ? _t : 2
          };
          const sameColorList = colorListEqual(wordsConfig.colorList, layoutConfig.fillingColorList);
          layoutConfig.sameColorList = sameColorList;
          initColorScale(data, wordsConfig, layoutConfig, options);
          initFillingWordsFontSize(data, wordsConfig, layoutConfig, segmentationOutput);
          const { getText, getFontFamily, getFontStyle, getFontWeight, getPadding, getColor, getFillingColor, getColorHex, fontSizeScale, colorScale, fillingColorScale, getFontOpacity, rotateList } = wordsConfig;
          const words = data.map(datum => {
              var _a, _b;
              return {
                  x: 0,
                  y: 0,
                  weight: 0,
                  text: getText(datum),
                  fontFamily: getFontFamily(datum),
                  fontWeight: getFontWeight(datum),
                  fontStyle: getFontStyle(datum),
                  rotate: rotateList[~~(segmentationInput.randomGenerator() * rotateList.length)],
                  fontSize: Math.max(layoutConfig.minInitFontSize, ~~fontSizeScale(datum)),
                  opacity: getFontOpacity(datum),
                  padding: getPadding(datum),
                  color: (getColorHex && getColorHex(datum)) || (colorScale && colorScale(getColor(datum))) || 'black',
                  fillingColor: getFillingColor && (((_a = options.colorField) === null || _a === void 0 ? void 0 : _a.field) !== ((_b = options.fillingColorField) === null || _b === void 0 ? void 0 : _b.field) || !sameColorList)
                      ? (getColorHex && getColorHex(datum)) ||
                          (fillingColorScale && fillingColorScale(getFillingColor(datum))) ||
                          'black'
                      : undefined,
                  datum: datum,
                  visible: true,
                  hasPlaced: false
              };
          });
          const wordsMaxFontSize = maxInArray(words.map(word => word.fontSize));
          words.forEach(word => (word.weight = word.fontSize / wordsMaxFontSize));
          words.sort((a, b) => b.weight - a.weight);
          const { fillingWords, successedWords, failedWords } = cloud(words, layoutConfig, segmentationOutput);
          const textKey = (_v = (_u = options.text) === null || _u === void 0 ? void 0 : _u.field) !== null && _v !== void 0 ? _v : 'textKey';
          const dataIndexKey = (_w = options.dataIndexKey) !== null && _w !== void 0 ? _w : 'defaultDataIndexKey';
          const as = options.as ? Object.assign(Object.assign({}, OUTPUT), options.as) : OUTPUT;
          let w;
          let t;
          const modKeywords = [];
          for (let i = 0; i < words.length; ++i) {
              w = words[i];
              t = w.datum;
              t[as.x] = w.x;
              t[as.y] = w.y;
              t[as.fontFamily] = w.fontFamily;
              t[as.fontSize] = w.fontSize;
              t[as.fontStyle] = w.fontStyle;
              t[as.fontWeight] = w.fontWeight;
              t[as.angle] = degreeToRadian(w.rotate);
              t[as.opacity] = w.opacity;
              t[as.visible] = w.visible;
              t[as.isFillingWord] = false;
              t[as.color] = w.color;
              t[dataIndexKey] = `${w.text}_${i}_keyword`;
              modKeywords.push(t);
          }
          const fillingWordsData = [];
          fillingWords.forEach((word, index) => {
              var _a, _b;
              const t = Object.assign({}, word.datum);
              t[as.x] = word.x;
              t[as.y] = word.y;
              t[as.fontFamily] = word.fontFamily;
              t[as.fontSize] = word.fontSize;
              t[as.fontStyle] = word.fontStyle;
              t[as.fontWeight] = word.fontWeight;
              t[as.angle] = degreeToRadian(word.rotate);
              t[as.opacity] = word.opacity;
              t[as.visible] = word.visible;
              t[as.isFillingWord] = true;
              t[as.color] = !getFillingColor
                  ? layoutConfig.fillingColorList[~~(segmentationInput.randomGenerator() * layoutConfig.fillingColorList.length)]
                  : ((_a = options.colorField) === null || _a === void 0 ? void 0 : _a.field) !== ((_b = options.fillingColorField) === null || _b === void 0 ? void 0 : _b.field) || !sameColorList
                      ? word.fillingColor
                      : word.color;
              t[textKey] = word.text;
              t[dataIndexKey] = `${word.text}_${index}_fillingWords`;
              fillingWordsData.push(t);
          });
          if (this.options.onLayoutFinished) {
              this.options.onLayoutFinished({ successedWords, failedWords });
          }
          this.progressiveResult = modKeywords.concat(fillingWordsData);
      }
      release() {
          this.segmentationInput = null;
          this.data = null;
          this.progressiveResult = null;
          this.options = null;
      }
  };
  const initColorScale = (data, wordsConfig, layoutConfig, options) => {
      var _a, _b, _c, _d;
      const { colorMode, getColor, getFillingColor } = wordsConfig;
      const { sameColorList } = layoutConfig;
      let colorScale;
      let colorList = wordsConfig.colorList;
      let fillingColorScale;
      let fillingColorList = layoutConfig.fillingColorList;
      if (colorMode === 'ordinal') {
          const uniqueColorField = data.map(word => getColor(word));
          colorScale = (datum) => {
              return new OrdinalScale().domain(uniqueColorField).range(colorList).scale(datum);
          };
          if (getFillingColor && (((_a = options.colorField) === null || _a === void 0 ? void 0 : _a.field) !== ((_b = options.fillingColorField) === null || _b === void 0 ? void 0 : _b.field) || !sameColorList)) {
              const uniquefillingColorField = data.map(datum => getFillingColor(datum));
              fillingColorScale = (datum) => {
                  return new OrdinalScale().domain(uniquefillingColorField).range(fillingColorList).scale(datum);
              };
          }
      }
      else {
          if (colorList.length === 1) {
              colorList = [colorList[0], colorList[0]];
          }
          const valueScale = new LinearScale().domain(extent(getColor, data)).range(colorList);
          colorScale = (i) => {
              return valueScale.scale(i);
          };
          if (getFillingColor && (((_c = options.colorField) === null || _c === void 0 ? void 0 : _c.field) !== ((_d = options.fillingColorField) === null || _d === void 0 ? void 0 : _d.field) || !sameColorList)) {
              if (fillingColorList.length === 1) {
                  fillingColorList = [fillingColorList[0], fillingColorList[0]];
              }
              const fillingValueScale = new LinearScale().domain(extent(getFillingColor, data)).range(fillingColorList);
              fillingColorScale = (i) => {
                  return fillingValueScale.scale(i);
              };
          }
      }
      Object.assign(wordsConfig, { colorScale, fillingColorScale });
  };
  const initFontSizeScale = (data, wordsConfig, segmentationOutput) => {
      let { fontSizeRange: range } = wordsConfig;
      const { getFontSize, getText } = wordsConfig;
      let fontSizeScale;
      if (!getFontSize) {
          const words = data.map(word => ({
              text: getText(word)
          }));
          const x = getInitialFontSize(words, segmentationOutput, false);
          fontSizeScale = functor(x);
      }
      else if (getFontSize && range) {
          const sizeScale = new SqrtScale().domain(extent(getFontSize, data)).range(range);
          fontSizeScale = (datum) => {
              return sizeScale.scale(getFontSize(datum));
          };
      }
      else if (getFontSize && isFunction$1(getFontSize) && !range) {
          const a = 0.5;
          const [min, max] = extent(getFontSize, data);
          const words = data.map(datum => ({
              text: getText(datum),
              value: getFontSize(datum),
              weight: max === min ? 1 : (getFontSize(datum) - min) / (max - min)
          }));
          const x = getInitialFontSize(words, segmentationOutput, true);
          range = [~~(a * x), ~~x];
          const sizeScale = new SqrtScale().domain(extent(getFontSize, data)).range(range);
          fontSizeScale = (datum) => {
              return sizeScale.scale(getFontSize(datum));
          };
      }
      Object.assign(wordsConfig, { getFontSize, fontSizeRange: range, fontSizeScale });
  };
  const getInitialFontSize = (words, segmentationOutput, weight) => {
      const a = 0.5;
      const b = 1.7;
      const shapeArea = segmentationOutput.shapeArea;
      const ratio = segmentationOutput.ratio;
      const regions = segmentationOutput.segmentation.regions;
      const shapeSizeLimitTextLength = Math.ceil(Math.sqrt(shapeArea) / 12);
      const wordArea = words.reduce((acc, word) => {
          const textLength = calTextLength(word.text);
          return textLength < shapeSizeLimitTextLength
              ? acc + textLength * (weight ? (a + (1 - a) * word.weight) ** 2 : 1)
              : acc;
      }, 0);
      if (wordArea === 0) {
          return 12;
      }
      let x = 20;
      if (regions.length === 1) {
          x = Math.sqrt(ratio * (shapeArea / (wordArea * b)));
      }
      else {
          const xArr = [];
          for (let i = 0; i < regions.length; i++) {
              const regionArea = regions[i].area;
              const regionAspect = regions[i].ratio;
              const regionRatio = regionArea / shapeArea;
              if (regionRatio < 0.1) {
                  continue;
              }
              const regionWordArea = regionRatio * (wordArea * (regionAspect < 1 ? 2.7 - regionAspect : b));
              const x = Math.sqrt(ratio * (regionArea / regionWordArea));
              xArr.push(x);
          }
          if (xArr.length) {
              x = Math.min(...xArr);
          }
          else {
              x = Math.sqrt(ratio * (shapeArea / (wordArea * b)));
          }
      }
      return x;
  };
  function initFillingWordsFontSize(data, wordsConfig, layoutConfig, segmentationOutput) {
      const { getText } = wordsConfig;
      let { fillingInitialFontSize, fillingDeltaFontSize } = layoutConfig;
      const { fillingRatio } = layoutConfig;
      const shapeSizeLimitTextLength = Math.ceil(Math.sqrt(segmentationOutput.shapeArea) / 4);
      if (!fillingInitialFontSize || !fillingDeltaFontSize) {
          const a = fillingRatio / 100;
          const averageLength = data.reduce((acc, word) => {
              const length = calTextLength(getText(word));
              if (length > shapeSizeLimitTextLength) {
                  return acc;
              }
              return acc + length;
          }, 0) / data.length;
          let fontSize;
          if (averageLength === 0) {
              fontSize = 8;
          }
          else {
              const area = segmentationOutput.shapeArea * 0.2;
              fontSize = Math.sqrt(a * (area / averageLength));
          }
          fillingInitialFontSize = ~~fontSize;
          fillingDeltaFontSize = fontSize * layoutConfig.fillingDeltaFontSizeFactor;
          Object.assign(layoutConfig, {
              fillingInitialFontSize,
              fillingDeltaFontSize
          });
      }
  }
  const extent = (field, data) => {
      let min = +Infinity;
      let max = -Infinity;
      const n = data.length;
      let v;
      for (let i = 0; i < n; ++i) {
          v = toNumber(field(data[i]));
          if (v < min) {
              min = v;
          }
          if (v > max) {
              max = v;
          }
      }
      if (data.length === 1 && min === max) {
          min -= 10000;
      }
      return [min, max];
  };

  const transform$1 = (options, upstreamData, parameters) => {
      if (!options.size ||
          isNil$1(options.size[0]) ||
          isNil$1(options.size[1]) ||
          options.size[0] <= 0 ||
          options.size[1] <= 0) {
          const logger = Logger.getInstance();
          logger.info('Wordcloud size dimensions must be greater than 0');
          return [];
      }
      options.size = [Math.ceil(options.size[0]), Math.ceil(options.size[1])];
      if (!options.shape) {
          Logger.getInstance().error('WordcloudShape shape must be specified.');
      }
      if (!options.text) {
          Logger.getInstance().error('WordcloudShape text must be specified.');
      }
      if (options.onBeforeLayout) {
          options.onBeforeLayout();
      }
      if (!upstreamData || upstreamData.length === 0) {
          return [];
      }
      const layout = new Layout$1(options);
      layout.layout(upstreamData);
      if (layout.unfinished()) {
          return {
              progressive: layout
          };
      }
      return layout.output();
  };

  var IMAGECLOUD_HOOK_EVENT;
  (function (IMAGECLOUD_HOOK_EVENT) {
      IMAGECLOUD_HOOK_EVENT["BEFORE_IMAGECLOUD_LAYOUT"] = "beforeImagecloudLayout";
      IMAGECLOUD_HOOK_EVENT["AFTER_IMAGECLOUD_LAYOUT"] = "afterImagecloudLayout";
      IMAGECLOUD_HOOK_EVENT["AFTER_IMAGECLOUD_DRAW"] = "afterImagecloudDraw";
  })(IMAGECLOUD_HOOK_EVENT || (IMAGECLOUD_HOOK_EVENT = {}));
  function setSize(image, longSideLength) {
      if (image.aspectRatio > 1) {
          image.width = longSideLength;
          image.height = ~~(longSideLength / image.aspectRatio);
      }
      else {
          image.height = longSideLength;
          image.width = ~~(longSideLength * image.aspectRatio);
      }
  }
  function setSizeByShortSide(image, shortSideLength) {
      if (image.aspectRatio > 1) {
          image.height = shortSideLength;
          image.width = ~~(shortSideLength * image.aspectRatio);
      }
      else {
          image.width = shortSideLength;
          image.height = ~~(shortSideLength / image.aspectRatio);
      }
  }

  class Layout {
      constructor(options) {
          this.progressiveResult = [];
          this.imageCollageList = [];
          this.options = options;
      }
      preProcess() {
          const { imageConfig = {}, weight } = this.options;
          const { padding = 0 } = imageConfig;
          let images = this.imageCollageList;
          images.forEach((img, index) => {
              if (img.valid === false) {
                  img.x = -10;
                  img.y = -10;
                  img.width = 0;
                  img.height = 0;
                  img.opacity = 0;
              }
              else {
                  img.padding = padding;
                  img.weight = simpleField(weight)(this.data[index]);
                  img.datum = this.data[index];
              }
          });
          images = images.filter(img => img.valid !== false).sort((a, b) => b.weight - a.weight);
          return images;
      }
      onImageCollageInputReady(images) {
          images.forEach((img, i) => {
              if (img.status === 'fulfilled') {
                  const imageElement = img.value;
                  const { width, height } = imageElement;
                  this.imageCollageList.push(Object.assign({}, this.data[i], { aspectRatio: width / height }));
              }
              else {
                  this.imageCollageList.push(Object.assign({}, this.data[i], { valid: false }));
              }
          });
      }
      layout(data) {
          this.data = data;
          this.loadSegmentationInput();
          this.loadImageCollageInput();
      }
      loadSegmentationInput() {
          var _a, _b, _c, _d, _e, _f;
          const options = this.options;
          const size = options.size;
          const segmentationInput = {
              shapeUrl: (_a = options.mask) !== null && _a !== void 0 ? _a : { type: 'geometric', shape: 'rect' },
              size: size,
              ratio: options.ratio || 0.8,
              tempCanvas: undefined,
              boardSize: [0, 0],
              random: false,
              randomGenerator: undefined,
              blur: (_b = options.maskConfig) === null || _b === void 0 ? void 0 : _b.edgeBlur
          };
          const tempCanvas = this.options.createCanvas({ width: size[0], height: size[1] });
          const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
          tempCtx.textAlign = 'center';
          tempCtx.textBaseline = 'middle';
          segmentationInput.tempCanvas = tempCanvas;
          const boardW = ((size[0] + 31) >> 5) << 5;
          segmentationInput.boardSize = [boardW, size[1]];
          if (segmentationInput.random) {
              segmentationInput.randomGenerator = Math.random;
          }
          else {
              segmentationInput.randomGenerator = fakeRandom();
          }
          this.segmentationInput = segmentationInput;
          if (isString$1(segmentationInput.shapeUrl)) {
              segmentationInput.isEmptyPixel = generateIsEmptyPixel(undefined, {
                  threshold: (_d = (_c = options.maskConfig) === null || _c === void 0 ? void 0 : _c.threshold) !== null && _d !== void 0 ? _d : 200,
                  invert: (_e = options.maskConfig) === null || _e === void 0 ? void 0 : _e.invert
              }, this.options.createCanvas);
              const imagePromise = loadImage(segmentationInput.shapeUrl, this.options.createImage);
              if (imagePromise) {
                  this.isMaskImageFinished = false;
                  this.isLayoutFinished = false;
                  imagePromise
                      .then(shapeImage => {
                      var _a, _b;
                      this.isMaskImageFinished = true;
                      const size = options.size;
                      const maskCanvas = this.options.createCanvas({
                          width: size[0],
                          height: size[1],
                          dpr: 1
                      });
                      segmentationInput.maskCanvas = maskCanvas;
                      const ctx = maskCanvas.getContext('2d');
                      if ((_a = options.maskConfig) === null || _a === void 0 ? void 0 : _a.removeWhiteBorder) {
                          removeBorder(shapeImage, maskCanvas, segmentationInput.isEmptyPixel);
                      }
                      const shapeConfig = scaleAndMiddleShape(shapeImage, size);
                      ctx.clearRect(0, 0, size[0], size[1]);
                      ctx.drawImage(shapeImage, shapeConfig.x, shapeConfig.y, shapeConfig.width, shapeConfig.height);
                      this.segmentationOutput = segmentation(this.segmentationInput);
                      let transparentMaskCanvas;
                      if (((_b = this.options.layoutConfig) === null || _b === void 0 ? void 0 : _b.placement) === 'masked') {
                          transparentMaskCanvas = this.generateTransparentMaskCanvas(shapeImage, size);
                      }
                      this.segmentationOutput.transparentMaskCanvas = transparentMaskCanvas;
                      if (this.options.onUpdateMaskCanvas) {
                          this.options.onUpdateMaskCanvas(maskCanvas, transparentMaskCanvas);
                      }
                  })
                      .catch(error => {
                      this.isMaskImageFinished = true;
                  });
              }
              else {
                  this.isMaskImageFinished = true;
                  this.isLayoutFinished = true;
              }
          }
          else if (segmentationInput.shapeUrl &&
              (segmentationInput.shapeUrl.type === 'text' || segmentationInput.shapeUrl.type === 'geometric')) {
              segmentationInput.isEmptyPixel = generateIsEmptyPixel(segmentationInput.shapeUrl.backgroundColor, undefined, this.options.createCanvas);
              if (segmentationInput.shapeUrl.type === 'text' || segmentationInput.shapeUrl.type === 'geometric') {
                  if (!segmentationInput.shapeUrl.backgroundColor) {
                      segmentationInput.shapeUrl.backgroundColor = 'rgba(255,255,255,255)';
                  }
              }
              const maskCanvas = generateMaskCanvas(segmentationInput.shapeUrl, size[0], size[1], undefined, (_f = options.maskConfig) === null || _f === void 0 ? void 0 : _f.invert, this.options.createCanvas);
              segmentationInput.maskCanvas = maskCanvas;
              this.segmentationOutput = segmentation(this.segmentationInput);
              if (this.options.onUpdateMaskCanvas) {
                  this.options.onUpdateMaskCanvas(maskCanvas, maskCanvas);
              }
              this.isMaskImageFinished = true;
          }
      }
      loadImageCollageInput() {
          const data = this.data;
          const imagesPromise = loadImages(data.map(d => simpleField(this.options.image)(d)), this.options.createImage);
          if (imagesPromise) {
              imagesPromise
                  .then((images) => {
                  this.onImageCollageInputReady(images);
                  this.isImagesFinished = true;
              })
                  .catch(error => {
                  this.isImagesFinished = true;
                  this.isLayoutFinished = true;
                  Logger.getInstance().error('image load failed', error);
              });
          }
          else {
              this.isImagesFinished = true;
              this.isLayoutFinished = true;
          }
      }
      canAnimate() {
          return true;
      }
      unfinished() {
          return !this.isLayoutFinished;
      }
      output() {
          return this.progressiveResult;
      }
      progressiveRun() {
          if (this.isImagesFinished && this.isMaskImageFinished && !this.isLayoutFinished) {
              const images = this.preProcess();
              const layoutResult = this.doLayout(images);
              if (this.options && this.options.onLayoutEnd) {
                  this.options.onLayoutEnd(layoutResult);
              }
              this.progressiveResult = this.processOutput(layoutResult);
              this.isLayoutFinished = true;
          }
          else {
              return;
          }
      }
      progressiveOutput() {
          return this.progressiveResult;
      }
      release() {
          this.segmentationInput = null;
          this.data = null;
          this.progressiveResult = null;
          this.options = null;
      }
      calculateImageSize(images, imageConfig = {}, ratio = 0.45) {
          const { imageSizeRange, padding = 0 } = imageConfig;
          const imageSize = isNumber$1(imageConfig.imageSize) ? imageConfig.imageSize : field$1(imageConfig.imageSize);
          const size = this.options.size;
          if (!imageSize && !imageSizeRange) {
              const imageArea = images.reduce((prev, pic) => {
                  const r = pic.aspectRatio;
                  return prev + (r > 1 ? 1 / r : r);
              }, 0);
              let longSideLength = ~~Math.sqrt((ratio * size[0] * size[1]) / imageArea);
              longSideLength = longSideLength - 2 * padding < 0 ? 1 : longSideLength - 2 * padding;
              images.forEach(img => setSize(img, longSideLength));
          }
          else if (imageSize && !isFunction$1(imageSize)) {
              images.forEach(img => setSize(img, imageSize));
          }
          else if (imageSizeRange) {
              const sizeScale = new SqrtScale().domain(extent$2(images, d => d.weight)).range(imageSizeRange);
              images.forEach(img => setSize(img, ~~sizeScale.scale(img.weight)));
          }
          else if (imageSize && isFunction$1(imageSize) && !imageSizeRange) {
              const a = 0.5;
              const [min, max] = extent$2(images, d => d.weight);
              const picArea = images.reduce((prev, img) => {
                  const r = img.aspectRatio;
                  const w = (img.weight - min) / (max - min);
                  return prev + (r > 1 ? 1 / r : r) * (a + (1 - a) * w) ** 2;
              }, 0);
              const x = ~~Math.sqrt((ratio * size[0] * size[1]) / picArea);
              const range = [
                  ~~(a * x) - padding * 2 < 0 ? 1 : ~~(a * x) - padding * 2,
                  ~~x - padding * 2 < 0 ? 1 : ~~x - padding * 2
              ];
              const sizeScale = new SqrtScale().domain(extent$2(images, d => d.weight)).range(range);
              images.forEach(img => setSize(img, ~~sizeScale.scale(img.weight)));
          }
          else {
              console.warn('image cloud imageSize error');
          }
          return images;
      }
      generateTransparentMaskCanvas(shapeImage, size) {
          var _a;
          const transparentMaskCanvas = this.options.createCanvas({
              width: size[0],
              height: size[1],
              dpr: 1
          });
          const transparentMaskContext = transparentMaskCanvas.getContext('2d');
          this.segmentationOutput.transparentMaskCanvas = transparentMaskCanvas;
          if ((_a = this.options.maskConfig) === null || _a === void 0 ? void 0 : _a.removeWhiteBorder) {
              removeBorder(shapeImage, transparentMaskCanvas, this.segmentationInput.isEmptyPixel);
          }
          const imageData = transparentMaskContext.createImageData(size[0], size[1]);
          const labels = this.segmentationOutput.segmentation.labels;
          for (let i = 0; i < labels.length; i++) {
              const color = labels[i] === 0 ? 255 : 0;
              const alpha = labels[i] * 255;
              const pixelIndex = i * 4;
              imageData.data[pixelIndex] = color;
              imageData.data[pixelIndex + 1] = color;
              imageData.data[pixelIndex + 2] = color;
              imageData.data[pixelIndex + 3] = alpha;
          }
          transparentMaskContext.clearRect(0, 0, size[0], size[1]);
          transparentMaskContext.fillStyle = `rgba(255,255,255,0)`;
          transparentMaskContext.fillRect(0, 0, size[0], size[1]);
          transparentMaskContext.putImageData(imageData, 0, 0);
          return transparentMaskCanvas;
      }
      processOutput(images) {
          var _a;
          const outputAs = (_a = this.options) === null || _a === void 0 ? void 0 : _a.as;
          if (outputAs) {
              Object.keys(outputAs).forEach(key => {
                  images.forEach(img => {
                      img[outputAs[key]] = img[key];
                      delete img[key];
                  });
              });
          }
          return images;
      }
  }

  class SpiralLayout extends Layout {
      preProcess() {
          const images = super.preProcess();
          const { imageConfig = {}, ratio = 0.45 } = this.options;
          return this.calculateImageSize(images, imageConfig, ratio);
      }
      tryPlaceImage(image, size, spiralType, segmentationOutput, fixedImages, dt = 1) {
          const [width, height] = size;
          const centerX = width / 2;
          const centerY = height / 2;
          const maxR = Math.sqrt(centerX ** 2 + centerY ** 2);
          const spiral = spirals[spiralType](size);
          let t = -dt;
          let dx;
          let dy;
          const { segmentation } = segmentationOutput;
          const { labels } = segmentation;
          while (([dx, dy] = spiral((t += dt)))) {
              if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxR) {
                  break;
              }
              dx -= image.width / 2;
              dy -= image.height / 2;
              image.visible = true;
              image.x = ~~(centerX + dx);
              image.y = ~~(centerY + dy);
              image._left = image.x + image.padding;
              image._top = image.y + image.padding;
              image._leftWithoutPadding = image.x;
              image._topWithoutPadding = image.y;
              if (fit(image, fixedImages)) {
                  const { x, y, width: imageWidth, height: imageHeight } = image;
                  let intersect = false;
                  for (let r = 0; r < imageWidth; r++) {
                      for (let c = 0; c < imageHeight && y + r <= height; c++) {
                          if (x + c > width) {
                              continue;
                          }
                          const token = !!labels[(y + r) * width + (x + c)];
                          if (!token) {
                              intersect = true;
                              break;
                          }
                      }
                      if (intersect) {
                          break;
                      }
                  }
                  if (!intersect) {
                      const corners = [
                          { x: image.x, y: image.y },
                          { x: image.x + image.width, y: image.y },
                          { x: image.x, y: image.y + image.height },
                          { x: image.x + image.width, y: image.y + image.height }
                      ];
                      let allCornersInShape = true;
                      for (const corner of corners) {
                          if (!labels[corner.y * width + corner.x]) {
                              allCornersInShape = false;
                              break;
                          }
                      }
                      if (!allCornersInShape) {
                          continue;
                      }
                      return true;
                  }
              }
          }
          return false;
      }
      doLayout(images) {
          var _a;
          const { segmentationOutput } = this;
          const { layoutConfig = {} } = this.options;
          const size = this.options.size;
          const { spiralType = 'archimedean', fillingTimes = 4, minFillingImageSize = 10 } = layoutConfig;
          const fixedImages = [];
          const key = Object.keys(images[0]).find(k => k.includes('VGRAMMAR'));
          for (const image of images) {
              image._widthWithPadding = image.width + image.padding * 2;
              image._heightWithPadding = image.height + image.padding * 2;
              image.frequency = 1;
              if (this.tryPlaceImage(image, size, spiralType, segmentationOutput, fixedImages)) {
                  fixedImages.push(image);
              }
          }
          const fillingSizeFactor = 0.5;
          const fillingSizeDelta = 1;
          const minImageWidth = minInArray(fixedImages, (a, b) => a.width - b.width).width;
          const minImageHeight = minInArray(fixedImages, (a, b) => a.height - b.height).height;
          const fixedFillingImages = [];
          for (let i = 0; i < fillingTimes; i++) {
              const minWidth = minImageWidth * fillingSizeFactor - fillingSizeDelta * i;
              const minHeight = minImageHeight * fillingSizeFactor - fillingSizeDelta * i;
              for (const image of images) {
                  const fillingImage = Object.assign({}, image, { visible: true });
                  const imageSize = Math.max(minFillingImageSize, fillingImage.aspectRatio > 1 ? minWidth : minHeight);
                  setSize(fillingImage, imageSize);
                  fillingImage._widthWithPadding = fillingImage.width + fillingImage.padding * 2;
                  fillingImage._heightWithPadding = fillingImage.height + fillingImage.padding * 2;
                  if (this.tryPlaceImage(fillingImage, size, spiralType, segmentationOutput, [...fixedFillingImages, ...fixedImages], 0.5)) {
                      image._tempFrequency = ((_a = image._tempFrequency) !== null && _a !== void 0 ? _a : image.frequency) + 1;
                      fillingImage.frequency = image._tempFrequency;
                      fillingImage.distance = Math.sqrt(Math.pow(fillingImage.x - size[0] / 2, 2) + Math.pow(fillingImage.y - size[1] / 2, 2));
                      fillingImage[key] = `${fillingImage[key]}_${fillingImage.frequency}`;
                      fixedFillingImages.push(fillingImage);
                  }
              }
          }
          return [...fixedImages, ...fixedFillingImages].filter(image => image.visible);
      }
  }
  function fit(image, fixedImages) {
      for (let i = 0; i < fixedImages.length; i++) {
          if (isOverlap(image, fixedImages[i])) {
              return false;
          }
      }
      return true;
  }
  function isOverlap(a, b) {
      if (a._leftWithoutPadding + a._widthWithPadding < b._leftWithoutPadding ||
          a._topWithoutPadding + a._heightWithPadding < b._topWithoutPadding ||
          a._leftWithoutPadding > b._leftWithoutPadding + b._widthWithPadding ||
          a._topWithoutPadding > b._topWithoutPadding + b._heightWithPadding) {
          return false;
      }
      return true;
  }

  function rectGridLayout(options) {
      const { imageConfig = {}, size, ratio = 0.1, layoutConfig = {} } = options;
      const { padding = 0, imageSize } = imageConfig;
      const [width, height] = size;
      let shortSideLength;
      if (imageSize) {
          shortSideLength = imageSize;
      }
      else {
          shortSideLength = Math.min(width, height) * ratio - padding * 2;
      }
      if (shortSideLength < 0) {
          shortSideLength = 1;
      }
      const { rectAspectRatio = 1 } = layoutConfig;
      let cellWidth;
      let cellHeight;
      if (rectAspectRatio > 1) {
          cellWidth = shortSideLength;
          cellHeight = shortSideLength / rectAspectRatio;
      }
      else {
          cellHeight = shortSideLength;
          cellWidth = shortSideLength * rectAspectRatio;
      }
      const rows = Math.ceil(height / (cellHeight + padding));
      const cols = Math.ceil(width / (cellWidth + padding));
      const cellCounts = cols * rows;
      const center = { x: width / 2, y: height / 2 };
      const cellInfo = new Array(cellCounts);
      for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
              const cellCenterX = c * (cellWidth + padding) + cellWidth / 2;
              const cellCenterY = r * (cellHeight + padding) + cellHeight / 2;
              cellInfo[r * cols + c] = {
                  centerX: cellCenterX,
                  centerY: cellCenterY,
                  x: cellCenterX - cellWidth / 2,
                  y: cellCenterY - cellHeight / 2,
                  row: r,
                  col: c,
                  distance: Math.sqrt(Math.pow(cellCenterX - center.x, 2) + Math.pow(cellCenterY - center.y, 2))
              };
          }
      }
      const context = Object.assign({}, layoutConfig, {
          cellWidth,
          cellHeight,
          cellInfo,
          cellCount: cellInfo.length,
          cellType: 'rect',
          cellPixelCount: cellWidth * cellHeight,
          eachPixel: (cell, callback) => {
              const { x, y } = cell;
              for (let r = 0; r < cellWidth; r++) {
                  for (let c = 0; c < cellHeight && y + r <= height; c++) {
                      if (x + c > width) {
                          continue;
                      }
                      callback((~~y + r) * width + (~~x + c));
                  }
              }
          },
          clipPath: `M${-cellWidth / 2} ${-cellHeight / 2} L${cellWidth / 2} ${-cellHeight / 2} L${cellWidth / 2} ${cellHeight / 2} L${-cellWidth / 2} ${cellHeight / 2} Z`
      });
      return { context, imageLength: shortSideLength };
  }

  function circleGridLayout(options) {
      const { imageConfig = {}, size, ratio = 0.1, layoutConfig = {} } = options;
      const { padding = 0, imageSize = 0 } = imageConfig;
      const [width, height] = size;
      const center = { x: width / 2, y: height / 2 };
      let circleRadius = 0;
      if (imageSize) {
          circleRadius = imageSize / 2;
      }
      else {
          circleRadius = (Math.min(width, height) * ratio) / 2;
      }
      if (circleRadius - padding <= 0) {
          circleRadius = padding + 1;
      }
      const circleDiameter = circleRadius * 2;
      const rowHeight = (Math.sqrt(3) / 2) * circleDiameter + padding;
      const cellInfo = [];
      let index = 0;
      for (let r = 0; r * rowHeight - circleRadius < height; r++) {
          const y = r * rowHeight;
          const offsetX = r % 2 === 0 ? 0 : circleRadius;
          for (let c = -1; c * (circleDiameter + padding) + offsetX - circleRadius < width; c++) {
              const x = c * (circleDiameter + padding) + offsetX + circleRadius;
              cellInfo[index++] = {
                  centerX: x,
                  centerY: y,
                  x: x - circleRadius,
                  y: y - circleRadius,
                  row: r,
                  col: c,
                  distance: Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2))
              };
          }
      }
      let cellPixelCount = 0;
      const rSquared = circleRadius * circleRadius;
      for (let r = 0; r < circleDiameter; r++) {
          for (let c = 0; c < circleDiameter; c++) {
              const dx = r - circleRadius;
              const dy = c - circleRadius;
              if (dx * dx + dy * dy <= rSquared) {
                  cellPixelCount++;
              }
          }
      }
      const context = Object.assign({}, layoutConfig, {
          cellWidth: circleDiameter,
          cellHeight: circleDiameter,
          cellInfo,
          cellCount: cellInfo.length,
          cellType: 'circle',
          cellPixelCount,
          eachPixel: (cell, callback) => {
              const { x, y } = cell;
              for (let r = 0; r < circleDiameter; r++) {
                  for (let c = 0; c < circleDiameter; c++) {
                      if (r + x < 0 || r + x > width || c + y > height || c + y < 0) {
                          continue;
                      }
                      const dx = r - circleRadius;
                      const dy = c - circleRadius;
                      if (dx * dx + dy * dy <= rSquared) {
                          callback((~~y + r) * width + (~~x + c));
                      }
                  }
              }
          },
          clipPath: `M 1 0 A 1 1 0 1 0 -1 0 A 1 1 0 1 0 1 0 Z`
      });
      return { context, imageLength: circleDiameter };
  }

  function hexagonalGridLayout(options) {
      const { imageConfig = {}, size, ratio = 0.1, layoutConfig = {} } = options;
      const { padding = 0, imageSize } = imageConfig;
      const [width, height] = size;
      const center = { x: width / 2, y: height / 2 };
      let radius;
      if (imageSize) {
          radius = imageSize / 2;
      }
      else {
          radius = (Math.min(width, height) * ratio) / 2;
      }
      if (radius - padding <= 0) {
          radius = padding + 1;
      }
      const points = [];
      const sides = 6;
      const step = (2 * Math.PI) / sides;
      for (let i = 0; i < sides; i++) {
          const angle = step * i;
          points.push({
              x: (radius - padding / 2) * Math.cos(angle),
              y: (radius - padding / 2) * Math.sin(angle)
          });
      }
      const diameter = radius * 2;
      const edgeLength = Math.sin(Math.PI / sides) * diameter;
      const cellHeight = Math.sqrt(3) * edgeLength;
      const gridSpaceX = diameter - edgeLength / 2;
      const gridSpaceY = Math.cos(Math.PI / sides) * diameter;
      const gridOffsetY = gridSpaceY / 2;
      const rows = Math.floor(height / cellHeight);
      const cols = Math.floor(width / edgeLength);
      const cellInfo = [];
      for (let r = -1; r <= rows + 1; r++) {
          for (let c = -1; c <= cols; c++) {
              const centerX = c * gridSpaceX;
              const centerY = r * gridSpaceY + (c % 2 ? gridOffsetY : 0);
              cellInfo.push({
                  centerX,
                  centerY,
                  x: centerX - edgeLength,
                  y: centerY - edgeLength,
                  row: r,
                  col: c,
                  distance: Math.sqrt(Math.pow(centerX - center.x, 2) + Math.pow(centerY - center.y, 2))
              });
          }
      }
      let cellPixelCount = 0;
      const pixelMap = [];
      for (let r = 0; r <= cellHeight; r++) {
          for (let c = 0; c <= edgeLength * 2; c++) {
              const px = c - edgeLength;
              const py = r - cellHeight / 2;
              const q2x = Math.abs(px);
              const q2y = Math.abs(py);
              const isInside = q2x <= edgeLength && q2y <= cellHeight / 2 && 2 * q2y + q2x * Math.sqrt(3) <= cellHeight;
              if (isInside) {
                  cellPixelCount++;
                  pixelMap.push(true);
              }
              else {
                  pixelMap.push(false);
              }
          }
      }
      const context = Object.assign({}, layoutConfig, {
          cellHexSideLength: edgeLength,
          cellHexPoints: points,
          cellHeight,
          cellWidth: edgeLength * 2,
          cellInfo,
          cellCount: cellInfo.length,
          cellType: 'hexagonal',
          cellPixelCount,
          eachPixel: (cell, callback) => {
              const { x, y } = cell;
              let index = 0;
              for (let r = 0; r <= cellHeight; r++) {
                  for (let c = 0; c <= edgeLength * 2; c++) {
                      if (pixelMap[index++]) {
                          callback((~~y + r) * width + (~~x + c));
                      }
                  }
              }
          },
          clipPath: `M 1 0 L 0.5 0.866 L -0.5 0.866 L -1 0 L -0.5 -0.866 L 0.5 -0.866 Z`
      });
      return { context, imageLength: diameter - padding };
  }

  const cellLayout = {
      rect: rectGridLayout,
      circle: circleGridLayout,
      hexagonal: hexagonalGridLayout
  };
  class GridLayout extends Layout {
      preProcess() {
          var _a;
          const images = super.preProcess();
          const { layoutConfig = {} } = this.options;
          const { cellType = 'rect' } = layoutConfig;
          const cellLayoutMethod = (_a = cellLayout[cellType]) !== null && _a !== void 0 ? _a : cellLayout.rect;
          const layoutResult = cellLayoutMethod(this.options);
          const { context, imageLength: shortSideLength } = layoutResult;
          images.forEach(img => setSizeByShortSide(img, shortSideLength));
          context.cellInfo.sort((cellA, cellB) => cellA.distance - cellB.distance);
          this.layoutContext = context;
          return images;
      }
      doLayout(images) {
          const { cellWidth, cellHeight, cellInfo, cellCount, clipPath, eachPixel, cellPixelCount } = this.layoutContext;
          if (images.length === 0 || cellCount === 0 || cellWidth === 0 || cellHeight === 0 || cellInfo.length === 0) {
              this.isLayoutFinished = true;
              return;
          }
          const { segmentationOutput } = this;
          const { layoutConfig = {} } = this.options;
          const { placement = 'default' } = layoutConfig;
          if (placement === 'edge' || placement === 'default') {
              const { segmentation } = segmentationOutput;
              const { labels } = segmentation;
              cellInfo.forEach(cell => {
                  let intersectPixelCount = 0;
                  eachPixel(cell, (index) => {
                      if (labels[index]) {
                          intersectPixelCount++;
                      }
                  });
                  cell.intersectPixels = intersectPixelCount;
              });
          }
          const imageCount = images.length;
          const imageVisible = (cell) => {
              const { intersectPixels } = cell;
              if (placement === 'default') {
                  return intersectPixels >= cellPixelCount * 0.45;
              }
              else if (placement === 'edge') {
                  return intersectPixels > cellPixelCount * 0.1 && intersectPixels < cellPixelCount;
              }
              return true;
          };
          for (let i = 0; i < imageCount; i++) {
              const image = images[i];
              const cell = cellInfo[i];
              if (cell) {
                  image.x = cell.centerX - image.width / 2;
                  image.y = cell.centerY - image.height / 2;
                  image.clipConfig = { shape: clipPath };
                  image.frequency = 1;
                  image.visible = imageVisible(cell);
                  image.cell = pickWithout(cell, ['image']);
                  image.distance = cell.distance;
                  cell.image = image;
              }
          }
          const key = Object.keys(images[0]).find(k => k.includes('VGRAMMAR'));
          if (imageCount < cellCount) {
              for (let i = imageCount; i < cellCount; i++) {
                  const image = images[i - imageCount];
                  const cell = cellInfo[i];
                  if (cell) {
                      const repeatImage = Object.assign({}, image);
                      repeatImage.x = cell.centerX - repeatImage.width / 2;
                      repeatImage.y = cell.centerY - repeatImage.height / 2;
                      repeatImage.frequency += 1;
                      repeatImage[key] = `${repeatImage[key]}_${repeatImage.frequency}`;
                      repeatImage.visible = imageVisible(cell);
                      repeatImage.distance = cell.distance;
                      repeatImage.cell = pickWithout(cell, ['image']);
                      cell.image = repeatImage;
                      images.push(repeatImage);
                  }
              }
          }
          return images.filter(img => img.visible);
      }
  }

  class StackLayout extends Layout {
      preProcess() {
          const images = super.preProcess();
          const { imageConfig = {}, ratio = 0.1 } = this.options;
          const cellLayoutMethod = rectGridLayout;
          this.layoutContext = cellLayoutMethod(Object.assign({}, this.options, { imageConfig: { imageSize: null } })).context;
          this.layoutContext.cellInfo.sort((cellA, cellB) => cellA.distance - cellB.distance);
          return this.calculateImageSize(images, imageConfig, ratio);
      }
      doLayout(images) {
          const { segmentationOutput } = this;
          const { cellWidth, cellHeight, cellInfo, cellCount, eachPixel, cellPixelCount } = this.layoutContext;
          if (images.length === 0 || cellCount === 0 || cellWidth === 0 || cellHeight === 0 || cellInfo.length === 0) {
              this.isLayoutFinished = true;
              return;
          }
          const { layoutConfig = {} } = this.options;
          const size = this.options.size;
          const { placement = 'default', maxAngle = 45 * (Math.PI / 180) } = layoutConfig;
          if (placement === 'edge' || placement === 'default') {
              const { segmentation } = segmentationOutput;
              const { labels } = segmentation;
              cellInfo.forEach(cell => {
                  let intersectPixelCount = 0;
                  eachPixel(cell, (index) => {
                      if (labels[index]) {
                          intersectPixelCount++;
                      }
                  });
                  cell.intersectPixels = intersectPixelCount;
              });
          }
          const imageCount = images.length;
          const maxDistance = Math.sqrt(Math.pow(size[0], 2) + Math.pow(size[1], 2));
          const imageVisible = (cell) => {
              const { intersectPixels } = cell;
              if (placement === 'default') {
                  return intersectPixels > cellPixelCount * 0.5;
              }
              else if (placement === 'edge') {
                  return intersectPixels > cellPixelCount * 0.1 && intersectPixels < cellPixelCount;
              }
              return true;
          };
          for (let i = 0; i < imageCount; i++) {
              const image = images[i];
              const cell = cellInfo[i];
              if (cell) {
                  image.x = cell.centerX - image.width / 2;
                  image.y = cell.centerY - image.height / 2;
                  image.visible = imageVisible(cell);
                  image.cell = `${cell.row}_${cell.col}`;
                  image.angle = Math.random() * (2 * maxAngle) - maxAngle;
                  image.anchor = [image.x + image.width / 2, image.y + image.height / 2];
                  image.zIndex = maxDistance - cell.distance;
                  image.distance = cell.distance;
                  image.frequency = 1;
                  cell.image = image;
              }
          }
          const key = Object.keys(images[0]).find(k => k.includes('VGRAMMAR'));
          if (imageCount < cellCount) {
              for (let i = imageCount; i < cellCount; i++) {
                  const image = images[i - imageCount];
                  const cell = cellInfo[i];
                  if (cell) {
                      const repeatImage = Object.assign({}, image);
                      repeatImage.x = cell.centerX - repeatImage.width / 2;
                      repeatImage.y = cell.centerY - repeatImage.height / 2;
                      repeatImage.anchor = [repeatImage.x + repeatImage.width / 2, repeatImage.y + repeatImage.height / 2];
                      repeatImage.angle = Math.random() * (2 * maxAngle) - maxAngle;
                      repeatImage.frequency += 1;
                      repeatImage[key] = `${repeatImage[key]}_${repeatImage.frequency}`;
                      repeatImage.visible = imageVisible(cell);
                      repeatImage.cell = `${cell.row}_${cell.col}`;
                      repeatImage.distance = cell.distance;
                      repeatImage.zIndex = maxDistance - cell.distance;
                      cell.image = repeatImage;
                      images.push(repeatImage);
                  }
              }
          }
          return images.filter(img => img.visible);
      }
  }

  const transform = (options, upstreamData, parameters) => {
      var _a, _b;
      const size = isFunction$1(options.size) ? options.size() : options.size;
      options.size = size;
      if (!size || isNil$1(size[0]) || isNil$1(size[1]) || size[0] <= 0 || size[1] <= 0) {
          const logger = Logger.getInstance();
          logger.info('Wordcloud size dimensions must be greater than 0');
          return [];
      }
      options.size = [Math.ceil(size[0]), Math.ceil(size[1])];
      if (!options.image) {
          Logger.getInstance().error('Imagecloud: image source must be specified.');
      }
      if (options.onBeforeLayout) {
          options.onBeforeLayout();
      }
      if (!upstreamData || upstreamData.length === 0) {
          return [];
      }
      let layoutConstructor;
      const layoutMode = (_b = (_a = options.layoutConfig) === null || _a === void 0 ? void 0 : _a.layoutMode) !== null && _b !== void 0 ? _b : 'spiral';
      switch (layoutMode) {
          case 'grid':
              layoutConstructor = GridLayout;
              break;
          case 'stack':
              layoutConstructor = StackLayout;
              break;
          case 'spiral':
          default:
              layoutConstructor = SpiralLayout;
              break;
      }
      const layout = new layoutConstructor(options);
      layout.layout(upstreamData);
      if (layout.unfinished()) {
          return {
              progressive: layout
          };
      }
      return layout.output();
  };

  exports.CirclePackingLayout = CirclePackingLayout;
  exports.ImageCloudGridLayout = GridLayout;
  exports.ImageCloudSpiralLayout = SpiralLayout;
  exports.ImageCloudStackLayout = StackLayout;
  exports.SankeyLayout = SankeyLayout;
  exports.SunburstLayout = SunburstLayout;
  exports.TreeLayout = TreeLayout;
  exports.TreemapLayout = TreemapLayout;
  exports.WordcloudCloudLayout = CloudLayout;
  exports.WordcloudFastLayout = FastLayout;
  exports.WordcloudGridLayout = GridLayout$1;
  exports.calculateNodeValue = calculateNodeValue$1;
  exports.circlePackingTransform = transform$8;
  exports.drawCardioid = drawCardioid;
  exports.drawRegularPolygon = drawRegularPolygon;
  exports.eachAfter = eachAfter;
  exports.eachBefore = eachBefore;
  exports.flattenNodes = flattenNodes;
  exports.flattenTreeLinks = flattenTreeLinks;
  exports.formatLinkPath = formatLinkPath;
  exports.formatLinkPolygon = formatLinkPolygon;
  exports.formatNodeRect = formatNodeRect;
  exports.generateCardioidPoints = generateCardioidPoints;
  exports.generateIsEmptyPixel = generateIsEmptyPixel;
  exports.generateMaskCanvas = generateMaskCanvas;
  exports.generatePoints = generatePoints;
  exports.getAlignEndTexts = getAlignEndTexts;
  exports.getAlignStartTexts = getAlignStartTexts;
  exports.getArcsFromCircles = getArcsFromCircles;
  exports.getArcsFromPath = getArcsFromPath;
  exports.getBoundsOfNodes = getBoundsOfNodes;
  exports.getCirclesFromArcs = getCirclesFromArcs;
  exports.getMaxRadiusAndCenter = getMaxRadiusAndCenter;
  exports.getPathFromArcs = getPathFromArcs;
  exports.getShapeFunction = getShapeFunction;
  exports.imagecloudTransform = transform;
  exports.loadImage = loadImage;
  exports.loadImages = loadImages;
  exports.removeBorder = removeBorder;
  exports.sankeyTransform = sankeyTransform;
  exports.scaleAndMiddleShape = scaleAndMiddleShape;
  exports.segmentation = segmentation;
  exports.shapes = shapes;
  exports.spirals = spirals;
  exports.sunburstTransform = transform$6;
  exports.treeTransform = transform$5;
  exports.treemapTransform = transform$4;
  exports.vennMarkTransform = vennMarkTransform;
  exports.vennTransform = vennTransform;
  exports.wordcloudShapeTransform = transform$1;
  exports.wordcloudTransform = transform$2;

}));
