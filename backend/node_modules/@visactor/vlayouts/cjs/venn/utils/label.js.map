{"version":3,"sources":["../src/venn/utils/label.ts"],"names":[],"mappings":"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","file":"label.js","sourcesContent":["/* Adapted from venn.js by Ben Frederickson\n * https://github.com/benfred/venn.js\n * Licensed under the MIT\n\n * url: https://github.com/benfred/venn.js/blob/master/src/diagram.js\n * License: https://github.com/benfred/venn.js/blob/master/LICENSE\n * @license\n */\n\nimport type { IOverlapAreaStats, IPointLike } from '@visactor/vutils';\nimport { getCenter, intersectionArea, Logger, nelderMead, PointService } from '@visactor/vutils';\nimport type { VennCircleName, IVennArea, IVennCircle, VennAreaName } from './interface';\n\nexport function computeTextCenters(\n  circles: Record<VennCircleName, IVennCircle>,\n  areas: IVennArea[]\n): Record<VennAreaName, IPointLike> {\n  const ret: Record<VennAreaName, IPointLike> = {};\n  const overlapped = getOverlappingCircles(circles);\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i].sets;\n    const areaIds: Record<VennCircleName, true> = {};\n    const exclude: Record<VennCircleName, true> = {};\n    for (let j = 0; j < area.length; ++j) {\n      areaIds[area[j]] = true;\n      const overlaps = overlapped[area[j]];\n      // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n      for (let k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n\n    const interior: IVennCircle[] = [];\n    const exterior: IVennCircle[] = [];\n    for (const setId in circles) {\n      if (setId in areaIds) {\n        interior.push(circles[setId]);\n      } else if (!(setId in exclude)) {\n        exterior.push(circles[setId]);\n      }\n    }\n    const center = computeTextCenter(interior, exterior);\n    ret[area.toString()] = center;\n    if (center.disjoint && areas[i].size > 0) {\n      const logger = Logger.getInstance();\n      logger.error('Area ' + area + ' not represented on screen');\n    }\n  }\n  return ret;\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles: Record<VennCircleName, IVennCircle>): Record<VennCircleName, VennCircleName[]> {\n  const ret: Record<VennCircleName, VennCircleName[]> = {};\n  const circleIds: VennCircleName[] = [];\n  for (const circleId in circles) {\n    circleIds.push(circleId);\n    ret[circleId] = [];\n  }\n  for (let i = 0; i < circleIds.length; i++) {\n    const a = circles[circleIds[i]];\n    for (let j = i + 1; j < circleIds.length; ++j) {\n      const b = circles[circleIds[j]];\n      const d = PointService.distancePP(a, b);\n\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[circleIds[j]].push(circleIds[i]);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[circleIds[i]].push(circleIds[j]);\n      }\n    }\n  }\n  return ret;\n}\n\n// compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\nexport function computeTextCenter(interior: IVennCircle[], exterior: IVennCircle[]) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  const points: IPointLike[] = [];\n  for (let i = 0; i < interior.length; ++i) {\n    const c = interior[i];\n    points.push({ x: c.x, y: c.y });\n    points.push({ x: c.x + c.radius / 2, y: c.y });\n    points.push({ x: c.x - c.radius / 2, y: c.y });\n    points.push({ x: c.x, y: c.y + c.radius / 2 });\n    points.push({ x: c.x, y: c.y - c.radius / 2 });\n  }\n  let initial = points[0];\n  let margin = circleMargin(points[0], interior, exterior);\n  for (let i = 1; i < points.length; ++i) {\n    const m = circleMargin(points[i], interior, exterior);\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  }\n\n  // maximize the margin numerically\n  const solution = nelderMead(\n    function (p: number[]) {\n      return -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior);\n    },\n    [initial.x, initial.y],\n    { maxIterations: 500, minErrorDelta: 1e-10 }\n  ).x;\n  let ret: {\n    x: number;\n    y: number;\n    disjoint?: boolean;\n  } = { x: solution[0], y: solution[1] };\n\n  // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n  let valid = true;\n  for (let i = 0; i < interior.length; ++i) {\n    if (PointService.distancePP(ret, interior[i]) > interior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  for (let i = 0; i < exterior.length; ++i) {\n    if (PointService.distancePP(ret, exterior[i]) < exterior[i].radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  if (!valid) {\n    if (interior.length === 1) {\n      ret = { x: interior[0].x, y: interior[0].y };\n    } else {\n      const areaStats: IOverlapAreaStats = {};\n      intersectionArea(interior, areaStats);\n\n      if (areaStats.arcs.length === 0) {\n        ret = { x: 0, y: -1000, disjoint: true };\n      } else if (areaStats.arcs.length === 1) {\n        ret = { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };\n      } else if (exterior.length) {\n        // try again without other circles\n        ret = computeTextCenter(interior, []);\n      } else {\n        // take average of all the points in the intersection\n        // polygon. this should basically never happen\n        // and has some issues:\n        // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n        ret = getCenter(\n          areaStats.arcs.map(function (a) {\n            return a.p1;\n          })\n        );\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction circleMargin(current: IPointLike, interior: IVennCircle[], exterior: IVennCircle[]) {\n  let margin = interior[0].radius - PointService.distancePP(interior[0], current);\n  let i;\n  let m;\n  for (i = 1; i < interior.length; ++i) {\n    m = interior[i].radius - PointService.distancePP(interior[i], current);\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  for (i = 0; i < exterior.length; ++i) {\n    m = PointService.distancePP(exterior[i], current) - exterior[i].radius;\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  return margin;\n}\n"]}