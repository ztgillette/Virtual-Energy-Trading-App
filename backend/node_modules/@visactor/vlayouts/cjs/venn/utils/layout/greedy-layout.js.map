{"version":3,"sources":["../src/venn/utils/layout/greedy-layout.ts"],"names":[],"mappings":"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","file":"greedy-layout.js","sourcesContent":["/* Adapted from venn.js by Ben Frederickson\n * https://github.com/benfred/venn.js\n * Licensed under the MIT\n\n * url: https://github.com/benfred/venn.js/blob/master/src/layout.js\n * License: https://github.com/benfred/venn.js/blob/master/LICENSE\n * @license\n */\n\nimport type { VennCircleName, IVennArea, IVennCircle, IVennSingleArea, IVennParams } from '../interface';\nimport { lossFunction } from './loss';\nimport { distanceFromIntersectArea } from './common';\nimport type { IPointLike } from '@visactor/vutils';\nimport { circleCircleIntersection, SMALL } from '@visactor/vutils';\n\n/** Lays out a Venn diagram greedily, going from most overlapped sets to\nleast overlapped, attempting to position each new set such that the\noverlapping areas to already positioned sets are basically right */\nexport function greedyLayout(areas: IVennArea[], params: IVennParams): Record<VennCircleName, IVennCircle> {\n  const loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n  // define a circle for each set\n  const circles: Record<VennCircleName, IVennCircle> = {};\n  const setOverlaps: Record<VennCircleName, IVennSingleArea[]> = {};\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i];\n    if (area.sets.length === 1) {\n      const set = area.sets[0];\n      circles[set] = {\n        x: 1e10,\n        y: 1e10,\n        size: area.size,\n        radius: Math.sqrt(area.size / Math.PI),\n        setId: set\n      };\n      setOverlaps[set] = [];\n    }\n  }\n  areas = areas.filter(function (a) {\n    return a.sets.length === 2;\n  });\n\n  // map each set to a list of all the other sets that overlap it\n  for (let i = 0; i < areas.length; ++i) {\n    const current = areas[i];\n    let weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n    const left = current.sets[0];\n    const right = current.sets[1];\n\n    // completely overlapped circles shouldn't be positioned early here\n    if (current.size + SMALL >= Math.min(circles[left].size, circles[right].size)) {\n      weight = 0;\n    }\n\n    setOverlaps[left].push({ set: right, size: current.size, weight: weight });\n    setOverlaps[right].push({ set: left, size: current.size, weight: weight });\n  }\n\n  // get list of most overlapped sets\n  const mostOverlapped: IVennSingleArea[] = [];\n  for (const set in setOverlaps) {\n    if (setOverlaps.hasOwnProperty(set)) {\n      let size = 0;\n      for (let i = 0; i < setOverlaps[set].length; ++i) {\n        size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n      }\n\n      mostOverlapped.push({ set, size });\n    }\n  }\n\n  // sort by size desc\n  function sortOrder(a: IVennSingleArea, b: IVennSingleArea) {\n    return b.size - a.size;\n  }\n  mostOverlapped.sort(sortOrder);\n\n  // keep track of what sets have been laid out\n  const positioned: Record<VennCircleName, true> = {};\n  function isPositioned(element: IVennSingleArea) {\n    return element.set in positioned;\n  }\n\n  // adds a point to the output\n  function positionSet(point: IPointLike, index: VennCircleName) {\n    circles[index].x = point.x;\n    circles[index].y = point.y;\n    positioned[index] = true;\n  }\n\n  // add most overlapped set at (0,0)\n  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);\n\n  // get distances between all points. TODO, necessary?\n  // answer: probably not\n  // var distances = venn.getDistanceMatrices(circles, areas).distances;\n  for (let i = 1; i < mostOverlapped.length; ++i) {\n    const setIndex = mostOverlapped[i].set;\n    const overlap = setOverlaps[setIndex].filter(isPositioned);\n    const set = circles[setIndex];\n    overlap.sort(sortOrder);\n\n    if (overlap.length === 0) {\n      // this shouldn't happen anymore with addMissingAreas\n      throw 'ERROR: missing pairwise overlap information';\n    }\n\n    const points: IPointLike[] = [];\n    for (let j = 0; j < overlap.length; ++j) {\n      // get appropriate distance from most overlapped already added set\n      const p1 = circles[overlap[j].set];\n      const d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size);\n\n      // sample positions at 90 degrees for maximum aesthetics\n      points.push({ x: p1.x + d1, y: p1.y });\n      points.push({ x: p1.x - d1, y: p1.y });\n      points.push({ y: p1.y + d1, x: p1.x });\n      points.push({ y: p1.y - d1, x: p1.x });\n\n      // if we have at least 2 overlaps, then figure out where the\n      // set should be positioned analytically and try those too\n      for (let k = j + 1; k < overlap.length; ++k) {\n        const p2 = circles[overlap[k].set];\n        const d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\n\n        const extraPoints = circleCircleIntersection(\n          { x: p1.x, y: p1.y, radius: d1 },\n          { x: p2.x, y: p2.y, radius: d2 }\n        );\n\n        for (let l = 0; l < extraPoints.length; ++l) {\n          points.push(extraPoints[l]);\n        }\n      }\n    }\n\n    // we have some candidate positions for the set, examine loss\n    // at each position to figure out where to put it at\n    let bestLoss = 1e50;\n    let bestPoint = points[0];\n    for (let j = 0; j < points.length; ++j) {\n      circles[setIndex].x = points[j].x;\n      circles[setIndex].y = points[j].y;\n      const localLoss = loss(circles, areas);\n      if (localLoss < bestLoss) {\n        bestLoss = localLoss;\n        bestPoint = points[j];\n      }\n    }\n\n    positionSet(bestPoint, setIndex);\n  }\n\n  return circles;\n}\n"]}