"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.transformMark = exports.transform = void 0;

const vutils_1 = require("@visactor/vutils"), utils_1 = require("./utils"), path_1 = require("./utils/path"), transform = (options, upstreamData) => {
    const {x0: x0, x1: x1, y0: y0, y1: y1, setField: setField = "sets", valueField: valueField = "size", orientation: orientation = Math.PI / 2, orientationOrder: orientationOrder = null, emptySetKey: emptySetKey} = options;
    let circles = {}, textCenters = {};
    const hasEmptySet = upstreamData.some((area => {
        const sets = (0, vutils_1.array)(area[setField]);
        return !sets || 0 === sets.length;
    })), nonEmptyData = hasEmptySet ? upstreamData.filter((area => !(0, vutils_1.isEmpty)((0, 
    vutils_1.array)(area[setField])))) : upstreamData;
    if (nonEmptyData.length > 0) {
        const vennData = nonEmptyData.map((area => ({
            sets: (0, vutils_1.array)(area[setField]),
            size: area[valueField]
        })));
        let solution = (0, utils_1.venn)(vennData, options);
        solution = (0, utils_1.normalizeSolution)(solution, orientation, orientationOrder), 
        circles = (0, utils_1.scaleSolution)(solution, x1 - x0, y1 - y0, x0, y0, hasEmptySet), 
        textCenters = (0, utils_1.computeTextCenters)(circles, vennData);
    }
    return upstreamData.map((area => {
        const sets = (0, vutils_1.array)(area[setField]);
        if (!sets || 0 === sets.length) return Object.assign(Object.assign({}, area), {
            datum: area,
            sets: sets,
            key: emptySetKey || "others",
            size: area[valueField],
            labelX: void 0,
            labelY: void 0,
            type: "circle",
            x: x0 + (x1 - x0) / 2,
            y: y0 + (y1 - y0) / 2,
            radius: Math.min(x1 - x0, y1 - y0) / 2
        });
        const key = sets.toString(), textCenter = textCenters[key], basicDatum = Object.assign(Object.assign({}, area), {
            datum: area,
            sets: sets,
            key: key,
            size: area[valueField],
            labelX: null == textCenter ? void 0 : textCenter.x,
            labelY: null == textCenter ? void 0 : textCenter.y
        }), circle = circles[key];
        if (circle) return Object.assign(Object.assign({}, basicDatum), {
            type: "circle",
            x: circle.x,
            y: circle.y,
            radius: circle.radius
        });
        const arcs = (0, path_1.getArcsFromCircles)(sets.map((name => circles[name])));
        return Object.assign(Object.assign({}, basicDatum), {
            type: "overlap",
            x: 0,
            y: 0,
            path: (0, path_1.getPathFromArcs)(arcs),
            arcs: arcs
        });
    }));
};

exports.transform = transform;

const transformMark = (options, upstreamData) => upstreamData.filter((datum => datum.type === options.datumType));

exports.transformMark = transformMark;
//# sourceMappingURL=venn.js.map