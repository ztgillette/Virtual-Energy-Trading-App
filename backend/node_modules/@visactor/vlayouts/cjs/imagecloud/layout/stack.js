"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.StackLayout = void 0;

const basic_1 = require("./basic"), rectGrid_1 = require("./grid/rectGrid");

class StackLayout extends basic_1.Layout {
    preProcess() {
        const images = super.preProcess(), {imageConfig: imageConfig = {}, ratio: ratio = .1} = this.options, cellLayoutMethod = rectGrid_1.rectGridLayout;
        return this.layoutContext = cellLayoutMethod(Object.assign({}, this.options, {
            imageConfig: {
                imageSize: null
            }
        })).context, this.layoutContext.cellInfo.sort(((cellA, cellB) => cellA.distance - cellB.distance)), 
        this.calculateImageSize(images, imageConfig, ratio);
    }
    doLayout(images) {
        const {segmentationOutput: segmentationOutput} = this, {cellWidth: cellWidth, cellHeight: cellHeight, cellInfo: cellInfo, cellCount: cellCount, eachPixel: eachPixel, cellPixelCount: cellPixelCount} = this.layoutContext;
        if (0 === images.length || 0 === cellCount || 0 === cellWidth || 0 === cellHeight || 0 === cellInfo.length) return void (this.isLayoutFinished = !0);
        const {layoutConfig: layoutConfig = {}} = this.options, size = this.options.size, {placement: placement = "default", maxAngle: maxAngle = Math.PI / 180 * 45} = layoutConfig;
        if ("edge" === placement || "default" === placement) {
            const {segmentation: segmentation} = segmentationOutput, {labels: labels} = segmentation;
            cellInfo.forEach((cell => {
                let intersectPixelCount = 0;
                eachPixel(cell, (index => {
                    labels[index] && intersectPixelCount++;
                })), cell.intersectPixels = intersectPixelCount;
            }));
        }
        const imageCount = images.length, maxDistance = Math.sqrt(Math.pow(size[0], 2) + Math.pow(size[1], 2)), imageVisible = cell => {
            const {intersectPixels: intersectPixels} = cell;
            return "default" === placement ? intersectPixels > .5 * cellPixelCount : "edge" !== placement || intersectPixels > .1 * cellPixelCount && intersectPixels < cellPixelCount;
        };
        for (let i = 0; i < imageCount; i++) {
            const image = images[i], cell = cellInfo[i];
            cell && (image.x = cell.centerX - image.width / 2, image.y = cell.centerY - image.height / 2, 
            image.visible = imageVisible(cell), image.cell = `${cell.row}_${cell.col}`, image.angle = Math.random() * (2 * maxAngle) - maxAngle, 
            image.anchor = [ image.x + image.width / 2, image.y + image.height / 2 ], image.zIndex = maxDistance - cell.distance, 
            image.distance = cell.distance, image.frequency = 1, cell.image = image);
        }
        const key = Object.keys(images[0]).find((k => k.includes("VGRAMMAR")));
        if (imageCount < cellCount) for (let i = imageCount; i < cellCount; i++) {
            const image = images[i - imageCount], cell = cellInfo[i];
            if (cell) {
                const repeatImage = Object.assign({}, image);
                repeatImage.x = cell.centerX - repeatImage.width / 2, repeatImage.y = cell.centerY - repeatImage.height / 2, 
                repeatImage.anchor = [ repeatImage.x + repeatImage.width / 2, repeatImage.y + repeatImage.height / 2 ], 
                repeatImage.angle = Math.random() * (2 * maxAngle) - maxAngle, repeatImage.frequency += 1, 
                repeatImage[key] = `${repeatImage[key]}_${repeatImage.frequency}`, repeatImage.visible = imageVisible(cell), 
                repeatImage.cell = `${cell.row}_${cell.col}`, repeatImage.distance = cell.distance, 
                repeatImage.zIndex = maxDistance - cell.distance, cell.image = repeatImage, images.push(repeatImage);
            }
        }
        return images.filter((img => img.visible));
    }
}

exports.StackLayout = StackLayout;
//# sourceMappingURL=stack.js.map
