"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.GridLayout = void 0;

const util_1 = require("../../util"), basic_1 = require("../basic"), rectGrid_1 = require("./rectGrid"), circlGrid_1 = require("./circlGrid"), hexagonalGrid_1 = require("./hexagonalGrid"), vutils_1 = require("@visactor/vutils"), cellLayout = {
    rect: rectGrid_1.rectGridLayout,
    circle: circlGrid_1.circleGridLayout,
    hexagonal: hexagonalGrid_1.hexagonalGridLayout
};

class GridLayout extends basic_1.Layout {
    preProcess() {
        var _a;
        const images = super.preProcess(), {layoutConfig: layoutConfig = {}} = this.options, {cellType: cellType = "rect"} = layoutConfig, layoutResult = (null !== (_a = cellLayout[cellType]) && void 0 !== _a ? _a : cellLayout.rect)(this.options), {context: context, imageLength: shortSideLength} = layoutResult;
        return images.forEach((img => (0, util_1.setSizeByShortSide)(img, shortSideLength))), 
        context.cellInfo.sort(((cellA, cellB) => cellA.distance - cellB.distance)), this.layoutContext = context, 
        images;
    }
    doLayout(images) {
        const {cellWidth: cellWidth, cellHeight: cellHeight, cellInfo: cellInfo, cellCount: cellCount, clipPath: clipPath, eachPixel: eachPixel, cellPixelCount: cellPixelCount} = this.layoutContext;
        if (0 === images.length || 0 === cellCount || 0 === cellWidth || 0 === cellHeight || 0 === cellInfo.length) return void (this.isLayoutFinished = !0);
        const {segmentationOutput: segmentationOutput} = this, {layoutConfig: layoutConfig = {}} = this.options, {placement: placement = "default"} = layoutConfig;
        if ("edge" === placement || "default" === placement) {
            const {segmentation: segmentation} = segmentationOutput, {labels: labels} = segmentation;
            cellInfo.forEach((cell => {
                let intersectPixelCount = 0;
                eachPixel(cell, (index => {
                    labels[index] && intersectPixelCount++;
                })), cell.intersectPixels = intersectPixelCount;
            }));
        }
        const imageCount = images.length, imageVisible = cell => {
            const {intersectPixels: intersectPixels} = cell;
            return "default" === placement ? intersectPixels >= .45 * cellPixelCount : "edge" !== placement || intersectPixels > .1 * cellPixelCount && intersectPixels < cellPixelCount;
        };
        for (let i = 0; i < imageCount; i++) {
            const image = images[i], cell = cellInfo[i];
            cell && (image.x = cell.centerX - image.width / 2, image.y = cell.centerY - image.height / 2, 
            image.clipConfig = {
                shape: clipPath
            }, image.frequency = 1, image.visible = imageVisible(cell), image.cell = (0, vutils_1.pickWithout)(cell, [ "image" ]), 
            image.distance = cell.distance, cell.image = image);
        }
        const key = Object.keys(images[0]).find((k => k.includes("VGRAMMAR")));
        if (imageCount < cellCount) for (let i = imageCount; i < cellCount; i++) {
            const image = images[i - imageCount], cell = cellInfo[i];
            if (cell) {
                const repeatImage = Object.assign({}, image);
                repeatImage.x = cell.centerX - repeatImage.width / 2, repeatImage.y = cell.centerY - repeatImage.height / 2, 
                repeatImage.frequency += 1, repeatImage[key] = `${repeatImage[key]}_${repeatImage.frequency}`, 
                repeatImage.visible = imageVisible(cell), repeatImage.distance = cell.distance, 
                repeatImage.cell = (0, vutils_1.pickWithout)(cell, [ "image" ]), cell.image = repeatImage, 
                images.push(repeatImage);
            }
        }
        return images.filter((img => img.visible));
    }
}

exports.GridLayout = GridLayout;
//# sourceMappingURL=grid.js.map
