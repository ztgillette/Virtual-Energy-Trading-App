"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.flattenNodes = exports.eachAfter = exports.eachBefore = exports.calculateNodeValue = void 0;

const vutils_1 = require("@visactor/vutils"), calculateNodeValue = (subTree, output, depth = 0, flattenIndex = -1, parent, getNodeKey, valueField = "value") => {
    let sum = 0, prevFlattenIndex = null != flattenIndex ? flattenIndex : -1, maxDepth = depth;
    return subTree.forEach(((datum, index) => {
        var _a, _b;
        const node = {
            flattenIndex: ++prevFlattenIndex,
            key: getNodeKey ? getNodeKey(datum) : `${null !== (_a = null == parent ? void 0 : parent.key) && void 0 !== _a ? _a : ""}-${index}`,
            maxDepth: -1,
            depth: depth,
            index: index,
            value: datum[valueField],
            isLeaf: !0,
            datum: parent ? parent.datum.concat(datum) : [ datum ],
            parentKey: null == parent ? void 0 : parent.key
        };
        if (null === (_b = datum.children) || void 0 === _b ? void 0 : _b.length) {
            node.children = [], node.isLeaf = !1;
            const res = (0, exports.calculateNodeValue)(datum.children, node.children, depth + 1, prevFlattenIndex, node, getNodeKey, valueField);
            node.value = (0, vutils_1.isNil)(datum[valueField]) ? res.sum : Math.max(res.sum, (0, 
            vutils_1.toValidNumber)(datum[valueField])), prevFlattenIndex = res.flattenIndex, 
            maxDepth = Math.max(res.maxDepth, maxDepth);
        } else node.isLeaf = !0, node.value = (0, vutils_1.toValidNumber)(datum[valueField]);
        sum += Math.abs(node.value), output.push(node);
    })), {
        sum: sum,
        maxDepth: maxDepth,
        flattenIndex: prevFlattenIndex
    };
};

exports.calculateNodeValue = calculateNodeValue;

const eachBefore = (subTree, callback, parent, ctx) => {
    let ctxRes = ctx;
    return subTree.forEach(((node, index) => {
        var _a;
        ctxRes = callback(node, index, parent, ctxRes), (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) && (ctxRes = (0, 
        exports.eachBefore)(node.children, callback, node, ctxRes));
    })), ctx;
};

exports.eachBefore = eachBefore;

const eachAfter = (subTree, callback, parent, ctx) => {
    let ctxRes = ctx;
    return subTree.forEach(((node, index) => {
        var _a;
        (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) && (ctxRes = (0, 
        exports.eachAfter)(node.children, callback, node, ctxRes)), ctxRes = callback(node, index, parent, ctxRes);
    })), ctxRes;
};

exports.eachAfter = eachAfter;

const flattenNodes = (nodes, output = [], options) => {
    const hasMaxDepth = (null == options ? void 0 : options.maxDepth) >= 0;
    return nodes.forEach((node => {
        (!hasMaxDepth || node.depth <= options.maxDepth) && (output.push((null == options ? void 0 : options.callback) ? options.callback(node) : node), 
        node.children && (hasMaxDepth && node.depth === options.maxDepth ? (node.children = null, 
        node.isLeaf = !0) : (0, exports.flattenNodes)(node.children, output, options)));
    })), output;
};

exports.flattenNodes = flattenNodes;
//# sourceMappingURL=hierarchy.js.map