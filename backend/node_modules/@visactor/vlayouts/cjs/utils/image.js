"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.scaleAndMiddleShape = exports.removeBorder = exports.segmentation = exports.drawCardioid = exports.drawRegularPolygon = exports.generateCardioidPoints = exports.generatePoints = exports.generateMaskCanvas = exports.generateIsEmptyPixel = void 0;

const shapes_1 = require("./shapes"), vutils_1 = require("@visactor/vutils"), generateIsEmptyPixel = (backgroundColor, options, createCanvas) => {
    const {threshold: threshold, invert: invert = !1} = null != options ? options : {};
    if (!backgroundColor || "#fff" === backgroundColor) return (imageData, y, x) => {
        const width = imageData.width;
        if (0 === imageData.data[y * width * 4 + 4 * x + 3]) return !invert;
        const r = imageData.data[y * width * 4 + 4 * x + 0], g = imageData.data[y * width * 4 + 4 * x + 1], b = imageData.data[y * width * 4 + 4 * x + 2];
        if (255 === r && 255 === g && 255 === b) return !invert;
        if ((0, vutils_1.isValidNumber)(threshold)) {
            const grayValue = .3 * r + .59 * g + .11 * b;
            return invert ? grayValue <= threshold : grayValue >= threshold;
        }
        return !1;
    };
    const bctx = createCanvas({
        width: 1,
        height: 1
    }).getContext("2d", {
        willReadFrequently: !0
    });
    bctx.fillStyle = backgroundColor, bctx.fillRect(0, 0, 1, 1);
    const bgPixel = bctx.getImageData(0, 0, 1, 1).data;
    return (imageData, y, x) => {
        const width = imageData.width;
        return [ 0, 1, 2, 3 ].every((i => invert ? imageData.data[4 * (y * width + x) + i] !== bgPixel[i] : imageData.data[4 * (y * width + x) + i] === bgPixel[i]));
    };
};

exports.generateIsEmptyPixel = generateIsEmptyPixel;

const generateMaskCanvas = (shape, width, height, cacheCanvas, invert = !1, createCanvas) => {
    let {backgroundColor: backgroundColor = "#fff"} = shape, {fill: foregroundColor = "#000"} = shape;
    invert && ([backgroundColor, foregroundColor] = [ foregroundColor, backgroundColor ]);
    const maskCanvas = cacheCanvas || createCanvas({
        width: width,
        height: height,
        dpr: 1
    }), tempContext = maskCanvas.getContext("2d", {
        willReadFrequently: !0
    });
    if (cacheCanvas) {
        const prevWidth = cacheCanvas.width, prevHeight = cacheCanvas.height;
        tempContext.clearRect(0, 0, prevWidth, prevHeight), cacheCanvas.style.width = `${width}px`, 
        cacheCanvas.style.height = `${height}px`, cacheCanvas.width = width, cacheCanvas.height = height;
    }
    return tempContext.fillStyle = backgroundColor, tempContext.fillRect(0, 0, maskCanvas.width, maskCanvas.height), 
    "text" === shape.type ? drawTextMask(shape, foregroundColor, maskCanvas.width, maskCanvas.height, tempContext) : "geometric" === shape.type && drawGeometricMask(shape, foregroundColor, maskCanvas.width, maskCanvas.height, tempContext), 
    maskCanvas;
};

exports.generateMaskCanvas = generateMaskCanvas;

const drawTextMask = (shape, fillColor, width, height, ctx) => {
    const {fontFamily: fontFamily = "sans-serif", fontWeight: fontWeight = "normal", fontStyle: fontStyle = "normal", fontVariant: fontVariant = "normal", text: text, hollow: hollow} = shape;
    let baseFontSize = 12;
    ctx.font = `${fontStyle} ${fontVariant} ${fontWeight} ${baseFontSize}px ${fontFamily}`, 
    ctx.textAlign = "center", ctx.textBaseline = "middle", ctx.fillStyle = fillColor;
    const textMetrics = ctx.measureText(text), scale = "normal" !== fontStyle ? 1.1 : 1, actualWidth = (0, 
    vutils_1.isValid)(textMetrics.actualBoundingBoxRight) && (0, vutils_1.isValid)(textMetrics.actualBoundingBoxLeft) ? Math.ceil(scale * (Math.abs(textMetrics.actualBoundingBoxRight) + Math.abs(textMetrics.actualBoundingBoxLeft))) : 0, textWidth = Math.max(Math.ceil(textMetrics.width), actualWidth, baseFontSize);
    if (hollow && (ctx.globalCompositeOperation = "xor"), textWidth > width) {
        const scale = Math.min(width / textWidth, height / baseFontSize);
        ctx.fillText(text, width / 2, height / 2), ctx.scale(scale, scale);
    } else baseFontSize = Math.floor(baseFontSize * width / textWidth), baseFontSize = Math.min(baseFontSize, height), 
    ctx.font = `${fontStyle} ${fontVariant} ${fontWeight} ${baseFontSize}px ${fontFamily}`, 
    ctx.fillText(text, Math.floor(width / 2), Math.floor(height / 2));
}, generatePoints = (center, radius, startAngle = 0, count) => {
    const angle = 2 * Math.PI / count;
    return new Array(count).fill(0).map(((entry, index) => (0, vutils_1.polarToCartesian)(center, radius, startAngle + index * angle)));
};

exports.generatePoints = generatePoints;

const generateCardioidPoints = (center, radius, startAngle = 0, count) => {
    const angle = 2 * Math.PI / count, func = (0, shapes_1.getShapeFunction)("cardioid");
    return new Array(count).fill(0).map(((entry, index) => {
        const theta = startAngle + index * angle, r = radius * func(theta);
        return (0, vutils_1.polarToCartesian)(center, r, theta);
    }));
};

exports.generateCardioidPoints = generateCardioidPoints;

const drawRegularPolygon = (ctx, points) => {
    ctx.beginPath(), points.forEach(((p, index) => {
        0 === index ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
    })), ctx.closePath(), ctx.fill();
};

exports.drawRegularPolygon = drawRegularPolygon;

const drawCardioid = (ctx, points) => {
    let prev;
    ctx.beginPath(), points.forEach(((p, index) => {
        0 === index ? ctx.moveTo(p.x, p.y) : ctx.bezierCurveTo(p.x, p.y, prev.x, prev.y, p.x, p.y), 
        prev = p;
    })), ctx.closePath(), ctx.fill();
};

exports.drawCardioid = drawCardioid;

const drawGeometricMask = (shape, fillColor, width, height, ctx) => {
    const {hollow: hollow} = shape, {center: center, maxRadius: maxRadius} = (0, shapes_1.getMaxRadiusAndCenter)(shape.shape, [ width, height ]);
    ctx.fillStyle = fillColor, hollow && (ctx.globalCompositeOperation = "xor");
    const cx = center[0], cy = center[1];
    if ("cardioid" === shape.shape) (0, exports.drawCardioid)(ctx, (0, exports.generateCardioidPoints)({
        x: cx,
        y: cy
    }, maxRadius, 0, 100)); else if ("circle" === shape.shape) ctx.beginPath(), ctx.arc(cx, cy, maxRadius, 0, 2 * Math.PI, !0), 
    ctx.fill(); else if ("diamond" === shape.shape) (0, exports.drawRegularPolygon)(ctx, (0, 
    exports.generatePoints)({
        x: cx,
        y: cy
    }, maxRadius, -Math.PI / 2, 4)); else if ("square" === shape.shape) (0, exports.drawRegularPolygon)(ctx, (0, 
    exports.generatePoints)({
        x: cx,
        y: cy
    }, maxRadius, -Math.PI / 4, 4)); else if ("pentagon" === shape.shape) (0, exports.drawRegularPolygon)(ctx, (0, 
    exports.generatePoints)({
        x: cx,
        y: cy
    }, maxRadius, Math.PI / 2, 5)); else if ("triangle" === shape.shape || "triangleUpright" === shape.shape) (0, 
    exports.drawRegularPolygon)(ctx, (0, exports.generatePoints)({
        x: cx,
        y: cy
    }, maxRadius, -Math.PI / 2, 3)); else if ("triangleForward" === shape.shape) (0, 
    exports.drawRegularPolygon)(ctx, (0, exports.generatePoints)({
        x: cx,
        y: cy
    }, maxRadius, 0, 3)); else if ("star" === shape.shape) {
        const outterPoints = (0, exports.generatePoints)({
            x: cx,
            y: cy
        }, maxRadius, -Math.PI / 2, 5), innerPoints = (0, exports.generatePoints)({
            x: cx,
            y: cy
        }, maxRadius / (2 * Math.cos(Math.PI / 5)), -Math.PI / 2 + Math.PI / 5, 5), points = [];
        for (let i = 0; i < 5; i++) points.push(outterPoints[i]), points.push(innerPoints[i]);
        (0, exports.drawRegularPolygon)(ctx, points);
    } else ctx.fillRect(0, 0, width, height);
};

function segmentation(segmentationInput) {
    const {size: size, maskCanvas: maskCanvas} = segmentationInput, imageData = maskCanvas.getContext("2d", {
        willReadFrequently: !0
    }).getImageData(0, 0, maskCanvas.width, maskCanvas.height), labels = new Array(size[0] * size[1]).fill(0);
    let curLabel = 1;
    const offset = [ [ 0, 1 ], [ 1, 0 ], [ -1, 0 ], [ 0, -1 ] ];
    let queue = [];
    for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) if (0 === labels[i * size[0] + j] && !segmentationInput.isEmptyPixel(imageData, i, j)) {
        labels[i * size[0] + j] = curLabel, queue.push([ i, j ]);
        for (let k = 0; k < queue.length; k++) for (let m = 0; m < 4; m++) {
            let row = queue[k][0] + offset[m][0], col = queue[k][1] + offset[m][1];
            row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row, col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col, 
            0 !== labels[row * size[0] + col] || segmentationInput.isEmptyPixel(imageData, row, col) || (labels[row * size[0] + col] = curLabel, 
            queue.push([ row, col ]));
        }
        curLabel++, queue = [];
    }
    const boundaries = {}, areas = {}, centers = {}, maxPoints = {}, maxR = {}, ratios = {}, shapeBounds = {
        x1: 1 / 0,
        x2: -1 / 0,
        y1: 1 / 0,
        y2: -1 / 0,
        width: 0,
        height: 0
    }, boundaryPixels = [];
    for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) {
        const label = labels[i * size[0] + j];
        0 !== label && (isBoundaryPixel(i, j) && (boundaryPixels.push([ i, j ]), boundaries[label] = boundaries[label] || [], 
        boundaries[label].push([ j, i ]), maxPoints[label] || (maxPoints[label] = [ 1 / 0, -1 / 0, 1 / 0, -1 / 0 ]), 
        i < maxPoints[label][0] && (maxPoints[label][0] = i), i > maxPoints[label][1] && (maxPoints[label][1] = i), 
        j < maxPoints[label][2] && (maxPoints[label][2] = j), j > maxPoints[label][3] && (maxPoints[label][3] = j), 
        j < shapeBounds.x1 && (shapeBounds.x1 = j), j > shapeBounds.x2 && (shapeBounds.x2 = j), 
        i < shapeBounds.y1 && (shapeBounds.y1 = i), i > shapeBounds.y2 && (shapeBounds.y2 = i)), 
        areas[label] = (areas[label] || 0) + 1);
    }
    const allBoundaries = [];
    for (const label in boundaries) {
        const boundary = boundaries[label], x = ~~(boundary.reduce(((acc, cur) => acc + cur[0]), 0) / boundary.length), y = ~~(boundary.reduce(((acc, cur) => acc + cur[1]), 0) / boundary.length);
        centers[label] = [ x, y ], allBoundaries.push(...boundary);
        const [yMin, yMax, xMin, xMax] = maxPoints[label];
        maxR[label] = ~~Math.max(Math.sqrt((x - xMin) ** 2 + (y - yMin) ** 2), Math.sqrt((x - xMax) ** 2 + (y - yMax) ** 2), Math.sqrt((x - xMin) ** 2 + (y - yMax) ** 2), Math.sqrt((x - xMax) ** 2 + (y - yMin) ** 2)), 
        ratios[label] = (xMax - xMin) / (yMax - yMin);
    }
    const regions = Object.keys(centers).map((key => ({
        label: key - 1,
        boundary: boundaries[key],
        area: areas[key],
        center: centers[key],
        maxPoint: maxPoints[key],
        maxR: maxR[key],
        ratio: ratios[key]
    })));
    shapeBounds.width = shapeBounds.x2 - shapeBounds.x1 + 1, shapeBounds.height = shapeBounds.y2 - shapeBounds.y1 + 1;
    const x = ~~(allBoundaries.reduce(((acc, cur) => acc + cur[0]), 0) / allBoundaries.length), y = ~~(allBoundaries.reduce(((acc, cur) => acc + cur[1]), 0) / allBoundaries.length), shapeMaxR = ~~Math.max(Math.sqrt((x - shapeBounds.x1) ** 2 + (y - shapeBounds.y1) ** 2), Math.sqrt((x - shapeBounds.x2) ** 2 + (y - shapeBounds.y2) ** 2), Math.sqrt((x - shapeBounds.x1) ** 2 + (y - shapeBounds.y2) ** 2), Math.sqrt((x - shapeBounds.x2) ** 2 + (y - shapeBounds.y1) ** 2)), shapeRatio = shapeBounds.width / shapeBounds.height, shapeArea = Object.keys(areas).reduce(((acc, key) => acc + areas[key]), 0), segmentation = {
        regions: regions,
        labels: labels,
        labelNumber: curLabel - 1
    };
    if (segmentationInput.blur) {
        const blur = segmentationInput.blur, blurredLabels = gaussianBlur(labels, size[0], size[1], blur);
        drawContour(labels, boundaryPixels, size[0], size[1], Math.ceil(blur / 2)).forEach(((value, index) => {
            1 === value && (labels[index] = blurredLabels[index]);
        }));
    }
    return Object.assign(segmentationInput, {
        segmentation: segmentation,
        shapeBounds: shapeBounds,
        shapeMaxR: shapeMaxR,
        shapeRatio: shapeRatio,
        shapeCenter: [ x, y ],
        shapeArea: shapeArea
    });
    function isBoundaryPixel(i, j) {
        const offset = [ [ 0, 1 ], [ 1, 0 ], [ -1, 0 ], [ 0, -1 ] ];
        if (0 === i || 0 === j || i === size[1] - 1 || j === size[0] - 1) return !0;
        for (let k = 0; k < 4; k++) {
            let row = i + offset[k][0], col = j + offset[k][1];
            if (row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row, col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col, 
            0 === labels[row * size[0] + col]) return !0;
        }
        return !1;
    }
}

function generateGaussianKernel1D(size, sigma) {
    const kernel = new Array(2 * size + 1).fill(0), center = size;
    let sum = 0;
    for (let x = -size; x <= size; x++) {
        const g = Math.exp(-x * x / (2 * sigma * sigma));
        kernel[x + center] = g, sum += g;
    }
    for (let i = 0; i < kernel.length; i++) kernel[i] /= sum;
    return kernel;
}

function gaussianBlur(labels, width, height, blur) {
    const sigma = blur / 3, size = Math.ceil(blur / 2), kernel = generateGaussianKernel1D(size, sigma), temp = new Array(labels.length).fill(0), result = new Array(labels.length).fill(0);
    for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) {
        let sum = 0;
        for (let i = -size; i <= size; i++) {
            sum += labels[y * width + Math.min(Math.max(x + i, 0), width - 1)] * kernel[i + size];
        }
        temp[y * width + x] = sum;
    }
    for (let x = 0; x < width; x++) for (let y = 0; y < height; y++) {
        let sum = 0;
        for (let i = -size; i <= size; i++) {
            sum += temp[Math.min(Math.max(y + i, 0), height - 1) * width + x] * kernel[i + size];
        }
        result[y * width + x] = Math.max(0, Math.min(1, sum));
    }
    return result;
}

function drawContour(labels, boundaryPixels, width, height, thickness = 1) {
    const result = new Array(labels.length).fill(0);
    for (const [i, j] of boundaryPixels) if (result[i * width + j] = 1, thickness > 1) for (let di = 1 - thickness; di <= thickness - 1; di++) for (let dj = 1 - thickness; dj <= thickness - 1; dj++) {
        if (Math.sqrt(di * di + dj * dj) < thickness) {
            const ni = i + di, nj = j + dj;
            ni >= 0 && ni < height && nj >= 0 && nj < width && (result[ni * width + nj] = 1);
        }
    }
    return result;
}

function removeBorder(image, canvas, isEmptyPixel) {
    canvas.width = image.width, canvas.height = image.height;
    const ctx = canvas.getContext("2d", {
        willReadFrequently: !0
    });
    ctx.clearRect(0, 0, canvas.width, canvas.height), ctx.drawImage(image, 0, 0);
    const width = canvas.width, imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    let top = 0, bottom = imageData.height, left = 0, right = imageData.width;
    const rowBlank = (width, y) => {
        for (let x = 0; x < width; ++x) if (!isEmptyPixel(imageData, y, x)) return !1;
        return !0;
    }, columnBlank = (x, y0, y1) => {
        for (let y = y0; y < y1; ++y) if (!isEmptyPixel(imageData, y, x)) return !1;
        return !0;
    };
    for (;top < bottom && rowBlank(width, top); ) ++top;
    for (;bottom - 1 > top && rowBlank(width, bottom - 1); ) --bottom;
    for (;left < right && columnBlank(left, top, bottom); ) ++left;
    for (;right - 1 > left && columnBlank(right - 1, top, bottom); ) --right;
    const trimmed = ctx.getImageData(left, top, right - left, bottom - top);
    return canvas.width = trimmed.width, canvas.height = trimmed.height, ctx.clearRect(0, 0, canvas.width, canvas.height), 
    ctx.putImageData(trimmed, 0, 0), canvas;
}

function scaleAndMiddleShape(image, size) {
    const width = image.width, height = image.height;
    let scale = size[0] / width;
    height * scale > size[1] && (scale = size[1] / height);
    const newWidth = Math.floor(scale * width), newHeight = Math.floor(scale * height);
    return {
        x: (size[0] - newWidth) / 2,
        y: (size[1] - newHeight) / 2,
        width: newWidth,
        height: newHeight,
        scale: scale
    };
}

exports.segmentation = segmentation, exports.removeBorder = removeBorder, exports.scaleAndMiddleShape = scaleAndMiddleShape;
//# sourceMappingURL=image.js.map