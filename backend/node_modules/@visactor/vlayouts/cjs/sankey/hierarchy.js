"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.computeNodeValues = exports.computeHierarchicNodeLinks = exports.makeHierarchicNodes = exports.calculateNodeValue = void 0;

const vutils_1 = require("@visactor/vutils"), calculateNodeValue = subTree => {
    let sum = 0;
    return subTree.forEach(((node, index) => {
        var _a;
        (0, vutils_1.isNil)(node.value) && ((null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) ? node.value = (0, 
        exports.calculateNodeValue)(node.children) : node.value = 0), sum += Math.abs(node.value);
    })), sum;
};

function makeHierarchicNodes(originalNodes, nodeKeyFunc, nodes = [], nodeMap = {}, originalLinks) {
    (0, exports.calculateNodeValue)(originalNodes);
    const doSubTree = (subTree, depth, parents) => {
        subTree.forEach(((node, index) => {
            const nodeKey = nodeKeyFunc ? nodeKeyFunc(node) : parents ? `${parents[parents.length - 1].key}-${index}` : `${depth}-${index}`, nodeValue = (0, 
            vutils_1.isNil)(node.value) ? 0 : (0, vutils_1.toValidNumber)(node.value);
            if (nodeMap[nodeKey]) nodeMap[nodeKey].value = void 0; else {
                const nodeElement = {
                    depth: depth,
                    datum: node,
                    index: index,
                    key: nodeKey,
                    value: nodeValue,
                    sourceLinks: [],
                    targetLinks: []
                };
                nodeMap[nodeKey] = nodeElement, nodes.push(nodeElement);
            }
            parents && originalLinks && originalLinks.push({
                source: parents[parents.length - 1].key,
                target: nodeKey,
                value: nodeValue,
                parents: parents
            }), node.children && node.children.length && doSubTree(node.children, depth + 1, parents ? parents.concat([ nodeMap[nodeKey] ]) : [ nodeMap[nodeKey] ]);
        }));
    };
    return doSubTree(originalNodes, 0, null), nodes;
}

function computeHierarchicNodeLinks(originalNodes, nodeKeyFunc) {
    const nodes = [], links = [], nodeMap = {}, linkMap = {}, originalLinks = [];
    return makeHierarchicNodes(originalNodes, nodeKeyFunc, nodes, nodeMap, originalLinks), 
    originalLinks.forEach(((link, index) => {
        const key = `${link.source}-${link.target}`, linkDatum = (0, vutils_1.pickWithout)(link, [ "parents" ]);
        if (linkDatum.parents = link.parents.map((node => (0, vutils_1.pickWithout)(node, [ "sourceLinks", "targetLinks" ]))), 
        linkMap[key]) return linkMap[key].value += (0, vutils_1.toValidNumber)(link.value), 
        void linkMap[key].datum.push(linkDatum);
        const linkElement = {
            index: index,
            key: `${link.source}-${link.target}`,
            source: link.source,
            target: link.target,
            datum: [ linkDatum ],
            value: link.value,
            parents: link.parents.map((parent => parent.key))
        };
        links.push(linkElement), nodeMap[link.source].sourceLinks.push(linkElement), nodeMap[link.target].targetLinks.push(linkElement), 
        linkMap[key] = linkElement;
    })), {
        nodes: nodes,
        links: links,
        nodeMap: nodeMap
    };
}

function computeNodeValues(nodes) {
    for (let i = 0, len = nodes.length; i < len; i++) {
        const node = nodes[i];
        node.value = Math.max((0, vutils_1.isNil)(node.value) ? 0 : (0, vutils_1.toValidNumber)(node.value), node.sourceLinks.reduce(((sum, link) => {
            var _a;
            return sum + (null !== (_a = (0, vutils_1.toValidNumber)(link.value)) && void 0 !== _a ? _a : 0);
        }), 0), node.targetLinks.reduce(((sum, link) => {
            var _a;
            return sum + (null !== (_a = (0, vutils_1.toValidNumber)(link.value)) && void 0 !== _a ? _a : 0);
        }), 0));
    }
}

exports.calculateNodeValue = calculateNodeValue, exports.makeHierarchicNodes = makeHierarchicNodes, 
exports.computeHierarchicNodeLinks = computeHierarchicNodeLinks, exports.computeNodeValues = computeNodeValues;
//# sourceMappingURL=hierarchy.js.map