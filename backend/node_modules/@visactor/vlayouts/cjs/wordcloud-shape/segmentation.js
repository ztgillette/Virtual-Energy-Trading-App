"use strict";

function allocateWords(words, segmentationOutput) {
    const {segmentation: {regions: regions}} = segmentationOutput;
    let areaMax = -1 / 0, totalArea = 0, areaMaxIndex = 0;
    regions.forEach(((region, index) => {
        const area = region.area;
        area > areaMax && (areaMax = area, areaMaxIndex = index), totalArea += area;
    }));
    let wordsSum = 0;
    regions.forEach((region => {
        const area = region.area, regionNum = Math.ceil(area / totalArea * words.length), regionWeight = area / areaMax;
        region.words = [], region.regionNum = regionNum, region.regionWeight = regionWeight, 
        wordsSum += regionNum;
    })), wordsSum < words.length && (regions[areaMaxIndex].wordsNum += words.length - wordsSum);
    let currIndex = areaMaxIndex;
    const regionNums = regions.map((region => region.regionNum));
    words.forEach((word => {
        let failCounter = 0, updateCounter = 0;
        word.regionIndex = -1;
        do {
            if (regionNums[currIndex] > 0 && word.weight <= regions[currIndex].regionWeight) {
                word.regionIndex = currIndex, regions[currIndex].words.push(word), regionNums[currIndex]--, 
                currIndex = (currIndex + 1) % regions.length;
                break;
            }
            currIndex = (currIndex + 1) % regions.length, failCounter++, updateCounter++, updateCounter > regions.length + 1 && (regions.forEach((region => {
                region.regionWeight += .15;
            })), updateCounter = 0);
        } while (-1 === word.regionIndex && failCounter < 3 * regions.length);
        -1 === word.regionIndex && (word.regionIndex = areaMaxIndex, regions[areaMaxIndex].words.push(word), 
        regionNums[areaMaxIndex]--);
    })), regions.forEach((region => {
        region.words.sort(((a, b) => b.weight - a.weight));
    }));
}

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.allocateWords = void 0, exports.allocateWords = allocateWords;
//# sourceMappingURL=segmentation.js.map
