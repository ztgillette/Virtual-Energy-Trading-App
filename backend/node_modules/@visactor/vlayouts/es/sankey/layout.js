import { clamp, clamper, field, isFunction, isNil, isNumber, isString, Logger, minInArray } from "@visactor/vutils";

import { computeHierarchicNodeLinks, computeNodeValues } from "./hierarchy";

function left(node) {
    return node.depth;
}

function right(node, maxDepth) {
    return maxDepth - 1 - node.endDepth;
}

function justify(node, maxDepth) {
    return node.sourceLinks.length ? node.depth : maxDepth - 1;
}

function center(node, maxDepth, nodeMap) {
    return node.targetLinks.length ? node.depth : node.sourceLinks.length ? minInArray(node.sourceLinks.map((link => nodeMap[link.target].depth))) - 1 : 0;
}

const ascendingNodeBreadth = (a, b) => (null == a ? void 0 : a.y0) - (null == b ? void 0 : b.y0), calcDivideValue = (node, isTarget) => {
    if (isNil(node.value)) return null;
    const res = (isTarget ? node.targetLinks : node.sourceLinks).reduce(((res, sLink) => (isNil(sLink.value) ? res.count += 1 : res.sum += sLink.value, 
    res)), {
        sum: 0,
        count: 0
    });
    return res.count > 0 ? (node.value - res.sum) / res.count : null;
}, alignFunctions = {
    left: left,
    right: right,
    justify: justify,
    center: center,
    start: left,
    end: right
}, linkClampe = clamper(0, 1);

export class SankeyLayout {
    constructor(options) {
        this._ascendingSourceBreadth = (a, b) => ascendingNodeBreadth(this._nodeMap[a.source], this._nodeMap[b.source]) || a.index - b.index, 
        this._ascendingTargetBreadth = (a, b) => ascendingNodeBreadth(this._nodeMap[a.target], this._nodeMap[b.target]) || a.index - b.index, 
        this.options = Object.assign({}, SankeyLayout.defaultOptions, options);
        const keyOption = this.options.nodeKey, keyFunc = isFunction(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
        this._getNodeKey = keyFunc, this._logger = Logger.getInstance(), this._alignFunc = isFunction(this.options.setNodeLayer) ? node => this.options.setNodeLayer(node.datum) : alignFunctions[this.options.nodeAlign];
    }
    layout(data, config) {
        if (!data) return null;
        const viewBox = "width" in config ? {
            x0: 0,
            x1: config.width,
            y0: 0,
            y1: config.height,
            width: config.width,
            height: config.height
        } : {
            x0: Math.min(config.x0, config.x1),
            x1: Math.max(config.x0, config.x1),
            y0: Math.min(config.y0, config.y1),
            y1: Math.max(config.y0, config.y1),
            width: Math.abs(config.x1 - config.x0),
            height: Math.abs(config.y1 - config.y0)
        };
        "vertical" === this.options.direction ? this._viewBox = {
            x0: viewBox.y0,
            x1: viewBox.y1,
            y0: viewBox.x0,
            y1: viewBox.x1,
            width: viewBox.height,
            height: viewBox.width
        } : this._viewBox = viewBox;
        const result = this.computeNodeLinks(data), nodes = result.nodes;
        let links = result.links;
        if (this._nodeMap = result.nodeMap, this.computeNodeValues(nodes), this.computeNodeDepths(nodes), 
        [ "right", "end", "justify" ].includes(this.options.nodeAlign) && this.computeNodeEndDepths(nodes), 
        this._maxDepth <= 0) return null;
        const columns = this.computeNodeBreadths(nodes);
        if (this.computeLinkBreadths(nodes), nodes.forEach((node => {
            node.sourceLinks = node.sourceLinks.filter((link => !isNil(link.source) && !isNil(link.target))), 
            node.targetLinks = node.targetLinks.filter((link => !isNil(link.source) && !isNil(link.target)));
        })), links = links.filter((link => !isNil(link.source) && !isNil(link.target))), 
        "vertical" === this.options.direction) if (this.options.inverse) {
            const viewY1 = this._viewBox.x1;
            nodes.forEach((node => {
                const {y0: y0, y1: y1, x0: x0, x1: x1} = node;
                node.y0 = viewY1 - x1, node.y1 = viewY1 - x0, node.x0 = y0, node.x1 = y1;
            })), links.forEach((link => {
                link.vertical = !0;
                const {x0: x0, x1: x1, y0: y0, y1: y1} = link;
                link.x0 = y0, link.x1 = y1, link.y0 = viewY1 - x0, link.y1 = viewY1 - x1;
            }));
        } else nodes.forEach((node => {
            const {y0: y0, y1: y1} = node;
            node.y0 = node.x0, node.y1 = node.x1, node.x0 = y0, node.x1 = y1;
        })), links.forEach((link => {
            link.vertical = !0;
            const x0 = link.x0, x1 = link.x1;
            link.x0 = link.y0, link.x1 = link.y1, link.y0 = x0, link.y1 = x1;
        })); else this.options.inverse && (nodes.forEach((node => {
            const {x0: x0, x1: x1} = node;
            node.x0 = viewBox.x1 - x1, node.x1 = viewBox.x1 - x0;
        })), links.forEach((link => {
            link.x0 = viewBox.x1 - link.x0, link.x1 = viewBox.x1 - link.x1;
        })));
        return links.forEach((link => {
            const sourceNode = this._nodeMap[link.source], targetNode = this._nodeMap[link.target];
            link.sourceRect = {
                x0: sourceNode.x0,
                x1: sourceNode.x1,
                y0: sourceNode.y0,
                y1: sourceNode.y1
            }, link.targetRect = {
                x0: targetNode.x0,
                x1: targetNode.x1,
                y1: targetNode.y1,
                y0: targetNode.y0
            };
        })), {
            nodes: nodes,
            links: links,
            columns: columns
        };
    }
    computeHierarchicNodeLinks(originalNodes) {
        return computeHierarchicNodeLinks(originalNodes, this._getNodeKey);
    }
    computeSourceTargetNodeLinks(data) {
        const nodes = [], links = [], nodeMap = {};
        data.nodes && data.nodes.forEach(((node, index) => {
            const nodeElement = {
                depth: -1,
                datum: node,
                index: index,
                key: this._getNodeKey ? this._getNodeKey(node) : index,
                value: node.value,
                sourceLinks: [],
                targetLinks: []
            };
            nodeMap[nodeElement.key] = nodeElement, nodes.push(nodeElement);
        }));
        const invalidLinks = [];
        return data.links.forEach(((link, index) => {
            const hasSource = !isNil(link.source), hasTarget = !isNil(link.target);
            if (data.nodes && (!nodeMap[link.source] || !nodeMap[link.target])) return;
            data.nodes || !hasSource || nodeMap[link.source] || (nodeMap[link.source] = {
                value: void 0,
                depth: -1,
                index: nodes.length,
                key: link.source,
                datum: null,
                sourceLinks: [],
                targetLinks: []
            }, nodes.push(nodeMap[link.source])), data.nodes || !hasTarget || nodeMap[link.target] || (nodeMap[link.target] = {
                value: void 0,
                depth: -1,
                index: nodes.length,
                key: link.target,
                datum: null,
                sourceLinks: [],
                targetLinks: []
            }, nodes.push(nodeMap[link.target]));
            const linkElement = {
                index: index,
                source: link.source,
                target: link.target,
                datum: link,
                value: link.value
            };
            this.options.divideNodeValueToLink && isNil(link.value) && invalidLinks.push(linkElement), 
            links.push(linkElement), hasSource && nodeMap[link.source].sourceLinks.push(linkElement), 
            hasTarget && nodeMap[link.target].targetLinks.push(linkElement);
        })), this.options.divideNodeValueToLink && invalidLinks.length && invalidLinks.forEach((link => {
            const values = [ calcDivideValue(nodeMap[link.source]), calcDivideValue(nodeMap[link.target], !0) ].filter((entry => !isNil(entry)));
            values.length && (link.value = minInArray(values));
        })), {
            nodeMap: nodeMap,
            nodes: nodes,
            links: links
        };
    }
    computeNodeLinks(data) {
        let res;
        "links" in data ? res = this.computeSourceTargetNodeLinks(data) : (this._isHierarchic = !0, 
        res = this.computeHierarchicNodeLinks(data.nodes));
        let nodes = res.nodes;
        const links = res.links;
        if (this.options.linkSortBy) for (let i = 0, len = nodes.length; i < len; i++) nodes[i].sourceLinks.sort(this.options.linkSortBy), 
        nodes[i].targetLinks.sort(this.options.linkSortBy);
        return this.options.dropIsolatedNode && (nodes = nodes.filter((node => node.targetLinks.length || node.sourceLinks.length))), 
        {
            nodes: nodes,
            links: links,
            nodeMap: res.nodeMap
        };
    }
    computeNodeValues(nodes) {
        return computeNodeValues(nodes);
    }
    computeNodeDepths(nodes) {
        var _a;
        const n = nodes.length;
        let next, nextMap, current = nodes, depth = 0, maxDepth = -1;
        const setNodeLayer = isFunction(this.options.setNodeLayer) ? this.options.setNodeLayer : null;
        for (;current.length && depth < n; ) {
            next = [], nextMap = {};
            for (let i = 0, curLen = current.length; i < curLen; i++) {
                const node = current[i];
                if (node && (node.depth = setNodeLayer && null !== (_a = setNodeLayer(node.datum)) && void 0 !== _a ? _a : depth, 
                setNodeLayer && (maxDepth = Math.max(node.depth, maxDepth)), node.sourceLinks && node.sourceLinks.length)) for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
                    const link = node.sourceLinks[j];
                    nextMap[link.target] || (next.push(this._nodeMap[link.target]), nextMap[link.target] = !0);
                }
            }
            current = next, depth += 1;
        }
        depth > n && this._logger.warn("Error: there is a circular link"), this._maxDepth = setNodeLayer ? maxDepth + 1 : depth;
    }
    computeNodeEndDepths(nodes) {
        const n = nodes.length;
        let next, nextMap, current = nodes, depth = 0;
        for (;current.length && depth < n; ) {
            next = [], nextMap = {};
            for (let i = 0, curLen = current.length; i < curLen; i++) {
                const node = current[i];
                if (node) {
                    node.endDepth = depth;
                    for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
                        const link = node.targetLinks[j];
                        nextMap[link.source] || (next.push(this._nodeMap[link.source]), nextMap[link.source] = !0);
                    }
                }
            }
            current = next, depth += 1;
        }
        depth > n && this._logger.warn("Error: there is a circular link");
    }
    computeNodeLayers(nodes) {
        const nodeWidthOption = this.options.nodeWidth, linkWidthOption = this.options.linkWidth, minStepWidth = this.options.minStepWidth, width = this._viewBox.width;
        let nodeWidth = null, linkWidth = null, isEvenWidth = !1;
        if (isString(nodeWidthOption)) {
            const ratio = clamp(parseFloat(nodeWidthOption.replace("%", "")) / 100, 0, 1);
            let stepWidth = width / (this._maxDepth - 1 + ratio);
            minStepWidth > 0 && (stepWidth = Math.max(minStepWidth, stepWidth)), nodeWidth = stepWidth * ratio, 
            linkWidth = stepWidth * (1 - ratio), isEvenWidth = !0;
        } else if (isNumber(nodeWidthOption)) {
            if (nodeWidth = nodeWidthOption, isNumber(linkWidthOption)) linkWidth = linkWidthOption; else if (isNil(linkWidthOption)) {
                let stepWidth = (width - nodeWidthOption) / (this._maxDepth - 1);
                minStepWidth > 0 && (stepWidth = Math.max(minStepWidth, stepWidth)), linkWidth = stepWidth - nodeWidthOption;
            }
            isEvenWidth = !0;
        } else isFunction(nodeWidthOption) && isNumber(linkWidthOption) && (linkWidth = linkWidthOption);
        const columns = [];
        for (let i = 0, len = nodes.length; i < len; i++) {
            const node = nodes[i];
            node.layer = this._isHierarchic ? node.depth : clamp(Math.floor(this._alignFunc(node, this._maxDepth, this._nodeMap)), 0, this._maxDepth - 1);
            const layer = node.layer;
            layer === this._maxDepth - 1 && (node.isLastLayer = !0), isEvenWidth && (node.x0 = this._viewBox.x0 + layer * (nodeWidth + linkWidth), 
            node.x1 = node.x0 + nodeWidth), columns[layer] ? columns[layer].push(node) : columns[layer] = [ node ];
        }
        if (this.options.nodeSortBy) for (let j = 0, colLen = columns.length; j < colLen; j++) columns[j].sort(this.options.nodeSortBy);
        if (!isEvenWidth && isFunction(nodeWidthOption)) {
            let curLayerX = this._viewBox.x0;
            for (let i = 0; i < this._maxDepth; i++) {
                const column = columns[i];
                let maxNodeWidth = 0, maxLinkWidth = 0;
                for (let j = 0, colLen = column && column.length; j < colLen; j++) {
                    const node = column[j], curNodeWidth = nodeWidthOption(node);
                    node.x0 = curLayerX, node.x1 = curLayerX + curNodeWidth, maxNodeWidth = Math.max(nodeWidth, curNodeWidth);
                    const sourceLinks = node.sourceLinks;
                    for (let k = 0, linkLen = sourceLinks.length; k < linkLen; k++) {
                        const link = sourceLinks[k], curLinkWidth = isFunction(linkWidthOption) ? linkWidthOption(link, this._viewBox) : linkWidth;
                        maxLinkWidth = Math.max(maxLinkWidth, curLinkWidth);
                    }
                }
                curLayerX += maxNodeWidth + maxLinkWidth;
            }
        }
        return columns;
    }
    initializeNodeBreadths(columns) {
        var _a, _b, _c;
        const minLinkHeight = null !== (_a = this.options.minLinkHeight) && void 0 !== _a ? _a : 0;
        let minNodeHeight = null !== (_b = this.options.minNodeHeight) && void 0 !== _b ? _b : 0;
        const maxNodeHeight = null !== (_c = this.options.maxNodeHeight) && void 0 !== _c ? _c : 1 / 0;
        let maxLinkHeight = this.options.maxLinkHeight;
        (isNil(minNodeHeight) || minNodeHeight < minLinkHeight) && (minNodeHeight = minLinkHeight), 
        (isNil(maxLinkHeight) || maxLinkHeight > maxNodeHeight) && (maxLinkHeight = maxNodeHeight);
        let ky = 0, getGapY = null, forceNodeHeight = null;
        if (isFunction(this.options.nodeGap)) getGapY = this.options.nodeGap, ky = columns.reduce(((val, column) => {
            const sumValue = column.reduce(((sum, node) => sum + node.value), 0), sumGapY = column.reduce(((sum, node) => sum + this.options.nodeGap(node)), 0);
            return Math.min(val, (this._viewBox.height - sumGapY) / sumValue);
        }), 1 / 0); else {
            const maxRowCount = columns.reduce(((cnt, column) => Math.max(cnt, column.length)), 0), maxStepHeight = this._viewBox.height / maxRowCount;
            let gapY = Math.min(this.options.nodeGap, maxStepHeight);
            if (minNodeHeight + gapY > maxStepHeight && (gapY = minNodeHeight >= maxStepHeight ? maxStepHeight / 2 : (maxStepHeight - minNodeHeight) / 2, 
            minNodeHeight = Math.min(maxStepHeight - gapY, minNodeHeight)), getGapY = () => gapY, 
            this._gapY = gapY, this.options.equalNodeHeight) forceNodeHeight = this._viewBox.height / maxRowCount - gapY; else {
                const calGapY = minNodeHeight > 0 ? Math.max(gapY, minNodeHeight) : gapY;
                ky = columns.reduce(((val, column) => {
                    const sumValue = column.reduce(((sum, node) => sum + node.value), 0);
                    return Math.min(val, (this._viewBox.height - ((column.length - 1) * calGapY + minNodeHeight)) / sumValue);
                }), 1 / 0);
            }
        }
        const isStartGap = "start" === this.options.gapPosition, isMiddleGap = !isStartGap && "end" !== this.options.gapPosition, getNodeHeight = isNumber(this.options.nodeHeight) ? node => this.options.nodeHeight : isFunction(this.options.nodeHeight) ? this.options.nodeHeight : forceNodeHeight > 0 ? node => forceNodeHeight : node => Math.max(node.value * ky, 0), getLinkHeight = isNumber(this.options.linkHeight) ? () => this.options.linkHeight : isFunction(this.options.linkHeight) ? this.options.linkHeight : (link, sourceNode, sourceNodeHeight) => Math.min(Math.max(sourceNode.value ? sourceNodeHeight * linkClampe(link.value / sourceNode.value) : 0, minLinkHeight, 0), maxLinkHeight);
        for (let i = 0, columnCount = columns.length; i < columnCount; i++) {
            const nodes = columns[i];
            if (!nodes || !nodes.length) continue;
            let y = this._viewBox.y0, gapY = 0, nodeHeight = 0, calculatedNodeHeight = 0;
            for (let j = 0, len = nodes.length; j < len; j++) {
                const node = nodes[j];
                gapY = getGapY(node), isStartGap && (y += gapY), calculatedNodeHeight = getNodeHeight(node), 
                nodeHeight = Math.min(Math.max(calculatedNodeHeight, minNodeHeight), maxNodeHeight), 
                node.y0 = y, node.y1 = y + nodeHeight, y = isStartGap ? node.y1 : node.y1 + gapY;
                for (let k = 0, linkLen = node.sourceLinks.length; k < linkLen; k++) {
                    const link = node.sourceLinks[k];
                    link.thickness = getLinkHeight(link, node, calculatedNodeHeight);
                }
            }
            let deltaY = this._viewBox.y1 - y + (isMiddleGap ? gapY : 0);
            if (deltaY > 0) if ("start" === this.options.crossNodeAlign) ; else if ("end" === this.options.crossNodeAlign) for (let j = 0, len = nodes.length; j < len; ++j) {
                const node = nodes[j];
                node.y0 += deltaY, node.y1 += deltaY;
            } else if ("parent" === this.options.crossNodeAlign) {
                const sourceNodes = nodes.reduce(((res, node) => (node.targetLinks && node.targetLinks.length && node.targetLinks.forEach((link => {
                    res[link.source] = !0;
                })), res)), {});
                if (Object.keys(sourceNodes).length && columns[i - 1] && columns[i - 1].length) {
                    const prevSourceNodes = columns[i - 1].filter((node => sourceNodes[node.key]));
                    if (prevSourceNodes && prevSourceNodes.length && prevSourceNodes[0].y0 !== nodes[0].y0) {
                        const newDeltaY = prevSourceNodes[0].y0 - nodes[0].y0;
                        for (let j = 0, len = nodes.length; j < len; ++j) {
                            const node = nodes[j];
                            node.y0 += newDeltaY, node.y1 += newDeltaY;
                        }
                    }
                }
            } else {
                deltaY /= nodes.length + 1;
                for (let j = 0, len = nodes.length; j < len; ++j) {
                    const node = nodes[j];
                    node.y0 += deltaY * (j + 1), node.y1 += deltaY * (j + 1);
                }
            } else if (deltaY < 0 && nodes.length > 1 && (deltaY /= nodes.length - 1, gapY + deltaY >= 0)) {
                gapY += deltaY, this._gapY = Math.min(gapY);
                for (let j = 1, len = nodes.length; j < len; ++j) {
                    const node = nodes[j];
                    node.y0 += deltaY * j, node.y1 += deltaY * j;
                }
            }
            this.reorderLinks(nodes);
        }
    }
    computeNodeBreadths(nodes) {
        const columns = this.computeNodeLayers(nodes);
        this.initializeNodeBreadths(columns);
        const iterations = this.options.iterations;
        if (!this._isHierarchic && !isFunction(this.options.setNodeLayer) && !isFunction(this.options.nodeGap)) for (let i = 0; i < iterations; ++i) {
            const alpha = Math.pow(.99, i), beta = Math.max(1 - alpha, (i + 1) / iterations);
            this.relaxRightToLeft(columns, alpha, beta), this.relaxLeftToRight(columns, alpha, beta);
        }
        return columns;
    }
    relaxLeftToRight(columns, alpha, beta) {
        for (let i = 1, n = columns.length; i < n; ++i) {
            const column = columns[i];
            for (let j = 0, colLen = column.length; j < colLen; j++) {
                const target = column[j];
                let y = 0, w = 0;
                for (let k = 0, linkLen = target.targetLinks.length; k < linkLen; k++) {
                    const link = target.targetLinks[k], v = link.value * (target.layer - this._nodeMap[link.source].layer);
                    y += this.targetTop(this._nodeMap[link.source], target) * v, w += v;
                }
                if (!(w > 0)) continue;
                const dy = (y / w - target.y0) * alpha;
                target.y0 += dy, target.y1 += dy, this.reorderNodeLinks(target);
            }
            isNil(this.options.nodeSortBy) && column.sort(ascendingNodeBreadth), this.resolveCollisions(column, beta);
        }
    }
    relaxRightToLeft(columns, alpha, beta) {
        for (let i = columns.length - 2; i >= 0; --i) {
            const column = columns[i];
            for (let j = 0, colLen = column.length; j < colLen; j++) {
                const source = column[j];
                let y = 0, w = 0;
                for (let k = 0, linkLen = source.sourceLinks.length; k < linkLen; k++) {
                    const link = source.sourceLinks[k], v = link.value * (this._nodeMap[link.target].layer - source.layer);
                    y += this.sourceTop(source, this._nodeMap[link.target]) * v, w += v;
                }
                if (!(w > 0)) continue;
                const dy = (y / w - source.y0) * alpha;
                source.y0 += dy, source.y1 += dy, this.reorderNodeLinks(source);
            }
            void 0 === this.options.nodeSortBy && column.sort(ascendingNodeBreadth), this.resolveCollisions(column, beta);
        }
    }
    resolveCollisions(nodes, alpha) {
        const i = nodes.length >> 1, subject = nodes[i];
        this.resolveCollisionsBottomToTop(nodes, subject.y0 - this._gapY, i - 1, alpha), 
        this.resolveCollisionsTopToBottom(nodes, subject.y1 + this._gapY, i + 1, alpha), 
        this.resolveCollisionsBottomToTop(nodes, this._viewBox.y1, nodes.length - 1, alpha), 
        this.resolveCollisionsTopToBottom(nodes, this._viewBox.y0, 0, alpha);
    }
    resolveCollisionsTopToBottom(nodes, y, i, alpha) {
        for (;i < nodes.length; ++i) {
            const node = nodes[i], dy = (y - node.y0) * alpha;
            dy > 1e-6 && (node.y0 += dy, node.y1 += dy), y = node.y1 + this._gapY;
        }
    }
    resolveCollisionsBottomToTop(nodes, y, i, alpha) {
        for (;i >= 0; --i) {
            const node = nodes[i], dy = (node.y1 - y) * alpha;
            dy > 1e-6 && (node.y0 -= dy, node.y1 -= dy), y = node.y0 - this._gapY;
        }
    }
    targetTop(source, target) {
        let i, len, link, y = source.y0 - (source.sourceLinks.length - 1) * this._gapY / 2;
        for (i = 0, len = source.sourceLinks.length; i < len && (link = source.sourceLinks[i], 
        link.target !== target.key); i++) y += link.thickness + this._gapY;
        for (i = 0, len = target.targetLinks.length; i < len && (link = target.targetLinks[i], 
        link.source !== source.key); i++) y -= link.thickness;
        return y;
    }
    sourceTop(source, target) {
        let i, len, link, y = target.y0 - (target.targetLinks.length - 1) * this._gapY / 2;
        for (i = 0, len = target.targetLinks.length; i < len && (link = target.targetLinks[i], 
        link.source !== source.key); i++) y += link.thickness + this._gapY;
        for (i = 0, len = source.sourceLinks.length; i < len && (link = source.sourceLinks[i], 
        link.target !== target.key); i++) y -= link.thickness;
        return y;
    }
    computeLinkBreadthsNoOverlap(nodes) {
        for (let i = 0, len = nodes.length; i < len; i++) {
            const node = nodes[i];
            let y0 = node.y0, reachBottom = !1;
            for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
                const link = node.sourceLinks[j];
                reachBottom || (link.y0 = y0 + link.thickness / 2), link.x0 = node.x1, y0 + link.thickness > node.y1 || reachBottom ? (link.y0 = node.y1 - link.thickness / 2, 
                reachBottom = !0) : y0 += link.thickness;
            }
            let y1 = node.y0;
            reachBottom = !1;
            for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
                const link = node.targetLinks[j];
                reachBottom || (link.y1 = y1 + link.thickness / 2), link.x1 = node.x0, y1 + link.thickness > node.y1 || reachBottom ? (link.y1 = node.y1 - link.thickness / 2, 
                reachBottom = !0) : y1 += link.thickness;
            }
        }
    }
    computeLinkBreadthsOverlap(nodes) {
        const linkOverlap = this.options.linkOverlap;
        for (let i = 0, len = nodes.length; i < len; i++) {
            const node = nodes[i], pos = "start" === linkOverlap ? node.y0 : "end" === linkOverlap ? node.y1 : (node.y0 + node.y1) / 2, sign = "start" === linkOverlap ? .5 : "end" === linkOverlap ? -.5 : 0;
            for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
                const link = node.sourceLinks[j];
                link.y0 = pos + sign * link.thickness, link.x0 = node.x1;
            }
            for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
                const link = node.targetLinks[j];
                link.y1 = pos + sign * link.thickness, link.x1 = node.x0;
            }
        }
    }
    computeLinkBreadths(nodes) {
        this.options.linkOverlap ? this.computeLinkBreadthsOverlap(nodes) : this.computeLinkBreadthsNoOverlap(nodes);
    }
    reorderNodeLinks(node) {
        if (isNil(this.options.linkSortBy)) {
            const targetLinks = node.targetLinks, sourceLinks = node.sourceLinks;
            for (let j = 0, linkLen = targetLinks.length; j < linkLen; j++) {
                const link = targetLinks[j];
                this._nodeMap[link.source].sourceLinks.sort(this._ascendingTargetBreadth);
            }
            for (let j = 0, linkLen = sourceLinks.length; j < linkLen; j++) {
                const link = sourceLinks[j];
                this._nodeMap[link.target].targetLinks.sort(this._ascendingSourceBreadth);
            }
        }
    }
    reorderLinks(nodes) {
        if (isNil(this.options.linkSortBy)) for (let i = 0, len = nodes.length; i < len; i++) {
            const node = nodes[i];
            node.sourceLinks.sort(this._ascendingTargetBreadth), node.targetLinks.sort(this._ascendingSourceBreadth);
        }
    }
}

SankeyLayout.defaultOptions = {
    iterations: 6,
    nodeAlign: "justify",
    direction: "horizontal",
    nodeWidth: 24,
    nodeGap: 8,
    crossNodeAlign: "middle",
    dropIsolatedNode: !0
};
//# sourceMappingURL=layout.js.map