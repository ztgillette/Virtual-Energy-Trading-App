import { isNil, pickWithout, toValidNumber } from "@visactor/vutils";

export const calculateNodeValue = subTree => {
    let sum = 0;
    return subTree.forEach(((node, index) => {
        var _a;
        isNil(node.value) && ((null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) ? node.value = calculateNodeValue(node.children) : node.value = 0), 
        sum += Math.abs(node.value);
    })), sum;
};

export function makeHierarchicNodes(originalNodes, nodeKeyFunc, nodes = [], nodeMap = {}, originalLinks) {
    calculateNodeValue(originalNodes);
    const doSubTree = (subTree, depth, parents) => {
        subTree.forEach(((node, index) => {
            const nodeKey = nodeKeyFunc ? nodeKeyFunc(node) : parents ? `${parents[parents.length - 1].key}-${index}` : `${depth}-${index}`, nodeValue = isNil(node.value) ? 0 : toValidNumber(node.value);
            if (nodeMap[nodeKey]) nodeMap[nodeKey].value = void 0; else {
                const nodeElement = {
                    depth: depth,
                    datum: node,
                    index: index,
                    key: nodeKey,
                    value: nodeValue,
                    sourceLinks: [],
                    targetLinks: []
                };
                nodeMap[nodeKey] = nodeElement, nodes.push(nodeElement);
            }
            parents && originalLinks && originalLinks.push({
                source: parents[parents.length - 1].key,
                target: nodeKey,
                value: nodeValue,
                parents: parents
            }), node.children && node.children.length && doSubTree(node.children, depth + 1, parents ? parents.concat([ nodeMap[nodeKey] ]) : [ nodeMap[nodeKey] ]);
        }));
    };
    return doSubTree(originalNodes, 0, null), nodes;
}

export function computeHierarchicNodeLinks(originalNodes, nodeKeyFunc) {
    const nodes = [], links = [], nodeMap = {}, linkMap = {}, originalLinks = [];
    return makeHierarchicNodes(originalNodes, nodeKeyFunc, nodes, nodeMap, originalLinks), 
    originalLinks.forEach(((link, index) => {
        const key = `${link.source}-${link.target}`, linkDatum = pickWithout(link, [ "parents" ]);
        if (linkDatum.parents = link.parents.map((node => pickWithout(node, [ "sourceLinks", "targetLinks" ]))), 
        linkMap[key]) return linkMap[key].value += toValidNumber(link.value), void linkMap[key].datum.push(linkDatum);
        const linkElement = {
            index: index,
            key: `${link.source}-${link.target}`,
            source: link.source,
            target: link.target,
            datum: [ linkDatum ],
            value: link.value,
            parents: link.parents.map((parent => parent.key))
        };
        links.push(linkElement), nodeMap[link.source].sourceLinks.push(linkElement), nodeMap[link.target].targetLinks.push(linkElement), 
        linkMap[key] = linkElement;
    })), {
        nodes: nodes,
        links: links,
        nodeMap: nodeMap
    };
}

export function computeNodeValues(nodes) {
    for (let i = 0, len = nodes.length; i < len; i++) {
        const node = nodes[i];
        node.value = Math.max(isNil(node.value) ? 0 : toValidNumber(node.value), node.sourceLinks.reduce(((sum, link) => {
            var _a;
            return sum + (null !== (_a = toValidNumber(link.value)) && void 0 !== _a ? _a : 0);
        }), 0), node.targetLinks.reduce(((sum, link) => {
            var _a;
            return sum + (null !== (_a = toValidNumber(link.value)) && void 0 !== _a ? _a : 0);
        }), 0));
    }
}
//# sourceMappingURL=hierarchy.js.map