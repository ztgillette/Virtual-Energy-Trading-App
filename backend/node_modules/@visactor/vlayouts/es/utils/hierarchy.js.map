{"version":3,"sources":["../src/utils/hierarchy.ts"],"names":[],"mappings":"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","file":"hierarchy.js","sourcesContent":["import { isNil, toValidNumber } from '@visactor/vutils';\nimport type { HierarchicalDatum, HierarchicalNodeElement } from '../interface/common';\nimport type { TreemapNodeElement } from '../treemap/interface';\n\nexport const calculateNodeValue = <Datum extends HierarchicalDatum, NodeElement extends HierarchicalNodeElement<Datum>>(\n  subTree: Datum[],\n  output: NodeElement[],\n  depth: number = 0,\n  flattenIndex: number = -1,\n  parent?: NodeElement,\n  getNodeKey?: (datum: Datum) => string,\n  valueField: string = 'value'\n): { sum: number; maxDepth: number; flattenIndex: number } => {\n  let sum = 0;\n  let prevFlattenIndex = flattenIndex ?? -1;\n  let maxDepth = depth;\n\n  subTree.forEach((datum, index) => {\n    const node = {\n      flattenIndex: ++prevFlattenIndex,\n      key: getNodeKey ? getNodeKey(datum) : `${parent?.key ?? ''}-${index}`,\n      maxDepth: -1,\n      depth,\n      index,\n      value: (datum as any)[valueField],\n      isLeaf: true,\n      datum: parent ? parent.datum.concat(datum) : [datum],\n      parentKey: parent?.key\n    } as NodeElement;\n\n    if (datum.children?.length) {\n      node.children = [];\n      node.isLeaf = false;\n      const res = calculateNodeValue(\n        datum.children as Datum[],\n        node.children,\n        depth + 1,\n        prevFlattenIndex,\n        node,\n        getNodeKey,\n        valueField\n      );\n      node.value = isNil((datum as any)[valueField])\n        ? res.sum\n        : Math.max(res.sum, toValidNumber((datum as any)[valueField]));\n\n      prevFlattenIndex = res.flattenIndex;\n      maxDepth = Math.max(res.maxDepth, maxDepth);\n    } else {\n      node.isLeaf = true;\n      node.value = toValidNumber((datum as any)[valueField]);\n    }\n\n    sum += Math.abs(node.value);\n    output.push(node);\n  });\n\n  return { sum, maxDepth, flattenIndex: prevFlattenIndex };\n};\n\nexport const eachBefore = <NodeElement extends HierarchicalDatum, ContextType = any>(\n  subTree: NodeElement[],\n  callback: (node: NodeElement, index?: number, parent?: NodeElement, ctx?: ContextType) => ContextType,\n  parent?: NodeElement,\n  ctx?: ContextType\n) => {\n  let ctxRes = ctx;\n\n  subTree.forEach((node, index) => {\n    ctxRes = callback(node, index, parent, ctxRes);\n    if (node.children?.length) {\n      ctxRes = eachBefore(node.children as NodeElement[], callback, node, ctxRes);\n    }\n  });\n\n  return ctx;\n};\n\nexport const eachAfter = <NodeElement extends HierarchicalDatum, ContextType = any>(\n  subTree: NodeElement[],\n  callback: (node: NodeElement, index?: number, parent?: NodeElement, ctx?: ContextType) => ContextType,\n  parent?: NodeElement,\n  ctx?: ContextType\n) => {\n  let ctxRes = ctx;\n\n  subTree.forEach((node, index) => {\n    if (node.children?.length) {\n      ctxRes = eachAfter(node.children as NodeElement[], callback, node, ctxRes);\n    }\n    ctxRes = callback(node, index, parent, ctxRes);\n  });\n\n  return ctxRes;\n};\n\nexport const flattenNodes = <T = TreemapNodeElement>(\n  nodes: TreemapNodeElement[],\n  output: T[] = [],\n  options?: {\n    maxDepth?: number;\n    callback?: (node: TreemapNodeElement) => T;\n  }\n) => {\n  const hasMaxDepth = options?.maxDepth >= 0;\n\n  nodes.forEach(node => {\n    if (!hasMaxDepth || node.depth <= options.maxDepth) {\n      output.push(options?.callback ? options.callback(node) : (node as unknown as T));\n      if (node.children) {\n        if (hasMaxDepth && node.depth === options.maxDepth) {\n          node.children = null;\n          node.isLeaf = true;\n        } else {\n          flattenNodes(node.children, output, options);\n        }\n      }\n    }\n  });\n\n  return output;\n};\n"]}