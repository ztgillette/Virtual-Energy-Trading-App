import { minInArray } from "@visactor/vutils";

import { setSize } from "../util";

import { Layout } from "./basic";

import { spirals } from "../../utils/spirals";

export class SpiralLayout extends Layout {
    preProcess() {
        const images = super.preProcess(), {imageConfig: imageConfig = {}, ratio: ratio = .45} = this.options;
        return this.calculateImageSize(images, imageConfig, ratio);
    }
    tryPlaceImage(image, size, spiralType, segmentationOutput, fixedImages, dt = 1) {
        const [width, height] = size, centerX = width / 2, centerY = height / 2, maxR = Math.sqrt(centerX ** 2 + centerY ** 2), spiral = spirals[spiralType](size);
        let dx, dy, t = -dt;
        const {segmentation: segmentation} = segmentationOutput, {labels: labels} = segmentation;
        for (;([dx, dy] = spiral(t += dt)) && !(Math.min(Math.abs(dx), Math.abs(dy)) >= maxR); ) if (dx -= image.width / 2, 
        dy -= image.height / 2, image.visible = !0, image.x = ~~(centerX + dx), image.y = ~~(centerY + dy), 
        image._left = image.x + image.padding, image._top = image.y + image.padding, image._leftWithoutPadding = image.x, 
        image._topWithoutPadding = image.y, fit(image, fixedImages)) {
            const {x: x, y: y, width: imageWidth, height: imageHeight} = image;
            let intersect = !1;
            for (let r = 0; r < imageWidth; r++) {
                for (let c = 0; c < imageHeight && y + r <= height; c++) {
                    if (x + c > width) continue;
                    if (!!!labels[(y + r) * width + (x + c)]) {
                        intersect = !0;
                        break;
                    }
                }
                if (intersect) break;
            }
            if (!intersect) {
                const corners = [ {
                    x: image.x,
                    y: image.y
                }, {
                    x: image.x + image.width,
                    y: image.y
                }, {
                    x: image.x,
                    y: image.y + image.height
                }, {
                    x: image.x + image.width,
                    y: image.y + image.height
                } ];
                let allCornersInShape = !0;
                for (const corner of corners) if (!labels[corner.y * width + corner.x]) {
                    allCornersInShape = !1;
                    break;
                }
                if (!allCornersInShape) continue;
                return !0;
            }
        }
        return !1;
    }
    doLayout(images) {
        var _a;
        const {segmentationOutput: segmentationOutput} = this, {layoutConfig: layoutConfig = {}} = this.options, size = this.options.size, {spiralType: spiralType = "archimedean", fillingTimes: fillingTimes = 4, minFillingImageSize: minFillingImageSize = 10} = layoutConfig, fixedImages = [], key = Object.keys(images[0]).find((k => k.includes("VGRAMMAR")));
        for (const image of images) image._widthWithPadding = image.width + 2 * image.padding, 
        image._heightWithPadding = image.height + 2 * image.padding, image.frequency = 1, 
        this.tryPlaceImage(image, size, spiralType, segmentationOutput, fixedImages) && fixedImages.push(image);
        const minImageWidth = minInArray(fixedImages, ((a, b) => a.width - b.width)).width, minImageHeight = minInArray(fixedImages, ((a, b) => a.height - b.height)).height, fixedFillingImages = [];
        for (let i = 0; i < fillingTimes; i++) {
            const minWidth = .5 * minImageWidth - 1 * i, minHeight = .5 * minImageHeight - 1 * i;
            for (const image of images) {
                const fillingImage = Object.assign({}, image, {
                    visible: !0
                }), imageSize = Math.max(minFillingImageSize, fillingImage.aspectRatio > 1 ? minWidth : minHeight);
                setSize(fillingImage, imageSize), fillingImage._widthWithPadding = fillingImage.width + 2 * fillingImage.padding, 
                fillingImage._heightWithPadding = fillingImage.height + 2 * fillingImage.padding, 
                this.tryPlaceImage(fillingImage, size, spiralType, segmentationOutput, [ ...fixedFillingImages, ...fixedImages ], .5) && (image._tempFrequency = (null !== (_a = image._tempFrequency) && void 0 !== _a ? _a : image.frequency) + 1, 
                fillingImage.frequency = image._tempFrequency, fillingImage.distance = Math.sqrt(Math.pow(fillingImage.x - size[0] / 2, 2) + Math.pow(fillingImage.y - size[1] / 2, 2)), 
                fillingImage[key] = `${fillingImage[key]}_${fillingImage.frequency}`, fixedFillingImages.push(fillingImage));
            }
        }
        return [ ...fixedImages, ...fixedFillingImages ].filter((image => image.visible));
    }
}

function fit(image, fixedImages) {
    for (let i = 0; i < fixedImages.length; i++) if (isOverlap(image, fixedImages[i])) return !1;
    return !0;
}

function isOverlap(a, b) {
    return !(a._leftWithoutPadding + a._widthWithPadding < b._leftWithoutPadding || a._topWithoutPadding + a._heightWithPadding < b._topWithoutPadding || a._leftWithoutPadding > b._leftWithoutPadding + b._widthWithPadding || a._topWithoutPadding > b._topWithoutPadding + b._heightWithPadding);
}
//# sourceMappingURL=spiral.js.map
