import { setSizeByShortSide } from "../../util";

import { Layout } from "../basic";

import { rectGridLayout } from "./rectGrid";

import { circleGridLayout } from "./circlGrid";

import { hexagonalGridLayout } from "./hexagonalGrid";

import { pickWithout } from "@visactor/vutils";

const cellLayout = {
    rect: rectGridLayout,
    circle: circleGridLayout,
    hexagonal: hexagonalGridLayout
};

export class GridLayout extends Layout {
    preProcess() {
        var _a;
        const images = super.preProcess(), {layoutConfig: layoutConfig = {}} = this.options, {cellType: cellType = "rect"} = layoutConfig, layoutResult = (null !== (_a = cellLayout[cellType]) && void 0 !== _a ? _a : cellLayout.rect)(this.options), {context: context, imageLength: shortSideLength} = layoutResult;
        return images.forEach((img => setSizeByShortSide(img, shortSideLength))), context.cellInfo.sort(((cellA, cellB) => cellA.distance - cellB.distance)), 
        this.layoutContext = context, images;
    }
    doLayout(images) {
        const {cellWidth: cellWidth, cellHeight: cellHeight, cellInfo: cellInfo, cellCount: cellCount, clipPath: clipPath, eachPixel: eachPixel, cellPixelCount: cellPixelCount} = this.layoutContext;
        if (0 === images.length || 0 === cellCount || 0 === cellWidth || 0 === cellHeight || 0 === cellInfo.length) return void (this.isLayoutFinished = !0);
        const {segmentationOutput: segmentationOutput} = this, {layoutConfig: layoutConfig = {}} = this.options, {placement: placement = "default"} = layoutConfig;
        if ("edge" === placement || "default" === placement) {
            const {segmentation: segmentation} = segmentationOutput, {labels: labels} = segmentation;
            cellInfo.forEach((cell => {
                let intersectPixelCount = 0;
                eachPixel(cell, (index => {
                    labels[index] && intersectPixelCount++;
                })), cell.intersectPixels = intersectPixelCount;
            }));
        }
        const imageCount = images.length, imageVisible = cell => {
            const {intersectPixels: intersectPixels} = cell;
            return "default" === placement ? intersectPixels >= .45 * cellPixelCount : "edge" !== placement || intersectPixels > .1 * cellPixelCount && intersectPixels < cellPixelCount;
        };
        for (let i = 0; i < imageCount; i++) {
            const image = images[i], cell = cellInfo[i];
            cell && (image.x = cell.centerX - image.width / 2, image.y = cell.centerY - image.height / 2, 
            image.clipConfig = {
                shape: clipPath
            }, image.frequency = 1, image.visible = imageVisible(cell), image.cell = pickWithout(cell, [ "image" ]), 
            image.distance = cell.distance, cell.image = image);
        }
        const key = Object.keys(images[0]).find((k => k.includes("VGRAMMAR")));
        if (imageCount < cellCount) for (let i = imageCount; i < cellCount; i++) {
            const image = images[i - imageCount], cell = cellInfo[i];
            if (cell) {
                const repeatImage = Object.assign({}, image);
                repeatImage.x = cell.centerX - repeatImage.width / 2, repeatImage.y = cell.centerY - repeatImage.height / 2, 
                repeatImage.frequency += 1, repeatImage[key] = `${repeatImage[key]}_${repeatImage.frequency}`, 
                repeatImage.visible = imageVisible(cell), repeatImage.distance = cell.distance, 
                repeatImage.cell = pickWithout(cell, [ "image" ]), cell.image = repeatImage, images.push(repeatImage);
            }
        }
        return images.filter((img => img.visible));
    }
}
//# sourceMappingURL=grid.js.map
