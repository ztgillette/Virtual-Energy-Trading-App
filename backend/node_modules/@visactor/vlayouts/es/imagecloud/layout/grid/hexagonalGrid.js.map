{"version":3,"sources":["../src/imagecloud/layout/grid/hexagonalGrid.ts"],"names":[],"mappings":"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","file":"hexagonalGrid.js","sourcesContent":["import type { GridLayoutCellType, ImageCloudOptions } from '../../interface';\n\nexport function hexagonalGridLayout(options: ImageCloudOptions) {\n  const { imageConfig = {}, size, ratio = 0.1, layoutConfig = {} } = options;\n  const { padding = 0, imageSize } = imageConfig;\n  const [width, height] = size as [number, number];\n  const center = { x: width / 2, y: height / 2 };\n  // 六边形外接圆半径\n  let radius;\n  if (imageSize) {\n    radius = imageSize / 2;\n  } else {\n    radius = (Math.min(width, height) * ratio) / 2;\n  }\n  if (radius - padding <= 0) {\n    radius = padding + 1;\n  }\n\n  const points: { x: number; y: number }[] = [];\n  const sides = 6;\n  const step = (2 * Math.PI) / sides;\n  for (let i = 0; i < sides; i++) {\n    const angle = step * i;\n    points.push({\n      x: (radius - padding / 2) * Math.cos(angle),\n      y: (radius - padding / 2) * Math.sin(angle)\n    });\n  }\n  const diameter = radius * 2;\n  const edgeLength = Math.sin(Math.PI / sides) * diameter;\n  const cellHeight = Math.sqrt(3) * edgeLength;\n  const gridSpaceX = diameter - edgeLength / 2;\n  const gridSpaceY = Math.cos(Math.PI / sides) * diameter;\n  const gridOffsetY = gridSpaceY / 2;\n  const rows = Math.floor(height / cellHeight);\n  const cols = Math.floor(width / edgeLength);\n  const cellInfo: GridLayoutCellType[] = [];\n\n  for (let r = -1; r <= rows + 1; r++) {\n    for (let c = -1; c <= cols; c++) {\n      // 计算六边形中心坐标\n      const centerX = c * gridSpaceX;\n      const centerY = r * gridSpaceY + (c % 2 ? gridOffsetY : 0);\n      cellInfo.push({\n        centerX,\n        centerY,\n        x: centerX - edgeLength,\n        y: centerY - edgeLength,\n        row: r,\n        col: c,\n        // 计算与中心点的距离\n        distance: Math.sqrt(Math.pow(centerX - center.x, 2) + Math.pow(centerY - center.y, 2))\n      });\n    }\n  }\n\n  let cellPixelCount = 0;\n  const pixelMap: boolean[] = [];\n  for (let r = 0; r <= cellHeight; r++) {\n    for (let c = 0; c <= edgeLength * 2; c++) {\n      // 判断点(c,r)是否在六边形内\n      const px = c - edgeLength; // 相对于六边形中心的x坐标\n      const py = r - cellHeight / 2; // 相对于六边形中心的y坐标\n      // 使用六边形的数学性质：点到中心的投影在六条边上的投影范围内\n      const q2x = Math.abs(px);\n      const q2y = Math.abs(py);\n      const isInside = q2x <= edgeLength && q2y <= cellHeight / 2 && 2 * q2y + q2x * Math.sqrt(3) <= cellHeight;\n\n      if (isInside) {\n        cellPixelCount++;\n        pixelMap.push(true);\n      } else {\n        pixelMap.push(false);\n      }\n    }\n  }\n\n  const context = Object.assign({}, layoutConfig, {\n    cellHexSideLength: edgeLength,\n    cellHexPoints: points,\n    cellHeight,\n    cellWidth: edgeLength * 2,\n    cellInfo,\n    cellCount: cellInfo.length,\n    cellType: 'hexagonal',\n    cellPixelCount,\n    eachPixel: (cell: GridLayoutCellType, callback: (...args: any) => void) => {\n      const { x, y } = cell;\n      // 遍历六边形外接矩形内的所有点\n      let index = 0;\n      for (let r = 0; r <= cellHeight; r++) {\n        for (let c = 0; c <= edgeLength * 2; c++) {\n          if (pixelMap[index++]) {\n            callback((~~y + r) * width + (~~x + c));\n          }\n        }\n      }\n    },\n    clipPath: `M 1 0 L 0.5 0.866 L -0.5 0.866 L -1 0 L -0.5 -0.866 L 0.5 -0.866 Z`\n  });\n  return { context, imageLength: diameter - padding };\n}\n"]}