export function hexagonalGridLayout(options) {
    const {imageConfig: imageConfig = {}, size: size, ratio: ratio = .1, layoutConfig: layoutConfig = {}} = options, {padding: padding = 0, imageSize: imageSize} = imageConfig, [width, height] = size, center_x = width / 2, center_y = height / 2;
    let radius;
    radius = imageSize ? imageSize / 2 : Math.min(width, height) * ratio / 2, radius - padding <= 0 && (radius = padding + 1);
    const points = [], step = 2 * Math.PI / 6;
    for (let i = 0; i < 6; i++) {
        const angle = step * i;
        points.push({
            x: (radius - padding / 2) * Math.cos(angle),
            y: (radius - padding / 2) * Math.sin(angle)
        });
    }
    const diameter = 2 * radius, edgeLength = Math.sin(Math.PI / 6) * diameter, cellHeight = Math.sqrt(3) * edgeLength, gridSpaceX = diameter - edgeLength / 2, gridSpaceY = Math.cos(Math.PI / 6) * diameter, gridOffsetY = gridSpaceY / 2, rows = Math.floor(height / cellHeight), cols = Math.floor(width / edgeLength), cellInfo = [];
    for (let r = -1; r <= rows + 1; r++) for (let c = -1; c <= cols; c++) {
        const centerX = c * gridSpaceX, centerY = r * gridSpaceY + (c % 2 ? gridOffsetY : 0);
        cellInfo.push({
            centerX: centerX,
            centerY: centerY,
            x: centerX - edgeLength,
            y: centerY - edgeLength,
            row: r,
            col: c,
            distance: Math.sqrt(Math.pow(centerX - center_x, 2) + Math.pow(centerY - center_y, 2))
        });
    }
    let cellPixelCount = 0;
    const pixelMap = [];
    for (let r = 0; r <= cellHeight; r++) for (let c = 0; c <= 2 * edgeLength; c++) {
        const px = c - edgeLength, py = r - cellHeight / 2, q2x = Math.abs(px), q2y = Math.abs(py);
        q2x <= edgeLength && q2y <= cellHeight / 2 && 2 * q2y + q2x * Math.sqrt(3) <= cellHeight ? (cellPixelCount++, 
        pixelMap.push(!0)) : pixelMap.push(!1);
    }
    return {
        context: Object.assign({}, layoutConfig, {
            cellHexSideLength: edgeLength,
            cellHexPoints: points,
            cellHeight: cellHeight,
            cellWidth: 2 * edgeLength,
            cellInfo: cellInfo,
            cellCount: cellInfo.length,
            cellType: "hexagonal",
            cellPixelCount: cellPixelCount,
            eachPixel: (cell, callback) => {
                const {x: x, y: y} = cell;
                let index = 0;
                for (let r = 0; r <= cellHeight; r++) for (let c = 0; c <= 2 * edgeLength; c++) pixelMap[index++] && callback((~~y + r) * width + (~~x + c));
            },
            clipPath: "M 1 0 L 0.5 0.866 L -0.5 0.866 L -1 0 L -0.5 -0.866 L 0.5 -0.866 Z"
        }),
        imageLength: diameter - padding
    };
}
//# sourceMappingURL=hexagonalGrid.js.map
