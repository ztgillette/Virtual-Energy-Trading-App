{"version":3,"sources":["../src/imagecloud/layout/basic.ts"],"names":[],"mappings":"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","file":"basic.js","sourcesContent":["import type {\n  GridLayoutConfig,\n  ImageCloudOptions,\n  ImageCollageType,\n  ImageConfig,\n  ImageCloudSegmentationOutputType\n} from '../interface';\nimport { extent, fakeRandom, field, isString, Logger, simpleField, isNumber, isFunction } from '@visactor/vutils';\nimport { setSize } from '../util';\nimport { SqrtScale } from '@visactor/vscale';\nimport type { SegmentationInputType } from '../../interface/wordcloud';\nimport {\n  generateIsEmptyPixel,\n  generateMaskCanvas,\n  removeBorder,\n  scaleAndMiddleShape,\n  segmentation\n} from '../../utils/image';\nimport { loadImage, loadImages } from '../../utils/loader';\n\nexport abstract class Layout {\n  options: ImageCloudOptions;\n  data: any[];\n\n  protected isMaskImageFinished?: boolean;\n  protected isImagesFinished?: boolean;\n  protected isLayoutFinished?: boolean;\n  protected progressiveResult?: any[] = [];\n  protected segmentationInput?: SegmentationInputType;\n  protected segmentationOutput?: ImageCloudSegmentationOutputType;\n\n  protected imageCollageList?: ImageCollageType[] = [];\n\n  abstract doLayout(images: ImageCollageType[]): ImageCollageType[];\n\n  constructor(options: ImageCloudOptions) {\n    this.options = options;\n  }\n\n  /**\n   * 预处理计算\n   * @returns 按照权重排列的所有有效图片\n   */\n  preProcess() {\n    const { imageConfig = {}, weight } = this.options;\n    const { padding = 0 } = imageConfig;\n    let images = this.imageCollageList;\n    images.forEach((img, index) => {\n      if (img.valid === false) {\n        img.x = -10;\n        img.y = -10;\n        img.width = 0;\n        img.height = 0;\n        img.opacity = 0;\n      } else {\n        img.padding = padding;\n        img.weight = simpleField(weight)(this.data[index]);\n        img.datum = this.data[index];\n      }\n    });\n\n    // 去除怀链导致的无效图\n    images = images.filter(img => img.valid !== false).sort((a, b) => b.weight - a.weight);\n\n    return images;\n  }\n\n  onImageCollageInputReady(images: any): void {\n    images.forEach((img: any, i: number) => {\n      if (img.status === 'fulfilled') {\n        const imageElement = img.value;\n        const { width, height } = imageElement;\n        this.imageCollageList.push(Object.assign({}, this.data[i], { aspectRatio: width / height }));\n      } else {\n        //  对加载失败的图片设为不可用\n        this.imageCollageList.push(Object.assign({}, this.data[i], { valid: false }));\n      }\n    });\n  }\n\n  layout(data: any[]) {\n    this.data = data;\n    this.loadSegmentationInput();\n    this.loadImageCollageInput();\n  }\n\n  loadSegmentationInput() {\n    const options = this.options;\n    const size = options.size as [number, number];\n    /** 根据shapeUrl, 计算segmentation */\n    const segmentationInput: SegmentationInputType = {\n      shapeUrl: options.mask ?? { type: 'geometric', shape: 'rect' },\n      size: size,\n      ratio: options.ratio || 0.8,\n      tempCanvas: undefined,\n      boardSize: [0, 0],\n      random: false,\n      randomGenerator: undefined,\n      blur: options.maskConfig?.edgeBlur\n    };\n\n    // 全局共用的临时画板，此处需要对小程序的 canvas 进行兼容\n    const tempCanvas = this.options.createCanvas({ width: size[0], height: size[1] });\n    const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });\n    tempCtx.textAlign = 'center';\n    tempCtx.textBaseline = 'middle';\n    segmentationInput.tempCanvas = tempCanvas;\n\n    // board 的宽必须为 32 的倍数\n    const boardW = ((size[0] + 31) >> 5) << 5;\n    segmentationInput.boardSize = [boardW, size[1]];\n\n    // 用于随机的随机数生成器\n    if (segmentationInput.random) {\n      segmentationInput.randomGenerator = Math.random;\n    } else {\n      segmentationInput.randomGenerator = fakeRandom();\n    }\n    this.segmentationInput = segmentationInput;\n    if (isString(segmentationInput.shapeUrl)) {\n      segmentationInput.isEmptyPixel = generateIsEmptyPixel(\n        undefined,\n        {\n          threshold: options.maskConfig?.threshold ?? 200,\n          invert: options.maskConfig?.invert\n        },\n        this.options.createCanvas\n      );\n      const imagePromise = loadImage(segmentationInput.shapeUrl, this.options.createImage);\n\n      if (imagePromise) {\n        this.isMaskImageFinished = false;\n        this.isLayoutFinished = false;\n        imagePromise\n          .then(shapeImage => {\n            this.isMaskImageFinished = true;\n            const size = options.size as [number, number];\n            const maskCanvas = this.options.createCanvas({\n              width: size[0],\n              height: size[1],\n              dpr: 1\n            }) as unknown as HTMLCanvasElement;\n            segmentationInput.maskCanvas = maskCanvas;\n            const ctx = maskCanvas.getContext('2d');\n            if (options.maskConfig?.removeWhiteBorder) {\n              removeBorder(shapeImage, maskCanvas, segmentationInput.isEmptyPixel);\n            }\n            const shapeConfig = scaleAndMiddleShape(shapeImage, size);\n            ctx.clearRect(0, 0, size[0], size[1]);\n            ctx.drawImage(shapeImage as any, shapeConfig.x, shapeConfig.y, shapeConfig.width, shapeConfig.height);\n\n            this.segmentationOutput = segmentation(this.segmentationInput);\n\n            let transparentMaskCanvas;\n            if ((this.options.layoutConfig as GridLayoutConfig)?.placement === 'masked') {\n              transparentMaskCanvas = this.generateTransparentMaskCanvas(shapeImage, size);\n            }\n            this.segmentationOutput.transparentMaskCanvas = transparentMaskCanvas;\n\n            if (this.options.onUpdateMaskCanvas) {\n              this.options.onUpdateMaskCanvas(maskCanvas, transparentMaskCanvas);\n            }\n          })\n          .catch(error => {\n            this.isMaskImageFinished = true;\n          });\n      } else {\n        this.isMaskImageFinished = true;\n        this.isLayoutFinished = true;\n      }\n    } else if (\n      segmentationInput.shapeUrl &&\n      (segmentationInput.shapeUrl.type === 'text' || segmentationInput.shapeUrl.type === 'geometric')\n    ) {\n      segmentationInput.isEmptyPixel = generateIsEmptyPixel(\n        segmentationInput.shapeUrl.backgroundColor,\n        undefined,\n        this.options.createCanvas\n      );\n\n      if (segmentationInput.shapeUrl.type === 'text' || segmentationInput.shapeUrl.type === 'geometric') {\n        if (!segmentationInput.shapeUrl.backgroundColor) {\n          segmentationInput.shapeUrl.backgroundColor = 'rgba(255,255,255,255)';\n        }\n      }\n\n      const maskCanvas = generateMaskCanvas(\n        segmentationInput.shapeUrl,\n        size[0],\n        size[1],\n        undefined,\n        options.maskConfig?.invert,\n        this.options.createCanvas\n      ) as HTMLCanvasElement;\n      segmentationInput.maskCanvas = maskCanvas;\n      this.segmentationOutput = segmentation(this.segmentationInput);\n\n      if (this.options.onUpdateMaskCanvas) {\n        this.options.onUpdateMaskCanvas(maskCanvas, maskCanvas);\n      }\n      this.isMaskImageFinished = true;\n    }\n  }\n\n  loadImageCollageInput() {\n    const data = this.data;\n    const imagesPromise = loadImages(\n      data.map(d => simpleField(this.options.image)(d)),\n      this.options.createImage\n    );\n    if (imagesPromise) {\n      imagesPromise\n        .then((images: any[]) => {\n          this.onImageCollageInputReady(images);\n          this.isImagesFinished = true;\n        })\n        .catch(error => {\n          this.isImagesFinished = true;\n          this.isLayoutFinished = true;\n          Logger.getInstance().error('image load failed', error);\n        });\n    } else {\n      this.isImagesFinished = true;\n      this.isLayoutFinished = true;\n    }\n  }\n\n  canAnimate() {\n    return true;\n  }\n\n  unfinished(): boolean {\n    return !this.isLayoutFinished;\n  }\n\n  output(): any[] {\n    return this.progressiveResult;\n  }\n\n  progressiveRun() {\n    if (this.isImagesFinished && this.isMaskImageFinished && !this.isLayoutFinished) {\n      const images = this.preProcess();\n      const layoutResult = this.doLayout(images);\n      if (this.options && this.options.onLayoutEnd) {\n        this.options.onLayoutEnd(layoutResult);\n      }\n      this.progressiveResult = this.processOutput(layoutResult);\n      this.isLayoutFinished = true;\n    } else {\n      return;\n    }\n  }\n\n  progressiveOutput(): any[] {\n    return this.progressiveResult;\n  }\n\n  release() {\n    this.segmentationInput = null;\n    this.data = null;\n    this.progressiveResult = null;\n    this.options = null;\n  }\n\n  protected calculateImageSize(images: ImageCollageType[], imageConfig: ImageConfig = {}, ratio: number = 0.45) {\n    const { imageSizeRange, padding = 0 } = imageConfig;\n    const imageSize = isNumber(imageConfig.imageSize) ? imageConfig.imageSize : field(imageConfig.imageSize);\n    const size = this.options.size as [number, number];\n\n    if (!imageSize && !imageSizeRange) {\n      // 用户没有设置图片大小，则自动计算一个统一的大小\n      const imageArea = images.reduce((prev, pic) => {\n        const r = pic.aspectRatio;\n        return prev + (r > 1 ? 1 / r : r);\n      }, 0);\n      let longSideLength = ~~Math.sqrt((ratio * size[0] * size[1]) / imageArea);\n      // 减掉 padding 的影响\n      longSideLength = longSideLength - 2 * padding < 0 ? 1 : longSideLength - 2 * padding;\n      images.forEach(img => setSize(img, longSideLength));\n    } else if (imageSize && !isFunction(imageSize)) {\n      // 用户指定了统一的图片大小\n      images.forEach(img => setSize(img, imageSize));\n    } else if (imageSizeRange) {\n      // 用户指定了图片大小的范围\n      const sizeScale = new SqrtScale().domain(extent(images, d => d.weight)).range(imageSizeRange);\n      images.forEach(img => setSize(img, ~~sizeScale.scale(img.weight)));\n    } else if (imageSize && isFunction(imageSize) && !imageSizeRange) {\n      // 用户没指定图片大小范围，但指定了图片大小的对应的 key\n      const a = 0.5;\n      const [min, max] = extent(images, d => d.weight);\n      const picArea = images.reduce((prev, img) => {\n        const r = img.aspectRatio;\n        const w = (img.weight - min) / (max - min);\n        return prev + (r > 1 ? 1 / r : r) * (a + (1 - a) * w) ** 2;\n      }, 0);\n      const x = ~~Math.sqrt((ratio * size[0] * size[1]) / picArea);\n      const range = [\n        ~~(a * x) - padding * 2 < 0 ? 1 : ~~(a * x) - padding * 2,\n        ~~x - padding * 2 < 0 ? 1 : ~~x - padding * 2\n      ];\n\n      const sizeScale = new SqrtScale().domain(extent(images, d => d.weight)).range(range);\n      images.forEach(img => setSize(img, ~~sizeScale.scale(img.weight)));\n    } else {\n      console.warn('image cloud imageSize error');\n    }\n\n    return images;\n  }\n\n  protected generateTransparentMaskCanvas(shapeImage: any, size: [number, number]) {\n    const transparentMaskCanvas = this.options.createCanvas({\n      width: size[0],\n      height: size[1],\n      dpr: 1\n    }) as unknown as HTMLCanvasElement;\n    const transparentMaskContext = transparentMaskCanvas.getContext('2d');\n    this.segmentationOutput.transparentMaskCanvas = transparentMaskCanvas;\n    if (this.options.maskConfig?.removeWhiteBorder) {\n      removeBorder(shapeImage, transparentMaskCanvas, this.segmentationInput.isEmptyPixel);\n    }\n    const imageData = transparentMaskContext.createImageData(size[0], size[1]); // 宽度和高度\n    const labels = this.segmentationOutput.segmentation.labels;\n    for (let i = 0; i < labels.length; i++) {\n      const color = labels[i] === 0 ? 255 : 0; // 0 为白色 (255, 255, 255)，1 为黑色 (0, 0, 0)\n      const alpha = labels[i] * 255; // 0 为透明 (0)，1 为不透明 (255)\n      // 每个像素在 ImageData 中占 4 个字节 (RGBA)\n      const pixelIndex = i * 4;\n      imageData.data[pixelIndex] = color; // 红色通道\n      imageData.data[pixelIndex + 1] = color; // 绿色通道\n      imageData.data[pixelIndex + 2] = color; // 蓝色通道\n      imageData.data[pixelIndex + 3] = alpha; // Alpha 通道\n    }\n    transparentMaskContext.clearRect(0, 0, size[0], size[1]);\n    transparentMaskContext.fillStyle = `rgba(255,255,255,0)`;\n    transparentMaskContext.fillRect(0, 0, size[0], size[1]);\n    transparentMaskContext.putImageData(imageData, 0, 0);\n    return transparentMaskCanvas;\n  }\n\n  protected processOutput(images: ImageCollageType[]) {\n    const outputAs = this.options?.as;\n    if (outputAs) {\n      Object.keys(outputAs).forEach(key => {\n        images.forEach(img => {\n          img[(outputAs as Record<string, string>)[key]] = img[key];\n          delete img[key];\n        });\n      });\n    }\n    return images;\n  }\n}\n"]}