import { extent, fakeRandom, field, isString, Logger, simpleField, isNumber, isFunction } from "@visactor/vutils";

import { setSize } from "../util";

import { SqrtScale } from "@visactor/vscale";

import { generateIsEmptyPixel, generateMaskCanvas, removeBorder, scaleAndMiddleShape, segmentation } from "../../utils/image";

import { loadImage, loadImages } from "../../utils/loader";

export class Layout {
    constructor(options) {
        this.progressiveResult = [], this.imageCollageList = [], this.options = options;
    }
    preProcess() {
        const {imageConfig: imageConfig = {}, weight: weight} = this.options, {padding: padding = 0} = imageConfig;
        let images = this.imageCollageList;
        return images.forEach(((img, index) => {
            !1 === img.valid ? (img.x = -10, img.y = -10, img.width = 0, img.height = 0, img.opacity = 0) : (img.padding = padding, 
            img.weight = simpleField(weight)(this.data[index]), img.datum = this.data[index]);
        })), images = images.filter((img => !1 !== img.valid)).sort(((a, b) => b.weight - a.weight)), 
        images;
    }
    onImageCollageInputReady(images) {
        images.forEach(((img, i) => {
            if ("fulfilled" === img.status) {
                const imageElement = img.value, {width: width, height: height} = imageElement;
                this.imageCollageList.push(Object.assign({}, this.data[i], {
                    aspectRatio: width / height
                }));
            } else this.imageCollageList.push(Object.assign({}, this.data[i], {
                valid: !1
            }));
        }));
    }
    layout(data) {
        this.data = data, this.loadSegmentationInput(), this.loadImageCollageInput();
    }
    loadSegmentationInput() {
        var _a, _b, _c, _d, _e, _f;
        const options = this.options, size = options.size, segmentationInput = {
            shapeUrl: null !== (_a = options.mask) && void 0 !== _a ? _a : {
                type: "geometric",
                shape: "rect"
            },
            size: size,
            ratio: options.ratio || .8,
            tempCanvas: void 0,
            boardSize: [ 0, 0 ],
            random: !1,
            randomGenerator: void 0,
            blur: null === (_b = options.maskConfig) || void 0 === _b ? void 0 : _b.edgeBlur
        }, tempCanvas = this.options.createCanvas({
            width: size[0],
            height: size[1]
        }), tempCtx = tempCanvas.getContext("2d", {
            willReadFrequently: !0
        });
        tempCtx.textAlign = "center", tempCtx.textBaseline = "middle", segmentationInput.tempCanvas = tempCanvas;
        const boardW = size[0] + 31 >> 5 << 5;
        if (segmentationInput.boardSize = [ boardW, size[1] ], segmentationInput.random ? segmentationInput.randomGenerator = Math.random : segmentationInput.randomGenerator = fakeRandom(), 
        this.segmentationInput = segmentationInput, isString(segmentationInput.shapeUrl)) {
            segmentationInput.isEmptyPixel = generateIsEmptyPixel(void 0, {
                threshold: null !== (_d = null === (_c = options.maskConfig) || void 0 === _c ? void 0 : _c.threshold) && void 0 !== _d ? _d : 200,
                invert: null === (_e = options.maskConfig) || void 0 === _e ? void 0 : _e.invert
            }, this.options.createCanvas);
            const imagePromise = loadImage(segmentationInput.shapeUrl, this.options.createImage);
            imagePromise ? (this.isMaskImageFinished = !1, this.isLayoutFinished = !1, imagePromise.then((shapeImage => {
                var _a, _b;
                this.isMaskImageFinished = !0;
                const size = options.size, maskCanvas = this.options.createCanvas({
                    width: size[0],
                    height: size[1],
                    dpr: 1
                });
                segmentationInput.maskCanvas = maskCanvas;
                const ctx = maskCanvas.getContext("2d");
                (null === (_a = options.maskConfig) || void 0 === _a ? void 0 : _a.removeWhiteBorder) && removeBorder(shapeImage, maskCanvas, segmentationInput.isEmptyPixel);
                const shapeConfig = scaleAndMiddleShape(shapeImage, size);
                let transparentMaskCanvas;
                ctx.clearRect(0, 0, size[0], size[1]), ctx.drawImage(shapeImage, shapeConfig.x, shapeConfig.y, shapeConfig.width, shapeConfig.height), 
                this.segmentationOutput = segmentation(this.segmentationInput), "masked" === (null === (_b = this.options.layoutConfig) || void 0 === _b ? void 0 : _b.placement) && (transparentMaskCanvas = this.generateTransparentMaskCanvas(shapeImage, size)), 
                this.segmentationOutput.transparentMaskCanvas = transparentMaskCanvas, this.options.onUpdateMaskCanvas && this.options.onUpdateMaskCanvas(maskCanvas, transparentMaskCanvas);
            })).catch((error => {
                this.isMaskImageFinished = !0;
            }))) : (this.isMaskImageFinished = !0, this.isLayoutFinished = !0);
        } else if (segmentationInput.shapeUrl && ("text" === segmentationInput.shapeUrl.type || "geometric" === segmentationInput.shapeUrl.type)) {
            segmentationInput.isEmptyPixel = generateIsEmptyPixel(segmentationInput.shapeUrl.backgroundColor, void 0, this.options.createCanvas), 
            "text" !== segmentationInput.shapeUrl.type && "geometric" !== segmentationInput.shapeUrl.type || segmentationInput.shapeUrl.backgroundColor || (segmentationInput.shapeUrl.backgroundColor = "rgba(255,255,255,255)");
            const maskCanvas = generateMaskCanvas(segmentationInput.shapeUrl, size[0], size[1], void 0, null === (_f = options.maskConfig) || void 0 === _f ? void 0 : _f.invert, this.options.createCanvas);
            segmentationInput.maskCanvas = maskCanvas, this.segmentationOutput = segmentation(this.segmentationInput), 
            this.options.onUpdateMaskCanvas && this.options.onUpdateMaskCanvas(maskCanvas, maskCanvas), 
            this.isMaskImageFinished = !0;
        }
    }
    loadImageCollageInput() {
        const data = this.data, imagesPromise = loadImages(data.map((d => simpleField(this.options.image)(d))), this.options.createImage);
        imagesPromise ? imagesPromise.then((images => {
            this.onImageCollageInputReady(images), this.isImagesFinished = !0;
        })).catch((error => {
            this.isImagesFinished = !0, this.isLayoutFinished = !0, Logger.getInstance().error("image load failed", error);
        })) : (this.isImagesFinished = !0, this.isLayoutFinished = !0);
    }
    canAnimate() {
        return !0;
    }
    unfinished() {
        return !this.isLayoutFinished;
    }
    output() {
        return this.progressiveResult;
    }
    progressiveRun() {
        if (this.isImagesFinished && this.isMaskImageFinished && !this.isLayoutFinished) {
            const images = this.preProcess(), layoutResult = this.doLayout(images);
            this.options && this.options.onLayoutEnd && this.options.onLayoutEnd(layoutResult), 
            this.progressiveResult = this.processOutput(layoutResult), this.isLayoutFinished = !0;
        }
    }
    progressiveOutput() {
        return this.progressiveResult;
    }
    release() {
        this.segmentationInput = null, this.data = null, this.progressiveResult = null, 
        this.options = null;
    }
    calculateImageSize(images, imageConfig = {}, ratio = .45) {
        const {imageSizeRange: imageSizeRange, padding: padding = 0} = imageConfig, imageSize = isNumber(imageConfig.imageSize) ? imageConfig.imageSize : field(imageConfig.imageSize), size = this.options.size;
        if (imageSize || imageSizeRange) if (imageSize && !isFunction(imageSize)) images.forEach((img => setSize(img, imageSize))); else if (imageSizeRange) {
            const sizeScale = (new SqrtScale).domain(extent(images, (d => d.weight))).range(imageSizeRange);
            images.forEach((img => setSize(img, ~~sizeScale.scale(img.weight))));
        } else if (imageSize && isFunction(imageSize) && !imageSizeRange) {
            const a = .5, [min, max] = extent(images, (d => d.weight)), picArea = images.reduce(((prev, img) => {
                const r = img.aspectRatio, w = (img.weight - min) / (max - min);
                return prev + (r > 1 ? 1 / r : r) * (a + (1 - a) * w) ** 2;
            }), 0), x = ~~Math.sqrt(ratio * size[0] * size[1] / picArea), range = [ ~~(a * x) - 2 * padding < 0 ? 1 : ~~(a * x) - 2 * padding, ~~x - 2 * padding < 0 ? 1 : ~~x - 2 * padding ], sizeScale = (new SqrtScale).domain(extent(images, (d => d.weight))).range(range);
            images.forEach((img => setSize(img, ~~sizeScale.scale(img.weight))));
        } else console.warn("image cloud imageSize error"); else {
            const imageArea = images.reduce(((prev, pic) => {
                const r = pic.aspectRatio;
                return prev + (r > 1 ? 1 / r : r);
            }), 0);
            let longSideLength = ~~Math.sqrt(ratio * size[0] * size[1] / imageArea);
            longSideLength = longSideLength - 2 * padding < 0 ? 1 : longSideLength - 2 * padding, 
            images.forEach((img => setSize(img, longSideLength)));
        }
        return images;
    }
    generateTransparentMaskCanvas(shapeImage, size) {
        var _a;
        const transparentMaskCanvas = this.options.createCanvas({
            width: size[0],
            height: size[1],
            dpr: 1
        }), transparentMaskContext = transparentMaskCanvas.getContext("2d");
        this.segmentationOutput.transparentMaskCanvas = transparentMaskCanvas, (null === (_a = this.options.maskConfig) || void 0 === _a ? void 0 : _a.removeWhiteBorder) && removeBorder(shapeImage, transparentMaskCanvas, this.segmentationInput.isEmptyPixel);
        const imageData = transparentMaskContext.createImageData(size[0], size[1]), labels = this.segmentationOutput.segmentation.labels;
        for (let i = 0; i < labels.length; i++) {
            const color = 0 === labels[i] ? 255 : 0, alpha = 255 * labels[i], pixelIndex = 4 * i;
            imageData.data[pixelIndex] = color, imageData.data[pixelIndex + 1] = color, imageData.data[pixelIndex + 2] = color, 
            imageData.data[pixelIndex + 3] = alpha;
        }
        return transparentMaskContext.clearRect(0, 0, size[0], size[1]), transparentMaskContext.fillStyle = "rgba(255,255,255,0)", 
        transparentMaskContext.fillRect(0, 0, size[0], size[1]), transparentMaskContext.putImageData(imageData, 0, 0), 
        transparentMaskCanvas;
    }
    processOutput(images) {
        var _a;
        const outputAs = null === (_a = this.options) || void 0 === _a ? void 0 : _a.as;
        return outputAs && Object.keys(outputAs).forEach((key => {
            images.forEach((img => {
                img[outputAs[key]] = img[key], delete img[key];
            }));
        })), images;
    }
}
//# sourceMappingURL=basic.js.map
