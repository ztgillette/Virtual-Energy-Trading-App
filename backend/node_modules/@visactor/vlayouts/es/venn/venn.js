import { array, isEmpty } from "@visactor/vutils";

import { computeTextCenters, normalizeSolution, scaleSolution, venn } from "./utils";

import { getArcsFromCircles, getPathFromArcs } from "./utils/path";

export const transform = (options, upstreamData) => {
    const {x0: x0, x1: x1, y0: y0, y1: y1, setField: setField = "sets", valueField: valueField = "size", orientation: orientation = Math.PI / 2, orientationOrder: orientationOrder = null, emptySetKey: emptySetKey} = options;
    let circles = {}, textCenters = {};
    const hasEmptySet = upstreamData.some((area => {
        const sets = array(area[setField]);
        return !sets || 0 === sets.length;
    })), nonEmptyData = hasEmptySet ? upstreamData.filter((area => !isEmpty(array(area[setField])))) : upstreamData;
    if (nonEmptyData.length > 0) {
        const vennData = nonEmptyData.map((area => ({
            sets: array(area[setField]),
            size: area[valueField]
        })));
        let solution = venn(vennData, options);
        solution = normalizeSolution(solution, orientation, orientationOrder), circles = scaleSolution(solution, x1 - x0, y1 - y0, x0, y0, hasEmptySet), 
        textCenters = computeTextCenters(circles, vennData);
    }
    return upstreamData.map((area => {
        const sets = array(area[setField]);
        if (!sets || 0 === sets.length) return Object.assign(Object.assign({}, area), {
            datum: area,
            sets: sets,
            key: emptySetKey || "others",
            size: area[valueField],
            labelX: void 0,
            labelY: void 0,
            type: "circle",
            x: x0 + (x1 - x0) / 2,
            y: y0 + (y1 - y0) / 2,
            radius: Math.min(x1 - x0, y1 - y0) / 2
        });
        const key = sets.toString(), textCenter = textCenters[key], basicDatum = Object.assign(Object.assign({}, area), {
            datum: area,
            sets: sets,
            key: key,
            size: area[valueField],
            labelX: null == textCenter ? void 0 : textCenter.x,
            labelY: null == textCenter ? void 0 : textCenter.y
        }), circle = circles[key];
        if (circle) return Object.assign(Object.assign({}, basicDatum), {
            type: "circle",
            x: circle.x,
            y: circle.y,
            radius: circle.radius
        });
        const arcs = getArcsFromCircles(sets.map((name => circles[name])));
        return Object.assign(Object.assign({}, basicDatum), {
            type: "overlap",
            x: 0,
            y: 0,
            path: getPathFromArcs(arcs),
            arcs: arcs
        });
    }));
};

export const transformMark = (options, upstreamData) => upstreamData.filter((datum => datum.type === options.datumType));
//# sourceMappingURL=venn.js.map