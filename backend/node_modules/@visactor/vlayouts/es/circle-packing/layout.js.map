{"version":3,"sources":["../src/circle-packing/layout.ts"],"names":[],"mappings":"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","file":"layout.js","sourcesContent":["import { eachBefore, eachAfter, calculateNodeValue } from '../utils/hierarchy';\nimport type { CirclePackingOptions, CirclePackingNodeElement } from './interface';\nimport { packSiblingsRandom } from './siblings';\nimport type { HierarchicalData, HierarchicalDatum } from '../interface/common';\nimport { field, isArray, isFunction, isNumber, randomLCG, zero } from '@visactor/vutils';\n\nfunction radiusLeaf(radius: (node: CirclePackingNodeElement) => number) {\n  return function (node: CirclePackingNodeElement) {\n    if (!node.children) {\n      node.radius = Math.max(0, +radius(node) || 0);\n    }\n  };\n}\n\nfunction packChildrenRandom(padding: (node: CirclePackingNodeElement) => number, k: number, random: () => number) {\n  return function (node: CirclePackingNodeElement) {\n    const children = node?.children;\n    if (children) {\n      let i;\n      const n = children.length;\n      const r = padding(node) * k || 0;\n\n      if (r) {\n        for (i = 0; i < n; ++i) {\n          children[i].radius += r;\n        }\n      }\n      const e = packSiblingsRandom(children, random);\n      if (r) {\n        for (i = 0; i < n; ++i) {\n          children[i].radius -= r;\n        }\n      }\n      node.radius = e + r;\n    }\n  };\n}\n\nfunction translateChild(k: number, maxDepth: number) {\n  return function (node: CirclePackingNodeElement, index: number, parent: CirclePackingNodeElement) {\n    node.radius *= k;\n    node.maxDepth = maxDepth;\n    if (parent) {\n      node.x = parent.x + k * node.x;\n      node.y = parent.y + k * node.y;\n    }\n  };\n}\n\nexport class CirclePackingLayout {\n  private options: CirclePackingOptions;\n\n  private _getNodeKey?: (datum: HierarchicalDatum) => string;\n\n  private _getPadding?: (node: CirclePackingNodeElement) => number;\n\n  private _maxDepth: number;\n\n  static defaultOpionts: Partial<CirclePackingOptions> = {\n    setRadius: (node: CirclePackingNodeElement) => {\n      return Math.sqrt(node.value);\n    },\n    padding: 0,\n    nodeSort: (a, b) => b.value - a.value\n  };\n\n  constructor(options?: CirclePackingOptions) {\n    this.options = options;\n\n    const keyOption = options?.nodeKey;\n    const keyFunc = isFunction(keyOption) ? keyOption : keyOption ? field(keyOption as string) : null;\n\n    this._getNodeKey = keyFunc;\n    this._getPadding = isNumber(options?.padding)\n      ? (node: CirclePackingNodeElement) => options.padding as number\n      : isArray(options?.padding)\n      ? (node: CirclePackingNodeElement) => (options.padding as number[])[node.depth + 1] ?? 0\n      : () => 0;\n    this._maxDepth = -1;\n  }\n\n  layout(\n    data: HierarchicalData,\n    config: { x0: number; x1: number; y0: number; y1: number } | { width: number; height: number }\n  ) {\n    const viewBox =\n      'width' in config\n        ? { x0: 0, x1: config.width, y0: 0, y1: config.height, width: config.width, height: config.height }\n        : {\n            x0: Math.min(config.x0, config.x1),\n            x1: Math.max(config.x0, config.x1),\n            y0: Math.min(config.y0, config.y1),\n            y1: Math.max(config.y0, config.y1),\n            width: Math.abs(config.x1 - config.x0),\n            height: Math.abs(config.y1 - config.y0)\n          };\n\n    if (!data || !data.length) {\n      return [];\n    }\n\n    const nodes: CirclePackingNodeElement[] = [];\n    const res = calculateNodeValue<HierarchicalDatum, CirclePackingNodeElement>(\n      data,\n      nodes,\n      0,\n      -1,\n      null,\n      this._getNodeKey\n    );\n    this._maxDepth = res.maxDepth;\n\n    const random = randomLCG();\n    const root: CirclePackingNodeElement = {\n      flattenIndex: -1,\n      maxDepth: -1,\n      key: 'root',\n      depth: -1,\n      index: -1,\n      value: res.sum,\n      datum: null,\n      children: nodes,\n      x: viewBox.x0 + viewBox.width / 2,\n      y: viewBox.y0 + viewBox.height / 2\n    };\n    const { nodeSort, setRadius, padding, includeRoot } = this.options ?? {};\n    if (nodeSort !== false) {\n      const sort = (isFunction(nodeSort) ? this.options.nodeKey : CirclePackingLayout.defaultOpionts.nodeSort) as (\n        a: CirclePackingNodeElement,\n        b: CirclePackingNodeElement\n      ) => number;\n      // 默认排序，布局效果更好\n      eachBefore([root], (node: CirclePackingNodeElement) => {\n        if (node.children && node.children.length) {\n          node.children.sort(sort);\n        }\n      });\n    }\n    if (setRadius) {\n      eachBefore([root], radiusLeaf(setRadius));\n      eachAfter([root], packChildrenRandom(this._getPadding, 0.5, random));\n      eachBefore([root], translateChild(1, this._maxDepth));\n    } else {\n      const size = Math.min(viewBox.width, viewBox.height);\n\n      eachBefore([root], radiusLeaf(CirclePackingLayout.defaultOpionts.setRadius));\n      // layout by value\n      eachAfter([root], packChildrenRandom(zero, 1, random));\n      if (padding) {\n        eachAfter([root], packChildrenRandom(this._getPadding, root.radius / size, random));\n      }\n      eachBefore([root], translateChild(size / (2 * root.radius), this._maxDepth));\n    }\n\n    return includeRoot ? [root] : nodes;\n  }\n}\n"]}