import type { CreateImageFunction, GeometricMaskShape, ICreateCanvas, SegmentationOutputType as SegmentationOutputTypeBase, TextShapeMask } from '../interface/wordcloud';
import type { TagItemAttribute } from '../wordcloud/interface';
import type { FieldOption } from '../wordcloud/wordcloud';
export type TagItemFunction<T> = (d?: any) => T;
export type Bounds = [{
    x: number;
    y: number;
}, {
    x: number;
    y: number;
}];
export interface Rect {
    x: number;
    y: number;
    width: number;
    height: number;
}
export type CallbackOption = (datum: any) => any;
export type AsType = {
    x: string;
    y: string;
    fontFamily: string;
    fontSize: string;
    fontStyle: string;
    fontWeight: string;
    angle: string;
    opacity: string;
    visible: string;
    isFillingWord: string;
    color: string;
};
export interface SegmentationOutputType extends SegmentationOutputTypeBase {
    fillingInitialFontSize?: number;
    fillingDeltaFontSize?: number;
}
export type wordsConfigType = {
    getText: TagItemFunction<string>;
    getFontSize?: TagItemFunction<number>;
    fontSizeRange?: [number, number];
    colorMode: 'linear' | 'ordinal';
    getColor: TagItemFunction<string>;
    getFillingColor?: TagItemFunction<string>;
    colorList?: string[];
    getColorHex?: TagItemFunction<string>;
    getFontFamily: TagItemFunction<string>;
    rotateList: number[];
    getPadding: TagItemFunction<number>;
    getFontStyle: TagItemFunction<string>;
    getFontWeight: TagItemFunction<string>;
    getFontOpacity: TagItemFunction<number>;
    fontSizeScale?: TagItemFunction<number>;
    colorScale?: TagItemFunction<string>;
    fillingColorScale?: TagItemFunction<string>;
};
export type LayoutConfigType = {
    size: [number, number];
    ratio: number;
    shapeUrl: string | TextShapeMask | GeometricMaskShape;
    random: boolean;
    textLayoutTimes: number;
    removeWhiteBorder: boolean;
    layoutMode: 'default' | 'ensureMapping' | 'ensureMappingEnlarge';
    fontSizeShrinkFactor: number;
    stepFactor: number;
    importantWordCount: number;
    globalShinkLimit: number;
    fontSizeEnlargeFactor: number;
    fillingRatio: number;
    fillingTimes: number;
    fillingXStep: number;
    fillingYStep: number;
    fillingInitialFontSize?: number;
    fillingDeltaFontSize?: number;
    fillingInitialOpacity: number;
    fillingDeltaOpacity: number;
    getFillingFontFamily: TagItemFunction<string>;
    getFillingFontStyle: TagItemFunction<string>;
    getFillingFontWeight: TagItemFunction<string>;
    getFillingPadding: TagItemFunction<number>;
    fillingRotateList: number[];
    fillingDeltaFontSizeFactor: number;
    fillingColorList: string[];
    sameColorList: boolean;
    board?: number[];
    minInitFontSize: number;
    minFontSize: number;
    minFillFontSize: number;
};
export type CloudWordType = {
    x: number;
    y: number;
    weight: number;
    text: string;
    fontFamily: string;
    fontWeight: string;
    fontStyle: string;
    rotate: number;
    fontSize: number;
    opacity: number;
    padding: number;
    color: string;
    fillingColor: string;
    datum: any;
    visible: boolean;
    hasPlaced: boolean;
    wordSize?: [number, number];
    bounds?: any;
    hasText?: boolean;
    sprite?: number[];
    LT?: [number, number];
};
export interface WordCloudShapeOptions {
    dataIndexKey?: string;
    text: FieldOption | TagItemAttribute<string> | string;
    size?: [number, number];
    fontFamily?: FieldOption | TagItemAttribute<string> | string;
    fontStyle?: FieldOption | TagItemAttribute<string> | string;
    fontOpacity?: FieldOption | TagItemAttribute<number> | number;
    fontWeight?: FieldOption | TagItemAttribute<string> | string;
    fontSize?: FieldOption | TagItemAttribute<number> | number;
    fontSizeRange?: [number, number];
    padding?: FieldOption | TagItemAttribute<number> | number;
    colorMode?: 'linear' | 'ordinal';
    colorField?: FieldOption;
    colorHexField?: FieldOption;
    colorList?: string[];
    rotate?: FieldOption | TagItemAttribute<number> | number;
    rotateList?: number[];
    shape: string | TextShapeMask | GeometricMaskShape;
    random?: boolean;
    textLayoutTimes?: number;
    layoutMode?: 'default' | 'ensureMapping' | 'ensureMappingEnlarge';
    ratio?: number;
    removeWhiteBorder?: boolean;
    fontSizeShrinkFactor?: number;
    stepFactor?: number;
    importantWordCount?: number;
    globalShinkLimit?: number;
    fontSizeEnlargeFactor?: number;
    fillingRatio?: number;
    fillingTimes?: number;
    fillingXRatioStep?: number;
    fillingYRatioStep?: number;
    fillingXStep?: number;
    fillingYStep?: number;
    fillingInitialFontSize?: number;
    fillingDeltaFontSize?: number;
    fillingInitialOpacity?: number;
    fillingDeltaOpacity?: number;
    fillingFontFamily?: FieldOption | TagItemAttribute<string> | string;
    fillingFontStyle?: FieldOption | TagItemAttribute<string> | string;
    fillingFontWeight?: FieldOption | TagItemAttribute<string> | string;
    fillingPadding?: FieldOption | TagItemAttribute<number> | number;
    fillingDeltaFontSizeFactor?: number;
    fillingColorList?: string[];
    fillingColorField?: FieldOption;
    fillingRotateList?: number[];
    as?: AsType;
    minInitFontSize?: number;
    minFontSize?: number;
    minFillFontSize?: number;
    onUpdateMaskCanvas?: (canvas?: HTMLCanvasElement) => void;
    onBeforeLayout?: () => void;
    onLayoutFinished?: (params: {
        successedWords: string[];
        failedWords: string[];
    }) => void;
    createCanvas: ICreateCanvas;
    createImage: CreateImageFunction;
}
