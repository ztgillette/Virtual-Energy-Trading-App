{"version":3,"sources":["../src/wordcloud-shape/segmentation.ts"],"names":[],"mappings":"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","file":"segmentation.js","sourcesContent":["import type { CloudWordType, SegmentationOutputType } from './interface';\n\n/**\n * 将单词分配到不同的区域内\n *\n * 先使用相对简单的分配逻辑，即根据区域面积来决定分配到的单词的 权重大小和数量\n * @param {*} words\n * @param {*} config\n */\nexport function allocateWords(words: CloudWordType[], segmentationOutput: SegmentationOutputType) {\n  const {\n    segmentation: { regions }\n  } = segmentationOutput;\n  let areaMax = -Infinity;\n  let totalArea = 0;\n  let areaMaxIndex = 0;\n\n  // 查找最大面积的区域，同时计算总的面积\n  regions.forEach((region: any, index: number) => {\n    const area = region.area;\n    if (area > areaMax) {\n      areaMax = area;\n      areaMaxIndex = index;\n    }\n    totalArea += area;\n  });\n\n  // 根据每个区域的面积大小给每个区域分配单词数量和权重限制\n  let wordsSum = 0;\n  regions.forEach((region: any) => {\n    const area = region.area;\n    const regionNum = Math.ceil((area / totalArea) * words.length);\n    const regionWeight = area / areaMax;\n\n    region.words = [];\n    region.regionNum = regionNum;\n    region.regionWeight = regionWeight;\n    wordsSum += regionNum;\n  });\n  // 如果有未分配的单词， 则分配到面积最大区域\n  if (wordsSum < words.length) {\n    regions[areaMaxIndex].wordsNum += words.length - wordsSum;\n  }\n\n  // 对单词进行分配，先分配面积最大的区域\n  let currIndex = areaMaxIndex;\n  const regionNums = regions.map((region: any) => region.regionNum);\n  words.forEach((word: any) => {\n    // 记录总的失败次数\n    let failCounter = 0;\n    // 记录失败次数，超过区域的数量，则更新一下所有区域的权重上限\n    let updateCounter = 0;\n    word.regionIndex = -1;\n\n    do {\n      if (regionNums[currIndex] > 0 && word.weight <= regions[currIndex].regionWeight) {\n        word.regionIndex = currIndex;\n        regions[currIndex].words.push(word);\n        regionNums[currIndex]--;\n        currIndex = (currIndex + 1) % regions.length;\n        break;\n      }\n      currIndex = (currIndex + 1) % regions.length;\n\n      failCounter++;\n      updateCounter++;\n      // 如果没有找到合适的区域，则更新所有区域的权重\n      if (updateCounter > regions.length + 1) {\n        regions.forEach((region: any) => {\n          // 这里 0.15 是经验值，可以后续根据业务场景调整\n          region.regionWeight += 0.15;\n        });\n        updateCounter = 0;\n      }\n    } while (word.regionIndex === -1 && failCounter < regions.length * 3);\n\n    // 未分配则分配为 area 最大的区域\n    if (word.regionIndex === -1) {\n      word.regionIndex = areaMaxIndex;\n      regions[areaMaxIndex].words.push(word);\n      regionNums[areaMaxIndex]--;\n    }\n  });\n\n  // 对每个区域里的单词根据权重进行排序\n  regions.forEach((region: any) => {\n    region.words.sort((a: CloudWordType, b: CloudWordType) => b.weight - a.weight);\n  });\n}\n"]}