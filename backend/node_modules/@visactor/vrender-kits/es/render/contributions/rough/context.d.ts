import type { IPointLike, TextMeasure, ITextMeasureSpec, IMatrix, Matrix } from '@visactor/vutils';
import type { ICamera, ICanvas, ICommonStyleParams, IConicalGradientData, IContext2d, ISetCommonStyleParams, ISetStrokeStyleParams, IStrokeStyleParams, ITextStyleParams, mat4, EnvType, vec3, CustomPath2D } from '@visactor/vrender-core';
export declare class RoughContext2d implements IContext2d {
    static env: EnvType;
    originContext: IContext2d;
    customPath: CustomPath2D;
    constructor(originContext: IContext2d, customPath: CustomPath2D);
    reset(setTransform?: boolean): void;
    beginPath(): void;
    moveTo(x: number, y: number, z?: number): void;
    lineTo(x: number, y: number, z?: number): void;
    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, z?: number): void;
    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, z?: number): void;
    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean, z?: number): void;
    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;
    ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;
    rect(x: number, y: number, w: number, h: number, z?: number): void;
    closePath(): void;
    get canvas(): ICanvas;
    set canvas(value: ICanvas);
    get camera(): ICamera | undefined;
    set camera(value: ICamera | undefined);
    get modelMatrix(): mat4 | undefined;
    set modelMatrix(value: mat4 | undefined);
    get nativeContext(): CanvasRenderingContext2D | any;
    set nativeContext(value: CanvasRenderingContext2D | any);
    get _inuse(): boolean;
    set _inuse(value: boolean);
    get inuse(): boolean;
    set inuse(value: boolean);
    get stack(): Matrix[];
    set stack(value: Matrix[]);
    get disableFill(): boolean | undefined;
    set disableFill(value: boolean | undefined);
    get disableStroke(): boolean | undefined;
    set disableStroke(value: boolean | undefined);
    get disableBeginPath(): boolean | undefined;
    set disableBeginPath(value: boolean | undefined);
    get fontFamily(): string;
    set fontFamily(value: string);
    get fontSize(): number;
    set fontSize(value: number);
    get _clearMatrix(): IMatrix;
    set _clearMatrix(value: IMatrix);
    get dpr(): number;
    set dpr(value: number);
    get baseGlobalAlpha(): number;
    set baseGlobalAlpha(value: number);
    get drawPromise(): Promise<any> | undefined;
    set drawPromise(value: Promise<any> | undefined);
    get mathTextMeasure(): TextMeasure<ITextMeasureSpec>;
    set mathTextMeasure(value: TextMeasure<ITextMeasureSpec>);
    get fillStyle(): string | CanvasGradient | CanvasPattern;
    set fillStyle(value: string | CanvasGradient | CanvasPattern);
    get font(): string;
    set font(value: string);
    get globalAlpha(): number;
    set globalAlpha(value: number);
    get lineCap(): CanvasLineCap;
    set lineCap(value: CanvasLineCap);
    get lineDashOffset(): number;
    set lineDashOffset(value: number);
    get lineJoin(): CanvasLineJoin;
    set lineJoin(value: CanvasLineJoin);
    get lineWidth(): number;
    set lineWidth(value: number);
    get miterLimit(): number;
    set miterLimit(value: number);
    get shadowBlur(): number;
    set shadowBlur(value: number);
    get shadowColor(): string;
    set shadowColor(value: string);
    get shadowOffsetX(): number;
    set shadowOffsetX(value: number);
    get shadowOffsetY(): number;
    set shadowOffsetY(value: number);
    get strokeStyle(): string | CanvasGradient | CanvasPattern;
    set strokeStyle(value: string | CanvasGradient | CanvasPattern);
    get textAlign(): CanvasTextAlign;
    set textAlign(value: CanvasTextAlign);
    get textBaseline(): CanvasTextBaseline;
    set textBaseline(value: CanvasTextBaseline);
    get currentMatrix(): IMatrix;
    save(): void;
    restore(): void;
    highPerformanceSave(): void;
    highPerformanceRestore(): void;
    rotate(rad: number, setTransform?: boolean): void;
    scale(sx: number, sy: number, setTransform?: boolean): void;
    setScale(sx: number, sy: number, setTransform?: boolean): void;
    scalePoint(sx: number, sy: number, px: number, py: number, setTransform?: boolean): void;
    setTransform(a: number, b: number, c: number, d: number, e: number, f: number, setTransform?: boolean, dpr?: number): void;
    setTransformFromMatrix(matrix: Matrix, setTransform?: boolean, dpr?: number): void;
    resetTransform(setTransform?: boolean, dpr?: number): void;
    transform(a: number, b: number, c: number, d: number, e: number, f: number, setTransform?: boolean): void;
    transformFromMatrix(matrix: Matrix, setTransform?: boolean): void;
    translate(x: number, y: number, setTransform?: boolean): void;
    rotateDegrees(deg: number, setTransform?: boolean): void;
    rotateAbout(rad: number, x: number, y: number, setTransform?: boolean): void;
    rotateDegreesAbout(deg: number, x: number, y: number, setTransform?: boolean): void;
    setTransformForCurrent(force?: boolean): void;
    clip(fillRule?: CanvasFillRule): void;
    clip(path: Path2D, fillRule?: CanvasFillRule): void;
    fill(path?: Path2D, fillRule?: CanvasFillRule): void;
    stroke(path?: Path2D): void;
    fillRect(x: number, y: number, width: number, height: number): void;
    strokeRect(x: number, y: number, width: number, height: number): void;
    fillText(text: string, x: number, y: number, z?: number): void;
    strokeText(text: string, x: number, y: number, z?: number): void;
    clearRect(x: number, y: number, w: number, h: number): void;
    drawImage(...args: any[]): void;
    createImageData(...args: any[]): ImageData;
    getImageData(sx: number, sy: number, sw: number, sh: number): ImageData;
    putImageData(imagedata: ImageData, dx: number, dy: number): void;
    createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient;
    createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient;
    createConicGradient(x: number, y: number, startAngle: number, endAngle: number): IConicalGradientData;
    createPattern(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, repetition: string): CanvasPattern;
    getLineDash(): number[];
    setLineDash(segments: number[]): void;
    clear(): void;
    measureText(text: string, method?: 'native' | 'simple' | 'quick'): {
        width: number;
    };
    isPointInPath(x: number, y: number): boolean;
    isPointInStroke(x: number, y: number): boolean;
    project(x: number, y: number, z?: number): IPointLike;
    view(x: number, y: number, z?: number): vec3;
    getCanvas(): ICanvas;
    getContext(): CanvasRenderingContext2D | any;
    setCommonStyle(params: ISetCommonStyleParams, attribute: ICommonStyleParams, offsetX: number, offsetY: number, defaultParams?: ICommonStyleParams | Partial<ICommonStyleParams>[]): void;
    setShadowBlendStyle(params: ISetCommonStyleParams, attribute: ICommonStyleParams, defaultParams?: ICommonStyleParams | Partial<ICommonStyleParams>[]): void;
    setStrokeStyle(params: ISetStrokeStyleParams, attribute: IStrokeStyleParams, offsetX: number, offsetY: number, defaultParams?: IStrokeStyleParams | any): void;
    setTextStyle(params: Partial<ITextStyleParams>, defaultParams?: ITextStyleParams, z?: number): void;
    setTextStyleWithoutAlignBaseline(params: Partial<ITextStyleParams>, defaultParams?: ITextStyleParams, z?: number): void;
    clearMatrix(setTransform?: boolean, dpr?: number): void;
    setClearMatrix(a: number, b: number, c: number, d: number, e: number, f: number): void;
    onlyTranslate(dpr?: number): boolean;
    cloneMatrix(m: Matrix): Matrix;
    draw(): void;
    release(...params: any): void;
}
