{"version":3,"sources":["../src/picker/contributions/common/rect-picker-base.ts"],"names":[],"mappings":"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","file":"rect-picker-base.js","sourcesContent":["import type { IPoint } from '@visactor/vutils';\nimport { isArray, isNumber, AABBBounds } from '@visactor/vutils';\nimport { getScaledStroke, RECT_NUMBER_TYPE } from '@visactor/vrender-core';\nimport type {\n  IGraphicAttribute,\n  IContext2d,\n  IMarkAttribute,\n  IRect,\n  IThemeAttribute,\n  IGraphicRender,\n  IPickParams,\n  ITransform\n} from '@visactor/vrender-core';\nconst _bounds = new AABBBounds();\n\nexport class RectPickerBase {\n  type: string = 'rect';\n  numberType: number = RECT_NUMBER_TYPE;\n\n  canvasRenderer!: IGraphicRender;\n\n  contains(rect: IRect, point: IPoint, params?: IPickParams): boolean {\n    if (!rect.AABBBounds.containsPoint(point)) {\n      return false;\n    }\n    if (rect.attribute.pickMode === 'imprecise') {\n      return true;\n    }\n\n    const { pickContext } = params ?? {};\n    if (!pickContext) {\n      return false;\n    }\n\n    // const { rectAttribute } = graphicService.themeService.getCurrentTheme();\n    const rectAttribute = rect.getGraphicTheme();\n    const { cornerRadius = rectAttribute.cornerRadius } = rect.attribute;\n    let { x = rectAttribute.x, y = rectAttribute.y } = rect.attribute;\n\n    pickContext.highPerformanceSave();\n    let onlyTranslate = true;\n    if (!rect.transMatrix.onlyTranslate()) {\n      // 性能较差\n      x = 0;\n      y = 0;\n      onlyTranslate = false;\n      pickContext.transformFromMatrix(rect.transMatrix, true);\n    } else {\n      const point = rect.getOffsetXY(rectAttribute as ITransform);\n      x += point.x;\n      y += point.y;\n      // 当前context有rotate/scale，重置matrix\n      pickContext.setTransformForCurrent();\n    }\n\n    let picked = true;\n    // 处理圆角情况，或者存在shadowRoot的情况，无圆角直接使用bounds判断结果\n    if (\n      !onlyTranslate ||\n      rect.shadowRoot ||\n      (isNumber(cornerRadius, true) && cornerRadius !== 0) ||\n      (isArray(cornerRadius) && (<number[]>cornerRadius).some(num => num !== 0))\n    ) {\n      // 详细形状判断\n      picked = false;\n      this.canvasRenderer.drawShape(\n        rect,\n        pickContext,\n        x,\n        y,\n        {} as any,\n        null,\n        (\n          context: IContext2d,\n          rectAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n          themeAttribute: IThemeAttribute\n        ) => {\n          // 选中后面就不需要再走逻辑了\n          if (picked) {\n            return true;\n          }\n          picked = context.isPointInPath(point.x, point.y);\n          return picked;\n        },\n        (\n          context: IContext2d,\n          rectAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n          themeAttribute: IThemeAttribute\n        ) => {\n          // 选中后面就不需要再走逻辑了\n          if (picked) {\n            return true;\n          }\n          const lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth;\n          const pickStrokeBuffer = rectAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;\n          const keepStrokeScale = rectAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;\n          pickContext.lineWidth = keepStrokeScale\n            ? lineWidth + pickStrokeBuffer\n            : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr);\n          picked = context.isPointInStroke(point.x, point.y);\n          return picked;\n        }\n      );\n    } else {\n      // 如果只有描边那需要测试描边\n      const {\n        fill = rectAttribute.fill,\n        stroke = rectAttribute.stroke,\n        lineWidth = rectAttribute.lineWidth\n      } = rect.attribute;\n      if (fill) {\n        picked = true;\n      } else if (stroke) {\n        const bounds = rect.AABBBounds;\n        _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2);\n        _bounds.expand(-lineWidth / 2);\n        picked = !_bounds.containsPoint(point);\n      }\n    }\n\n    pickContext.highPerformanceRestore();\n    return picked; // 无圆角形状判断通过\n  }\n}\n"]}