{"version":3,"sources":["../src/tools/dynamicTexture.ts"],"names":[],"mappings":"","file":"dynamicTexture.js","sourcesContent":["// import type { IContext2d, IGraphic } from '@visactor/vrender-core';\n\n// export function randomOpacity(\n//   ctx: IContext2d,\n//   row: number,\n//   column: number,\n//   rowCount: number,\n//   columnCount: number,\n//   ratio: number,\n//   graphic: IGraphic\n// ) {\n//   if (!graphic.dynamicTextureCache) {\n//     graphic.dynamicTextureCache = new Array(rowCount * columnCount).fill(0).map(item => Math.random() * 2 * Math.PI);\n//   }\n//   const targetRandomValue = graphic.dynamicTextureCache[row * columnCount + column];\n//   const _r = (Math.sin(ratio * 2 * Math.PI + targetRandomValue) + 1) / 2;\n//   ctx.globalAlpha = _r;\n//   ctx.fill();\n// }\n\n// // 从左到右的列式渐变\n// export function columnLeftToRight(\n//   ctx: IContext2d,\n//   row: number,\n//   column: number,\n//   rowCount: number,\n//   columnCount: number,\n//   ratio: number,\n//   graphic: IGraphic\n// ) {\n//   // 根据列号计算延迟\n//   const delay = column / columnCount;\n//   // 使用连续的sin函数，不需要max(0,ratio-delay)的截断\n//   const _r = (Math.sin(ratio * 2 * Math.PI - delay * 2 * Math.PI) + 1) / 2;\n//   ctx.globalAlpha = _r;\n//   ctx.fill();\n// }\n\n// // 从右到左的列式渐变\n// export function columnRightToLeft(\n//   ctx: IContext2d,\n//   row: number,\n//   column: number,\n//   rowCount: number,\n//   columnCount: number,\n//   ratio: number,\n//   graphic: IGraphic\n// ) {\n//   const delay = (columnCount - 1 - column) / columnCount;\n//   const _r = (Math.sin(ratio * 2 * Math.PI - delay * 2 * Math.PI) + 1) / 2;\n//   ctx.globalAlpha = _r;\n//   ctx.fill();\n// }\n\n// // 从上到下的行式渐变\n// export function rowTopToBottom(\n//   ctx: IContext2d,\n//   row: number,\n//   column: number,\n//   rowCount: number,\n//   columnCount: number,\n//   ratio: number,\n//   graphic: IGraphic\n// ) {\n//   const delay = row / rowCount;\n//   const _r = (Math.sin(ratio * 2 * Math.PI - delay * 2 * Math.PI) + 1) / 2;\n//   ctx.globalAlpha = _r;\n//   ctx.fill();\n// }\n\n// // 从下到上的行式渐变\n// export function rowBottomToTop(\n//   ctx: IContext2d,\n//   row: number,\n//   column: number,\n//   rowCount: number,\n//   columnCount: number,\n//   ratio: number,\n//   graphic: IGraphic\n// ) {\n//   const delay = (rowCount - 1 - row) / rowCount;\n//   const _r = (Math.sin(ratio * 2 * Math.PI - delay * 2 * Math.PI) + 1) / 2;\n//   ctx.globalAlpha = _r;\n//   ctx.fill();\n// }\n\n// // 从中心向两边的对角线渐变\n// export function diagonalCenterToEdge(\n//   ctx: IContext2d,\n//   row: number,\n//   column: number,\n//   rowCount: number,\n//   columnCount: number,\n//   ratio: number,\n//   graphic: IGraphic\n// ) {\n//   const centerRow = rowCount / 2;\n//   const centerCol = columnCount / 2;\n//   const distance = Math.sqrt(\n//     Math.pow((row - centerRow) / rowCount, 2) + Math.pow((column - centerCol) / columnCount, 2)\n//   );\n//   const _r = (Math.sin(ratio * 2 * Math.PI - distance * 2 * Math.PI) + 1) / 2;\n//   ctx.globalAlpha = _r;\n//   ctx.fill();\n// }\n\n// // 从左上角到右下角的对角线渐变\n// export function diagonalTopLeftToBottomRight(\n//   ctx: IContext2d,\n//   row: number,\n//   column: number,\n//   rowCount: number,\n//   columnCount: number,\n//   ratio: number,\n//   graphic: IGraphic\n// ) {\n//   const delay = (row / rowCount + column / columnCount) / 2;\n//   const _r = (Math.sin(ratio * 2 * Math.PI - delay * 2 * Math.PI) + 1) / 2;\n//   ctx.globalAlpha = _r;\n//   ctx.fill();\n// }\n\n// // 旋转扫描效果\n// export function rotationScan(\n//   ctx: IContext2d,\n//   row: number,\n//   column: number,\n//   rowCount: number,\n//   columnCount: number,\n//   ratio: number,\n//   graphic: IGraphic\n// ) {\n//   // 计算当前点相对于中心点的角度\n//   const centerRow = rowCount / 2;\n//   const centerCol = columnCount / 2;\n//   const angle = Math.atan2(row - centerRow, column - centerCol);\n//   // 将角度归一化到 [0, 2π]\n//   const normalizedAngle = angle < 0 ? angle + 2 * Math.PI : angle;\n//   // 计算扫描延迟\n//   const delay = normalizedAngle / (2 * Math.PI);\n//   const _r = (Math.sin(ratio * 2 * Math.PI - delay * 2 * Math.PI) + 1) / 2;\n//   ctx.globalAlpha = _r;\n//   ctx.fill();\n// }\n\n// // 波纹扩散效果\n// export function rippleEffect(\n//   ctx: IContext2d,\n//   row: number,\n//   column: number,\n//   rowCount: number,\n//   columnCount: number,\n//   ratio: number,\n//   graphic: IGraphic\n// ) {\n//   const centerRow = rowCount / 2;\n//   const centerCol = columnCount / 2;\n//   // 计算到中心的距离\n//   const distance = Math.sqrt(Math.pow(row - centerRow, 2) + Math.pow(column - centerCol, 2));\n//   // 归一化距离\n//   const normalizedDistance = distance / Math.sqrt(Math.pow(rowCount / 2, 2) + Math.pow(columnCount / 2, 2));\n//   // 创建多个波纹\n//   const waves = 3;\n//   const _r = (Math.sin(ratio * 2 * Math.PI * waves - normalizedDistance * 2 * Math.PI) + 1) / 2;\n//   ctx.globalAlpha = _r;\n//   ctx.fill();\n// }\n\n// // 蛇形波动效果\n// export function snakeWave(\n//   ctx: IContext2d,\n//   row: number,\n//   column: number,\n//   rowCount: number,\n//   columnCount: number,\n//   ratio: number,\n//   graphic: IGraphic\n// ) {\n//   // 使用行和列的位置创建蛇形路径\n//   const delay = ((row + column) % (rowCount + columnCount)) / (rowCount + columnCount);\n//   const _r = (Math.sin(ratio * 2 * Math.PI - delay * 4 * Math.PI) + 1) / 2;\n//   ctx.globalAlpha = _r;\n//   ctx.fill();\n// }\n\n// // 交错波纹效果\n// export function alternatingWave(\n//   ctx: IContext2d,\n//   row: number,\n//   column: number,\n//   rowCount: number,\n//   columnCount: number,\n//   ratio: number,\n//   graphic: IGraphic\n// ) {\n//   // 行和列的交错波纹\n//   const rowPhase = row / rowCount;\n//   const colPhase = column / columnCount;\n//   const _r =\n//     (Math.sin(ratio * 2 * Math.PI - rowPhase * 2 * Math.PI) * Math.sin(ratio * 2 * Math.PI - colPhase * 2 * Math.PI) +\n//       1) /\n//     2;\n//   ctx.globalAlpha = _r;\n//   ctx.fill();\n// }\n\n// // 螺旋效果\n// export function spiralEffect(\n//   ctx: IContext2d,\n//   row: number,\n//   column: number,\n//   rowCount: number,\n//   columnCount: number,\n//   ratio: number,\n//   graphic: IGraphic\n// ) {\n//   const centerRow = rowCount / 2;\n//   const centerCol = columnCount / 2;\n//   // 计算到中心的距离和角度\n//   const distance = Math.sqrt(Math.pow(row - centerRow, 2) + Math.pow(column - centerCol, 2));\n//   const angle = Math.atan2(row - centerRow, column - centerCol);\n//   // 归一化距离\n//   const normalizedDistance = distance / Math.sqrt(Math.pow(rowCount / 2, 2) + Math.pow(columnCount / 2, 2));\n//   // 组合距离和角度创建螺旋效果\n//   const delay = (normalizedDistance + angle / (2 * Math.PI)) / 2;\n//   const _r = (Math.sin(ratio * 2 * Math.PI - delay * 4 * Math.PI) + 1) / 2;\n//   ctx.globalAlpha = _r;\n//   ctx.fill();\n// }\n"]}