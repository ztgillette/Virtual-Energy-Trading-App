"use strict";

var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LynxEnvContribution = exports.createImageElement = void 0;

const vrender_core_1 = require("@visactor/vrender-core"), canvas_wrap_1 = require("./canvas-wrap");

let ng = !1;

try {
    ng = !!lynx.createCanvasNG;
} catch (err) {}

function makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, offscreen, pixelRatio) {
    const dpr = null != pixelRatio ? pixelRatio : SystemInfo.pixelRatio;
    if (canvasIdLists.forEach(((id, i) => {
        let _canvas;
        offscreen ? _canvas = lynx.createOffscreenCanvas() : (_canvas = ng ? lynx.createCanvasNG(id) : lynx.createCanvas(id), 
        ng && _canvas.attachToCanvasView(id)), _canvas.width = domref.width * dpr, _canvas.height = domref.height * dpr;
        const ctx = _canvas.getContext("2d"), canvas = new canvas_wrap_1.CanvasWrapEnableWH(_canvas, ctx, dpr, domref.width, domref.height, id);
        canvasMap.set(id, canvas), i > freeCanvasIdx && freeCanvasList.push(canvas);
    })), !freeCanvasList.length && lynx.createOffscreenCanvas) {
        const _canvas = lynx.createOffscreenCanvas();
        _canvas.width = domref.width * dpr, _canvas.height = domref.height * dpr;
        const ctx = _canvas.getContext("2d"), id = Math.random().toString(), canvas = new canvas_wrap_1.CanvasWrapEnableWH(_canvas, ctx, dpr, domref.width, domref.height, id);
        canvasMap.set(id, canvas), freeCanvasList.push(canvas);
    }
}

function createImageElement(src, isSvg = !1) {
    if (isSvg) return Promise.reject();
    const img = lynx.createImage(src);
    return new Promise(((resolve, reject) => {
        img.onload = () => {
            resolve(img);
        }, img.onerror = () => {
            reject(new Error("加载失败"));
        };
    }));
}

exports.createImageElement = createImageElement;

let LynxEnvContribution = class extends vrender_core_1.BaseEnvContribution {
    constructor() {
        super(), this.type = "lynx", this.supportEvent = !0, this.canvasMap = new Map, this.freeCanvasList = [], 
        this.canvasIdx = 0, this.supportsTouchEvents = !0;
        try {
            this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
        } catch (err) {
            this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;
        }
        this.applyStyles = !0;
    }
    configure(service, params) {
        service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, !!params.offscreen, params.pixelRatio));
    }
    getDynamicCanvasCount() {
        return this.freeCanvasList.length;
    }
    getStaticCanvasCount() {
        return 9999;
    }
    loadImage(url) {
        return createImageElement(url, !1).then((img => ({
            data: img,
            loadState: "success"
        }))).catch((() => ({
            data: null,
            loadState: "fail"
        })));
    }
    loadSvg(url) {
        return Promise.reject();
    }
    createCanvas(params) {
        const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
        return this.canvasIdx++, result;
    }
    createOffscreenCanvas(params) {}
    releaseCanvas(canvas) {}
    getDevicePixelRatio() {
        return SystemInfo.pixelRatio;
    }
    getRequestAnimationFrame() {
        return function(callback) {
            return vrender_core_1.rafBasedSto.call(callback);
        };
    }
    getCancelAnimationFrame() {
        return h => {
            vrender_core_1.rafBasedSto.clear(h);
        };
    }
    mapToCanvasPoint(event) {
        var _a;
        return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), 
        event;
    }
    addEventListener(type, listener, options) {
        return null;
    }
    removeEventListener(type, listener, options) {
        return null;
    }
    dispatchEvent(event) {
        return null;
    }
    getElementById(str) {
        return this.canvasMap.get(str);
    }
    getRootElement() {
        return null;
    }
    getDocument() {
        return null;
    }
    release(...params) {}
};

LynxEnvContribution = __decorate([ (0, vrender_core_1.injectable)(), __metadata("design:paramtypes", []) ], LynxEnvContribution), 
exports.LynxEnvContribution = LynxEnvContribution;
//# sourceMappingURL=lynx-contribution.js.map