{"version":3,"sources":["../src/common/debounce.ts"],"names":[],"mappings":";;;;;AAGA,0DAAkC;AAClC,oEAA4C;AAW5C,IAAI,MAAM,GAAY,KAAK,CAAC;AAC5B,IAAI;IACF,MAAM,GAAG,OAAO,qBAAqB,KAAK,UAAU,IAAI,OAAO,oBAAoB,KAAK,UAAU,CAAC;CACpG;AAAC,OAAO,GAAG,EAAE;IACZ,MAAM,GAAG,KAAK,CAAC;CAChB;AACD,MAAM,GAAG,KAAK,CAAC;AAEf,SAAS,QAAQ,CACf,IAAyB,EACzB,IAAY,EACZ,OAAgC;IAEhC,IAAI,QAAa,CAAC;IAClB,IAAI,QAAa,CAAC;IAClB,IAAI,OAAe,CAAC;IACpB,IAAI,MAAW,CAAC;IAEhB,IAAI,OAA4C,CAAC;IACjD,IAAI,YAAgC,CAAC;IAErC,IAAI,cAAc,GAAG,CAAC,CAAC;IACvB,IAAI,OAAO,GAAG,KAAK,CAAC;IACpB,IAAI,MAAM,GAAG,KAAK,CAAC;IACnB,IAAI,QAAQ,GAAG,IAAI,CAAC;IAGpB,MAAM,MAAM,GAAG,CAAC,IAAI,IAAI,IAAI,KAAK,CAAC,IAAI,MAAM,CAAC;IAE7C,IAAI,OAAO,IAAI,KAAK,UAAU,EAAE;QAC9B,MAAM,IAAI,SAAS,CAAC,qBAAqB,CAAC,CAAC;KAC5C;IACD,IAAI,GAAG,CAAC,IAAI,IAAI,CAAC,CAAC;IAClB,IAAI,IAAA,kBAAQ,EAAC,OAAO,CAAC,EAAE;QACrB,OAAO,GAAG,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC;QAC5B,MAAM,GAAG,SAAS,IAAI,OAAO,CAAC;QAC9B,IAAI,MAAM,EAAE;YACV,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,IAAA,uBAAa,EAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;SAChF;QAED,QAAQ,GAAG,UAAU,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC;KAClE;IAED,SAAS,UAAU,CAAC,IAAY;QAC9B,MAAM,IAAI,GAAG,QAAQ,CAAC;QACtB,MAAM,OAAO,GAAG,QAAQ,CAAC;QAEzB,QAAQ,GAAG,QAAQ,GAAG,SAAS,CAAC;QAChC,cAAc,GAAG,IAAI,CAAC;QACtB,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;QACnC,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,SAAS,UAAU,CAAC,WAAgB,EAAE,IAAY;QAChD,IAAI,MAAM,EAAE;YACV,oBAAoB,CAAC,OAAiB,CAAC,CAAC;YACxC,OAAO,qBAAqB,CAAC,WAAW,CAAC,CAAC;SAC3C;QACD,OAAO,UAAU,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;IACvC,CAAC;IAED,SAAS,WAAW,CAAC,EAAU;QAC7B,IAAI,MAAM,EAAE;YACV,OAAO,oBAAoB,CAAC,EAAE,CAAC,CAAC;SACjC;QACD,YAAY,CAAC,EAAE,CAAC,CAAC;IACnB,CAAC;IAED,SAAS,WAAW,CAAC,IAAY;QAE/B,cAAc,GAAG,IAAI,CAAC;QAEtB,OAAO,GAAG,UAAU,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;QAEzC,OAAO,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;IAC7C,CAAC;IAED,SAAS,aAAa,CAAC,IAAY;QACjC,MAAM,iBAAiB,GAAG,IAAI,GAAI,YAAuB,CAAC;QAC1D,MAAM,mBAAmB,GAAG,IAAI,GAAG,cAAc,CAAC;QAClD,MAAM,WAAW,GAAG,IAAI,GAAG,iBAAiB,CAAC;QAE7C,OAAO,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,OAAO,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC;IACrF,CAAC;IAED,SAAS,YAAY,CAAC,IAAY;QAChC,MAAM,iBAAiB,GAAG,IAAI,GAAI,YAAuB,CAAC;QAC1D,MAAM,mBAAmB,GAAG,IAAI,GAAG,cAAc,CAAC;QAKlD,OAAO,CACL,YAAY,KAAK,SAAS;YAC1B,iBAAiB,IAAI,IAAI;YACzB,iBAAiB,GAAG,CAAC;YACrB,CAAC,MAAM,IAAI,mBAAmB,IAAI,OAAO,CAAC,CAC3C,CAAC;IACJ,CAAC;IAED,SAAS,YAAY;QACnB,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACxB,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;YACtB,OAAO,YAAY,CAAC,IAAI,CAAC,CAAC;SAC3B;QAED,OAAO,GAAG,UAAU,CAAC,YAAY,EAAE,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;IAC1D,CAAC;IAED,SAAS,YAAY,CAAC,IAAY;QAChC,OAAO,GAAG,SAAS,CAAC;QAIpB,IAAI,QAAQ,IAAI,QAAQ,EAAE;YACxB,OAAO,UAAU,CAAC,IAAI,CAAC,CAAC;SACzB;QACD,QAAQ,GAAG,QAAQ,GAAG,SAAS,CAAC;QAChC,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,SAAS,MAAM;QACb,IAAI,OAAO,KAAK,SAAS,EAAE;YACzB,WAAW,CAAC,OAAiB,CAAC,CAAC;SAChC;QACD,cAAc,GAAG,CAAC,CAAC;QACnB,QAAQ,GAAG,YAAY,GAAG,QAAQ,GAAG,OAAO,GAAG,SAAS,CAAC;IAC3D,CAAC;IAED,SAAS,KAAK;QACZ,OAAO,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;IACnE,CAAC;IAED,SAAS,OAAO;QACd,OAAO,OAAO,KAAK,SAAS,CAAC;IAC/B,CAAC;IAED,SAAS,SAAS,CAAC,GAAG,IAAW;QAC/B,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QACxB,MAAM,UAAU,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;QAEtC,QAAQ,GAAG,IAAI,CAAC;QAEhB,QAAQ,GAAG,IAAI,CAAC;QAChB,YAAY,GAAG,IAAI,CAAC;QAEpB,IAAI,UAAU,EAAE;YACd,IAAI,OAAO,KAAK,SAAS,EAAE;gBACzB,OAAO,WAAW,CAAC,YAAY,CAAC,CAAC;aAClC;YACD,IAAI,MAAM,EAAE;gBAEV,OAAO,GAAG,UAAU,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;gBACzC,OAAO,UAAU,CAAC,YAAY,CAAC,CAAC;aACjC;SACF;QACD,IAAI,OAAO,KAAK,SAAS,EAAE;YACzB,OAAO,GAAG,UAAU,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;SAC1C;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IACD,SAAS,CAAC,MAAM,GAAG,MAAM,CAAC;IAC1B,SAAS,CAAC,KAAK,GAAG,KAAK,CAAC;IACxB,SAAS,CAAC,OAAO,GAAG,OAAO,CAAC;IAC5B,OAAO,SAAS,CAAC;AACnB,CAAC;AAED,kBAAe,QAAQ,CAAC","file":"debounce.js","sourcesContent":["/**\n * @see https://github.com/lodash/lodash/blob/master/debounce.js\n */\nimport isObject from './isObject';\nimport isValidNumber from './isValidNumber';\n\nexport type FunctionControlOptions = {\n  // 是否在等待开始时调用\n  leading?: boolean;\n  // 是否在等待结束后调用\n  trailing?: boolean;\n  // 最长等待时间\n  maxWait?: number;\n};\n\nlet hasRaf: boolean = false;\ntry {\n  hasRaf = typeof requestAnimationFrame === 'function' && typeof cancelAnimationFrame === 'function';\n} catch (err) {\n  hasRaf = false;\n}\nhasRaf = false;\n\nfunction debounce<T, S>(\n  func: (...args: T[]) => S,\n  wait: number,\n  options?: FunctionControlOptions\n): (...args: T[]) => S {\n  let lastArgs: any;\n  let lastThis: any;\n  let maxWait: number;\n  let result: any;\n  // eslint-disable-next-line no-undef\n  let timerId: number | NodeJS.Timeout | undefined;\n  let lastCallTime: number | undefined;\n\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF = !wait && wait !== 0 && hasRaf;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  wait = +wait || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    if (maxing) {\n      maxWait = Math.max(isValidNumber(options.maxWait) ? options.maxWait : 0, wait);\n    }\n\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time: number) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function startTimer(pendingFunc: any, wait: number) {\n    if (useRAF) {\n      cancelAnimationFrame(timerId as number);\n      return requestAnimationFrame(pendingFunc);\n    }\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id: number) {\n    if (useRAF) {\n      return cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time: number) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time: number) {\n    const timeSinceLastCall = time - (lastCallTime as number);\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n  }\n\n  function shouldInvoke(time: number) {\n    const timeSinceLastCall = time - (lastCallTime as number);\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxing && timeSinceLastInvoke >= maxWait)\n    );\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time: number) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId as number);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args: any[]) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = args;\n    // @ts-ignore\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n  return debounced;\n}\n\nexport default debounce;\n"]}