{"version":3,"sources":["../src/graphics/algorithm/intersect.ts"],"names":[],"mappings":"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","file":"intersect.js","sourcesContent":["/* 用于判断2d相交 */\nimport { degreeToRadian } from '../../angle';\nimport type { IBoundsLike } from '../../data-structure';\nimport type { vec2 } from '../../math';\nimport { pi2, halfPi, crossProduct, fuzzyEqualVec } from '../../math';\nimport type { Point } from './interface';\n\nfunction sub(out: vec2, v1: vec2, v2: vec2) {\n  out[0] = v1[0] - v2[0];\n  out[1] = v1[1] - v2[1];\n}\n\n/**\n * 判断直线是否相交，投影法\n * @param left1\n * @param right1\n * @param left2\n * @param right2\n */\nexport function isIntersect(left1: vec2, right1: vec2, left2: vec2, right2: vec2): boolean {\n  let min1: number = left1[0];\n  let max1: number = right1[0];\n  let min2: number = left2[0];\n  let max2: number = right2[0];\n  if (max1 < min1) {\n    [min1, max1] = [max1, min1];\n  }\n  if (max2 < min2) {\n    [max2, min2] = [min2, max2];\n  }\n  if (max1 < min2 || max2 < min1) {\n    return false;\n  }\n\n  (min1 = left1[1]), (max1 = right1[1]), (min2 = left2[1]), (max2 = right2[1]);\n  if (max1 < min1) {\n    [min1, max1] = [max1, min1];\n  }\n  if (max2 < min2) {\n    [max2, min2] = [min2, max2];\n  }\n  if (max1 < min2 || max2 < min1) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * 获取直线交点\n * 不相交返回false，共线返回true，相交返回交点\n * https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#565282\n * @param left1\n * @param right1\n * @param left2\n * @param right2\n */\nexport function getIntersectPoint(left1: vec2, right1: vec2, left2: vec2, right2: vec2): boolean | vec2 {\n  if (!isIntersect(left1, right1, left2, right2)) {\n    return false;\n  }\n  const dir1: vec2 = [0, 0];\n  const dir2: vec2 = [0, 0];\n  const tempVec: vec2 = [0, 0];\n  sub(dir1, right1, left1);\n  sub(dir2, right2, left2);\n\n  // 判断共线\n  if (fuzzyEqualVec(dir1, dir2)) {\n    return true;\n  }\n\n  // https://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/565282#565282\n  // line1: left1 + dir1 * t\n  // line2: left2 + dir2 * u\n  // 当 left1 + dir1 * t = left2 + dir2 * u => (left1 + dir1 * t) x dir2 = (left2 + dir2 * u) x dir2\n  // => dir1 x dir2 * t = (left2 - left1) x dir2 => t = (left2 - left1) x dir2 / (dir1 x dir2)\n  // 直线不平行，dir1 x dir2 ≠ 0，当0 <= t <= 1时，可以求出交点\n  sub(tempVec, left2, left1);\n  const t = crossProduct(tempVec, dir2) / crossProduct(dir1, dir2);\n  if (t >= 0 && t <= 1) {\n    return [left1[0] + dir1[0] * t, left1[1] + dir1[1] * t];\n  }\n\n  return false;\n}\n\n/**\n * 获取两个rect的相交部分\n * 如果有bbox为null，返回null，如果不相交返回{x1: 0, y1: 0, x2: 0, y2: 0}\n * @param bbox1\n * @param bbox2\n * @param format\n */\nexport function getRectIntersect(\n  bbox1: IBoundsLike | null,\n  bbox2: IBoundsLike | null,\n  format: boolean\n): IBoundsLike | null {\n  if (bbox1 === null) {\n    return bbox2;\n  }\n  if (bbox2 === null) {\n    return bbox1;\n  }\n\n  const { x11, x12, y11, y12, x21, x22, y21, y22 } = formatTwoBBox(bbox1, bbox2, format);\n\n  if (x11 >= x22 || x12 <= x21 || y11 >= y22 || y12 <= y21) {\n    return { x1: 0, y1: 0, x2: 0, y2: 0 };\n  }\n  return { x1: Math.max(x11, x21), y1: Math.max(y11, y21), x2: Math.min(x12, x22), y2: Math.min(y12, y22) };\n}\n\nexport enum InnerBBox {\n  NONE = 0,\n  BBOX1 = 1,\n  BBOX2 = 2\n}\n\nconst formatTwoBBox = (bbox1: IBoundsLike, bbox2: IBoundsLike, format: boolean) => {\n  let x11 = bbox1.x1;\n  let x12 = bbox1.x2;\n  let y11 = bbox1.y1;\n  let y12 = bbox1.y2;\n  let x21 = bbox2.x1;\n  let x22 = bbox2.x2;\n  let y21 = bbox2.y1;\n  let y22 = bbox2.y2;\n\n  if (format) {\n    if (x11 > x12) {\n      [x11, x12] = [x12, x11];\n    }\n    if (y11 > y12) {\n      [y11, y12] = [y12, y11];\n    }\n    if (x21 > x22) {\n      [x21, x22] = [x22, x21];\n    }\n    if (y21 > y22) {\n      [y21, y22] = [y22, y21];\n    }\n  }\n  return { x11, x12, y11, y12, x21, x22, y21, y22 };\n};\n/**\n * 矩形是否在另一个矩形内部\n * 返回InnerBBox\n * @param bbox1\n * @param bbox2\n * @param format\n */\nexport function rectInsideAnotherRect(\n  bbox1: IBoundsLike | null,\n  bbox2: IBoundsLike | null,\n  format: boolean\n): InnerBBox {\n  if (!bbox1 || !bbox2) {\n    return InnerBBox.NONE;\n  }\n\n  const { x11, x12, y11, y12, x21, x22, y21, y22 } = formatTwoBBox(bbox1, bbox2, format);\n  // bbox1在bbox2内部\n  if (x11 > x21 && x12 < x22 && y11 > y21 && y12 < y22) {\n    return InnerBBox.BBOX1;\n  }\n  // bbox2在bbox1内部\n  if (x21 > x11 && x22 < x12 && y21 > y11 && y22 < y12) {\n    return InnerBBox.BBOX2;\n  }\n\n  return InnerBBox.NONE;\n}\n\n/**\n * 两个矩形是否相交\n * 如果有矩形为null，判断为相交\n * @param bbox1\n * @param bbox2\n * @param format\n */\nexport function isRectIntersect(bbox1: IBoundsLike | null, bbox2: IBoundsLike | null, format: boolean): boolean {\n  if (bbox1 && bbox2) {\n    if (!format) {\n      if (bbox1.x1 > bbox2.x2 || bbox1.x2 < bbox2.x1 || bbox1.y1 > bbox2.y2 || bbox1.y2 < bbox2.y1) {\n        return false;\n      }\n      return true;\n    }\n\n    const { x11, x12, y11, y12, x21, x22, y21, y22 } = formatTwoBBox(bbox1, bbox2, true);\n\n    if (x11 > x22 || x12 < x21 || y11 > y22 || y12 < y21) {\n      return false;\n    }\n    return true;\n  }\n  return true;\n}\n\n/**\n * 点在box内部\n * 如果bbox为null返回true\n * @param point\n * @param bbox\n */\nexport function pointInRect(point: { x: number; y: number }, bbox: IBoundsLike | null, format: boolean): boolean {\n  if (!bbox) {\n    return true;\n  }\n  if (!format) {\n    return point.x >= bbox.x1 && point.x <= bbox.x2 && point.y >= bbox.y1 && point.y <= bbox.y2;\n  }\n  let x11 = bbox.x1;\n  let x12 = bbox.x2;\n  let y11 = bbox.y1;\n  let y12 = bbox.y2;\n  if (x11 > x12) {\n    [x11, x12] = [x12, x11];\n  }\n  if (y11 > y12) {\n    [y11, y12] = [y12, y11];\n  }\n  return point.x >= x11 && point.x <= x12 && point.y >= y11 && point.y <= y12;\n}\n\n// 参考https://github.com/francecil/leetcode/issues/1\n\n/**\n * 计算投影半径\n * @param {Array(Number)} checkAxis 检测轴 [cosθ,sinθ]\n * @param {Array} axis 目标轴 [x,y]\n */\nfunction getProjectionRadius(checkAxis: [number, number], axis: [number, number]) {\n  return Math.abs(axis[0] * checkAxis[0] + axis[1] * checkAxis[1]);\n}\n\n/**\n * 逆时针旋转矩阵（从正 x 轴开始，旋转到正 y 轴的方向）\n * [ cos(θ)  -sin(θ) ]\n * [ sin(θ)  cos(θ) ]\n */\nexport function rotatePoint({ x, y }: Point, rad: number, origin = { x: 0, y: 0 }) {\n  return {\n    x: (x - origin.x) * Math.cos(rad) - (y - origin.y) * Math.sin(rad) + origin.x,\n    y: (x - origin.x) * Math.sin(rad) + (y - origin.y) * Math.cos(rad) + origin.y\n  };\n}\n\nfunction getCenterPoint(box: RotateBound): Point {\n  return {\n    x: (box.x1 + box.x2) / 2,\n    y: (box.y1 + box.y2) / 2\n  };\n}\n\ninterface RotateBound extends IBoundsLike {\n  angle: number;\n  rotateCenter?: { x: number; y: number };\n}\n\n/**\n * 转化为顶点坐标数组\n * @param {Object} box\n */\nfunction toRect(box: RotateBound, isDeg: boolean) {\n  const deg = isDeg ? degreeToRadian(box.angle) : box.angle;\n  const cp = getCenterPoint(box);\n  return [\n    rotatePoint(\n      {\n        x: box.x1,\n        y: box.y1\n      },\n      deg,\n      cp\n    ),\n    rotatePoint(\n      {\n        x: box.x2,\n        y: box.y1\n      },\n      deg,\n      cp\n    ),\n    rotatePoint(\n      {\n        x: box.x2,\n        y: box.y2\n      },\n      deg,\n      cp\n    ),\n    rotatePoint(\n      {\n        x: box.x1,\n        y: box.y2\n      },\n      deg,\n      cp\n    )\n  ];\n}\nexport function isRotateAABBIntersect(box1: RotateBound, box2: RotateBound, isDeg = false) {\n  const rect1 = toRect(box1, isDeg);\n  const rect2 = toRect(box2, isDeg);\n\n  const vector = (start: Point, end: Point) => {\n    return [end.x - start.x, end.y - start.y] as [number, number];\n  };\n\n  // 两个矩形的中心点\n  const p1 = getCenterPoint(box1);\n  const p2 = getCenterPoint(box2);\n  // 向量 p1p2\n  const vp1p2 = vector(p1, p2);\n\n  //矩形1的两边向量\n  const AB = vector(rect1[0], rect1[1]);\n  const BC = vector(rect1[1], rect1[2]);\n  //矩形2的两边向量\n  const A1B1 = vector(rect2[0], rect2[1]);\n  const B1C1 = vector(rect2[1], rect2[2]);\n\n  // 矩形1 的两个弧度\n  const deg11 = isDeg ? degreeToRadian(box1.angle) : box1.angle;\n  let deg12 = isDeg ? degreeToRadian(90 - box1.angle) : box1.angle + halfPi;\n  // 矩形2 的两个弧度\n  const deg21 = isDeg ? degreeToRadian(box2.angle) : box2.angle;\n  let deg22 = isDeg ? degreeToRadian(90 - box2.angle) : box2.angle + halfPi;\n  if (deg12 > pi2) {\n    deg12 -= pi2;\n  }\n  if (deg22 > pi2) {\n    deg22 -= pi2;\n  }\n\n  // 投影重叠\n  const isCover = (\n    checkAxisRadius: number,\n    deg: number,\n    targetAxis1: [number, number],\n    targetAxis2: [number, number]\n  ) => {\n    const checkAxis = [Math.cos(deg), Math.sin(deg)] as [number, number];\n    const targetAxisRadius =\n      (getProjectionRadius(checkAxis, targetAxis1) + getProjectionRadius(checkAxis, targetAxis2)) / 2;\n    const centerPointRadius = getProjectionRadius(checkAxis, vp1p2);\n    // console.log('abc', `checkAxis:${checkAxis},三个投影:${checkAxisRadius}, ${targetAxisRadius}, ${centerPointRadius}`)\n    return checkAxisRadius + targetAxisRadius > centerPointRadius;\n  };\n\n  return (\n    isCover((box1.x2 - box1.x1) / 2, deg11, A1B1, B1C1) &&\n    isCover((box1.y2 - box1.y1) / 2, deg12, A1B1, B1C1) &&\n    isCover((box2.x2 - box2.x1) / 2, deg21, AB, BC) &&\n    isCover((box2.y2 - box2.y1) / 2, deg22, AB, BC)\n  );\n}\n"]}