(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@visactor/vchart')) :
	typeof define === 'function' && define.amd ? define(['exports', '@visactor/vchart'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VChartExtension = {}, global.VChart));
})(this, (function (exports, vchart) { 'use strict';

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var eventemitter3 = {exports: {}};

	(function (module) {

	  var has = Object.prototype.hasOwnProperty,
	    prefix = '~';

	  /**
	   * Constructor to create a storage for our `EE` objects.
	   * An `Events` instance is a plain object whose properties are event names.
	   *
	   * @constructor
	   * @private
	   */
	  function Events() {}

	  //
	  // We try to not inherit from `Object.prototype`. In some engines creating an
	  // instance in this way is faster than calling `Object.create(null)` directly.
	  // If `Object.create(null)` is not supported we prefix the event names with a
	  // character to make sure that the built-in object properties are not
	  // overridden or used as an attack vector.
	  //
	  if (Object.create) {
	    Events.prototype = Object.create(null);

	    //
	    // This hack is needed because the `__proto__` property is still inherited in
	    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
	    //
	    if (!new Events().__proto__) prefix = false;
	  }

	  /**
	   * Representation of a single event listener.
	   *
	   * @param {Function} fn The listener function.
	   * @param {*} context The context to invoke the listener with.
	   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
	   * @constructor
	   * @private
	   */
	  function EE(fn, context, once) {
	    this.fn = fn;
	    this.context = context;
	    this.once = once || false;
	  }

	  /**
	   * Add a listener for a given event.
	   *
	   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	   * @param {(String|Symbol)} event The event name.
	   * @param {Function} fn The listener function.
	   * @param {*} context The context to invoke the listener with.
	   * @param {Boolean} once Specify if the listener is a one-time listener.
	   * @returns {EventEmitter}
	   * @private
	   */
	  function addListener(emitter, event, fn, context, once) {
	    if (typeof fn !== 'function') {
	      throw new TypeError('The listener must be a function');
	    }
	    var listener = new EE(fn, context || emitter, once),
	      evt = prefix ? prefix + event : event;
	    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
	    return emitter;
	  }

	  /**
	   * Clear event by name.
	   *
	   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	   * @param {(String|Symbol)} evt The Event name.
	   * @private
	   */
	  function clearEvent(emitter, evt) {
	    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
	  }

	  /**
	   * Minimal `EventEmitter` interface that is molded against the Node.js
	   * `EventEmitter` interface.
	   *
	   * @constructor
	   * @public
	   */
	  function EventEmitter() {
	    this._events = new Events();
	    this._eventsCount = 0;
	  }

	  /**
	   * Return an array listing the events for which the emitter has registered
	   * listeners.
	   *
	   * @returns {Array}
	   * @public
	   */
	  EventEmitter.prototype.eventNames = function eventNames() {
	    var names = [],
	      events,
	      name;
	    if (this._eventsCount === 0) return names;
	    for (name in events = this._events) {
	      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
	    }
	    if (Object.getOwnPropertySymbols) {
	      return names.concat(Object.getOwnPropertySymbols(events));
	    }
	    return names;
	  };

	  /**
	   * Return the listeners registered for a given event.
	   *
	   * @param {(String|Symbol)} event The event name.
	   * @returns {Array} The registered listeners.
	   * @public
	   */
	  EventEmitter.prototype.listeners = function listeners(event) {
	    var evt = prefix ? prefix + event : event,
	      handlers = this._events[evt];
	    if (!handlers) return [];
	    if (handlers.fn) return [handlers.fn];
	    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
	      ee[i] = handlers[i].fn;
	    }
	    return ee;
	  };

	  /**
	   * Return the number of listeners listening to a given event.
	   *
	   * @param {(String|Symbol)} event The event name.
	   * @returns {Number} The number of listeners.
	   * @public
	   */
	  EventEmitter.prototype.listenerCount = function listenerCount(event) {
	    var evt = prefix ? prefix + event : event,
	      listeners = this._events[evt];
	    if (!listeners) return 0;
	    if (listeners.fn) return 1;
	    return listeners.length;
	  };

	  /**
	   * Calls each of the listeners registered for a given event.
	   *
	   * @param {(String|Symbol)} event The event name.
	   * @returns {Boolean} `true` if the event had listeners, else `false`.
	   * @public
	   */
	  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	    var evt = prefix ? prefix + event : event;
	    if (!this._events[evt]) return false;
	    var listeners = this._events[evt],
	      len = arguments.length,
	      args,
	      i;
	    if (listeners.fn) {
	      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
	      switch (len) {
	        case 1:
	          return listeners.fn.call(listeners.context), true;
	        case 2:
	          return listeners.fn.call(listeners.context, a1), true;
	        case 3:
	          return listeners.fn.call(listeners.context, a1, a2), true;
	        case 4:
	          return listeners.fn.call(listeners.context, a1, a2, a3), true;
	        case 5:
	          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	        case 6:
	          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	      }
	      for (i = 1, args = new Array(len - 1); i < len; i++) {
	        args[i - 1] = arguments[i];
	      }
	      listeners.fn.apply(listeners.context, args);
	    } else {
	      var length = listeners.length,
	        j;
	      for (i = 0; i < length; i++) {
	        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
	        switch (len) {
	          case 1:
	            listeners[i].fn.call(listeners[i].context);
	            break;
	          case 2:
	            listeners[i].fn.call(listeners[i].context, a1);
	            break;
	          case 3:
	            listeners[i].fn.call(listeners[i].context, a1, a2);
	            break;
	          case 4:
	            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
	            break;
	          default:
	            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
	              args[j - 1] = arguments[j];
	            }
	            listeners[i].fn.apply(listeners[i].context, args);
	        }
	      }
	    }
	    return true;
	  };

	  /**
	   * Add a listener for a given event.
	   *
	   * @param {(String|Symbol)} event The event name.
	   * @param {Function} fn The listener function.
	   * @param {*} [context=this] The context to invoke the listener with.
	   * @returns {EventEmitter} `this`.
	   * @public
	   */
	  EventEmitter.prototype.on = function on(event, fn, context) {
	    return addListener(this, event, fn, context, false);
	  };

	  /**
	   * Add a one-time listener for a given event.
	   *
	   * @param {(String|Symbol)} event The event name.
	   * @param {Function} fn The listener function.
	   * @param {*} [context=this] The context to invoke the listener with.
	   * @returns {EventEmitter} `this`.
	   * @public
	   */
	  EventEmitter.prototype.once = function once(event, fn, context) {
	    return addListener(this, event, fn, context, true);
	  };

	  /**
	   * Remove the listeners of a given event.
	   *
	   * @param {(String|Symbol)} event The event name.
	   * @param {Function} fn Only remove the listeners that match this function.
	   * @param {*} context Only remove the listeners that have this context.
	   * @param {Boolean} once Only remove one-time listeners.
	   * @returns {EventEmitter} `this`.
	   * @public
	   */
	  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	    var evt = prefix ? prefix + event : event;
	    if (!this._events[evt]) return this;
	    if (!fn) {
	      clearEvent(this, evt);
	      return this;
	    }
	    var listeners = this._events[evt];
	    if (listeners.fn) {
	      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
	        clearEvent(this, evt);
	      }
	    } else {
	      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
	        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
	          events.push(listeners[i]);
	        }
	      }

	      //
	      // Reset the array, or remove it completely if we have no more listeners.
	      //
	      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
	    }
	    return this;
	  };

	  /**
	   * Remove all listeners, or those of the specified event.
	   *
	   * @param {(String|Symbol)} [event] The event name.
	   * @returns {EventEmitter} `this`.
	   * @public
	   */
	  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	    var evt;
	    if (event) {
	      evt = prefix ? prefix + event : event;
	      if (this._events[evt]) clearEvent(this, evt);
	    } else {
	      this._events = new Events();
	      this._eventsCount = 0;
	    }
	    return this;
	  };

	  //
	  // Alias methods names because people roll like that.
	  //
	  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	  //
	  // Expose the prefix.
	  //
	  EventEmitter.prefixed = prefix;

	  //
	  // Allow `EventEmitter` to be imported as module namespace.
	  //
	  EventEmitter.EventEmitter = EventEmitter;

	  //
	  // Expose the module.
	  //
	  {
	    module.exports = EventEmitter;
	  }
	})(eventemitter3);
	var eventemitter3Exports = eventemitter3.exports;
	var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

	const isType = (value, type) => Object.prototype.toString.call(value) === `[object ${type}]`;
	var isType$1 = isType;

	const isBoolean = (value, fuzzy = !1) => fuzzy ? "boolean" == typeof value : !0 === value || !1 === value || isType$1(value, "Boolean");
	var isBoolean$1 = isBoolean;

	const isFunction = value => "function" == typeof value;
	var isFunction$1 = isFunction;

	const isNil = value => null == value;
	var isNil$1 = isNil;

	const isValid = value => null != value;
	var isValid$1 = isValid;

	const isObject = value => {
	  const type = typeof value;
	  return null !== value && "object" === type || "function" === type;
	};
	var isObject$1 = isObject;

	const isObjectLike = value => "object" == typeof value && null !== value;
	var isObjectLike$1 = isObjectLike;

	const isPlainObject = function (value) {
	  if (!isObjectLike$1(value) || !isType$1(value, "Object")) return !1;
	  if (null === Object.getPrototypeOf(value)) return !0;
	  let proto = value;
	  for (; null !== Object.getPrototypeOf(proto);) proto = Object.getPrototypeOf(proto);
	  return Object.getPrototypeOf(value) === proto;
	};
	var isPlainObject$1 = isPlainObject;

	const isString = (value, fuzzy = !1) => {
	  const type = typeof value;
	  return fuzzy ? "string" === type : "string" === type || isType$1(value, "String");
	};
	var isString$1 = isString;

	const isArray = value => Array.isArray ? Array.isArray(value) : isType$1(value, "Array");
	var isArray$1 = isArray;

	const isArrayLike = function (value) {
	  return null !== value && "function" != typeof value && Number.isFinite(value.length);
	};
	var isArrayLike$1 = isArrayLike;

	const isDate = value => isType$1(value, "Date");
	var isDate$1 = isDate;

	const isNumber = (value, fuzzy = !1) => {
	  const type = typeof value;
	  return fuzzy ? "number" === type : "number" === type || isType$1(value, "Number");
	};
	var isNumber$1 = isNumber;

	const isValidNumber = value => isNumber$1(value) && Number.isFinite(value);
	var isValidNumber$1 = isValidNumber;

	const isValidUrl = value => new RegExp(/^(http(s)?:\/\/)\w+[^\s]+(\.[^\s]+){1,}$/).test(value);
	var isValidUrl$1 = isValidUrl;

	const isBase64 = value => new RegExp(/^data:image\/(?:gif|png|jpeg|bmp|webp|svg\+xml)(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}/g).test(value);
	var isBase64$1 = isBase64;

	const getType = value => ({}).toString.call(value).replace(/^\[object /, "").replace(/]$/, "");
	var getType$1 = getType;

	const objectProto = Object.prototype,
	  isPrototype = function (value) {
	    const Ctor = value && value.constructor;
	    return value === ("function" == typeof Ctor && Ctor.prototype || objectProto);
	  };
	var isPrototype$1 = isPrototype;

	const hasOwnProperty = Object.prototype.hasOwnProperty;
	function isEmpty(value) {
	  if (isNil$1(value)) return !0;
	  if (isArrayLike$1(value)) return !value.length;
	  const type = getType$1(value);
	  if ("Map" === type || "Set" === type) return !value.size;
	  if (isPrototype$1(value)) return !Object.keys(value).length;
	  for (const key in value) if (hasOwnProperty.call(value, key)) return !1;
	  return !0;
	}

	const get = (obj, path, defaultValue) => {
	  const paths = isString$1(path) ? path.split(".") : path;
	  for (let p = 0; p < paths.length; p++) obj = obj ? obj[paths[p]] : void 0;
	  return void 0 === obj ? defaultValue : obj;
	};
	var get$1 = get;

	function cloneDeep(value, ignoreWhen, excludeKeys) {
	  let result;
	  if (!isValid$1(value) || "object" != typeof value || ignoreWhen && ignoreWhen(value)) return value;
	  const isArr = isArray$1(value),
	    length = value.length;
	  result = isArr ? new Array(length) : "object" == typeof value ? {} : isBoolean$1(value) || isNumber$1(value) || isString$1(value) ? value : isDate$1(value) ? new Date(+value) : void 0;
	  const props = isArr ? void 0 : Object.keys(Object(value));
	  let index = -1;
	  if (result) for (; ++index < (props || value).length;) {
	    const key = props ? props[index] : index,
	      subValue = value[key];
	    excludeKeys && excludeKeys.includes(key.toString()) ? result[key] = subValue : result[key] = cloneDeep(subValue, ignoreWhen, excludeKeys);
	  }
	  return result;
	}

	function baseMerge(target, source, shallowArray = !1, skipTargetArray = !1) {
	  if (source) {
	    if (target === source) return;
	    if (isValid$1(source) && "object" == typeof source) {
	      const iterable = Object(source),
	        props = [];
	      for (const key in iterable) props.push(key);
	      let {
	          length: length
	        } = props,
	        propIndex = -1;
	      for (; length--;) {
	        const key = props[++propIndex];
	        !isValid$1(iterable[key]) || "object" != typeof iterable[key] || skipTargetArray && isArray$1(target[key]) ? assignMergeValue(target, key, iterable[key]) : baseMergeDeep(target, source, key, shallowArray, skipTargetArray);
	      }
	    }
	  }
	}
	function baseMergeDeep(target, source, key, shallowArray = !1, skipTargetArray = !1) {
	  const objValue = target[key],
	    srcValue = source[key];
	  let newValue = source[key],
	    isCommon = !0;
	  if (isArray$1(srcValue)) {
	    if (shallowArray) newValue = [];else if (isArray$1(objValue)) newValue = objValue;else if (isArrayLike$1(objValue)) {
	      newValue = new Array(objValue.length);
	      let index = -1;
	      const length = objValue.length;
	      for (; ++index < length;) newValue[index] = objValue[index];
	    }
	  } else isPlainObject$1(srcValue) ? (newValue = null != objValue ? objValue : {}, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = !1;
	  isCommon && baseMerge(newValue, srcValue, shallowArray, skipTargetArray), assignMergeValue(target, key, newValue);
	}
	function assignMergeValue(target, key, value) {
	  (void 0 !== value && !eq(target[key], value) || void 0 === value && !(key in target)) && (target[key] = value);
	}
	function eq(value, other) {
	  return value === other || Number.isNaN(value) && Number.isNaN(other);
	}
	function merge(target, ...sources) {
	  let sourceIndex = -1;
	  const length = sources.length;
	  for (; ++sourceIndex < length;) {
	    baseMerge(target, sources[sourceIndex], !0);
	  }
	  return target;
	}

	function pickWithout(obj, keys) {
	  if (!obj || !isPlainObject$1(obj)) return obj;
	  const result = {};
	  return Object.keys(obj).forEach(k => {
	    const v = obj[k];
	    let match = !1;
	    keys.forEach(itKey => {
	      (isString$1(itKey) && itKey === k || itKey instanceof RegExp && k.match(itKey)) && (match = !0);
	    }), match || (result[k] = v);
	  }), result;
	}

	function objToString(obj) {
	  return Object.prototype.toString.call(obj);
	}
	function objectKeys(obj) {
	  return Object.keys(obj);
	}
	function isEqual(a, b, options) {
	  if (a === b) return !0;
	  if (typeof a != typeof b) return !1;
	  if (null == a || null == b) return !1;
	  if (Number.isNaN(a) && Number.isNaN(b)) return !0;
	  if (objToString(a) !== objToString(b)) return !1;
	  if (isFunction$1(a)) return !!(null == options ? void 0 : options.skipFunction);
	  if ("object" != typeof a) return !1;
	  if (isArray$1(a)) {
	    if (a.length !== b.length) return !1;
	    for (let i = a.length - 1; i >= 0; i--) if (!isEqual(a[i], b[i], options)) return !1;
	    return !0;
	  }
	  if (!isPlainObject$1(a)) return !1;
	  const ka = objectKeys(a),
	    kb = objectKeys(b);
	  if (ka.length !== kb.length) return !1;
	  ka.sort(), kb.sort();
	  for (let i = ka.length - 1; i >= 0; i--) if (ka[i] != kb[i]) return !1;
	  for (let i = ka.length - 1; i >= 0; i--) {
	    const key = ka[i];
	    if (!isEqual(a[key], b[key], options)) return !1;
	  }
	  return !0;
	}

	function keys(obj) {
	  if (!obj) return [];
	  if (Object.keys) return Object.keys(obj);
	  const keyList = [];
	  for (const key in obj) obj.hasOwnProperty(key) && keyList.push(key);
	  return keyList;
	}
	function defaults(target, source, overlay) {
	  const keysArr = keys(source);
	  for (let i = 0; i < keysArr.length; i++) {
	    const key = keysArr[i];
	    (overlay ? null != source[key] : null == target[key]) && (target[key] = source[key]);
	  }
	  return target;
	}
	function mixin(target, source, override = !0) {
	  if (target = "prototype" in target ? target.prototype : target, source = "prototype" in source ? source.prototype : source, Object.getOwnPropertyNames) {
	    const keyList = Object.getOwnPropertyNames(source);
	    for (let i = 0; i < keyList.length; i++) {
	      const key = keyList[i];
	      "constructor" !== key && (override ? null != source[key] : null == target[key]) && (target[key] = source[key]);
	    }
	  } else defaults(target, source, override);
	}

	function array(arr) {
	  return isValid$1(arr) ? isArray$1(arr) ? arr : [arr] : [];
	}
	function last(val) {
	  if (isArrayLike$1(val)) {
	    return val[val.length - 1];
	  }
	}
	const maxInArray = (arr, compareFn) => {
	  var _a;
	  if (0 === arr.length) return;
	  let max = arr[0];
	  for (let i = 1; i < arr.length; i++) {
	    const value = arr[i];
	    (null !== (_a = null == compareFn ? void 0 : compareFn(value, max)) && void 0 !== _a ? _a : value - max) > 0 && (max = value);
	  }
	  return max;
	};
	const minInArray = (arr, compareFn) => {
	  var _a;
	  if (0 === arr.length) return;
	  let min = arr[0];
	  for (let i = 1; i < arr.length; i++) {
	    const value = arr[i];
	    (null !== (_a = null == compareFn ? void 0 : compareFn(value, min)) && void 0 !== _a ? _a : value - min) < 0 && (min = value);
	  }
	  return min;
	};
	function arrayEqual(a, b) {
	  if (!isArray$1(a) || !isArray$1(b)) return !1;
	  if (a.length !== b.length) return !1;
	  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
	  return !0;
	}
	function flattenArray(arr) {
	  if (!isArray$1(arr)) return [arr];
	  const result = [];
	  for (const value of arr) result.push(...flattenArray(value));
	  return result;
	}

	function range$1(start, stop, step) {
	  isValid$1(stop) || (stop = start, start = 0), isValid$1(step) || (step = 1);
	  let i = -1;
	  const n = 0 | Math.max(0, Math.ceil((stop - start) / step)),
	    range = new Array(n);
	  for (; ++i < n;) range[i] = start + i * step;
	  return range;
	}

	function ascending$1(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function toNumber(a) {
	  return Number(a);
	}

	const hasConsole = "undefined" != typeof console;
	function log(method, level, input) {
	  const args = [level].concat([].slice.call(input));
	  hasConsole && console[method].apply(console, args);
	}
	var LoggerLevel;
	!function (LoggerLevel) {
	  LoggerLevel[LoggerLevel.None = 0] = "None", LoggerLevel[LoggerLevel.Error = 1] = "Error", LoggerLevel[LoggerLevel.Warn = 2] = "Warn", LoggerLevel[LoggerLevel.Info = 3] = "Info", LoggerLevel[LoggerLevel.Debug = 4] = "Debug";
	}(LoggerLevel || (LoggerLevel = {}));
	class Logger {
	  static getInstance(level, method) {
	    return Logger._instance && isNumber$1(level) ? Logger._instance.level(level) : Logger._instance || (Logger._instance = new Logger(level, method)), Logger._instance;
	  }
	  static setInstance(logger) {
	    return Logger._instance = logger;
	  }
	  static setInstanceLevel(level) {
	    Logger._instance ? Logger._instance.level(level) : Logger._instance = new Logger(level);
	  }
	  static clearInstance() {
	    Logger._instance = null;
	  }
	  constructor(level = LoggerLevel.None, method) {
	    this._onErrorHandler = [], this._level = level, this._method = method;
	  }
	  addErrorHandler(handler) {
	    this._onErrorHandler.find(h => h === handler) || this._onErrorHandler.push(handler);
	  }
	  removeErrorHandler(handler) {
	    const index = this._onErrorHandler.findIndex(h => h === handler);
	    index < 0 || this._onErrorHandler.splice(index, 1);
	  }
	  callErrorHandler(...args) {
	    this._onErrorHandler.forEach(h => h(...args));
	  }
	  canLogInfo() {
	    return this._level >= LoggerLevel.Info;
	  }
	  canLogDebug() {
	    return this._level >= LoggerLevel.Debug;
	  }
	  canLogError() {
	    return this._level >= LoggerLevel.Error;
	  }
	  canLogWarn() {
	    return this._level >= LoggerLevel.Warn;
	  }
	  level(levelValue) {
	    return arguments.length ? (this._level = +levelValue, this) : this._level;
	  }
	  error(...args) {
	    var _a;
	    return this._level >= LoggerLevel.Error && (this._onErrorHandler.length ? this.callErrorHandler(...args) : log(null !== (_a = this._method) && void 0 !== _a ? _a : "error", "ERROR", args)), this;
	  }
	  warn(...args) {
	    return this._level >= LoggerLevel.Warn && log(this._method || "warn", "WARN", args), this;
	  }
	  info(...args) {
	    return this._level >= LoggerLevel.Info && log(this._method || "log", "INFO", args), this;
	  }
	  debug(...args) {
	    return this._level >= LoggerLevel.Debug && log(this._method || "log", "DEBUG", args), this;
	  }
	}
	Logger._instance = null;

	function bisect(a, x, lo = 0, hi) {
	  for (isNil$1(hi) && (hi = a.length); lo < hi;) {
	    const mid = lo + hi >>> 1;
	    ascending$1(a[mid], x) > 0 ? hi = mid : lo = mid + 1;
	  }
	  return lo;
	}

	const DEFAULT_ABSOLUTE_TOLERATE = 1e-10,
	  DEFAULT_RELATIVE_TOLERATE = 1e-10;
	function isNumberClose(a, b, relTol = DEFAULT_RELATIVE_TOLERATE, absTol = DEFAULT_ABSOLUTE_TOLERATE) {
	  const abs = absTol,
	    rel = relTol * Math.max(a, b);
	  return Math.abs(a - b) <= Math.max(abs, rel);
	}

	const memoize = func => {
	  let lastArgs = null,
	    lastResult = null;
	  return (...args) => (lastArgs && args.every((val, i) => val === lastArgs[i]) || (lastArgs = args, lastResult = func(...args)), lastResult);
	};

	const clamp = function (input, min, max) {
	  return input < min ? min : input > max ? max : input;
	};
	var clamp$1 = clamp;

	function clamper(a, b) {
	  let t;
	  return a > b && (t = a, a = b, b = t), x => Math.max(a, Math.min(b, x));
	}

	function interpolateNumber$1(a, b) {
	  return t => a * (1 - t) + b * t;
	}
	function interpolateNumberRound(a, b) {
	  return function (t) {
	    return Math.round(a * (1 - t) + b * t);
	  };
	}
	function interpolateDate(a, b) {
	  const aVal = a.valueOf(),
	    bVal = b.valueOf(),
	    d = new Date();
	  return t => (d.setTime(aVal * (1 - t) + bVal * t), d);
	}

	const fakeRandom = () => {
	  let i = -1;
	  const arr = [0, .1, .2, .3, .4, .5, .6, .7, .8, .9];
	  return () => (i = (i + 1) % arr.length, arr[i]);
	};

	const getter = path => obj => get$1(obj, path);
	const fieldSingle = (fieldStr, opt = {}) => {
	  if (isFunction$1(fieldStr)) return fieldStr;
	  const path = [fieldStr];
	  return (opt && opt.get || getter)(path);
	};
	const field = (fieldStr, opt = {}) => {
	  if (isArray$1(fieldStr)) {
	    const funcs = fieldStr.map(entry => fieldSingle(entry, opt));
	    return datum => funcs.map(func => func(datum));
	  }
	  return fieldSingle(fieldStr, opt);
	};
	const simpleField = option => option ? "string" == typeof option || "number" == typeof option ? () => option : isFunction$1(option) ? option : datum => datum[option.field] : null;

	const extent = (array, func) => {
	  const valueGetter = isFunction$1(func) ? func : val => val;
	  let min, max;
	  if (array && array.length) {
	    const n = array.length;
	    for (let i = 0; i < n; i += 1) {
	      let value = valueGetter(array[i]);
	      isNil$1(value) || !isNumber$1(value = +value) || Number.isNaN(value) || (isNil$1(min) ? (min = value, max = value) : (min = Math.min(min, value), max = Math.max(max, value)));
	    }
	    return [min, max];
	  }
	  return [min, max];
	};

	const epsilon = 1e-12;
	const pi = Math.PI;
	const halfPi$1 = pi / 2;
	const tau = 2 * pi;
	const pi2 = 2 * Math.PI;
	const abs = Math.abs;
	const atan2 = Math.atan2;
	const cos = Math.cos;
	const max = Math.max;
	const min = Math.min;
	const sin = Math.sin;
	const sqrt$1 = Math.sqrt;
	const pow = Math.pow;
	function acos(x) {
	  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
	}
	function asin(x) {
	  return x >= 1 ? halfPi$1 : x <= -1 ? -halfPi$1 : Math.asin(x);
	}
	function pointAt(x1, y1, x2, y2, t) {
	  let x = x2,
	    y = y2;
	  return "number" == typeof x1 && "number" == typeof x2 && (x = (1 - t) * x1 + t * x2), "number" == typeof y1 && "number" == typeof y2 && (y = (1 - t) * y1 + t * y2), {
	    x: x,
	    y: y
	  };
	}
	function crossProduct(dir1, dir2) {
	  return dir1[0] * dir2[1] - dir1[1] * dir2[0];
	}
	function fuzzyEqualVec(a, b) {
	  return abs(a[0] - b[0]) + abs(a[1] - b[1]) < 1e-12;
	}

	class Point {
	  constructor(x = 0, y = 0, x1, y1) {
	    this.x = 0, this.y = 0, this.x = x, this.y = y, this.x1 = x1, this.y1 = y1;
	  }
	  clone() {
	    return new Point(this.x, this.y);
	  }
	  copyFrom(p) {
	    return this.x = p.x, this.y = p.y, this.x1 = p.x1, this.y1 = p.y1, this.defined = p.defined, this.context = p.context, this;
	  }
	  set(x, y) {
	    return this.x = x, this.y = y, this;
	  }
	  add(point) {
	    return isNumber$1(point) ? (this.x += point, void (this.y += point)) : (this.x += point.x, this.y += point.y, this);
	  }
	  sub(point) {
	    return isNumber$1(point) ? (this.x -= point, void (this.y -= point)) : (this.x -= point.x, this.y -= point.y, this);
	  }
	  multi(point) {
	    throw new Error("暂不支持");
	  }
	  div(point) {
	    throw new Error("暂不支持");
	  }
	}
	class PointService {
	  static distancePP(p1, p2) {
	    return sqrt$1(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
	  }
	  static distanceNN(x, y, x1, y1) {
	    return sqrt$1(pow(x - x1, 2) + pow(y - y1, 2));
	  }
	  static distancePN(point, x, y) {
	    return sqrt$1(pow(x - point.x, 2) + pow(y - point.y, 2));
	  }
	  static pointAtPP(p1, p2, t) {
	    return new Point((p2.x - p1.x) * t + p1.x, (p2.y - p1.y) * t + p1.y);
	  }
	}

	function degreeToRadian(degree) {
	  return degree * (Math.PI / 180);
	}
	function radianToDegree(radian) {
	  return 180 * radian / Math.PI;
	}
	const clampRadian = (angle = 0) => {
	  if (angle < 0) for (; angle < -tau;) angle += tau;else if (angle > 0) for (; angle > tau;) angle -= tau;
	  return angle;
	};
	const clampAngleByRadian = clampRadian;
	function polarToCartesian(center, radius, angleInRadian) {
	  return radius ? {
	    x: center.x + radius * Math.cos(angleInRadian),
	    y: center.y + radius * Math.sin(angleInRadian)
	  } : {
	    x: center.x,
	    y: center.y
	  };
	}
	function normalizeAngle(angle) {
	  for (; angle < 0;) angle += 2 * Math.PI;
	  for (; angle >= 2 * Math.PI;) angle -= 2 * Math.PI;
	  return angle;
	}

	function sub(out, v1, v2) {
	  out[0] = v1[0] - v2[0], out[1] = v1[1] - v2[1];
	}
	function isIntersect(left1, right1, left2, right2) {
	  let min1 = left1[0],
	    max1 = right1[0],
	    min2 = left2[0],
	    max2 = right2[0];
	  return max1 < min1 && ([min1, max1] = [max1, min1]), max2 < min2 && ([max2, min2] = [min2, max2]), !(max1 < min2 || max2 < min1) && (min1 = left1[1], max1 = right1[1], min2 = left2[1], max2 = right2[1], max1 < min1 && ([min1, max1] = [max1, min1]), max2 < min2 && ([max2, min2] = [min2, max2]), !(max1 < min2 || max2 < min1));
	}
	function getIntersectPoint(left1, right1, left2, right2) {
	  if (!isIntersect(left1, right1, left2, right2)) return !1;
	  const dir1 = [0, 0],
	    dir2 = [0, 0],
	    tempVec = [0, 0];
	  if (sub(dir1, right1, left1), sub(dir2, right2, left2), fuzzyEqualVec(dir1, dir2)) return !0;
	  sub(tempVec, left2, left1);
	  const t = crossProduct(tempVec, dir2) / crossProduct(dir1, dir2);
	  return t >= 0 && t <= 1 && [left1[0] + dir1[0] * t, left1[1] + dir1[1] * t];
	}
	var InnerBBox;
	!function (InnerBBox) {
	  InnerBBox[InnerBBox.NONE = 0] = "NONE", InnerBBox[InnerBBox.BBOX1 = 1] = "BBOX1", InnerBBox[InnerBBox.BBOX2 = 2] = "BBOX2";
	}(InnerBBox || (InnerBBox = {}));
	function pointInRect(point, bbox, format) {
	  if (!bbox) return !0;
	  if (!format) return point.x >= bbox.x1 && point.x <= bbox.x2 && point.y >= bbox.y1 && point.y <= bbox.y2;
	  let x11 = bbox.x1,
	    x12 = bbox.x2,
	    y11 = bbox.y1,
	    y12 = bbox.y2;
	  return x11 > x12 && ([x11, x12] = [x12, x11]), y11 > y12 && ([y11, y12] = [y12, y11]), point.x >= x11 && point.x <= x12 && point.y >= y11 && point.y <= y12;
	}
	function getProjectionRadius(checkAxis, axis) {
	  return Math.abs(axis[0] * checkAxis[0] + axis[1] * checkAxis[1]);
	}
	function rotatePoint({
	  x: x,
	  y: y
	}, rad, origin = {
	  x: 0,
	  y: 0
	}) {
	  return {
	    x: (x - origin.x) * Math.cos(rad) - (y - origin.y) * Math.sin(rad) + origin.x,
	    y: (x - origin.x) * Math.sin(rad) + (y - origin.y) * Math.cos(rad) + origin.y
	  };
	}
	function getCenterPoint(box) {
	  return {
	    x: (box.x1 + box.x2) / 2,
	    y: (box.y1 + box.y2) / 2
	  };
	}
	function toRect$1(box, isDeg) {
	  const deg = isDeg ? degreeToRadian(box.angle) : box.angle,
	    cp = getCenterPoint(box);
	  return [rotatePoint({
	    x: box.x1,
	    y: box.y1
	  }, deg, cp), rotatePoint({
	    x: box.x2,
	    y: box.y1
	  }, deg, cp), rotatePoint({
	    x: box.x2,
	    y: box.y2
	  }, deg, cp), rotatePoint({
	    x: box.x1,
	    y: box.y2
	  }, deg, cp)];
	}
	function isRotateAABBIntersect(box1, box2, isDeg = !1) {
	  const rect1 = toRect$1(box1, isDeg),
	    rect2 = toRect$1(box2, isDeg),
	    vector = (start, end) => [end.x - start.x, end.y - start.y],
	    vp1p2 = vector(getCenterPoint(box1), getCenterPoint(box2)),
	    AB = vector(rect1[0], rect1[1]),
	    BC = vector(rect1[1], rect1[2]),
	    A1B1 = vector(rect2[0], rect2[1]),
	    B1C1 = vector(rect2[1], rect2[2]),
	    deg11 = isDeg ? degreeToRadian(box1.angle) : box1.angle;
	  let deg12 = isDeg ? degreeToRadian(90 - box1.angle) : box1.angle + halfPi$1;
	  const deg21 = isDeg ? degreeToRadian(box2.angle) : box2.angle;
	  let deg22 = isDeg ? degreeToRadian(90 - box2.angle) : box2.angle + halfPi$1;
	  deg12 > pi2 && (deg12 -= pi2), deg22 > pi2 && (deg22 -= pi2);
	  const isCover = (checkAxisRadius, deg, targetAxis1, targetAxis2) => {
	    const checkAxis = [Math.cos(deg), Math.sin(deg)];
	    return checkAxisRadius + (getProjectionRadius(checkAxis, targetAxis1) + getProjectionRadius(checkAxis, targetAxis2)) / 2 > getProjectionRadius(checkAxis, vp1p2);
	  };
	  return isCover((box1.x2 - box1.x1) / 2, deg11, A1B1, B1C1) && isCover((box1.y2 - box1.y1) / 2, deg12, A1B1, B1C1) && isCover((box2.x2 - box2.x1) / 2, deg21, AB, BC) && isCover((box2.y2 - box2.y1) / 2, deg22, AB, BC);
	}

	let x1, y1, x2, y2;
	function getAABBFromPoints(points) {
	  return x1 = 1 / 0, y1 = 1 / 0, x2 = -1 / 0, y2 = -1 / 0, points.forEach(point => {
	    x1 > point.x && (x1 = point.x), x2 < point.x && (x2 = point.x), y1 > point.y && (y1 = point.y), y2 < point.y && (y2 = point.y);
	  }), {
	    x1: x1,
	    y1: y1,
	    x2: x2,
	    y2: y2
	  };
	}

	const EPSILON$1 = 1e-8;
	function polygonContainPoint(points, x, y) {
	  let w = 0,
	    p = points[0];
	  if (!p) return !1;
	  for (let i = 1; i < points.length; i++) {
	    const p2 = points[i];
	    w += isPointInLine(p.x, p.y, p2.x, p2.y, x, y), p = p2;
	  }
	  const p0 = points[0];
	  return isAroundEqual$1(p.x, p0.x) && isAroundEqual$1(p.y, p0.y) || (w += isPointInLine(p.x, p.y, p0.x, p0.y, x, y)), 0 !== w;
	}
	function isPointInLine(x0, y0, x1, y1, x, y) {
	  if (y > y0 && y > y1 || y < y0 && y < y1) return 0;
	  if (y1 === y0) return 0;
	  const t = (y - y0) / (y1 - y0);
	  let dir = y1 < y0 ? 1 : -1;
	  1 !== t && 0 !== t || (dir = y1 < y0 ? .5 : -.5);
	  const x_ = t * (x1 - x0) + x0;
	  return x_ === x ? 1 / 0 : x_ > x ? dir : 0;
	}
	function isAroundEqual$1(a, b) {
	  return Math.abs(a - b) < EPSILON$1;
	}

	const eastAsianCharacterInfo = character => {
	  let x = character.charCodeAt(0),
	    y = 2 === character.length ? character.charCodeAt(1) : 0,
	    codePoint = x;
	  return 55296 <= x && x <= 56319 && 56320 <= y && y <= 57343 && (x &= 1023, y &= 1023, codePoint = x << 10 | y, codePoint += 65536), 12288 === codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : 8361 === codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 === codePoint || 175 === codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : 161 === codePoint || 164 === codePoint || 167 <= codePoint && codePoint <= 168 || 170 === codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 === codePoint || 208 === codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 === codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 === codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 === codePoint || 254 === codePoint || 257 === codePoint || 273 === codePoint || 275 === codePoint || 283 === codePoint || 294 <= codePoint && codePoint <= 295 || 299 === codePoint || 305 <= codePoint && codePoint <= 307 || 312 === codePoint || 319 <= codePoint && codePoint <= 322 || 324 === codePoint || 328 <= codePoint && codePoint <= 331 || 333 === codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 === codePoint || 462 === codePoint || 464 === codePoint || 466 === codePoint || 468 === codePoint || 470 === codePoint || 472 === codePoint || 474 === codePoint || 476 === codePoint || 593 === codePoint || 609 === codePoint || 708 === codePoint || 711 === codePoint || 713 <= codePoint && codePoint <= 715 || 717 === codePoint || 720 === codePoint || 728 <= codePoint && codePoint <= 731 || 733 === codePoint || 735 === codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 === codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 === codePoint || 8208 === codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 === codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 === codePoint || 8251 === codePoint || 8254 === codePoint || 8308 === codePoint || 8319 === codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 === codePoint || 8451 === codePoint || 8453 === codePoint || 8457 === codePoint || 8467 === codePoint || 8470 === codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 === codePoint || 8491 === codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 === codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 === codePoint || 8660 === codePoint || 8679 === codePoint || 8704 === codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 === codePoint || 8719 === codePoint || 8721 === codePoint || 8725 === codePoint || 8730 === codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 === codePoint || 8741 === codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 === codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 === codePoint || 8780 === codePoint || 8786 === codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 === codePoint || 8857 === codePoint || 8869 === codePoint || 8895 === codePoint || 8978 === codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 === codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 === codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 === codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 === codePoint || 9758 === codePoint || 9792 === codePoint || 9794 === codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 === codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 === codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 === codePoint || 10071 === codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 === codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
	};

	function getContextFont(text, defaultAttr = {}, fontSizeScale) {
	  fontSizeScale || (fontSizeScale = 1);
	  const {
	    fontStyle = defaultAttr.fontStyle,
	    fontVariant = defaultAttr.fontVariant,
	    fontWeight = defaultAttr.fontWeight,
	    fontSize = defaultAttr.fontSize,
	    fontFamily = defaultAttr.fontFamily
	  } = text;
	  return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize * fontSizeScale + "px " + (fontFamily || "sans-serif");
	}

	class TextMeasure {
	  constructor(option, textSpec) {
	    this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = !1, this._notSupportCanvas = !1, this._notSupportVRender = !1, this._userSpec = {}, this.specialCharSet = "-/: .,@%'\"~", this._option = option, this._userSpec = null != textSpec ? textSpec : {}, this.textSpec = this._initSpec(), isValid$1(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), this._standardMethod = isValid$1(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
	  }
	  initContext() {
	    if (this._notSupportCanvas) return !1;
	    if (isNil$1(this._canvas) && (isValid$1(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), isNil$1(this._canvas) && "undefined" != typeof window && void 0 !== window.document && globalThis && isValid$1(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), isNil$1(this._context) && isValid$1(this._canvas)) {
	      const context = this._canvas.getContext("2d");
	      isValid$1(context) && (context.save(), context.font = getContextFont(this.textSpec), this._contextSaved = !0, this._context = context);
	    }
	    return !isNil$1(this._context) || (this._notSupportCanvas = !0, !1);
	  }
	  _initSpec() {
	    var _a, _b, _c;
	    const {
	        defaultFontParams = {}
	      } = this._option,
	      {
	        fontStyle = defaultFontParams.fontStyle,
	        fontVariant = defaultFontParams.fontVariant,
	        fontWeight = null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal",
	        fontSize = null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12,
	        fontFamily = null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif",
	        align: align,
	        textAlign = null != align ? align : "center",
	        baseline: baseline,
	        textBaseline = null != baseline ? baseline : "middle",
	        ellipsis: ellipsis,
	        limit: limit
	      } = this._userSpec;
	    let {
	      lineHeight = fontSize
	    } = this._userSpec;
	    if (isString$1(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
	      const scale = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
	      lineHeight = fontSize * scale;
	    }
	    return {
	      fontStyle: fontStyle,
	      fontVariant: fontVariant,
	      fontFamily: fontFamily,
	      fontSize: fontSize,
	      fontWeight: fontWeight,
	      textAlign: textAlign,
	      textBaseline: textBaseline,
	      ellipsis: ellipsis,
	      limit: limit,
	      lineHeight: lineHeight
	    };
	  }
	  measure(text, method) {
	    switch (method) {
	      case "vrender":
	      case "canopus":
	        return this.fullMeasure(text);
	      case "canvas":
	        return this.measureWithNaiveCanvas(text);
	      case "simple":
	        return this.quickMeasureWithoutCanvas(text);
	      default:
	        return this.quickMeasure(text);
	    }
	  }
	  fullMeasure(text) {
	    if (isNil$1(text)) return {
	      width: 0,
	      height: 0
	    };
	    if (isNil$1(this._option.getTextBounds) || !this._notSupportVRender) return this.measureWithNaiveCanvas(text);
	    const {
	      fontFamily: fontFamily,
	      fontSize: fontSize,
	      fontWeight: fontWeight,
	      textAlign: textAlign,
	      textBaseline: textBaseline,
	      ellipsis: ellipsis,
	      limit: limit,
	      lineHeight: lineHeight
	    } = this.textSpec;
	    let size;
	    try {
	      const bounds = this._option.getTextBounds({
	        text: text,
	        fontFamily: fontFamily,
	        fontSize: fontSize,
	        fontWeight: fontWeight,
	        textAlign: textAlign,
	        textBaseline: textBaseline,
	        ellipsis: !!ellipsis,
	        maxLineWidth: limit || 1 / 0,
	        lineHeight: lineHeight
	      });
	      size = {
	        width: bounds.width(),
	        height: bounds.height()
	      };
	    } catch (e) {
	      this._notSupportVRender = !0, size = this.measureWithNaiveCanvas(text);
	    }
	    return size;
	  }
	  measureWithNaiveCanvas(text) {
	    return this._measureReduce(text, this._measureWithNaiveCanvas.bind(this));
	  }
	  _measureWithNaiveCanvas(text) {
	    var _a;
	    if (!this.initContext()) return this._quickMeasureWithoutCanvas(text);
	    const metrics = this._context.measureText(text),
	      {
	        fontSize: fontSize,
	        lineHeight: lineHeight
	      } = this.textSpec;
	    return {
	      width: metrics.width,
	      height: null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize,
	      fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
	      fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
	    };
	  }
	  quickMeasure(text) {
	    return this._measureReduce(text, this._quickMeasure.bind(this));
	  }
	  _quickMeasure(text) {
	    const totalSize = {
	      width: 0,
	      height: 0
	    };
	    for (let i = 0; i < text.length; i++) {
	      const char = text[i];
	      let size = this._measureSpecialChar(char);
	      isNil$1(size) && TextMeasure.NUMBERS_CHAR_SET.includes(char) && (size = this._measureNumberChar()), isNil$1(size) && ["F", "W"].includes(eastAsianCharacterInfo(char)) && (size = this._measureFullSizeChar()), isNil$1(size) && (size = this._measureLetterChar()), totalSize.width += size.width, totalSize.height = Math.max(totalSize.height, size.height), !isNil$1(size.fontBoundingBoxAscent) && (totalSize.fontBoundingBoxAscent = size.fontBoundingBoxAscent), !isNil$1(size.fontBoundingBoxDescent) && (totalSize.fontBoundingBoxDescent = size.fontBoundingBoxDescent);
	    }
	    return totalSize;
	  }
	  quickMeasureWithoutCanvas(text) {
	    return this._measureReduce(text, this._quickMeasureWithoutCanvas.bind(this));
	  }
	  _quickMeasureWithoutCanvas(text) {
	    var _a;
	    const totalSize = {
	        width: 0,
	        height: 0
	      },
	      {
	        fontSize: fontSize,
	        lineHeight: lineHeight
	      } = this.textSpec;
	    for (let i = 0; i < text.length; i++) {
	      const char = text[i],
	        size = ["F", "W"].includes(eastAsianCharacterInfo(char)) ? 1 : .53;
	      totalSize.width += size * fontSize;
	    }
	    return totalSize.height = null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize, totalSize;
	  }
	  _measureReduce(text, processor) {
	    var _a;
	    const {
	        fontSize: fontSize,
	        lineHeight: lineHeight
	      } = this.textSpec,
	      defaultResult = {
	        width: 0,
	        height: 0
	      };
	    if (isNil$1(text)) return defaultResult;
	    if (isArray$1(text)) {
	      const textArr = text.filter(isValid$1).map(s => s.toString());
	      return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
	        width: textArr.reduce((maxWidth, cur) => Math.max(maxWidth, processor(cur).width), 0),
	        height: textArr.length * ((null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize) + 1) + 1
	      };
	    }
	    return processor(text.toString());
	  }
	  _measureNumberChar() {
	    if (isNil$1(this._numberCharSize)) {
	      const numberBounds = this._standardMethod(TextMeasure.NUMBERS_CHAR_SET);
	      this._numberCharSize = {
	        width: numberBounds.width / TextMeasure.NUMBERS_CHAR_SET.length,
	        height: numberBounds.height,
	        fontBoundingBoxAscent: numberBounds.fontBoundingBoxAscent,
	        fontBoundingBoxDescent: numberBounds.fontBoundingBoxDescent
	      };
	    }
	    return this._numberCharSize;
	  }
	  _measureFullSizeChar() {
	    return isNil$1(this._fullCharSize) && (this._fullCharSize = this._standardMethod(TextMeasure.FULL_SIZE_CHAR)), this._fullCharSize;
	  }
	  _measureLetterChar() {
	    if (isNil$1(this._letterCharSize)) {
	      const alphabetBounds = this._standardMethod(TextMeasure.ALPHABET_CHAR_SET);
	      this._letterCharSize = {
	        width: alphabetBounds.width / TextMeasure.ALPHABET_CHAR_SET.length,
	        height: alphabetBounds.height,
	        fontBoundingBoxAscent: alphabetBounds.fontBoundingBoxAscent,
	        fontBoundingBoxDescent: alphabetBounds.fontBoundingBoxDescent
	      };
	    }
	    return this._letterCharSize;
	  }
	  _measureSpecialChar(char) {
	    return isValid$1(this._specialCharSizeMap[char]) ? this._specialCharSizeMap[char] : this.specialCharSet.includes(char) ? (this._specialCharSizeMap[char] = this._standardMethod(char), this._specialCharSizeMap[char]) : null;
	  }
	  release() {
	    isValid$1(this._canvas) && (this._canvas = null), isValid$1(this._context) && (this._contextSaved && (this._context.restore(), this._contextSaved = !1), this._context = null);
	  }
	}
	TextMeasure.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure.NUMBERS_CHAR_SET = "0123456789", TextMeasure.FULL_SIZE_CHAR = "字";

	function transformBoundsWithMatrix(out, bounds, matrix) {
	  const {
	    x1: x1,
	    y1: y1,
	    x2: x2,
	    y2: y2
	  } = bounds;
	  return matrix.onlyTranslate() ? (out !== bounds && out.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), out.translate(matrix.e, matrix.f), bounds) : (out.clear(), out.add(matrix.a * x1 + matrix.c * y1 + matrix.e, matrix.b * x1 + matrix.d * y1 + matrix.f), out.add(matrix.a * x2 + matrix.c * y1 + matrix.e, matrix.b * x2 + matrix.d * y1 + matrix.f), out.add(matrix.a * x2 + matrix.c * y2 + matrix.e, matrix.b * x2 + matrix.d * y2 + matrix.f), out.add(matrix.a * x1 + matrix.c * y2 + matrix.e, matrix.b * x1 + matrix.d * y2 + matrix.f), bounds);
	}
	class Bounds {
	  constructor(bounds) {
	    bounds ? this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2) : this.clear();
	  }
	  clone() {
	    return new Bounds(this);
	  }
	  clear() {
	    return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
	  }
	  empty() {
	    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
	  }
	  equals(b) {
	    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
	  }
	  setValue(x1 = 0, y1 = 0, x2 = 0, y2 = 0) {
	    return this.x1 = x1, this.y1 = y1, this.x2 = x2, this.y2 = y2, this;
	  }
	  set(x1 = 0, y1 = 0, x2 = 0, y2 = 0) {
	    return x2 < x1 ? (this.x2 = x1, this.x1 = x2) : (this.x1 = x1, this.x2 = x2), y2 < y1 ? (this.y2 = y1, this.y1 = y2) : (this.y1 = y1, this.y2 = y2), this;
	  }
	  add(x = 0, y = 0) {
	    return x < this.x1 && (this.x1 = x), y < this.y1 && (this.y1 = y), x > this.x2 && (this.x2 = x), y > this.y2 && (this.y2 = y), this;
	  }
	  expand(d = 0) {
	    return isArray$1(d) ? (this.y1 -= d[0], this.x2 += d[1], this.y2 += d[2], this.x1 -= d[3]) : (this.x1 -= d, this.y1 -= d, this.x2 += d, this.y2 += d), this;
	  }
	  round() {
	    return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
	  }
	  translate(dx = 0, dy = 0) {
	    return this.x1 += dx, this.x2 += dx, this.y1 += dy, this.y2 += dy, this;
	  }
	  rotate(angle = 0, x = 0, y = 0) {
	    const p = this.rotatedPoints(angle, x, y);
	    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
	  }
	  scale(sx = 0, sy = 0, x = 0, y = 0) {
	    const p = this.scalePoints(sx, sy, x, y);
	    return this.clear().add(p[0], p[1]).add(p[2], p[3]);
	  }
	  union(b) {
	    return b.x1 < this.x1 && (this.x1 = b.x1), b.y1 < this.y1 && (this.y1 = b.y1), b.x2 > this.x2 && (this.x2 = b.x2), b.y2 > this.y2 && (this.y2 = b.y2), this;
	  }
	  intersect(b) {
	    return b.x1 > this.x1 && (this.x1 = b.x1), b.y1 > this.y1 && (this.y1 = b.y1), b.x2 < this.x2 && (this.x2 = b.x2), b.y2 < this.y2 && (this.y2 = b.y2), this;
	  }
	  encloses(b) {
	    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
	  }
	  alignsWith(b) {
	    return b && (this.x1 === b.x1 || this.x2 === b.x2 || this.y1 === b.y1 || this.y2 === b.y2);
	  }
	  intersects(b) {
	    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
	  }
	  contains(x = 0, y = 0) {
	    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
	  }
	  containsPoint(p) {
	    return !(p.x < this.x1 || p.x > this.x2 || p.y < this.y1 || p.y > this.y2);
	  }
	  width() {
	    return this.empty() ? 0 : this.x2 - this.x1;
	  }
	  height() {
	    return this.empty() ? 0 : this.y2 - this.y1;
	  }
	  scaleX(s = 0) {
	    return this.x1 *= s, this.x2 *= s, this;
	  }
	  scaleY(s = 0) {
	    return this.y1 *= s, this.y2 *= s, this;
	  }
	  transformWithMatrix(matrix) {
	    return transformBoundsWithMatrix(this, this, matrix), this;
	  }
	  copy(b) {
	    return this.x1 = b.x1, this.y1 = b.y1, this.x2 = b.x2, this.y2 = b.y2, this;
	  }
	  rotatedPoints(angle, x, y) {
	    const {
	        x1: x1,
	        y1: y1,
	        x2: x2,
	        y2: y2
	      } = this,
	      cos = Math.cos(angle),
	      sin = Math.sin(angle),
	      cx = x - x * cos + y * sin,
	      cy = y - x * sin - y * cos;
	    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];
	  }
	  scalePoints(sx, sy, x, y) {
	    const {
	      x1: x1,
	      y1: y1,
	      x2: x2,
	      y2: y2
	    } = this;
	    return [sx * x1 + (1 - sx) * x, sy * y1 + (1 - sy) * y, sx * x2 + (1 - sx) * x, sy * y2 + (1 - sy) * y];
	  }
	}
	class AABBBounds extends Bounds {}
	class OBBBounds extends Bounds {
	  constructor(bounds, angle = 0) {
	    var _a;
	    super(bounds), bounds && (this.angle = null !== (_a = bounds.angle) && void 0 !== _a ? _a : angle);
	  }
	  intersects(b) {
	    return isRotateAABBIntersect(this, b);
	  }
	  setValue(x1 = 0, y1 = 0, x2 = 0, y2 = 0, angle = 0) {
	    return super.setValue(x1, y1, x2, y2), this.angle = angle, this;
	  }
	  clone() {
	    return new OBBBounds(this);
	  }
	  getRotatedCorners() {
	    const originPoint = {
	      x: (this.x1 + this.x2) / 2,
	      y: (this.y1 + this.y2) / 2
	    };
	    return [rotatePoint({
	      x: this.x1,
	      y: this.y1
	    }, this.angle, originPoint), rotatePoint({
	      x: this.x2,
	      y: this.y1
	    }, this.angle, originPoint), rotatePoint({
	      x: this.x1,
	      y: this.y2
	    }, this.angle, originPoint), rotatePoint({
	      x: this.x2,
	      y: this.y2
	    }, this.angle, originPoint)];
	  }
	}

	class Matrix {
	  constructor(a = 1, b = 0, c = 0, d = 1, e = 0, f = 0) {
	    this.a = a, this.b = b, this.c = c, this.d = d, this.e = e, this.f = f;
	  }
	  equalToMatrix(m2) {
	    return !(this.e !== m2.e || this.f !== m2.f || this.a !== m2.a || this.d !== m2.d || this.b !== m2.b || this.c !== m2.c);
	  }
	  equalTo(a, b, c, d, e, f) {
	    return !(this.e !== e || this.f !== f || this.a !== a || this.d !== d || this.b !== b || this.c !== c);
	  }
	  setValue(a, b, c, d, e, f) {
	    return this.a = a, this.b = b, this.c = c, this.d = d, this.e = e, this.f = f, this;
	  }
	  reset() {
	    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
	  }
	  getInverse() {
	    const a = this.a,
	      b = this.b,
	      c = this.c,
	      d = this.d,
	      e = this.e,
	      f = this.f,
	      m = new Matrix(),
	      dt = a * d - b * c;
	    return m.a = d / dt, m.b = -b / dt, m.c = -c / dt, m.d = a / dt, m.e = (c * f - d * e) / dt, m.f = -(a * f - b * e) / dt, m;
	  }
	  rotate(rad) {
	    const c = Math.cos(rad),
	      s = Math.sin(rad),
	      m11 = this.a * c + this.c * s,
	      m12 = this.b * c + this.d * s,
	      m21 = this.a * -s + this.c * c,
	      m22 = this.b * -s + this.d * c;
	    return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this;
	  }
	  rotateByCenter(rad, cx, cy) {
	    const cos = Math.cos(rad),
	      sin = Math.sin(rad),
	      rotateM13 = (1 - cos) * cx + sin * cy,
	      rotateM23 = (1 - cos) * cy - sin * cx,
	      m11 = cos * this.a - sin * this.b,
	      m21 = sin * this.a + cos * this.b,
	      m12 = cos * this.c - sin * this.d,
	      m22 = sin * this.c + cos * this.d,
	      m13 = cos * this.e - sin * this.f + rotateM13,
	      m23 = sin * this.e + cos * this.f + rotateM23;
	    return this.a = m11, this.b = m21, this.c = m12, this.d = m22, this.e = m13, this.f = m23, this;
	  }
	  scale(sx, sy) {
	    return this.a *= sx, this.b *= sx, this.c *= sy, this.d *= sy, this;
	  }
	  setScale(sx, sy) {
	    return this.b = this.b / this.a * sx, this.c = this.c / this.d * sy, this.a = sx, this.d = sy, this;
	  }
	  transform(a, b, c, d, e, f) {
	    return this.multiply(a, b, c, d, e, f), this;
	  }
	  translate(x, y) {
	    return this.e += this.a * x + this.c * y, this.f += this.b * x + this.d * y, this;
	  }
	  transpose() {
	    const {
	      a: a,
	      b: b,
	      c: c,
	      d: d,
	      e: e,
	      f: f
	    } = this;
	    return this.a = b, this.b = a, this.c = d, this.d = c, this.e = f, this.f = e, this;
	  }
	  multiply(a2, b2, c2, d2, e2, f2) {
	    const a1 = this.a,
	      b1 = this.b,
	      c1 = this.c,
	      d1 = this.d,
	      m11 = a1 * a2 + c1 * b2,
	      m12 = b1 * a2 + d1 * b2,
	      m21 = a1 * c2 + c1 * d2,
	      m22 = b1 * c2 + d1 * d2,
	      dx = a1 * e2 + c1 * f2 + this.e,
	      dy = b1 * e2 + d1 * f2 + this.f;
	    return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this.e = dx, this.f = dy, this;
	  }
	  interpolate(m2, t) {
	    const m = new Matrix();
	    return m.a = this.a + (m2.a - this.a) * t, m.b = this.b + (m2.b - this.b) * t, m.c = this.c + (m2.c - this.c) * t, m.d = this.d + (m2.d - this.d) * t, m.e = this.e + (m2.e - this.e) * t, m.f = this.f + (m2.f - this.f) * t, m;
	  }
	  transformPoint(source, target) {
	    const {
	        a: a,
	        b: b,
	        c: c,
	        d: d,
	        e: e,
	        f: f
	      } = this,
	      dt = a * d - b * c,
	      nextA = d / dt,
	      nextB = -b / dt,
	      nextC = -c / dt,
	      nextD = a / dt,
	      nextE = (c * f - d * e) / dt,
	      nextF = -(a * f - b * e) / dt,
	      {
	        x: x,
	        y: y
	      } = source;
	    target.x = x * nextA + y * nextC + nextE, target.y = x * nextB + y * nextD + nextF;
	  }
	  onlyTranslate(scale = 1) {
	    return this.a === scale && 0 === this.b && 0 === this.c && this.d === scale;
	  }
	  clone() {
	    return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
	  }
	  toTransformAttrs() {
	    const a = this.a,
	      b = this.b,
	      c = this.c,
	      d = this.d,
	      delta = a * d - b * c,
	      result = {
	        x: this.e,
	        y: this.f,
	        rotateDeg: 0,
	        scaleX: 0,
	        scaleY: 0,
	        skewX: 0,
	        skewY: 0
	      };
	    if (0 !== a || 0 !== b) {
	      const r = Math.sqrt(a * a + b * b);
	      result.rotateDeg = b > 0 ? Math.acos(a / r) : -Math.acos(a / r), result.scaleX = r, result.scaleY = delta / r, result.skewX = (a * c + b * d) / delta, result.skewY = 0;
	    } else if (0 !== c || 0 !== d) {
	      const s = Math.sqrt(c * c + d * d);
	      result.rotateDeg = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s)), result.scaleX = delta / s, result.scaleY = s, result.skewX = 0, result.skewY = (a * c + b * d) / delta;
	    }
	    return result.rotateDeg = radianToDegree(result.rotateDeg), result;
	  }
	}
	function normalTransform(out, origin, x, y, scaleX, scaleY, angle, rotateCenter) {
	  const oa = origin.a,
	    ob = origin.b,
	    oc = origin.c,
	    od = origin.d,
	    oe = origin.e,
	    of = origin.f,
	    cosTheta = cos(angle),
	    sinTheta = sin(angle);
	  let rotateCenterX, rotateCenterY;
	  rotateCenter ? (rotateCenterX = rotateCenter[0], rotateCenterY = rotateCenter[1]) : (rotateCenterX = x, rotateCenterY = y);
	  const offsetX = rotateCenterX - x,
	    offsetY = rotateCenterY - y,
	    a1 = oa * cosTheta + oc * sinTheta,
	    b1 = ob * cosTheta + od * sinTheta,
	    c1 = oc * cosTheta - oa * sinTheta,
	    d1 = od * cosTheta - ob * sinTheta;
	  out.a = scaleX * a1, out.b = scaleX * b1, out.c = scaleY * c1, out.d = scaleY * d1, out.e = oe + oa * rotateCenterX + oc * rotateCenterY - a1 * offsetX - c1 * offsetY, out.f = of + ob * rotateCenterX + od * rotateCenterY - b1 * offsetX - d1 * offsetY;
	}

	function hslToRgb(h, s, l) {
	  s /= 100, l /= 100;
	  const c = (1 - Math.abs(2 * l - 1)) * s,
	    x = c * (1 - Math.abs(h / 60 % 2 - 1)),
	    m = l - c / 2;
	  let r = 0,
	    g = 0,
	    b = 0;
	  return 0 <= h && h < 60 ? (r = c, g = x, b = 0) : 60 <= h && h < 120 ? (r = x, g = c, b = 0) : 120 <= h && h < 180 ? (r = 0, g = c, b = x) : 180 <= h && h < 240 ? (r = 0, g = x, b = c) : 240 <= h && h < 300 ? (r = x, g = 0, b = c) : 300 <= h && h < 360 && (r = c, g = 0, b = x), r = Math.round(255 * (r + m)), g = Math.round(255 * (g + m)), b = Math.round(255 * (b + m)), {
	    r: r,
	    g: g,
	    b: b
	  };
	}

	function rgbToHsl(r, g, b) {
	  r /= 255, g /= 255, b /= 255;
	  const cMin = Math.min(r, g, b),
	    cMax = Math.max(r, g, b),
	    delta = cMax - cMin;
	  let h = 0,
	    s = 0,
	    l = 0;
	  return h = 0 === delta ? 0 : cMax === r ? (g - b) / delta % 6 : cMax === g ? (b - r) / delta + 2 : (r - g) / delta + 4, h = Math.round(60 * h), h < 0 && (h += 360), l = (cMax + cMin) / 2, s = 0 === delta ? 0 : delta / (1 - Math.abs(2 * l - 1)), s = +(100 * s).toFixed(1), l = +(100 * l).toFixed(1), {
	    h: h,
	    s: s,
	    l: l
	  };
	}

	const REG_HEX = /^#([0-9a-f]{3,8})$/,
	  DEFAULT_COLORS_OPACITY = {
	    transparent: 4294967040
	  };
	const DEFAULT_COLORS = {
	  aliceblue: 15792383,
	  antiquewhite: 16444375,
	  aqua: 65535,
	  aquamarine: 8388564,
	  azure: 15794175,
	  beige: 16119260,
	  bisque: 16770244,
	  black: 0,
	  blanchedalmond: 16772045,
	  blue: 255,
	  blueviolet: 9055202,
	  brown: 10824234,
	  burlywood: 14596231,
	  cadetblue: 6266528,
	  chartreuse: 8388352,
	  chocolate: 13789470,
	  coral: 16744272,
	  cornflowerblue: 6591981,
	  cornsilk: 16775388,
	  crimson: 14423100,
	  cyan: 65535,
	  darkblue: 139,
	  darkcyan: 35723,
	  darkgoldenrod: 12092939,
	  darkgray: 11119017,
	  darkgreen: 25600,
	  darkgrey: 11119017,
	  darkkhaki: 12433259,
	  darkmagenta: 9109643,
	  darkolivegreen: 5597999,
	  darkorange: 16747520,
	  darkorchid: 10040012,
	  darkred: 9109504,
	  darksalmon: 15308410,
	  darkseagreen: 9419919,
	  darkslateblue: 4734347,
	  darkslategray: 3100495,
	  darkslategrey: 3100495,
	  darkturquoise: 52945,
	  darkviolet: 9699539,
	  deeppink: 16716947,
	  deepskyblue: 49151,
	  dimgray: 6908265,
	  dimgrey: 6908265,
	  dodgerblue: 2003199,
	  firebrick: 11674146,
	  floralwhite: 16775920,
	  forestgreen: 2263842,
	  fuchsia: 16711935,
	  gainsboro: 14474460,
	  ghostwhite: 16316671,
	  gold: 16766720,
	  goldenrod: 14329120,
	  gray: 8421504,
	  green: 32768,
	  greenyellow: 11403055,
	  grey: 8421504,
	  honeydew: 15794160,
	  hotpink: 16738740,
	  indianred: 13458524,
	  indigo: 4915330,
	  ivory: 16777200,
	  khaki: 15787660,
	  lavender: 15132410,
	  lavenderblush: 16773365,
	  lawngreen: 8190976,
	  lemonchiffon: 16775885,
	  lightblue: 11393254,
	  lightcoral: 15761536,
	  lightcyan: 14745599,
	  lightgoldenrodyellow: 16448210,
	  lightgray: 13882323,
	  lightgreen: 9498256,
	  lightgrey: 13882323,
	  lightpink: 16758465,
	  lightsalmon: 16752762,
	  lightseagreen: 2142890,
	  lightskyblue: 8900346,
	  lightslategray: 7833753,
	  lightslategrey: 7833753,
	  lightsteelblue: 11584734,
	  lightyellow: 16777184,
	  lime: 65280,
	  limegreen: 3329330,
	  linen: 16445670,
	  magenta: 16711935,
	  maroon: 8388608,
	  mediumaquamarine: 6737322,
	  mediumblue: 205,
	  mediumorchid: 12211667,
	  mediumpurple: 9662683,
	  mediumseagreen: 3978097,
	  mediumslateblue: 8087790,
	  mediumspringgreen: 64154,
	  mediumturquoise: 4772300,
	  mediumvioletred: 13047173,
	  midnightblue: 1644912,
	  mintcream: 16121850,
	  mistyrose: 16770273,
	  moccasin: 16770229,
	  navajowhite: 16768685,
	  navy: 128,
	  oldlace: 16643558,
	  olive: 8421376,
	  olivedrab: 7048739,
	  orange: 16753920,
	  orangered: 16729344,
	  orchid: 14315734,
	  palegoldenrod: 15657130,
	  palegreen: 10025880,
	  paleturquoise: 11529966,
	  palevioletred: 14381203,
	  papayawhip: 16773077,
	  peachpuff: 16767673,
	  peru: 13468991,
	  pink: 16761035,
	  plum: 14524637,
	  powderblue: 11591910,
	  purple: 8388736,
	  rebeccapurple: 6697881,
	  red: 16711680,
	  rosybrown: 12357519,
	  royalblue: 4286945,
	  saddlebrown: 9127187,
	  salmon: 16416882,
	  sandybrown: 16032864,
	  seagreen: 3050327,
	  seashell: 16774638,
	  sienna: 10506797,
	  silver: 12632256,
	  skyblue: 8900331,
	  slateblue: 6970061,
	  slategray: 7372944,
	  slategrey: 7372944,
	  snow: 16775930,
	  springgreen: 65407,
	  steelblue: 4620980,
	  tan: 13808780,
	  teal: 32896,
	  thistle: 14204888,
	  tomato: 16737095,
	  turquoise: 4251856,
	  violet: 15631086,
	  wheat: 16113331,
	  white: 16777215,
	  whitesmoke: 16119285,
	  yellow: 16776960,
	  yellowgreen: 10145074
	};
	function hex(value) {
	  return ((value = Math.max(0, Math.min(255, Math.round(value) || 0))) < 16 ? "0" : "") + value.toString(16);
	}
	function rgb(value) {
	  return isNumber$1(value) ? new RGB(value >> 16, value >> 8 & 255, 255 & value, 1) : isArray$1(value) ? new RGB(value[0], value[1], value[2]) : new RGB(255, 255, 255);
	}
	function rgba(value) {
	  return isNumber$1(value) ? new RGB(value >>> 24, value >>> 16 & 255, value >>> 8 & 255, 255 & value) : isArray$1(value) ? new RGB(value[0], value[1], value[2], value[3]) : new RGB(255, 255, 255, 1);
	}
	function SRGBToLinear(c) {
	  return c < .04045 ? .0773993808 * c : Math.pow(.9478672986 * c + .0521327014, 2.4);
	}
	function LinearToSRGB(c) {
	  return c < .0031308 ? 12.92 * c : 1.055 * Math.pow(c, .41666) - .055;
	}
	const setHex = (formatValue, forceHex) => {
	  const isHex = REG_HEX.exec(formatValue);
	  if (forceHex || isHex) {
	    const hex = parseInt(isHex[1], 16),
	      hexLength = isHex[1].length;
	    return 3 === hexLength ? new RGB((hex >> 8 & 15) + ((hex >> 8 & 15) << 4), (hex >> 4 & 15) + ((hex >> 4 & 15) << 4), (15 & hex) + ((15 & hex) << 4), 1) : 6 === hexLength ? rgb(hex) : 8 === hexLength ? new RGB(hex >> 24 & 255, hex >> 16 & 255, hex >> 8 & 255, (255 & hex) / 255) : null;
	  }
	};
	class Color {
	  static Brighter(source, b = 1) {
	    return 1 === b ? source : new Color(source).brighter(b).toRGBA();
	  }
	  static SetOpacity(source, o = 1) {
	    return 1 === o ? source : new Color(source).setOpacity(o).toRGBA();
	  }
	  static getColorBrightness(source, model = "hsl") {
	    const color = source instanceof Color ? source : new Color(source);
	    switch (model) {
	      case "hsv":
	      default:
	        return color.getHSVBrightness();
	      case "hsl":
	        return color.getHSLBrightness();
	      case "lum":
	        return color.getLuminance();
	      case "lum2":
	        return color.getLuminance2();
	      case "lum3":
	        return color.getLuminance3();
	      case "wcag":
	        return color.getLuminanceWCAG();
	    }
	  }
	  static parseColorString(value) {
	    if (isValid$1(DEFAULT_COLORS_OPACITY[value])) return rgba(DEFAULT_COLORS_OPACITY[value]);
	    if (isValid$1(DEFAULT_COLORS[value])) return rgb(DEFAULT_COLORS[value]);
	    const formatValue = `${value}`.trim().toLowerCase(),
	      hexRes = setHex(formatValue);
	    if (void 0 !== hexRes) return hexRes;
	    if (/^(rgb|RGB|rgba|RGBA)/.test(formatValue)) {
	      const aColor = formatValue.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
	      return new RGB(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10), parseFloat(aColor[3]));
	    }
	    if (/^(hsl|HSL|hsla|HSLA)/.test(formatValue)) {
	      const aColor = formatValue.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","),
	        rgb = hslToRgb(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10));
	      return new RGB(rgb.r, rgb.g, rgb.b, parseFloat(aColor[3]));
	    }
	  }
	  constructor(value) {
	    const color = Color.parseColorString(value);
	    color ? this.color = color : (console.warn(`Warn: 传入${value}无法解析为Color`), this.color = new RGB(255, 255, 255));
	  }
	  toRGBA() {
	    return this.color.formatRgb();
	  }
	  toString() {
	    return this.color.formatRgb();
	  }
	  toHex() {
	    return this.color.formatHex();
	  }
	  toHsl() {
	    return this.color.formatHsl();
	  }
	  brighter(k) {
	    const {
	      r: r,
	      g: g,
	      b: b
	    } = this.color;
	    return this.color.r = Math.max(0, Math.min(255, Math.floor(r * k))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * k))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * k))), this;
	  }
	  add(color) {
	    const {
	      r: r,
	      g: g,
	      b: b
	    } = this.color;
	    return this.color.r += Math.min(255, r + color.color.r), this.color.g += Math.min(255, g + color.color.g), this.color.b += Math.min(255, b + color.color.b), this;
	  }
	  sub(color) {
	    return this.color.r = Math.max(0, this.color.r - color.color.r), this.color.g = Math.max(0, this.color.g - color.color.g), this.color.b = Math.max(0, this.color.b - color.color.b), this;
	  }
	  multiply(color) {
	    const {
	      r: r,
	      g: g,
	      b: b
	    } = this.color;
	    return this.color.r = Math.max(0, Math.min(255, Math.floor(r * color.color.r))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * color.color.g))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * color.color.b))), this;
	  }
	  getHSVBrightness() {
	    return Math.max(this.color.r, this.color.g, this.color.b) / 255;
	  }
	  getHSLBrightness() {
	    return .5 * (Math.max(this.color.r, this.color.g, this.color.b) / 255 + Math.min(this.color.r, this.color.g, this.color.b) / 255);
	  }
	  setHsl(h, s, l) {
	    const opacity = this.color.opacity,
	      hsl = rgbToHsl(this.color.r, this.color.g, this.color.b),
	      rgb = hslToRgb(isNil$1(h) ? hsl.h : clamp$1(h, 0, 360), isNil$1(s) ? hsl.s : s >= 0 && s <= 1 ? 100 * s : s, isNil$1(l) ? hsl.l : l <= 1 && l >= 0 ? 100 * l : l);
	    return this.color = new RGB(rgb.r, rgb.g, rgb.b, opacity), this;
	  }
	  setRGB(r, g, b) {
	    return !isNil$1(r) && (this.color.r = r), !isNil$1(g) && (this.color.g = g), !isNil$1(b) && (this.color.b = b), this;
	  }
	  setHex(value) {
	    const formatValue = `${value}`.trim().toLowerCase(),
	      res = setHex(formatValue, !0);
	    return null != res ? res : this;
	  }
	  setColorName(name) {
	    const hex = DEFAULT_COLORS[name.toLowerCase()];
	    return void 0 !== hex ? this.setHex(hex) : console.warn("THREE.Color: Unknown color " + name), this;
	  }
	  setScalar(scalar) {
	    return this.color.r = scalar, this.color.g = scalar, this.color.b = scalar, this;
	  }
	  setOpacity(o = 1) {
	    return this.color.opacity = o, this;
	  }
	  getLuminance() {
	    return (.2126 * this.color.r + .7152 * this.color.g + .0722 * this.color.b) / 255;
	  }
	  getLuminance2() {
	    return (.2627 * this.color.r + .678 * this.color.g + .0593 * this.color.b) / 255;
	  }
	  getLuminance3() {
	    return (.299 * this.color.r + .587 * this.color.g + .114 * this.color.b) / 255;
	  }
	  getLuminanceWCAG() {
	    const RsRGB = this.color.r / 255,
	      GsRGB = this.color.g / 255,
	      BsRGB = this.color.b / 255;
	    let R, G, B;
	    R = RsRGB <= .03928 ? RsRGB / 12.92 : Math.pow((RsRGB + .055) / 1.055, 2.4), G = GsRGB <= .03928 ? GsRGB / 12.92 : Math.pow((GsRGB + .055) / 1.055, 2.4), B = BsRGB <= .03928 ? BsRGB / 12.92 : Math.pow((BsRGB + .055) / 1.055, 2.4);
	    return .2126 * R + .7152 * G + .0722 * B;
	  }
	  clone() {
	    return new Color(this.color.toString());
	  }
	  copyGammaToLinear(color, gammaFactor = 2) {
	    return this.color.r = Math.pow(color.color.r, gammaFactor), this.color.g = Math.pow(color.color.g, gammaFactor), this.color.b = Math.pow(color.color.b, gammaFactor), this;
	  }
	  copyLinearToGamma(color, gammaFactor = 2) {
	    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
	    return this.color.r = Math.pow(color.color.r, safeInverse), this.color.g = Math.pow(color.color.g, safeInverse), this.color.b = Math.pow(color.color.b, safeInverse), this;
	  }
	  convertGammaToLinear(gammaFactor) {
	    return this.copyGammaToLinear(this, gammaFactor), this;
	  }
	  convertLinearToGamma(gammaFactor) {
	    return this.copyLinearToGamma(this, gammaFactor), this;
	  }
	  copySRGBToLinear(color) {
	    return this.color.r = SRGBToLinear(color.color.r), this.color.g = SRGBToLinear(color.color.g), this.color.b = SRGBToLinear(color.color.b), this;
	  }
	  copyLinearToSRGB(color) {
	    return this.color.r = LinearToSRGB(color.color.r), this.color.g = LinearToSRGB(color.color.g), this.color.b = LinearToSRGB(color.color.b), this;
	  }
	  convertSRGBToLinear() {
	    return this.copySRGBToLinear(this), this;
	  }
	  convertLinearToSRGB() {
	    return this.copyLinearToSRGB(this), this;
	  }
	}
	class RGB {
	  constructor(r, g, b, opacity) {
	    this.r = isNaN(+r) ? 255 : Math.max(0, Math.min(255, +r)), this.g = isNaN(+g) ? 255 : Math.max(0, Math.min(255, +g)), this.b = isNaN(+b) ? 255 : Math.max(0, Math.min(255, +b)), isValid$1(opacity) ? this.opacity = isNaN(+opacity) ? 1 : Math.max(0, Math.min(1, +opacity)) : this.opacity = 1;
	  }
	  formatHex() {
	    return `#${hex(this.r) + hex(this.g) + hex(this.b) + (1 === this.opacity ? "" : hex(255 * this.opacity))}`;
	  }
	  formatRgb() {
	    const opacity = this.opacity;
	    return `${1 === opacity ? "rgb(" : "rgba("}${this.r},${this.g},${this.b}${1 === opacity ? ")" : `,${opacity})`}`;
	  }
	  formatHsl() {
	    const opacity = this.opacity,
	      {
	        h: h,
	        s: s,
	        l: l
	      } = rgbToHsl(this.r, this.g, this.b);
	    return `${1 === opacity ? "hsl(" : "hsla("}${h},${s}%,${l}%${1 === opacity ? ")" : `,${opacity})`}`;
	  }
	  toString() {
	    return this.formatHex();
	  }
	}

	function hexToRgb(str) {
	  let r = "",
	    g = "",
	    b = "";
	  const strtIndex = "#" === str[0] ? 1 : 0;
	  for (let i = strtIndex; i < str.length; i++) "#" !== str[i] && (i < strtIndex + 2 ? r += str[i] : i < strtIndex + 4 ? g += str[i] : i < strtIndex + 6 && (b += str[i]));
	  return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
	}

	function rgbToHex(r, g, b) {
	  return Number((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
	}

	function interpolateRgb$1(colorA, colorB) {
	  const redA = colorA.r,
	    redB = colorB.r,
	    greenA = colorA.g,
	    greenB = colorB.g,
	    blueA = colorA.b,
	    blueB = colorB.b,
	    opacityA = colorA.opacity,
	    opacityB = colorB.opacity;
	  return t => {
	    const r = Math.round(redA * (1 - t) + redB * t),
	      g = Math.round(greenA * (1 - t) + greenB * t),
	      b = Math.round(blueA * (1 - t) + blueB * t);
	    return new RGB(r, g, b, opacityA * (1 - t) + opacityB * t);
	  };
	}

	var ColorUtil = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Color: Color,
		DEFAULT_COLORS: DEFAULT_COLORS,
		RGB: RGB,
		hexToRgb: hexToRgb,
		hslToRgb: hslToRgb,
		interpolateRgb: interpolateRgb$1,
		rgbToHex: rgbToHex,
		rgbToHsl: rgbToHsl
	});

	function normalizePadding(padding) {
	  if (isValidNumber$1(padding)) return [padding, padding, padding, padding];
	  if (isArray$1(padding)) {
	    const length = padding.length;
	    if (1 === length) {
	      const paddingValue = padding[0];
	      return [paddingValue, paddingValue, paddingValue, paddingValue];
	    }
	    if (2 === length) {
	      const [vertical, horizontal] = padding;
	      return [vertical, horizontal, vertical, horizontal];
	    }
	    if (3 === length) {
	      const [top, horizontal, bottom] = padding;
	      return [top, horizontal, bottom, horizontal];
	    }
	    if (4 === length) return padding;
	  }
	  if (isObject$1(padding)) {
	    const {
	      top = 0,
	      right = 0,
	      bottom = 0,
	      left = 0
	    } = padding;
	    return [top, right, bottom, left];
	  }
	  return [0, 0, 0, 0];
	}

	function toCamelCase(str) {
	  return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
	}

	/**
	 * @module helpers
	 */
	/**
	 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
	 *
	 * @memberof helpers
	 * @type {number}
	 */
	var earthRadius = 6371008.8;
	/**
	 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
	 *
	 * @memberof helpers
	 * @type {Object}
	 */
	var factors = {
	  centimeters: earthRadius * 100,
	  centimetres: earthRadius * 100,
	  degrees: earthRadius / 111325,
	  feet: earthRadius * 3.28084,
	  inches: earthRadius * 39.37,
	  kilometers: earthRadius / 1000,
	  kilometres: earthRadius / 1000,
	  meters: earthRadius,
	  metres: earthRadius,
	  miles: earthRadius / 1609.344,
	  millimeters: earthRadius * 1000,
	  millimetres: earthRadius * 1000,
	  nauticalmiles: earthRadius / 1852,
	  radians: 1,
	  yards: earthRadius * 1.0936
	};
	/**
	 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
	 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
	 *
	 * @name lengthToRadians
	 * @param {number} distance in real units
	 * @param {string} [units="kilometers"] can be degrees, radians, miles, inches, yards, metres,
	 * meters, kilometres, kilometers.
	 * @returns {number} radians
	 */
	function lengthToRadians(distance, units) {
	  if (units === void 0) {
	    units = "kilometers";
	  }
	  var factor = factors[units];
	  if (!factor) {
	    throw new Error(units + " units is invalid");
	  }
	  return distance / factor;
	}

	function getGeom(geojson) {
	  return "Feature" === geojson.type ? geojson.geometry : geojson;
	}
	function isPointInPolygon$1(point, polygon) {
	  if (!point) return !1;
	  if (!polygon) return !1;
	  const geom = getGeom(polygon),
	    type = geom.type,
	    bbox = polygon.bbox;
	  let polys = geom.coordinates;
	  if (bbox && !0 === pointInRect(point, {
	    x1: bbox[0],
	    x2: bbox[1],
	    y1: bbox[1],
	    y2: bbox[3]
	  }, !0)) return !1;
	  "Polygon" === type && (polys = [polys]);
	  let result = !1;
	  for (let i = 0; i < polys.length; ++i) for (let j = 0; j < polys[i].length; ++j) {
	    if (polygonContainPoint(polys[i][j].map(p => ({
	      x: p[0],
	      y: p[1]
	    })), point.x, point.y)) return result = !0, result;
	  }
	  return result;
	}
	function destination(point, distance, bearing, options = {}) {
	  const longitude1 = degreeToRadian(point[0]),
	    latitude1 = degreeToRadian(point[1]),
	    bearingRad = degreeToRadian(bearing),
	    radians = lengthToRadians(distance, options.units),
	    latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad)),
	    longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
	  return {
	    x: radianToDegree(longitude2),
	    y: radianToDegree(latitude2)
	  };
	}

	class RankingBarChartSpecTransformer extends vchart.BaseChartSpecTransformer {
	    transformSpec(spec) {
	        const { timeData, timeNodes } = processData(spec);
	        const { interval: userInterval, xField, yField, color, icon, iconPosition, iconShape, timeLabel, label, nameLabel, xAxis, yAxis } = spec;
	        const interval = userInterval ? userInterval : 1000;
	        const exchangeDuration = Math.min(interval, 500);
	        spec.type = 'common';
	        spec.data = [
	            {
	                id: 'timeData',
	                values: timeData.get(timeNodes[0])
	            },
	            {
	                id: 'time',
	                values: [{ time: timeNodes[0] }]
	            }
	        ];
	        spec.color = {
	            specified: Object.assign({}, color)
	        };
	        spec.region = [{ clip: true }];
	        spec.series = [
	            {
	                type: 'bar',
	                id: 'ranking-bar',
	                dataId: 'timeData',
	                direction: 'horizontal',
	                yField,
	                xField,
	                seriesField: yField,
	                extensionMark: [],
	                label: labelSpec(label, Object.assign(Object.assign({}, nameLabel), { yField }))
	            }
	        ];
	        spec.axes = axisSpec(xAxis, yAxis);
	        spec.player = {
	            type: 'continuous',
	            auto: true,
	            loop: false,
	            interval,
	            specs: timeNodes.map(time => ({
	                data: [
	                    { id: 'timeData', values: timeData.get(time) },
	                    { id: 'time', values: [{ time }] }
	                ]
	            }))
	        };
	        spec.tooltip = { visible: false };
	        spec.customMark = [];
	        transformAnimationSpec(spec, { interval, exchangeDuration });
	        if (!timeLabel || timeLabel.visible !== false) {
	            spec.customMark.push(timeLabelSpec(timeLabel.style));
	        }
	        if (icon) {
	            const icon = iconSpec(iconPosition, iconShape, { interval, exchangeDuration });
	            spec.series[0].extensionMark.push(icon);
	        }
	        super.transformSpec(spec);
	    }
	}
	function processData(spec) {
	    const { xField, yField, timeField, data, topN = 10, icon } = spec;
	    const timeNodes = new Set();
	    const timeData = new Map();
	    data.sort((d1, d2) => Number(d2[xField]) - Number(d1[xField]));
	    data.forEach(d => {
	        const time = d[timeField];
	        if (isValid$1(time)) {
	            timeNodes.add(time);
	        }
	        if (!timeData.has(time)) {
	            timeData.set(time, []);
	        }
	        const currentData = timeData.get(time);
	        if (currentData.length < topN) {
	            const _d = Object.assign({}, d);
	            if (icon && icon[_d[yField]]) {
	                _d.icon = icon[_d[yField]];
	            }
	            currentData.push(_d);
	        }
	    });
	    return { timeData, timeNodes: Array.from(timeNodes).sort() };
	}
	function transformAnimationSpec(spec, { interval, exchangeDuration }) {
	    spec.animationAppear = false;
	    spec.animationUpdate = {
	        bar: [
	            {
	                type: 'update',
	                options: { excludeChannels: ['y'] },
	                easing: 'linear',
	                duration: interval
	            },
	            {
	                channel: ['y'],
	                easing: 'circInOut',
	                duration: exchangeDuration
	            }
	        ],
	        axis: {
	            duration: interval,
	            easing: 'linear'
	        }
	    };
	    spec.animationEnter = {
	        bar: [
	            {
	                type: 'moveIn',
	                duration: exchangeDuration,
	                easing: 'cubicInOut',
	                options: {
	                    direction: 'y',
	                    orient: 'negative',
	                    point: (datum, element, param) => {
	                        return {
	                            y: param.groupHeight + element.getBounds().height()
	                        };
	                    }
	                }
	            }
	        ]
	    };
	    spec.animationExit = {
	        bar: [
	            {
	                type: 'moveOut',
	                duration: exchangeDuration,
	                easing: 'cubicInOut',
	                options: {
	                    direction: 'y',
	                    orient: 'negative'
	                }
	            }
	        ]
	    };
	}
	function labelSpec(label = {}, nameLabel) {
	    var _a, _b, _c, _e;
	    const spec = [];
	    if (label.visible !== false) {
	        spec.push({
	            visible: true,
	            overlap: false,
	            style: Object.assign({ fill: `rgb(64, 64, 64)` }, label.style),
	            smartInvert: {
	                fillStrategy: ((_a = label.style) === null || _a === void 0 ? void 0 : _a.fill) ? 'null' : undefined,
	                strokeStrategy: ((_b = label.style) === null || _b === void 0 ? void 0 : _b.stroke) ? 'null' : undefined
	            }
	        });
	    }
	    if (nameLabel.visible) {
	        spec.push({
	            visible: true,
	            overlap: false,
	            style: Object.assign({}, nameLabel.style),
	            smartInvert: {
	                fillStrategy: ((_c = nameLabel.style) === null || _c === void 0 ? void 0 : _c.fill) ? 'null' : undefined,
	                strokeStrategy: ((_e = nameLabel.style) === null || _e === void 0 ? void 0 : _e.stroke) ? 'null' : undefined
	            },
	            position: nameLabel.position === 'bar-end' ? 'inside-right' : 'inside-left',
	            formatter: `{${nameLabel.yField}}`
	        });
	    }
	    return spec;
	}
	function axisSpec(xAxis = {}, yAxis = {}) {
	    const leftAxis = {
	        orient: 'left',
	        type: 'band',
	        inverse: true,
	        label: { style: yAxis.label },
	        domainLine: { style: yAxis.domainLine },
	        grid: { style: yAxis.grid }
	    };
	    const bottomAxis = {
	        orient: 'bottom',
	        type: 'linear',
	        nice: false,
	        animation: true,
	        label: { style: xAxis.label },
	        domainLine: { style: xAxis.domainLine },
	        grid: { style: xAxis.grid },
	        innerOffset: { right: '10%' }
	    };
	    if (xAxis.label) {
	        bottomAxis.label = xAxis.label;
	    }
	    return [leftAxis, bottomAxis];
	}
	function timeLabelSpec(textStyle = {}) {
	    return {
	        type: 'text',
	        dataId: 'time',
	        style: Object.assign({ textBaseline: 'bottom', fontSize: 200, textAlign: 'end', fontWeight: 600, text: (datum) => datum.time, x: (datum, ctx) => {
	                var _a;
	                return ((_a = ctx.vchart.getChart().getCanvasRect()) === null || _a === void 0 ? void 0 : _a.width) - 50;
	            }, y: (datum, ctx) => {
	                var _a;
	                return ((_a = ctx.vchart.getChart().getCanvasRect()) === null || _a === void 0 ? void 0 : _a.height) - 80;
	            }, fill: 'grey', fillOpacity: 0.5 }, textStyle)
	    };
	}
	function iconSpec(iconPosition = 'bar-end', iconShape = 'circle', { interval, exchangeDuration }) {
	    return {
	        type: 'symbol',
	        dataId: 'timeData',
	        style: {
	            symbolType: iconShape,
	            stroke: 'white',
	            lineWidth: 1,
	            size: (data, ctx) => {
	                var _a, _b;
	                const vchart = ctx.vchart;
	                const series = (_a = vchart.getChart()) === null || _a === void 0 ? void 0 : _a.getSeriesInIndex(0)[0];
	                if (vchart && series) {
	                    const bandwidth = (_b = series.getYAxisHelper().getBandwidth(0)) !== null && _b !== void 0 ? _b : 0;
	                    return Math.max(bandwidth - 4, 0);
	                }
	                return 10;
	            },
	            background: (data) => data.icon,
	            x: (data, ctx) => {
	                var _a, _b;
	                const vchart = ctx.vchart;
	                const series = (_a = vchart.getChart()) === null || _a === void 0 ? void 0 : _a.getSeriesInIndex(0)[0];
	                if (vchart && series) {
	                    const bandwidth = (_b = series.getYAxisHelper().getBandwidth(0)) !== null && _b !== void 0 ? _b : 0;
	                    if (iconPosition === 'bar-start') {
	                        return bandwidth / 2;
	                    }
	                    else if (iconPosition === 'axis') {
	                        return -bandwidth / 2;
	                    }
	                    return series.dataToPositionX(data) - bandwidth / 2;
	                }
	                return undefined;
	            },
	            y: (data, ctx) => {
	                var _a, _b;
	                const vchart = ctx.vchart;
	                const series = (_a = vchart.getChart()) === null || _a === void 0 ? void 0 : _a.getSeriesInIndex(0)[0];
	                if (vchart && series) {
	                    const bandwidth = (_b = series.getYAxisHelper().getBandwidth(0)) !== null && _b !== void 0 ? _b : 0;
	                    return series.dataToPositionY(data) + bandwidth / 2;
	                }
	                return undefined;
	            },
	            scaleY: iconShape === 'rect' ? 1.2 : 1
	        },
	        animationUpdate: customMarkUpdateAnimation(interval, exchangeDuration),
	        animationEnter: [
	            {
	                type: 'moveIn',
	                duration: exchangeDuration,
	                easing: 'cubicInOut',
	                options: {
	                    direction: 'y',
	                    orient: 'negative',
	                    point: (datum, element, param) => {
	                        return {
	                            y: param.groupHeight + element.getBounds().height()
	                        };
	                    }
	                }
	            }
	        ],
	        animationExit: [
	            {
	                type: 'moveOut',
	                duration: exchangeDuration,
	                easing: 'cubicInOut',
	                options: {
	                    direction: 'y',
	                    orient: 'negative'
	                }
	            }
	        ]
	    };
	}
	function customMarkUpdateAnimation(duration, exchangeDuration) {
	    return [
	        {
	            duration: exchangeDuration,
	            easing: 'cubicInOut',
	            channel: ['y']
	        },
	        {
	            options: { excludeChannels: ['y'] },
	            channel: ['x', 'x2', 'x1'],
	            easing: 'linear',
	            duration
	        }
	    ];
	}

	class RankingBar extends vchart.BaseChart {
	    constructor() {
	        super(...arguments);
	        this.type = 'rankingBar';
	        this.transformerConstructor = RankingBarChartSpecTransformer;
	    }
	    init() {
	        if (!this.isValid()) {
	            return;
	        }
	        super.init();
	    }
	    isValid() {
	        var _a, _b, _c, _d;
	        const { xField, yField, timeField, data } = this._spec;
	        if (!xField || !yField || !timeField) {
	            (_b = (_a = this._option).onError) === null || _b === void 0 ? void 0 : _b.call(_a, 'Missing Required Config: `xField`, `yField`, `timeField` ');
	            return false;
	        }
	        if (!data) {
	            (_d = (_c = this._option).onError) === null || _d === void 0 ? void 0 : _d.call(_c, 'Data is required');
	            return false;
	        }
	        return true;
	    }
	}
	RankingBar.type = 'rankingBar';
	RankingBar.view = 'singleDefault';
	RankingBar.transformerConstructor = RankingBarChartSpecTransformer;
	const registerRankingBarChart = (option) => {
	    const vchartConstructor = (option === null || option === void 0 ? void 0 : option.VChart) || vchart.VChart;
	    if (vchartConstructor) {
	        vchartConstructor.useChart([RankingBar]);
	    }
	};

	const cornerRadius = 5;
	const animationDuration = 1000;
	const fontSize = 20;
	const pageSize = 5;
	const scrollSize = 1;
	const primaryFontColor = '#21252c';
	const shadowColor = 'rgba(33,37,44,0.1)';
	const defaultSpec = {
	    labelLayout: 'top',
	    bar: {
	        style: {
	            cornerRadius
	        }
	    },
	    barBackground: {
	        type: 'rect',
	        style: {
	            fill: shadowColor,
	            cornerRadius
	        }
	    },
	    rankingIcon: {
	        visible: true,
	        style: {
	            fill: primaryFontColor,
	            size: fontSize
	        }
	    },
	    nameLabel: {
	        visible: true,
	        style: {
	            fontSize: fontSize,
	            fontWeight: 'normal',
	            fill: primaryFontColor,
	            textBaseline: 'middle'
	        }
	    },
	    orderLabel: {
	        visible: true,
	        style: {
	            fontSize: fontSize,
	            fontWeight: 'normal',
	            fill: primaryFontColor,
	            textBaseline: 'middle'
	        }
	    },
	    valueLabel: {
	        visible: true,
	        style: {
	            fontSize: fontSize,
	            fontWeight: 'normal',
	            fill: primaryFontColor,
	            textBaseline: 'middle'
	        }
	    },
	    pageSize,
	    scrollSize,
	    animationAppear: {
	        enable: true,
	        type: 'grow',
	        duration: animationDuration,
	        easing: 'linear'
	    },
	    animationUpdate: {
	        enable: true,
	        type: 'grow',
	        duration: animationDuration,
	        easing: 'linear'
	    },
	    animationNormal: {
	        interval: animationDuration
	    }
	};

	const applyVisible = (spec, keyList) => {
	    keyList.forEach(key => {
	        var _a, _b, _c, _d, _e, _f, _g;
	        if (isArray$1(spec[key])) {
	            (_a = spec[key]) === null || _a === void 0 ? void 0 : _a.forEach((s, i) => {
	                var _a, _b, _c;
	                spec[key][i] = Object.assign(Object.assign({}, s), { style: Object.assign(Object.assign({}, s === null || s === void 0 ? void 0 : s.style), { visible: (_c = (_b = (_a = s === null || s === void 0 ? void 0 : s.style) === null || _a === void 0 ? void 0 : _a.visible) !== null && _b !== void 0 ? _b : s === null || s === void 0 ? void 0 : s.visible) !== null && _c !== void 0 ? _c : true }) });
	            });
	        }
	        else {
	            spec[key] = Object.assign(Object.assign({}, spec[key]), { style: Object.assign(Object.assign({}, (_b = spec[key]) === null || _b === void 0 ? void 0 : _b.style), { visible: (_g = (_e = (_d = (_c = spec[key]) === null || _c === void 0 ? void 0 : _c.style) === null || _d === void 0 ? void 0 : _d.visible) !== null && _e !== void 0 ? _e : (_f = spec[key]) === null || _f === void 0 ? void 0 : _f.visible) !== null && _g !== void 0 ? _g : true }) });
	        }
	    });
	};
	const mergeObjects = (objA, objB) => {
	    function recursiveMerge(target, source) {
	        for (const key in source) {
	            if (key !== '__proto__' &&
	                key !== 'constructor' &&
	                key !== 'prototype' &&
	                typeof source[key] === 'object' &&
	                source[key] !== null) {
	                if (!target.hasOwnProperty(key)) {
	                    target[key] = Array.isArray(source[key]) ? [] : {};
	                }
	                recursiveMerge(target[key], source[key]);
	            }
	            else if (!target.hasOwnProperty(key) && typeof target === 'object') {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	    return recursiveMerge(objA, objB);
	};
	const computeDataRange = (data, field) => {
	    let dataMin;
	    let dataMax;
	    const datumX = data.map(d => d[field]).filter(d => typeof d !== 'undefined' && d !== null);
	    if (datumX.length === 0) {
	        dataMin = 0;
	        dataMax = 1;
	    }
	    else {
	        dataMin = Math.min(...datumX) - (Math.max(...datumX) - Math.min(...datumX)) / 3;
	        dataMax = (Math.max(...datumX) - dataMin) / 0.8 + dataMin;
	        const delta_value = 10;
	        const data = dataMin;
	        if (dataMin === dataMax) {
	            dataMin = data - delta_value;
	            dataMax = (4 * data + delta_value) / 4;
	        }
	    }
	    return { min: dataMin, max: dataMax };
	};

	const DATA_KEY$3 = 'dataKey';
	const ORDER_KEY = 'VCHART_ORDER';
	const SUPPLY_DATA_KEY = 'SUPPLY_DATA_KEY';
	const NAME_LABEL_PADDING_RIGHT = 10;
	const NAME_ORDER_PADDING_RIGHT = 5;
	const NAME_SYMBOL_PADDING_RIGHT = 8;
	const CHART_PADDING_LEFT = 5;
	const CHART_PADDING_RIGHT = 5;
	const VALUE_LABEL_PADDING_LEFT = 5;
	const LABEL_PADDING_BOTTOM = 5;
	class RankingListChartSpecTransformer extends vchart.CommonChartSpecTransformer {
	    constructor() {
	        super(...arguments);
	        this.formatMap = {};
	        this.paginateDataArr = (spec) => {
	            const { scrollSize = 1, pageSize = 5 } = spec;
	            const arr = this.originalData;
	            const result = {};
	            let pageOrder = 0;
	            for (let i = 0; i < arr.length; i += scrollSize) {
	                pageOrder++;
	                result[`page${pageOrder}`] = arr.slice(i, i + pageSize);
	                if (i + pageSize - 1 >= arr.length - 1) {
	                    arr.push(...Array.from({ length: i + pageSize - arr.length }, _ => {
	                        return {
	                            [spec.yField]: Math.random() * 100,
	                            [spec.xField]: null,
	                            [SUPPLY_DATA_KEY]: true
	                        };
	                    }));
	                    break;
	                }
	            }
	            return {
	                orderCount: pageOrder,
	                result: result
	            };
	        };
	        this.processRankingData = (spec) => {
	            const result = [];
	            spec.data.forEach((datum, index) => (datum[ORDER_KEY] = index + 1 < 10 ? `0${index + 1}` : index + 1));
	            const pagerData = this.paginateDataArr(spec).result;
	            const orderCount = this.paginateDataArr(spec).orderCount;
	            this.orderCount = orderCount;
	            const supplyCount = spec.pageSize - pagerData[`page${orderCount}`].length;
	            pagerData[`page${orderCount}`].push(...Array.from({ length: supplyCount }, (_) => {
	                return {
	                    [spec.yField]: Math.random() * 100,
	                    [spec.xField]: null,
	                    [SUPPLY_DATA_KEY]: true
	                };
	            }));
	            Object.keys(pagerData).forEach(order => {
	                result.push({
	                    data: [
	                        {
	                            id: 'datas',
	                            values: pagerData[order].map(d => {
	                                return Object.assign(Object.assign({}, d), { [DATA_KEY$3]: d[spec.yField] });
	                            })
	                        },
	                        {
	                            id: 'order',
	                            values: [
	                                {
	                                    order
	                                }
	                            ]
	                        }
	                    ]
	                });
	            });
	            return result;
	        };
	    }
	    isSpecValid(spec) {
	        const { xField, yField, data } = spec;
	        if (!xField || !yField || !data || data.length === 0) {
	            return false;
	        }
	        return true;
	    }
	    transformSpec(spec) {
	        var _a;
	        super.transformSpec(spec);
	        if (!this.isSpecValid(spec)) {
	            spec.series = [];
	            return;
	        }
	        this.normalizeSpec(spec);
	        this.upgradeTextMeasure(spec);
	        this.upgradeFormatMap(spec);
	        this.processData(spec);
	        this.transformBaseSpec(spec);
	        this.transformAnimationSpec(spec);
	        this.transformAxesSpec(spec);
	        spec.extensionMark = [
	            this.generateBarBackground(spec),
	            ...this.generateDecorateHaloIcons(spec),
	            this.generateRankingIcon(spec),
	            this.generateNameLabel(spec),
	            this.generateOrderLabel(spec),
	            this.generateValueLabel(spec)
	        ];
	        this.transformPaddingSpec(spec);
	        (_a = spec.customTransformSpec) === null || _a === void 0 ? void 0 : _a.call(spec, spec);
	        super.transformSpec(spec);
	    }
	    normalizeSpec(spec) {
	        mergeObjects(spec, defaultSpec);
	        applyVisible(spec, [
	            'barBackground',
	            'rankingIcon',
	            'decorateHaloIcons',
	            'orderLabel',
	            'nameLabel',
	            'valueLabel'
	        ]);
	    }
	    upgradeTextMeasure(spec) {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
	        (_a = this.nameLabelTextMeasure) === null || _a === void 0 ? void 0 : _a.release();
	        (_b = this.valueLabelTextMeasure) === null || _b === void 0 ? void 0 : _b.release();
	        (_c = this.orderLabelTextMeasure) === null || _c === void 0 ? void 0 : _c.release();
	        this.nameLabelTextMeasure = new TextMeasure({
	            defaultFontParams: (_e = (_d = spec.nameLabel) === null || _d === void 0 ? void 0 : _d.style) !== null && _e !== void 0 ? _e : {}
	        });
	        this.valueLabelTextMeasure = new TextMeasure({
	            defaultFontParams: (_g = (_f = spec.valueLabel) === null || _f === void 0 ? void 0 : _f.style) !== null && _g !== void 0 ? _g : {}
	        });
	        this.orderLabelTextMeasure = new TextMeasure({
	            defaultFontParams: (_j = (_h = spec.orderLabel) === null || _h === void 0 ? void 0 : _h.style) !== null && _j !== void 0 ? _j : {}
	        });
	    }
	    upgradeFormatMap(spec) {
	        this.formatMap[spec.yField] = spec.nameLabel.formatMethod;
	        this.formatMap[spec.xField] = spec.valueLabel.formatMethod;
	        this.formatMap[ORDER_KEY] = spec.orderLabel.formatMethod;
	    }
	    processData(spec) {
	        var _a;
	        if (!((_a = spec.data[0]) === null || _a === void 0 ? void 0 : _a.values)) {
	            this.originalData = spec.data;
	            this.originalSpec = cloneDeep(spec);
	            this.dataSpecs = this.processRankingData(spec);
	            spec.data = this.dataSpecs[0].data;
	        }
	    }
	    transformBaseSpec(spec) {
	        var _a, _b, _c;
	        spec.type = 'common';
	        spec.dataKey = DATA_KEY$3;
	        spec.series = [
	            {
	                type: 'bar',
	                direction: 'horizontal',
	                xField: spec.xField,
	                yField: spec.yField,
	                barWidth: (_b = (_a = spec.bar) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 10,
	                bar: Object.assign(Object.assign({}, spec.bar), { style: Object.assign(Object.assign({}, (_c = spec.bar) === null || _c === void 0 ? void 0 : _c.style), { x1: 0, visible: (datum) => {
	                            var _a, _b;
	                            if (datum[SUPPLY_DATA_KEY]) {
	                                return false;
	                            }
	                            return (_b = (_a = spec.bar) === null || _a === void 0 ? void 0 : _a.style) !== null && _b !== void 0 ? _b : true;
	                        } }) })
	            }
	        ];
	    }
	    transformAnimationSpec(spec) {
	        var _a, _b, _c;
	        if (spec.animationUpdate.enable && this.orderCount > 1) {
	            spec.player = Object.assign({ specs: this.dataSpecs, auto: true, visible: false, interval: ((_b = (_a = spec.animationNormal) === null || _a === void 0 ? void 0 : _a.interval) !== null && _b !== void 0 ? _b : 1000) + ((_c = spec.animationUpdate.duration) !== null && _c !== void 0 ? _c : 1000) / 2, loop: true }, spec.player);
	            spec.animationExit = this.getAnimationExit(this.originalSpec);
	            spec.animationEnter = this.getAnimationEnter(this.originalSpec);
	            spec.animationUpdate = this.getAnimationUpdate(this.originalSpec);
	        }
	        spec.animationNormal = this.originalSpec.animationNormal;
	        spec.animationAppear = this.getAnimationAppear(this.originalSpec, 'rect');
	    }
	    transformAxesSpec(spec) {
	        const { min, max } = computeDataRange(this.originalData, spec.xField);
	        spec.axes = [
	            {
	                orient: 'left',
	                type: 'band',
	                visible: false,
	                inverse: true,
	                paddingOuter: 0.5
	            },
	            {
	                orient: 'bottom',
	                label: { visible: true },
	                type: 'linear',
	                visible: false,
	                min,
	                max
	            }
	        ];
	    }
	    generateBarBackground(spec) {
	        var _a;
	        return {
	            type: spec.barBackground.type,
	            dataId: 'data',
	            visible: true,
	            dataKey: DATA_KEY$3,
	            zIndex: -99,
	            state: (_a = spec.barBackground) === null || _a === void 0 ? void 0 : _a.state,
	            style: Object.assign(Object.assign({ x: (datum, ctx) => spec.barBackground.type === 'symbol' ? ctx.getRegion().getLayoutRect().width / 2 : 0, y: (datum, ctx) => {
	                    return (ctx.valueToY([datum[spec.yField]]) +
	                        ctx.yBandwidth() / 2 -
	                        (spec.barBackground.type === 'symbol' ? 0 : spec.bar.height / 2));
	                }, size: (datum, ctx) => [ctx.getRegion().getLayoutRect().width, spec.bar.height], width: (datum, ctx) => ctx.getRegion().getLayoutRect().width, height: spec.bar.height }, spec.barBackground.style), { visible: (datum) => {
	                    if (datum[SUPPLY_DATA_KEY]) {
	                        return false;
	                    }
	                    return spec.barBackground.style.visible;
	                } }),
	            animation: true,
	            animationEnter: this.getAnimationEnter(this.originalSpec),
	            animationExit: this.getAnimationExit(this.originalSpec),
	            animationAppear: this.getAnimationAppear(this.originalSpec, 'barBack'),
	            animationUpdate: this.getAnimationUpdate(this.originalSpec)
	        };
	    }
	    generateDecorateHaloIcons(spec) {
	        var _a;
	        return (_a = spec.decorateHaloIcons) === null || _a === void 0 ? void 0 : _a.map((decorateHaloIcon) => {
	            return {
	                type: 'symbol',
	                dataId: 'data',
	                visible: true,
	                dataKey: DATA_KEY$3,
	                state: decorateHaloIcon === null || decorateHaloIcon === void 0 ? void 0 : decorateHaloIcon.state,
	                style: Object.assign(Object.assign({ x: (datum, ctx) => {
	                        if (datum[spec.xField] === undefined || datum[spec.xField] === null) {
	                            return undefined;
	                        }
	                        return ctx.valueToX([datum[spec.xField]]);
	                    }, y: (datum, ctx) => {
	                        return ctx.valueToY([datum[spec.yField]]) + ctx.yBandwidth() / 2;
	                    } }, decorateHaloIcon.style), { visible: (datum) => {
	                        if (datum[SUPPLY_DATA_KEY]) {
	                            return false;
	                        }
	                        return decorateHaloIcon.style.visible;
	                    } }),
	                animation: true,
	                animationEnter: this.getAnimationEnter(this.originalSpec),
	                animationExit: this.getAnimationExit(this.originalSpec),
	                animationAppear: this.getAnimationAppear(this.originalSpec, 'symbol'),
	                animationUpdate: this.getAnimationUpdate(this.originalSpec)
	            };
	        });
	    }
	    generateRankingIcon(spec) {
	        return {
	            type: 'symbol',
	            dataId: 'data',
	            visible: true,
	            dataKey: DATA_KEY$3,
	            state: spec.rankingIcon.state,
	            style: Object.assign(Object.assign({ x: (datum) => {
	                    if (spec.labelLayout === 'bothEnd') {
	                        return -(NAME_LABEL_PADDING_RIGHT +
	                            this.nameLabelTextMeasure.fullMeasure(this.formatDatum(spec.yField, datum)).width +
	                            (spec.orderLabel.style.visible
	                                ? NAME_ORDER_PADDING_RIGHT +
	                                    this.orderLabelTextMeasure.fullMeasure(this.formatDatum(ORDER_KEY, datum)).width
	                                : 0) +
	                            NAME_SYMBOL_PADDING_RIGHT);
	                    }
	                    return CHART_PADDING_LEFT;
	                }, y: (datum, ctx) => {
	                    if (spec.labelLayout === 'bothEnd') {
	                        return ctx.valueToY([datum[spec.yField]]) + ctx.yBandwidth() / 2;
	                    }
	                    return (ctx.valueToY([datum[spec.yField]]) +
	                        ctx.yBandwidth() / 2 -
	                        spec.bar.height / 2 -
	                        LABEL_PADDING_BOTTOM -
	                        Math.max(this.nameLabelTextMeasure.fullMeasure(this.formatDatum(spec.yField, datum)).height, this.orderLabelTextMeasure.fullMeasure(this.formatDatum(ORDER_KEY, datum)).height) /
	                            2);
	                } }, spec.rankingIcon.style), { lineWidth: 0, stroke: null, visible: (datum) => {
	                    if (datum[SUPPLY_DATA_KEY]) {
	                        return false;
	                    }
	                    return spec.rankingIcon.style.visible;
	                } }),
	            animation: true,
	            animationEnter: this.getAnimationEnter(this.originalSpec),
	            animationExit: this.getAnimationExit(this.originalSpec),
	            animationAppear: this.getAnimationAppear(this.originalSpec, 'text'),
	            animationUpdate: this.getAnimationUpdate(this.originalSpec)
	        };
	    }
	    generateNameLabel(spec) {
	        var _a;
	        return {
	            type: 'text',
	            dataId: 'data',
	            dataKey: DATA_KEY$3,
	            state: (_a = spec.nameLabel) === null || _a === void 0 ? void 0 : _a.state,
	            style: Object.assign(Object.assign({ text: (datum) => this.formatDatum(spec.yField, datum), x: () => {
	                    var _a;
	                    if (spec.labelLayout === 'bothEnd') {
	                        return -NAME_LABEL_PADDING_RIGHT;
	                    }
	                    return ((spec.rankingIcon.style.visible ? NAME_SYMBOL_PADDING_RIGHT + ((_a = spec.rankingIcon.style.size) !== null && _a !== void 0 ? _a : 10) : 0) +
	                        (spec.orderLabel.style.visible
	                            ? NAME_ORDER_PADDING_RIGHT + this.getMaxDataLabelLens(spec, ORDER_KEY, this.orderLabelTextMeasure)
	                            : 0));
	                }, y: (datum, ctx) => {
	                    if (spec.labelLayout === 'bothEnd') {
	                        return ctx.valueToY([datum[spec.yField]]) + ctx.yBandwidth() / 2;
	                    }
	                    return ctx.valueToY([datum[spec.yField]]) + ctx.yBandwidth() / 2 - spec.bar.height / 2 - LABEL_PADDING_BOTTOM;
	                } }, spec.nameLabel.style), { textAlign: spec.labelLayout === 'bothEnd' ? 'right' : 'left', textBaseline: spec.labelLayout === 'bothEnd' ? 'middle' : 'bottom', visible: (datum) => {
	                    if (datum[SUPPLY_DATA_KEY]) {
	                        return false;
	                    }
	                    return spec.nameLabel.style.visible;
	                } }),
	            animation: true,
	            animationEnter: this.getAnimationEnter(this.originalSpec),
	            animationExit: this.getAnimationExit(this.originalSpec),
	            animationAppear: this.getAnimationAppear(this.originalSpec, 'text'),
	            animationUpdate: this.getAnimationUpdate(this.originalSpec)
	        };
	    }
	    generateOrderLabel(spec) {
	        var _a;
	        return {
	            type: 'text',
	            dataId: 'data',
	            dataKey: DATA_KEY$3,
	            state: (_a = spec.orderLabel) === null || _a === void 0 ? void 0 : _a.state,
	            style: Object.assign(Object.assign({ text: (datum) => this.formatDatum(ORDER_KEY, datum), x: (datum) => {
	                    var _a;
	                    if (spec.labelLayout === 'bothEnd') {
	                        return -(NAME_LABEL_PADDING_RIGHT +
	                            this.nameLabelTextMeasure.fullMeasure(this.formatDatum(spec.yField, datum)).width +
	                            NAME_ORDER_PADDING_RIGHT);
	                    }
	                    return spec.rankingIcon.style.visible ? NAME_SYMBOL_PADDING_RIGHT + ((_a = spec.rankingIcon.style.size) !== null && _a !== void 0 ? _a : 10) : 0;
	                }, y: (datum, ctx) => {
	                    if (spec.labelLayout === 'bothEnd') {
	                        return ctx.valueToY([datum[spec.yField]]) + ctx.yBandwidth() / 2;
	                    }
	                    return ctx.valueToY([datum[spec.yField]]) + ctx.yBandwidth() / 2 - spec.bar.height / 2 - LABEL_PADDING_BOTTOM;
	                } }, spec.orderLabel.style), { textAlign: spec.labelLayout === 'bothEnd' ? 'right' : 'left', textBaseline: spec.labelLayout === 'bothEnd' ? 'middle' : 'bottom', visible: (datum) => {
	                    if (datum[SUPPLY_DATA_KEY]) {
	                        return false;
	                    }
	                    return spec.orderLabel.style.visible;
	                } }),
	            animation: true,
	            animationEnter: this.getAnimationEnter(this.originalSpec),
	            animationExit: this.getAnimationExit(this.originalSpec),
	            animationAppear: this.getAnimationAppear(this.originalSpec, 'text'),
	            animationUpdate: this.getAnimationUpdate(this.originalSpec)
	        };
	    }
	    generateValueLabel(spec) {
	        var _a;
	        return {
	            type: 'text',
	            dataId: 'data',
	            visible: true,
	            dataKey: DATA_KEY$3,
	            state: (_a = spec.valueLabel) === null || _a === void 0 ? void 0 : _a.state,
	            style: Object.assign(Object.assign({ text: (datum) => this.formatDatum(spec.xField, datum), x: (datum, ctx) => {
	                    if (spec.labelLayout === 'bothEnd') {
	                        return (ctx.getRegion().getLayoutRect().width +
	                            VALUE_LABEL_PADDING_LEFT);
	                    }
	                    return ctx.getRegion().getLayoutRect().width;
	                }, y: (datum, ctx) => {
	                    if (spec.labelLayout === 'bothEnd') {
	                        return ctx.valueToY([datum[spec.yField]]) + ctx.yBandwidth() / 2;
	                    }
	                    return ctx.valueToY([datum[spec.yField]]) + ctx.yBandwidth() / 2 - spec.bar.height / 2 - LABEL_PADDING_BOTTOM;
	                } }, spec.valueLabel.style), { textAlign: spec.labelLayout === 'bothEnd' ? 'left' : 'right', textBaseline: spec.labelLayout === 'bothEnd' ? 'middle' : 'bottom', visible: (datum) => {
	                    if (datum[SUPPLY_DATA_KEY]) {
	                        return false;
	                    }
	                    return spec.valueLabel.style.visible;
	                } }),
	            animation: true,
	            animationEnter: this.getAnimationEnter(this.originalSpec),
	            animationExit: this.getAnimationExit(this.originalSpec),
	            animationAppear: this.getAnimationAppear(this.originalSpec, 'text'),
	            animationUpdate: this.getAnimationUpdate(this.originalSpec)
	        };
	    }
	    transformPaddingSpec(spec) {
	        var _a;
	        const maxHaloIconSize = spec.decorateHaloIcons.length > 0
	            ? Math.max(...spec.decorateHaloIcons.map((icon) => { var _a, _b; return (_b = (_a = icon.style) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 18; }))
	            : 0;
	        spec.padding = Object.assign({ left: spec.labelLayout === 'bothEnd'
	                ? NAME_LABEL_PADDING_RIGHT +
	                    this.getMaxDataLabelLens(spec, spec.yField, this.nameLabelTextMeasure) +
	                    (spec.orderLabel.style.visible
	                        ? NAME_ORDER_PADDING_RIGHT + this.getMaxDataLabelLens(spec, ORDER_KEY, this.orderLabelTextMeasure)
	                        : 0) +
	                    (spec.rankingIcon.style.visible ? NAME_SYMBOL_PADDING_RIGHT + ((_a = spec.rankingIcon.style.size) !== null && _a !== void 0 ? _a : 10) : 0) +
	                    CHART_PADDING_LEFT
	                : CHART_PADDING_LEFT + maxHaloIconSize / 2, right: spec.labelLayout === 'bothEnd'
	                ? VALUE_LABEL_PADDING_LEFT +
	                    this.getMaxDataLabelLens(spec, spec.xField, this.valueLabelTextMeasure) +
	                    CHART_PADDING_RIGHT
	                : CHART_PADDING_RIGHT + 10, top: 0, bottom: 0 }, spec.padding);
	    }
	    getMaxDataLabelLens(spec, field, textMeasure) {
	        const textWidths = this.originalData.map(datum => datum[SUPPLY_DATA_KEY] ? 0 : textMeasure.fullMeasure(this.formatDatum(field, datum)).width);
	        return Math.max(...textWidths);
	    }
	    formatDatum(field, datum) {
	        var _a;
	        if ((_a = this.formatMap) === null || _a === void 0 ? void 0 : _a[field]) {
	            return this.formatMap[field](datum[field], datum);
	        }
	        return datum[field];
	    }
	    getLabelWidth(padding, width) {
	        return width + padding;
	    }
	    getAnimationExit(spec) {
	        var _a, _b, _c, _d, _e;
	        if (((_a = spec.animationUpdate) === null || _a === void 0 ? void 0 : _a.enable) === false) {
	            return false;
	        }
	        return {
	            type: 'moveOut',
	            options: {
	                direction: 'y',
	                orient: 'negative',
	                excludeChannels: ['x'],
	                point: (datum, graphic) => {
	                    const channelAttr = graphic.getGraphicAttribute('y');
	                    const barSpace = spec.height / (spec.pageSize + 1);
	                    return { y: channelAttr - barSpace * Math.min(spec.scrollSize, spec.pageSize) };
	                }
	            },
	            duration: (_c = (_b = spec.animationUpdate) === null || _b === void 0 ? void 0 : _b.duration) !== null && _c !== void 0 ? _c : 1000,
	            easing: (_e = (_d = spec.animationUpdate) === null || _d === void 0 ? void 0 : _d.easing) !== null && _e !== void 0 ? _e : 'linear'
	        };
	    }
	    getAnimationEnter(spec) {
	        var _a, _b, _c, _d, _e;
	        if (((_a = spec.animationUpdate) === null || _a === void 0 ? void 0 : _a.enable) === false) {
	            return false;
	        }
	        return {
	            type: 'moveIn',
	            options: {
	                direction: 'y',
	                orient: 'negative',
	                excludeChannels: ['x'],
	                point: (datum, graphic) => {
	                    const channelAttr = graphic.getGraphicAttribute('y');
	                    return { y: channelAttr + (spec.height / (spec.pageSize + 1)) * Math.min(spec.scrollSize, spec.pageSize) };
	                }
	            },
	            duration: (_c = (_b = spec.animationUpdate) === null || _b === void 0 ? void 0 : _b.duration) !== null && _c !== void 0 ? _c : 1000,
	            easing: (_e = (_d = spec.animationUpdate) === null || _d === void 0 ? void 0 : _d.easing) !== null && _e !== void 0 ? _e : 'linear'
	        };
	    }
	    getAnimationAppear(spec, markType) {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
	        if (((_a = spec.animationAppear) === null || _a === void 0 ? void 0 : _a.enable) === false) {
	            return false;
	        }
	        if (markType === 'rect') {
	            return {
	                type: 'growWidthIn',
	                oneByOne: false,
	                duration: (_c = (_b = spec.animationAppear) === null || _b === void 0 ? void 0 : _b.duration) !== null && _c !== void 0 ? _c : 1000,
	                easing: (_e = (_d = spec.animationAppear) === null || _d === void 0 ? void 0 : _d.easing) !== null && _e !== void 0 ? _e : 'linear',
	                options: {}
	            };
	        }
	        else if (markType === 'symbol') {
	            return {
	                channel: {
	                    x: {
	                        from: 0,
	                        to: (datum, graphic) => {
	                            return graphic.getGraphicAttribute('x');
	                        }
	                    }
	                },
	                duration: (_g = (_f = spec.animationAppear) === null || _f === void 0 ? void 0 : _f.duration) !== null && _g !== void 0 ? _g : 1000,
	                easing: (_j = (_h = spec.animationAppear) === null || _h === void 0 ? void 0 : _h.easing) !== null && _j !== void 0 ? _j : 'linear'
	            };
	        }
	        return {
	            channel: {
	                opacity: {
	                    from: 0,
	                    to: 1
	                }
	            },
	            duration: (_l = (_k = spec.animationAppear) === null || _k === void 0 ? void 0 : _k.duration) !== null && _l !== void 0 ? _l : 1000,
	            easing: (_o = (_m = spec.animationAppear) === null || _m === void 0 ? void 0 : _m.easing) !== null && _o !== void 0 ? _o : 'linear'
	        };
	    }
	    getAnimationUpdate(spec) {
	        var _a, _b, _c, _d;
	        if (spec.animationUpdate.enable === false) {
	            return false;
	        }
	        return {
	            duration: (_b = (_a = spec.animationUpdate) === null || _a === void 0 ? void 0 : _a.duration) !== null && _b !== void 0 ? _b : 1000,
	            easing: (_d = (_c = spec.animationUpdate) === null || _c === void 0 ? void 0 : _c.easing) !== null && _d !== void 0 ? _d : 'linear'
	        };
	    }
	}

	class RankingList extends vchart.BaseChart {
	    constructor() {
	        super(...arguments);
	        this.type = 'rankingList';
	        this.transformerConstructor = RankingListChartSpecTransformer;
	    }
	    init() {
	        if (!this.isValid()) {
	            return;
	        }
	        super.init();
	    }
	    isValid() {
	        var _a, _b, _c, _d;
	        const { xField, yField, data } = this._spec;
	        if (!xField || !yField) {
	            (_b = (_a = this._option).onError) === null || _b === void 0 ? void 0 : _b.call(_a, 'Missing Required Config: `xField`, `yField` ');
	            return false;
	        }
	        if (!data) {
	            (_d = (_c = this._option).onError) === null || _d === void 0 ? void 0 : _d.call(_c, 'Data is required');
	            return false;
	        }
	        return true;
	    }
	}
	RankingList.type = 'rankingList';
	RankingList.view = 'singleDefault';
	RankingList.transformerConstructor = RankingListChartSpecTransformer;
	const registerRankingList = (option) => {
	    const vchartConstructor = (option === null || option === void 0 ? void 0 : option.VChart) || vchart.VChart;
	    if (vchartConstructor) {
	        vchartConstructor.useChart([RankingList, vchart.BarChart]);
	    }
	};

	const fields = (data, options) => {
	  var _a, _b;
	  if (!(null == options ? void 0 : options.fields)) return data;
	  if (0 === data.length) return data;
	  const fields = options.fields,
	    dataTemp = data[0],
	    filterFields = {},
	    sortFields = [];
	  for (const key in fields) if (Object.prototype.hasOwnProperty.call(fields, key)) {
	    const fieldInfo = fields[key];
	    if (fieldInfo.sort && (isValidNumber$1(fieldInfo.sortIndex) || (fieldInfo.sortIndex = 0), isValid$1(fieldInfo.sortReverse) || (fieldInfo.sortReverse = "desc" === fieldInfo.sort)), !fieldInfo.type) {
	      let dataCheck = dataTemp;
	      key in dataTemp || (dataCheck = null !== (_a = data.find(d => key in d)) && void 0 !== _a ? _a : dataTemp), fieldInfo.type = "number" == typeof dataCheck[key] ? "linear" : "ordinal";
	    }
	    let sortInfo;
	    if ("number" == typeof fieldInfo.sortIndex && (sortInfo = {
	      key: key,
	      type: fieldInfo.type,
	      index: fieldInfo.sortIndex,
	      sortIndex: {},
	      sortIndexCount: 0,
	      sortReverse: !0 === fieldInfo.sortReverse
	    }, sortFields.push(sortInfo)), (null === (_b = fieldInfo.domain) || void 0 === _b ? void 0 : _b.length) > 0) if ("ordinal" === fieldInfo.type) {
	      fieldInfo._domainCache = {}, filterFields[key] = fieldInfo;
	      const _domainCache = {};
	      fieldInfo.domain.forEach((d, i) => {
	        _domainCache[d] = i, fieldInfo._domainCache[d] = i;
	      }), sortInfo && (sortInfo.sortIndex = _domainCache, sortInfo.sortIndexCount = fieldInfo.domain.length);
	    } else fieldInfo.domain.length >= 2 && (filterFields[key] = fieldInfo);
	  }
	  return Object.keys(filterFields).length > 0 && (data = data.filter(d => {
	    for (const key in filterFields) {
	      const fieldInfo = filterFields[key];
	      if ("ordinal" === fieldInfo.type) {
	        if (!(d[key] in fieldInfo._domainCache)) return !1;
	      } else if (fieldInfo.domain[0] > d[key] || fieldInfo.domain[1] < d[key]) return !1;
	    }
	    return !0;
	  })), sortFields.sort((a, b) => a.index - b.index), data.sort((a, b) => sortData(a, b, sortFields)), data;
	};
	function sortData(a, b, sortFields) {
	  for (let i = 0; i < sortFields.length; i++) {
	    const sortInfo = sortFields[i];
	    let v = 0;
	    if ("ordinal" === sortInfo.type ? (void 0 === sortInfo.sortIndex[b[sortInfo.key]] && (sortInfo.sortIndex[b[sortInfo.key]] = sortInfo.sortIndexCount++), void 0 === sortInfo.sortIndex[a[sortInfo.key]] && (sortInfo.sortIndex[a[sortInfo.key]] = sortInfo.sortIndexCount++), v = sortInfo.sortIndex[a[sortInfo.key]] - sortInfo.sortIndex[b[sortInfo.key]]) : "linear" === sortInfo.type && (v = a[sortInfo.key] - b[sortInfo.key]), sortInfo.sortReverse && (v = -v), 0 !== v) return v;
	  }
	  return 0;
	}

	const tagNameToType = {
	    svg: "group",
	    rect: "rect",
	    line: "rule",
	    polygon: "polygon",
	    path: "path",
	    polyline: "line",
	    g: "group",
	    circle: "arc",
	    ellipse: "arc"
	  },
	  validTagName = Object.keys(tagNameToType),
	  validGroupNode = ["g", "svg", "text", "tspan", "switch"],
	  validTextAttributes = ["font-size", "font-family", "font-weight", "font-style", "text-align", "text-anchor"],
	  validCircleAttributes = ["cx", "cy", "r"],
	  validEllipseAttributes = ["cx", "cy", "rx", "ry"],
	  validLineAttributes = ["x1", "x2", "y1", "y2"],
	  validAttributes = ["visibility", "x", "y", "width", "height", "d", "points", "stroke", "stroke-width", "fill", "fill-opacity", "stroke-opacity", ...validTextAttributes, ...validCircleAttributes, ...validEllipseAttributes, ...validLineAttributes],
	  validInheritAttributes = ["visible", "fill", "stroke", "stroke-width", "fill-opacity", "stroke-opacity", ...validTextAttributes],
	  numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
	function splitNumberSequence(rawStr) {
	  return rawStr.match(numberReg) || [];
	}
	const svgParser = (data, option = {}, dataView) => {
	  let parser = option.customDOMParser;
	  if (parser || (null === window || void 0 === window ? void 0 : window.DOMParser) && (parser = svg => new DOMParser().parseFromString(svg, "text/xml")), !parser) throw new Error("No Available DOMParser!");
	  const svg = parser(data);
	  let node = 9 === svg.nodeType ? svg.firstChild : svg;
	  for (; node && ("svg" !== node.nodeName.toLowerCase() || 1 !== node.nodeType);) node = node.nextSibling;
	  if (node) {
	    return parseSvgNode(node);
	  }
	  return null;
	};
	let idx$1 = 0;
	function parseSvgNode(svg, opt = {}) {
	  const elements = [],
	    root = parseNode(svg, null);
	  let width = parseFloat(svg.getAttribute("width") || opt.width),
	    height = parseFloat(svg.getAttribute("height") || opt.height);
	  !isValidNumber$1(width) && (width = null), !isValidNumber$1(height) && (height = null);
	  const viewBox = svg.getAttribute("viewBox");
	  let viewBoxRect;
	  if (viewBox) {
	    const viewBoxArr = splitNumberSequence(viewBox);
	    if (viewBoxArr.length >= 4 && (viewBoxRect = {
	      x: parseFloat(viewBoxArr[0] || 0),
	      y: parseFloat(viewBoxArr[1] || 0),
	      width: parseFloat(viewBoxArr[2]),
	      height: parseFloat(viewBoxArr[3])
	    }, width || height)) {
	      const boundingRect = {
	          x: 0,
	          y: 0,
	          width: width,
	          height: height
	        },
	        scaleX = boundingRect.width / viewBoxRect.width,
	        scaleY = boundingRect.height / viewBoxRect.height,
	        scale = Math.min(scaleX, scaleY),
	        transLateX = -(viewBoxRect.x + viewBoxRect.width / 2) * scale + (boundingRect.x + boundingRect.width / 2),
	        transLateY = -(viewBoxRect.y + viewBoxRect.height / 2) * scale + (boundingRect.y + boundingRect.height / 2),
	        viewBoxTransform = new Matrix().translate(transLateX, transLateY).scale(scale, scale);
	      root.transform = viewBoxTransform;
	    }
	  }
	  return traverse(svg, root, elements), {
	    root: root,
	    width: width,
	    height: height,
	    elements: elements,
	    viewBoxRect: viewBoxRect
	  };
	}
	function parseInheritAttributes(parsedElement) {
	  let inheritedAttrs;
	  const {
	      parent: parent,
	      attributes: attributes
	    } = parsedElement,
	    parse = parent => parent ? validInheritAttributes.reduce((acc, attrName) => {
	      const camelAttrName = toCamelCase(attrName);
	      return isValid$1(parent[camelAttrName]) && (acc[camelAttrName] = parent[camelAttrName]), acc;
	    }, {}) : {};
	  return parent ? (parent._inheritStyle || (parent._inheritStyle = parse(parent.attributes)), inheritedAttrs = merge({}, parent._inheritStyle, parse(attributes))) : inheritedAttrs = parse(attributes), inheritedAttrs;
	}
	function parseAttributes(el) {
	  var _a, _b, _c;
	  const attrs = {},
	    attributes = null !== (_a = el.attributes) && void 0 !== _a ? _a : {},
	    style = null !== (_b = el.style) && void 0 !== _b ? _b : {};
	  for (let i = 0; i < validAttributes.length; i++) {
	    const attrName = validAttributes[i],
	      attrValue = isValid$1(style[attrName]) && "" !== style[attrName] ? style[attrName] : null === (_c = attributes[attrName]) || void 0 === _c ? void 0 : _c.value;
	    isValid$1(attrValue) && (attrs[toCamelCase(attrName)] = isNaN(+attrValue) ? attrValue : parseFloat(attrValue));
	  }
	  return "none" === style.display && (attrs.visible = !1), ["fontSize", "strokeWidth", "width", "height"].forEach(attr => {
	    const attrValue = attrs[attr];
	    isString$1(attrs[attr]) && (attrs[attr] = parseFloat(attrValue));
	  }), attrs;
	}
	function parseNode(node, parent) {
	  var _a, _b, _c, _d, _e;
	  const tagName = null === (_a = node.tagName) || void 0 === _a ? void 0 : _a.toLowerCase();
	  if (3 === node.nodeType || "text" === tagName || "tspan" === tagName) return parseText(node, parent);
	  if (!validTagName.includes(tagName)) return null;
	  const parsed = {
	    tagName: tagName,
	    graphicType: tagNameToType[tagName],
	    attributes: parseAttributes(node),
	    parent: parent,
	    name: null !== (_b = node.getAttribute("name")) && void 0 !== _b ? _b : null === (_c = null == parent ? void 0 : parent.attributes) || void 0 === _c ? void 0 : _c.name,
	    id: null !== (_d = node.getAttribute("id")) && void 0 !== _d ? _d : `${tagName}-${idx$1++}`,
	    transform: parseTransform(node)
	  };
	  return parsed._inheritStyle = parseInheritAttributes(parsed), parent && !isValid$1(parsed.name) && (parsed._nameFromParent = null !== (_e = parent.name) && void 0 !== _e ? _e : parent._nameFromParent), parsed;
	}
	function parseText(node, parent) {
	  var _a, _b, _c, _d, _e, _f;
	  if (!parent) return null;
	  const tagName = null === (_a = node.tagName) || void 0 === _a ? void 0 : _a.toLowerCase();
	  if (!tagName && "group" !== parent.graphicType) return null;
	  const nodeAsGroup = "text" === tagName || "tspan" === tagName,
	    elType = nodeAsGroup ? "group" : "text",
	    value = nodeAsGroup || null === (_b = node.textContent) || void 0 === _b ? void 0 : _b.replace(/\n/g, " ").replace(/\s+/g, " ");
	  if (" " === value) return null;
	  let parsed;
	  return parsed = nodeAsGroup ? {
	    tagName: tagName,
	    graphicType: elType,
	    attributes: parseAttributes(node),
	    parent: parent,
	    name: node.getAttribute("name"),
	    id: null !== (_c = node.getAttribute("id")) && void 0 !== _c ? _c : `${tagName}-${idx$1++}`,
	    transform: parseTransform(node),
	    value: value
	  } : {
	    tagName: tagName,
	    graphicType: "text",
	    attributes: parseAttributes(node),
	    parent: parent,
	    name: null == parent ? void 0 : parent.name,
	    id: null !== (_e = null === (_d = node.getAttribute) || void 0 === _d ? void 0 : _d.call(node, "id")) && void 0 !== _e ? _e : `${tagName}-${idx$1++}`,
	    value: value
	  }, parsed._inheritStyle = parseInheritAttributes(parsed), isValid$1(parsed.name) || (parsed._nameFromParent = null !== (_f = parent.name) && void 0 !== _f ? _f : parent._nameFromParent), nodeAsGroup ? parent._textGroupStyle ? parsed._textGroupStyle = merge({}, parent._textGroupStyle, parseAttributes(node)) : parsed._textGroupStyle = parseAttributes(node) : parsed.attributes = parsed._inheritStyle, parsed;
	}
	function parseTransform(node) {
	  var _a, _b;
	  const transforms = null === (_a = node.transform) || void 0 === _a ? void 0 : _a.baseVal;
	  if (!transforms) return null;
	  const matrix = null === (_b = transforms.consolidate()) || void 0 === _b ? void 0 : _b.matrix;
	  if (!matrix) return null;
	  const {
	    a: a,
	    b: b,
	    c: c,
	    d: d,
	    e: e,
	    f: f
	  } = matrix;
	  return new Matrix(a, b, c, d, e, f);
	}
	function traverse(node, parsedParent, result = []) {
	  var _a;
	  if (!node) return;
	  let parseResult;
	  "svg" !== node.nodeName && (parseResult = parseNode(node, parsedParent)), parseResult && result.push(parseResult);
	  let child = validGroupNode.includes(null === (_a = node.tagName) || void 0 === _a ? void 0 : _a.toLocaleLowerCase()) ? node.firstChild : null;
	  for (; child;) traverse(child, null != parseResult ? parseResult : parsedParent, result), child = child.nextSibling;
	}

	let idIndex = 0;
	const maxId = 1e8;
	function getUUID(prefix = "dataset") {
	  return idIndex > maxId && (idIndex = 0), prefix + "_" + idIndex++;
	}

	class DataSet {
	  constructor(options) {
	    var _a;
	    let name;
	    this.options = options, this.isDataSet = !0, this.transformMap = {}, this.parserMap = {}, this.dataViewMap = {}, this.target = new EventEmitter(), name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataset"), this.name = name, this._logger = null !== (_a = null == options ? void 0 : options.logger) && void 0 !== _a ? _a : Logger.getInstance();
	  }
	  setLogger(logger) {
	    this._logger = logger;
	  }
	  getDataView(name) {
	    return this.dataViewMap[name];
	  }
	  setDataView(name, dataView) {
	    var _a;
	    this.dataViewMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.error(`Error: dataView ${name} 之前已存在，请重新命名`)), this.dataViewMap[name] = dataView;
	  }
	  removeDataView(name) {
	    this.dataViewMap[name] = null, delete this.dataViewMap[name];
	  }
	  registerParser(name, parser) {
	    var _a;
	    this.parserMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.warn(`Warn: transform ${name} 之前已注册，执行覆盖逻辑`)), this.parserMap[name] = parser;
	  }
	  removeParser(name) {
	    this.parserMap[name] = null, delete this.parserMap[name];
	  }
	  getParser(name) {
	    return this.parserMap[name] || this.parserMap.default;
	  }
	  registerTransform(name, transform) {
	    var _a;
	    this.transformMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.warn(`Warn: transform ${name} 之前已注册，执行覆盖逻辑`)), this.transformMap[name] = transform;
	  }
	  removeTransform(name) {
	    this.transformMap[name] = null, delete this.transformMap[name];
	  }
	  getTransform(name) {
	    return this.transformMap[name];
	  }
	  multipleDataViewAddListener(list, event, call) {
	    this._callMap || (this._callMap = new Map());
	    let callAd = this._callMap.get(call);
	    callAd || (callAd = () => {
	      list.some(l => l.isRunning) || call();
	    }), list.forEach(l => {
	      l.target.addListener(event, callAd);
	    }), this._callMap.set(call, callAd);
	  }
	  allDataViewAddListener(event, call) {
	    this.multipleDataViewAddListener(Object.values(this.dataViewMap), event, call);
	  }
	  multipleDataViewRemoveListener(list, event, call) {
	    if (this._callMap) {
	      const callAd = this._callMap.get(call);
	      callAd && list.forEach(l => {
	        l.target.removeListener(event, callAd);
	      }), this._callMap.delete(call);
	    }
	  }
	  multipleDataViewUpdateInParse(newData) {
	    newData.forEach(d => {
	      var _a;
	      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.markRunning();
	    }), newData.forEach(d => {
	      var _a;
	      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.parseNewData(d.data, d.options);
	    });
	  }
	  multipleDataViewUpdateInRawData(newData) {
	    newData.forEach(d => {
	      var _a;
	      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.markRunning();
	    }), newData.forEach(d => {
	      var _a;
	      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.updateRawData(d.data, d.options);
	    });
	  }
	  destroy() {
	    this.transformMap = null, this.parserMap = null, this.dataViewMap = null, this._callMap = null, this.target.removeAllListeners();
	  }
	}

	class DataView {
	  constructor(dataSet, options) {
	    let name;
	    this.dataSet = dataSet, this.options = options, this.isDataView = !0, this.target = new EventEmitter(), this.parseOption = null, this.transformsArr = [], this.isRunning = !1, this.rawData = {}, this.history = !1, this.parserData = {}, this.latestData = {}, this._fields = null, this.reRunAllTransform = (opt = {}) => {
	      const prevLatestData = this.latestData;
	      return this.isRunning = !0, this.resetTransformData(), this.transformsArr.forEach(t => {
	        this.executeTransform(t, {
	          pushHistory: opt.pushHistory,
	          emitMessage: !1
	        });
	      }), this.isRunning = !1, !1 === opt.emitMessage || opt.skipEqual && isEqual(prevLatestData, this.latestData) || this.target.emit("change", {
	        latestData: this.latestData
	      }), this;
	    }, this.markRunning = () => {
	      this.isRunning = !0, this.target.emit("markRunning", []);
	    }, name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataview"), this.name = name, (null == options ? void 0 : options.history) && (this.history = options.history, this.historyData = []), this.dataSet.setDataView(name, this), this.setFields(null == options ? void 0 : options.fields);
	  }
	  parse(data, options, emit = !1) {
	    var _a;
	    this.isRunning = !0, emit && this.target.emit("beforeParse", []), options && (this.parseOption = options);
	    const cloneData = this.cloneParseData(data, options);
	    if (null == options ? void 0 : options.type) {
	      const parserData = (null !== (_a = this.dataSet.getParser(options.type)) && void 0 !== _a ? _a : this.dataSet.getParser("bytejson"))(cloneData, options.options, this);
	      this.rawData = cloneData, this.parserData = parserData, this.history && this.historyData.push(cloneData, parserData), this.latestData = parserData;
	    } else this.parserData = cloneData, this.rawData = cloneData, this.history && this.historyData.push(cloneData), this.latestData = cloneData;
	    return this.isRunning = !1, emit && this.target.emit("afterParse", []), this;
	  }
	  transform(options, execute = !0) {
	    if (this.isRunning = !0, options && options.type) {
	      let pushOption = !0;
	      if ("fields" === options.type) {
	        this._fields = options.options.fields;
	        const index = this.transformsArr.findIndex(_op => _op.type === options.type);
	        index >= 0 && (pushOption = !1, this.transformsArr[index].options.fields = this._fields);
	      }
	      pushOption && this.transformsArr.push(options), execute && this.executeTransform(options);
	    }
	    return this.sortTransform(), this.isRunning = !1, this;
	  }
	  sortTransform() {
	    this.transformsArr.length >= 2 && this.transformsArr.sort((a, b) => {
	      var _a, _b;
	      return (null !== (_a = a.level) && void 0 !== _a ? _a : 0) - (null !== (_b = b.level) && void 0 !== _b ? _b : 0);
	    });
	  }
	  executeTransform(options, opt = {}) {
	    const {
	        pushHistory: pushHistory,
	        emitMessage: emitMessage,
	        skipEqual: skipEqual
	      } = opt,
	      transformFn = this.dataSet.getTransform(options.type),
	      prevLatestData = this.latestData,
	      transformData = transformFn(prevLatestData, options.options);
	    this.history && !1 !== pushHistory && this.historyData.push(transformData), this.latestData = transformData, !1 === emitMessage || skipEqual && isEqual(prevLatestData, this.latestData) || this.target.emit("change", {
	      latestData: this.latestData
	    });
	  }
	  resetTransformData() {
	    this.latestData = this.parserData, this.history && (this.historyData.length = 0, this.historyData.push(this.rawData, this.parserData));
	  }
	  cloneParseData(data, options) {
	    let clone = !1;
	    return data instanceof DataView || !0 !== (null == options ? void 0 : options.clone) || (clone = !0), clone ? cloneDeep(data) : data;
	  }
	  parseNewData(data, options) {
	    this.parse(data, options || this.parseOption), this.reRunAllTransform();
	  }
	  updateRawData(data, options) {
	    const cloneData = this.cloneParseData(data, options);
	    this.rawData = cloneData, this.parserData = cloneData, this.latestData = cloneData, this.reRunAllTransform();
	  }
	  getFields() {
	    var _a;
	    return this._fields ? this._fields : "dataview" === (null === (_a = this.parseOption) || void 0 === _a ? void 0 : _a.type) && 1 === this.rawData.length && this.rawData[0].getFields ? this.rawData[0].getFields() : null;
	  }
	  setFields(f, foreMerge = !1) {
	    this._fields = f && foreMerge ? merge({}, this._fields, f) : f;
	    const fieldsOption = this.transformsArr.find(_op => "fields" === _op.type);
	    !isNil$1(this._fields) && isNil$1(fieldsOption) ? (this.dataSet.registerTransform("fields", fields), this.transform({
	      type: "fields",
	      options: {
	        fields: this._fields
	      }
	    }, !1)) : fieldsOption && (fieldsOption.options.fields = this._fields);
	  }
	  destroy() {
	    this.dataSet.removeDataView(this.name), this.latestData = null, this.rawData = null, this.parserData = null, this.transformsArr = null, this.target = null;
	  }
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	function __rest$1(s, e) {
	  var t = {};
	  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
	  }
	  return t;
	}

	const DEFAULT_ARROW_MARK_STYLE = {
	    cornerRadius: 4,
	    stroke: 'black',
	    strokeOpacity: 1,
	    lineWidth: 1,
	    closePath: false,
	    pickable: false
	};
	const DEFAULT_ARROW_SYMBOL_MARK_STYLE = {
	    symbolType: 'triangle',
	    size: 8,
	    scaleX: 0.7,
	    fill: 'black'
	};
	const DEFAULT_ARROW_TEXT_MARK_STYLE = {
	    fill: '#606773',
	    fontSize: 12
	};
	const DEFAULT_FUNNEL_BACKGROUND_MARK_STYLE = {
	    fill: '#eff1f9'
	};

	class ConversionFunnelChartSpecTransformer extends vchart.FunnelChartSpecTransformer {
	    transformSpec(spec) {
	        const { conversionArrow, extensionMark = [], funnelBackground } = spec;
	        if (conversionArrow && conversionArrow.arrows && conversionArrow.arrows.length) {
	            const marks = addArrowMark(conversionArrow);
	            if (marks && marks.length) {
	                extensionMark.push(...marks);
	            }
	        }
	        if (funnelBackground && funnelBackground.visible) {
	            const mark = addFunnelBackgroundMark(funnelBackground);
	            if (mark) {
	                extensionMark.push(mark);
	            }
	        }
	        spec.extensionMark = extensionMark;
	        super.transformSpec(spec);
	    }
	    _getDefaultSeriesSpec(spec) {
	        const seriesSpec = super._getDefaultSeriesSpec(spec);
	        seriesSpec.conversionArrow = spec.conversionArrow;
	        seriesSpec.funnelBackground = spec.funnelBackground;
	        return seriesSpec;
	    }
	}
	function addArrowMark(arrowSpec) {
	    const { arrows } = arrowSpec, style = __rest$1(arrowSpec, ["arrows"]);
	    const leftArrows = arrows.filter(arrow => arrow.position === 'left');
	    const rightArrows = arrows.filter(arrow => arrow.position === 'right');
	    const rightGroup = computeArrows$1(rightArrows, style);
	    const leftGroup = computeArrows$1(leftArrows, style);
	    const result = [];
	    if (rightGroup) {
	        rightGroup.name = 'arrowRight';
	        result.push(rightGroup);
	    }
	    if (leftGroup) {
	        leftGroup.name = 'arrowLeft';
	        result.push(leftGroup);
	    }
	    return result;
	}
	function computeArrows$1(arrows, style) {
	    if ((arrows === null || arrows === void 0 ? void 0 : arrows.length) === 0) {
	        return null;
	    }
	    const { line, symbol, text, margin } = style;
	    const result = [];
	    const rootGroup = {
	        type: 'group',
	        zIndex: vchart.LayoutZIndex.Mark + 1,
	        children: []
	    };
	    const lineMark = generateArrowLineSpec(line, margin);
	    if (lineMark) {
	        result.push(lineMark);
	    }
	    const arrowMark = generateArrowSymbolSpec(symbol, margin);
	    if (arrowMark) {
	        result.push(arrowMark);
	    }
	    const textMark = generateArrowTextSpec(text, margin);
	    if (textMark) {
	        result.push(textMark);
	    }
	    rootGroup.children = result;
	    return rootGroup;
	}
	function generateArrowLineSpec(line = {}, margin) {
	    const { style = {} } = line, rest = __rest$1(line, ["style"]);
	    const renderable = (arrow, ctx) => {
	        var _a, _b;
	        const { from, to } = arrow;
	        const { vchart } = ctx;
	        const data = (_b = (_a = vchart === null || vchart === void 0 ? void 0 : vchart.getChart()) === null || _a === void 0 ? void 0 : _a.getSeriesData()) === null || _b === void 0 ? void 0 : _b.latestData;
	        if (to > data.length - 1 || from > data.length - 1) {
	            return false;
	        }
	        return true;
	    };
	    return Object.assign(Object.assign({ type: 'polygon', interactive: false }, rest), { dataKey: arrow => `${arrow.id}`, style: Object.assign(Object.assign(Object.assign({}, DEFAULT_ARROW_MARK_STYLE), style), { renderable, points: (arrow, ctx) => {
	                if (!renderable(arrow, ctx)) {
	                    return [];
	                }
	                let points = arrow.layout.points;
	                points = prepareArrowPoints(arrow, ctx, margin);
	                return points;
	            } }) });
	}
	function generateArrowSymbolSpec(symbol = {}, margin) {
	    const { style = {} } = symbol, rest = __rest$1(symbol, ["style"]);
	    return Object.assign(Object.assign({ type: 'symbol', interactive: false, dataKey: arrow => `${arrow.id}` }, rest), { style: Object.assign(Object.assign(Object.assign({}, DEFAULT_ARROW_SYMBOL_MARK_STYLE), style), { x: (arrow, ctx) => {
	                var _a, _b;
	                let points = arrow.layout.points;
	                points = prepareArrowPoints(arrow, ctx, margin);
	                return (_b = (_a = points[(points === null || points === void 0 ? void 0 : points.length) - 1]) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : NaN;
	            }, y: (arrow, ctx) => {
	                var _a, _b;
	                let points = arrow.layout.points;
	                points = prepareArrowPoints(arrow, ctx, margin);
	                return (_b = (_a = points[(points === null || points === void 0 ? void 0 : points.length) - 1]) === null || _a === void 0 ? void 0 : _a.y) !== null && _b !== void 0 ? _b : NaN;
	            }, angle: (arrow) => (arrow.position === 'left' ? 90 : -90) }) });
	}
	function generateArrowTextSpec(text = {}, margin) {
	    const { style = {}, formatMethod, textMargin = 4 } = text, rest = __rest$1(text, ["style", "formatMethod", "textMargin"]);
	    return Object.assign(Object.assign({ type: 'text', dataKey: arrow => `${arrow.id}`, interactive: false, animation: false }, rest), { style: Object.assign(Object.assign(Object.assign({}, DEFAULT_ARROW_TEXT_MARK_STYLE), { text: (arrow, ctx) => {
	                var _a, _b, _c, _d, _e, _f, _g;
	                const { text: textContent } = arrow;
	                let displayTextContent = textContent;
	                if (isFunction$1(formatMethod)) {
	                    const { vchart } = ctx;
	                    const { from, to } = arrow;
	                    const { field } = arrow.context;
	                    const rawData = (_c = (_b = (_a = vchart === null || vchart === void 0 ? void 0 : vchart.getChart()) === null || _a === void 0 ? void 0 : _a.getSeriesData()) === null || _b === void 0 ? void 0 : _b.latestData) !== null && _c !== void 0 ? _c : [];
	                    const viewData = (_g = (_f = (_e = (_d = vchart === null || vchart === void 0 ? void 0 : vchart.getChart()) === null || _d === void 0 ? void 0 : _d.getAllSeries()[0]) === null || _e === void 0 ? void 0 : _e.getViewData()) === null || _f === void 0 ? void 0 : _f.latestData) !== null && _g !== void 0 ? _g : [];
	                    const fromData = viewData.find((datum) => datum[field] === rawData[from][field]);
	                    const toData = viewData.find((datum) => datum[field] === rawData[to][field]);
	                    displayTextContent = formatMethod(textContent, { arrow, from: fromData, to: toData });
	                }
	                return displayTextContent;
	            }, x: (arrow, ctx) => {
	                var _a, _b;
	                let points = arrow.layout.points;
	                points = prepareArrowPoints(arrow, ctx, margin);
	                return (_b = ((_a = points[1]) === null || _a === void 0 ? void 0 : _a.x) + (arrow.position === 'left' ? -textMargin : textMargin)) !== null && _b !== void 0 ? _b : NaN;
	            }, y: (arrow, ctx) => {
	                var _a, _b, _c;
	                let points = arrow.layout.points;
	                points = prepareArrowPoints(arrow, ctx, margin);
	                return (_c = (((_a = points[1]) === null || _a === void 0 ? void 0 : _a.y) + ((_b = points[2]) === null || _b === void 0 ? void 0 : _b.y)) / 2) !== null && _c !== void 0 ? _c : NaN;
	            }, textAlign: (arrow) => (arrow.position === 'left' ? 'right' : 'left'), textBaseline: 'middle' }), style) });
	}
	function prepareArrowPoints(arrow, ctx, margin) {
	    var _a, _b, _c, _d, _e;
	    const { vchart } = ctx;
	    const { from, to } = arrow;
	    const { field } = arrow.context;
	    const rawData = (_b = (_a = vchart === null || vchart === void 0 ? void 0 : vchart.getChart()) === null || _a === void 0 ? void 0 : _a.getSeriesData()) === null || _b === void 0 ? void 0 : _b.latestData;
	    const viewData = (_e = (_d = (_c = vchart === null || vchart === void 0 ? void 0 : vchart.getChart()) === null || _c === void 0 ? void 0 : _c.getAllSeries()[0]) === null || _d === void 0 ? void 0 : _d.getViewData()) === null || _e === void 0 ? void 0 : _e.latestData;
	    let points = [];
	    if (rawData && rawData.length) {
	        const fromDatum = viewData.find((datum) => datum[field] === rawData[from][field]);
	        const toDatum = viewData.find((datum) => datum[field] === rawData[to][field]);
	        const firstDatum = viewData[0];
	        if (fromDatum && toDatum && firstDatum) {
	            const fromPoints = ctx.getPoints(fromDatum);
	            const toPoints = ctx.getPoints(toDatum);
	            const firstPoints = ctx.getPoints(firstDatum);
	            points = computeArrowPoints(arrow, fromPoints, toPoints, firstPoints, margin);
	            arrow.layout.points = points;
	        }
	    }
	    return points;
	}
	function computeArrowPoints(arrow, fromPoints, toPoints, firstPoints, margin = 12) {
	    const { layout, distance, position } = arrow;
	    const { level, fromIndex, toIndex, fromTotal, toTotal } = layout;
	    const isRight = position === 'right';
	    const fromTop = isRight ? fromPoints[1] : fromPoints[0];
	    const fromBottom = isRight ? fromPoints[2] : fromPoints[3];
	    const fromHeight = Math.abs(fromTop.y - fromBottom.y);
	    const toTop = isRight ? toPoints[1] : toPoints[0];
	    const toBottom = isRight ? toPoints[2] : toPoints[3];
	    const toHeight = Math.abs(toTop.y - toBottom.y);
	    const firstTop = isRight ? firstPoints[1] : firstPoints[0];
	    const fromOffset = fromHeight / (fromTotal + 1);
	    const toOffset = toHeight / (toTotal + 1);
	    const fromY = fromTop.y + fromOffset * (fromIndex + 1);
	    const toY = toTop.y + toOffset * (toIndex + 1);
	    const sign = isRight ? -1 : 1;
	    const points = [
	        { x: fromTop.x - margin * sign, y: fromY },
	        { x: firstTop.x - (margin + (level + 1) * distance) * sign, y: fromY },
	        {
	            x: firstTop.x - (margin + (level + 1) * distance) * sign,
	            y: toY
	        },
	        {
	            x: toTop.x - margin * sign,
	            y: toY
	        }
	    ];
	    return points;
	}
	function addFunnelBackgroundMark(funnelBackground) {
	    const { style = {} } = funnelBackground, rest = __rest$1(funnelBackground, ["style"]);
	    return Object.assign(Object.assign({ type: 'rect' }, rest), { dataIndex: 0, zIndex: 0, style: Object.assign(Object.assign(Object.assign({}, DEFAULT_FUNNEL_BACKGROUND_MARK_STYLE), style), { x: 0, y: (datum, ctx) => {
	                const points = ctx.getPoints(datum);
	                const tl = points[0];
	                return tl.y;
	            }, width: (datum, ctx) => {
	                const region = ctx.getRegion();
	                const { width } = region.getLayoutRect();
	                return width;
	            }, height: (datum, ctx) => {
	                const points = ctx.getPoints(datum);
	                const tl = points[0];
	                const bl = points[3];
	                return bl.y - tl.y;
	            } }) });
	}

	function isArrowCross(arrow1, arrow2) {
	    const { from: from1, to: to1 } = arrow1;
	    const { from: from2, to: to2 } = arrow2;
	    return to1 > from2 && to2 > from1;
	}
	function isSameArrow(arrow1, arrow2) {
	    const { from: from1, to: to1 } = arrow1;
	    const { from: from2, to: to2 } = arrow2;
	    return from1 === from2 && to1 === to2;
	}

	const conversionArrowTransform = (arrowSpec, options) => {
	    var _a, _b, _c;
	    if (!arrowSpec || !((_a = arrowSpec.arrows) === null || _a === void 0 ? void 0 : _a.length)) {
	        return [];
	    }
	    const { arrows } = arrowSpec;
	    const parsedArrows = parseArrow(arrows, options.categoryField);
	    const leftArrows = parsedArrows.filter(arrow => arrow.position === 'left');
	    const rightArrows = parsedArrows.filter(arrow => arrow.position === 'right');
	    const left = (_b = computeArrows(leftArrows)) !== null && _b !== void 0 ? _b : [];
	    const right = (_c = computeArrows(rightArrows)) !== null && _c !== void 0 ? _c : [];
	    return [...left, ...right];
	};
	function parseArrow(arrows, categoryField) {
	    return arrows
	        .filter(arrow => isValidNumber$1(arrow.from * arrow.to))
	        .map((arrow, index) => {
	        const { from, to, position = 'right' } = arrow;
	        return Object.assign(Object.assign({}, arrow), { position, distance: arrow.distance || 40, from: Math.min(from, to), to: Math.max(from, to), span: Math.abs(from - to), isLayout: false, context: {
	                field: categoryField
	            }, layout: {
	                level: 0
	            }, id: `${from}-${to}-${position}-${index}` });
	    });
	}
	function computeArrows(arrows) {
	    if ((arrows === null || arrows === void 0 ? void 0 : arrows.length) === 0) {
	        return null;
	    }
	    const nodeDegreeMap = new Map();
	    arrows.forEach(arrow => {
	        const fromNodeDegree = nodeDegreeMap.get(arrow.from);
	        if (isValid$1(fromNodeDegree)) {
	            const firstNodeWidthSameFromTo = fromNodeDegree.fromArrows.find(node => isSameArrow(node, arrow));
	            if (!firstNodeWidthSameFromTo) {
	                fromNodeDegree.degree += 1;
	            }
	            else {
	                arrow.layout.duplicateNode = firstNodeWidthSameFromTo;
	            }
	            fromNodeDegree.fromArrows.push(arrow);
	        }
	        else {
	            nodeDegreeMap.set(arrow.from, {
	                fromArrows: [arrow],
	                toArrows: [],
	                totalArrows: [],
	                degree: 1
	            });
	        }
	        const toNodeDegree = nodeDegreeMap.get(arrow.to);
	        if (isValid$1(toNodeDegree)) {
	            const firstNodeWidthSameFromTo = toNodeDegree.toArrows.find(node => isSameArrow(node, arrow));
	            if (!firstNodeWidthSameFromTo) {
	                toNodeDegree.degree += 1;
	            }
	            else {
	                arrow.layout.duplicateNode = firstNodeWidthSameFromTo;
	            }
	            toNodeDegree.toArrows.push(arrow);
	        }
	        else {
	            nodeDegreeMap.set(arrow.to, {
	                toArrows: [arrow],
	                fromArrows: [],
	                totalArrows: [],
	                degree: 1
	            });
	        }
	    });
	    nodeDegreeMap.forEach(node => {
	        node.fromArrows.sort((a, b) => b.span - a.span);
	        node.toArrows.sort((a, b) => a.span - b.span);
	        node.totalArrows = [...node.toArrows, ...node.fromArrows];
	    });
	    arrows
	        .sort((a, b) => a.span - b.span)
	        .forEach(arrow => {
	        var _a;
	        const arrowsIsLayout = arrows.filter(arrow => arrow.layout.isLayout);
	        const maxLevelArrow = maxInArray(arrowsIsLayout, (cur, curMax) => cur.layout.level - curMax.layout.level);
	        let level = (_a = maxLevelArrow === null || maxLevelArrow === void 0 ? void 0 : maxLevelArrow.layout.level) !== null && _a !== void 0 ? _a : 0;
	        while (level >= 0) {
	            if (arrowsIsLayout.some(arr => arr.layout.level === level && isArrowCross(arr, arrow))) {
	                level += 1;
	                break;
	            }
	            --level;
	        }
	        arrow.layout.level = Math.max(0, level);
	        arrow.layout.fromTotal = nodeDegreeMap.get(arrow.from).degree;
	        arrow.layout.toTotal = nodeDegreeMap.get(arrow.to).degree;
	        const duplicateNode = arrow.layout.duplicateNode;
	        if (duplicateNode) {
	            arrow.layout.fromIndex = duplicateNode.layout.fromIndex;
	            arrow.layout.toIndex = duplicateNode.layout.toIndex;
	        }
	        else {
	            arrow.layout.fromIndex = computeIndex(arrow, nodeDegreeMap.get(arrow.from).totalArrows);
	            arrow.layout.toIndex = computeIndex(arrow, nodeDegreeMap.get(arrow.to).totalArrows);
	        }
	        arrow.layout.isLayout = true;
	    });
	    return arrows;
	}
	function computeIndex(arrow, totalArrows) {
	    let index = 0;
	    let duplicateCount = 0;
	    for (let i = 0; i < totalArrows.length; i++) {
	        const curArrow = totalArrows[i];
	        if (curArrow === arrow) {
	            index = i - duplicateCount;
	            break;
	        }
	        if (curArrow.layout.duplicateNode) {
	            duplicateCount++;
	        }
	    }
	    return index;
	}

	class ConversionFunnelChart extends vchart.FunnelChart {
	    constructor() {
	        super(...arguments);
	        this.type = 'conversionFunnel';
	        this.transformerConstructor = ConversionFunnelChartSpecTransformer;
	    }
	}
	ConversionFunnelChart.type = 'conversionFunnel';
	ConversionFunnelChart.transformerConstructor = ConversionFunnelChartSpecTransformer;
	class ConversionFunnelSeries extends vchart.FunnelSeries {
	    initData() {
	        var _a;
	        super.initData();
	        const { conversionArrow } = this._spec;
	        if (conversionArrow && ((_a = conversionArrow.arrows) === null || _a === void 0 ? void 0 : _a.length)) {
	            this._arrowData = new DataView(this._dataSet, { name: `${vchart.PREFIX}_series_${this.id}_arrowData` });
	            if (!this._dataSet.getTransform('conversionArrow')) {
	                this._dataSet.registerTransform('conversionArrow', conversionArrowTransform);
	            }
	            this._arrowData.parse(conversionArrow).transform({
	                type: 'conversionArrow',
	                options: {
	                    categoryField: this._spec.categoryField
	                }
	            });
	        }
	    }
	    afterCompile() {
	        var _a;
	        (_a = super.afterCompile) === null || _a === void 0 ? void 0 : _a.call(this);
	        const rightGroup = this.getMarkInName('arrowRight');
	        if (rightGroup) {
	            rightGroup.getMarks().forEach(mark => {
	                mark.setDataView(this._arrowData);
	                mark.compileData();
	                mark.setTransform([
	                    {
	                        type: 'filter',
	                        callback: (datum) => datum.position === 'right'
	                    }
	                ]);
	            });
	        }
	        const leftGroup = this.getMarkInName('arrowLeft');
	        if (leftGroup) {
	            leftGroup.getMarks().forEach(mark => {
	                mark.setDataView(this._arrowData);
	                mark.compileData();
	                mark.setTransform([
	                    {
	                        type: 'filter',
	                        callback: (datum) => datum.position === 'left'
	                    }
	                ]);
	            });
	        }
	    }
	}
	const registerConversionFunnelChart = (option) => {
	    vchart.registerMarkFilterTransform();
	    const vchartConstructor = (option === null || option === void 0 ? void 0 : option.VChart) || vchart.VChart;
	    if (vchartConstructor) {
	        vchartConstructor.useChart([ConversionFunnelChart]);
	        vchartConstructor.useSeries([ConversionFunnelSeries]);
	    }
	};

	const DATA_KEY$2 = 'dataKey';
	class SequenceScatterLinkChartSpecTransformer extends vchart.CommonChartSpecTransformer {
	    transformSpec(spec) {
	        var _a, _b, _c, _d, _e;
	        super.transformSpec(spec);
	        const dataSpecs = processSequenceData$2(spec);
	        const showTooltip = spec.taskType === 'neighborhood' ? false : true;
	        spec.type = 'common';
	        spec.dataKey = DATA_KEY$2;
	        spec.data = dataSpecs[0].data;
	        spec.series = [
	            {
	                id: 'background-series',
	                type: 'area',
	                dataId: 'background',
	                interactive: false,
	                persent: true,
	                xField: 'x',
	                yField: 'y',
	                point: {
	                    visible: false
	                },
	                line: {
	                    visible: false
	                },
	                area: {
	                    visible: true,
	                    interactive: false,
	                    style: {
	                        background: (datum) => {
	                            if (spec.taskType === 'neighborhood') {
	                                return '';
	                            }
	                            return `https://lf9-dp-fe-cms-tos.byteorg.com/obj/bit-cloud/sequence-scatter-bgimg-2/${datum.iter}.png`;
	                        },
	                        fill: 'transparent',
	                        fillOpacity: 0.5
	                    }
	                },
	                hover: {
	                    enable: false
	                },
	                select: {
	                    enable: false
	                }
	            },
	            {
	                id: 'line-series',
	                type: 'line',
	                dataId: 'endpoints',
	                xField: 'x',
	                yField: 'y',
	                seriesField: 'edgeId',
	                animation: true,
	                point: {
	                    visible: false
	                },
	                line: {
	                    visible: true,
	                    style: {
	                        stroke: (datum) => {
	                            return datum.color;
	                        },
	                        lineDash: (datum) => {
	                            if (datum.type === 'same_type') {
	                                return [0, 0];
	                            }
	                            else {
	                                return [3, 2];
	                            }
	                        },
	                        lineWidth: 0.8,
	                        strokeOpacity: 0.6
	                    }
	                }
	            },
	            {
	                id: 'scatter-series',
	                type: 'scatter',
	                dataId: 'nodes',
	                xField: spec.xField,
	                yField: spec.yField,
	                seriesField: 'label',
	                point: {
	                    state: {
	                        hover: {
	                            scaleX: 1.5,
	                            scaleY: 1.5,
	                            fillOpacity: 1
	                        },
	                        hover_reverse: {
	                            scaleX: 1,
	                            scaleY: 1,
	                            fillOpacity: 0.3
	                        }
	                    },
	                    style: {
	                        size: () => {
	                            return spec.taskType === 'neighborhood' ? 6 : 4;
	                        },
	                        fill: (datum) => {
	                            var _a;
	                            const color = (_a = spec.labelColor[datum.label]) !== null && _a !== void 0 ? _a : 'gray';
	                            return color;
	                        },
	                        fillOpacity: (datum) => {
	                            return datum.confidence;
	                        }
	                    }
	                },
	                label: {
	                    visible: true,
	                    style: {
	                        visible: () => {
	                            return spec.taskType == 'neighborhood';
	                        },
	                        type: 'text',
	                        fontFamily: 'Console',
	                        fontStyle: 'italic',
	                        fontSize: 12,
	                        fill: 'black',
	                        fillOpacity: 0.6,
	                        text: (datum) => {
	                            return datum.id;
	                        }
	                    }
	                }
	            }
	        ];
	        if (spec.player) {
	            spec.player = Object.assign(Object.assign({}, spec.player), { specs: dataSpecs });
	            spec.animationAppear = {
	                duration: (_b = (_a = spec.player) === null || _a === void 0 ? void 0 : _a.duration) !== null && _b !== void 0 ? _b : 2000,
	                easing: 'linear'
	            };
	            spec.animationUpdate = {
	                duration: (_d = (_c = spec.player) === null || _c === void 0 ? void 0 : _c.duration) !== null && _d !== void 0 ? _d : 2000,
	                easing: 'linear'
	            };
	        }
	        spec.axes = [
	            {
	                orient: 'left',
	                type: 'linear',
	                inverse: true,
	                min: spec.scope[1],
	                max: spec.scope[3]
	            },
	            {
	                orient: 'bottom',
	                type: 'linear',
	                min: spec.scope[0],
	                max: spec.scope[2]
	            }
	        ];
	        spec.customMark = [
	            {
	                type: 'text',
	                dataId: 'iter',
	                style: Object.assign({ x: 50, y: () => 10, textBaseline: 'top', textAlign: 'left', fontSize: 100, fontWeight: 'bolder', fill: 'black', fillOpacity: 0.2 }, (_e = spec.infoLabel) === null || _e === void 0 ? void 0 : _e.style)
	            }
	        ];
	        (spec.legends = [
	            {
	                seriesId: 'scatter-series',
	                visible: true,
	                orient: 'right',
	                position: 'middle',
	                data: (items) => {
	                    return items.map(item => {
	                        item.shape.outerBorder = {
	                            stroke: item.shape.fill,
	                            distance: 2,
	                            lineWidth: 1
	                        };
	                        return item;
	                    });
	                },
	                title: {
	                    visible: true,
	                    align: 'left',
	                    textStyle: {
	                        text: 'Classes',
	                        fontFamily: 'Console',
	                        fontSize: 18,
	                        fontWeight: 'bold'
	                    }
	                },
	                item: {
	                    visible: true,
	                    width: '8%',
	                    value: {
	                        alignRight: true,
	                        style: {
	                            fill: '#000',
	                            fillOpacity: 1,
	                            fontSize: 12
	                        },
	                        state: {
	                            unselected: {
	                                fill: '#d8d8d8'
	                            }
	                        }
	                    }
	                }
	            }
	        ]),
	            (spec.tooltip = {
	                visible: showTooltip,
	                seriesId: 'scatter-series',
	                lockAfterClick: false,
	                activeType: 'mark',
	                trigger: 'hover',
	                mark: {
	                    title: {
	                        visible: true,
	                        value: 'Info'
	                    },
	                    content: [
	                        {
	                            key: 'Label',
	                            value: (datum) => {
	                                return datum.label;
	                            },
	                            shapeType: 'circle',
	                            shapeSize: 8
	                        },
	                        {
	                            key: 'Prediction',
	                            value: (datum) => {
	                                return datum.prediction;
	                            },
	                            shapeType: 'circle',
	                            shapeSize: 8,
	                            shapeFill: (datum) => {
	                                var _a;
	                                const color = (_a = spec.labelColor[datum.prediction]) !== null && _a !== void 0 ? _a : 'gray';
	                                return color;
	                            }
	                        },
	                        {
	                            key: 'Confidence',
	                            value: (datum) => {
	                                return datum.confidence.toFixed(2);
	                            },
	                            shapeType: 'square',
	                            shapeSize: 8,
	                            shapeFill: (datum) => {
	                                return datum.label === datum.prediction ? 'green' : 'red';
	                            }
	                        }
	                    ]
	                },
	                style: {
	                    panel: {
	                        padding: { top: 10, bottom: 15, left: 10, right: 10 },
	                        backgroundColor: '#fff',
	                        border: {
	                            color: '#eee',
	                            width: 1,
	                            radius: 10
	                        }
	                    },
	                    titleLabel: {
	                        fontSize: 20,
	                        fontFamily: 'Times New Roman',
	                        fill: 'brown',
	                        fontWeight: 'bold',
	                        textAlign: 'center',
	                        lineHeight: 24
	                    },
	                    keyLabel: {
	                        fontSize: 16,
	                        fontFamily: 'Times New Roman',
	                        fill: 'black',
	                        textAlign: 'center',
	                        lineHeight: 15,
	                        spacing: 10
	                    },
	                    valueLabel: {
	                        fontSize: 14,
	                        fill: 'black',
	                        textAlign: 'center',
	                        lineHeight: 15,
	                        spacing: 10
	                    }
	                }
	            });
	        spec.dataZoom = [
	            {
	                visible: false,
	                orient: 'left',
	                filterMode: 'axis',
	                showDetail: false,
	                roamZoom: {
	                    enable: true,
	                    focus: true,
	                    rate: 3
	                },
	                roamDrag: {
	                    enable: true,
	                    reverse: true,
	                    rate: 1
	                }
	            },
	            {
	                visible: false,
	                orient: 'bottom',
	                filterMode: 'axis',
	                showDetail: false,
	                roamZoom: {
	                    enable: true,
	                    focus: true,
	                    rate: 3
	                },
	                roamDrag: {
	                    enable: true,
	                    reverse: true,
	                    rate: 1
	                }
	            }
	        ];
	        super.transformSpec(spec);
	    }
	}
	function processSequenceData$2(spec) {
	    const result = [];
	    Object.keys(spec.data).forEach(iter => {
	        const nodes = spec.data[iter].nodes;
	        result.push({
	            data: [
	                {
	                    id: 'nodes',
	                    values: nodes.map((d, i) => {
	                        return Object.assign(Object.assign({}, d), { [DATA_KEY$2]: i });
	                    })
	                },
	                {
	                    id: 'endpoints',
	                    values: []
	                },
	                {
	                    id: 'iter',
	                    values: [
	                        {
	                            iter
	                        }
	                    ]
	                },
	                {
	                    id: 'background',
	                    values: [
	                        { iter: iter, x: spec.scope[0], y: spec.scope[1] },
	                        { iter: iter, x: spec.scope[0], y: spec.scope[3] },
	                        { iter: iter, x: spec.scope[2], y: spec.scope[3] },
	                        { iter: iter, x: spec.scope[2], y: spec.scope[1] },
	                        { iter: iter, x: spec.scope[0], y: spec.scope[1] }
	                    ]
	                }
	            ]
	        });
	    });
	    return result;
	}

	class SequenceScatterLink extends vchart.BaseChart {
	    constructor() {
	        super(...arguments);
	        this.type = 'sequenceScatterLink';
	        this.transformerConstructor = SequenceScatterLinkChartSpecTransformer;
	    }
	    init() {
	        if (!this.isValid()) {
	            return;
	        }
	        super.init();
	    }
	    isValid() {
	        var _a, _b, _c, _d;
	        const { xField, yField, data } = this._spec;
	        if (!xField || !yField) {
	            (_b = (_a = this._option).onError) === null || _b === void 0 ? void 0 : _b.call(_a, 'Missing Required Config: `xField`, `yField` ');
	            return false;
	        }
	        if (!data) {
	            (_d = (_c = this._option).onError) === null || _d === void 0 ? void 0 : _d.call(_c, 'Data is required');
	            return false;
	        }
	        return true;
	    }
	}
	SequenceScatterLink.type = 'sequenceScatterLink';
	SequenceScatterLink.view = 'singleDefault';
	SequenceScatterLink.transformerConstructor = SequenceScatterLinkChartSpecTransformer;
	const registerSequenceScatterLink = (option) => {
	    const vchartConstructor = (option === null || option === void 0 ? void 0 : option.VChart) || vchart.VChart;
	    if (vchartConstructor) {
	        vchartConstructor.useChart([SequenceScatterLink, vchart.ScatterChart]);
	    }
	};

	const EXPAND_RATIO = 0.2;

	function gaussKernel(x) {
	    const SQRT2PI2 = Math.sqrt((Math.PI * 2) ** 2);
	    return Math.exp(-(x ** 2) / 2) / SQRT2PI2;
	}
	function scottBandwidth(data) {
	    return data.length ** (-1 / 6);
	}
	function calculateKDE(data, bins = 100, bandwidth) {
	    const groupedData = data.reduce((groups, point) => {
	        const label = point.label;
	        groups[label] = groups[label] || [];
	        groups[label].push(point);
	        return groups;
	    }, {});
	    const kdeResult = [];
	    Object.entries(groupedData).forEach(([label, points]) => {
	        const h = bandwidth || scottBandwidth(points);
	        const xValues = points.map(d => d.x);
	        const yValues = points.map(d => d.y);
	        const xMin = Math.min(...xValues);
	        const xMax = Math.max(...xValues);
	        const yMin = Math.min(...yValues);
	        const yMax = Math.max(...yValues);
	        const xExpand = (xMax - xMin) * EXPAND_RATIO;
	        const yExpand = (yMax - yMin) * EXPAND_RATIO;
	        const xExtent = { min: xMin - xExpand, max: xMax + xExpand };
	        const yExtent = { min: yMin - yExpand, max: yMax + yExpand };
	        const xStep = 0.1;
	        const yStep = 0.1;
	        for (let i = 0; i < bins; i++) {
	            for (let j = 0; j < bins; j++) {
	                const x = xExtent.min + i * xStep;
	                const y = yExtent.min + j * yStep;
	                let density = 0;
	                for (const point of points) {
	                    const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
	                    density += gaussKernel(distance / h);
	                }
	                density = density / (points.length * h * h);
	                kdeResult.push({ x, y, kde: density, label });
	            }
	        }
	    });
	    return kdeResult;
	}

	const DATA_KEY$1 = 'dataKey';
	class SequenceScatterKDEChartSpecTransformer extends vchart.CommonChartSpecTransformer {
	    transformSpec(spec) {
	        var _a, _b, _c, _d, _e, _f;
	        super.transformSpec(spec);
	        const dataSpecs = processSequenceData$1(spec);
	        spec.type = 'common';
	        spec.dataKey = DATA_KEY$1;
	        spec.data = dataSpecs[0].data;
	        spec.scales = [
	            {
	                id: 'colorScale',
	                type: 'ordinal',
	                specified: {
	                    '0': 'rgb(150, 10, 100)',
	                    '1': 'rgb(31, 119, 180)',
	                    '2': 'rgb(255, 127, 14)',
	                    '3': 'rgb(44, 160, 44)',
	                    '4': 'rgb(214, 39, 40)',
	                    '5': 'rgb(148, 103, 189)',
	                    '6': 'rgb(140, 86, 75)',
	                    '7': 'rgb(227, 119, 194)',
	                    '8': 'rgb(127, 127, 127)',
	                    '9': 'rgb(188, 189, 34)',
	                    '10': 'rgb(23, 190, 207)'
	                }
	            },
	            {
	                id: 'brighterColorScale',
	                type: 'ordinal',
	                specified: {
	                    '0': 'rgb(150, 10, 150)',
	                    '1': 'rgb(31, 119, 230)',
	                    '2': 'rgb(255, 127, 64)',
	                    '3': 'rgb(44, 160, 94)',
	                    '4': 'rgb(214, 39, 90)',
	                    '5': 'rgb(148, 103, 239)',
	                    '6': 'rgb(140, 86, 125)',
	                    '7': 'rgb(227, 119, 244)',
	                    '8': 'rgb(127, 127, 177)',
	                    '9': 'rgb(188, 189, 84)',
	                    '10': 'rgb(23, 190, 255)'
	                }
	            },
	            ...((_a = spec.scales) !== null && _a !== void 0 ? _a : [])
	        ];
	        spec.series = [
	            {
	                type: 'scatter',
	                dataIndex: 0,
	                xField: spec.xField,
	                yField: spec.yField,
	                seriesField: spec.seriesField,
	                size: 5,
	                point: {
	                    zIndex: 1000,
	                    style: {
	                        fill: {
	                            scale: 'colorScale',
	                            field: spec.seriesField
	                        }
	                    }
	                }
	            }
	        ];
	        const regionX = 54;
	        const regionY = 26;
	        spec.customMark = [
	            {
	                type: 'text',
	                dataIndex: 1,
	                style: Object.assign({ text: (datum) => datum['iter'], x: 10, y: () => 10, textBaseline: 'top', textAlign: 'left', fontSize: 25, fontWeight: 'bolder', fill: 'black', fillOpacity: 0.2 }, (_b = spec.infoLabel) === null || _b === void 0 ? void 0 : _b.style)
	            },
	            {
	                type: 'symbol',
	                dataIndex: 2,
	                style: {
	                    symbolType: 'rect',
	                    x: (datum, ctx) => {
	                        const valueToX = ctx.chart.getAllSeries()[0]._markAttributeContext.valueToX;
	                        const markX = valueToX([datum.x]);
	                        return regionX + markX;
	                    },
	                    y: (datum, ctx) => {
	                        const valueToY = ctx.chart.getAllSeries()[0]._markAttributeContext.valueToY;
	                        const markY = valueToY([datum.y]);
	                        return markY + regionY;
	                    },
	                    size: 5,
	                    fill: {
	                        scale: 'brighterColorScale',
	                        field: 'label'
	                    },
	                    fillOpacity: (datum) => datum.kde * 10
	                }
	            }
	        ];
	        spec.tooltip = {
	            visible: true,
	            fields: ['x', 'y', 'label']
	        };
	        if (spec.player) {
	            spec.player = Object.assign(Object.assign({}, spec.player), { specs: dataSpecs });
	            spec.animationAppear = {
	                duration: (_d = (_c = spec.player) === null || _c === void 0 ? void 0 : _c.duration) !== null && _d !== void 0 ? _d : 2000,
	                easing: 'linear'
	            };
	            spec.animationUpdate = {
	                duration: (_f = (_e = spec.player) === null || _e === void 0 ? void 0 : _e.duration) !== null && _f !== void 0 ? _f : 2000,
	                easing: 'linear'
	            };
	        }
	        spec.axes = [
	            {
	                orient: 'left',
	                type: 'linear',
	                nice: true
	            },
	            {
	                orient: 'bottom',
	                type: 'linear',
	                nice: true,
	                label: { visible: true }
	            }
	        ];
	        super.transformSpec(spec);
	    }
	}
	function processSequenceData$1(spec) {
	    const result = [];
	    Object.keys(spec.data).forEach(iter => {
	        const currentData = spec.data[iter].map((d, i) => (Object.assign(Object.assign({}, d), { [DATA_KEY$1]: i })));
	        const kdeResults = calculateKDE(currentData, 150);
	        result.push({
	            data: [
	                {
	                    id: 'nodes',
	                    values: currentData
	                },
	                {
	                    id: 'iter',
	                    values: [{ iter }]
	                },
	                {
	                    id: 'kde',
	                    values: kdeResults
	                }
	            ]
	        });
	    });
	    return result;
	}

	class SequenceScatterKDE extends vchart.BaseChart {
	    constructor() {
	        super(...arguments);
	        this.type = 'sequenceScatterKDE';
	        this.transformerConstructor = SequenceScatterKDEChartSpecTransformer;
	    }
	    init() {
	        if (!this.isValid()) {
	            return;
	        }
	        super.init();
	    }
	    isValid() {
	        var _a, _b, _c, _d;
	        const { xField, yField, data } = this._spec;
	        if (!xField || !yField) {
	            (_b = (_a = this._option).onError) === null || _b === void 0 ? void 0 : _b.call(_a, 'Missing Required Config: `xField`, `yField` ');
	            return false;
	        }
	        if (!data) {
	            (_d = (_c = this._option).onError) === null || _d === void 0 ? void 0 : _d.call(_c, 'Data is required');
	            return false;
	        }
	        return true;
	    }
	}
	SequenceScatterKDE.type = 'sequenceScatterKDE';
	SequenceScatterKDE.view = 'singleDefault';
	SequenceScatterKDE.transformerConstructor = SequenceScatterKDEChartSpecTransformer;
	const registerSequenceScatterKDE = (option) => {
	    const vchartConstructor = (option === null || option === void 0 ? void 0 : option.VChart) || vchart.VChart;
	    if (vchartConstructor) {
	        vchartConstructor.useChart([SequenceScatterKDE, vchart.ScatterChart]);
	    }
	};

	const DATA_KEY = 'dataKey';
	const BACKGROUND_KEY = 'background';

	function createImageDataFromColorMatrix(colorMatrix, spec) {
	    var _a;
	    if (typeof document === 'undefined') {
	        throw new Error('Canvas rendering requires browser environment with document object');
	    }
	    const canvas = document.createElement('canvas');
	    canvas.width = spec.width;
	    canvas.height = spec.height;
	    const ctx = canvas.getContext('2d');
	    if (!ctx) {
	        throw new Error('Failed to get 2D rendering context from canvas');
	    }
	    const imageData = ctx.createImageData(spec.width, spec.height);
	    for (let y = 0; y < 300; y++) {
	        for (let x = 0; x < 300; x++) {
	            const rgb = ((_a = colorMatrix[y]) === null || _a === void 0 ? void 0 : _a[x]) || [0, 0, 0];
	            const pixelIndex = (y * 300 + x) * 4;
	            imageData.data[pixelIndex] = Math.round(rgb[0] * 255);
	            imageData.data[pixelIndex + 1] = Math.round(rgb[1] * 255);
	            imageData.data[pixelIndex + 2] = Math.round(rgb[2] * 255);
	            imageData.data[pixelIndex + 3] = 255;
	        }
	    }
	    ctx.putImageData(imageData, 0, 0);
	    return canvas.toDataURL('image/png');
	}
	function processSequenceData(spec) {
	    const result = [];
	    Object.keys(spec.data).forEach(inter => {
	        let backgroundData = null;
	        if (spec.backgroundColors && spec.backgroundColors[inter]) {
	            const imageData = createImageDataFromColorMatrix(spec.backgroundColors[inter], spec);
	            backgroundData = { imageData };
	        }
	        result.push({
	            data: [
	                {
	                    id: 'nodes',
	                    values: spec.data[inter].map((d, i) => {
	                        return Object.assign(Object.assign({}, d), { [DATA_KEY]: i });
	                    })
	                },
	                {
	                    id: 'inter',
	                    values: [
	                        {
	                            inter
	                        }
	                    ]
	                },
	                {
	                    id: BACKGROUND_KEY,
	                    values: backgroundData ? [backgroundData] : []
	                }
	            ]
	        });
	    });
	    return result;
	}

	class SequenceScatterPixelChartSpecTransformer extends vchart.CommonChartSpecTransformer {
	    transformSpec(spec) {
	        var _a, _b, _c, _d, _e;
	        super.transformSpec(spec);
	        const dataSpecs = processSequenceData(spec);
	        spec.type = 'common';
	        spec.dataKey = DATA_KEY;
	        spec.data = dataSpecs[0].data;
	        spec.width = 300;
	        spec.height = 300;
	        spec.autoFit = false;
	        spec.series = [
	            {
	                type: 'scatter',
	                xField: spec.xField,
	                yField: spec.yField
	            }
	        ];
	        if (spec.player) {
	            spec.player = Object.assign(Object.assign({}, spec.player), { specs: dataSpecs });
	            spec.animationAppear = {
	                duration: (_b = (_a = spec.player) === null || _a === void 0 ? void 0 : _a.duration) !== null && _b !== void 0 ? _b : 2000,
	                easing: 'linear'
	            };
	            spec.animationUpdate = {
	                duration: (_d = (_c = spec.player) === null || _c === void 0 ? void 0 : _c.duration) !== null && _d !== void 0 ? _d : 2000,
	                easing: 'linear'
	            };
	        }
	        spec.axes = [
	            {
	                orient: 'left',
	                type: 'linear'
	            },
	            {
	                orient: 'bottom',
	                label: { visible: true },
	                type: 'linear'
	            }
	        ];
	        spec.customMark = [
	            {
	                type: 'image',
	                dataIndex: 2,
	                style: {
	                    x: 0,
	                    y: 0,
	                    width: 300,
	                    height: 300,
	                    image: (datum) => datum.imageData,
	                    zIndex: -1
	                }
	            },
	            {
	                type: 'text',
	                dataIndex: 1,
	                style: Object.assign({ text: (datum) => datum['inter'], x: 50, y: () => 10, textBaseline: 'top', textAlign: 'left', fontSize: 100, fontWeight: 'bolder', fill: 'black', fillOpacity: 0.2 }, (_e = spec.infoLabel) === null || _e === void 0 ? void 0 : _e.style)
	            }
	        ];
	        spec.tooltip = {
	            visible: false
	        };
	        super.transformSpec(spec);
	    }
	}

	class SequenceScatterPixel extends vchart.BaseChart {
	    constructor() {
	        super(...arguments);
	        this.type = 'sequenceScatterPixel';
	        this.transformerConstructor = SequenceScatterPixelChartSpecTransformer;
	    }
	    init() {
	        if (!this.isValid()) {
	            return;
	        }
	        super.init();
	    }
	    isValid() {
	        var _a, _b, _c, _d;
	        const { xField, yField, data } = this._spec;
	        if (!xField || !yField) {
	            (_b = (_a = this._option).onError) === null || _b === void 0 ? void 0 : _b.call(_a, 'Missing Required Config: `xField`, `yField` ');
	            return false;
	        }
	        if (!data) {
	            (_d = (_c = this._option).onError) === null || _d === void 0 ? void 0 : _d.call(_c, 'Data is required');
	            return false;
	        }
	        return true;
	    }
	}
	SequenceScatterPixel.type = 'sequenceScatterPixel';
	SequenceScatterPixel.view = 'singleDefault';
	SequenceScatterPixel.transformerConstructor = SequenceScatterPixelChartSpecTransformer;
	const registerSequenceScatterPixel = (option) => {
	    const vchartConstructor = (option === null || option === void 0 ? void 0 : option.VChart) || vchart.VChart;
	    if (vchartConstructor) {
	        vchartConstructor.useChart([SequenceScatterPixel, vchart.ScatterChart]);
	    }
	};

	class Bar3dChartSpecTransformer extends vchart.BarChartSpecTransformer {
	    _getDefaultSeriesSpec(spec) {
	        const seriesSpec = super._getDefaultSeriesSpec(spec);
	        seriesSpec.barWidth = spec.barWidth;
	        seriesSpec.barMaxWidth = spec.barMaxWidth;
	        seriesSpec.barMinWidth = spec.barMinWidth;
	        seriesSpec.barGapInGroup = spec.barGapInGroup;
	        return seriesSpec;
	    }
	}

	var ChartType3dEnum;
	(function (ChartType3dEnum) {
	    ChartType3dEnum["bar3d"] = "bar3d";
	    ChartType3dEnum["histogram3d"] = "histogram3d";
	    ChartType3dEnum["rangeColumn3d"] = "rangeColumn3d";
	    ChartType3dEnum["pie3d"] = "pie3d";
	    ChartType3dEnum["wordCloud3d"] = "wordCloud3d";
	    ChartType3dEnum["funnel3d"] = "funnel3d";
	})(ChartType3dEnum || (ChartType3dEnum = {}));
	var MarkType3dEnum;
	(function (MarkType3dEnum) {
	    MarkType3dEnum["rect3d"] = "rect3d";
	    MarkType3dEnum["arc3d"] = "arc3d";
	    MarkType3dEnum["pyramid3d"] = "pyramid3d";
	})(MarkType3dEnum || (MarkType3dEnum = {}));
	var SeriesType3dEnum;
	(function (SeriesType3dEnum) {
	    SeriesType3dEnum["bar3d"] = "bar3d";
	    SeriesType3dEnum["rangeColumn3d"] = "rangeColumn3d";
	    SeriesType3dEnum["pie3d"] = "pie3d";
	    SeriesType3dEnum["wordCloud3d"] = "wordCloud3d";
	    SeriesType3dEnum["funnel3d"] = "funnel3d";
	})(SeriesType3dEnum || (SeriesType3dEnum = {}));
	var SeriesMark3dNameEnum;
	(function (SeriesMark3dNameEnum) {
	    SeriesMark3dNameEnum["bar3d"] = "bar3d";
	    SeriesMark3dNameEnum["funnel3d"] = "funnel3d";
	    SeriesMark3dNameEnum["transform3d"] = "transform3d";
	    SeriesMark3dNameEnum["pie3d"] = "pie3d";
	})(SeriesMark3dNameEnum || (SeriesMark3dNameEnum = {}));
	var SeriesType3dForThemeEnum;
	(function (SeriesType3dForThemeEnum) {
	    SeriesType3dForThemeEnum["bar3d_horizontal"] = "bar3d_horizontal";
	    SeriesType3dForThemeEnum["bar3d_vertical"] = "bar3d_vertical";
	    SeriesType3dForThemeEnum["bar3d_stack"] = "bar3d_stack";
	    SeriesType3dForThemeEnum["rangeColumn3d_horizontal"] = "rangeColumn3d_horizontal";
	    SeriesType3dForThemeEnum["rangeColumn3d_vertical"] = "rangeColumn3d_vertical";
	})(SeriesType3dForThemeEnum || (SeriesType3dForThemeEnum = {}));

	class Generator {
	  static GenAutoIncrementId() {
	    return Generator.auto_increment_id++;
	  }
	}
	Generator.auto_increment_id = 0;

	class ContainerModule {
	  constructor(registry) {
	    this.id = Generator.GenAutoIncrementId(), this.registry = registry;
	  }
	}

	const NAMED_TAG = "named";
	const INJECT_TAG = "inject";
	const MULTI_INJECT_TAG = "multi_inject";
	const TAGGED = "inversify:tagged";
	const PARAM_TYPES = "inversify:paramtypes";

	class Metadata {
	  constructor(key, value) {
	    this.key = key, this.value = value;
	  }
	  toString() {
	    return this.key === NAMED_TAG ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
	  }
	}

	var Reflect$1 = (function (Reflect) {
	  var target;
	  return function (exporter) {
	    const supportsSymbol = "function" == typeof Symbol,
	      toPrimitiveSymbol = supportsSymbol && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive",
	      functionPrototype = (Object.getPrototypeOf(Function)),
	      _Map = ("object" == typeof process && process.env && process.env.REFLECT_METADATA_USE_MAP_POLYFILL, Map),
	      Metadata = (new WeakMap());
	    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
	      if (!IsObject(target)) throw new TypeError();
	      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
	    }
	    function hasMetadata(metadataKey, target, propertyKey) {
	      if (!IsObject(target)) throw new TypeError();
	      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasMetadata(metadataKey, target, propertyKey);
	    }
	    function hasOwnMetadata(metadataKey, target, propertyKey) {
	      if (!IsObject(target)) throw new TypeError();
	      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
	    }
	    function getMetadata(metadataKey, target, propertyKey) {
	      if (!IsObject(target)) throw new TypeError();
	      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetMetadata(metadataKey, target, propertyKey);
	    }
	    function GetOrCreateMetadataMap(O, P, Create) {
	      let targetMetadata = Metadata.get(O);
	      if (IsUndefined(targetMetadata)) {
	        if (!Create) return;
	        targetMetadata = new _Map(), Metadata.set(O, targetMetadata);
	      }
	      let metadataMap = targetMetadata.get(P);
	      if (IsUndefined(metadataMap)) {
	        if (!Create) return;
	        metadataMap = new _Map(), targetMetadata.set(P, metadataMap);
	      }
	      return metadataMap;
	    }
	    function OrdinaryHasMetadata(MetadataKey, O, P) {
	      if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return !0;
	      const parent = OrdinaryGetPrototypeOf(O);
	      return !IsNull(parent) && OrdinaryHasMetadata(MetadataKey, parent, P);
	    }
	    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
	      const metadataMap = GetOrCreateMetadataMap(O, P, !1);
	      return !IsUndefined(metadataMap) && ToBoolean(metadataMap.has(MetadataKey));
	    }
	    function OrdinaryGetMetadata(MetadataKey, O, P) {
	      if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
	      const parent = OrdinaryGetPrototypeOf(O);
	      return IsNull(parent) ? void 0 : OrdinaryGetMetadata(MetadataKey, parent, P);
	    }
	    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
	      const metadataMap = GetOrCreateMetadataMap(O, P, !1);
	      if (!IsUndefined(metadataMap)) return metadataMap.get(MetadataKey);
	    }
	    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
	      GetOrCreateMetadataMap(O, P, !0).set(MetadataKey, MetadataValue);
	    }
	    function Type(x) {
	      if (null === x) return 1;
	      switch (typeof x) {
	        case "undefined":
	          return 0;
	        case "boolean":
	          return 2;
	        case "string":
	          return 3;
	        case "symbol":
	          return 4;
	        case "number":
	          return 5;
	        case "object":
	          return null === x ? 1 : 6;
	        default:
	          return 6;
	      }
	    }
	    function IsUndefined(x) {
	      return void 0 === x;
	    }
	    function IsNull(x) {
	      return null === x;
	    }
	    function IsSymbol(x) {
	      return "symbol" == typeof x;
	    }
	    function IsObject(x) {
	      return "object" == typeof x ? null !== x : "function" == typeof x;
	    }
	    function ToPrimitive(input, PreferredType) {
	      switch (Type(input)) {
	        case 0:
	        case 1:
	        case 2:
	        case 3:
	        case 4:
	        case 5:
	          return input;
	      }
	      const hint = 3 === PreferredType ? "string" : 5 === PreferredType ? "number" : "default",
	        exoticToPrim = GetMethod(input, toPrimitiveSymbol);
	      if (void 0 !== exoticToPrim) {
	        const result = exoticToPrim.call(input, hint);
	        if (IsObject(result)) throw new TypeError();
	        return result;
	      }
	      return OrdinaryToPrimitive(input, "default" === hint ? "number" : hint);
	    }
	    function OrdinaryToPrimitive(O, hint) {
	      if ("string" === hint) {
	        const toString_1 = O.toString;
	        if (IsCallable(toString_1)) {
	          const result = toString_1.call(O);
	          if (!IsObject(result)) return result;
	        }
	        const valueOf = O.valueOf;
	        if (IsCallable(valueOf)) {
	          const result = valueOf.call(O);
	          if (!IsObject(result)) return result;
	        }
	      } else {
	        const valueOf = O.valueOf;
	        if (IsCallable(valueOf)) {
	          const result = valueOf.call(O);
	          if (!IsObject(result)) return result;
	        }
	        const toString_2 = O.toString;
	        if (IsCallable(toString_2)) {
	          const result = toString_2.call(O);
	          if (!IsObject(result)) return result;
	        }
	      }
	      throw new TypeError();
	    }
	    function ToBoolean(argument) {
	      return !!argument;
	    }
	    function ToString(argument) {
	      return "" + argument;
	    }
	    function ToPropertyKey(argument) {
	      const key = ToPrimitive(argument, 3);
	      return IsSymbol(key) ? key : ToString(key);
	    }
	    function IsCallable(argument) {
	      return "function" == typeof argument;
	    }
	    function GetMethod(V, P) {
	      const func = V[P];
	      if (null != func) {
	        if (!IsCallable(func)) throw new TypeError();
	        return func;
	      }
	    }
	    function OrdinaryGetPrototypeOf(O) {
	      const proto = Object.getPrototypeOf(O);
	      if ("function" != typeof O || O === functionPrototype) return proto;
	      if (proto !== functionPrototype) return proto;
	      const prototype = O.prototype,
	        prototypeProto = prototype && Object.getPrototypeOf(prototype);
	      if (null == prototypeProto || prototypeProto === Object.prototype) return proto;
	      const constructor = prototypeProto.constructor;
	      return "function" != typeof constructor || constructor === O ? proto : constructor;
	    }
	    exporter("defineMetadata", defineMetadata), exporter("hasMetadata", hasMetadata), exporter("hasOwnMetadata", hasOwnMetadata), exporter("getMetadata", getMetadata);
	  }((target = Reflect, function (key, value) {
	    "function" != typeof target[key] && Object.defineProperty(target, key, {
	      configurable: !0,
	      writable: !0,
	      value: value
	    });
	  })), Reflect;
	})({});

	function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
	  const metadatas = [metadata];
	  let paramsOrPropertiesMetadata = {};
	  Reflect$1.hasOwnMetadata(metadataKey, annotationTarget) && (paramsOrPropertiesMetadata = Reflect$1.getMetadata(metadataKey, annotationTarget));
	  let paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
	  void 0 === paramOrPropertyMetadata && (paramOrPropertyMetadata = []), paramOrPropertyMetadata.push(...metadatas), paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata, Reflect$1.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
	}
	function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
	  _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
	}
	function createTaggedDecorator(metadata) {
	  return (target, targetKey, indexOrPropertyDescriptor) => {
	    tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
	  };
	}
	function injectBase(metadataKey) {
	  return serviceIdentifier => (target, targetKey, indexOrPropertyDescriptor) => createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
	}

	const inject = injectBase(INJECT_TAG);

	function injectable() {
	  return function (target) {
	    return Reflect$1.defineMetadata(PARAM_TYPES, null, target), target;
	  };
	}

	function named(name) {
	  return createTaggedDecorator(new Metadata(NAMED_TAG, name));
	}

	const BindingScopeEnum = {
	    Singleton: "Singleton",
	    Transient: "Transient"
	  },
	  BindingTypeEnum = {
	    ConstantValue: "ConstantValue",
	    Constructor: "Constructor",
	    DynamicValue: "DynamicValue",
	    Factory: "Factory",
	    Function: "Function",
	    Instance: "Instance",
	    Invalid: "Invalid",
	    Provider: "Provider"
	  };

	class Binding {
	  constructor(serviceIdentifier, scope) {
	    this.id = Generator.GenAutoIncrementId(), this.activated = !1, this.serviceIdentifier = serviceIdentifier, this.scope = scope, this.type = BindingTypeEnum.Invalid, this.constraint = request => !0, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.dynamicValue = null;
	  }
	  clone() {
	    const clone = new Binding(this.serviceIdentifier, this.scope);
	    return clone.activated = clone.scope === BindingScopeEnum.Singleton && this.activated, clone.implementationType = this.implementationType, clone.dynamicValue = this.dynamicValue, clone.scope = this.scope, clone.type = this.type, clone.provider = this.provider, clone.constraint = this.constraint, clone.cache = this.cache, clone;
	  }
	}

	class MetadataReader {
	  getConstructorMetadata(constructorFunc) {
	    return {
	      compilerGeneratedMetadata: Reflect$1.getMetadata(PARAM_TYPES, constructorFunc),
	      userGeneratedMetadata: Reflect$1.getMetadata(TAGGED, constructorFunc) || {}
	    };
	  }
	  getPropertiesMetadata(constructorFunc) {
	    throw new Error("暂未实现");
	  }
	}

	const taggedConstraint = key => value => {
	  const constraint = request => {
	    if (null == request) return !1;
	    if (request.key === key && request.value === value) return !0;
	    if (null == request.constructorArgsMetadata) return !1;
	    const constructorArgsMetadata = request.constructorArgsMetadata;
	    for (let i = 0; i < constructorArgsMetadata.length; i++) if (constructorArgsMetadata[i].key === key && constructorArgsMetadata[i].value === value) return !0;
	    return !1;
	  };
	  return constraint.metaData = new Metadata(key, value), constraint;
	};
	const namedConstraint = taggedConstraint(NAMED_TAG);

	class BindingInSyntax {
	  constructor(binding) {
	    this._binding = binding;
	  }
	  inRequestScope() {
	    throw new Error("暂未实现");
	  }
	  inSingletonScope() {
	    return this._binding.scope = BindingScopeEnum.Singleton, this;
	  }
	  inTransientScope() {
	    return this._binding.scope = BindingScopeEnum.Transient, this;
	  }
	  whenTargetNamed(name) {
	    return this._binding.constraint = namedConstraint(name), this;
	  }
	}

	class BindingToSyntax {
	  constructor(binding) {
	    this._binding = binding;
	  }
	  to(constructor) {
	    return this._binding.type = BindingTypeEnum.Instance, this._binding.implementationType = constructor, new BindingInSyntax(this._binding);
	  }
	  toSelf() {
	    const self = this._binding.serviceIdentifier;
	    return this.to(self);
	  }
	  toDynamicValue(func) {
	    return this._binding.type = BindingTypeEnum.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = func, this._binding.implementationType = null, new BindingInSyntax(this._binding);
	  }
	  toConstantValue(value) {
	    return this._binding.type = BindingTypeEnum.ConstantValue, this._binding.cache = value, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
	  }
	  toFactory(factory) {
	    return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = factory, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
	  }
	  toService(service) {
	    this.toDynamicValue(context => context.container.get(service));
	  }
	}

	class Container {
	  constructor(containerOptions) {
	    const options = containerOptions || {};
	    options.defaultScope = options.defaultScope || BindingScopeEnum.Transient, this.options = options, this.id = Generator.GenAutoIncrementId(), this._bindingDictionary = new Map(), this._metadataReader = new MetadataReader();
	  }
	  load(module) {
	    const containerModuleHelpers = this._getContainerModuleHelpersFactory()(module.id);
	    module.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
	  }
	  get(serviceIdentifier) {
	    const getArgs = this._getNotAllArgs(serviceIdentifier, !1);
	    return this._get(getArgs);
	  }
	  getAll(serviceIdentifier) {
	    const getArgs = this._getAllArgs(serviceIdentifier);
	    return this._get(getArgs);
	  }
	  getTagged(serviceIdentifier, key, value) {
	    const getArgs = this._getNotAllArgs(serviceIdentifier, !1, key, value);
	    return this._get(getArgs);
	  }
	  getNamed(serviceIdentifier, named) {
	    return this.getTagged(serviceIdentifier, NAMED_TAG, named);
	  }
	  isBound(serviceIdentifier) {
	    return this._bindingDictionary.has(serviceIdentifier);
	  }
	  bind(serviceIdentifier) {
	    const scope = this.options.defaultScope,
	      binding = new Binding(serviceIdentifier, scope),
	      list = this._bindingDictionary.get(serviceIdentifier) || [];
	    return list.push(binding), this._bindingDictionary.set(serviceIdentifier, list), new BindingToSyntax(binding);
	  }
	  unbind(serviceIdentifier) {
	    this._bindingDictionary.delete(serviceIdentifier);
	  }
	  rebind(serviceIdentifier) {
	    return this.unbind(serviceIdentifier), this.bind(serviceIdentifier);
	  }
	  _getContainerModuleHelpersFactory() {
	    const setModuleId = (bindingToSyntax, moduleId) => {
	        bindingToSyntax._binding.moduleId = moduleId;
	      },
	      getBindFunction = moduleId => serviceIdentifier => {
	        const bindingToSyntax = this.bind(serviceIdentifier);
	        return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
	      },
	      getUnbindFunction = () => serviceIdentifier => this.unbind(serviceIdentifier),
	      getIsboundFunction = () => serviceIdentifier => this.isBound(serviceIdentifier),
	      getRebindFunction = moduleId => serviceIdentifier => {
	        const bindingToSyntax = this.rebind(serviceIdentifier);
	        return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
	      };
	    return mId => ({
	      bindFunction: getBindFunction(mId),
	      isboundFunction: getIsboundFunction(),
	      rebindFunction: getRebindFunction(mId),
	      unbindFunction: getUnbindFunction(),
	      unbindAsyncFunction: serviceIdentifier => null
	    });
	  }
	  _getNotAllArgs(serviceIdentifier, isMultiInject, key, value) {
	    return {
	      avoidConstraints: !1,
	      isMultiInject: isMultiInject,
	      serviceIdentifier: serviceIdentifier,
	      key: key,
	      value: value
	    };
	  }
	  _getAllArgs(serviceIdentifier) {
	    return {
	      avoidConstraints: !0,
	      isMultiInject: !0,
	      serviceIdentifier: serviceIdentifier
	    };
	  }
	  _get(getArgs) {
	    const result = [];
	    return this._bindingDictionary.get(getArgs.serviceIdentifier).filter(b => b.constraint(getArgs)).forEach(binding => {
	      result.push(this._resolveFromBinding(binding));
	    }), getArgs.isMultiInject || 1 !== result.length ? result : result[0];
	  }
	  _getChildRequest(binding) {
	    const constr = binding.implementationType,
	      {
	        userGeneratedMetadata: userGeneratedMetadata
	      } = this._metadataReader.getConstructorMetadata(constr),
	      keys = Object.keys(userGeneratedMetadata),
	      arr = [];
	    for (let i = 0; i < keys.length; i++) {
	      const constructorArgsMetadata = userGeneratedMetadata[i],
	        targetMetadataMap = {};
	      constructorArgsMetadata.forEach(md => {
	        targetMetadataMap[md.key] = md.value;
	      });
	      const metadata = {
	          inject: targetMetadataMap[INJECT_TAG],
	          multiInject: targetMetadataMap[MULTI_INJECT_TAG]
	        },
	        injectIdentifier = metadata.inject || metadata.multiInject,
	        target = {
	          serviceIdentifier: injectIdentifier,
	          constructorArgsMetadata: constructorArgsMetadata
	        },
	        bindings = (this._bindingDictionary.get(injectIdentifier) || []).filter(b => b.constraint(target));
	      if (bindings.length) {
	        const request = {
	          injectIdentifier: injectIdentifier,
	          metadata: constructorArgsMetadata,
	          bindings: bindings
	        };
	        arr.push(request);
	      }
	    }
	    return arr;
	  }
	  _resolveFromBinding(binding) {
	    const result = this._getResolvedFromBinding(binding);
	    return this._saveToScope(binding, result), result;
	  }
	  _getResolvedFromBinding(binding) {
	    let result;
	    switch (binding.type) {
	      case BindingTypeEnum.ConstantValue:
	      case BindingTypeEnum.Function:
	        result = binding.cache;
	        break;
	      case BindingTypeEnum.Instance:
	        result = this._resolveInstance(binding, binding.implementationType);
	        break;
	      default:
	        result = binding.dynamicValue({
	          container: this
	        });
	    }
	    return result;
	  }
	  _resolveInstance(binding, constr) {
	    if (binding.activated) return binding.cache;
	    const childRequests = this._getChildRequest(binding);
	    return this._createInstance(constr, childRequests);
	  }
	  _createInstance(constr, childRequests) {
	    if (childRequests.length) {
	      return new constr(...this._resolveRequests(childRequests));
	    }
	    return new constr();
	  }
	  _resolveRequests(childRequests) {
	    return childRequests.map(request => request.bindings.length > 1 ? request.bindings.map(binding => this._resolveFromBinding(binding)) : this._resolveFromBinding(request.bindings[0]));
	  }
	  _saveToScope(binding, result) {
	    binding.scope === BindingScopeEnum.Singleton && (binding.cache = result, binding.activated = !0);
	  }
	}

	const ContributionProvider = Symbol("ContributionProvider");
	class ContributionProviderCache {
	  constructor(serviceIdentifier, container) {
	    this.serviceIdentifier = serviceIdentifier, this.container = container, ContributionStore.setStore(this.serviceIdentifier, this);
	  }
	  getContributions() {
	    return this.caches || (this.caches = [], this.container && this.container.isBound(this.serviceIdentifier) && this.caches.push(...this.container.getAll(this.serviceIdentifier))), this.caches;
	  }
	  refresh() {
	    this.caches && (this.caches.length = 0, this.container && this.container.isBound(this.serviceIdentifier) && this.caches.push(...this.container.getAll(this.serviceIdentifier)));
	  }
	}
	function bindContributionProvider(bind, id) {
	  bind(ContributionProvider).toDynamicValue(({
	    container: container
	  }) => new ContributionProviderCache(id, container)).inSingletonScope().whenTargetNamed(id);
	}
	class ContributionStore {
	  static getStore(id) {
	    return this.store.get(id);
	  }
	  static setStore(id, cache) {
	    this.store.set(id, cache);
	  }
	  static refreshAllContributions() {
	    this.store.forEach(cache => {
	      cache.refresh();
	    });
	  }
	}
	ContributionStore.store = new Map();

	class Hook {
	  constructor(args, name) {
	    this._args = args, this.name = name, this.taps = [];
	  }
	  tap(options, fn) {
	    this._tap("sync", options, fn);
	  }
	  unTap(options, fn) {
	    const name = "string" == typeof options ? options.trim() : options.name;
	    name && (this.taps = this.taps.filter(tap => !(tap.name === name && (!fn || tap.fn === fn))));
	  }
	  _parseOptions(type, options, fn) {
	    let _options;
	    if ("string" == typeof options) _options = {
	      name: options.trim()
	    };else if ("object" != typeof options || null === options) throw new Error("Invalid tap options");
	    if ("string" != typeof _options.name || "" === _options.name) throw new Error("Missing name for tap");
	    return _options = Object.assign({
	      type: type,
	      fn: fn
	    }, _options), _options;
	  }
	  _tap(type, options, fn) {
	    this._insert(this._parseOptions(type, options, fn));
	  }
	  _insert(item) {
	    let before;
	    "string" == typeof item.before ? before = new Set([item.before]) : Array.isArray(item.before) && (before = new Set(item.before));
	    let stage = 0;
	    "number" == typeof item.stage && (stage = item.stage);
	    let i = this.taps.length;
	    for (; i > 0;) {
	      i--;
	      const x = this.taps[i];
	      this.taps[i + 1] = x;
	      const xStage = x.stage || 0;
	      if (before) {
	        if (before.has(x.name)) {
	          before.delete(x.name);
	          continue;
	        }
	        if (before.size > 0) continue;
	      }
	      if (!(xStage > stage)) {
	        i++;
	        break;
	      }
	    }
	    this.taps[i] = item;
	  }
	}

	class SyncHook extends Hook {
	  call(...args) {
	    this.taps.map(t => t.fn).forEach(cb => cb(...args));
	  }
	}

	const DEFAULT_TEXT_FONT_FAMILY$1 = "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol";

	class Application {}
	const application = new Application();

	let idx = 0;
	class PerformanceRAF {
	  constructor() {
	    this.nextAnimationFrameCbs = new Map(), this._rafHandle = null, this.runAnimationFrame = time => {
	      this._rafHandle = null;
	      const cbs = this.nextAnimationFrameCbs;
	      this.nextAnimationFrameCbs = new Map(), cbs.forEach(cb => cb(time));
	    }, this.tryRunAnimationFrameNextFrame = () => {
	      null === this._rafHandle && 0 !== this.nextAnimationFrameCbs.size && (this._rafHandle = application.global.getRequestAnimationFrame()(this.runAnimationFrame));
	    };
	  }
	  addAnimationFrameCb(callback) {
	    return this.nextAnimationFrameCbs.set(++idx, callback), this.tryRunAnimationFrameNextFrame(), idx;
	  }
	  removeAnimationFrameCb(index) {
	    return !!this.nextAnimationFrameCbs.has(index) && (this.nextAnimationFrameCbs.delete(index), !0);
	  }
	}

	var MeasureModeEnum;
	!function (MeasureModeEnum) {
	  MeasureModeEnum[MeasureModeEnum.estimate = 0] = "estimate", MeasureModeEnum[MeasureModeEnum.actualBounding = 1] = "actualBounding", MeasureModeEnum[MeasureModeEnum.fontBounding = 2] = "fontBounding";
	}(MeasureModeEnum || (MeasureModeEnum = {}));

	var STATUS;
	!function (STATUS) {
	  STATUS[STATUS.INITIAL = 0] = "INITIAL", STATUS[STATUS.RUNNING = 1] = "RUNNING", STATUS[STATUS.PAUSE = 2] = "PAUSE";
	}(STATUS || (STATUS = {}));

	var AnimateStepType;
	!function (AnimateStepType) {
	  AnimateStepType.wait = "wait", AnimateStepType.from = "from", AnimateStepType.to = "to", AnimateStepType.customAnimate = "customAnimate";
	}(AnimateStepType || (AnimateStepType = {}));
	var AnimateStatus;
	!function (AnimateStatus) {
	  AnimateStatus[AnimateStatus.INITIAL = 0] = "INITIAL", AnimateStatus[AnimateStatus.RUNNING = 1] = "RUNNING", AnimateStatus[AnimateStatus.PAUSED = 2] = "PAUSED", AnimateStatus[AnimateStatus.END = 3] = "END";
	}(AnimateStatus || (AnimateStatus = {}));

	const circleThreshold = tau - 1e-8;
	class BoundsContext {
	  constructor(bounds) {
	    this.init(bounds);
	  }
	  init(bounds) {
	    this.bounds = bounds;
	  }
	  arc(cx, cy, r, sa, ea, ccw) {
	    if (Math.abs(ea - sa) > circleThreshold) return this.bounds.add(cx - r, cy - r), void this.bounds.add(cx + r, cy + r);
	    let s,
	      i,
	      x,
	      y,
	      xmin = 1 / 0,
	      xmax = -1 / 0,
	      ymin = 1 / 0,
	      ymax = -1 / 0;
	    function update(a) {
	      x = r * Math.cos(a), y = r * Math.sin(a), x < xmin && (xmin = x), x > xmax && (xmax = x), y < ymin && (ymin = y), y > ymax && (ymax = y);
	    }
	    if (update(sa), update(ea), ea !== sa) if ((sa %= tau) < 0 && (sa += tau), (ea %= tau) < 0 && (ea += tau), ea < sa && (ccw = !ccw, s = sa, sa = ea, ea = s), ccw) for (ea -= tau, s = sa - sa % halfPi$1, i = 0; i < 4 && s > ea; ++i, s -= halfPi$1) update(s);else for (s = sa - sa % halfPi$1 + halfPi$1, i = 0; i < 4 && s < ea; ++i, s += halfPi$1) update(s);
	    this.bounds.add(cx + xmin, cy + ymin), this.bounds.add(cx + xmax, cy + ymax);
	  }
	  arcTo(x1, y1, x2, y2, radius) {
	    this.bounds.add(x1, y1);
	  }
	  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
	    this.bounds.add(cp1x, cp1y), this.bounds.add(cp2x, cp2y), this.bounds.add(x, y);
	  }
	  closePath() {}
	  ellipse() {
	    throw new Error("不支持ellipse");
	  }
	  lineTo(x, y) {
	    this.bounds.add(x, y);
	  }
	  moveTo(x, y) {
	    this.bounds.add(x, y);
	  }
	  quadraticCurveTo(cpx, cpy, x, y) {
	    this.bounds.add(cpx, cpy), this.bounds.add(x, y);
	  }
	  rect(x, y, w, h) {
	    this.bounds.add(x, y), this.bounds.add(x + w, y + h);
	  }
	  clear() {
	    this.bounds.clear();
	  }
	  release(...params) {}
	}

	class CurvePath {
	  constructor() {
	    this._curves = [], this.bounds = new AABBBounds();
	  }
	  get curves() {
	    return this._curves;
	  }
	  getCurveLengths() {
	    return this._curves.map(curve => curve.getLength());
	  }
	  getPointAt(t) {
	    return {
	      x: 0,
	      y: 0
	    };
	  }
	  getLength() {
	    return 0;
	  }
	  getBounds() {
	    return this.bounds;
	  }
	}

	const rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi,
	  commandLengths = {
	    m: 2,
	    l: 2,
	    h: 1,
	    v: 1,
	    c: 6,
	    s: 4,
	    q: 4,
	    t: 2,
	    a: 7,
	    M: 2,
	    L: 2,
	    H: 1,
	    V: 1,
	    C: 6,
	    S: 4,
	    Q: 4,
	    T: 2,
	    A: 7
	  };
	const enumCommandMap = {
	  A: 0,
	  AT: 1,
	  C: 2,
	  Z: 3,
	  E: 4,
	  L: 5,
	  M: 6,
	  Q: 7,
	  R: 8
	};
	let currPath, coordsStr, commandChar, coordStr, coordNumber, standardCommandLen;
	function parseSvgPath(str) {
	  if (!str) return [];
	  const paths = str.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
	  if (null === paths) return [];
	  let currCommandData, coordsStrArr;
	  const result = [];
	  for (let i = 0, len = paths.length; i < len; i++) if (currPath = paths[i], coordsStr = currPath.slice(1), commandChar = currPath[0], currCommandData = [commandChar], coordsStrArr = coordsStr.match(rePathCommand), null !== coordsStrArr) {
	    for (let i = 0, len = coordsStrArr.length; i < len; i++) coordStr = coordsStrArr[i], coordNumber = parseFloat(coordStr), Number.isNaN(coordNumber) || currCommandData.push(coordNumber);
	    if (standardCommandLen = commandLengths[commandChar], currCommandData.length - 1 > standardCommandLen) {
	      let subCommand,
	        bestCommandChar = commandChar;
	      for (let i = 1, len = currCommandData.length; i < len; i += standardCommandLen) {
	        subCommand = [bestCommandChar];
	        for (let j = i, subLen = i + standardCommandLen; j < subLen; j++) subCommand.push(currCommandData[j]);
	        result.push(subCommand), "m" === bestCommandChar ? bestCommandChar = "l" : "M" === bestCommandChar && (bestCommandChar = "L");
	      }
	    } else result.push(currCommandData);
	  } else result.push(currCommandData);
	  return result;
	}

	var UpdateTag;
	!function (UpdateTag) {
	  UpdateTag[UpdateTag.NONE = 0] = "NONE", UpdateTag[UpdateTag.UPDATE_BOUNDS = 1] = "UPDATE_BOUNDS", UpdateTag[UpdateTag.UPDATE_SHAPE = 2] = "UPDATE_SHAPE", UpdateTag[UpdateTag.CLEAR_SHAPE = 253] = "CLEAR_SHAPE", UpdateTag[UpdateTag.UPDATE_SHAPE_AND_BOUNDS = 3] = "UPDATE_SHAPE_AND_BOUNDS", UpdateTag[UpdateTag.INIT = 179] = "INIT", UpdateTag[UpdateTag.CLEAR_BOUNDS = 254] = "CLEAR_BOUNDS", UpdateTag[UpdateTag.UPDATE_GLOBAL_MATRIX = 32] = "UPDATE_GLOBAL_MATRIX", UpdateTag[UpdateTag.CLEAR_GLOBAL_MATRIX = 223] = "CLEAR_GLOBAL_MATRIX", UpdateTag[UpdateTag.UPDATE_LOCAL_MATRIX = 16] = "UPDATE_LOCAL_MATRIX", UpdateTag[UpdateTag.CLEAR_LOCAL_MATRIX = 239] = "CLEAR_LOCAL_MATRIX", UpdateTag[UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX = 48] = "UPDATE_GLOBAL_LOCAL_MATRIX", UpdateTag[UpdateTag.UPDATE_LAYOUT = 128] = "UPDATE_LAYOUT", UpdateTag[UpdateTag.CLEAR_LAYOUT = 127] = "CLEAR_LAYOUT";
	}(UpdateTag || (UpdateTag = {}));
	var IContainPointMode;
	!function (IContainPointMode) {
	  IContainPointMode[IContainPointMode.GLOBAL = 1] = "GLOBAL", IContainPointMode[IContainPointMode.LOCAL = 16] = "LOCAL", IContainPointMode[IContainPointMode.GLOBAL_ACCURATE = 3] = "GLOBAL_ACCURATE", IContainPointMode[IContainPointMode.LOCAL_ACCURATE = 48] = "LOCAL_ACCURATE";
	}(IContainPointMode || (IContainPointMode = {}));
	var AttributeUpdateType;
	!function (AttributeUpdateType) {
	  AttributeUpdateType[AttributeUpdateType.INIT = 0] = "INIT", AttributeUpdateType[AttributeUpdateType.DEFAULT = 1] = "DEFAULT", AttributeUpdateType[AttributeUpdateType.STATE = 2] = "STATE", AttributeUpdateType[AttributeUpdateType.ANIMATE_BIND = 10] = "ANIMATE_BIND", AttributeUpdateType[AttributeUpdateType.ANIMATE_PLAY = 11] = "ANIMATE_PLAY", AttributeUpdateType[AttributeUpdateType.ANIMATE_START = 12] = "ANIMATE_START", AttributeUpdateType[AttributeUpdateType.ANIMATE_UPDATE = 13] = "ANIMATE_UPDATE", AttributeUpdateType[AttributeUpdateType.ANIMATE_END = 14] = "ANIMATE_END", AttributeUpdateType[AttributeUpdateType.TRANSLATE = 20] = "TRANSLATE", AttributeUpdateType[AttributeUpdateType.TRANSLATE_TO = 21] = "TRANSLATE_TO", AttributeUpdateType[AttributeUpdateType.SCALE = 22] = "SCALE", AttributeUpdateType[AttributeUpdateType.SCALE_TO = 23] = "SCALE_TO", AttributeUpdateType[AttributeUpdateType.ROTATE = 24] = "ROTATE", AttributeUpdateType[AttributeUpdateType.ROTATE_TO = 25] = "ROTATE_TO";
	}(AttributeUpdateType || (AttributeUpdateType = {}));
	var Direction;
	!function (Direction) {
	  Direction[Direction.ROW = 1] = "ROW", Direction[Direction.COLUMN = 2] = "COLUMN";
	}(Direction || (Direction = {}));
	var CurveTypeEnum;
	!function (CurveTypeEnum) {
	  CurveTypeEnum[CurveTypeEnum.CubicBezierCurve = 0] = "CubicBezierCurve", CurveTypeEnum[CurveTypeEnum.QuadraticBezierCurve = 1] = "QuadraticBezierCurve", CurveTypeEnum[CurveTypeEnum.ArcCurve = 2] = "ArcCurve", CurveTypeEnum[CurveTypeEnum.LineCurve = 3] = "LineCurve", CurveTypeEnum[CurveTypeEnum.EllipseCurve = 4] = "EllipseCurve", CurveTypeEnum[CurveTypeEnum.MoveCurve = 5] = "MoveCurve";
	}(CurveTypeEnum || (CurveTypeEnum = {}));
	var BaseRenderContributionTime;
	!function (BaseRenderContributionTime) {
	  BaseRenderContributionTime[BaseRenderContributionTime.beforeFillStroke = 0] = "beforeFillStroke", BaseRenderContributionTime[BaseRenderContributionTime.afterFillStroke = 1] = "afterFillStroke";
	}(BaseRenderContributionTime || (BaseRenderContributionTime = {}));

	function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
	  const th = degreeToRadian(rotateX),
	    sin_th = Math.sin(th),
	    cos_th = Math.cos(th),
	    px = cos_th * (ox - x) * .5 + sin_th * (oy - y) * .5,
	    py = cos_th * (oy - y) * .5 - sin_th * (ox - x) * .5;
	  let pl = px * px / ((rx = Math.abs(rx)) * rx) + py * py / ((ry = Math.abs(ry)) * ry);
	  pl > 1 && (pl = Math.sqrt(pl), rx *= pl, ry *= pl);
	  const a00 = cos_th / rx,
	    a01 = sin_th / rx,
	    a10 = -sin_th / ry,
	    a11 = cos_th / ry,
	    x0 = a00 * ox + a01 * oy,
	    y0 = a10 * ox + a11 * oy,
	    x1 = a00 * x + a01 * y,
	    y1 = a10 * x + a11 * y;
	  let sfactor_sq = 1 / ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) - .25;
	  sfactor_sq < 0 && (sfactor_sq = 0);
	  let sfactor = Math.sqrt(sfactor_sq);
	  sweep === large && (sfactor = -sfactor);
	  const xc = .5 * (x0 + x1) - sfactor * (y1 - y0),
	    yc = .5 * (y0 + y1) + sfactor * (x1 - x0),
	    th0 = Math.atan2(y0 - yc, x0 - xc);
	  let th_arc = Math.atan2(y1 - yc, x1 - xc) - th0;
	  th_arc < 0 && 1 === sweep ? th_arc += tau : th_arc > 0 && 0 === sweep && (th_arc -= tau);
	  const segs = Math.ceil(Math.abs(th_arc / (halfPi$1 + .001))),
	    result = [];
	  for (let i = 0; i < segs; ++i) {
	    const th2 = th0 + i * th_arc / segs,
	      th3 = th0 + (i + 1) * th_arc / segs;
	    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
	  }
	  return result;
	}
	function bezier(params) {
	  const cx = params[0],
	    cy = params[1],
	    th0 = params[2],
	    th1 = params[3],
	    rx = params[4],
	    ry = params[5],
	    sin_th = params[6],
	    cos_th = params[7],
	    a00 = cos_th * rx,
	    a01 = -sin_th * ry,
	    a10 = sin_th * rx,
	    a11 = cos_th * ry,
	    cos_th0 = Math.cos(th0),
	    sin_th0 = Math.sin(th0),
	    cos_th1 = Math.cos(th1),
	    sin_th1 = Math.sin(th1),
	    th_half = .5 * (th1 - th0),
	    sin_th_h2 = Math.sin(.5 * th_half),
	    t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half),
	    x1 = cx + cos_th0 - t * sin_th0,
	    y1 = cy + sin_th0 + t * cos_th0,
	    x3 = cx + cos_th1,
	    y3 = cy + sin_th1,
	    x2 = x3 + t * sin_th1,
	    y2 = y3 - t * cos_th1;
	  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
	}
	function drawArc(context, x, y, coords) {
	  const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x, y);
	  for (let i = 0; i < seg.length; ++i) {
	    const bez = bezier(seg[i]);
	    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
	  }
	}
	const addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry, counterclockwise = !1) => {
	  const PI2 = 2 * Math.PI,
	    sAngle = (startAngle % PI2 + PI2) % PI2;
	  let deltaAngle,
	    eAngle = (endAngle % PI2 + PI2) % PI2;
	  counterclockwise ? (eAngle >= sAngle && (eAngle -= PI2), deltaAngle = eAngle - sAngle) : (eAngle <= sAngle && (eAngle += PI2), deltaAngle = eAngle - sAngle);
	  const count = Math.ceil(Math.abs(deltaAngle) / (.5 * Math.PI)),
	    stepAngle = deltaAngle / count;
	  for (let i = 0; i < count; i++) {
	    const sa = sAngle + stepAngle * i,
	      ea = sAngle + stepAngle * (i + 1),
	      len = 4 / 3 * Math.tan(Math.abs(stepAngle) / 4),
	      c1 = Math.cos(sa),
	      s1 = Math.sin(sa),
	      c2 = Math.cos(ea),
	      s2 = Math.sin(ea),
	      x1 = c1 * rx + cx,
	      y1 = s1 * ry + cy,
	      x4 = c2 * rx + cx,
	      y4 = s2 * ry + cy,
	      sign = counterclockwise ? -1 : 1,
	      hx = rx * len * sign,
	      hy = ry * len * sign;
	    bezierPath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
	  }
	};

	const commandFuncs = [(command, context, x, y, sx, sy, z) => context.arc(command[1] * sx + x, command[2] * sy + y, command[3] * (sx + sy) / 2, command[4], command[5], command[6], z), (command, context, x, y, sx, sy, z) => context.arcTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * (sx + sy) / 2, z), (command, context, x, y, sx, sy, z) => context.bezierCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * sx + x, command[6] * sy + y, z), (command, context, x, y) => context.closePath(), (command, context, x, y, sx, sy) => context.ellipse(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]), (command, context, x, y, sx, sy, z) => context.lineTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.moveTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.quadraticCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, z), (command, context, x, y, sx, sy, z) => context.rect(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, z)];
	function renderCommandList(commandList, context, x = 0, y = 0, sx = 1, sy = 1, z) {
	  for (let i = 0; i < commandList.length; i++) {
	    const command = commandList[i];
	    commandFuncs[command[0]](command, context, x, y, sx, sy, z);
	  }
	}

	class Curve {
	  getLength(direction) {
	    return null != direction ? this.calcProjLength(direction) : (Number.isFinite(this.length) || (this.length = this.calcLength()), this.length);
	  }
	}

	function snapLength(xArr, yArr) {
	  let totalLength = 0;
	  const count = xArr.length;
	  for (let i = 0; i < count; i++) {
	    const x = xArr[i],
	      y = yArr[i],
	      nextX = xArr[(i + 1) % count],
	      nextY = yArr[(i + 1) % count];
	    totalLength += PointService.distanceNN(x, y, nextX, nextY);
	  }
	  return totalLength / 2;
	}
	function cubicLength(p0, p1, p2, p3, iterationCount) {
	  return snapLength([p0.x, p1.x, p2.x, p3.x], [p0.y, p1.y, p2.y, p3.y]);
	}
	function cubicCalc(p0, p1, p2, p3, t) {
	  const one = 1 - t;
	  return one * one * one * p0 + 3 * p1 * t * one * one + 3 * p2 * t * t * one + p3 * t * t * t;
	}
	function cubicPointAt(p0, p1, p2, p3, t) {
	  const x = cubicCalc(p0.x, p1.x, p2.x, p3.x, t),
	    y = cubicCalc(p0.y, p1.y, p2.y, p3.y, t);
	  return new Point(x, y);
	}
	function quadCalc(p0, p1, p2, t) {
	  const one = 1 - t;
	  return one * one * p0 + 2 * one * t * p1 + t * t * p2;
	}
	function quadPointAt(p0, p1, p2, t) {
	  const x = quadCalc(p0.x, p1.x, p2.x, t),
	    y = quadCalc(p0.y, p1.y, p2.y, t);
	  return new Point(x, y);
	}
	function quadLength(p0, p1, p2, iterationCount) {
	  return snapLength([p0.x, p1.x, p2.x], [p0.y, p1.y, p2.y]);
	}

	function divideCubic(curve, t) {
	  const {
	      p0: p0,
	      p1: p1,
	      p2: p2,
	      p3: p3
	    } = curve,
	    pt = cubicPointAt(p0, p1, p2, p3, t),
	    c1 = PointService.pointAtPP(p0, p1, t),
	    c2 = PointService.pointAtPP(p1, p2, t),
	    c3 = PointService.pointAtPP(p2, p3, t),
	    c12 = PointService.pointAtPP(c1, c2, t),
	    c23 = PointService.pointAtPP(c2, c3, t);
	  return [new CubicBezierCurve(p0, c1, c12, pt), new CubicBezierCurve(pt, c23, c3, p3)];
	}
	class CubicBezierCurve extends Curve {
	  constructor(p0, p1, p2, p3) {
	    super(), this.type = CurveTypeEnum.CubicBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2, this.p3 = p3;
	  }
	  _validPoint() {
	    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
	  }
	  getPointAt(t) {
	    if (!1 !== this.defined) return cubicPointAt(this.p0, this.p1, this.p2, this.p3, t);
	    throw new Error("defined为false的点不能getPointAt");
	  }
	  calcLength() {
	    return this._validPoint() ? cubicLength(this.p0, this.p1, this.p2, this.p3) : 60;
	  }
	  calcProjLength(direction) {
	    return direction === Direction.ROW ? abs(this.p0.x - this.p3.x) : direction === Direction.COLUMN ? abs(this.p0.y - this.p3.y) : 0;
	  }
	  getAngleAt(t) {
	    const minT = max(t - .01, 0),
	      maxT = min(t + .01, 1),
	      minP = this.getPointAt(minT),
	      maxP = this.getPointAt(maxT);
	    return atan2(maxP.y - minP.y, maxP.x - minP.x);
	  }
	  draw(path, x, y, sx, sy, percent) {
	    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.bezierCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y, this.p3.x * sx + x, this.p3.y * sy + y);else if (percent > 0) {
	      const [curve1] = divideCubic(this, percent);
	      path.bezierCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y, curve1.p3.x * sx + x, curve1.p3.y * sy + y);
	    }
	  }
	  includeX(x) {
	    const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x),
	      maxX = max(this.p0.x, this.p1.x, this.p2.x, this.p3.x);
	    return x >= minX && x <= maxX;
	  }
	  getYAt(x) {
	    const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x),
	      t = (x - minX) / (max(this.p0.x, this.p1.x, this.p2.x, this.p3.x) - minX);
	    return this.getPointAt(t).y;
	  }
	}

	class LineCurve extends Curve {
	  constructor(p0, p1) {
	    super(), this.type = CurveTypeEnum.LineCurve, this.p0 = p0, this.p1 = p1;
	  }
	  getPointAt(t) {
	    if (!1 !== this.defined) return PointService.pointAtPP(this.p0, this.p1, t);
	    throw new Error("defined为false的点不能getPointAt");
	  }
	  getAngleAt(t) {
	    return null == this.angle && (this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), this.angle;
	  }
	  _validPoint() {
	    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
	  }
	  calcLength() {
	    return this._validPoint() ? PointService.distancePP(this.p0, this.p1) : 60;
	  }
	  calcProjLength(direction) {
	    return direction === Direction.ROW ? abs(this.p0.x - this.p1.x) : direction === Direction.COLUMN ? abs(this.p0.y - this.p1.y) : 0;
	  }
	  draw(path, x, y, sx, sy, percent) {
	    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.lineTo(this.p1.x * sx + x, this.p1.y * sy + y);else if (percent > 0) {
	      const p = this.getPointAt(percent);
	      path.lineTo(p.x * sx + x, p.y * sy + y);
	    }
	  }
	  includeX(x) {
	    return x >= this.p0.x && x <= this.p1.x || x >= this.p1.x && x <= this.p0.x;
	  }
	  getYAt(x) {
	    if (this.includeX(x)) {
	      let minP = this.p0,
	        maxP = this.p1;
	      this.p0.x > this.p1.x && (minP = this.p1, maxP = this.p0);
	      const percent = (x - minP.x) / (maxP.x - minP.x);
	      return minP.y + percent * (maxP.y - minP.y);
	    }
	    return 1 / 0;
	  }
	}

	class SegContext {
	  get endX() {
	    return this._lastX;
	  }
	  get endY() {
	    return this._lastY;
	  }
	  constructor(curveType, direction) {
	    this.init(curveType, direction);
	  }
	  init(curveType, direction) {
	    this._lastX = this._lastY = this._startX = this._startY = 0, this.curveType = curveType, this.direction = direction, this.curves = [];
	  }
	  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
	    const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
	    curve.originP1 = this._lastOriginP, curve.originP2 = p, curve.defined = defined, this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
	  }
	  closePath() {
	    if (this.curves.length < 2) return;
	    const lastCurve = this.curves[this.curves.length - 1];
	    this.lineTo(this._startX, this._startY, lastCurve.defined, this._startOriginP);
	  }
	  ellipse() {
	    throw new Error("SegContext不支持调用ellipse");
	  }
	  lineTo(x, y, defined, p) {
	    const curve = this.addLinearCurve(x, y, defined, this._lastOriginP, p);
	    this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
	  }
	  moveTo(x, y, p) {
	    return this._lastX = this._startX = x, this._lastY = this._startY = y, this._lastOriginP = p, this._startOriginP = p, this;
	  }
	  quadraticCurveTo(cpx, cpy, x, y) {
	    throw new Error("SegContext不支持调用quadraticCurveTo");
	  }
	  clear() {
	    this.curves = [], this.length = NaN;
	  }
	  tryUpdateLength(direction) {
	    return this.getLength(direction);
	  }
	  addLinearCurve(x, y, defined, p1, p2) {
	    const curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
	    return curve.originP1 = p1, curve.originP2 = p2, curve.defined = defined, curve;
	  }
	  getPointAt(t) {
	    throw new Error("暂未实现");
	  }
	  getCurveLengths() {
	    return [];
	  }
	  getLength(direction) {
	    var _a, _b;
	    if (direction === Direction.COLUMN) {
	      if (!this.curves.length) return 0;
	      const sc = this.curves[0],
	        ec = this.curves[this.curves.length - 1],
	        endP = null !== (_a = ec.p3) && void 0 !== _a ? _a : ec.p1;
	      return abs(sc.p0.y - endP.y);
	    }
	    if (direction === Direction.ROW) {
	      if (!this.curves.length) return 0;
	      const sc = this.curves[0],
	        ec = this.curves[this.curves.length - 1],
	        endP = null !== (_b = ec.p3) && void 0 !== _b ? _b : ec.p1;
	      return abs(sc.p0.x - endP.x);
	    }
	    return Number.isFinite(this.length) || (this.length = this.curves.reduce((l, c) => l + c.getLength(), 0)), this.length;
	  }
	}
	class ReflectSegContext extends SegContext {
	  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
	    return super.bezierCurveTo(cp1y, cp1x, cp2y, cp2x, y, x, defined, p);
	  }
	  lineTo(x, y, defined, p) {
	    return super.lineTo(y, x, defined, p);
	  }
	  moveTo(x, y, p) {
	    return super.moveTo(y, x, p);
	  }
	  clear() {
	    return super.clear();
	  }
	}

	function genCurveSegments(path, points, step = 1) {
	  let defined0 = !1;
	  for (let i = 0, n = points.length; i <= n; i++) i >= n === defined0 && ((defined0 = !defined0) ? path.lineStart() : path.lineEnd()), defined0 && path.point(points[i]);
	}
	function genSegContext(curveType, direction, points) {
	  const curveDirection = null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN;
	  return "monotoneY" === curveType ? new ReflectSegContext(curveType, curveDirection) : new SegContext(curveType, curveDirection);
	}

	class Linear {
	  constructor(context, startPoint) {
	    this.context = context, startPoint && (this.startPoint = startPoint);
	  }
	  areaStart() {
	    this._line = 0;
	  }
	  areaEnd() {
	    this._line = NaN;
	  }
	  lineStart() {
	    this._point = 0, this.startPoint && this.point(this.startPoint);
	  }
	  lineEnd() {
	    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
	  }
	  point(p) {
	    const x = p.x,
	      y = p.y;
	    switch (this._point) {
	      case 0:
	        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p) : this.context.moveTo(x, y, p);
	        break;
	      case 1:
	        this._point = 2;
	      default:
	        this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p);
	    }
	    this._lastDefined = p.defined;
	  }
	  tryUpdateLength() {
	    return this.context.tryUpdateLength();
	  }
	}
	function genLinearSegments(points, params = {}) {
	  const {
	    direction: direction,
	    startPoint: startPoint
	  } = params;
	  if (points.length < 2 - Number(!!startPoint)) return null;
	  const segContext = genSegContext("linear", direction, points);
	  return genLinearTypeSegments(new Linear(segContext, startPoint), points), segContext;
	}
	function genLinearTypeSegments(path, points) {
	  return genCurveSegments(path, points, 1);
	}

	function point$3(curveClass, x, y, defined, p) {
	  curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x) / 6, (curveClass._y0 + 4 * curveClass._y1 + y) / 6, defined, curveClass.lastPoint1);
	}
	class Basis {
	  constructor(context, startPoint) {
	    this.context = context, this.startPoint = startPoint;
	  }
	  areaStart() {
	    this._line = 0;
	  }
	  areaEnd() {
	    this._line = NaN;
	  }
	  lineStart() {
	    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
	  }
	  lineEnd() {
	    if (2 === this._point) point$3(this, 6 * this._x1 - (this._x0 + 4 * this._x1), 6 * this._y1 - (this._y0 + 4 * this._y1), !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
	    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
	  }
	  point(p) {
	    const x = p.x,
	      y = p.y;
	    switch (this._point) {
	      case 0:
	        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
	        break;
	      case 1:
	        this._point = 2;
	        break;
	      default:
	        point$3(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
	    }
	    this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
	  }
	  tryUpdateLength() {
	    return this.context.tryUpdateLength();
	  }
	}
	function genBasisTypeSegments(path, points) {
	  return genCurveSegments(path, points, 2);
	}
	function genBasisSegments(points, params = {}) {
	  const {
	    direction: direction,
	    startPoint: startPoint
	  } = params;
	  if (points.length < 2 - Number(!!startPoint)) return null;
	  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
	  const segContext = genSegContext("basis", direction, points);
	  return genBasisTypeSegments(new Basis(segContext, startPoint), points), segContext;
	}

	function sign(x) {
	  return x < 0 ? -1 : 1;
	}
	function slope3(curveClass, x2, y2) {
	  const h0 = curveClass._x1 - curveClass._x0,
	    h1 = x2 - curveClass._x1,
	    s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0)),
	    s1 = (y2 - curveClass._y1) / (h1 || Number(h0 < 0 && -0)),
	    p = (s0 * h1 + s1 * h0) / (h0 + h1);
	  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), .5 * Math.abs(p)) || 0;
	}
	function slope2(curveClass, t) {
	  const h = curveClass._x1 - curveClass._x0;
	  return h ? (3 * (curveClass._y1 - curveClass._y0) / h - t) / 2 : t;
	}
	function point$2(curveClass, t0, t1, defined, p) {
	  const x0 = curveClass._x0,
	    y0 = curveClass._y0,
	    x1 = curveClass._x1,
	    y1 = curveClass._y1,
	    dx = (x1 - x0) / 3;
	  curveClass.context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1, defined, curveClass.lastPoint1);
	}
	class MonotoneX {
	  constructor(context, startPoint) {
	    this.context = context, this.startPoint = startPoint;
	  }
	  areaStart() {
	    this._line = 0;
	  }
	  areaEnd() {
	    this._line = NaN;
	  }
	  lineStart() {
	    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
	  }
	  lineEnd() {
	    switch (this._point) {
	      case 2:
	        this.context.lineTo(this._x1, this._y1, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
	        break;
	      case 3:
	        point$2(this, this._t0, slope2(this, this._t0), !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
	    }
	    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
	  }
	  point(p) {
	    let t1 = NaN;
	    const x = p.x,
	      y = p.y;
	    switch (this._point) {
	      case 0:
	        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
	        break;
	      case 1:
	        this._point = 2;
	        break;
	      case 2:
	        this._point = 3, point$2(this, slope2(this, t1 = slope3(this, x, y)), t1, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
	        break;
	      default:
	        point$2(this, this._t0, t1 = slope3(this, x, y), !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
	    }
	    this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._t0 = t1, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = !1 !== p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
	  }
	  tryUpdateLength() {
	    return this.context.tryUpdateLength();
	  }
	}
	class MonotoneY extends MonotoneX {
	  constructor(context, startPoint) {
	    super(context, startPoint);
	  }
	  point(p) {
	    return super.point({
	      y: p.x,
	      x: p.y,
	      defined: p.defined
	    });
	  }
	}
	function genMonotoneXTypeSegments(path, points) {
	  return genCurveSegments(path, points, 2);
	}
	function genMonotoneXSegments(points, params = {}) {
	  const {
	    direction: direction,
	    startPoint: startPoint
	  } = params;
	  if (points.length < 2 - Number(!!startPoint)) return null;
	  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
	  const segContext = genSegContext("monotoneX", direction, points);
	  return genMonotoneXTypeSegments(new MonotoneX(segContext, startPoint), points), segContext;
	}
	function genMonotoneYTypeSegments(path, points) {
	  return genCurveSegments(path, points, 2);
	}
	function genMonotoneYSegments(points, params = {}) {
	  const {
	    direction: direction,
	    startPoint: startPoint
	  } = params;
	  if (points.length < 2 - Number(!!startPoint)) return null;
	  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
	  const segContext = genSegContext("monotoneY", direction, points);
	  return genMonotoneYTypeSegments(new MonotoneY(segContext, startPoint), points), segContext;
	}

	let Step$1 = class Step {
	  constructor(context, t = .5, startPoint) {
	    this.context = context, this._t = t, this.startPoint = startPoint;
	  }
	  areaStart() {
	    this._line = 0;
	  }
	  areaEnd() {
	    this._line = NaN;
	  }
	  lineStart() {
	    this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
	  }
	  lineEnd() {
	    0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, !1 !== this._lastDefined, this.lastPoint), (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
	  }
	  point(p) {
	    const x = p.x,
	      y = p.y;
	    switch (this._point) {
	      case 0:
	        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p) : this.context.moveTo(x, y, p);
	        break;
	      case 1:
	        this._point = 2;
	      default:
	        if (this._t <= 0) this.context.lineTo(this._x, y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p);else {
	          const x1 = this._x * (1 - this._t) + x * this._t;
	          .5 === this._t ? this.context.lineTo(x1, this._y, !1 !== this._lastDefined, this.lastPoint) : this.context.lineTo(x1, this._y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), this.context.lineTo(x1, y, !1 !== this._lastDefined && !1 !== p.defined, p);
	        }
	    }
	    this._lastDefined = p.defined, this._x = x, this._y = y, this.lastPoint = p;
	  }
	  tryUpdateLength() {
	    return this.context.tryUpdateLength();
	  }
	};
	class StepClosed extends Step$1 {
	  lineEnd() {
	    this.context.closePath();
	  }
	}
	function genStepSegments(points, t, params = {}) {
	  const {
	    direction: direction,
	    startPoint: startPoint
	  } = params;
	  if (points.length < 2 - Number(!!startPoint)) return null;
	  const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN);
	  return genStepTypeSegments(new Step$1(segContext, t, startPoint), points), segContext;
	}
	function genStepTypeSegments(path, points) {
	  return genCurveSegments(path, points, 1);
	}
	function genStepClosedSegments(points, t, params = {}) {
	  const {
	    direction: direction,
	    startPoint: startPoint
	  } = params;
	  if (points.length < 2 - Number(!!startPoint)) return null;
	  const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN);
	  return genStepTypeSegments(new StepClosed(segContext, t, startPoint), points), segContext;
	}

	class LinearClosed extends Linear {
	  lineEnd() {
	    this.context.closePath();
	  }
	}
	function genLinearClosedSegments(points, params = {}) {
	  const {
	    direction: direction,
	    startPoint: startPoint
	  } = params;
	  if (points.length < 2 - Number(!!startPoint)) return null;
	  const segContext = genSegContext("linear", direction, points);
	  return genLinearClosedTypeSegments(new LinearClosed(segContext, startPoint), points), segContext;
	}
	function genLinearClosedTypeSegments(path, points) {
	  return genCurveSegments(path, points, 1);
	}

	function point$1(curveClass, x, y, defined, p) {
	  let x1 = curveClass._x1,
	    y1 = curveClass._y1,
	    x2 = curveClass._x2,
	    y2 = curveClass._y2;
	  if (curveClass._l01_a > epsilon) {
	    const a = 2 * curveClass._l01_2a + 3 * curveClass._l01_a * curveClass._l12_a + curveClass._l12_2a,
	      n = 3 * curveClass._l01_a * (curveClass._l01_a + curveClass._l12_a);
	    x1 = (x1 * a - curveClass._x0 * curveClass._l12_2a + curveClass._x2 * curveClass._l01_2a) / n, y1 = (y1 * a - curveClass._y0 * curveClass._l12_2a + curveClass._y2 * curveClass._l01_2a) / n;
	  }
	  if (curveClass._l23_a > epsilon) {
	    const b = 2 * curveClass._l23_2a + 3 * curveClass._l23_a * curveClass._l12_a + curveClass._l12_2a,
	      m = 3 * curveClass._l23_a * (curveClass._l23_a + curveClass._l12_a);
	    x2 = (x2 * b + curveClass._x1 * curveClass._l23_2a - x * curveClass._l12_2a) / m, y2 = (y2 * b + curveClass._y1 * curveClass._l23_2a - y * curveClass._l12_2a) / m;
	  }
	  curveClass.context.bezierCurveTo(x1, y1, x2, y2, curveClass._x2, curveClass._y2, defined, curveClass.lastPoint1);
	}
	class CatmullRom {
	  constructor(context, alpha = .5, startPoint) {
	    this.context = context, this.startPoint = startPoint, this._alpha = alpha;
	  }
	  areaStart() {
	    this._line = 0;
	  }
	  areaEnd() {
	    this._line = NaN;
	  }
	  lineStart() {
	    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
	  }
	  lineEnd() {
	    switch (this._point) {
	      case 2:
	        this.context.lineTo(this._x2, this._y2, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
	        break;
	      case 3:
	        this.point({
	          x: this._x2,
	          y: this._y2
	        });
	    }
	    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
	  }
	  point(p) {
	    const {
	      x: x,
	      y: y
	    } = p;
	    if (this._point) {
	      const x23 = this._x2 - x,
	        y23 = this._y2 - y;
	      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	    }
	    switch (this._point) {
	      case 0:
	        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2) : this.context.moveTo(x, y);
	        break;
	      case 1:
	        this._point = 2;
	        break;
	      case 2:
	        this._point = 3;
	      default:
	        point$1(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
	    }
	    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
	  }
	  tryUpdateLength() {
	    return this.context.tryUpdateLength();
	  }
	}
	function commonGenCatmullRomSegments(type, cons) {
	  return function (points, alpha, params = {}) {
	    const {
	      direction: direction,
	      startPoint: startPoint
	    } = params;
	    if (points.length < 2 - Number(!!startPoint)) return null;
	    if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
	    const segContext = genSegContext(type, direction, points),
	      gatmullRom = new cons(segContext, alpha, startPoint);
	    return genCurveSegments(gatmullRom, points, 2), segContext;
	  };
	}
	const genCatmullRomSegments = commonGenCatmullRomSegments("catmullRom", CatmullRom);

	class CatmullRomClosed {
	  constructor(context, alpha = .5, startPoint) {
	    this.context = context, this.startPoint = startPoint, this._alpha = alpha;
	  }
	  areaStart() {
	    this._line = 0;
	  }
	  areaEnd() {
	    this._line = NaN;
	  }
	  lineStart() {
	    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
	  }
	  lineEnd() {
	    switch (this._point) {
	      case 1:
	        this.context.moveTo(this._x3, this._y3, this.lastPoint1), this.context.closePath();
	        break;
	      case 2:
	        this.context.lineTo(this._x3, this._y3, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1), this.context.closePath();
	        break;
	      case 3:
	        this.point({
	          x: this._x3,
	          y: this._y3
	        }), this.point({
	          x: this._x4,
	          y: this._y4
	        }), this.point({
	          x: this._x5,
	          y: this._y5
	        });
	    }
	  }
	  point(p) {
	    const {
	      x: x,
	      y: y
	    } = p;
	    if (this._point) {
	      const x23 = this._x2 - x,
	        y23 = this._y2 - y;
	      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	    }
	    switch (this._point) {
	      case 0:
	        this._point = 1, this._x3 = x, this._y3 = y;
	        break;
	      case 1:
	        this._point = 2, this.context.moveTo(this._x4 = x, this._y4 = y, p);
	        break;
	      case 2:
	        this._point = 3, this._x5 = x, this._y5 = y;
	        break;
	      default:
	        point$1(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
	    }
	    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
	  }
	  tryUpdateLength() {
	    return this.context.tryUpdateLength();
	  }
	}
	const genCatmullRomClosedSegments = commonGenCatmullRomSegments("catmullRomClosed", CatmullRomClosed);

	function divideQuad(curve, t) {
	  const {
	      p0: p0,
	      p1: p1,
	      p2: p2
	    } = curve,
	    pt = quadPointAt(p0, p1, p2, t),
	    c1 = PointService.pointAtPP(p0, p1, t),
	    c2 = PointService.pointAtPP(p1, p2, t);
	  return [new QuadraticBezierCurve(p0, c1, pt), new QuadraticBezierCurve(pt, c2, p2)];
	}
	class QuadraticBezierCurve extends Curve {
	  constructor(p0, p1, p2) {
	    super(), this.type = CurveTypeEnum.QuadraticBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2;
	  }
	  _validPoint() {
	    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y);
	  }
	  getPointAt(t) {
	    if (!1 !== this.defined) return quadPointAt(this.p0, this.p1, this.p2, t);
	    throw new Error("defined为false的点不能getPointAt");
	  }
	  calcLength() {
	    return this._validPoint() ? quadLength(this.p0, this.p1, this.p2) : 60;
	  }
	  calcProjLength(direction) {
	    return direction === Direction.ROW ? abs(this.p0.x - this.p2.x) : direction === Direction.COLUMN ? abs(this.p0.y - this.p2.y) : 0;
	  }
	  getAngleAt(t) {
	    const minT = max(t - .01, 0),
	      maxT = min(t + .01, 1),
	      minP = this.getPointAt(minT),
	      maxP = this.getPointAt(maxT);
	    return atan2(maxP.y - minP.y, maxP.x - minP.x);
	  }
	  draw(path, x, y, sx, sy, percent) {
	    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.quadraticCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y);else if (percent > 0) {
	      const [curve1] = divideQuad(this, percent);
	      path.quadraticCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y);
	    }
	  }
	  getYAt(x) {
	    throw new Error("QuadraticBezierCurve暂不支持getYAt");
	  }
	  includeX(x) {
	    throw new Error("QuadraticBezierCurve暂不支持includeX");
	  }
	}

	class CurveContext {
	  constructor(path) {
	    this.path = path, this._lastX = this._lastY = this._startX = this._startY = 0;
	  }
	  moveTo(x, y) {
	    return this._lastX = this._startX = x, this._lastY = this._startY = y, this;
	  }
	  lineTo(x, y) {
	    const curve = this.addLinearCurve(x, y);
	    this.path.addCurve(curve), this._lastX = x, this._lastY = y;
	  }
	  addLinearCurve(x, y) {
	    return new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
	  }
	  quadraticCurveTo(aCPx, aCPy, aX, aY) {
	    const curve = new QuadraticBezierCurve(new Point(this._lastX, this._lastY), new Point(aCPx, aCPy), new Point(aX, aY));
	    this.path.addCurve(curve), this._lastX = aX, this._lastY = aY;
	  }
	  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
	    const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
	    this.path.addCurve(curve), this._lastX = x, this._lastY = y;
	  }
	  arcTo(aX1, aY1, aX2, aY2, aRadius) {
	    throw new Error("CurveContext不支持调用arcTo");
	  }
	  ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
	    throw new Error("CurveContext不支持调用ellipse");
	  }
	  rect(x, y, w, h) {
	    throw new Error("CurveContext不支持调用rect");
	  }
	  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
	    throw new Error("CurveContext不支持调用arc");
	  }
	  closePath() {
	    this.path.curves.length < 2 || this.lineTo(this._startX, this._startY);
	  }
	}

	function calcLineCache(points, curveType, params) {
	  var _a, _b;
	  switch (curveType) {
	    case "linear":
	    default:
	      return genLinearSegments(points, params);
	    case "basis":
	      return genBasisSegments(points, params);
	    case "monotoneX":
	      return genMonotoneXSegments(points, params);
	    case "monotoneY":
	      return genMonotoneYSegments(points, params);
	    case "step":
	      return genStepSegments(points, .5, params);
	    case "stepClosed":
	      return genStepClosedSegments(points, .5, params);
	    case "stepBefore":
	      return genStepSegments(points, 0, params);
	    case "stepAfter":
	      return genStepSegments(points, 1, params);
	    case "catmullRom":
	      return genCatmullRomSegments(points, null !== (_a = null == params ? void 0 : params.curveTension) && void 0 !== _a ? _a : .5, params);
	    case "catmullRomClosed":
	      return genCatmullRomClosedSegments(points, null !== (_b = null == params ? void 0 : params.curveTension) && void 0 !== _b ? _b : .5, params);
	    case "linearClosed":
	      return genLinearClosedSegments(points, params);
	  }
	}

	class CustomPath2D extends CurvePath {
	  constructor(ctx) {
	    super(), this.commandList = [], ctx && (this._ctx = ctx), this._boundsContext = new BoundsContext(this.bounds);
	  }
	  get curves() {
	    return this.tryBuildCurves();
	  }
	  setCtx(ctx) {
	    this._ctx = ctx;
	  }
	  moveTo(x, y) {
	    return this.commandList.push([enumCommandMap.M, x, y]), this._ctx && this._ctx.moveTo(x, y), this;
	  }
	  lineTo(x, y) {
	    return this.commandList.push([enumCommandMap.L, x, y]), this._ctx && this._ctx.lineTo(x, y), this;
	  }
	  quadraticCurveTo(aCPx, aCPy, aX, aY) {
	    return this.commandList.push([enumCommandMap.Q, aCPx, aCPy, aX, aY]), this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY), this;
	  }
	  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
	    return this.commandList.push([enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]), this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY), this;
	  }
	  arcTo(aX1, aY1, aX2, aY2, aRadius) {
	    return this.commandList.push([enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius]), this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius), this;
	  }
	  ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
	    return this.commandList.push([enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise]), this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise), this;
	  }
	  rect(x, y, w, h) {
	    return this.commandList.push([enumCommandMap.R, x, y, w, h]), this._ctx && this._ctx.rect(x, y, w, h), this;
	  }
	  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
	    return this.commandList.push([enumCommandMap.A, x, y, radius, startAngle, endAngle, counterclockwise]), this._ctx && this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise), this;
	  }
	  closePath() {
	    return this.commandList.push([enumCommandMap.Z]), this._ctx && this._ctx.closePath(), this;
	  }
	  addCurve(curve) {
	    this._curves.push(curve);
	  }
	  clear() {
	    this.transformCbList = null, this.commandList.length = 0, this._curves.length = 0;
	  }
	  beginPath() {
	    this.clear();
	  }
	  tryBuildCurves() {
	    if (!this._curves || !this._curves.length) {
	      const curveContext = new CurveContext(this);
	      renderCommandList(this.commandList, curveContext, 0, 0, 1, 1);
	    }
	    return this._curves;
	  }
	  toString() {
	    if (!this.toStringCbList) {
	      const list = [];
	      list[enumCommandMap.M] = cmd => `M${cmd[1]} ${cmd[2]}`, list[enumCommandMap.L] = cmd => `L${cmd[1]} ${cmd[2]}`, list[enumCommandMap.Q] = cmd => `Q${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`, list[enumCommandMap.C] = cmd => `C${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]} ${cmd[5]} ${cmd[6]}`, list[enumCommandMap.A] = cmd => {
	        const bezierPathList = [],
	          x = cmd[1],
	          y = cmd[2],
	          radius = cmd[3],
	          startAngle = cmd[4],
	          endAngle = cmd[5],
	          counterclockwise = cmd[6];
	        addArcToBezierPath(bezierPathList, startAngle, endAngle, x, y, radius, radius, counterclockwise);
	        let path = "";
	        for (let i = 0; i < bezierPathList.length; i += 6) path += `C${bezierPathList[i]} ${bezierPathList[i + 1]} ${bezierPathList[i + 2]} ${bezierPathList[i + 3]} ${bezierPathList[i + 4]} ${bezierPathList[i + 5]}`;
	        return path;
	      }, list[enumCommandMap.R] = cmd => `M${cmd[1]} ${cmd[2]} h${cmd[3]} v${cmd[4]} H${cmd[1]}Z`, list[enumCommandMap.Z] = cmd => "Z", this.toStringCbList = list;
	    }
	    const list = this.toStringCbList;
	    let path = "";
	    return this.commandList.forEach(c => {
	      path += list[c[0]](c);
	    }), path;
	  }
	  fromString(str, x, y, sX, sY) {
	    this.clear();
	    const commandStrList = parseSvgPath(str);
	    return this._runCommandStrList(commandStrList, x, y, sX, sY), this._updateBounds(), this;
	  }
	  fromLine(line) {
	    const {
	      points: points,
	      curveType: curveType,
	      clipRangeByDimension: clipRangeByDimension
	    } = line.attribute;
	    if (!points) return;
	    const cache = calcLineCache(points, curveType);
	    "x" === clipRangeByDimension ? this.direction = Direction.ROW : "y" === clipRangeByDimension ? this.direction = Direction.COLUMN : "auto" === clipRangeByDimension && (this.direction = cache.direction), this._curves = cache.curves;
	  }
	  fromCustomPath2D(path, x, y, sX, sY) {
	    return this.clear(), this._runCommandList(path.commandList, x, y, sX, sY), this._updateBounds(), this;
	  }
	  transform(x, y, sx, sy) {
	    const commandList = this.commandList;
	    if (!this.transformCbList) {
	      const list = [];
	      list[enumCommandMap.M] = this.moveToTransform, list[enumCommandMap.L] = this.lineToTransform, list[enumCommandMap.Q] = this.quadraticCurveToTransform, list[enumCommandMap.C] = this.bezierCurveToTransform, list[enumCommandMap.AT] = this.arcToTransform, list[enumCommandMap.E] = this.ellipseTransform, list[enumCommandMap.R] = this.rectTransform, list[enumCommandMap.A] = this.arcTransform, list[enumCommandMap.Z] = this.closePathTransform, this.transformCbList = list;
	    }
	    commandList.forEach(cmd => {
	      this.transformCbList[cmd[0]](cmd, x, y, sx, sy);
	    }), this._updateBounds();
	  }
	  moveToTransform(cmd, x, y, sx, sy) {
	    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
	  }
	  lineToTransform(cmd, x, y, sx, sy) {
	    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
	  }
	  quadraticCurveToTransform(cmd, x, y, sx, sy) {
	    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y;
	  }
	  bezierCurveToTransform(cmd, x, y, sx, sy) {
	    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * sx + x, cmd[6] = cmd[6] * sy + y;
	  }
	  arcToTransform(cmd, x, y, sx, sy) {
	    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * (sx + sy) / 2;
	  }
	  ellipseTransform(cmd, x, y, sx, sy) {
	    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
	  }
	  rectTransform(cmd, x, y, sx, sy) {
	    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
	  }
	  arcTransform(cmd, x, y, sx, sy) {
	    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * (sx + sy) / 2;
	  }
	  closePathTransform() {}
	  _runCommandStrList(commandStrList, l = 0, t = 0, sX = 1, sY = 1) {
	    let current,
	      tempX,
	      tempY,
	      tempControlX,
	      tempControlY,
	      previous = null,
	      x = 0,
	      y = 0,
	      controlX = 0,
	      controlY = 0;
	    for (let i = 0, len = commandStrList.length; i < len; ++i) {
	      switch (current = commandStrList[i], 1 === sX && 1 === sY || (current = scale(current, sX, sY)), current[0]) {
	        case "l":
	          x += current[1], y += current[2], this.lineTo(x + l, y + t);
	          break;
	        case "L":
	          x = current[1], y = current[2], this.lineTo(x + l, y + t);
	          break;
	        case "h":
	          x += current[1], this.lineTo(x + l, y + t);
	          break;
	        case "H":
	          x = current[1], this.lineTo(x + l, y + t);
	          break;
	        case "v":
	          y += current[1], this.lineTo(x + l, y + t);
	          break;
	        case "V":
	          y = current[1], this.lineTo(x + l, y + t);
	          break;
	        case "m":
	          x += current[1], y += current[2], this.moveTo(x + l, y + t);
	          break;
	        case "M":
	          x = current[1], y = current[2], this.moveTo(x + l, y + t);
	          break;
	        case "c":
	          tempX = x + current[5], tempY = y + current[6], controlX = x + current[3], controlY = y + current[4], this.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
	          break;
	        case "C":
	          x = current[5], y = current[6], controlX = current[3], controlY = current[4], this.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
	          break;
	        case "s":
	          tempX = x + current[3], tempY = y + current[4], null === previous[0].match(/[CcSs]/) ? (controlX = x, controlY = y) : (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = x + current[1], tempControlY = y + current[2], this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t), controlX = tempControlX, controlY = tempControlY, x = tempX, y = tempY;
	          break;
	        case "S":
	          tempX = current[3], tempY = current[4], null === previous[0].match(/[CcSs]/) ? (controlX = x, controlY = y) : (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = current[1], tempControlY = current[2], this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t), controlX = tempControlX, controlY = tempControlY, x = tempX, y = tempY;
	          break;
	        case "q":
	          tempX = x + current[3], tempY = y + current[4], controlX = x + current[1], controlY = y + current[2], this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
	          break;
	        case "Q":
	          tempX = current[3], tempY = current[4], this.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = current[1], controlY = current[2];
	          break;
	        case "t":
	          tempX = x + current[1], tempY = y + current[2], null === previous[0].match(/[QqTt]/) ? (controlX = x, controlY = y) : "t" === previous[0] ? (controlX = 2 * x - tempControlX, controlY = 2 * y - tempControlY) : "q" === previous[0] && (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = controlX, tempControlY = controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = x + current[1], controlY = y + current[2];
	          break;
	        case "T":
	          tempX = current[1], tempY = current[2], controlX = 2 * x - controlX, controlY = 2 * y - controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
	          break;
	        case "a":
	          drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]), x += current[6], y += current[7];
	          break;
	        case "A":
	          drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]), x = current[6], y = current[7];
	          break;
	        case "z":
	        case "Z":
	          this.closePath();
	      }
	      previous = current;
	    }
	  }
	  _runCommandList(commandList, l = 0, t = 0, sX = 1, sY = 1) {
	    if (0 !== l || 0 !== t || 1 !== sX || 1 !== sY) for (let i = 0, len = commandList.length; i < len; ++i) {
	      const current = commandList[i].slice();
	      switch (current[0]) {
	        case enumCommandMap.L:
	          this.lineToTransform(current, l, t, sX, sY);
	          break;
	        case enumCommandMap.M:
	          this.moveToTransform(current, l, t, sX, sY);
	          break;
	        case enumCommandMap.C:
	          this.bezierCurveToTransform(current, l, t, sX, sY);
	          break;
	        case enumCommandMap.Q:
	          this.quadraticCurveToTransform(current, l, t, sX, sY);
	          break;
	        case enumCommandMap.A:
	          this.arcToTransform(current, l, t, sX, sY);
	          break;
	        case enumCommandMap.E:
	          this.ellipseTransform(current, l, t, sX, sY);
	          break;
	        case enumCommandMap.R:
	          this.rectTransform(current, l, t, sX, sY);
	          break;
	        case enumCommandMap.AT:
	          this.arcToTransform(current, l, t, sX, sY);
	          break;
	        case enumCommandMap.Z:
	          this.closePath();
	      }
	    } else this.commandList = commandList.map(entry => entry.slice());
	  }
	  _updateBounds() {
	    this.bounds.clear(), renderCommandList(this.commandList, this._boundsContext);
	  }
	  release() {
	    this.commandList = [], this._boundsContext = null, this._ctx = null;
	  }
	  getLength() {
	    if (this.direction === Direction.COLUMN) {
	      if (!this._curves.length) return 0;
	      const sc = this._curves[0],
	        ec = this._curves[this._curves.length - 1];
	      return abs(sc.p0.y - ec.p1.y);
	    }
	    if (this.direction === Direction.ROW) {
	      if (!this._curves.length) return 0;
	      const sc = this._curves[0],
	        ec = this._curves[this._curves.length - 1];
	      return abs(sc.p0.x - ec.p1.x);
	    }
	    return this._curves.reduce((l, c) => l + c.getLength(), 0);
	  }
	  getYAt(x) {
	    if (!this.curves) return 1 / 0;
	    for (let i = 0; i < this.curves.length; i++) {
	      const curve = this.curves[i];
	      if (curve.includeX(x)) return curve.getYAt(x);
	    }
	    return 1 / 0;
	  }
	  getAttrAt(distance) {
	    if (!this._curves) return {
	      pos: {
	        x: 0,
	        y: 0
	      },
	      angle: 0
	    };
	    let curve,
	      _dis = 0;
	    for (let i = 0; i < this._curves.length; i++) {
	      curve = this._curves[i];
	      const cl = curve.getLength(this.direction);
	      if (_dis + cl >= distance) break;
	      _dis += cl;
	    }
	    const t = (distance - _dis) / curve.getLength(this.direction);
	    return {
	      pos: curve.getPointAt(t),
	      angle: curve.getAngleAt(t)
	    };
	  }
	  drawWithClipRange(ctx, size, x, y, clipRange) {
	    this.tryBuildCurves();
	    const totalLen = this.getLength() * clipRange;
	    let currLen = 0;
	    for (let i = 0; i < this._curves.length; i++) {
	      const curve = this._curves[i],
	        cl = curve.getLength(this.direction);
	      if (!(currLen + cl <= totalLen)) {
	        const percent = 1 - (currLen + cl - totalLen) / cl;
	        curve.draw(ctx, x, y, size, size, percent);
	        break;
	      }
	      curve.draw(ctx, x, y, size, size, 1), currLen += cl;
	    }
	  }
	}
	const temp = ["l", 0, 0, 0, 0, 0, 0, 0];
	function scale(current, sX, sY) {
	  const c = temp[0] = current[0];
	  if ("a" === c || "A" === c) temp[1] = sX * current[1], temp[2] = sY * current[2], temp[3] = current[3], temp[4] = current[4], temp[5] = current[5], temp[6] = sX * current[6], temp[7] = sY * current[7];else if ("h" === c || "H" === c) temp[1] = sX * current[1];else if ("v" === c || "V" === c) temp[1] = sY * current[1];else for (let i = 1, n = current.length; i < n; ++i) temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
	  return temp;
	}

	const DefaultLayout = {
	  alignSelf: "auto"
	};
	const DefaultTransform = {
	  x: 0,
	  y: 0,
	  z: 0,
	  dx: 0,
	  dy: 0,
	  dz: 0,
	  scrollX: 0,
	  scrollY: 0,
	  scaleX: 1,
	  scaleY: 1,
	  scaleZ: 1,
	  angle: 0,
	  alpha: 0,
	  beta: 0,
	  scaleCenter: [0, 0],
	  anchor: [0, 0],
	  anchor3d: [0, 0],
	  postMatrix: new Matrix()
	};
	const DefaultFillStyle = {
	  fillOpacity: 1,
	  fill: !1,
	  shadowBlur: 0,
	  shadowColor: "black",
	  shadowOffsetX: 0,
	  shadowOffsetY: 0
	};
	const commonStroke = {
	  strokeOpacity: 1,
	  lineDash: [],
	  lineDashOffset: 0,
	  lineWidth: 1,
	  lineCap: "butt",
	  lineJoin: "miter",
	  miterLimit: 10,
	  strokeBoundsBuffer: 2,
	  stroke: !1
	};
	const DefaultStrokeStyle = Object.assign({
	  outerBorder: Object.assign(Object.assign({}, commonStroke), {
	    distance: 0
	  }),
	  innerBorder: Object.assign(Object.assign({}, commonStroke), {
	    distance: 0
	  })
	}, commonStroke);
	const DefaultTextStyle = {
	  text: "",
	  maxLineWidth: 1 / 0,
	  maxWidth: 1 / 0,
	  textAlign: "left",
	  textBaseline: "alphabetic",
	  fontSize: 16,
	  fontFamily: "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
	  fontWeight: "",
	  ellipsis: "…",
	  fontVariant: "",
	  fontStyle: "",
	  lineHeight: void 0,
	  underline: 0,
	  lineThrough: 0,
	  scaleIn3d: !1,
	  direction: "horizontal",
	  wordBreak: "break-all",
	  ignoreBuf: !1,
	  verticalMode: 0,
	  wrap: !1,
	  whiteSpace: "no-wrap",
	  heightLimit: 1 / 0,
	  lineClamp: 1 / 0,
	  suffixPosition: "end",
	  underlineDash: [],
	  underlineOffset: 0,
	  disableAutoClipedPoptip: void 0,
	  measureMode: MeasureModeEnum.fontBounding,
	  keepCenterInLine: !1
	};
	const DefaultPickStyle = {
	  pickStrokeBuffer: 0
	};
	const DefaultStyle = Object.assign(Object.assign(Object.assign(Object.assign({
	  forceBoundsWidth: void 0,
	  forceBoundsHeight: void 0,
	  opacity: 1,
	  background: null,
	  autoAnimateTexture: !1,
	  textureRatio: 1,
	  textureOptions: null,
	  backgroundOpacity: 1,
	  backgroundCornerRadius: 0,
	  texture: null,
	  textureColor: "black",
	  textureSize: 10,
	  texturePadding: 2,
	  backgroundMode: "no-repeat",
	  backgroundFit: !0,
	  backgroundKeepAspectRatio: !1,
	  backgroundClip: !0,
	  backgroundScale: 1,
	  backgroundOffsetX: 0,
	  backgroundOffsetY: 0,
	  blur: 0,
	  filter: "",
	  cursor: null,
	  html: null,
	  react: null,
	  vue: null
	}, DefaultFillStyle), DefaultStrokeStyle), DefaultLayout), DefaultPickStyle);
	const DefaultConnectAttribute = {
	  connectedType: "none",
	  connectedStyle: {},
	  connectedX: NaN,
	  connectedY: NaN
	};
	const DefaultDebugAttribute = {
	  _debug_bounds: !1
	};
	const DefaultAttribute = Object.assign(Object.assign(Object.assign({
	  strokeSeg: null,
	  renderable: !0,
	  pickable: !0,
	  shadowGraphic: void 0,
	  childrenPickable: !0,
	  fillPickable: !0,
	  strokePickable: !0,
	  visible: !0,
	  zIndex: 0,
	  layout: null,
	  boundsPadding: 0,
	  fillStrokeOrder: 0,
	  renderStyle: "default",
	  pickMode: "accurate",
	  customPickShape: null,
	  boundsMode: "accurate",
	  keepDirIn3d: !0,
	  shadowRootIdx: 1,
	  globalZIndex: 1,
	  globalCompositeOperation: "",
	  overflow: "hidden",
	  shadowPickMode: "graphic",
	  keepStrokeScale: !1,
	  clipConfig: null,
	  roughStyle: null
	}, DefaultDebugAttribute), DefaultStyle), DefaultTransform);
	const DefaultArcAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
	  startAngle: 0,
	  endAngle: pi2,
	  innerRadius: 0,
	  outerRadius: 1,
	  innerPadding: 0,
	  outerPadding: 0,
	  cornerRadius: 0,
	  padRadius: 0,
	  padAngle: 0,
	  cap: !1,
	  forceShowCap: !1
	});
	const DefaultAreaAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
	  points: [],
	  segments: [],
	  curveType: "linear",
	  clipRange: 1,
	  closePath: !1,
	  curveTension: 1
	});
	const DefaultCircleAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
	  radius: 1,
	  startAngle: 0,
	  endAngle: pi2
	});
	const DefaultGroupAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
	  width: 0,
	  height: 0,
	  cornerRadius: 0,
	  path: [],
	  clip: !1,
	  visibleAll: !0,
	  display: "relative",
	  flexDirection: "row",
	  flexWrap: "wrap",
	  justifyContent: "flex-start",
	  alignItems: "flex-start",
	  alignContent: "flex-start",
	  baseOpacity: 1,
	  cornerType: "round"
	});
	const DefaultGlyphAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
	  path: "",
	  width: 0,
	  height: 0,
	  cornerRadius: 0,
	  clip: !1
	});
	const DefaultLineAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
	  points: [],
	  segments: [],
	  curveType: "linear",
	  clipRange: 1,
	  clipRangeByDimension: "default",
	  closePath: !1,
	  curveTension: 1
	});
	const DefaultPathAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
	  path: new CustomPath2D(),
	  fillStrokeOrder: 1,
	  clipRange: 1,
	  customPath: () => {
	    Logger.getInstance().warn("空函数");
	  }
	});
	const DefaultPolygonAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
	  points: [],
	  cornerRadius: 0,
	  closePath: !0
	});
	const DefaultStarAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
	  width: 100,
	  height: 100,
	  spikes: 5,
	  thickness: .5
	});
	const DefaultRectAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
	  width: 0,
	  height: 0,
	  x1: 0,
	  y1: 0,
	  strokeBoundsBuffer: 0,
	  cornerRadius: 0,
	  cornerType: "round",
	  drawStrokeWhenZeroWH: !1
	});
	Object.assign(Object.assign({}, DefaultAttribute), {
	  width: 0,
	  height: 0,
	  x1: 0,
	  y1: 0,
	  cornerRadius: 0,
	  length: 0,
	  cornerType: "round",
	  drawStrokeWhenZeroWH: !1
	});
	const DefaultSymbolAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
	  symbolType: "circle",
	  size: 10,
	  keepDirIn3d: !0,
	  clipRange: 1
	});
	const DefaultTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
	  strokeBoundsBuffer: 0,
	  keepDirIn3d: !0
	});
	const DefaultRichTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
	  upgradeAttrs: null,
	  editable: !1,
	  editOptions: null,
	  ascentDescentMode: "actual",
	  width: 300,
	  height: 300,
	  ellipsis: !0,
	  wordBreak: "break-word",
	  verticalDirection: "top",
	  textAlign: "left",
	  textBaseline: "top",
	  layoutDirection: "horizontal",
	  textConfig: [],
	  disableAutoWrapLine: !1,
	  maxHeight: void 0,
	  maxWidth: void 0,
	  singleLine: !1
	});
	const DefaultImageAttribute = Object.assign(Object.assign({
	  repeatX: "no-repeat",
	  repeatY: "no-repeat",
	  image: "",
	  width: 0,
	  height: 0,
	  maxWidth: 500,
	  maxHeight: 500
	}, DefaultAttribute), {
	  fill: !0,
	  cornerRadius: 0,
	  cornerType: "round"
	});
	const DefaultRichTextIconAttribute = Object.assign(Object.assign({}, DefaultImageAttribute), {
	  backgroundShowMode: "never",
	  backgroundWidth: 0,
	  backgroundHeight: 0,
	  textAlign: "left",
	  textBaseline: "middle",
	  direction: "horizontal",
	  margin: 0,
	  id: "",
	  width: 20,
	  height: 20,
	  backgroundFill: "rgba(101, 117, 168, 0.1)",
	  backgroundFillOpacity: 1,
	  backgroundStroke: !1,
	  backgroundStrokeOpacity: 1,
	  backgroundRadius: 4,
	  opacity: 1
	});

	const parse = function () {
	  const tokens = {
	    linearGradient: /^(linear\-gradient)/i,
	    radialGradient: /^(radial\-gradient)/i,
	    conicGradient: /^(conic\-gradient)/i,
	    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
	    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
	    positionKeywords: /^(left|center|right|top|bottom)/i,
	    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
	    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
	    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
	    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
	    fromAngleValue: /^from\s*(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
	    startCall: /^\(/,
	    endCall: /^\)/,
	    comma: /^,/,
	    hexColor: /(^\#[0-9a-fA-F]+)/,
	    literalColor: /^([a-zA-Z]+)/,
	    rgbColor: /^(rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))/i,
	    rgbaColor: /^(rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*((\d\.\d+)|\d{1,3})\))/i,
	    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
	  };
	  let input = "";
	  function error(msg) {
	    const err = new Error(input + ": " + msg);
	    throw err.source = input, err;
	  }
	  function getAST() {
	    const ast = matchListing(matchDefinition);
	    return input.length > 0 && error("Invalid input not EOF"), ast;
	  }
	  function matchDefinition() {
	    return matchGradient("linear", tokens.linearGradient, matchLinearOrientation) || matchGradient("radial", tokens.radialGradient, matchListRadialOrientations) || matchGradient("conic", tokens.conicGradient, matchConicalOrientation);
	  }
	  function matchGradient(gradientType, pattern, orientationMatcher) {
	    return function (pattern, callback) {
	      const captures = scan(pattern);
	      if (captures) {
	        scan(tokens.startCall) || error("Missing (");
	        const result = callback(captures);
	        return scan(tokens.endCall) || error("Missing )"), result;
	      }
	    }(pattern, function (captures) {
	      const orientation = orientationMatcher();
	      return orientation && (scan(tokens.comma) || error("Missing comma before color stops")), {
	        type: gradientType,
	        orientation: orientation,
	        colorStops: matchListing(matchColorStop)
	      };
	    });
	  }
	  function matchLinearOrientation() {
	    return match("directional", tokens.sideOrCorner, 1) || match("angular", tokens.angleValue, 1);
	  }
	  function matchConicalOrientation() {
	    return match("angular", tokens.fromAngleValue, 1);
	  }
	  function matchListRadialOrientations() {
	    let radialOrientations,
	      lookaheadCache,
	      radialOrientation = matchRadialOrientation();
	    return radialOrientation && (radialOrientations = [], radialOrientations.push(radialOrientation), lookaheadCache = input, scan(tokens.comma) && (radialOrientation = matchRadialOrientation(), radialOrientation ? radialOrientations.push(radialOrientation) : input = lookaheadCache)), radialOrientations;
	  }
	  function matchRadialOrientation() {
	    let radialType = function () {
	      const circle = match("shape", /^(circle)/i, 0);
	      circle && (circle.style = matchLength() || matchExtentKeyword());
	      return circle;
	    }() || function () {
	      const ellipse = match("shape", /^(ellipse)/i, 0);
	      ellipse && (ellipse.style = matchDistance() || matchExtentKeyword());
	      return ellipse;
	    }();
	    if (radialType) radialType.at = matchAtPosition();else {
	      const extent = matchExtentKeyword();
	      if (extent) {
	        radialType = extent;
	        const positionAt = matchAtPosition();
	        positionAt && (radialType.at = positionAt);
	      } else {
	        const defaultPosition = matchPositioning();
	        defaultPosition && (radialType = {
	          type: "default-radial",
	          at: defaultPosition
	        });
	      }
	    }
	    return radialType;
	  }
	  function matchExtentKeyword() {
	    return match("extent-keyword", tokens.extentKeywords, 1);
	  }
	  function matchAtPosition() {
	    if (match("position", /^at/, 0)) {
	      const positioning = matchPositioning();
	      return positioning || error("Missing positioning value"), positioning;
	    }
	  }
	  function matchPositioning() {
	    const location = {
	      x: matchDistance(),
	      y: matchDistance()
	    };
	    if (location.x || location.y) return {
	      type: "position",
	      value: location
	    };
	  }
	  function matchListing(matcher) {
	    let captures = matcher();
	    const result = [];
	    if (captures) for (result.push(captures); scan(tokens.comma);) captures = matcher(), captures ? result.push(captures) : error("One extra comma");
	    return result;
	  }
	  function matchColorStop() {
	    const color = match("hex", tokens.hexColor, 1) || match("rgba", tokens.rgbaColor, 1) || match("rgb", tokens.rgbColor, 1) || match("literal", tokens.literalColor, 0);
	    return color || error("Expected color definition"), color.length = matchDistance(), color;
	  }
	  function matchDistance() {
	    return match("%", tokens.percentageValue, 1) || match("position-keyword", tokens.positionKeywords, 1) || matchLength();
	  }
	  function matchLength() {
	    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
	  }
	  function match(type, pattern, captureIndex) {
	    const captures = scan(pattern);
	    if (captures) return {
	      type: type,
	      value: captures[captureIndex]
	    };
	  }
	  function scan(regexp) {
	    const blankCaptures = /^[\n\r\t\s]+/.exec(input);
	    blankCaptures && consume(blankCaptures[0].length);
	    const captures = regexp.exec(input);
	    return captures && consume(captures[0].length), captures;
	  }
	  function consume(size) {
	    input = input.substr(size);
	  }
	  return function (code) {
	    return input = code.toString(), getAST();
	  };
	}();
	class GradientParser {
	  static IsGradient(c) {
	    return !("string" == typeof c && !c.includes("gradient"));
	  }
	  static IsGradientStr(c) {
	    return "string" == typeof c && c.includes("gradient");
	  }
	  static Parse(c) {
	    if (GradientParser.IsGradientStr(c)) try {
	      const datum = parse(c)[0];
	      if (datum) {
	        if ("linear" === datum.type) return GradientParser.ParseLinear(datum);
	        if ("radial" === datum.type) return GradientParser.ParseRadial(datum);
	        if ("conic" === datum.type) return GradientParser.ParseConic(datum);
	      }
	    } catch (err) {
	      return c;
	    }
	    return c;
	  }
	  static processColorStops(colorStops) {
	    if (!colorStops || 0 === colorStops.length) return [];
	    if (colorStops.some(item => item.length)) {
	      const stops = colorStops.map(item => ({
	        color: item.value,
	        offset: item.length ? parseFloat(item.length.value) / 100 : -1
	      }));
	      stops[0].offset < 0 && (stops[0].offset = 0), stops[stops.length - 1].offset < 0 && (stops[stops.length - 1].offset = 1);
	      for (let i = 1; i < stops.length - 1; i++) if (stops[i].offset < 0) {
	        const prevWithOffsetIdx = i - 1;
	        let nextWithOffsetIdx = i + 1;
	        for (; nextWithOffsetIdx < stops.length && stops[nextWithOffsetIdx].offset < 0;) nextWithOffsetIdx++;
	        const startOffset = stops[prevWithOffsetIdx].offset,
	          endOffset = stops[nextWithOffsetIdx].offset,
	          unspecCount = nextWithOffsetIdx - prevWithOffsetIdx;
	        for (let j = 1; j < unspecCount; j++) stops[prevWithOffsetIdx + j].offset = startOffset + (endOffset - startOffset) * j / unspecCount;
	        i = nextWithOffsetIdx - 1;
	      }
	      return stops;
	    }
	    return colorStops.map((item, index) => {
	      const offset = colorStops.length > 1 ? index / (colorStops.length - 1) : 0;
	      return {
	        color: item.value,
	        offset: offset
	      };
	    });
	  }
	  static ParseConic(datum) {
	    const {
	        orientation: orientation,
	        colorStops = []
	      } = datum,
	      halfPi = pi / 2,
	      sa = parseFloat(orientation.value) / 180 * pi - halfPi;
	    return {
	      gradient: "conical",
	      x: .5,
	      y: .5,
	      startAngle: sa,
	      endAngle: sa + pi2,
	      stops: GradientParser.processColorStops(colorStops)
	    };
	  }
	  static ParseRadial(datum) {
	    const {
	      colorStops = []
	    } = datum;
	    return {
	      gradient: "radial",
	      x0: .5,
	      y0: .5,
	      x1: .5,
	      y1: .5,
	      r0: 0,
	      r1: 1,
	      stops: GradientParser.processColorStops(colorStops)
	    };
	  }
	  static ParseLinear(datum) {
	    const {
	        orientation: orientation,
	        colorStops = []
	      } = datum,
	      halfPi = pi / 2;
	    let angle = "angular" === orientation.type ? parseFloat(orientation.value) / 180 * pi : 0;
	    for (; angle < 0;) angle += pi2;
	    for (; angle >= pi2;) angle -= pi2;
	    let x0 = 0,
	      y0 = 0,
	      x1 = 0,
	      y1 = 0;
	    return angle < halfPi ? (x0 = 0, y0 = 1, x1 = Math.sin(angle), y1 = y0 - Math.cos(angle)) : angle < pi ? (x0 = 0, y0 = 0, x1 = Math.cos(angle - halfPi), y1 = Math.sin(angle - halfPi)) : angle < pi + halfPi ? (x0 = 1, y0 = 0, x1 = x0 - Math.sin(angle - pi), y1 = Math.cos(angle - pi)) : (x0 = 1, x1 = x0 - Math.cos(angle - halfPi - pi), y1 -= Math.sin(angle - halfPi - pi)), {
	      gradient: "linear",
	      x0: x0,
	      y0: y0,
	      x1: x1,
	      y1: y1,
	      stops: GradientParser.processColorStops(colorStops)
	    };
	  }
	}

	function getScaledStroke(context, width, dpr) {
	  let strokeWidth = width;
	  const {
	      a: a,
	      b: b,
	      c: c,
	      d: d
	    } = context.currentMatrix,
	    scaleX = Math.sign(a) * Math.sqrt(a * a + b * b),
	    scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);
	  return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, strokeWidth);
	}
	function createColor(context, c, params, offsetX = 0, offsetY = 0) {
	  var _a, _b, _c, _d;
	  if (!c || !0 === c) return "black";
	  let result, color;
	  if (isArray$1(c)) for (let i = 0; i < c.length && (color = c[i], !color); i++);else color = c;
	  if (color = GradientParser.Parse(color), "string" == typeof color) return color;
	  if (params.AABBBounds && (!params.attribute || 0 !== params.attribute.scaleX || 0 !== params.attribute.scaleY)) {
	    const bounds = params.AABBBounds;
	    let w = bounds.x2 - bounds.x1,
	      h = bounds.y2 - bounds.y1,
	      x = bounds.x1 - offsetX,
	      y = bounds.y1 - offsetY;
	    if (params.attribute) {
	      const {
	        scaleX = 1,
	        scaleY = 1,
	        angle = 0
	      } = params.attribute;
	      w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY, (angle || 1 !== scaleX || 1 !== scaleY) && (x = null !== (_a = params.x1WithoutTransform) && void 0 !== _a ? _a : 0, y = null !== (_b = params.y1WithoutTransform) && void 0 !== _b ? _b : 0, w = null !== (_c = params.widthWithoutTransform) && void 0 !== _c ? _c : w, h = null !== (_d = params.heightWithoutTransform) && void 0 !== _d ? _d : h);
	    }
	    "linear" === color.gradient ? result = createLinearGradient(context, color, x, y, w, h) : "conical" === color.gradient ? result = createConicGradient(context, color, x, y, w, h) : "radial" === color.gradient && (result = createRadialGradient(context, color, x, y, w, h));
	  }
	  return result || "orange";
	}
	function createLinearGradient(context, color, x, y, w, h) {
	  var _a, _b, _c, _d;
	  const canvasGradient = context.createLinearGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h, x + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w, y + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h);
	  return color.stops.forEach(stop => {
	    canvasGradient.addColorStop(stop.offset, stop.color);
	  }), canvasGradient;
	}
	function createRadialGradient(context, color, x, y, w, h) {
	  var _a, _b, _c, _d, _e, _f;
	  const canvasGradient = context.createRadialGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : .5) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : .5) * h, Math.max(w, h) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x + (null !== (_d = color.x1) && void 0 !== _d ? _d : .5) * w, y + (null !== (_e = color.y1) && void 0 !== _e ? _e : .5) * h, Math.max(w, h) * (null !== (_f = color.r1) && void 0 !== _f ? _f : .5));
	  return color.stops.forEach(stop => {
	    canvasGradient.addColorStop(stop.offset, stop.color);
	  }), canvasGradient;
	}
	function createConicGradient(context, color, x, y, w, h) {
	  var _a, _b;
	  const canvasGradient = context.createConicGradient(x + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h, color.startAngle, color.endAngle);
	  return color.stops.forEach(stop => {
	    canvasGradient.addColorStop(stop.offset, stop.color);
	  }), canvasGradient.GetPattern ? canvasGradient.GetPattern(w + x, h + y, undefined) : canvasGradient;
	}

	const DIRECTION_KEY = {
	  horizontal: {
	    width: "width",
	    height: "height",
	    left: "left",
	    top: "top",
	    x: "x",
	    y: "y",
	    bottom: "bottom"
	  },
	  vertical: {
	    width: "height",
	    height: "width",
	    left: "top",
	    top: "left",
	    x: "y",
	    y: "x",
	    bottom: "right"
	  }
	};
	const defaultFormatting = {
	    fontSize: 16,
	    fontFamily: DEFAULT_TEXT_FONT_FAMILY$1,
	    fill: !0,
	    stroke: !1,
	    fontWeight: "normal",
	    lineHeight: "normal",
	    fontStyle: "normal",
	    textDecoration: "none",
	    textAlign: "left",
	    script: "normal"
	  };
	const regLetter = /\w|\(|\)|-/;
	const regPunctuation = /[.?!,;:/，。？！、；：]/;
	const regFirstSpace = /\S/;
	const setTextStyle = (ctx, character) => {
	  let fontSize = character.fontSize || 16;
	  switch (character.script) {
	    case "super":
	    case "sub":
	      fontSize *= .8;
	  }
	  ctx.setTextStyle({
	    textAlign: "left",
	    textBaseline: character.textBaseline || "alphabetic",
	    fontStyle: character.fontStyle || "",
	    fontWeight: character.fontWeight || "",
	    fontSize: fontSize,
	    fontFamily: character.fontFamily
	  });
	};
	function applyFillStyle(ctx, character, b) {
	  const fillStyle = character && character.fill || defaultFormatting.fill;
	  if (!fillStyle) return void (ctx.globalAlpha = 0);
	  const {
	    fillOpacity = 1,
	    opacity = 1
	  } = character;
	  ctx.globalAlpha = fillOpacity * opacity, ctx.fillStyle = b ? createColor(ctx, fillStyle, {
	    AABBBounds: b
	  }) : fillStyle, setTextStyle(ctx, character);
	}
	function applyStrokeStyle(ctx, character) {
	  const strokeStyle = character && character.stroke || defaultFormatting.stroke;
	  if (!strokeStyle) return void (ctx.globalAlpha = 0);
	  const {
	    strokeOpacity = 1,
	    opacity = 1
	  } = character;
	  ctx.globalAlpha = strokeOpacity * opacity, ctx.lineWidth = character && "number" == typeof character.lineWidth ? character.lineWidth : 1, ctx.strokeStyle = strokeStyle, setTextStyle(ctx, character);
	}
	function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
	  if (desc.length <= 1) return 0;
	  if (!width || width <= 0) return 0;
	  const textMeasure = application.graphicUtil.textMeasure;
	  let index = guessIndex,
	    temp = desc.slice(0, index),
	    tempWidth = Math.floor(textMeasure.measureText(temp, character).width),
	    tempNext = desc.slice(0, index + 1),
	    tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
	  for (; tempWidth > width || tempWidthNext <= width;) {
	    if (tempWidth > width ? index-- : index++, index > desc.length) {
	      index = desc.length;
	      break;
	    }
	    if (index < 0) {
	      index = 0;
	      break;
	    }
	    temp = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
	  }
	  return needTestLetter && (index = testLetter(desc, index)), index;
	}
	function testLetter(string, index, negativeWrongMatch = !1) {
	  let i = index;
	  for (; regLetter.test(string[i - 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]);) if (i--, i <= 0) return negativeWrongMatch ? testLetter2(string, index) : index;
	  return i;
	}
	function testLetter2(string, index) {
	  let i = index;
	  for (; regLetter.test(string[i + 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]);) if (i++, i >= string.length) return i;
	  return i + 1;
	}
	function measureTextCanvas(text, character, mode = "actual") {
	  var _a;
	  if ("" === text) return {
	    ascent: 0,
	    height: 0,
	    descent: 0,
	    width: 0
	  };
	  const measurement = application.graphicUtil.textMeasure.measureText(text, character),
	    result = {
	      ascent: 0,
	      height: 0,
	      descent: 0,
	      width: 0
	    },
	    ascent = "actual" === mode ? measurement.actualBoundingBoxAscent : measurement.fontBoundingBoxAscent,
	    descent = "actual" === mode ? measurement.actualBoundingBoxDescent : measurement.fontBoundingBoxDescent;
	  "number" != typeof ascent || "number" != typeof descent ? (result.width = Math.floor(measurement.width), result.height = character.fontSize || 0, result.ascent = result.height, result.descent = 0) : (result.width = Math.floor(measurement.width), result.height = Math.floor(ascent + descent), result.ascent = Math.floor(ascent), result.descent = result.height - result.ascent);
	  const space = null !== (_a = character.space) && void 0 !== _a ? _a : 0;
	  return result.width += space, result;
	}

	const container = new Container();

	const CanvasFactory = Symbol.for("CanvasFactory");

	function wrapCanvas(params) {
	  return container.getNamed(CanvasFactory, application.global.env)(params);
	}
	const EPSILON_NUMERIC = 1e-4,
	  THREE_SQRT = Math.sqrt(3),
	  ONE_THIRD = 1 / 3;
	function isAroundZero(val) {
	  return val > -EPSILON && val < EPSILON;
	}
	function isNotAroundZero(val) {
	  return val > EPSILON || val < -EPSILON;
	}
	const _v0 = [0, 0],
	  _v1 = [0, 0],
	  _v2 = [0, 0];
	function distanceSquare(v1, v2) {
	  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	}
	function quadraticAt(p0, p1, p2, t) {
	  const onet = 1 - t;
	  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	}
	function cubicAt(p0, p1, p2, p3, t) {
	  const onet = 1 - t;
	  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
	}
	function quadraticRootAt(p0, p1, p2, val, roots) {
	  const a = p0 - 2 * p1 + p2,
	    b = 2 * (p1 - p0),
	    c = p0 - val;
	  let n = 0;
	  if (isAroundZero(a)) {
	    if (isNotAroundZero(b)) {
	      const t1 = -c / b;
	      t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
	    }
	  } else {
	    const disc = b * b - 4 * a * c;
	    if (isAroundZero(disc)) {
	      const t1 = -b / (2 * a);
	      t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
	    } else if (disc > 0) {
	      const discSqrt = Math.sqrt(disc),
	        t1 = (-b + discSqrt) / (2 * a),
	        t2 = (-b - discSqrt) / (2 * a);
	      t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);
	    }
	  }
	  return n;
	}
	function quadraticExtremum(p0, p1, p2) {
	  const divider = p0 + p2 - 2 * p1;
	  return 0 === divider ? .5 : (p0 - p1) / divider;
	}
	function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
	  let t = 0,
	    interval = .005,
	    d = 1 / 0;
	  _v0[0] = x, _v0[1] = y;
	  for (let _t = 0; _t < 1; _t += .05) {
	    _v1[0] = quadraticAt(x0, x1, x2, _t), _v1[1] = quadraticAt(y0, y1, y2, _t);
	    const d1 = distanceSquare(_v0, _v1);
	    d1 < d && (t = _t, d = d1);
	  }
	  d = 1 / 0;
	  for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) {
	    const prev = t - interval,
	      next = t + interval;
	    _v1[0] = quadraticAt(x0, x1, x2, prev), _v1[1] = quadraticAt(y0, y1, y2, prev);
	    const d1 = distanceSquare(_v1, _v0);
	    if (prev >= 0 && d1 < d) t = prev, d = d1;else {
	      _v2[0] = quadraticAt(x0, x1, x2, next), _v2[1] = quadraticAt(y0, y1, y2, next);
	      const d2 = distanceSquare(_v2, _v0);
	      next <= 1 && d2 < d ? (t = next, d = d2) : interval *= .5;
	    }
	  }
	  return out && (out[0] = quadraticAt(x0, x1, x2, t), out[1] = quadraticAt(y0, y1, y2, t)), Math.sqrt(d);
	}
	function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
	  let prev,
	    next,
	    d1,
	    d2,
	    t = 0,
	    interval = .005,
	    d = 1 / 0;
	  _v0[0] = x, _v0[1] = y;
	  for (let _t = 0; _t < 1; _t += .05) _v1[0] = cubicAt(x0, x1, x2, x3, _t), _v1[1] = cubicAt(y0, y1, y2, y3, _t), d1 = distanceSquare(_v0, _v1), d1 < d && (t = _t, d = d1);
	  d = 1 / 0;
	  for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) prev = t - interval, next = t + interval, _v1[0] = cubicAt(x0, x1, x2, x3, prev), _v1[1] = cubicAt(y0, y1, y2, y3, prev), d1 = distanceSquare(_v1, _v0), prev >= 0 && d1 < d ? (t = prev, d = d1) : (_v2[0] = cubicAt(x0, x1, x2, x3, next), _v2[1] = cubicAt(y0, y1, y2, y3, next), d2 = distanceSquare(_v2, _v0), next <= 1 && d2 < d ? (t = next, d = d2) : interval *= .5);
	  return out && (out[0] = cubicAt(x0, x1, x2, x3, t), out[1] = cubicAt(y0, y1, y2, y3, t)), Math.sqrt(d);
	}
	function normalizeRadian(angle) {
	  return (angle %= pi2) < 0 && (angle += pi2), angle;
	}
	function containQuadStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	  if (0 === lineWidth) return !1;
	  const _l = lineWidth;
	  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) return !1;
	  return quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null) <= _l / 2;
	}
	function containCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	  if (0 === lineWidth) return !1;
	  const _l = lineWidth;
	  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) return !1;
	  return cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null) <= _l / 2;
	}
	function containArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
	  if (0 === lineWidth) return !1;
	  const _l = lineWidth;
	  x -= cx, y -= cy;
	  const d = Math.sqrt(x * x + y * y);
	  if (d - _l > r || d + _l < r) return !1;
	  if (Math.abs(startAngle - endAngle) % pi2 < 1e-4) return !0;
	  if (anticlockwise) {
	    const tmp = startAngle;
	    startAngle = normalizeRadian(endAngle), endAngle = normalizeRadian(tmp);
	  } else startAngle = normalizeRadian(startAngle), endAngle = normalizeRadian(endAngle);
	  startAngle > endAngle && (endAngle += pi2);
	  let angle = Math.atan2(y, x);
	  return angle < 0 && (angle += pi2), angle >= startAngle && angle <= endAngle || angle + pi2 >= startAngle && angle + pi2 <= endAngle;
	}
	function containLineStroke(x0, y0, x1, y1, lineWidth, x, y) {
	  if (0 === lineWidth) return !1;
	  const _l = lineWidth,
	    _halfL = lineWidth / 2;
	  let _a = 0,
	    _b = x0;
	  if (y > y0 + _halfL && y > y1 + _halfL || y < y0 - _halfL && y < y1 - _halfL || x > x0 + _halfL && x > x1 + _halfL || x < x0 - _halfL && x < x1 - _halfL) return !1;
	  if (x0 === x1) return Math.abs(x - x0) <= _l / 2;
	  _a = (y0 - y1) / (x0 - x1), _b = (x0 * y1 - x1 * y0) / (x0 - x1);
	  const tmp = _a * x - y + _b;
	  return tmp * tmp / (_a * _a + 1) <= _l / 2 * _l / 2;
	}
	const EPSILON = 1e-4;
	function cubicRootAt(p0, p1, p2, p3, val, roots) {
	  const a = p3 + 3 * (p1 - p2) - p0,
	    b = 3 * (p2 - 2 * p1 + p0),
	    c = 3 * (p1 - p0),
	    d = p0 - val,
	    A = b * b - 3 * a * c,
	    B = b * c - 9 * a * d,
	    C = c * c - 3 * b * d;
	  let n = 0;
	  if (isAroundZero(A) && isAroundZero(B)) {
	    if (isAroundZero(b)) roots[0] = 0;else {
	      const t1 = -c / b;
	      t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
	    }
	  } else {
	    const disc = B * B - 4 * A * C;
	    if (isAroundZero(disc)) {
	      const K = B / A,
	        t1 = -b / a + K,
	        t2 = -K / 2;
	      t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);
	    } else if (disc > 0) {
	      const discSqrt = Math.sqrt(disc);
	      let Y1 = A * b + 1.5 * a * (-B + discSqrt),
	        Y2 = A * b + 1.5 * a * (-B - discSqrt);
	      Y1 = Y1 < 0 ? -Math.pow(-Y1, ONE_THIRD) : Math.pow(Y1, ONE_THIRD), Y2 = Y2 < 0 ? -Math.pow(-Y2, ONE_THIRD) : Math.pow(Y2, ONE_THIRD);
	      const t1 = (-b - (Y1 + Y2)) / (3 * a);
	      t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
	    } else {
	      const T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A)),
	        theta = Math.acos(T) / 3,
	        ASqrt = Math.sqrt(A),
	        tmp = Math.cos(theta),
	        t1 = (-b - 2 * ASqrt * tmp) / (3 * a),
	        t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a),
	        t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	      t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2), t3 >= 0 && t3 <= 1 && (roots[n++] = t3);
	    }
	  }
	  return n;
	}
	function cubicExtrema(p0, p1, p2, p3, extrema) {
	  const b = 6 * p2 - 12 * p1 + 6 * p0,
	    a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2,
	    c = 3 * p1 - 3 * p0;
	  let n = 0;
	  if (isAroundZero(a)) {
	    if (isNotAroundZero(b)) {
	      const t1 = -c / b;
	      t1 >= 0 && t1 <= 1 && (extrema[n++] = t1);
	    }
	  } else {
	    const disc = b * b - 4 * a * c;
	    if (isAroundZero(disc)) extrema[0] = -b / (2 * a);else if (disc > 0) {
	      const discSqrt = Math.sqrt(disc),
	        t1 = (-b + discSqrt) / (2 * a),
	        t2 = (-b - discSqrt) / (2 * a);
	      t1 >= 0 && t1 <= 1 && (extrema[n++] = t1), t2 >= 0 && t2 <= 1 && (extrema[n++] = t2);
	    }
	  }
	  return n;
	}
	function isAroundEqual(a, b) {
	  return Math.abs(a - b) < EPSILON;
	}
	const roots = [-1, -1, -1],
	  extrema = [-1, -1];
	function swapExtrema() {
	  const tmp = extrema[0];
	  extrema[0] = extrema[1], extrema[1] = tmp;
	}
	function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) return 0;
	  const nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
	  if (0 === nRoots) return 0;
	  let w = 0,
	    nExtrema = -1,
	    y0_ = 0,
	    y1_ = 0;
	  for (let i = 0; i < nRoots; i++) {
	    const t = roots[i],
	      unit = 0 === t || 1 === t ? .5 : 1;
	    cubicAt(x0, x1, x2, x3, t) < x || (nExtrema < 0 && (nExtrema = cubicExtrema(y0, y1, y2, y3, extrema), extrema[1] < extrema[0] && nExtrema > 1 && swapExtrema(), y0_ = cubicAt(y0, y1, y2, y3, extrema[0]), nExtrema > 1 && (y1_ = cubicAt(y0, y1, y2, y3, extrema[1]))), 2 === nExtrema ? t < extrema[0] ? w += y0_ < y0 ? unit : -unit : t < extrema[1] ? w += y1_ < y0_ ? unit : -unit : w += y3 < y1_ ? unit : -unit : t < extrema[0] ? w += y0_ < y0 ? unit : -unit : w += y3 < y0_ ? unit : -unit);
	  }
	  return w;
	}
	function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) return 0;
	  const nRoots = quadraticRootAt(y0, y1, y2, y, roots);
	  if (0 === nRoots) return 0;
	  const t = quadraticExtremum(y0, y1, y2);
	  if (t >= 0 && t <= 1) {
	    let w = 0;
	    const y_ = quadraticAt(y0, y1, y2, t);
	    for (let i = 0; i < nRoots; i++) {
	      const unit = 0 === roots[i] || 1 === roots[i] ? .5 : 1;
	      quadraticAt(x0, x1, x2, roots[i]) < x || (roots[i] < t ? w += y_ < y0 ? unit : -unit : w += y2 < y_ ? unit : -unit);
	    }
	    return w;
	  }
	  const unit = 0 === roots[0] || 1 === roots[0] ? .5 : 1;
	  return quadraticAt(x0, x1, x2, roots[0]) < x ? 0 : y2 < y0 ? unit : -unit;
	}
	function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
	  if ((y -= cy) > r || y < -r) return 0;
	  const tmp = Math.sqrt(r * r - y * y);
	  roots[0] = -tmp, roots[1] = tmp;
	  const dTheta = Math.abs(startAngle - endAngle);
	  if (dTheta < 1e-4) return 0;
	  if (dTheta >= pi2 - 1e-4) {
	    startAngle = 0, endAngle = pi2;
	    const dir = anticlockwise ? 1 : -1;
	    return x >= roots[0] + cx && x <= roots[1] + cx ? dir : 0;
	  }
	  if (startAngle > endAngle) {
	    const tmp = startAngle;
	    startAngle = endAngle, endAngle = tmp;
	  }
	  startAngle < 0 && (startAngle += pi2, endAngle += pi2);
	  let w = 0;
	  for (let i = 0; i < 2; i++) {
	    const x_ = roots[i];
	    if (x_ + cx > x) {
	      let angle = Math.atan2(y, x_),
	        dir = anticlockwise ? 1 : -1;
	      angle < 0 && (angle = pi2 + angle), (angle >= startAngle && angle <= endAngle || angle + pi2 >= startAngle && angle + pi2 <= endAngle) && (angle > pi / 2 && angle < 1.5 * pi && (dir = -dir), w += dir);
	    }
	  }
	  return w;
	}
	function modpi2(radian) {
	  return Math.round(radian / pi * 1e8) / 1e8 % 2 * pi;
	}
	function normalizeArcAngles(angles, anticlockwise) {
	  let newStartAngle = modpi2(angles[0]);
	  newStartAngle < 0 && (newStartAngle += pi2);
	  const delta = newStartAngle - angles[0];
	  let newEndAngle = angles[1];
	  newEndAngle += delta, !anticlockwise && newEndAngle - newStartAngle >= pi2 ? newEndAngle = newStartAngle + pi2 : anticlockwise && newStartAngle - newEndAngle >= pi2 ? newEndAngle = newStartAngle - pi2 : !anticlockwise && newStartAngle > newEndAngle ? newEndAngle = newStartAngle + (pi2 - modpi2(newStartAngle - newEndAngle)) : anticlockwise && newStartAngle < newEndAngle && (newEndAngle = newStartAngle - (pi2 - modpi2(newEndAngle - newStartAngle))), angles[0] = newStartAngle, angles[1] = newEndAngle;
	}
	const tmpAngles = [0, 0];
	function containPath(commands, lineWidth, isStroke, x, y) {
	  const data = commands,
	    len = commands.length;
	  let x1,
	    y1,
	    w = 0,
	    xi = 0,
	    yi = 0,
	    x0 = 0,
	    y0 = 0;
	  for (let i = 0; i < len; i++) {
	    const command = data[i],
	      isFirst = 0 === i;
	    command[0] === enumCommandMap.M && i > 1 && (isStroke || (w += isPointInLine(xi, yi, x0, y0, x, y))), isFirst && (xi = command[1], yi = command[2], x0 = xi, y0 = yi);
	    const c0 = command[0],
	      c1 = command[1],
	      c2 = command[2],
	      c3 = command[3],
	      c4 = command[4],
	      c5 = command[5],
	      c6 = command[6];
	    let startAngle = c4,
	      endAngle = c5;
	    tmpAngles[0] = startAngle, tmpAngles[1] = endAngle, normalizeArcAngles(tmpAngles, Boolean(command[6])), startAngle = tmpAngles[0], endAngle = tmpAngles[1];
	    const theta = startAngle,
	      dTheta = endAngle - startAngle,
	      anticlockwise = !!(1 - (command[6] ? 0 : 1)),
	      _x = (x - c1) * c3 / c3 + c1;
	    switch (c0) {
	      case enumCommandMap.M:
	        x0 = c1, y0 = c2, xi = x0, yi = y0;
	        break;
	      case enumCommandMap.L:
	        if (isStroke) {
	          if (containLineStroke(xi, yi, c1, c2, lineWidth, x, y)) return !0;
	        } else w += isPointInLine(xi, yi, c1, c2, x, y) || 0;
	        xi = c1, yi = c2;
	        break;
	      case enumCommandMap.C:
	        if (isStroke) {
	          if (containCubicStroke(xi, yi, c1, c2, c3, c4, c5, c6, lineWidth, x, y)) return !0;
	        } else w += windingCubic(xi, yi, c1, c2, c3, c4, c5, c6, x, y) || 0;
	        xi = c5, yi = c6;
	        break;
	      case enumCommandMap.Q:
	        if (isStroke) {
	          if (containQuadStroke(xi, yi, c1, c2, c3, c4, lineWidth, x, y)) return !0;
	        } else w += windingQuadratic(xi, yi, c1, c2, c3, c4, x, y) || 0;
	        xi = c3, yi = c4;
	        break;
	      case enumCommandMap.A:
	        if (x1 = Math.cos(theta) * c3 + c1, y1 = Math.sin(theta) * c3 + c2, isFirst ? (x0 = x1, y0 = y1) : w += isPointInLine(xi, yi, x1, y1, x, y), isStroke) {
	          if (containArcStroke(c1, c2, c3, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) return !0;
	        } else w += windingArc(c1, c2, c3, theta, theta + dTheta, anticlockwise, _x, y);
	        xi = Math.cos(theta + dTheta) * c3 + c1, yi = Math.sin(theta + dTheta) * c3 + c2;
	        break;
	      case enumCommandMap.R:
	        if (x0 = xi = c1, y0 = yi = c2, x1 = x0 + c3, y1 = y0 + c4, isStroke) {
	          if (containLineStroke(x0, y0, x1, y0, lineWidth, x, y) || containLineStroke(x1, y0, x1, y1, lineWidth, x, y) || containLineStroke(x1, y1, x0, y1, lineWidth, x, y) || containLineStroke(x0, y1, x0, y0, lineWidth, x, y)) return !0;
	        } else w += isPointInLine(x1, y0, x1, y1, x, y), w += isPointInLine(x0, y1, x0, y0, x, y);
	        break;
	      case enumCommandMap.Z:
	        if (isStroke) {
	          if (containLineStroke(xi, yi, x0, y0, lineWidth, x, y)) return !0;
	        } else w += isPointInLine(xi, yi, x0, y0, x, y);
	        xi = x0, yi = y0;
	    }
	  }
	  return isStroke || isAroundEqual(yi, y0) || (w += isPointInLine(xi, yi, x0, y0, x, y) || 0), 0 !== w;
	}
	function contain(commands, x, y) {
	  return containPath(commands, 0, !1, x, y);
	}
	function containStroke(commands, lineWidth, x, y) {
	  return containPath(commands, lineWidth, !0, x, y);
	}

	class DefaultCanvasAllocate {
	  constructor() {
	    this.pools = [], this.allocatedCanvas = [];
	  }
	  shareCanvas() {
	    return this.allocatedCanvas.length ? this.allocatedCanvas[0] : this.getCommonCanvas();
	  }
	  getCommonCanvas() {
	    return this._commonCanvas || (this._commonCanvas = this.allocate({
	      width: 100,
	      height: 100,
	      dpr: 2
	    })), this._commonCanvas;
	  }
	  allocate(data) {
	    if (!this.pools.length) {
	      const c = wrapCanvas(Object.assign({
	        nativeCanvas: application.global.createCanvas(data)
	      }, data));
	      return this.allocatedCanvas.push(c), c;
	    }
	    const m = this.pools.pop();
	    return m.resize(data.width, data.height), m.dpr = data.dpr, m;
	  }
	  allocateByObj(canvas) {
	    if (!this.pools.length) {
	      const data = {
	          width: canvas.width / canvas.dpr,
	          height: canvas.height / canvas.dpr,
	          dpr: canvas.dpr
	        },
	        c = wrapCanvas(Object.assign({
	          nativeCanvas: application.global.createCanvas(data)
	        }, data));
	      return this.allocatedCanvas.push(c), c;
	    }
	    const m = this.pools.pop();
	    return m.width = canvas.width, m.height = canvas.height, m;
	  }
	  free(d) {
	    this.pools.push(d);
	  }
	  get length() {
	    return this.pools.length;
	  }
	  release(...params) {
	    this.pools = [];
	  }
	}
	const canvasAllocate = new DefaultCanvasAllocate();

	const defaultThemeObj = {
	    arc: DefaultArcAttribute,
	    area: DefaultAreaAttribute,
	    circle: DefaultCircleAttribute,
	    line: DefaultLineAttribute,
	    path: DefaultPathAttribute,
	    symbol: DefaultSymbolAttribute,
	    text: DefaultTextAttribute,
	    rect: DefaultRectAttribute,
	    polygon: DefaultPolygonAttribute,
	    star: DefaultStarAttribute,
	    richtext: DefaultRichTextAttribute,
	    richtextIcon: DefaultRichTextIconAttribute,
	    image: DefaultImageAttribute,
	    group: DefaultGroupAttribute,
	    glyph: DefaultGlyphAttribute
	  },
	  themeKeys = Object.keys(defaultThemeObj);
	function newThemeObj() {
	  return {
	    arc: Object.assign({}, defaultThemeObj.arc),
	    area: Object.assign({}, defaultThemeObj.area),
	    circle: Object.assign({}, defaultThemeObj.circle),
	    line: Object.assign({}, defaultThemeObj.line),
	    path: Object.assign({}, defaultThemeObj.path),
	    symbol: Object.assign({}, defaultThemeObj.symbol),
	    text: Object.assign({}, defaultThemeObj.text),
	    rect: Object.assign({}, defaultThemeObj.rect),
	    polygon: Object.assign({}, defaultThemeObj.polygon),
	    star: Object.assign({}, defaultThemeObj.star),
	    richtext: Object.assign({}, defaultThemeObj.richtext),
	    richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
	    image: Object.assign({}, defaultThemeObj.image),
	    group: Object.assign({}, defaultThemeObj.group),
	    glyph: Object.assign({}, defaultThemeObj.glyph)
	  };
	}
	function combine(out, t) {
	  Object.keys(t).forEach(k => {
	    out[k] = t[k];
	  });
	}
	const globalThemeObj = newThemeObj();
	class Theme {
	  constructor() {
	    this.initTheme(), this.dirty = !1;
	  }
	  initTheme() {
	    this._defaultTheme = {}, themeKeys.forEach(key => {
	      this._defaultTheme[key] = Object.create(globalThemeObj[key]);
	    }), this.combinedTheme = this._defaultTheme;
	  }
	  getTheme(group) {
	    if (!group) return this.combinedTheme;
	    if (!this.dirty) return this.combinedTheme;
	    let parentTheme = {};
	    const parentGroup = this.getParentWithTheme(group);
	    return parentGroup && (parentTheme = parentGroup.theme), this.applyTheme(group, parentTheme), this.combinedTheme;
	  }
	  getParentWithTheme(group) {
	    for (; group.parent;) if ((group = group.parent).theme) return group;
	    return null;
	  }
	  applyTheme(group, pt, force = !1) {
	    if (this.dirty) {
	      const parentGroup = this.getParentWithTheme(group);
	      if (parentGroup) {
	        const parentTheme = parentGroup.theme;
	        (parentTheme.dirty || force) && parentTheme.applyTheme(parentGroup, pt, !0);
	      }
	      this.userTheme ? this.doCombine(parentGroup && parentGroup.theme.combinedTheme) : (parentGroup ? this.combinedTheme = parentGroup.theme.combinedTheme : (this.combinedTheme = this._defaultTheme, Logger.getInstance().warn("未知错误，走到不应该走的区域里")), this.dirty = !1);
	    }
	    return this.combinedTheme;
	  }
	  doCombine(parentCombinedTheme) {
	    const userTheme = this.userTheme,
	      combinedTheme = this.combinedTheme;
	    themeKeys.forEach(k => {
	      const obj = Object.create(globalThemeObj[k]);
	      parentCombinedTheme && parentCombinedTheme[k] && combine(obj, parentCombinedTheme[k]), combinedTheme[k] && combine(obj, combinedTheme[k]), userTheme[k] && combine(obj, userTheme[k]), this.combinedTheme[k] = obj;
	    }), userTheme.common && themeKeys.forEach(k => {
	      combine(this.combinedTheme[k], userTheme.common);
	    }), this.dirty = !1;
	  }
	  setTheme(t, g) {
	    let userTheme = this.userTheme;
	    userTheme ? Object.keys(t).forEach(k => {
	      userTheme[k] ? Object.assign(userTheme[k], t[k]) : userTheme[k] = Object.assign({}, t[k]);
	    }) : userTheme = t, this.userTheme = userTheme, this.dirty = !0, this.dirtyChildren(g);
	  }
	  resetTheme(t, g) {
	    this.userTheme = t, this.dirty = !0, this.dirtyChildren(g);
	  }
	  dirtyChildren(g) {
	    g.forEachChildren(item => {
	      item.isContainer && (item.theme && (item.theme.dirty = !0), this.dirtyChildren(item));
	    });
	  }
	}
	const globalTheme = new Theme();
	function getTheme(graphic, theme) {
	  return graphic.glyphHost ? getTheme(graphic.glyphHost) : theme ? (graphic.isContainer, theme) : getThemeFromGroup(graphic) || graphic.attachedThemeGraphic && getTheme(graphic.attachedThemeGraphic) || globalTheme.getTheme();
	}
	function getThemeFromGroup(graphic) {
	  let g;
	  if (g = graphic.isContainer ? graphic : graphic.parent, g) {
	    for (; g && !g.theme;) g = g.parent;
	    return g ? (g.theme || g.createTheme(), g.theme.getTheme(g)) : globalTheme.getTheme();
	  }
	  return null;
	}

	var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }
	    function rejected(value) {
	      try {
	        step(generator.throw(value));
	      } catch (e) {
	        reject(e);
	      }
	    }
	    function step(result) {
	      var value;
	      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      })).then(fulfilled, rejected);
	    }
	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};
	class Node extends EventEmitter {
	  get previousSibling() {
	    return this._prev;
	  }
	  get nextSibling() {
	    return this._next;
	  }
	  get children() {
	    return this.getChildren();
	  }
	  get firstChild() {
	    return this._firstChild;
	  }
	  get lastChild() {
	    return this._lastChild;
	  }
	  get count() {
	    return this._count;
	  }
	  get childrenCount() {
	    return this._idMap ? this._idMap.size : 0;
	  }
	  constructor() {
	    super(), this._uid = Generator.GenAutoIncrementId(), this._firstChild = null, this._lastChild = null, this.parent = null, this._count = 1;
	  }
	  forEachChildren(cb, reverse = !1) {
	    if (reverse) {
	      let child = this._lastChild,
	        i = 0;
	      for (; child;) {
	        if (cb(child, i++)) return;
	        child = child._prev;
	      }
	    } else {
	      let child = this._firstChild,
	        i = 0;
	      for (; child;) {
	        if (cb(child, i++)) return;
	        child = child._next;
	      }
	    }
	  }
	  forEachChildrenAsync(cb, reverse = !1) {
	    return __awaiter(this, void 0, void 0, function* () {
	      if (reverse) {
	        let child = this._lastChild,
	          i = 0;
	        for (; child;) {
	          let breakTag = cb(child, i++);
	          if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
	          child = child._prev;
	        }
	      } else {
	        let child = this._firstChild,
	          i = 0;
	        for (; child;) {
	          let breakTag = cb(child, i++);
	          if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
	          child = child._next;
	        }
	      }
	    });
	  }
	  forEach(cb) {
	    return this.forEachChildren(cb);
	  }
	  appendChild(node, highPerformance = !0) {
	    if (this._uid === node._uid) return null;
	    if (!highPerformance && node.isAncestorsOf(this)) throw new Error("【Node::appendChild】不能将父辈元素append为子元素");
	    return node.parent && node.parent.removeChild(node), node.parent = this, this._lastChild ? (this._lastChild._next = node, node._prev = this._lastChild, this._lastChild = node) : (this._firstChild = this._lastChild = node, node._prev = node._next = null), this._idMap || (this._idMap = new Map()), this._idMap.set(node._uid, node), this.setCount(node.count), this._structEdit = !0, node;
	  }
	  appendChildArrHighPerformance(nodes, replace = !1) {
	    return console.error("暂不支持该函数"), nodes;
	  }
	  insertBefore(newNode, referenceNode) {
	    if (!referenceNode) return this.appendChild(newNode);
	    if (this === newNode || newNode === referenceNode) return null;
	    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
	    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, newNode._prev = referenceNode._prev, referenceNode._prev ? referenceNode._prev._next = newNode : this._firstChild = newNode, referenceNode._prev = newNode, newNode._next = referenceNode, this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode);
	  }
	  insertAfter(newNode, referenceNode) {
	    if (!referenceNode) return this.appendChild(newNode);
	    if (this === newNode || newNode === referenceNode) return null;
	    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertAfter】不能将父辈元素insert为子元素");
	    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, referenceNode._next ? (referenceNode._next._prev = newNode, newNode._next = referenceNode._next) : this._lastChild = newNode, referenceNode._next = newNode, newNode._prev = referenceNode, this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode);
	  }
	  insertInto(newNode, idx) {
	    if (!this._ignoreWarn && this._nodeList && Logger.getInstance().warn("insertIntoKeepIdx和insertInto混用可能会存在错误"), idx >= this.childrenCount) return this.appendChild(newNode);
	    if (this === newNode) return null;
	    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
	    if (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, 0 === idx) newNode._next = this._firstChild, this._firstChild && (this._firstChild._prev = newNode), newNode._prev = null, this._firstChild = newNode;else {
	      let child = this._firstChild;
	      for (let i = 0; i < idx; i++) {
	        if (!child) return null;
	        i > 0 && (child = child._next);
	      }
	      if (!child) return null;
	      newNode._next = child._next, newNode._prev = child, child._next = newNode, newNode._next && (newNode._next._prev = newNode);
	    }
	    return this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode;
	  }
	  insertIntoKeepIdx(newNode, idx) {
	    if (this._nodeList || (this._nodeList = this.children), this._nodeList[idx]) {
	      const node = this._nodeList[idx];
	      return this._nodeList.splice(idx, 0, newNode), this.insertBefore(newNode, node);
	    }
	    let node;
	    this._nodeList[idx] = newNode;
	    for (let i = idx - 1; i >= 0 && (node = this._nodeList[i], !node); i--);
	    if (node) return node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode);
	    this._ignoreWarn = !0;
	    const data = this.insertInto(newNode, 0);
	    return this._ignoreWarn = !1, data;
	  }
	  removeChild(child) {
	    if (!this._idMap) return null;
	    if (!this._idMap.has(child._uid)) return null;
	    if (this._idMap.delete(child._uid), this._nodeList) {
	      const idx = this._nodeList.findIndex(n => n === child);
	      idx >= 0 && this._nodeList.splice(idx, 1);
	    }
	    return child._prev ? child._prev._next = child._next : this._firstChild = child._next, child._next ? child._next._prev = child._prev : this._lastChild = child._prev, child.parent = null, child._prev = null, child._next = null, this._structEdit = !0, this.setCount(-child.count), child;
	  }
	  delete() {
	    this.parent && this.parent.removeChild(this);
	  }
	  removeAllChild(deep) {
	    if (!this._idMap) return;
	    this._nodeList && (this._nodeList.length = 0);
	    let child = this._firstChild;
	    for (; child;) {
	      const next = child._next;
	      child.parent = null, child._prev = null, child._next = null, child = child._next, child = next;
	    }
	    this._firstChild = null, this._lastChild = null, this._idMap.clear(), this._structEdit = !0, this.setCount(1 - this._count);
	  }
	  replaceChild(newChild, oldChild) {
	    throw new Error("暂不支持");
	  }
	  find(callback, deep = !1) {
	    let target = null;
	    return this.forEachChildren((node, index) => !(node === this || !callback(node, index)) && (target = node, !0)), deep && this.forEachChildren(child => {
	      if (child.isContainer) {
	        const node = child.find(callback, !0);
	        if (node) return target = node, !0;
	      }
	      return !1;
	    }), target;
	  }
	  findAll(callback, deep = !1) {
	    let nodes = [];
	    return this.forEachChildren((node, index) => {
	      node !== this && callback(node, index) && nodes.push(node);
	    }), deep && this.forEachChildren(child => {
	      if (child.isContainer) {
	        const targets = child.findAll(callback, !0);
	        targets.length && (nodes = nodes.concat(targets));
	      }
	    }), nodes;
	  }
	  getElementById(id) {
	    return this.find(node => node.id === id, !0);
	  }
	  findChildById(id) {
	    return this.getElementById(id);
	  }
	  findChildByUid(uid) {
	    return this._idMap && this._idMap.get(uid) || null;
	  }
	  getElementsByName(name) {
	    return this.findAll(node => node.name === name, !0);
	  }
	  findChildrenByName(name) {
	    return this.getElementsByName(name);
	  }
	  getElementsByType(type) {
	    return this.findAll(node => node.type === type, !0);
	  }
	  getChildByName(name, deep = !1) {
	    return this.find(node => node.name === name, deep);
	  }
	  getChildAt(idx) {
	    let c = this._firstChild;
	    if (!c) return null;
	    for (let i = 0; i < idx; i++) {
	      if (!c._next) return null;
	      c = c._next;
	    }
	    return c;
	  }
	  at(idx) {
	    return this.getChildAt(idx);
	  }
	  containNode(node) {
	    if (!this._idMap) return !1;
	    if (this._idMap.has(node._uid)) return !0;
	    let child = this._firstChild;
	    for (; child;) {
	      if (child.containNode(node)) return !0;
	      child = child._next;
	    }
	    return !1;
	  }
	  getRootNode() {
	    let parent = this.parent;
	    for (; null == parent ? void 0 : parent.parent;) parent = parent.parent;
	    return parent || this;
	  }
	  hasChildNodes() {
	    return null !== this._firstChild;
	  }
	  addChild(node) {
	    return this.appendChild(node);
	  }
	  add(node) {
	    return this.appendChild(node);
	  }
	  getChildren() {
	    const nodes = [];
	    let child = this._firstChild;
	    for (; child;) nodes.push(child), child = child._next;
	    return nodes;
	  }
	  isChildOf(node) {
	    return !!this.parent && this.parent._uid === node._uid;
	  }
	  isParentOf(node) {
	    return node.isChildOf(this);
	  }
	  isDescendantsOf(node) {
	    let parent = this.parent;
	    if (!parent) return !1;
	    do {
	      if (parent._uid === node._uid) return !0;
	      parent = parent.parent;
	    } while (null !== parent);
	    return !1;
	  }
	  isAncestorsOf(node) {
	    return node.isDescendantsOf(this);
	  }
	  getAncestor(idx) {
	    throw new Error("暂不支持");
	  }
	  setAllDescendantsProps(propsName, propsValue) {
	    let child = this._firstChild;
	    for (; child;) child[propsName] = propsValue, child.setAllDescendantsProps(propsName, propsValue), child = child._next;
	  }
	  setCount(deltaCount) {
	    this._count += deltaCount;
	    let parent = this.parent;
	    if (parent) do {
	      parent._count += deltaCount, parent = parent.parent;
	    } while (null !== parent);
	  }
	  clone() {
	    throw new Error("暂不支持");
	  }
	  cloneTo(node) {
	    throw new Error("暂不支持");
	  }
	  getParent() {
	    return this.parent;
	  }
	  del(child) {
	    return this.removeChild(child);
	  }
	  addEventListener(type, listener, options) {
	    const capture = isBoolean$1(options, !0) && options || isObject$1(options) && options.capture,
	      once = isObject$1(options) && options.once,
	      context = isFunction$1(listener) ? void 0 : listener;
	    return type = capture ? `${type}capture` : type, listener = isFunction$1(listener) ? listener : listener.handleEvent, once ? super.once(type, listener, context) : super.on(type, listener, context), this;
	  }
	  on(type, listener, options) {
	    return this.addEventListener(type, listener, options);
	  }
	  removeEventListener(type, listener, options) {
	    const capture = isBoolean$1(options, !0) && options || isObject$1(options) && options.capture,
	      context = isFunction$1(listener) ? void 0 : listener;
	    type = capture ? `${type}capture` : type, listener = isFunction$1(listener) ? listener : listener.handleEvent;
	    const once = isObject$1(options) && options.once;
	    return super.off(type, listener, context, once), this;
	  }
	  off(type, listener, options) {
	    return this.removeEventListener(type, listener, options);
	  }
	  once(type, listener, options) {
	    return isObject$1(options) ? (options.once = !0, this.addEventListener(type, listener, options)) : this.addEventListener(type, listener, {
	      once: !0
	    });
	  }
	  removeAllEventListeners() {
	    return super.removeAllListeners(), this;
	  }
	  removeAllListeners() {
	    return this.removeAllEventListeners();
	  }
	  dispatchEvent(event, ...args) {
	    return super.emit(event.type, event, ...args), !event.defaultPrevented;
	  }
	  emit(event, data) {
	    return this.dispatchEvent(event, data);
	  }
	  release() {
	    this.removeAllListeners();
	  }
	}

	class FederatedEvent {
	  get layerX() {
	    return this.layer.x;
	  }
	  get layerY() {
	    return this.layer.y;
	  }
	  get pageX() {
	    return this.page.x;
	  }
	  get pageY() {
	    return this.page.y;
	  }
	  get x() {
	    return this.canvas.x;
	  }
	  get y() {
	    return this.canvas.y;
	  }
	  get canvasX() {
	    return this.canvas.x;
	  }
	  get canvasY() {
	    return this.canvas.y;
	  }
	  get viewX() {
	    return this.viewport.x;
	  }
	  get viewY() {
	    return this.viewport.y;
	  }
	  constructor(manager) {
	    this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = FederatedEvent.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = {
	      x: 0,
	      y: 0
	    }, this.page = {
	      x: 0,
	      y: 0
	    }, this.canvas = {
	      x: 0,
	      y: 0
	    }, this.viewport = {
	      x: 0,
	      y: 0
	    }, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
	  }
	  composedPath() {
	    return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.composedDetailPath(), this.path;
	  }
	  composedDetailPath() {
	    return this.pickParams && this.pickParams.graphic ? (this.detailPath = this.path.slice(), this._composedDetailPath(this.pickParams)) : this.detailPath = this.path.slice(), this.detailPath;
	  }
	  _composedDetailPath(params) {
	    if (params && params.graphic) {
	      const g = params.graphic;
	      if (g.stage) {
	        const path = g.stage.eventSystem.manager.propagationPath(g);
	        this.detailPath.push(path), this._composedDetailPath(params.params);
	      }
	    }
	  }
	  preventDefault() {
	    try {
	      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault();
	    } catch (err) {
	      this.nativeEvent.preventDefault && isFunction$1(this.nativeEvent.preventDefault) && this.nativeEvent.preventDefault();
	    }
	    this.defaultPrevented = !0;
	  }
	  stopImmediatePropagation() {
	    this.propagationImmediatelyStopped = !0;
	  }
	  stopPropagation() {
	    try {
	      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.stopPropagation();
	    } catch (err) {
	      this.nativeEvent.stopPropagation && isFunction$1(this.nativeEvent.stopPropagation) && this.nativeEvent.stopPropagation();
	    }
	    this.propagationStopped = !0;
	  }
	  initEvent() {}
	  initUIEvent() {}
	  clone() {
	    throw new Error("Method not implemented.");
	  }
	}

	class CustomEvent extends FederatedEvent {
	  constructor(eventName, object) {
	    super(), this.type = eventName, this.detail = object;
	  }
	}

	const EventTarget = {
	  dispatchEvent(e) {
	    var _a;
	    if (!(e instanceof FederatedEvent)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
	    return e.defaultPrevented = !1, e.path = [], e.detailPath && (e.detailPath = []), e.target = this, null === (_a = null == e ? void 0 : e.manager) || void 0 === _a || _a.dispatchEvent(e), !e.defaultPrevented;
	  },
	  emit(eventName, object) {
	    return this.dispatchEvent(new CustomEvent(eventName, object));
	  }
	};

	class ResourceLoader {
	  static GetImage(url, mark) {
	    var _a;
	    const data = ResourceLoader.cache.get(url);
	    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
	      mark.imageLoadFail(url);
	    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(url, data.data) : ResourceLoader.loadImage(url, mark);
	  }
	  static GetSvg(svgStr, mark) {
	    var _a;
	    let data = ResourceLoader.cache.get(svgStr);
	    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
	      mark.imageLoadFail(svgStr);
	    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(svgStr, data.data) : (data = {
	      type: "image",
	      loadState: "init"
	    }, ResourceLoader.cache.set(svgStr, data), data.dataPromise = application.global.loadSvg(svgStr), data.dataPromise ? (data.waitingMark = [mark], data.dataPromise.then(res => {
	      var _a;
	      data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map((mark, index) => {
	        (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(svgStr, res.data)) : (data.loadState = "fail", mark.imageLoadFail(svgStr));
	      }), data.waitingMark && (data.waitingMark = []);
	    })) : (data.loadState = "fail", mark.imageLoadFail(svgStr)));
	  }
	  static GetFile(url, type) {
	    let data = ResourceLoader.cache.get(url);
	    return data ? "fail" === data.loadState ? Promise.reject() : "init" === data.loadState || "loading" === data.loadState ? data.dataPromise.then(data => data.data) : Promise.resolve(data.data) : (data = {
	      type: type,
	      loadState: "init"
	    }, ResourceLoader.cache.set(url, data), "arrayBuffer" === type ? data.dataPromise = application.global.loadArrayBuffer(url) : "blob" === type ? data.dataPromise = application.global.loadBlob(url) : "json" === type && (data.dataPromise = application.global.loadJson(url)), data.dataPromise.then(data => data.data));
	  }
	  static loading() {
	    setTimeout(() => {
	      if (!ResourceLoader.isLoading && ResourceLoader.toLoadAueue.length) {
	        ResourceLoader.isLoading = !0;
	        const tasks = ResourceLoader.toLoadAueue.splice(0, 10),
	          promises = [];
	        tasks.forEach(task => {
	          const {
	              url: url,
	              marks: marks
	            } = task,
	            data = {
	              type: "image",
	              loadState: "init"
	            };
	          if (ResourceLoader.cache.set(url, data), data.dataPromise = application.global.loadImage(url), data.dataPromise) {
	            data.waitingMark = marks;
	            const end = data.dataPromise.then(res => {
	              var _a;
	              data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map((mark, index) => {
	                (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(url, res.data)) : (data.loadState = "fail", mark.imageLoadFail(url));
	              }), data.waitingMark && (data.waitingMark = []);
	            });
	            promises.push(end);
	          } else data.loadState = "fail", marks.forEach(mark => mark.imageLoadFail(url));
	        }), Promise.all(promises).then(() => {
	          ResourceLoader.isLoading = !1, this.onLoadSuccessCb.forEach(cb => cb()), ResourceLoader.loading();
	        }).catch(error => {
	          console.error(error), ResourceLoader.isLoading = !1, this.onLoadSuccessCb.forEach(cb => cb()), ResourceLoader.loading();
	        });
	      }
	    }, 0);
	  }
	  static loadImage(url, mark) {
	    const index = getIndex(url, ResourceLoader.toLoadAueue);
	    if (-1 !== index) return ResourceLoader.toLoadAueue[index].marks.push(mark), void ResourceLoader.loading();
	    ResourceLoader.toLoadAueue.push({
	      url: url,
	      marks: [mark]
	    }), ResourceLoader.loading();
	  }
	  static improveImageLoading(url) {
	    const index = getIndex(url, ResourceLoader.toLoadAueue);
	    if (-1 !== index) {
	      const elememt = ResourceLoader.toLoadAueue.splice(index, 1);
	      ResourceLoader.toLoadAueue.unshift(elememt[0]);
	    }
	  }
	  static onLoadSuccess(cb) {
	    this.onLoadSuccessCb.push(cb);
	  }
	}
	function getIndex(url, arr) {
	  for (let i = 0; i < arr.length; i++) if (arr[i].url === url) return i;
	  return -1;
	}
	ResourceLoader.cache = new Map(), ResourceLoader.isLoading = !1, ResourceLoader.toLoadAueue = [], ResourceLoader.onLoadSuccessCb = [];

	var Edge;
	!function (Edge) {
	  Edge[Edge.Top = 1] = "Top", Edge[Edge.Right = 2] = "Right", Edge[Edge.Bottom = 4] = "Bottom", Edge[Edge.Left = 8] = "Left", Edge[Edge.ALL = 15] = "ALL";
	}(Edge || (Edge = {}));
	const _strokeVec4 = [!1, !1, !1, !1];
	const parseStroke = stroke => {
	  var _a;
	  let isFullStroke = !0;
	  if (isBoolean$1(stroke, !0)) {
	    for (let i = 0; i < 4; i++) _strokeVec4[i] = stroke, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i]) && void 0 !== _a && !_a));
	    isFullStroke = stroke;
	  } else if (Array.isArray(stroke)) for (let i = 0; i < 4; i++) _strokeVec4[i] = !!stroke[i], isFullStroke && (isFullStroke = !!_strokeVec4[i]);else _strokeVec4[0] = !1, _strokeVec4[1] = !1, _strokeVec4[2] = !1, _strokeVec4[3] = !1;
	  return {
	    isFullStroke: isFullStroke,
	    stroke: _strokeVec4
	  };
	};
	const _paddingVec4 = [0, 0, 0, 0];
	const parsePadding = padding => padding ? isArray$1(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], _paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], _paddingVec4) : padding : padding : 0;
	const _coords = [{
	    x: 0,
	    y: 0
	  }, {
	    x: 0,
	    y: 0
	  }, {
	    x: 0,
	    y: 0
	  }, {
	    x: 0,
	    y: 0
	  }],
	  indexList = [1, 2, 3, 0, 1, 2, 3, 0];
	function circleBounds(startAngle, endAngle, radius, bounds) {
	  for (; startAngle >= pi2;) startAngle -= pi2;
	  for (; startAngle < 0;) startAngle += pi2;
	  for (; startAngle > endAngle;) endAngle += pi2;
	  _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;
	  const startIdx = Math.ceil(startAngle / halfPi$1) % 4,
	    endIdx = Math.ceil(endAngle / halfPi$1) % 4;
	  if (bounds.add(cos(startAngle) * radius, sin(startAngle) * radius), bounds.add(cos(endAngle) * radius, sin(endAngle) * radius), startIdx !== endIdx || endAngle - startAngle > pi) {
	    let match = !1;
	    for (let i = 0; i < indexList.length; i++) if (match || startIdx !== indexList[i]) {
	      if (match && endIdx === indexList[i]) break;
	      if (match) {
	        const p = _coords[indexList[i]];
	        bounds.add(p.x, p.y);
	      }
	    } else {
	      match = !0;
	      const p = _coords[startIdx];
	      bounds.add(p.x, p.y);
	    }
	  }
	}
	function pointInterpolation(pointA, pointB, ratio) {
	  const {
	      x: x,
	      y: y
	    } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio),
	    {
	      x: x1,
	      y: y1
	    } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio),
	    point = new Point(x, y, x1, y1);
	  return point.defined = pointB.defined, point;
	}
	function pointsInterpolation(pointsA, pointsB, ratio) {
	  if (!pointsA || !pointsB) return [];
	  Array.isArray(pointsA) || (pointsA = [pointsA]), Array.isArray(pointsB) || (pointsB = [pointsB]);
	  let points = [];
	  if (pointsA.length > pointsB.length) {
	    points = pointsB.map(point => {
	      const p = new Point(point.x, point.y, point.x1, point.y1);
	      return p.defined = point.defined, p;
	    });
	    for (let i = 0; i < pointsB.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
	  } else {
	    points = pointsB.map(point => {
	      const p = new Point(point.x, point.y, point.x1, point.y1);
	      return p.defined = point.defined, p;
	    });
	    for (let i = 0; i < pointsA.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
	  }
	  return points;
	}
	const _calculateLineHeight = (lineHeight, fontSize) => {
	  if (isString$1(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
	    return fontSize * (Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100);
	  }
	  return lineHeight;
	};
	const calculateLineHeight = (lineHeight, fontSize) => {
	  const _lh = _calculateLineHeight(lineHeight, fontSize);
	  return isNaN(_lh) ? _lh : Math.max(fontSize, _lh);
	};

	class BaseSymbol {
	  bounds(size, bounds) {
	    if (isNumber$1(size)) {
	      const halfS = size / 2;
	      bounds.x1 = -halfS, bounds.x2 = halfS, bounds.y1 = -halfS, bounds.y2 = halfS;
	    } else bounds.x1 = -size[0] / 2, bounds.x2 = size[0] / 2, bounds.y1 = -size[1] / 2, bounds.y2 = size[1] / 2;
	  }
	  parseSize(size) {
	    return isNumber$1(size) ? size : Math.min(size[0], size[1]);
	  }
	}

	function circle$1(ctx, r, x, y, z) {
	  return z ? ctx.arc(x, y, r, 0, tau, !1, z) : ctx.arc(x, y, r, 0, tau), !1;
	}
	class CircleSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "circle", this.pathStr = "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0";
	  }
	  draw(ctx, size, x, y, z) {
	    return circle$1(ctx, this.parseSize(size) / 2, x, y, z);
	  }
	  drawOffset(ctx, size, x, y, offset, z) {
	    return circle$1(ctx, this.parseSize(size) / 2 + offset, x, y, z);
	  }
	  drawToSvgPath(size, x, y, z) {
	    const r = this.parseSize(size) / 2;
	    return `M ${x - r}, ${y} a ${r},${r} 0 1,0 ${2 * r},0 a ${r},${r} 0 1,0 -${2 * r},0`;
	  }
	}
	var circle$2 = new CircleSymbol();

	function cross(ctx, r, x, y, z) {
	  return ctx.moveTo(-3 * r + x, -r + y, z), ctx.lineTo(-r + x, -r + y, z), ctx.lineTo(-r + x, -3 * r + y, z), ctx.lineTo(r + x, -3 * r + y, z), ctx.lineTo(r + x, -r + y, z), ctx.lineTo(3 * r + x, -r + y, z), ctx.lineTo(3 * r + x, r + y, z), ctx.lineTo(r + x, r + y, z), ctx.lineTo(r + x, 3 * r + y, z), ctx.lineTo(-r + x, 3 * r + y, z), ctx.lineTo(-r + x, r + y, z), ctx.lineTo(-3 * r + x, r + y, z), ctx.closePath(), !0;
	}
	function crossOffset(ctx, r, x, y, offset, z) {
	  return ctx.moveTo(-3 * r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, r + y + offset, z), ctx.lineTo(-3 * r + x - offset, r + y + offset, z), ctx.closePath(), !0;
	}
	class CrossSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "cross", this.pathStr = "M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z";
	  }
	  draw(ctx, size, x, y, z) {
	    return cross(ctx, this.parseSize(size) / 6, x, y, z);
	  }
	  drawOffset(ctx, size, x, y, offset, z) {
	    return crossOffset(ctx, this.parseSize(size) / 6, x, y, offset, z);
	  }
	}
	var cross$1 = new CrossSymbol();

	function diamond$1(ctx, r, x, y, z) {
	  return ctx.moveTo(x, y - r, z), ctx.lineTo(r + x, y, z), ctx.lineTo(x, y + r, z), ctx.lineTo(x - r, y, z), ctx.closePath(), !0;
	}
	class DiamondSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "diamond", this.pathStr = "M-0.5,0L0,-0.5L0.5,0L0,0.5Z";
	  }
	  draw(ctx, size, x, y, z) {
	    return diamond$1(ctx, this.parseSize(size) / 2, x, y, z);
	  }
	  drawFitDir(ctx, size, x, y, z) {
	    return diamond$1(ctx, this.parseSize(size) / 2, x, y, z);
	  }
	  drawOffset(ctx, size, x, y, offset, z) {
	    return diamond$1(ctx, this.parseSize(size) / 2 + offset, x, y, z);
	  }
	}
	var diamond$2 = new DiamondSymbol();

	function square$2(ctx, r, x, y) {
	  const wh = 2 * r;
	  return ctx.rect(x - r, y - r, wh, wh), !1;
	}
	class SquareSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "square", this.pathStr = "M-0.5,-0.5h1v1h-1Z";
	  }
	  draw(ctx, size, x, y) {
	    return square$2(ctx, this.parseSize(size) / 2, x, y);
	  }
	  drawOffset(ctx, size, x, y, offset) {
	    return square$2(ctx, this.parseSize(size) / 2 + offset, x, y);
	  }
	}
	var square$3 = new SquareSymbol();

	function trianglUpOffset(ctx, r, x, y, offset = 0) {
	  return ctx.moveTo(x + r + 2 * offset, r + y + offset), ctx.lineTo(x - r - 2 * offset, r + y + offset), ctx.lineTo(x, y - r - 2 * offset), ctx.closePath(), !0;
	}
	class TriangleUpSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "triangleUp", this.pathStr = "M0.5,0.5 L-0.5,0.5 L0,-0.5 Z";
	  }
	  draw(ctx, size, x, y) {
	    return trianglUpOffset(ctx, this.parseSize(size) / 2, x, y);
	  }
	  drawOffset(ctx, size, x, y, offset) {
	    return trianglUpOffset(ctx, this.parseSize(size) / 2, x, y, offset);
	  }
	}
	var triangleUp = new TriangleUpSymbol();

	class TriangleSymbol extends TriangleUpSymbol {
	  constructor() {
	    super(...arguments), this.type = "triangle";
	  }
	}
	var triangle$1 = new TriangleSymbol();

	const kr = Math.sin(Math.PI / 10) / Math.sin(7 * Math.PI / 10),
	  kx = Math.sin(tau / 10) * kr,
	  ky = -Math.cos(tau / 10) * kr;
	function star$1(ctx, r, transX, transY) {
	  const x = kx * r,
	    y = ky * r;
	  ctx.moveTo(transX, -r + transY), ctx.lineTo(x + transX, y + transY);
	  for (let i = 1; i < 5; ++i) {
	    const a = tau * i / 5,
	      c = Math.cos(a),
	      s = Math.sin(a);
	    ctx.lineTo(s * r + transX, -c * r + transY), ctx.lineTo(c * x - s * y + transX, s * x + c * y + transY);
	  }
	  return ctx.closePath(), !0;
	}
	class StarSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "star", this.pathStr = "M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z";
	  }
	  draw(ctx, size, transX, transY) {
	    return star$1(ctx, this.parseSize(size) / 2, transX, transY);
	  }
	  drawOffset(ctx, size, transX, transY, offset) {
	    return star$1(ctx, this.parseSize(size) / 2 + offset, transX, transY);
	  }
	}
	var star$2 = new StarSymbol();

	const sqrt3$1 = sqrt$1(3);
	function arrow(ctx, r, transX, transY) {
	  const triangleH = r,
	    trangleBottomSide = triangleH / sqrt3$1,
	    rectW = trangleBottomSide / 5,
	    rectH = r;
	  return ctx.moveTo(0 + transX, -triangleH + transY), ctx.lineTo(trangleBottomSide / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, transY), ctx.lineTo(-trangleBottomSide / 2 + transX, transY), ctx.closePath(), !0;
	}
	class ArrowSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "arrow", this.pathStr = "M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z";
	  }
	  draw(ctx, size, transX, transY) {
	    return arrow(ctx, this.parseSize(size) / 2, transX, transY);
	  }
	  drawOffset(ctx, size, transX, transY, offset) {
	    return arrow(ctx, this.parseSize(size) / 2 + offset, transX, transY);
	  }
	}
	var arrow$1 = new ArrowSymbol();

	function wedge(ctx, r, transX, transY) {
	  const h = 2 * r;
	  return ctx.moveTo(transX, -r + transY), ctx.lineTo(h / 3 / 2 + transX, r + transY), ctx.lineTo(-h / 3 / 2 + transX, r + transY), ctx.closePath(), !0;
	}
	class WedgeSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "wedge", this.pathStr = "M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z";
	  }
	  draw(ctx, size, transX, transY) {
	    return wedge(ctx, this.parseSize(size) / 2, transX, transY);
	  }
	  drawOffset(ctx, size, transX, transY, offset) {
	    return wedge(ctx, this.parseSize(size) / 2 + offset, transX, transY);
	  }
	}
	var wedge$1 = new WedgeSymbol();

	function stroke(ctx, r, transX, transY) {
	  return ctx.moveTo(-r + transX, transY), ctx.lineTo(transX, r + transY), !1;
	}
	class StrokeSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "stroke", this.pathStr = "";
	  }
	  draw(ctx, size, transX, transY) {
	    return stroke(ctx, this.parseSize(size) / 2, transX, transY);
	  }
	  drawOffset(ctx, size, transX, transY, offset) {
	    return stroke(ctx, this.parseSize(size) / 2 + offset, transX, transY);
	  }
	}
	var stroke$1 = new StrokeSymbol();

	const c = -.5,
	  s = sqrt$1(3) / 2,
	  k = 1 / sqrt$1(12);
	function wye(ctx, r, transX, transY) {
	  const x0 = r / 2,
	    y0 = r * k,
	    x1 = x0,
	    y1 = r * k + r,
	    x2 = -x1,
	    y2 = y1;
	  return ctx.moveTo(x0 + transX, y0 + transY), ctx.lineTo(x1 + transX, y1 + transY), ctx.lineTo(x2 + transX, y2 + transY), ctx.lineTo(c * x0 - s * y0 + transX, s * x0 + c * y0 + transY), ctx.lineTo(c * x1 - s * y1 + transX, s * x1 + c * y1 + transY), ctx.lineTo(c * x2 - s * y2 + transX, s * x2 + c * y2 + transY), ctx.lineTo(c * x0 + s * y0 + transX, c * y0 - s * x0 + transY), ctx.lineTo(c * x1 + s * y1 + transX, c * y1 - s * x1 + transY), ctx.lineTo(c * x2 + s * y2 + transX, c * y2 - s * x2 + transY), ctx.closePath(), !1;
	}
	class WyeSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "wye", this.pathStr = "M0.25 0.14433756729740646L0.25 0.6443375672974064L-0.25 0.6443375672974064L-0.25 0.14433756729740643L-0.6830127018922193 -0.10566243270259357L-0.4330127018922193 -0.5386751345948129L0 -0.28867513459481287L0.4330127018922193 -0.5386751345948129L0.6830127018922193 -0.10566243270259357Z";
	  }
	  draw(ctx, size, transX, transY) {
	    return wye(ctx, this.parseSize(size) / 2, transX, transY);
	  }
	  drawOffset(ctx, size, transX, transY, offset) {
	    return wye(ctx, this.parseSize(size) / 2 + offset, transX, transY);
	  }
	}
	var wye$1 = new WyeSymbol();

	function trianglLeftOffset(ctx, r, x, y, offset) {
	  return ctx.moveTo(-r + x - 2 * offset, y), ctx.lineTo(r + x + offset, r + y + 2 * offset), ctx.lineTo(r + x + offset, y - r - 2 * offset), ctx.closePath(), !0;
	}
	class TriangleLeftSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "triangleLeft", this.pathStr = "M-0.5,0 L0.5,0.5 L0.5,-0.5 Z";
	  }
	  draw(ctx, size, x, y) {
	    return trianglLeftOffset(ctx, this.parseSize(size) / 2, x, y, 0);
	  }
	  drawOffset(ctx, size, x, y, offset) {
	    return trianglLeftOffset(ctx, this.parseSize(size) / 2, x, y, offset);
	  }
	}
	var triangleLeft = new TriangleLeftSymbol();

	function trianglRightOffset(ctx, r, x, y, offset = 0) {
	  return ctx.moveTo(x - r - offset, r + y + 2 * offset), ctx.lineTo(r + x + 2 * offset, y), ctx.lineTo(x - r - offset, y - r - 2 * offset), ctx.closePath(), !0;
	}
	class TriangleRightSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "triangleRight", this.pathStr = "M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z";
	  }
	  draw(ctx, size, x, y) {
	    return trianglRightOffset(ctx, this.parseSize(size) / 2, x, y);
	  }
	  drawOffset(ctx, size, x, y, offset) {
	    return trianglRightOffset(ctx, this.parseSize(size) / 2, x, y, offset);
	  }
	}
	var triangleRight = new TriangleRightSymbol();

	function trianglDownOffset(ctx, r, x, y, offset = 0) {
	  return ctx.moveTo(x - r - 2 * offset, y - r - offset), ctx.lineTo(x + r + 2 * offset, y - r - offset), ctx.lineTo(x, y + r + 2 * offset), ctx.closePath(), !0;
	}
	class TriangleDownSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "triangleDown", this.pathStr = "M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z";
	  }
	  draw(ctx, size, x, y) {
	    return trianglDownOffset(ctx, this.parseSize(size) / 2, x, y);
	  }
	  drawOffset(ctx, size, x, y, offset) {
	    return trianglDownOffset(ctx, this.parseSize(size) / 2, x, y, offset);
	  }
	}
	var triangleDown = new TriangleDownSymbol();

	const sqrt3 = sqrt$1(3);
	function thinTriangle(ctx, r, x, y) {
	  const h = r * sqrt3;
	  return ctx.moveTo(x, y + -h / 3 * 2), ctx.lineTo(r + x, y + h), ctx.lineTo(x - r, y + h), ctx.closePath(), !0;
	}
	class ThinTriangleSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "thinTriangle", this.pathStr = "M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z";
	  }
	  draw(ctx, size, x, y) {
	    return thinTriangle(ctx, this.parseSize(size) / 2 / sqrt3, x, y);
	  }
	  drawOffset(ctx, size, x, y, offset) {
	    return thinTriangle(ctx, this.parseSize(size) / 2 / sqrt3 + offset, x, y);
	  }
	}
	var thinTriangle$1 = new ThinTriangleSymbol();

	function arrow2Left(ctx, r, transX, transY) {
	  const r2 = 2 * r;
	  return ctx.moveTo(r + transX, transY - r2), ctx.lineTo(transX - r, transY), ctx.lineTo(r + transX, r2 + transY), !0;
	}
	class Arrow2LeftSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "arrow2Left", this.pathStr = "M 0.25 -0.5 L -0.25 0 l 0.25 0.5";
	  }
	  draw(ctx, size, transX, transY) {
	    return arrow2Left(ctx, this.parseSize(size) / 4, transX, transY);
	  }
	  drawOffset(ctx, size, transX, transY, offset) {
	    return arrow2Left(ctx, this.parseSize(size) / 4 + offset, transX, transY);
	  }
	}
	var arrow2Left$1 = new Arrow2LeftSymbol();

	function arrow2Right(ctx, r, transX, transY) {
	  const r2 = 2 * r;
	  return ctx.moveTo(transX - r, transY - r2), ctx.lineTo(transX + r, transY), ctx.lineTo(transX - r, r2 + transY), !0;
	}
	class Arrow2RightSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "arrow2Right", this.pathStr = "M -0.25 -0.5 l 0.25 0 l -0.25 0.5";
	  }
	  draw(ctx, size, transX, transY) {
	    return arrow2Right(ctx, this.parseSize(size) / 4, transX, transY);
	  }
	  drawOffset(ctx, size, transX, transY, offset) {
	    return arrow2Right(ctx, this.parseSize(size) / 4 + offset, transX, transY);
	  }
	}
	var arrow2Right$1 = new Arrow2RightSymbol();

	function arrow2Up(ctx, r, transX, transY) {
	  const r2 = 2 * r;
	  return ctx.moveTo(transX - r2, transY + r), ctx.lineTo(transX, transY - r), ctx.lineTo(transX + r2, transY + r), !0;
	}
	class Arrow2UpSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "arrow2Up", this.pathStr = "M -0.5 0.25 L 0 -0.25 l 0.5 0.25";
	  }
	  draw(ctx, size, transX, transY) {
	    return arrow2Up(ctx, this.parseSize(size) / 4, transX, transY);
	  }
	  drawOffset(ctx, size, transX, transY, offset) {
	    return arrow2Up(ctx, this.parseSize(size) / 4 + offset, transX, transY);
	  }
	}
	var arrow2Up$1 = new Arrow2UpSymbol();

	function arrow2Down(ctx, r, transX, transY) {
	  const r2 = 2 * r;
	  return ctx.moveTo(transX - r2, transY - r), ctx.lineTo(transX, transY + r), ctx.lineTo(transX + r2, transY - r), !0;
	}
	class Arrow2DownSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "arrow2Down", this.pathStr = "M -0.5 -0.25 L 0 0.25 l 0.5 -0.25";
	  }
	  draw(ctx, size, transX, transY) {
	    return arrow2Down(ctx, this.parseSize(size) / 4, transX, transY);
	  }
	  drawOffset(ctx, size, transX, transY, offset) {
	    return arrow2Down(ctx, this.parseSize(size) / 4 + offset, transX, transY);
	  }
	}
	var arrow2Down$1 = new Arrow2DownSymbol();

	function lineV(ctx, r, x, y, z) {
	  return ctx.moveTo(x, y - r), ctx.lineTo(x, y + r), !0;
	}
	class LineVSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "lineV", this.pathStr = "M0,-0.5L0,0.5";
	  }
	  draw(ctx, size, x, y, z) {
	    return lineV(ctx, this.parseSize(size) / 2, x, y);
	  }
	  drawOffset(ctx, size, x, y, offset, z) {
	    return lineV(ctx, this.parseSize(size) / 2 + offset, x, y);
	  }
	  drawToSvgPath(size, x, y, z) {
	    const r = this.parseSize(size) / 2;
	    return `M ${x}, ${y - r} L ${x},${y + r}`;
	  }
	}
	var lineV$1 = new LineVSymbol();

	function lineH(ctx, r, x, y, z) {
	  return ctx.moveTo(x - r, y), ctx.lineTo(x + r, y), !0;
	}
	class LineHSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "lineH", this.pathStr = "M-0.5,0L0.5,0";
	  }
	  draw(ctx, size, x, y, z) {
	    return lineH(ctx, this.parseSize(size) / 2, x, y);
	  }
	  drawOffset(ctx, size, x, y, offset, z) {
	    return lineH(ctx, this.parseSize(size) / 2 + offset, x, y);
	  }
	  drawToSvgPath(size, x, y, z) {
	    const r = this.parseSize(size) / 2;
	    return `M ${x - r}, ${y} L ${x + r},${y}`;
	  }
	}
	var lineH$1 = new LineHSymbol();

	function close(ctx, r, x, y, z) {
	  return ctx.moveTo(x - r, y - r), ctx.lineTo(x + r, y + r), ctx.moveTo(x + r, y - r), ctx.lineTo(x - r, y + r), !0;
	}
	class CloseSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "close", this.pathStr = "M-0.5,-0.5L0.5,0.5,M0.5,-0.5L-0.5,0.5";
	  }
	  draw(ctx, size, x, y, z) {
	    return close(ctx, this.parseSize(size) / 2, x, y);
	  }
	  drawOffset(ctx, size, x, y, offset, z) {
	    return close(ctx, this.parseSize(size) / 2 + offset, x, y);
	  }
	  drawToSvgPath(size, x, y, z) {
	    const r = this.parseSize(size) / 2;
	    return `M ${x - r}, ${y - r} L ${x + r},${y + r} M ${x + r}, ${y - r} L ${x - r},${y + r}`;
	  }
	}
	var close$1 = new CloseSymbol();

	function rectSizeArray(ctx, size, x, y) {
	  return ctx.rect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]), !1;
	}
	function rectSize(ctx, size, x, y) {
	  const w = size,
	    h = size / 2;
	  return ctx.rect(x - w / 2, y - h / 2, w, h), !1;
	}
	class RectSymbol extends BaseSymbol {
	  constructor() {
	    super(...arguments), this.type = "rect", this.pathStr = "M -0.5,0.25 L 0.5,0.25 L 0.5,-0.25,L -0.5,-0.25 Z";
	  }
	  draw(ctx, size, x, y) {
	    return isNumber$1(size) ? rectSize(ctx, size, x, y) : rectSizeArray(ctx, size, x, y);
	  }
	  drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
	    isNumber$1(size) && (size = [size, size / 2]);
	    const drawLength = 2 * (size[0] + size[1]) * clipRange,
	      points = [{
	        x: x + size[0] / 2,
	        y: y - size[1] / 2
	      }, {
	        x: x + size[0] / 2,
	        y: y + size[1] / 2
	      }, {
	        x: x - size[0] / 2,
	        y: y + size[1] / 2
	      }, {
	        x: x - size[0] / 2,
	        y: y - size[1] / 2
	      }];
	    let currLength = 0,
	      lastP = points[3];
	    ctx.moveTo(lastP.x, lastP.y);
	    for (let i = 0; i < points.length; i++) {
	      const p = points[i],
	        len = Math.sqrt((p.x - lastP.x) * (p.x - lastP.x) + (p.y - lastP.y) * (p.y - lastP.y));
	      if (currLength + len > drawLength) {
	        const dx = (p.x - lastP.x) * (drawLength - currLength) / len,
	          dy = (p.y - lastP.y) * (drawLength - currLength) / len;
	        ctx.lineTo(lastP.x + dx, lastP.y + dy);
	        break;
	      }
	      ctx.lineTo(p.x, p.y), lastP = p, currLength += len;
	    }
	    return !1;
	  }
	  drawOffset(ctx, size, x, y, offset) {
	    return isNumber$1(size) ? rectSize(ctx, size + 2 * offset, x, y) : rectSizeArray(ctx, [size[0] + 2 * offset, size[1] + 2 * offset], x, y);
	  }
	}
	var rect = new RectSymbol();

	const tempBounds = new AABBBounds();
	class CustomSymbolClass {
	  constructor(type, path, isSvg = !1) {
	    this.pathStr = "", this.type = type, isArray$1(path) ? this.svgCache = path : this.path = path, this.isSvg = isSvg;
	  }
	  drawOffset(ctx, size, x, y, offset, z, cb) {
	    return size = this.parseSize(size), this.isSvg ? !!this.svgCache && (this.svgCache.forEach(item => {
	      ctx.beginPath(), renderCommandList(item.path.commandList, ctx, x, y, size, size), cb && cb(item.path, item.attribute);
	    }), !1) : (renderCommandList(this.path.commandList, ctx, x, y, size + offset, size + offset), !1);
	  }
	  draw(ctx, size, x, y, z, cb) {
	    return size = this.parseSize(size), this.drawOffset(ctx, size, x, y, 0, z, cb);
	  }
	  parseSize(size) {
	    return isNumber$1(size) ? size : Math.min(size[0], size[1]);
	  }
	  drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
	    return size = this.parseSize(size), this.isSvg ? !!this.svgCache && (this.svgCache.forEach(item => {
	      item.path.drawWithClipRange(ctx, size, x, y, clipRange), cb && cb(item.path, item.attribute);
	    }), !1) : (this.path.drawWithClipRange(ctx, size, x, y, clipRange), !1);
	  }
	  bounds(size, bounds) {
	    if (size = this.parseSize(size), this.isSvg) {
	      if (!this.svgCache) return;
	      return bounds.clear(), void this.svgCache.forEach(({
	        path: path
	      }) => {
	        tempBounds.x1 = path.bounds.x1 * size, tempBounds.y1 = path.bounds.y1 * size, tempBounds.x2 = path.bounds.x2 * size, tempBounds.y2 = path.bounds.y2 * size, bounds.union(tempBounds);
	      });
	    }
	    this.path.bounds && (bounds.x1 = this.path.bounds.x1 * size, bounds.y1 = this.path.bounds.y1 * size, bounds.x2 = this.path.bounds.x2 * size, bounds.y2 = this.path.bounds.y2 * size);
	  }
	}

	const builtinSymbols = [circle$2, cross$1, diamond$2, square$3, thinTriangle$1, triangle$1, star$2, arrow$1, wedge$1, stroke$1, wye$1, triangleLeft, triangleRight, triangleUp, triangleDown, arrow2Left$1, arrow2Right$1, arrow2Up$1, arrow2Down$1, rect, lineV$1, lineH$1, close$1];
	const builtinSymbolsMap = {};
	builtinSymbols.forEach(symbol => {
	  builtinSymbolsMap[symbol.type] = symbol;
	});
	const builtInSymbolStrMap = {
	  arrowLeft: "M 0.25 -0.5 L -0.25 0 l 0.5 0.5",
	  arrowRight: "M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5",
	  rectRound: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
	  roundLine: "M 1.2392 -0.258 L -1.3432 -0.258 C -1.4784 -0.258 -1.588 -0.1436 -1.588 -0.002 c 0 0.1416 0.1096 0.256 0.2448 0.256 l 2.5824 0 c 0.1352 0 0.2448 -0.1144 0.2448 -0.256 C 1.484 -0.1436 1.3744 -0.258 1.2392 -0.258 z"
	};

	function getAllMatches(string, regex) {
	  const matches = [];
	  let match = regex.exec(string);
	  for (; match;) {
	    const allmatches = [];
	    allmatches.startIndex = regex.lastIndex - match[0].length;
	    const len = match.length;
	    for (let index = 0; index < len; index++) allmatches.push(match[index]);
	    matches.push(allmatches), match = regex.exec(string);
	  }
	  return matches;
	}

	class XmlNode {
	  constructor(tagname) {
	    this.tagname = tagname, this.child = [], this[":@"] = {};
	  }
	  add(key, val) {
	    "__proto__" === key && (key = "#__proto__"), this.child.push({
	      [key]: val
	    });
	  }
	  addChild(node) {
	    "__proto__" === node.tagname && (node.tagname = "#__proto__"), node[":@"] && Object.keys(node[":@"]).length > 0 ? this.child.push({
	      [node.tagname]: node.child,
	      ":@": node[":@"]
	    }) : this.child.push({
	      [node.tagname]: node.child
	    });
	  }
	}
	function findClosingIndex(xmlData, str, i, errMsg) {
	  const closingIndex = xmlData.indexOf(str, i);
	  if (-1 === closingIndex) throw new Error(errMsg);
	  return closingIndex + str.length - 1;
	}
	function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
	  let attrBoundary,
	    tagExp = "";
	  for (let index = i; index < xmlData.length; index++) {
	    let ch = xmlData[index];
	    if (attrBoundary) ch === attrBoundary && (attrBoundary = "");else if ('"' === ch || "'" === ch) attrBoundary = ch;else if (ch === closingChar[0]) {
	      if (!closingChar[1]) return {
	        data: tagExp,
	        index: index
	      };
	      if (xmlData[index + 1] === closingChar[1]) return {
	        data: tagExp,
	        index: index
	      };
	    } else "\t" === ch && (ch = " ");
	    tagExp += ch;
	  }
	}
	function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
	  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
	  if (!result) return;
	  let tagExp = result.data;
	  const closeIndex = result.index,
	    separatorIndex = tagExp.search(/\s/);
	  let tagName = tagExp,
	    attrExpPresent = !0;
	  -1 !== separatorIndex && (tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, ""), tagExp = tagExp.substr(separatorIndex + 1));
	  const rawTagName = tagName;
	  if (removeNSPrefix) {
	    const colonIndex = tagName.indexOf(":");
	    -1 !== colonIndex && (tagName = tagName.substr(colonIndex + 1), attrExpPresent = tagName !== result.data.substr(colonIndex + 1));
	  }
	  return {
	    tagName: tagName,
	    tagExp: tagExp,
	    closeIndex: closeIndex,
	    attrExpPresent: attrExpPresent,
	    rawTagName: rawTagName
	  };
	}
	const attrsRegx = new RegExp("([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?", "gm");
	class OrderedObjParser {
	  constructor(options) {
	    this.currentNode = null, this.options = options, this.tagsNodeStack = [], this.docTypeEntities = {};
	  }
	  addChild(currentNode, childNode, jPath) {
	    const result = childNode.tagname;
	    "string" == typeof result ? (childNode.tagname = result, currentNode.addChild(childNode)) : currentNode.addChild(childNode);
	  }
	  buildAttributesMap(attrStr, jPath, tagName) {
	    const attrs = {};
	    if (!attrStr) return;
	    const matches = getAllMatches(attrStr, attrsRegx),
	      len = matches.length;
	    for (let i = 0; i < len; i++) {
	      const attrName = matches[i][1],
	        oldVal = matches[i][4],
	        aName = attrName;
	      attrName && (attrs[aName] = void 0 === oldVal || (isNaN(oldVal) ? oldVal : Number(oldVal)));
	    }
	    return attrs;
	  }
	  parseXml(xmlData) {
	    xmlData = xmlData.replace(/\r\n?/g, "\n");
	    const xmlObj = new XmlNode("!xml");
	    let currentNode = xmlObj,
	      textData = "",
	      jPath = "";
	    for (let i = 0; i < xmlData.length; i++) {
	      if ("<" === xmlData[i]) {
	        if ("/" === xmlData[i + 1]) {
	          const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed."),
	            propIndex = jPath.lastIndexOf(".");
	          jPath = jPath.substring(0, propIndex), currentNode = this.tagsNodeStack.pop(), currentNode && currentNode.child && textData && currentNode.child[currentNode.child.length - 1][":@"] && (currentNode.child[currentNode.child.length - 1][":@"].text = textData), textData = "", i = closeIndex;
	        } else if ("?" === xmlData[i + 1]) {
	          i = readTagExp(xmlData, i, !1, "?>").closeIndex + 1;
	        } else if ("!--" === xmlData.substr(i + 1, 3)) {
	          i = findClosingIndex(xmlData, "--\x3e", i + 4, "Comment is not closed.");
	        } else {
	          const result = readTagExp(xmlData, i, !1);
	          let tagName = result.tagName,
	            tagExp = result.tagExp;
	          const attrExpPresent = result.attrExpPresent,
	            closeIndex = result.closeIndex;
	          if (tagName !== xmlObj.tagname && (jPath += jPath ? "." + tagName : tagName), tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
	            "/" === tagName[tagName.length - 1] ? (tagName = tagName.substr(0, tagName.length - 1), jPath = jPath.substr(0, jPath.length - 1), tagExp = tagName) : tagExp = tagExp.substr(0, tagExp.length - 1);
	            const childNode = new XmlNode(tagName);
	            tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), jPath = jPath.substr(0, jPath.lastIndexOf("."));
	          } else {
	            const childNode = new XmlNode(tagName);
	            this.tagsNodeStack.push(currentNode), tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), currentNode = childNode;
	          }
	          textData = "", i = closeIndex;
	        }
	      } else textData += xmlData[i];
	    }
	    return xmlObj.child;
	  }
	}

	function prettify(node, options) {
	  return compress(node);
	}
	function compress(arr, jPath) {
	  const compressedObj = {};
	  for (let i = 0; i < arr.length; i++) {
	    const tagObj = arr[i],
	      property = propName(tagObj);
	    if (void 0 !== property && tagObj[property]) {
	      const val = compress(tagObj[property]);
	      isLeafTag(val);
	      tagObj[":@"] && assignAttributes(val, tagObj[":@"]), void 0 !== compressedObj[property] && compressedObj.hasOwnProperty(property) ? (Array.isArray(compressedObj[property]) || (compressedObj[property] = [compressedObj[property]]), compressedObj[property].push(val)) : compressedObj[property] = val;
	    }
	  }
	  return compressedObj;
	}
	function propName(obj) {
	  const keys = Object.keys(obj);
	  for (let i = 0; i < keys.length; i++) {
	    const key = keys[i];
	    if (":@" !== key) return key;
	  }
	}
	function assignAttributes(obj, attrMap, jpath) {
	  if (attrMap) {
	    const keys = Object.keys(attrMap),
	      len = keys.length;
	    for (let i = 0; i < len; i++) {
	      const atrrName = keys[i];
	      obj[atrrName] = attrMap[atrrName];
	    }
	  }
	}
	function isLeafTag(obj) {
	  return 0 === Object.keys(obj).length;
	}

	class XMLParser {
	  constructor(options) {
	    this.options = Object.assign({}, XMLParser.defaultOptions, options);
	  }
	  valid(xml) {
	    return xml.startsWith("<");
	  }
	  parse(xmlData) {
	    if (!this.valid) return !1;
	    const orderedResult = new OrderedObjParser(this.options).parseXml(xmlData);
	    return prettify(orderedResult, this.options);
	  }
	}
	XMLParser.defaultOptions = {};
	function isSvg(str) {
	  return str.startsWith("<svg") || str.startsWith("<?xml");
	}

	undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
	  return new (P || (P = Promise))(function (resolve, reject) {
	    function fulfilled(value) {
	      try {
	        step(generator.next(value));
	      } catch (e) {
	        reject(e);
	      }
	    }
	    function rejected(value) {
	      try {
	        step(generator.throw(value));
	      } catch (e) {
	        reject(e);
	      }
	    }
	    function step(result) {
	      var value;
	      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      })).then(fulfilled, rejected);
	    }
	    step((generator = generator.apply(thisArg, _arguments || [])).next());
	  });
	};
	function boundStroke(bounds, halfW, miter, pad = 0) {
	  return bounds.expand(halfW + (pad / 2 + (miter ? miterAdjustment(miter, halfW) : 0))), bounds;
	}
	function miterAdjustment(miter, strokeWidth) {
	  return miter ? strokeWidth : 0;
	}
	let NUMBER_TYPE = 0;
	function genNumberType() {
	  return NUMBER_TYPE++;
	}
	var TextDirection;
	!function (TextDirection) {
	  TextDirection[TextDirection.HORIZONTAL = 0] = "HORIZONTAL", TextDirection[TextDirection.VERTICAL = 1] = "VERTICAL";
	}(TextDirection || (TextDirection = {}));
	function verticalLayout(text) {
	  const nextCharacter = [];
	  let flag = 0,
	    currStr = "";
	  for (let i = 0; i < text.length; i++) rotateText(text[i]) ? flag ? currStr += text[i] : (flag = 1, currStr = text[i]) : (flag && (nextCharacter.push({
	    text: currStr,
	    direction: TextDirection.VERTICAL
	  }), currStr = "", flag = 0), nextCharacter.push({
	    text: text[i],
	    direction: TextDirection.HORIZONTAL
	  }));
	  return currStr && nextCharacter.push({
	    text: currStr,
	    direction: TextDirection.VERTICAL
	  }), nextCharacter;
	}
	const rotateCharList = ["…", "（", "）", "—", "【", "】", "「", "」", "《", "》"],
	  rotateCharMap = new Map();
	rotateCharList.forEach(c => rotateCharMap.set(c, !0));
	const noRotateCharList = [""],
	  noRotateCharMap = new Map();
	function rotateText(c) {
	  if (rotateCharMap.has(c)) return !0;
	  if (noRotateCharMap.has(c)) return !1;
	  let rotate = !1;
	  return c.codePointAt(0) < 256 && (rotate = !0), rotate;
	}
	noRotateCharList.forEach(c => noRotateCharMap.set(c, !0));

	const ARC_NUMBER_TYPE = genNumberType();
	const ARC3D_NUMBER_TYPE = genNumberType();
	const AREA_NUMBER_TYPE = genNumberType();
	genNumberType();
	genNumberType();
	const GROUP_NUMBER_TYPE = genNumberType();
	const IMAGE_NUMBER_TYPE = genNumberType();
	const LINE_NUMBER_TYPE = genNumberType();
	const PATH_NUMBER_TYPE = genNumberType();
	const POLYGON_NUMBER_TYPE = genNumberType();
	const PYRAMID3D_NUMBER_TYPE = genNumberType();
	const RECT_NUMBER_TYPE = genNumberType();
	const RECT3D_NUMBER_TYPE = genNumberType();
	const RICHTEXT_NUMBER_TYPE = genNumberType();
	genNumberType();
	const SYMBOL_NUMBER_TYPE = genNumberType();
	const TEXT_NUMBER_TYPE = genNumberType();
	const GraphicCreator$1 = Symbol.for("GraphicCreator");
	const SVG_PARSE_ATTRIBUTE_MAP = {
	  "stroke-linecap": "lineCap",
	  "stroke-linejoin": "lineJoin",
	  "stroke-dasharray": "lineDash",
	  "stroke-dashoffset": "lineDashOffset",
	  "stroke-width": "lineWidth",
	  "fill-opacity": "fillOpacity",
	  "stroke-opacity": "strokeOpacity",
	  stroke: "stroke",
	  fill: "fill"
	};
	const SVG_PARSE_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_PARSE_ATTRIBUTE_MAP);

	const DefaultStateAnimateConfig = {
	  duration: 200,
	  easing: "cubicOut"
	};

	function identityMat4(out) {
	  return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, out[14] = 0, out[15] = 1, out;
	}
	function rotateX(out, a, rad) {
	  const s = Math.sin(rad),
	    c = Math.cos(rad),
	    a10 = a[4],
	    a11 = a[5],
	    a12 = a[6],
	    a13 = a[7],
	    a20 = a[8],
	    a21 = a[9],
	    a22 = a[10],
	    a23 = a[11];
	  return a !== out && (out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[4] = a10 * c + a20 * s, out[5] = a11 * c + a21 * s, out[6] = a12 * c + a22 * s, out[7] = a13 * c + a23 * s, out[8] = a20 * c - a10 * s, out[9] = a21 * c - a11 * s, out[10] = a22 * c - a12 * s, out[11] = a23 * c - a13 * s, out;
	}
	function rotateY(out, a, rad) {
	  const s = Math.sin(rad),
	    c = Math.cos(rad),
	    a00 = a[0],
	    a01 = a[1],
	    a02 = a[2],
	    a03 = a[3],
	    a20 = a[8],
	    a21 = a[9],
	    a22 = a[10],
	    a23 = a[11];
	  return a !== out && (out[4] = a[4], out[5] = a[5], out[6] = a[6], out[7] = a[7], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c - a20 * s, out[1] = a01 * c - a21 * s, out[2] = a02 * c - a22 * s, out[3] = a03 * c - a23 * s, out[8] = a00 * s + a20 * c, out[9] = a01 * s + a21 * c, out[10] = a02 * s + a22 * c, out[11] = a03 * s + a23 * c, out;
	}
	function rotateZ(out, a, rad) {
	  const s = Math.sin(rad),
	    c = Math.cos(rad),
	    a00 = a[0],
	    a01 = a[1],
	    a02 = a[2],
	    a03 = a[3],
	    a10 = a[4],
	    a11 = a[5],
	    a12 = a[6],
	    a13 = a[7];
	  return a !== out && (out[8] = a[8], out[9] = a[9], out[10] = a[10], out[11] = a[11], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c + a10 * s, out[1] = a01 * c + a11 * s, out[2] = a02 * c + a12 * s, out[3] = a03 * c + a13 * s, out[4] = a10 * c - a00 * s, out[5] = a11 * c - a01 * s, out[6] = a12 * c - a02 * s, out[7] = a13 * c - a03 * s, out;
	}
	function translate(out, a, v) {
	  const x = v[0],
	    y = v[1],
	    z = v[2];
	  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
	  return a === out ? (out[12] = a[0] * x + a[4] * y + a[8] * z + a[12], out[13] = a[1] * x + a[5] * y + a[9] * z + a[13], out[14] = a[2] * x + a[6] * y + a[10] * z + a[14], out[15] = a[3] * x + a[7] * y + a[11] * z + a[15]) : (a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], out[0] = a00, out[1] = a01, out[2] = a02, out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x + a10 * y + a20 * z + a[12], out[13] = a01 * x + a11 * y + a21 * z + a[13], out[14] = a02 * x + a12 * y + a22 * z + a[14], out[15] = a03 * x + a13 * y + a23 * z + a[15]), out;
	}
	function scaleMat4(out, a, v) {
	  const x = v[0],
	    y = v[1],
	    z = v[2];
	  return out[0] = a[0] * x, out[1] = a[1] * x, out[2] = a[2] * x, out[3] = a[3] * x, out[4] = a[4] * y, out[5] = a[5] * y, out[6] = a[6] * y, out[7] = a[7] * y, out[8] = a[8] * z, out[9] = a[9] * z, out[10] = a[10] * z, out[11] = a[11] * z, out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15], out;
	}
	function multiplyMat4Mat4(out, a, b) {
	  const a00 = a[0],
	    a01 = a[1],
	    a02 = a[2],
	    a03 = a[3],
	    a10 = a[4],
	    a11 = a[5],
	    a12 = a[6],
	    a13 = a[7],
	    a20 = a[8],
	    a21 = a[9],
	    a22 = a[10],
	    a23 = a[11],
	    a30 = a[12],
	    a31 = a[13],
	    a32 = a[14],
	    a33 = a[15];
	  let b0 = b[0],
	    b1 = b[1],
	    b2 = b[2],
	    b3 = b[3];
	  return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
	}
	function lookAt(out, eye, center, up) {
	  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
	  const eyex = eye[0],
	    eyey = eye[1],
	    eyez = eye[2],
	    upx = up[0],
	    upy = up[1],
	    upz = up[2],
	    centerx = center[0],
	    centery = center[1],
	    centerz = center[2];
	  return Math.abs(eyex - centerx) < epsilon && Math.abs(eyey - centery) < epsilon && Math.abs(eyez - centerz) < epsilon ? identityMat4(out) : (z0 = eyex - centerx, z1 = eyey - centery, z2 = eyez - centerz, len = 1 / Math.hypot(z0, z1, z2), z0 *= len, z1 *= len, z2 *= len, x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0, len = Math.hypot(x0, x1, x2), len ? (len = 1 / len, x0 *= len, x1 *= len, x2 *= len) : (x0 = 0, x1 = 0, x2 = 0), y0 = z1 * x2 - z2 * x1, y1 = z2 * x0 - z0 * x2, y2 = z0 * x1 - z1 * x0, len = Math.hypot(y0, y1, y2), len ? (len = 1 / len, y0 *= len, y1 *= len, y2 *= len) : (y0 = 0, y1 = 0, y2 = 0), out[0] = x0, out[1] = y0, out[2] = z0, out[3] = 0, out[4] = x1, out[5] = y1, out[6] = z1, out[7] = 0, out[8] = x2, out[9] = y2, out[10] = z2, out[11] = 0, out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez), out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez), out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez), out[15] = 1, out);
	}
	function ortho(out, left, right, bottom, top, near, far) {
	  const lr = 1 / (left - right),
	    bt = 1 / (bottom - top),
	    nf = 1 / (near - far);
	  return out[0] = -2 * lr, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = -2 * bt, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 2 * nf, out[11] = 0, out[12] = (left + right) * lr, out[13] = (top + bottom) * bt, out[14] = (far + near) * nf, out[15] = 1, out;
	}
	function transformMat4(out, a, m) {
	  const x = a[0],
	    y = a[1],
	    z = a[2];
	  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
	  return w = w || 1, out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w, out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w, out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w, out;
	}

	function createMat4() {
	  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	}
	class DefaultMatrixAllocate {
	  constructor() {
	    this.pools = [];
	  }
	  allocate(a, b, c, d, e, f) {
	    if (!this.pools.length) return new Matrix(a, b, c, d, e, f);
	    const m = this.pools.pop();
	    return m.a = a, m.b = b, m.c = c, m.d = d, m.e = e, m.f = f, m;
	  }
	  allocateByObj(matrix) {
	    if (!this.pools.length) return new Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
	    const m = this.pools.pop();
	    return m.a = matrix.a, m.b = matrix.b, m.c = matrix.c, m.d = matrix.d, m.e = matrix.e, m.f = matrix.f, m;
	  }
	  free(d) {
	    this.pools.push(d);
	  }
	  get length() {
	    return this.pools.length;
	  }
	  release(...params) {
	    this.pools = [];
	  }
	}
	class DefaultMat4Allocate {
	  constructor() {
	    this.pools = [];
	  }
	  static identity(out) {
	    return identityMat4(out);
	  }
	  allocate() {
	    if (!this.pools.length) return createMat4();
	    const m = this.pools.pop();
	    return DefaultMat4Allocate.identity(m), m;
	  }
	  allocateByObj(d) {
	    let m;
	    m = this.pools.length ? this.pools.pop() : createMat4();
	    for (let i = 0; i < m.length; i++) m[i] = d[i];
	    return m;
	  }
	  free(m) {
	    m && this.pools.push(m);
	  }
	  get length() {
	    return this.pools.length;
	  }
	  release(...params) {
	    this.pools = [];
	  }
	}
	const matrixAllocate = new DefaultMatrixAllocate();
	const mat4Allocate = new DefaultMat4Allocate();

	var __decorate$x = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$p = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  };
	const initMatrix = new Matrix(1, 0, 0, 1, 0, 0),
	  globalPoint = {
	    x: 0,
	    y: 0
	  };
	let EmptyContext2d = class {
	  get nativeContext() {
	    return this.path;
	  }
	  constructor(canvas, dpr) {
	    this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.path = new CustomPath2D(), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0);
	  }
	  getCanvas() {
	    throw new Error("不支持getCanvas");
	  }
	  getContext() {
	    throw new Error("不支持getContext");
	  }
	  setTransformForCurrent(force = !1) {
	    !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix = this.cloneMatrix(this.matrix));
	  }
	  get currentMatrix() {
	    return this.matrix;
	  }
	  cloneMatrix(m) {
	    return matrixAllocate.allocateByObj(m);
	  }
	  clear() {
	    this.save(), this.resetTransform(), this.restore();
	  }
	  reset() {
	    this.matrix.setValue(1, 0, 0, 1, 0, 0), this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack.length = 0;
	  }
	  restore() {
	    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent());
	  }
	  highPerformanceRestore() {
	    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
	  }
	  rotate(rad, setTransform = !0) {
	    this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
	  }
	  save() {
	    const matrix = this.cloneMatrix(this.matrix);
	    this.stack.push(matrix);
	  }
	  highPerformanceSave() {
	    const matrix = this.cloneMatrix(this.matrix);
	    this.stack.push(matrix);
	  }
	  scale(sx, sy, setTransform = !0) {
	    this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
	  }
	  setScale(sx, sy, setTransform = !0) {
	    this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
	  }
	  scalePoint(sx, sy, px, py, setTransform = !0) {
	    this.translate(px, py, !1), this.scale(sx, sy, !1), this.translate(-px, -py, !1), setTransform && this.setTransformForCurrent();
	  }
	  setTransform(a, b, c, d, e, f, setTransform = !0, dpr = this.dpr) {
	    this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
	  }
	  setTransformFromMatrix(matrix, setTransform = !0, dpr = this.dpr) {
	    this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
	  }
	  resetTransform(setTransform = !0, dpr = this.dpr) {
	    this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
	  }
	  transform(a, b, c, d, e, f, setTransform = !0) {
	    this.matrix.multiply(a, b, c, d, e, f), setTransform && this.setTransformForCurrent();
	  }
	  transformFromMatrix(matrix, setTransform) {
	    this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
	  }
	  translate(x, y, setTransform = !0) {
	    this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
	  }
	  rotateDegrees(deg, setTransform = !0) {
	    const rad = deg * Math.PI / 180;
	    this.rotate(rad, setTransform);
	  }
	  rotateAbout(rad, x, y, setTransform = !0) {
	    this.translate(x, y, !1), this.rotate(rad, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
	  }
	  rotateDegreesAbout(deg, x, y, setTransform = !0) {
	    this.translate(x, y, !1), this.rotateDegrees(deg, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
	  }
	  beginPath() {
	    this.path.clear();
	  }
	  clip(path, fillRule) {}
	  arc(x, y, radius, startAngle, endAngle, anticlockwise) {
	    this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
	  }
	  arcTo(x1, y1, x2, y2, radiusX) {
	    this.path.arcTo(x1, y1, x2, y2, radiusX);
	  }
	  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
	    this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
	  }
	  closePath() {
	    this.path.closePath();
	  }
	  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {}
	  lineTo(x, y) {
	    this.path.lineTo(x, y);
	  }
	  moveTo(x, y) {
	    this.path.moveTo(x, y);
	  }
	  quadraticCurveTo(cpx, cpy, x, y) {
	    this.path.quadraticCurveTo(cpx, cpy, x, y);
	  }
	  rect(x, y, w, h) {
	    this.path.rect(x, y, w, h);
	  }
	  createImageData(imageDataOrSw, sh) {
	    return null;
	  }
	  createLinearGradient(x0, y0, x1, y1) {
	    throw new Error("不支持createLinearGradient");
	  }
	  createPattern(image, repetition) {
	    throw new Error("不支持createPattern");
	  }
	  createRadialGradient(x0, y0, r0, x1, y1, r1) {
	    throw new Error("不支持createRadialGradient");
	  }
	  createConicGradient(x, y, startAngle, endAngle) {
	    return null;
	  }
	  fill(path, fillRule) {}
	  fillRect(x, y, width, height) {
	    this.path.rect(x, y, width, height);
	  }
	  clearRect(x, y, w, h) {}
	  fillText(text, x, y) {}
	  getImageData(sx, sy, sw, sh) {
	    return null;
	  }
	  getLineDash() {
	    return [];
	  }
	  isPointInPath(x, y) {
	    return this.matrix.transformPoint({
	      x: x,
	      y: y
	    }, globalPoint), contain(this.path.commandList, globalPoint.x, globalPoint.y);
	  }
	  isPointInStroke(x, y) {
	    if (!this.lineWidth) return !1;
	    this.matrix.transformPoint({
	      x: x,
	      y: y
	    }, globalPoint);
	    const lineWidth = getScaledStroke(this, this.lineWidth, this.dpr);
	    return containStroke(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);
	  }
	  measureText(text) {
	    throw new Error("不支持measureText");
	  }
	  putImageData(imagedata, dx, dy) {
	    throw new Error("不支持measureText");
	  }
	  setLineDash(segments) {}
	  stroke(path) {}
	  strokeRect(x, y, width, height) {
	    this.path.rect(x, y, width, height);
	  }
	  strokeText(text, x, y) {}
	  drawImage() {}
	  setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {}
	  _setCommonStyle(params, offsetX, offsetY, defaultParams) {}
	  setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {}
	  _setStrokeStyle(params, offsetX, offsetY, defaultParams) {}
	  setTextStyleWithoutAlignBaseline(params, defaultParams) {}
	  setTextStyle(params, defaultParams) {}
	  draw() {}
	  clearMatrix(setTransform = !0, dpr = this.dpr) {
	    this.setTransformFromMatrix(initMatrix, setTransform, dpr);
	  }
	  setClearMatrix(a, b, c, d, e, f) {
	    this._clearMatrix.setValue(a, b, c, d, e, f);
	  }
	  onlyTranslate(dpr = this.dpr) {
	    return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
	  }
	  release(...params) {
	    this.stack.forEach(m => matrixAllocate.free(m)), this.stack.length = 0;
	  }
	};
	EmptyContext2d = __decorate$x([injectable(), __metadata$p("design:paramtypes", [Object, Number])], EmptyContext2d);

	var ColorType;
	!function (ColorType) {
	  ColorType[ColorType.Color255 = 0] = "Color255", ColorType[ColorType.Color1 = 1] = "Color1";
	}(ColorType || (ColorType = {}));
	class ColorStore {
	  static Get(str, size = ColorType.Color1, arr = [0, 0, 0, 1]) {
	    if (size === ColorType.Color1) {
	      const color = ColorStore.store1[str];
	      if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
	      const c = Color.parseColorString(str);
	      if (c) {
	        const data = [c.r / 255, c.g / 255, c.b / 255, c.opacity];
	        ColorStore.store1[str] = data, ColorStore.store255[str] = [c.r, c.g, c.b, c.opacity], arr[0] = data[0], arr[1] = data[1], arr[2] = data[2], arr[3] = data[3];
	      }
	      return arr;
	    }
	    const color = ColorStore.store255[str];
	    if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
	    const c = Color.parseColorString(str);
	    return c && (ColorStore.store1[str] = [c.r / 255, c.g / 255, c.b / 255, c.opacity], ColorStore.store255[str] = [c.r, c.g, c.b, c.opacity], arr[0] = c.r, arr[1] = c.g, arr[2] = c.b, arr[3] = c.opacity), arr;
	  }
	  static Set(str, size, arr) {
	    if (size === ColorType.Color1) {
	      if (ColorStore.store1[str]) return;
	      ColorStore.store1[str] = arr, ColorStore.store255[str] = [Math.floor(255 * arr[0]), Math.floor(255 * arr[1]), Math.floor(255 * arr[2]), Math.floor(255 * arr[3])];
	    } else {
	      if (ColorStore.store255[str]) return;
	      ColorStore.store255[str] = arr, ColorStore.store1[str] = [arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3]];
	    }
	  }
	}
	ColorStore.store255 = {}, ColorStore.store1 = {};

	function colorArrayToString(color, alphaChannel = !1) {
	  return Array.isArray(color) && isNumber$1(color[0]) ? alphaChannel ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})` : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})` : color;
	}
	function interpolateColor(from, to, ratio, alphaChannel, cb) {
	  if (Array.isArray(from) && !isNumber$1(from[0]) || Array.isArray(to) && !isNumber$1(to[0])) {
	    return new Array(4).fill(0).map((_, index) => {
	      var _a, _b;
	      return _interpolateColor(isArray$1(from) ? null !== (_a = from[index]) && void 0 !== _a ? _a : from[0] : from, isArray$1(to) ? null !== (_b = to[index]) && void 0 !== _b ? _b : to[0] : to, ratio, alphaChannel);
	    });
	  }
	  return _interpolateColor(from, to, ratio, alphaChannel, cb);
	}
	function _interpolateColor(from, to, ratio, alphaChannel, cb) {
	  if (!from || !to) return from && colorArrayToString(from) || to && colorArrayToString(to) || !1;
	  let fromArray,
	    toArray,
	    fromGradient = !1,
	    toGradient = !1;
	  if (Array.isArray(from) ? fromArray = from : "string" == typeof from ? fromArray = ColorStore.Get(from, ColorType.Color255) : fromGradient = !0, Array.isArray(to) ? toArray = to : "string" == typeof to ? toArray = ColorStore.Get(to, ColorType.Color255) : toGradient = !0, fromGradient !== toGradient) {
	    const gradient = fromGradient ? from : to,
	      pure = fromGradient ? to : from,
	      gradientFromPure = Object.assign(Object.assign({}, gradient), {
	        stops: gradient.stops.map(v => Object.assign(Object.assign({}, v), {
	          color: colorArrayToString(pure)
	        }))
	      });
	    return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
	  }
	  if (fromGradient) {
	    if (from.gradient === to.gradient) {
	      const fc = from,
	        tc = to,
	        fromStops = fc.stops,
	        toStops = tc.stops;
	      if (fromStops.length !== toStops.length) return !1;
	      if ("linear" === fc.gradient) return interpolateGradientLinearColor(fc, tc, ratio);
	      if ("radial" === fc.gradient) return interpolateGradientRadialColor(fc, tc, ratio);
	      if ("conical" === fc.gradient) return interpolateGradientConicalColor(fc, tc, ratio);
	    }
	    return !1;
	  }
	  cb && cb(fromArray, toArray);
	  return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);
	}
	function interpolateGradientLinearColor(fc, tc, ratio) {
	  const fStops = fc.stops,
	    tStops = tc.stops;
	  return {
	    gradient: "linear",
	    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
	    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
	    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
	    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
	    stops: new Array(fStops.length).fill(0).map((_, i) => ({
	      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
	      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
	    }))
	  };
	}
	function interpolateGradientRadialColor(fc, tc, ratio) {
	  const fStops = fc.stops,
	    tStops = tc.stops;
	  return {
	    gradient: "radial",
	    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
	    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
	    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
	    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
	    r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
	    r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
	    stops: new Array(fStops.length).fill(0).map((_, i) => ({
	      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
	      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
	    }))
	  };
	}
	function interpolateGradientConicalColor(fc, tc, ratio) {
	  const fStops = fc.stops,
	    tStops = tc.stops;
	  return {
	    gradient: "conical",
	    startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
	    endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
	    x: fc.x + (tc.x - fc.x) * ratio,
	    y: fc.y + (tc.y - fc.y) * ratio,
	    stops: new Array(fStops.length).fill(0).map((_, i) => ({
	      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
	      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
	    }))
	  };
	}
	function interpolatePureColorArray(from, to, ratio) {
	  return [from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio];
	}
	function interpolatePureColorArrayToStr(from, to, ratio) {
	  return `rgba(${from[0] + (to[0] - from[0]) * ratio},${from[1] + (to[1] - from[1]) * ratio},${from[2] + (to[2] - from[2]) * ratio},${from[3] + (to[3] - from[3]) * ratio})`;
	}
	const _fromColorRGB = [0, 0, 0, 0],
	  _toColorRGB = [0, 0, 0, 0];
	function colorStringInterpolationToStr(fromColor, toColor, ratio) {
	  return ColorStore.Get(fromColor, ColorType.Color255, _fromColorRGB), ColorStore.Get(toColor, ColorType.Color255, _toColorRGB), `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
	}

	function getConicGradientAt(x, y, angle, color) {
	  const {
	    stops: stops,
	    startAngle: startAngle,
	    endAngle: endAngle
	  } = color;
	  for (; angle < 0;) angle += pi2;
	  for (; angle > pi2;) angle -= pi2;
	  if (angle < startAngle) return stops[0].color;
	  if (angle > endAngle) return stops[0].color;
	  let startStop,
	    endStop,
	    percent = (angle - startAngle) / (endAngle - startAngle);
	  for (let i = 0; i < stops.length; i++) if (stops[i].offset >= percent) {
	    startStop = stops[i - 1], endStop = stops[i];
	    break;
	  }
	  return percent = (percent - startStop.offset) / (endStop.offset - startStop.offset), interpolateColor(startStop.color, endStop.color, percent, !1);
	}

	const _tempBounds = new AABBBounds(),
	  tempMatrix = new Matrix();
	  new AABBBounds();
	const GRAPHIC_UPDATE_TAG_KEY = ["lineWidth", "scaleX", "scaleY", "angle", "anchor", "visible"];
	const tempConstantXYKey = ["x", "y"],
	  tempConstantScaleXYKey = ["scaleX", "scaleY"],
	  tempConstantAngleKey = ["angle"],
	  point = new Point();
	const NOWORK_ANIMATE_ATTR = {
	  strokeSeg: 1,
	  boundsPadding: 2,
	  pickMode: 1,
	  boundsMode: 1,
	  customPickShape: 1,
	  pickable: 1,
	  childrenPickable: 1,
	  visible: 1,
	  zIndex: 1,
	  layout: 1,
	  keepDirIn3d: 1,
	  globalZIndex: 1,
	  outerBorder: 1,
	  innerBorder: 1,
	  lineDash: 1,
	  lineCap: 1,
	  lineJoin: 1,
	  miterLimit: 2,
	  strokeBoundsBuffer: 2,
	  scaleCenter: 1,
	  anchor: 1,
	  anchor3d: 1,
	  postMatrix: 1,
	  backgroundMode: 2,
	  background: 1,
	  texture: 1,
	  cursor: 1,
	  html: 1
	};
	class Graphic extends Node {
	  static mixin(source) {
	    const keys = Object.keys(source);
	    for (let i = 0; i < keys.length; ++i) {
	      const propertyName = keys[i];
	      Object.defineProperty(Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
	    }
	  }
	  get AABBBounds() {
	    return this.tryUpdateAABBBounds();
	  }
	  get OBBBounds() {
	    return this.tryUpdateOBBBounds();
	  }
	  get globalAABBBounds() {
	    return this.tryUpdateGlobalAABBBounds();
	  }
	  get transMatrix() {
	    return this.tryUpdateLocalTransMatrix(!0);
	  }
	  get globalTransMatrix() {
	    return this.tryUpdateGlobalTransMatrix(!0);
	  }
	  constructor(params = {}) {
	    var _a;
	    super(), this._AABBBounds = new AABBBounds(), this._updateTag = UpdateTag.INIT, this.attribute = params, this.valid = this.isValid(), this.updateAABBBoundsStamp = 0, params.background ? this.loadImage(null !== (_a = params.background.background) && void 0 !== _a ? _a : params.background, !0) : params.shadowGraphic && this.setShadowGraphic(params.shadowGraphic);
	  }
	  getGraphicService() {
	    var _a, _b;
	    return null !== (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.graphicService) && void 0 !== _b ? _b : application.graphicService;
	  }
	  getAttributes() {
	    return this.attribute;
	  }
	  setMode(mode) {
	    "3d" === mode ? this.set3dMode() : this.set2dMode();
	  }
	  set3dMode() {
	    this.in3dMode = !0;
	  }
	  set2dMode() {
	    this.in3dMode = !1;
	  }
	  getOffsetXY(attr, includeScroll = !1) {
	    var _a, _b;
	    const {
	      dx = attr.dx,
	      dy = attr.dy
	    } = this.attribute;
	    if (includeScroll && this.parent) {
	      const attribute = this.parent.attribute;
	      point.x = dx + (null !== (_a = attribute.scrollX) && void 0 !== _a ? _a : 0), point.y = dy + (null !== (_b = attribute.scrollY) && void 0 !== _b ? _b : 0);
	    } else point.x = dx, point.y = dy;
	    return point;
	  }
	  onAnimateBind(animate) {
	    this._emitCustomEvent("animate-bind", animate);
	  }
	  tryUpdateAABBBounds() {
	    const full = "imprecise" === this.attribute.boundsMode;
	    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
	    if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;
	    this.getGraphicService().beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
	    const bounds = this.doUpdateAABBBounds(full);
	    return this.getGraphicService().afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, !0), "empty" === this.attribute.boundsMode && bounds.clear(), bounds;
	  }
	  tryUpdateOBBBounds() {
	    if (this._OBBBounds || (this._OBBBounds = new OBBBounds()), this.tryUpdateAABBBounds(), this.updateOBBBoundsStamp === this.updateAABBBoundsStamp) return this._OBBBounds;
	    if (this.updateOBBBoundsStamp = this.updateAABBBoundsStamp, !this.valid) return this._OBBBounds.clear(), this._OBBBounds;
	    return this.doUpdateOBBBounds();
	  }
	  combindShadowAABBBounds(bounds) {
	    if (this.shadowRoot) {
	      const b = this.shadowRoot.AABBBounds.clone();
	      bounds.union(b);
	    }
	  }
	  doUpdateOBBBounds() {
	    return this._OBBBounds;
	  }
	  getClipPath() {
	    const {
	      clipConfig: clipConfig
	    } = this.attribute;
	    if (!clipConfig) return null;
	    this.clipPathMap || (this.clipPathMap = new Map());
	    const {
	      shape: shape
	    } = clipConfig;
	    let path = this.clipPathMap.get(shape) || null;
	    return path || (this.clipPathMap.size > 10 && this.clipPathMap.clear(), path = this.parsePath(shape), path && this.clipPathMap.set(shape, path)), path;
	  }
	  parsePath(symbolType) {
	    if (!symbolType) return null;
	    let path = builtinSymbolsMap[symbolType];
	    if (path) return path;
	    if (path = Graphic.userSymbolMap[symbolType], path) return path;
	    const _symbolType = builtInSymbolStrMap[symbolType];
	    if (!0 === isSvg(symbolType = _symbolType || symbolType)) {
	      const parser = new XMLParser(),
	        {
	          svg: svg
	        } = parser.parse(symbolType);
	      if (!svg) return null;
	      const path = isArray$1(svg.path) ? svg.path : [svg.path];
	      _tempBounds.clear();
	      const cacheList = [];
	      path.forEach(item => {
	        const cache = new CustomPath2D().fromString(item.d),
	          attribute = {};
	        SVG_PARSE_ATTRIBUTE_MAP_KEYS.forEach(k => {
	          item[k] && (attribute[SVG_PARSE_ATTRIBUTE_MAP[k]] = item[k]);
	        }), cacheList.push({
	          path: cache,
	          attribute: attribute
	        }), _tempBounds.union(cache.bounds);
	      });
	      const width = _tempBounds.width(),
	        height = _tempBounds.height(),
	        scale = 1 / max(width, height);
	      cacheList.forEach(cache => cache.path.transform(0, 0, scale, scale));
	      const _parsedPath = new CustomSymbolClass(symbolType, cacheList, !0);
	      return Graphic.userSymbolMap[symbolType] = _parsedPath, _parsedPath;
	    }
	    const cache = new CustomPath2D().fromString(symbolType),
	      width = cache.bounds.width(),
	      height = cache.bounds.height(),
	      scale = 1 / max(width, height);
	    cache.transform(0, 0, scale, scale);
	    const _parsedPath = new CustomSymbolClass(symbolType, cache);
	    return Graphic.userSymbolMap[symbolType] = _parsedPath, _parsedPath;
	  }
	  doUpdateAABBBounds(full) {
	    this.updateAABBBoundsStamp++;
	    const graphicTheme = this.getGraphicTheme();
	    this._AABBBounds.clear();
	    const attribute = this.attribute,
	      bounds = this.updateAABBBounds(attribute, graphicTheme, this._AABBBounds, full),
	      {
	        boundsPadding = graphicTheme.boundsPadding
	      } = attribute,
	      paddingArray = parsePadding(boundsPadding);
	    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
	  }
	  updatePathProxyAABBBounds(aabbBounds) {
	    const path = "function" == typeof this.pathProxy ? this.pathProxy(this.attribute) : this.pathProxy;
	    if (!path) return !1;
	    const boundsContext = new BoundsContext(aabbBounds);
	    return renderCommandList(path.commandList, boundsContext, 0, 0), !0;
	  }
	  tryUpdateGlobalAABBBounds() {
	    const b = this.AABBBounds;
	    return this._globalAABBBounds ? this._globalAABBBounds.setValue(b.x1, b.y1, b.x2, b.y2) : this._globalAABBBounds = b.clone(), this._globalAABBBounds.empty() || this.parent && this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix), this._globalAABBBounds;
	  }
	  tryUpdateGlobalTransMatrix(clearTag = !0) {
	    if (this._globalTransMatrix) {
	      if (this.parent) {
	        const m = this.parent.globalTransMatrix;
	        this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
	      }
	    } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
	    return this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(), this._globalTransMatrix;
	  }
	  shouldUpdateGlobalMatrix() {
	    return !0;
	  }
	  tryUpdateLocalTransMatrix(clearTag = !0) {
	    return this._transMatrix || (this._transMatrix = new Matrix()), this.shouldUpdateLocalMatrix() && (this.doUpdateLocalMatrix(), clearTag && this.clearUpdateLocalPositionTag()), this._transMatrix;
	  }
	  shouldUpdateAABBBounds() {
	    return this.shadowRoot ? (!!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds()) && this.getGraphicService().validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this) : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) && this.getGraphicService().validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this);
	  }
	  shouldSelfChangeUpdateAABBBounds() {
	    return this.shadowRoot ? !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
	  }
	  shouldUpdateLocalMatrix() {
	    return !!(this._updateTag & UpdateTag.UPDATE_LOCAL_MATRIX);
	  }
	  isValid() {
	    var _a, _b;
	    const attribute = this.attribute;
	    return Number.isFinite((null !== (_a = attribute.x) && void 0 !== _a ? _a : 0) + (null !== (_b = attribute.y) && void 0 !== _b ? _b : 0));
	  }
	  _validNumber(num) {
	    return null == num || Number.isFinite(num);
	  }
	  shouldUpdateShape() {
	    return !!(this._updateTag & UpdateTag.UPDATE_SHAPE);
	  }
	  clearUpdateShapeTag() {
	    this._updateTag &= UpdateTag.CLEAR_SHAPE;
	  }
	  containsPoint(x, y, mode, picker) {
	    if (!picker) return !1;
	    if (mode === IContainPointMode.GLOBAL) {
	      const point = new Point(x, y);
	      this.parent && this.parent.globalTransMatrix.transformPoint(point, point), x = point.x, y = point.y;
	    }
	    return picker.containsPoint(this, {
	      x: x,
	      y: y
	    });
	  }
	  setWidthHeightWithoutTransform(aabbBounds) {
	    this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
	  }
	  setAttributesAndPreventAnimate(params, forceUpdateTag = !1, context, ignorePriority) {
	    this.setAttributes(params, forceUpdateTag, context), this.animates && this.animates.forEach(animate => {
	      (animate.priority !== 1 / 0 || ignorePriority) && Object.keys(params).forEach(key => {
	        animate.preventAttr(key);
	      });
	    });
	  }
	  setAttributes(params, forceUpdateTag = !1, context) {
	    params && ((params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params).background ? this.loadImage(params.background, !0) : params.shadowGraphic && this.setShadowGraphic(params.shadowGraphic), this._setAttributes(params, forceUpdateTag, context));
	  }
	  _setAttributes(params, forceUpdateTag = !1, context) {
	    const keys = Object.keys(params);
	    for (let i = 0; i < keys.length; i++) {
	      const key = keys[i];
	      this.attribute[key] = params[key];
	    }
	    this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context);
	  }
	  setAttribute(key, value, forceUpdateTag, context) {
	    var _a;
	    const params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
	      [key]: value
	    }, this.attribute, key, context);
	    params ? this._setAttributes(params, forceUpdateTag, context) : isNil$1(null === (_a = this.normalAttrs) || void 0 === _a ? void 0 : _a[key]) ? (this.attribute[key] = value, this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context)) : this.normalAttrs[key] = value, "background" === key ? this.loadImage(value, !0) : "shadowGraphic" === key && this.setShadowGraphic(value);
	  }
	  needUpdateTags(keys, k = GRAPHIC_UPDATE_TAG_KEY) {
	    for (let i = 0; i < k.length; i++) {
	      const attrKey = k[i];
	      if (-1 !== keys.indexOf(attrKey)) return !0;
	    }
	    return !1;
	  }
	  needUpdateTag(key, k = GRAPHIC_UPDATE_TAG_KEY) {
	    for (let i = 0; i < k.length; i++) {
	      if (key === k[i]) return !0;
	    }
	    return !1;
	  }
	  initAttributes(params) {
	    const context = {
	      type: AttributeUpdateType.INIT
	    };
	    params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params, this.attribute = params, params.background ? this.loadImage(params.background, !0) : params.shadowGraphic && this.setShadowGraphic(params.shadowGraphic), this._updateTag = UpdateTag.INIT, this.valid = this.isValid(), this.onAttributeUpdate(context);
	  }
	  translate(x, y) {
	    var _a, _b;
	    if (0 === x && 0 === y) return this;
	    const context = {
	        type: AttributeUpdateType.TRANSLATE
	      },
	      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
	        x: x,
	        y: y
	      }, this.attribute, tempConstantXYKey, context);
	    params && (x = params.x, y = params.y, delete params.x, delete params.y, this._setAttributes(params));
	    const attribute = this.attribute,
	      postMatrix = attribute.postMatrix;
	    return postMatrix ? application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x, y) : (attribute.x = (null !== (_a = attribute.x) && void 0 !== _a ? _a : DefaultTransform.x) + x, attribute.y = (null !== (_b = attribute.y) && void 0 !== _b ? _b : DefaultTransform.y) + y), this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
	  }
	  translateTo(x, y) {
	    const attribute = this.attribute;
	    if (attribute.x === x && attribute.y === y) return this;
	    const context = {
	        type: AttributeUpdateType.TRANSLATE_TO
	      },
	      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
	        x: x,
	        y: y
	      }, this.attribute, tempConstantXYKey, context);
	    return params ? (this._setAttributes(params, !1, context), this) : (attribute.x = x, attribute.y = y, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
	  }
	  scale(scaleX, scaleY, scaleCenter) {
	    var _a, _b;
	    if (1 === scaleX && 1 === scaleY) return this;
	    const context = {
	        type: AttributeUpdateType.SCALE
	      },
	      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
	        scaleX: scaleX,
	        scaleY: scaleY,
	        scaleCenter: scaleCenter
	      }, this.attribute, tempConstantScaleXYKey, context);
	    params && (scaleX = params.scaleX, scaleY = params.scaleY, delete params.scaleX, delete params.scaleY, this._setAttributes(params));
	    const attribute = this.attribute;
	    if (scaleCenter) {
	      let {
	        postMatrix: postMatrix
	      } = this.attribute;
	      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);
	    } else attribute.scaleX = (null !== (_a = attribute.scaleX) && void 0 !== _a ? _a : DefaultTransform.scaleX) * scaleX, attribute.scaleY = (null !== (_b = attribute.scaleY) && void 0 !== _b ? _b : DefaultTransform.scaleY) * scaleY;
	    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
	  }
	  scaleTo(scaleX, scaleY) {
	    const attribute = this.attribute;
	    if (attribute.scaleX === scaleX && attribute.scaleY === scaleY) return this;
	    const context = {
	        type: AttributeUpdateType.SCALE_TO
	      },
	      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
	        scaleX: scaleX,
	        scaleY: scaleY
	      }, this.attribute, tempConstantScaleXYKey, context);
	    return params ? (this._setAttributes(params, !1, context), this) : (attribute.scaleX = scaleX, attribute.scaleY = scaleY, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
	  }
	  rotate(angle, rotateCenter) {
	    var _a;
	    if (0 === angle) return this;
	    const context = {
	        type: AttributeUpdateType.ROTATE
	      },
	      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
	        angle: angle,
	        rotateCenter: rotateCenter
	      }, this.attribute, tempConstantAngleKey, context);
	    params && (delete params.angle, this._setAttributes(params, !1, context));
	    const attribute = this.attribute;
	    if (rotateCenter) {
	      let {
	        postMatrix: postMatrix
	      } = this.attribute;
	      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).rotate(angle, rotateCenter);
	    } else attribute.angle = (null !== (_a = attribute.angle) && void 0 !== _a ? _a : DefaultTransform.angle) + angle;
	    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
	  }
	  rotateTo(angle) {
	    const attribute = this.attribute;
	    if (attribute.angle === angle) return this;
	    const context = {
	        type: AttributeUpdateType.ROTATE_TO
	      },
	      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle, this.attribute, tempConstantAngleKey, context);
	    return params ? (this._setAttributes(params, !1, context), this) : (attribute.angle = angle, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
	  }
	  skewTo(b, c) {
	    return this;
	  }
	  onAttributeUpdate(context) {
	    context && context.skipUpdateCallback || (this.getGraphicService().onAttributeUpdate(this), this._emitCustomEvent("afterAttributeUpdate", context));
	  }
	  update(d) {
	    d ? (d.bounds && this.tryUpdateAABBBounds(), d.trans && this.tryUpdateLocalTransMatrix()) : (this.tryUpdateAABBBounds(), this.tryUpdateLocalTransMatrix());
	  }
	  hasState(stateName) {
	    return !(!this.currentStates || !this.currentStates.length) && (!!isNil$1(stateName) || this.currentStates.includes(stateName));
	  }
	  getState(stateName) {
	    var _a;
	    return null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
	  }
	  applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {
	    var _a, _b;
	    if (hasAnimation) {
	      const keys = Object.keys(attrs),
	        noWorkAttrs = this.getNoWorkAnimateAttr(),
	        animateAttrs = {};
	      let noAnimateAttrs;
	      keys.forEach(key => {
	        noWorkAttrs[key] ? (noAnimateAttrs || (noAnimateAttrs = {}), noAnimateAttrs[key] = attrs[key]) : animateAttrs[key] = isClear && void 0 === attrs[key] ? this.getDefaultAttribute(key) : attrs[key];
	      });
	      const stateAnimateConfig = null !== (_b = null !== (_a = this.context && this.context.stateAnimateConfig) && void 0 !== _a ? _a : this.stateAnimateConfig) && void 0 !== _b ? _b : DefaultStateAnimateConfig;
	      this.applyAnimationState(["state"], [{
	        name: "state",
	        animation: {
	          type: "state",
	          to: animateAttrs,
	          duration: stateAnimateConfig.duration,
	          easing: stateAnimateConfig.easing
	        }
	      }]), noAnimateAttrs && this.setAttributesAndPreventAnimate(noAnimateAttrs, !1, {
	        type: AttributeUpdateType.STATE
	      });
	    } else this.stopStateAnimates(), this.setAttributesAndPreventAnimate(attrs, !1, {
	      type: AttributeUpdateType.STATE
	    }), this.finalAttribute && Object.assign(this.finalAttribute, attrs);
	    this._emitCustomEvent("afterStateUpdate", {
	      type: AttributeUpdateType.STATE
	    });
	  }
	  updateNormalAttrs(stateAttrs) {
	    const newNormalAttrs = {};
	    this.normalAttrs ? (Object.keys(stateAttrs).forEach(key => {
	      key in this.normalAttrs ? (newNormalAttrs[key] = this.normalAttrs[key], delete this.normalAttrs[key]) : newNormalAttrs[key] = this.getNormalAttribute(key);
	    }), Object.keys(this.normalAttrs).forEach(key => {
	      stateAttrs[key] = this.normalAttrs[key];
	    })) : Object.keys(stateAttrs).forEach(key => {
	      newNormalAttrs[key] = this.getNormalAttribute(key);
	    }), this.normalAttrs = newNormalAttrs;
	  }
	  stopStateAnimates(type = "end") {
	    this.animates && this.animates.forEach(animate => {
	      animate.stateNames && (animate.stop(type), this.animates.delete(animate.id));
	    });
	  }
	  getNormalAttribute(key) {
	    var _a, _b;
	    const value = this.attribute[key];
	    return this.animates ? null === (_a = this.finalAttribute) || void 0 === _a ? void 0 : _a[key] : null != value ? value : null === (_b = this.finalAttribute) || void 0 === _b ? void 0 : _b[key];
	  }
	  clearStates(hasAnimation) {
	    this.hasState() && this.normalAttrs ? (this.currentStates = [], this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0)) : this.currentStates = [], this.normalAttrs = null;
	  }
	  removeState(stateName, hasAnimation) {
	    if (this.currentStates) {
	      const filter = isArray$1(stateName) ? s => !stateName.includes(s) : s => s !== stateName,
	        newStates = this.currentStates.filter(filter);
	      newStates.length !== this.currentStates.length && this.useStates(newStates, hasAnimation);
	    }
	  }
	  toggleState(stateName, hasAnimation) {
	    if (this.hasState(stateName)) this.removeState(stateName, hasAnimation);else {
	      if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) < 0) {
	        const nextStates = this.currentStates ? this.currentStates.slice() : [];
	        nextStates.push(stateName), this.useStates(nextStates, hasAnimation);
	      }
	    }
	  }
	  addState(stateName, keepCurrentStates, hasAnimation) {
	    var _a;
	    if (this.currentStates && this.currentStates.includes(stateName) && (keepCurrentStates || 1 === this.currentStates.length)) return;
	    const newStates = keepCurrentStates && (null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) ? this.currentStates.concat([stateName]) : [stateName];
	    this.useStates(newStates, hasAnimation);
	  }
	  useStates(states, hasAnimation) {
	    var _a;
	    if (!states.length) return void this.clearStates(hasAnimation);
	    if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName))) return;
	    const stateAttrs = {};
	    states.forEach(stateName => {
	      var _a;
	      const attrs = this.stateProxy ? this.stateProxy(stateName, states) : null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
	      attrs && Object.assign(stateAttrs, attrs);
	    }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
	  }
	  addUpdateBoundTag() {
	    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
	  }
	  addUpdateShapeTag() {
	    this._updateTag |= UpdateTag.UPDATE_SHAPE;
	  }
	  addUpdateShapeAndBoundsTag() {
	    this._updateTag |= UpdateTag.UPDATE_SHAPE_AND_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
	  }
	  updateShapeAndBoundsTagSetted() {
	    return (this._updateTag & UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
	  }
	  clearUpdateBoundTag() {
	    this._updateTag &= UpdateTag.CLEAR_BOUNDS;
	  }
	  addUpdatePositionTag() {
	    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;
	  }
	  addUpdateGlobalPositionTag() {
	    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_MATRIX;
	  }
	  clearUpdateLocalPositionTag() {
	    this._updateTag &= UpdateTag.CLEAR_LOCAL_MATRIX;
	  }
	  clearUpdateGlobalPositionTag() {
	    this._updateTag &= UpdateTag.CLEAR_GLOBAL_MATRIX;
	  }
	  addUpdateLayoutTag() {
	    this._updateTag |= UpdateTag.UPDATE_LAYOUT;
	  }
	  clearUpdateLayoutTag() {
	    this._updateTag &= UpdateTag.CLEAR_LAYOUT;
	  }
	  needUpdateLayout() {
	    return !!(this._updateTag & UpdateTag.UPDATE_LAYOUT);
	  }
	  getAnchor(anchor, params, resetScale) {
	    const _anchor = [0, 0],
	      getBounds = () => {
	        if (params.b) return params.b;
	        const graphic = this.clone();
	        return graphic.attribute.angle = 0, graphic.attribute.scaleCenter = null, resetScale && (graphic.attribute.scaleX = 1, graphic.attribute.scaleY = 1), params.b = graphic.AABBBounds, params.b;
	      };
	    if ("string" == typeof anchor[0]) {
	      const ratio = parseFloat(anchor[0]) / 100,
	        bounds = getBounds();
	      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
	    } else _anchor[0] = anchor[0];
	    if ("string" == typeof anchor[1]) {
	      const ratio = parseFloat(anchor[1]) / 100,
	        bounds = getBounds();
	      _anchor[1] = bounds.y1 + (bounds.y2 - bounds.y1) * ratio;
	    } else _anchor[1] = anchor[1];
	    return _anchor;
	  }
	  doUpdateLocalMatrix() {
	    const {
	      x = DefaultTransform.x,
	      y = DefaultTransform.y,
	      scaleX = DefaultTransform.scaleX,
	      scaleY = DefaultTransform.scaleY,
	      angle = DefaultTransform.angle,
	      scaleCenter: scaleCenter,
	      anchor: anchor,
	      postMatrix: postMatrix
	    } = this.attribute;
	    let _anchor = [0, 0];
	    const params = {};
	    if (anchor && angle && (_anchor = this.getAnchor(anchor, params)), !scaleCenter || 1 === scaleX && 1 === scaleY) normalTransform(this._transMatrix, this._transMatrix.reset(), x, y, scaleX, scaleY, angle, anchor && _anchor);else {
	      const m = this._transMatrix;
	      m.reset(), m.translate(_anchor[0], _anchor[1]), m.rotate(angle), m.translate(-_anchor[0], -_anchor[1]), m.translate(x, y), _anchor = this.getAnchor(scaleCenter, params, !0), application.transformUtil.fromMatrix(m, m).scale(scaleX, scaleY, {
	        x: _anchor[0],
	        y: _anchor[1]
	      });
	    }
	    const p = this.getOffsetXY(DefaultTransform);
	    if (this._transMatrix.e += p.x, this._transMatrix.f += p.y, postMatrix) {
	      const m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f),
	        m2 = this._transMatrix;
	      m1.multiply(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f), m2.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);
	    }
	  }
	  doUpdateGlobalMatrix() {
	    if (this.parent) {
	      this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);
	      const {
	        scrollX = 0,
	        scrollY = 0
	      } = this.parent.attribute;
	      this._globalTransMatrix.translate(scrollX, scrollY);
	    }
	  }
	  setStage(stage, layer) {
	    if (this.stage !== stage) {
	      if (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this.animates && this.animates.size) {
	        const timeline = stage.getTimeline();
	        this.animates.forEach(a => {
	          a.timeline.isGlobal && (a.setTimeline(timeline), timeline.addAnimate(a));
	        });
	      }
	      this._onSetStage && this._onSetStage(this, stage, layer), this.getGraphicService().onSetStage(this, stage);
	    }
	  }
	  setStageToShadowRoot(stage, layer) {
	    this.shadowRoot && this.shadowRoot.setStage(stage, layer);
	  }
	  onAddStep(step) {}
	  onStop(props) {
	    props && this.setAttributes(props, !1, {
	      type: AttributeUpdateType.ANIMATE_END
	    });
	  }
	  getDefaultAttribute(name) {
	    return this.getGraphicTheme()[name];
	  }
	  getComputedAttribute(name) {
	    var _a;
	    return null !== (_a = this.attribute[name]) && void 0 !== _a ? _a : this.getDefaultAttribute(name);
	  }
	  onSetStage(cb, immediate = !1) {
	    this._onSetStage = cb, immediate && this.stage && cb(this, this.stage);
	  }
	  attachShadow(shadowRoot) {
	    return shadowRoot && (shadowRoot.shadowHost = this), this.shadowRoot = null != shadowRoot ? shadowRoot : application.graphicService.creator.shadowRoot(this), this.addUpdateBoundTag(), this.shadowRoot.setStage(this.stage, this.layer), this.shadowRoot;
	  }
	  detachShadow() {
	    this.shadowRoot && (this.addUpdateBoundTag(), this.shadowRoot.release(!0), this.shadowRoot = null);
	  }
	  toJson() {
	    return {
	      attribute: this.attribute,
	      _uid: this._uid,
	      type: this.type,
	      name: this.name,
	      children: this.children.map(item => item.toJson())
	    };
	  }
	  createPathProxy(path) {
	    return isString$1(path, !0) ? this.pathProxy = new CustomPath2D().fromString(path) : this.pathProxy = new CustomPath2D(), this.pathProxy;
	  }
	  loadImage(image, background = !1) {
	    if (!image || background && backgroundNotImage(image)) return;
	    const url = image;
	    this.resources || (this.resources = new Map());
	    const cache = {
	      data: "init",
	      state: null
	    };
	    this.resources.set(url, cache), "string" == typeof image ? (cache.state = "loading", image.startsWith("<svg") ? (ResourceLoader.GetSvg(image, this), this.backgroundImg = this.backgroundImg || background) : (isValidUrl$1(image) || image.includes("/") || isBase64$1(image)) && (ResourceLoader.GetImage(image, this), this.backgroundImg = this.backgroundImg || background)) : isObject$1(image) ? (cache.state = "success", cache.data = image, this.backgroundImg = this.backgroundImg || background) : cache.state = "fail";
	  }
	  setShadowGraphic(graphic) {
	    if (graphic) {
	      this.attachShadow().add(graphic);
	    } else this.detachShadow();
	  }
	  imageLoadSuccess(url, image, cb) {
	    if (!this.resources) return;
	    const res = this.resources.get(url);
	    res && (res.state = "success", res.data = image, cb && cb(), this.addUpdateBoundTag(), this.stage && this.stage.renderNextFrame());
	  }
	  imageLoadFail(url, cb) {
	    if (!this.resources) return;
	    const res = this.resources.get(url);
	    res && (res.state = "fail", cb && cb());
	  }
	  _stopAnimates(animates) {
	    animates && animates.forEach(animate => {
	      animate.stop();
	    });
	  }
	  stopAnimates(stopChildren = !1) {
	    this._stopAnimates(this.animates), this.shadowRoot && this.shadowRoot.stopAnimates(!0), this.isContainer && stopChildren && this.forEachChildren(c => {
	      c.stopAnimates(stopChildren);
	    });
	  }
	  release() {
	    this.releaseStatus = "released", this.stopAnimates(), application.graphicService.onRelease(this);
	  }
	  _emitCustomEvent(type, context) {
	    var _a, _b;
	    if (this._events && type in this._events) {
	      const changeEvent = new CustomEvent(type, context);
	      changeEvent.bubbles = !1, changeEvent.manager = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem) || void 0 === _b ? void 0 : _b.manager, this.dispatchEvent(changeEvent);
	    }
	  }
	  toCustomPath() {
	    var _a, _b, _c;
	    const renderer = null === (_c = null === (_b = (null === (_a = this.stage) || void 0 === _a ? void 0 : _a.renderService) || application.renderService) || void 0 === _b ? void 0 : _b.drawContribution) || void 0 === _c ? void 0 : _c.getRenderContribution(this);
	    if (renderer) {
	      const context = new EmptyContext2d(null, 1);
	      return renderer.drawShape(this, context, 0, 0, {}, {}), context.path;
	    }
	    return null;
	  }
	}
	function backgroundNotImage(image) {
	  return !(!image.fill && !image.stroke);
	}
	Graphic.userSymbolMap = {}, Graphic.mixin(EventTarget);

	var GroupUpdateAABBBoundsMode;
	!function (GroupUpdateAABBBoundsMode) {
	  GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.LESS_GROUP = 0] = "LESS_GROUP", GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.MORE_GROUP = 1] = "MORE_GROUP";
	}(GroupUpdateAABBBoundsMode || (GroupUpdateAABBBoundsMode = {}));
	class Group extends Graphic {
	  constructor(params) {
	    super(params), this.type = "group", this.parent = null, this.isContainer = !0, this.numberType = GROUP_NUMBER_TYPE, this._childUpdateTag = UpdateTag.UPDATE_BOUNDS;
	  }
	  setMode(mode) {
	    "3d" === mode ? this.set3dMode() : this.set2dMode();
	  }
	  set3dMode() {
	    this.in3dMode = !0;
	  }
	  set2dMode() {
	    this.in3dMode = !1;
	  }
	  setTheme(t) {
	    return this.theme || (this.theme = new Theme()), this.theme.setTheme(t, this);
	  }
	  createTheme() {
	    this.theme || (this.theme = new Theme());
	  }
	  visibleAll(visible) {
	    this.setAttribute("visible", visible), this.forEachChildren(item => {
	      item.isContainer && item.visibleAll ? item.visibleAll(visible) : item.setAttribute("visible", visible);
	    });
	  }
	  hideAll() {
	    this.visibleAll(!1);
	  }
	  showAll() {
	    this.visibleAll(!0);
	  }
	  containsPoint(x, y, mode) {
	    if (mode === IContainPointMode.GLOBAL) {
	      const point = new Point(x, y);
	      return this.parent && this.parent.globalTransMatrix.transformPoint(point, point), this.AABBBounds.contains(point.x, point.y);
	    }
	    return this.AABBBounds.contains(x, y);
	  }
	  shouldUpdateAABBBounds() {
	    return !!super.shouldUpdateAABBBounds() || !!(this._childUpdateTag & UpdateTag.UPDATE_BOUNDS);
	  }
	  tryUpdateAABBBounds() {
	    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
	    this.getGraphicService().beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
	    const selfChange = this.shouldSelfChangeUpdateAABBBounds(),
	      bounds = this.doUpdateAABBBounds();
	    return this.addUpdateLayoutTag(), this.getGraphicService().afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange), "empty" === this.attribute.boundsMode && bounds.clear(), bounds;
	  }
	  doUpdateLocalMatrix() {
	    const {
	      x = DefaultTransform.x,
	      y = DefaultTransform.y,
	      dx = DefaultTransform.dx,
	      dy = DefaultTransform.dy,
	      scaleX = DefaultTransform.scaleX,
	      scaleY = DefaultTransform.scaleY,
	      angle = DefaultTransform.angle,
	      postMatrix: postMatrix
	    } = this.attribute;
	    if (0 !== x || 0 !== y || 0 !== dx || 0 !== dy || 1 !== scaleX || 1 !== scaleY || 0 !== angle || postMatrix) return super.doUpdateLocalMatrix();
	    this._transMatrix.reset();
	  }
	  getGraphicTheme() {
	    return getTheme(this).group;
	  }
	  updateAABBBounds(attribute, groupTheme, aabbBounds) {
	    const originalAABBBounds = aabbBounds;
	    aabbBounds = aabbBounds.clone();
	    const {
	      width: width,
	      height: height,
	      path: path,
	      clip = groupTheme.clip
	    } = attribute;
	    if (path && path.length ? path.forEach(g => {
	      aabbBounds.union(g.AABBBounds);
	    }) : null != width && null != height && aabbBounds.set(0, 0, Math.max(0, width), Math.max(0, height)), !clip) {
	      this.forEachChildren(node => {
	        aabbBounds.union(node.AABBBounds);
	      });
	      const {
	        scrollX = 0,
	        scrollY = 0
	      } = attribute;
	      aabbBounds.translate(scrollX, scrollY);
	    }
	    return application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, groupTheme, !1, this), originalAABBBounds.copy(aabbBounds), originalAABBBounds;
	  }
	  doUpdateAABBBounds() {
	    this.updateAABBBoundsStamp++;
	    const bounds = super.doUpdateAABBBounds();
	    return this.parent && this.parent.addChildUpdateBoundTag(), this._emitCustomEvent("AAABBBoundsChange"), bounds;
	  }
	  clearUpdateBoundTag() {
	    this._updateTag &= UpdateTag.CLEAR_BOUNDS, this._childUpdateTag &= UpdateTag.CLEAR_BOUNDS;
	  }
	  addUpdateBoundTag() {
	    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag();
	  }
	  addChildUpdateBoundTag() {
	    this._childUpdateTag & UpdateTag.UPDATE_BOUNDS || (this._childUpdateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag());
	  }
	  getTheme() {
	    return this.theme.getTheme(this);
	  }
	  incrementalAppendChild(node) {
	    const data = super.appendChild(node);
	    return this.stage && data && (data.stage = this.stage, data.layer = this.layer), this.addUpdateBoundTag(), this.getGraphicService().onAddIncremental(node, this, this.stage), data;
	  }
	  incrementalClearChild() {
	    super.removeAllChild(), this.addUpdateBoundTag(), this.getGraphicService().onClearIncremental(this, this.stage);
	  }
	  _updateChildToStage(child) {
	    return this.stage && child && child.setStage(this.stage, this.layer), this.addUpdateBoundTag(), child;
	  }
	  appendChild(node, addStage = !0) {
	    const data = super.appendChild(node);
	    return addStage && this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
	  }
	  insertBefore(newNode, referenceNode) {
	    return this._updateChildToStage(super.insertBefore(newNode, referenceNode));
	  }
	  insertAfter(newNode, referenceNode) {
	    return this._updateChildToStage(super.insertAfter(newNode, referenceNode));
	  }
	  insertInto(newNode, idx) {
	    return this._updateChildToStage(super.insertInto(newNode, idx));
	  }
	  removeChild(child) {
	    const data = super.removeChild(child);
	    return this.getGraphicService().onRemove(child), child.stage = null, this.addUpdateBoundTag(), data;
	  }
	  removeAllChild(deep = !1) {
	    this.forEachChildren(child => {
	      this.getGraphicService().onRemove(child), deep && child.isContainer && child.removeAllChild(deep);
	    }), super.removeAllChild(), this.addUpdateBoundTag();
	  }
	  setStage(stage, layer) {
	    this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this._onSetStage && this._onSetStage(this, stage, layer), this.getGraphicService().onSetStage(this, stage), this.forEachChildren(item => {
	      item.setStage(stage, this.layer);
	    }));
	  }
	  addUpdatePositionTag() {
	    super.addUpdatePositionTag(), this.forEachChildren(g => {
	      g.isContainer && g.addUpdateGlobalPositionTag();
	    });
	  }
	  addUpdateGlobalPositionTag() {
	    super.addUpdateGlobalPositionTag(), this.forEachChildren(g => {
	      g.isContainer && g.addUpdateGlobalPositionTag();
	    });
	  }
	  tryUpdateGlobalTransMatrix(clearTag = !0) {
	    if (this.shouldUpdateGlobalMatrix()) {
	      if (this._globalTransMatrix) {
	        if (this.parent) {
	          const m = this.parent.globalTransMatrix;
	          this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
	        }
	      } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
	      this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
	    }
	    return this._globalTransMatrix;
	  }
	  shouldUpdateGlobalMatrix() {
	    return !!(this._updateTag & UpdateTag.UPDATE_GLOBAL_MATRIX);
	  }
	  _getChildByName(name, deep) {
	    return this.find(node => node.name === name, deep);
	  }
	  createOrUpdateChild(graphicName, attributes, graphicType) {
	    let graphic = this._getChildByName(graphicName);
	    return graphic ? graphic.setAttributes(attributes) : (graphic = application.graphicService.creator[graphicType](attributes), graphic.name = graphicName, this.add(graphic)), graphic;
	  }
	  clone() {
	    return new Group(Object.assign({}, this.attribute));
	  }
	  getNoWorkAnimateAttr() {
	    return Group.NOWORK_ANIMATE_ATTR;
	  }
	  release(all) {
	    all && this.forEachChildren(g => {
	      g.release(all);
	    }), super.release();
	  }
	}
	Group.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
	function createGroup(attributes) {
	  return new Group(attributes);
	}

	function runFill(fill, background) {
	  return !(!fill && !background);
	}
	function runStroke(stroke, lineWidth) {
	  let s;
	  return s = isArray$1(stroke) ? stroke.some(item => item || void 0 === item) : !!stroke, s && lineWidth > 0;
	}
	function fillVisible(opacity, fillOpacity, fill) {
	  return fill && opacity * fillOpacity > 0;
	}
	function rectFillVisible(opacity, fillOpacity, width, height, fill) {
	  return fill && opacity * fillOpacity > 0 && 0 !== width && 0 !== height;
	}
	function strokeVisible(opacity, strokeOpacity) {
	  return opacity * strokeOpacity > 0;
	}
	function rectStrokeVisible(opacity, strokeOpacity, width, height, drawStrokeWhenZeroWH) {
	  return drawStrokeWhenZeroWH ? opacity * strokeOpacity > 0 : opacity * strokeOpacity > 0 && 0 !== width && 0 !== height;
	}
	function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
	  const x10 = x1 - x0,
	    y10 = y1 - y0,
	    x32 = x3 - x2,
	    y32 = y3 - y2;
	  let t = y32 * x10 - x32 * y10;
	  return t * t < epsilon ? [] : (t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, [x0 + t * x10, y0 + t * y10]);
	}
	function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
	  const x01 = x0 - x1,
	    y01 = y0 - y1,
	    lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
	    ox = lo * y01,
	    oy = -lo * x01,
	    x11 = x0 + ox,
	    y11 = y0 + oy,
	    x10 = x1 + ox,
	    y10 = y1 + oy,
	    x00 = (x11 + x10) / 2,
	    y00 = (y11 + y10) / 2,
	    dx = x10 - x11,
	    dy = y10 - y11,
	    d2 = dx * dx + dy * dy,
	    r = r1 - rc,
	    D = x11 * y10 - x10 * y11,
	    d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
	  let cx0 = (D * dy - dx * d) / d2,
	    cy0 = (-D * dx - dy * d) / d2;
	  const cx1 = (D * dy + dx * d) / d2,
	    cy1 = (-D * dx + dy * d) / d2,
	    dx0 = cx0 - x00,
	    dy0 = cy0 - y00,
	    dx1 = cx1 - x00,
	    dy1 = cy1 - y00;
	  return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), {
	    cx: cx0,
	    cy: cy0,
	    x01: -ox,
	    y01: -oy,
	    x11: cx0 * (r1 / r - 1),
	    y11: cy0 * (r1 / r - 1)
	  };
	}
	function calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius) {
	  const deltaAngle = abs(endAngle - startAngle),
	    cornerRadius = arc.getParsedCornerRadius(),
	    cornerRadiusIsArray = isArray$1(cornerRadius),
	    {
	      outerDeltaAngle: outerDeltaAngle,
	      innerDeltaAngle: innerDeltaAngle,
	      outerStartAngle: outerStartAngle,
	      outerEndAngle: outerEndAngle,
	      innerEndAngle: innerEndAngle,
	      innerStartAngle: innerStartAngle
	    } = arc.getParsePadAngle(startAngle, endAngle),
	    outerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[0] : cornerRadius,
	    outerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[1] : cornerRadius,
	    innerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[2] : cornerRadius,
	    innerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[3] : cornerRadius,
	    maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart),
	    maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
	  let limitedOcr = maxOuterCornerRadius,
	    limitedIcr = maxInnerCornerRadius;
	  const xors = outerRadius * cos(outerStartAngle),
	    yors = outerRadius * sin(outerStartAngle),
	    xire = innerRadius * cos(innerEndAngle),
	    yire = innerRadius * sin(innerEndAngle);
	  let xore, yore, xirs, yirs;
	  if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
	    const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
	    if (oc) {
	      const ax = xors - oc[0],
	        ay = yors - oc[1],
	        bx = xore - oc[0],
	        by = yore - oc[1],
	        kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt$1(ax * ax + ay * ay) * sqrt$1(bx * bx + by * by))) / 2),
	        lc = sqrt$1(oc[0] * oc[0] + oc[1] * oc[1]);
	      limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
	    }
	  }
	  return {
	    outerDeltaAngle: outerDeltaAngle,
	    xors: xors,
	    yors: yors,
	    xirs: xirs,
	    yirs: yirs,
	    xore: xore,
	    yore: yore,
	    xire: xire,
	    yire: yire,
	    limitedOcr: limitedOcr,
	    limitedIcr: limitedIcr,
	    outerCornerRadiusStart: outerCornerRadiusStart,
	    outerCornerRadiusEnd: outerCornerRadiusEnd,
	    maxOuterCornerRadius: maxOuterCornerRadius,
	    maxInnerCornerRadius: maxInnerCornerRadius,
	    outerStartAngle: outerStartAngle,
	    outerEndAngle: outerEndAngle,
	    innerDeltaAngle: innerDeltaAngle,
	    innerEndAngle: innerEndAngle,
	    innerStartAngle: innerStartAngle,
	    innerCornerRadiusStart: innerCornerRadiusStart,
	    innerCornerRadiusEnd: innerCornerRadiusEnd
	  };
	}
	function drawArcPath$1(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
	  const {
	      startAngle: startAngle,
	      endAngle: endAngle
	    } = arc.getParsedAngle(),
	    deltaAngle = abs(endAngle - startAngle),
	    clockwise = endAngle > startAngle;
	  let collapsedToLine = !1;
	  if (outerRadius < innerRadius) {
	    const temp = outerRadius;
	    outerRadius = innerRadius, innerRadius = temp;
	  }
	  if (outerRadius <= epsilon) context.moveTo(cx, cy);else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise));else {
	    const {
	      outerDeltaAngle: outerDeltaAngle,
	      xors: xors,
	      yors: yors,
	      xirs: xirs,
	      yirs: yirs,
	      limitedOcr: limitedOcr,
	      outerCornerRadiusStart: outerCornerRadiusStart,
	      outerCornerRadiusEnd: outerCornerRadiusEnd,
	      maxOuterCornerRadius: maxOuterCornerRadius,
	      xore: xore,
	      yore: yore,
	      xire: xire,
	      yire: yire,
	      outerStartAngle: outerStartAngle,
	      outerEndAngle: outerEndAngle,
	      limitedIcr: limitedIcr,
	      innerDeltaAngle: innerDeltaAngle,
	      innerEndAngle: innerEndAngle,
	      innerStartAngle: innerStartAngle,
	      innerCornerRadiusStart: innerCornerRadiusStart,
	      innerCornerRadiusEnd: innerCornerRadiusEnd,
	      maxInnerCornerRadius: maxInnerCornerRadius
	    } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
	    if (outerDeltaAngle < .001) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), collapsedToLine = !0;else if (limitedOcr > epsilon) {
	      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr),
	        cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr),
	        t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)),
	        t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
	      limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * cos(atan2(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * sin(atan2(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, outerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * sin(outerEndAngle));
	    } else !partStroke || partStroke[0] ? (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise)) : context.moveTo(cx + outerRadius * cos(outerEndAngle), cy + outerRadius * sin(outerEndAngle));
	    if (!(innerRadius > epsilon) || innerDeltaAngle < .001) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), collapsedToLine = !0;else if (limitedIcr > epsilon) {
	      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr),
	        cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr),
	        t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)),
	        t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
	      if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
	        const arcEndAngle = atan2(t1.y01, t1.x01);
	        !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + cos(arcEndAngle), cy + t0.cy + sin(arcEndAngle));
	      } else !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, innerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);
	    } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
	  }
	  return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)) : context.closePath(), collapsedToLine;
	}

	const ArcRenderContribution = Symbol.for("ArcRenderContribution");
	const ImageRenderContribution = Symbol.for("ImageRenderContribution");
	const PolygonRenderContribution = Symbol.for("PolygonRenderContribution");
	const RectRenderContribution = Symbol.for("RectRenderContribution");
	const SymbolRenderContribution = Symbol.for("SymbolRenderContribution");
	const TextRenderContribution = Symbol.for("TextRenderContribution");
	const InteractiveSubRenderContribution = Symbol.for("InteractiveSubRenderContribution");

	function textDrawOffsetX(textAlign, width) {
	  return "end" === textAlign || "right" === textAlign ? -width : "center" === textAlign ? -width / 2 : 0;
	}
	function textLayoutOffsetY(baseline, lineHeight, fontSize, buf = 0) {
	  return "middle" === baseline ? -lineHeight / 2 : "top" === baseline ? 0 : "bottom" === baseline ? buf - lineHeight : baseline && "alphabetic" !== baseline ? 0 : (fontSize || (fontSize = lineHeight), -(lineHeight - fontSize) / 2 - .79 * fontSize);
	}

	var __decorate$w = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$o = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$n = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	function getModelMatrix(out, graphic, theme) {
	  var _a;
	  const {
	      x = theme.x,
	      y = theme.y,
	      z = theme.z,
	      dx = theme.dx,
	      dy = theme.dy,
	      dz = theme.dz,
	      scaleX = theme.scaleX,
	      scaleY = theme.scaleY,
	      scaleZ = theme.scaleZ,
	      alpha = theme.alpha,
	      beta = theme.beta,
	      angle = theme.angle,
	      anchor3d = graphic.attribute.anchor,
	      anchor: anchor
	    } = graphic.attribute,
	    _anchor = [0, 0, 0];
	  if (anchor3d) {
	    if ("string" == typeof anchor3d[0]) {
	      const ratio = parseFloat(anchor3d[0]) / 100,
	        bounds = graphic.AABBBounds;
	      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
	    } else _anchor[0] = anchor3d[0];
	    if ("string" == typeof anchor3d[1]) {
	      const ratio = parseFloat(anchor3d[1]) / 100,
	        bounds = graphic.AABBBounds;
	      _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
	    } else _anchor[1] = anchor3d[1];
	    _anchor[2] = null !== (_a = anchor3d[2]) && void 0 !== _a ? _a : 0;
	  }
	  if (identityMat4(out), translate(out, out, [x + dx, y + dy, z + dz]), translate(out, out, [_anchor[0], _anchor[1], _anchor[2]]), rotateX(out, out, beta), rotateY(out, out, alpha), translate(out, out, [-_anchor[0], -_anchor[1], _anchor[2]]), scaleMat4(out, out, [scaleX, scaleY, scaleZ]), angle) {
	    const m = mat4Allocate.allocate(),
	      _anchor = [0, 0];
	    if (anchor) {
	      if ("string" == typeof anchor3d[0]) {
	        const ratio = parseFloat(anchor3d[0]) / 100,
	          bounds = graphic.AABBBounds;
	        _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
	      } else _anchor[0] = anchor3d[0];
	      if ("string" == typeof anchor3d[1]) {
	        const ratio = parseFloat(anchor3d[1]) / 100,
	          bounds = graphic.AABBBounds;
	        _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
	      } else _anchor[1] = anchor3d[1];
	    }
	    translate(m, m, [_anchor[0], _anchor[1], 0]), rotateZ(m, m, angle), translate(m, m, [-_anchor[0], -_anchor[1], 0]), multiplyMat4Mat4(out, out, m);
	  }
	}
	function shouldUseMat4(graphic) {
	  const {
	    alpha: alpha,
	    beta: beta
	  } = graphic.attribute;
	  return alpha || beta;
	}
	let DefaultGraphicService = class {
	  constructor(creator) {
	    this.creator = creator, this.hooks = {
	      onAttributeUpdate: new SyncHook(["graphic"]),
	      onSetStage: new SyncHook(["graphic", "stage"]),
	      onRemove: new SyncHook(["graphic"]),
	      onRelease: new SyncHook(["graphic"]),
	      onAddIncremental: new SyncHook(["graphic", "group", "stage"]),
	      onClearIncremental: new SyncHook(["graphic", "group", "stage"]),
	      beforeUpdateAABBBounds: new SyncHook(["graphic", "stage", "willUpdate", "aabbBounds"]),
	      afterUpdateAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds", "globalAABBBounds", "selfChange"]),
	      clearAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds"])
	    }, this.tempAABBBounds1 = new AABBBounds(), this.tempAABBBounds2 = new AABBBounds();
	  }
	  onAttributeUpdate(graphic) {
	    this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(graphic);
	  }
	  onSetStage(graphic, stage) {
	    this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(graphic, stage);
	  }
	  onRemove(graphic) {
	    this.hooks.onRemove.taps.length && this.hooks.onRemove.call(graphic);
	  }
	  onRelease(graphic) {
	    this.hooks.onRelease.taps.length && this.hooks.onRelease.call(graphic);
	  }
	  onAddIncremental(graphic, group, stage) {
	    this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(graphic, group, stage);
	  }
	  onClearIncremental(group, stage) {
	    this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(group, stage);
	  }
	  beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
	    this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
	  }
	  afterUpdateAABBBounds(graphic, stage, bounds, params, selfChange) {
	    this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params, selfChange);
	  }
	  clearAABBBounds(graphic, stage, b) {
	    this.hooks.clearAABBBounds.taps.length && this.hooks.clearAABBBounds.call(graphic, stage, b);
	  }
	  updatePathProxyAABBBounds(aabbBounds, graphic) {
	    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
	    if (!path) return !1;
	    const boundsContext = new BoundsContext(aabbBounds);
	    return renderCommandList(path.commandList, boundsContext, 0, 0), !0;
	  }
	  updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
	    const {
	      textAlign: textAlign,
	      textBaseline: textBaseline
	    } = attribute;
	    if (null != attribute.forceBoundsHeight) {
	      const h = isNumber$1(attribute.forceBoundsHeight) ? attribute.forceBoundsHeight : attribute.forceBoundsHeight(),
	        dy = textLayoutOffsetY(textBaseline, h, h);
	      aabbBounds.set(aabbBounds.x1, dy, aabbBounds.x2, dy + h);
	    }
	    if (null != attribute.forceBoundsWidth) {
	      const w = isNumber$1(attribute.forceBoundsWidth) ? attribute.forceBoundsWidth : attribute.forceBoundsWidth(),
	        dx = textDrawOffsetX(textAlign, w);
	      aabbBounds.set(dx, aabbBounds.y1, dx + w, aabbBounds.y2);
	    }
	  }
	  combindShadowAABBBounds(bounds, graphic) {
	    if (graphic && graphic.shadowRoot) {
	      const b = graphic.shadowRoot.AABBBounds;
	      bounds.union(b);
	    }
	  }
	  transformAABBBounds(attribute, aabbBounds, theme, miter, graphic) {
	    if (!aabbBounds.empty()) {
	      const {
	          scaleX = theme.scaleX,
	          scaleY = theme.scaleY,
	          stroke = theme.stroke,
	          shadowBlur = theme.shadowBlur,
	          lineWidth = theme.lineWidth,
	          pickStrokeBuffer = theme.pickStrokeBuffer,
	          strokeBoundsBuffer = theme.strokeBoundsBuffer
	        } = attribute,
	        tb1 = this.tempAABBBounds1,
	        tb2 = this.tempAABBBounds2;
	      if (stroke && lineWidth) {
	        const scaledHalfLineWidth = (lineWidth + pickStrokeBuffer) / Math.abs(scaleX + scaleY);
	        boundStroke(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
	      }
	      if (shadowBlur) {
	        const {
	            shadowOffsetX = theme.shadowOffsetX,
	            shadowOffsetY = theme.shadowOffsetY
	          } = attribute,
	          shadowBlurWidth = shadowBlur / Math.abs(scaleX + scaleY) * 2;
	        boundStroke(tb1, shadowBlurWidth, !1, strokeBoundsBuffer + 1), tb1.translate(shadowOffsetX, shadowOffsetY), aabbBounds.union(tb1);
	      }
	    }
	    if (this.combindShadowAABBBounds(aabbBounds, graphic), aabbBounds.empty()) return;
	    let updateMatrix = !0;
	    const m = graphic.transMatrix;
	    graphic && graphic.isContainer && (updateMatrix = !(1 === m.a && 0 === m.b && 0 === m.c && 1 === m.d && 0 === m.e && 0 === m.f)), updateMatrix && transformBoundsWithMatrix(aabbBounds, aabbBounds, m);
	  }
	  validCheck(attribute, theme, aabbBounds, graphic) {
	    if (!graphic) return !0;
	    if (null != attribute.forceBoundsHeight || null != attribute.forceBoundsWidth) return !0;
	    if (graphic.shadowRoot || graphic.isContainer) return !0;
	    const {
	      visible = theme.visible
	    } = attribute;
	    return !(!graphic.valid || !visible) || (aabbBounds.empty() || (graphic.parent && aabbBounds.transformWithMatrix(graphic.parent.globalTransMatrix), this.clearAABBBounds(graphic, graphic.stage, aabbBounds), aabbBounds.clear()), !1);
	  }
	  updateTempAABBBounds(aabbBounds) {
	    const tb1 = this.tempAABBBounds1,
	      tb2 = this.tempAABBBounds2;
	    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), {
	      tb1: tb1,
	      tb2: tb2
	    };
	  }
	};
	DefaultGraphicService = __decorate$w([injectable(), __param$n(0, inject(GraphicCreator$1)), __metadata$o("design:paramtypes", [Object])], DefaultGraphicService);

	const updateBoundsOfCommonOuterBorder = (attribute, theme, aabbBounds) => {
	  const {
	    outerBorder: outerBorder,
	    shadowBlur = theme.shadowBlur
	  } = attribute;
	  if (outerBorder) {
	    const defaultOuterBorder = theme.outerBorder,
	      {
	        distance = defaultOuterBorder.distance,
	        lineWidth = defaultOuterBorder.lineWidth
	      } = outerBorder;
	    aabbBounds.expand(distance + (shadowBlur + lineWidth) / 2);
	  }
	  return aabbBounds;
	};

	class CanvasTextLayout {
	  constructor(fontFamily, options, textMeasure) {
	    this.fontFamily = fontFamily, this.textOptions = options, this.textMeasure = textMeasure;
	  }
	  LayoutBBox(bbox, textAlign, textBaseline, linesLayout) {
	    if (bbox.xOffset = "left" === textAlign || "start" === textAlign ? 0 : "center" === textAlign ? bbox.width / -2 : "right" === textAlign || "end" === textAlign ? -bbox.width : 0, "top" === textBaseline) bbox.yOffset = 0;else if ("middle" === textBaseline) bbox.yOffset = bbox.height / -2;else if ("alphabetic" === textBaseline) {
	      let percent = .79;
	      if (1 === linesLayout.length) {
	        const lineInfo = linesLayout[0];
	        percent = lineInfo.ascent / (lineInfo.ascent + lineInfo.descent);
	      }
	      bbox.yOffset = bbox.height * -percent;
	    } else bbox.yOffset = -bbox.height;
	    return bbox;
	  }
	  GetLayoutByLines(lines, textAlign, textBaseline, lineHeight, suffix = "", wordBreak, params) {
	    const {
	      lineWidth: lineWidth,
	      suffixPosition = "end",
	      measureMode = MeasureModeEnum.actualBounding,
	      keepCenterInLine = !1
	    } = null != params ? params : {};
	    lines = lines.map(l => l.toString());
	    const linesLayout = [],
	      bboxWH = [0, 0];
	    if ("number" == typeof lineWidth && lineWidth !== 1 / 0) {
	      let width;
	      for (let i = 0, len = lines.length; i < len; i++) {
	        const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
	        let str = lines[i].toString();
	        if (metrics.width > lineWidth) {
	          const data = this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, lineWidth, suffix, wordBreak, suffixPosition);
	          str = data.str, width = data.width;
	        } else width = metrics.width;
	        linesLayout.push({
	          str: str,
	          width: width,
	          ascent: metrics.ascent,
	          descent: metrics.descent,
	          keepCenterInLine: keepCenterInLine
	        });
	      }
	      bboxWH[0] = lineWidth;
	    } else {
	      let width,
	        text,
	        _lineWidth = 0;
	      for (let i = 0, len = lines.length; i < len; i++) {
	        text = lines[i];
	        const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
	        width = metrics.width, _lineWidth = Math.max(_lineWidth, width), linesLayout.push({
	          str: text,
	          width: width,
	          ascent: metrics.ascent,
	          descent: metrics.descent,
	          keepCenterInLine: keepCenterInLine
	        });
	      }
	      bboxWH[0] = _lineWidth;
	    }
	    bboxWH[1] = linesLayout.length * lineHeight, bboxWH[0] = linesLayout.reduce((a, b) => Math.max(a, b.width), 0);
	    const bbox = {
	      xOffset: 0,
	      yOffset: 0,
	      width: bboxWH[0],
	      height: bboxWH[1]
	    };
	    return this.LayoutBBox(bbox, textAlign, textBaseline, linesLayout), this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
	  }
	  layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
	    const origin = [0, 0],
	      totalLineHeight = lines.length * lineHeight;
	    "top" === textBaseline || ("middle" === textBaseline ? origin[1] = (bbox.height - totalLineHeight) / 2 : "bottom" === textBaseline && (origin[1] = bbox.height - totalLineHeight));
	    for (let i = 0; i < lines.length; i++) this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);
	    return {
	      bbox: bbox,
	      lines: lines,
	      fontFamily: this.fontFamily,
	      fontSize: this.textOptions.fontSize,
	      fontWeight: this.textOptions.fontWeight,
	      lineHeight: lineHeight,
	      textAlign: textAlign,
	      textBaseline: textBaseline
	    };
	  }
	  lineOffset(bbox, line, textAlign, textBaseline, lineHeight, origin) {
	    if ("left" === textAlign || "start" === textAlign ? line.leftOffset = 0 : "center" === textAlign ? line.leftOffset = (bbox.width - line.width) / 2 : "right" !== textAlign && "end" !== textAlign || (line.leftOffset = bbox.width - line.width), line.topOffset = lineHeight / 2 + (line.ascent - line.descent) / 2 + origin[1], !line.keepCenterInLine) {
	      const buf = 0,
	        actualHeightWithBuf = line.ascent + line.descent + buf;
	      if (actualHeightWithBuf < lineHeight - buf && ("bottom" === textBaseline ? line.topOffset += (lineHeight - actualHeightWithBuf) / 2 : "top" === textBaseline && (line.topOffset -= (lineHeight - actualHeightWithBuf) / 2)), "alphabetic" === textBaseline) {
	        const ratio = lineHeight / (line.ascent + line.descent);
	        line.topOffset = lineHeight / 2 + (line.ascent - line.descent) / 2 * ratio + origin[1];
	      }
	    }
	    return origin[1] += lineHeight, line;
	  }
	}

	const TEXT_UPDATE_TAG_KEY = ["text", "maxLineWidth", "maxWidth", "textAlign", "textBaseline", "heightLimit", "lineClamp", "fontSize", "fontFamily", "fontWeight", "ellipsis", "lineHeight", "direction", "wordBreak", "heightLimit", "lineClamp", ...GRAPHIC_UPDATE_TAG_KEY];
	class Text extends Graphic {
	  get font() {
	    const textTheme = this.getGraphicTheme();
	    return this._font || (this._font = getContextFont(this.attribute, textTheme)), this._font;
	  }
	  get clipedText() {
	    var _a;
	    const attribute = this.attribute,
	      textTheme = this.getGraphicTheme(),
	      maxWidth = this.getMaxWidth(textTheme);
	    return Number.isFinite(maxWidth) ? (this.tryUpdateAABBBounds(), this.cache.clipedText) : (null !== (_a = attribute.text) && void 0 !== _a ? _a : textTheme.text).toString();
	  }
	  get clipedWidth() {
	    return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
	  }
	  get cliped() {
	    var _a, _b;
	    const textTheme = this.getGraphicTheme(),
	      attribute = this.attribute,
	      maxWidth = this.getMaxWidth(textTheme);
	    if (!Number.isFinite(maxWidth)) return !1;
	    const {
	      text: text
	    } = this.attribute;
	    if (this.tryUpdateAABBBounds(), null === (_b = null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData) || void 0 === _b ? void 0 : _b.lines) {
	      let mergedText = "";
	      this.cache.layoutData.lines.forEach(item => {
	        mergedText += item.str;
	      });
	      return (Array.isArray(text) ? text.join("") : text) !== mergedText;
	    }
	    return "vertical" === attribute.direction && this.cache.verticalList && this.cache.verticalList[0] ? this.cache.verticalList[0].map(item => item.text).join("") !== attribute.text.toString() : null != this.clipedText && this.clipedText !== attribute.text.toString();
	  }
	  get multilineLayout() {
	    return this.tryUpdateAABBBounds(), this.cache.layoutData;
	  }
	  get isMultiLine() {
	    return Array.isArray(this.attribute.text) || "normal" === this.attribute.whiteSpace;
	  }
	  constructor(params = {
	    text: "",
	    fontSize: 16
	  }) {
	    super(params), this.type = "text", this.numberType = TEXT_NUMBER_TYPE, this.cache = {};
	  }
	  isValid() {
	    return super.isValid() && this._isValid();
	  }
	  _isValid() {
	    const {
	      text: text
	    } = this.attribute;
	    return isArray$1(text) ? !text.every(t => null == t || "" === t) : null != text && "" !== text;
	  }
	  getGraphicTheme() {
	    return getTheme(this).text;
	  }
	  doUpdateOBBBounds() {
	    const graphicTheme = this.getGraphicTheme();
	    this._OBBBounds.clear();
	    const attribute = this.attribute,
	      {
	        angle = graphicTheme.angle
	      } = attribute;
	    if (!angle) {
	      const b = this.AABBBounds;
	      return this._OBBBounds.setValue(b.x1, b.y1, b.x2, b.y2), this._OBBBounds;
	    }
	    this.obbText || (this.obbText = new Text({})), this.obbText.setAttributes(Object.assign(Object.assign({}, attribute), {
	      angle: 0
	    }));
	    const bounds1 = this.obbText.AABBBounds,
	      {
	        x: x,
	        y: y
	      } = attribute,
	      boundsCenter = {
	        x: (bounds1.x1 + bounds1.x2) / 2,
	        y: (bounds1.y1 + bounds1.y2) / 2
	      },
	      center = rotatePoint(boundsCenter, angle, {
	        x: x,
	        y: y
	      });
	    return this._OBBBounds.copy(bounds1), this._OBBBounds.translate(center.x - boundsCenter.x, center.y - boundsCenter.y), this._OBBBounds.angle = angle, this._OBBBounds;
	  }
	  updateAABBBounds(attribute, textTheme, aabbBounds) {
	    const {
	      text = textTheme.text
	    } = this.attribute;
	    Array.isArray(text) ? this.updateMultilineAABBBounds(text) : this.updateSingallineAABBBounds(text);
	    const {
	        tb1: tb1
	      } = application.graphicService.updateTempAABBBounds(aabbBounds),
	      {
	        scaleX = textTheme.scaleX,
	        scaleY = textTheme.scaleY,
	        shadowBlur = textTheme.shadowBlur,
	        strokeBoundsBuffer = textTheme.strokeBoundsBuffer
	      } = attribute;
	    if (shadowBlur) {
	      const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
	      boundStroke(tb1, shadowBlurHalfWidth, !0, strokeBoundsBuffer), aabbBounds.union(tb1);
	    }
	    return application.graphicService.combindShadowAABBBounds(aabbBounds, this), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || application.graphicService.updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, transformBoundsWithMatrix(aabbBounds, aabbBounds, this.transMatrix), aabbBounds;
	  }
	  updateSingallineAABBBounds(text) {
	    this.updateMultilineAABBBounds([text]);
	    const layoutData = this.cache.layoutData;
	    if (layoutData && layoutData.lines && layoutData.lines.length) {
	      const line = layoutData.lines[0];
	      this.cache.clipedText = line.str, this.cache.clipedWidth = line.width;
	    }
	    return this._AABBBounds;
	  }
	  updateMultilineAABBBounds(text) {
	    const textTheme = this.getGraphicTheme(),
	      {
	        direction = textTheme.direction,
	        underlineOffset = textTheme.underlineOffset
	      } = this.attribute,
	      b = "horizontal" === direction ? this.updateHorizontalMultilineAABBBounds(text) : this.updateVerticalMultilineAABBBounds(text);
	    return "horizontal" === direction && underlineOffset && this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + underlineOffset), b;
	  }
	  guessLineHeightBuf(fontSize) {
	    return fontSize ? .1 * fontSize : 0;
	  }
	  updateHorizontalMultilineAABBBounds(text) {
	    var _a;
	    const textTheme = this.getGraphicTheme(),
	      attribute = this.attribute,
	      {
	        fontFamily = textTheme.fontFamily,
	        textAlign = textTheme.textAlign,
	        textBaseline = textTheme.textBaseline,
	        fontSize = textTheme.fontSize,
	        fontWeight = textTheme.fontWeight,
	        ellipsis = textTheme.ellipsis,
	        maxLineWidth: maxLineWidth,
	        stroke = textTheme.stroke,
	        wrap = textTheme.wrap,
	        measureMode = textTheme.measureMode,
	        lineWidth = textTheme.lineWidth,
	        whiteSpace = textTheme.whiteSpace,
	        suffixPosition = textTheme.suffixPosition,
	        ignoreBuf = textTheme.ignoreBuf,
	        keepCenterInLine = textTheme.keepCenterInLine
	      } = attribute,
	      buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize),
	      lineHeight = this.getLineHeight(attribute, textTheme, buf);
	    if ("normal" === whiteSpace || wrap) return this.updateWrapAABBBounds(text);
	    if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
	      const bbox = this.cache.layoutData.bbox;
	      return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
	    }
	    const textMeasure = application.graphicUtil.textMeasure,
	      layoutData = new CanvasTextLayout(fontFamily, {
	        fontSize: fontSize,
	        fontWeight: fontWeight,
	        fontFamily: fontFamily,
	        lineHeight: lineHeight
	      }, textMeasure).GetLayoutByLines(text, textAlign, textBaseline, lineHeight, !0 === ellipsis ? textTheme.ellipsis : ellipsis || void 0, !1, {
	        lineWidth: maxLineWidth,
	        suffixPosition: suffixPosition,
	        measureMode: measureMode,
	        keepCenterInLine: keepCenterInLine
	      }),
	      {
	        bbox: bbox
	      } = layoutData;
	    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
	  }
	  updateWrapAABBBounds(text) {
	    var _a, _b, _c;
	    const textTheme = this.getGraphicTheme(),
	      {
	        fontFamily = textTheme.fontFamily,
	        textAlign = textTheme.textAlign,
	        textBaseline = textTheme.textBaseline,
	        fontSize = textTheme.fontSize,
	        ellipsis = textTheme.ellipsis,
	        maxLineWidth: maxLineWidth,
	        stroke = textTheme.stroke,
	        lineWidth = textTheme.lineWidth,
	        wordBreak = textTheme.wordBreak,
	        fontWeight = textTheme.fontWeight,
	        ignoreBuf = textTheme.ignoreBuf,
	        measureMode = textTheme.measureMode,
	        suffixPosition = textTheme.suffixPosition,
	        heightLimit = 0,
	        lineClamp: lineClamp,
	        keepCenterInLine = textTheme.keepCenterInLine
	      } = this.attribute,
	      buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize),
	      lineHeight = this.getLineHeight(this.attribute, textTheme, buf);
	    if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
	      const bbox = this.cache.layoutData.bbox;
	      return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
	    }
	    const textMeasure = application.graphicUtil.textMeasure,
	      textOptions = {
	        fontSize: fontSize,
	        fontWeight: fontWeight,
	        fontFamily: fontFamily,
	        lineHeight: lineHeight
	      },
	      layoutObj = new CanvasTextLayout(fontFamily, textOptions, textMeasure),
	      lines = isArray$1(text) ? text.map(l => l.toString()) : [text.toString()],
	      linesLayout = [],
	      bboxWH = [0, 0];
	    let lineCountLimit = 1 / 0;
	    if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
	      if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
	        const str = lines[i];
	        let needCut = !0;
	        if (i === lineCountLimit - 1) {
	          const clip = textMeasure.clipTextWithSuffix(str, textOptions, maxLineWidth, ellipsis, !1, suffixPosition, i !== lines.length - 1),
	            matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
	          linesLayout.push({
	            str: clip.str,
	            width: clip.width,
	            ascent: matrics.ascent,
	            descent: matrics.descent,
	            keepCenterInLine: keepCenterInLine
	          });
	          break;
	        }
	        const clip = textMeasure.clipText(str, textOptions, maxLineWidth, "break-all" !== wordBreak, "keep-all" === wordBreak);
	        if ("" !== str && "" === clip.str || clip.wordBreaked) {
	          if (ellipsis) {
	            const clipEllipsis = textMeasure.clipTextWithSuffix(str, textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
	            clip.str = null !== (_b = clipEllipsis.str) && void 0 !== _b ? _b : "", clip.width = null !== (_c = clipEllipsis.width) && void 0 !== _c ? _c : 0;
	          } else clip.str = "", clip.width = 0;
	          needCut = !1;
	        }
	        const matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
	        linesLayout.push({
	          str: clip.str,
	          width: clip.width,
	          ascent: matrics.ascent,
	          descent: matrics.descent,
	          keepCenterInLine: keepCenterInLine
	        });
	        let cutLength = clip.str.length;
	        if (!clip.wordBreaked || "" !== str && "" === clip.str || (needCut = !0, cutLength = clip.wordBreaked), clip.str.length === str.length) ;else if (needCut) {
	          let newStr = str.substring(cutLength);
	          "keep-all" === wordBreak && (newStr = newStr.replace(/^\s+/g, "")), lines.splice(i + 1, 0, newStr);
	        }
	      }
	      let maxWidth = 0;
	      linesLayout.forEach(layout => {
	        maxWidth = Math.max(maxWidth, layout.width);
	      }), bboxWH[0] = maxWidth;
	    } else {
	      let width,
	        text,
	        lineWidth = 0;
	      for (let i = 0, len = lines.length; i < len; i++) {
	        if (i === lineCountLimit - 1) {
	          const clip = textMeasure.clipTextWithSuffix(lines[i], textOptions, maxLineWidth, ellipsis, !1, suffixPosition),
	            matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
	          linesLayout.push({
	            str: clip.str,
	            width: clip.width,
	            ascent: matrics.ascent,
	            descent: matrics.descent,
	            keepCenterInLine: keepCenterInLine
	          }), lineWidth = Math.max(lineWidth, clip.width);
	          break;
	        }
	        text = lines[i], width = textMeasure.measureTextWidth(text, textOptions), lineWidth = Math.max(lineWidth, width);
	        const matrics = textMeasure.measureTextPixelADscentAndWidth(text, textOptions, measureMode);
	        linesLayout.push({
	          str: text,
	          width: width,
	          ascent: matrics.ascent,
	          descent: matrics.descent,
	          keepCenterInLine: keepCenterInLine
	        });
	      }
	      bboxWH[0] = lineWidth;
	    }
	    bboxWH[1] = linesLayout.length * lineHeight;
	    const bbox = {
	      xOffset: 0,
	      yOffset: 0,
	      width: bboxWH[0],
	      height: bboxWH[1]
	    };
	    layoutObj.LayoutBBox(bbox, textAlign, textBaseline, linesLayout);
	    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
	    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
	  }
	  updateVerticalMultilineAABBBounds(text) {
	    var _a, _b;
	    const textTheme = this.getGraphicTheme(),
	      textMeasure = application.graphicUtil.textMeasure;
	    let width;
	    const attribute = this.attribute,
	      {
	        maxLineWidth = textTheme.maxLineWidth,
	        ellipsis = textTheme.ellipsis,
	        fontFamily = textTheme.fontFamily,
	        fontSize = textTheme.fontSize,
	        fontWeight = textTheme.fontWeight,
	        stroke = textTheme.stroke,
	        lineWidth = textTheme.lineWidth,
	        verticalMode = textTheme.verticalMode,
	        suffixPosition = textTheme.suffixPosition
	      } = attribute,
	      lineHeight = this.getLineHeight(attribute, textTheme, 0);
	    let {
	      textAlign = textTheme.textAlign,
	      textBaseline = textTheme.textBaseline
	    } = attribute;
	    if (!verticalMode) {
	      const t = textAlign;
	      textAlign = null !== (_a = Text.baselineMapAlign[textBaseline]) && void 0 !== _a ? _a : "left", textBaseline = null !== (_b = Text.alignMapBaseline[t]) && void 0 !== _b ? _b : "top";
	    }
	    if (width = 0, !this.shouldUpdateShape() && this.cache) {
	      this.cache.verticalList.forEach(item => {
	        const w = item.reduce((a, b) => a + b.width, 0);
	        width = max(w, width);
	      });
	      const dx = textDrawOffsetX(textAlign, width),
	        height = this.cache.verticalList.length * lineHeight,
	        dy = textLayoutOffsetY(textBaseline, height, fontSize);
	      return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
	    }
	    const verticalLists = text.map(str => verticalLayout(str.toString()));
	    verticalLists.forEach((verticalData, i) => {
	      if (Number.isFinite(maxLineWidth)) {
	        if (ellipsis) {
	          const strEllipsis = !0 === ellipsis ? textTheme.ellipsis : ellipsis,
	            data = textMeasure.clipTextWithSuffixVertical(verticalData, {
	              fontSize: fontSize,
	              fontWeight: fontWeight,
	              fontFamily: fontFamily
	            }, maxLineWidth, strEllipsis, !1, suffixPosition);
	          verticalLists[i] = data.verticalList, width = data.width;
	        } else {
	          const data = textMeasure.clipTextVertical(verticalData, {
	            fontSize: fontSize,
	            fontWeight: fontWeight,
	            fontFamily: fontFamily
	          }, maxLineWidth, !1);
	          verticalLists[i] = data.verticalList, width = data.width;
	        }
	      } else width = 0, verticalData.forEach(t => {
	        const w = t.direction === TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t.text, {
	          fontSize: fontSize,
	          fontWeight: fontWeight,
	          fontFamily: fontFamily
	        });
	        width += w, t.width = w;
	      });
	    }), this.cache.verticalList = verticalLists, this.clearUpdateShapeTag(), this.cache.verticalList.forEach(item => {
	      const w = item.reduce((a, b) => a + b.width, 0);
	      width = max(w, width);
	    });
	    const dx = textDrawOffsetX(textAlign, width),
	      height = this.cache.verticalList.length * lineHeight,
	      dy = textLayoutOffsetY(textBaseline, height, fontSize);
	    return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
	  }
	  getMaxWidth(theme) {
	    var _a, _b;
	    const attribute = this.attribute;
	    return null !== (_b = null !== (_a = attribute.maxLineWidth) && void 0 !== _a ? _a : attribute.maxWidth) && void 0 !== _b ? _b : theme.maxWidth;
	  }
	  getLineHeight(attribute, textTheme, buf) {
	    var _a;
	    return null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
	  }
	  needUpdateTags(keys, k = TEXT_UPDATE_TAG_KEY) {
	    return super.needUpdateTags(keys, k);
	  }
	  needUpdateTag(key, k = TEXT_UPDATE_TAG_KEY) {
	    return super.needUpdateTag(key, k);
	  }
	  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
	    "text" === key && (nextAttributes.text = nextStepVal);
	  }
	  clone() {
	    return new Text(Object.assign({}, this.attribute));
	  }
	  getNoWorkAnimateAttr() {
	    return Text.NOWORK_ANIMATE_ATTR;
	  }
	  getBaselineMapAlign() {
	    return Text.baselineMapAlign;
	  }
	  getAlignMapBaseline() {
	    return Text.alignMapBaseline;
	  }
	}
	Text.NOWORK_ANIMATE_ATTR = Object.assign({
	  ellipsis: 1,
	  wordBreak: 1,
	  direction: 1,
	  textAlign: 1,
	  textBaseline: 1,
	  fontFamily: 1,
	  fontWeight: 1
	}, NOWORK_ANIMATE_ATTR), Text.baselineMapAlign = {
	  top: "left",
	  bottom: "right",
	  middle: "center"
	}, Text.alignMapBaseline = {
	  left: "top",
	  right: "bottom",
	  center: "middle"
	};
	function createText(attributes) {
	  return new Text(attributes);
	}

	const updateBoundsOfSymbolOuterBorder = (attribute, symbolTheme, aabbBounds) => {
	  const {
	    outerBorder: outerBorder,
	    shadowBlur = symbolTheme.shadowBlur,
	    strokeBoundsBuffer = symbolTheme.strokeBoundsBuffer
	  } = attribute;
	  if (outerBorder) {
	    const defaultOuterBorder = symbolTheme.outerBorder,
	      {
	        distance = defaultOuterBorder.distance,
	        lineWidth = defaultOuterBorder.lineWidth
	      } = outerBorder;
	    boundStroke(aabbBounds, distance + (shadowBlur + lineWidth) / 2, !0, strokeBoundsBuffer);
	  }
	  return aabbBounds;
	};

	const SYMBOL_UPDATE_TAG_KEY = ["symbolType", "size", ...GRAPHIC_UPDATE_TAG_KEY];
	let Symbol$1 = class Symbol extends Graphic {
	  constructor(params = {
	    symbolType: "circle"
	  }) {
	    super(params), this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
	  }
	  getParsedPath() {
	    return this.shouldUpdateShape() && (this._parsedPath = this.doUpdateParsedPath(), this.clearUpdateShapeTag()), this._parsedPath;
	  }
	  getParsedPath2D(x = 0, y = 0, size = 1) {
	    let path = null;
	    try {
	      path = new Path2D();
	    } catch (err) {
	      return null;
	    }
	    const parsedPath = this.getParsedPath();
	    if (!parsedPath) return null;
	    parsedPath.draw(path, size, x, y);
	  }
	  isValid() {
	    return super.isValid() && this._isValid();
	  }
	  _isValid() {
	    const {
	      size: size
	    } = this.attribute;
	    return isArray$1(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);
	  }
	  doUpdateParsedPath() {
	    const {
	      symbolType = "circle"
	    } = this.attribute;
	    return super.parsePath(symbolType);
	  }
	  getGraphicTheme() {
	    return getTheme(this).symbol;
	  }
	  updateAABBBounds(attribute, symbolTheme, aabbBounds, full) {
	    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds));
	    const {
	      tb1: tb1,
	      tb2: tb2
	    } = application.graphicService.updateTempAABBBounds(aabbBounds);
	    updateBoundsOfSymbolOuterBorder(attribute, symbolTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, this.x1WithoutTransform = aabbBounds.x1, this.y1WithoutTransform = aabbBounds.y1;
	    const {
	      lineJoin = symbolTheme.lineJoin
	    } = attribute;
	    return application.graphicService.transformAABBBounds(attribute, aabbBounds, symbolTheme, "miter" === lineJoin, this), aabbBounds;
	  }
	  updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) {
	    const {
	      size = symbolTheme.size
	    } = attribute;
	    if (isArray$1(size)) aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2);else {
	      const halfWH = size / 2;
	      aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
	    }
	    return aabbBounds;
	  }
	  updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds) {
	    const {
	      size = symbolTheme.size
	    } = attribute;
	    return this.getParsedPath().bounds(size, aabbBounds), aabbBounds;
	  }
	  needUpdateTags(keys) {
	    return super.needUpdateTags(keys, SYMBOL_UPDATE_TAG_KEY);
	  }
	  needUpdateTag(key) {
	    return super.needUpdateTag(key, SYMBOL_UPDATE_TAG_KEY);
	  }
	  toCustomPath() {
	    const symbolInstance = this.getParsedPath(),
	      size = this.attribute.size,
	      formattedSize = isArray$1(size) ? size : [size, size];
	    return symbolInstance.path ? new CustomPath2D().fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : new CustomPath2D().fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);
	  }
	  clone() {
	    return new Symbol(Object.assign({}, this.attribute));
	  }
	  getNoWorkAnimateAttr() {
	    return Symbol.NOWORK_ANIMATE_ATTR;
	  }
	};
	Symbol$1.NOWORK_ANIMATE_ATTR = Object.assign({
	  symbolType: 1
	}, NOWORK_ANIMATE_ATTR);
	function createSymbol(attributes) {
	  return new Symbol$1(attributes);
	}

	const LINE_UPDATE_TAG_KEY = ["segments", "points", "curveType", "curveTension", ...GRAPHIC_UPDATE_TAG_KEY];
	let Line$1 = class Line extends Graphic {
	  constructor(params = {}) {
	    super(params), this.type = "line", this.numberType = LINE_NUMBER_TYPE;
	  }
	  isValid() {
	    return super.isValid() && this._isValid();
	  }
	  _isValid() {
	    if (this.pathProxy) return !0;
	    const {
	      points: points,
	      segments: segments
	    } = this.attribute;
	    return segments ? 0 !== segments.length : !!points && !(points.length <= 1);
	  }
	  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
	    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
	  }
	  getGraphicTheme() {
	    return getTheme(this).line;
	  }
	  updateAABBBounds(attribute, lineTheme, aabbBounds) {
	    this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds)), application.graphicService.updateTempAABBBounds(aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
	    const {
	      lineJoin = lineTheme.lineJoin
	    } = attribute;
	    return application.graphicService.transformAABBBounds(attribute, aabbBounds, lineTheme, "miter" === lineJoin, this), aabbBounds;
	  }
	  updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
	    const {
	        points = lineTheme.points,
	        connectedType: connectedType
	      } = attribute,
	      b = aabbBounds;
	    return points.forEach(p => {
	      !1 === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
	    }), b;
	  }
	  updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
	    const {
	        segments = lineTheme.segments,
	        connectedType: connectedType
	      } = attribute,
	      b = aabbBounds;
	    return segments.forEach(s => {
	      s.points.forEach(p => {
	        !1 === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
	      });
	    }), b;
	  }
	  needUpdateTags(keys) {
	    return super.needUpdateTags(keys, LINE_UPDATE_TAG_KEY);
	  }
	  needUpdateTag(key) {
	    return super.needUpdateTag(key, LINE_UPDATE_TAG_KEY);
	  }
	  toCustomPath() {
	    let path = super.toCustomPath();
	    if (path) return path;
	    const attribute = this.attribute;
	    path = new CustomPath2D();
	    const segments = attribute.segments,
	      parsePoints = points => {
	        if (points && points.length) {
	          let isFirst = !0;
	          points.forEach(point => {
	            !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), isFirst = !1);
	          });
	        }
	      };
	    return segments && segments.length ? segments.forEach(seg => {
	      parsePoints(seg.points);
	    }) : attribute.points && parsePoints(attribute.points), path;
	  }
	  clone() {
	    return new Line(Object.assign({}, this.attribute));
	  }
	  getNoWorkAnimateAttr() {
	    return Line.NOWORK_ANIMATE_ATTR;
	  }
	};
	Line$1.NOWORK_ANIMATE_ATTR = Object.assign({
	  segments: 1,
	  curveType: 1
	}, NOWORK_ANIMATE_ATTR);
	function createLine(attributes) {
	  return new Line$1(attributes);
	}

	const normalizeRectAttributes = attribute => {
	  if (!attribute) return {
	    x: 0,
	    y: 0,
	    width: 0,
	    height: 0
	  };
	  let width = isNil$1(attribute.width) ? attribute.x1 - attribute.x : attribute.width,
	    height = isNil$1(attribute.height) ? attribute.y1 - attribute.y : attribute.height,
	    x = 0,
	    y = 0;
	  return width < 0 ? (x = width, width = -width) : Number.isNaN(width) && (width = 0), height < 0 ? (y = height, height = -height) : Number.isNaN(height) && (height = 0), {
	    x: x,
	    y: y,
	    width: width,
	    height: height
	  };
	};

	const RECT_UPDATE_TAG_KEY = ["width", "x1", "y1", "height", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
	class Rect extends Graphic {
	  constructor(params) {
	    super(params), this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
	  }
	  isValid() {
	    return super.isValid() && this._isValid();
	  }
	  _isValid() {
	    return !0;
	  }
	  getGraphicTheme() {
	    return getTheme(this).rect;
	  }
	  updateAABBBounds(attribute, rectTheme, aabbBounds) {
	    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
	      let {
	        width: width,
	        height: height
	      } = attribute;
	      const {
	        x1: x1,
	        y1: y1,
	        x: x,
	        y: y
	      } = attribute;
	      width = null != width ? width : x1 - x, height = null != height ? height : y1 - y, (isFinite(width) || isFinite(height) || isFinite(x) || isFinite(y)) && aabbBounds.set(0, 0, width || 0, height || 0);
	    }
	    const {
	      tb1: tb1,
	      tb2: tb2
	    } = application.graphicService.updateTempAABBBounds(aabbBounds);
	    return updateBoundsOfCommonOuterBorder(attribute, rectTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, rectTheme, !1, this), aabbBounds;
	  }
	  needUpdateTags(keys) {
	    return super.needUpdateTags(keys, RECT_UPDATE_TAG_KEY);
	  }
	  needUpdateTag(key) {
	    return super.needUpdateTag(key, RECT_UPDATE_TAG_KEY);
	  }
	  toCustomPath() {
	    let path = super.toCustomPath();
	    if (path) return path;
	    const attribute = this.attribute,
	      {
	        x: x,
	        y: y,
	        width: width,
	        height: height
	      } = normalizeRectAttributes(attribute);
	    return path = new CustomPath2D(), path.moveTo(x, y), path.rect(x, y, width, height), path;
	  }
	  clone() {
	    return new Rect(Object.assign({}, this.attribute));
	  }
	  getNoWorkAnimateAttr() {
	    return Rect.NOWORK_ANIMATE_ATTR;
	  }
	}
	Rect.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
	function createRect(attributes) {
	  return new Rect(attributes);
	}

	const CUBE_VERTICES = [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]];
	class Rect3d extends Rect {
	  constructor(params) {
	    super(params), this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
	  }
	  findFace() {
	    const faces = {
	        polygons: [],
	        vertices: [],
	        edges: []
	      },
	      rectTheme = this.getGraphicTheme(),
	      {
	        x1: x1,
	        y1: y1,
	        x: x,
	        y: y,
	        length = min(rectTheme.width, rectTheme.height)
	      } = this.attribute;
	    let {
	      width: width,
	      height: height
	    } = this.attribute;
	    width = null != width ? width : x1 - x, height = null != height ? height : y1 - y;
	    for (let i = 0; i < CUBE_VERTICES.length; i++) {
	      const v = CUBE_VERTICES[i];
	      faces.vertices.push([v[0] * width, v[1] * height, v[2] * length]);
	    }
	    return faces.polygons.push({
	      polygon: [0, 1, 5, 4],
	      normal: [0, -1, 0]
	    }), faces.polygons.push({
	      polygon: [2, 3, 7, 6],
	      normal: [0, 1, 0]
	    }), faces.polygons.push({
	      polygon: [4, 7, 3, 0],
	      normal: [-1, 0, 0]
	    }), faces.polygons.push({
	      polygon: [1, 2, 6, 5],
	      normal: [1, 0, 0]
	    }), faces.polygons.push({
	      polygon: [0, 1, 2, 3],
	      normal: [0, 0, -1]
	    }), faces.polygons.push({
	      polygon: [4, 5, 6, 7],
	      normal: [0, 0, 1]
	    }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
	  }
	  getNoWorkAnimateAttr() {
	    return Rect3d.NOWORK_ANIMATE_ATTR;
	  }
	}
	Rect3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
	function createRect3d(attributes) {
	  return new Rect3d(attributes);
	}

	class Frame {
	  constructor(left, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons) {
	    this.left = left, this.top = top, this.width = width, this.height = height, this.actualHeight = 0, this.bottom = top + height, this.right = left + width, this.ellipsis = ellipsis, this.wordBreak = wordBreak, this.verticalDirection = verticalDirection, this.lines = [], this.globalAlign = globalAlign, this.globalBaseline = globalBaseline, this.layoutDirection = layoutDirection, this.directionKey = DIRECTION_KEY[this.layoutDirection], this.isWidthMax = isWidthMax, this.isHeightMax = isHeightMax, this.singleLine = singleLine, icons ? (icons.clear(), this.icons = icons) : this.icons = new Map();
	  }
	  draw(ctx, drawIcon) {
	    const {
	        width: actualWidth,
	        height: actualHeight
	      } = this.getActualSize(),
	      width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;
	    let height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;
	    height = Math.min(height, actualHeight);
	    let deltaY = 0;
	    switch (this.globalBaseline) {
	      case "top":
	        deltaY = 0;
	        break;
	      case "middle":
	        deltaY = -height / 2;
	        break;
	      case "bottom":
	        deltaY = -height;
	    }
	    let deltaX = 0;
	    "right" === this.globalAlign || "end" === this.globalAlign ? deltaX = -width : "center" === this.globalAlign && (deltaX = -width / 2);
	    let frameHeight = this[this.directionKey.height];
	    this.singleLine && (frameHeight = this.lines[0].height + 1);
	    let lastLineTag = !1;
	    if ("middle" === this.verticalDirection) {
	      if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
	        const {
	          top: top,
	          height: height
	        } = this.lines[i];
	        if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) return lastLineTag;
	        let lastLine = !1;
	        this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
	      } else {
	        const detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);
	        "vertical" === this.layoutDirection ? deltaX += detalHeight : deltaY += detalHeight;
	        for (let i = 0; i < this.lines.length; i++) this.lines[i].draw(ctx, !1, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
	      }
	    } else if ("bottom" === this.verticalDirection && "vertical" !== this.layoutDirection) for (let i = 0; i < this.lines.length; i++) {
	      const {
	          top: top,
	          height: height
	        } = this.lines[i],
	        y = frameHeight - this.lines[i].top - this.lines[i].height;
	      if (0 === frameHeight) this.lines[i].draw(ctx, !1, deltaX, y + deltaY, this.ellipsis, drawIcon);else {
	        if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) return lastLineTag;
	        {
	          let lastLine = !1;
	          this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top] && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, deltaX, y + deltaY, this.ellipsis, drawIcon);
	        }
	      }
	    } else {
	      "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && this.singleLine && this.isWidthMax && (deltaX += this.lines[0].height + 1);
	      for (let i = 0; i < this.lines.length; i++) {
	        "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && (deltaX -= this.lines[i].height + this.lines[i].top);
	        const {
	          top: top,
	          height: height
	        } = this.lines[i];
	        if (0 === frameHeight) this.lines[i].draw(ctx, !1, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);else {
	          if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) return lastLineTag;
	          {
	            let lastLine = !1;
	            this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
	          }
	        }
	      }
	    }
	    return lastLineTag;
	  }
	  getActualSize() {
	    return this.ellipsis ? this.getActualSizeWidthEllipsis() : this.getRawActualSize();
	  }
	  getRawActualSize() {
	    let width = 0,
	      height = 0;
	    for (let i = 0; i < this.lines.length; i++) {
	      const line = this.lines[i];
	      line.actualWidth > width && (width = line.actualWidth), height += line.height;
	    }
	    return {
	      width: "vertical" === this.layoutDirection ? height : width,
	      height: "vertical" === this.layoutDirection ? width : height
	    };
	  }
	  getActualSizeWidthEllipsis() {
	    let widthBound = 0,
	      heightBound = 0;
	    const {
	      width: actualWidth,
	      height: actualHeight
	    } = this.getRawActualSize();
	    this.width;
	    this.height || actualHeight || 0;
	    let frameHeight = this[this.directionKey.height];
	    if (this.singleLine && (frameHeight = this.lines[0].height + 1), "middle" === this.verticalDirection) {
	      if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
	        const {
	          top: top,
	          height: height
	        } = this.lines[i];
	        if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ;else if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
	          const ellipsis = !0 === this.ellipsis ? "..." : this.ellipsis || "",
	            lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
	          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
	        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
	      } else {
	        Math.floor((frameHeight - this.actualHeight) / 2);
	        for (let i = 0; i < this.lines.length; i++) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
	      }
	    } else if ("bottom" === this.verticalDirection) for (let i = 0; i < this.lines.length; i++) {
	      const {
	          top: top,
	          height: height
	        } = this.lines[i],
	        y = frameHeight - this.lines[i].top - this.lines[i].height;
	      if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;else if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) ;else {
	        if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {
	          const ellipsis = !0 === this.ellipsis ? "..." : this.ellipsis || "",
	            lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
	          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
	        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
	      }
	    } else for (let i = 0; i < this.lines.length; i++) {
	      const {
	        top: top,
	        height: height
	      } = this.lines[i];
	      if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;else if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ;else {
	        if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
	          const ellipsis = !0 === this.ellipsis ? "..." : this.ellipsis || "",
	            lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
	          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
	        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
	      }
	    }
	    return {
	      width: "vertical" === this.layoutDirection ? heightBound : widthBound,
	      height: "vertical" === this.layoutDirection ? widthBound : heightBound
	    };
	  }
	}

	function getFixedLRTB(left, right, top, bottom) {
	  const leftInt = Math.round(left),
	    topInt = Math.round(top),
	    rightInt = Math.round(right),
	    bottomInt = Math.round(bottom);
	  return {
	    left: left > leftInt ? leftInt : leftInt - .5,
	    top: top > topInt ? topInt : topInt - .5,
	    right: rightInt > right ? rightInt : rightInt + .5,
	    bottom: bottomInt > bottom ? bottomInt : bottomInt + .5
	  };
	}
	class Paragraph {
	  constructor(text, newLine, character, ascentDescentMode) {
	    var _a, _b;
	    this.fontSize = character.fontSize || 16, this.textBaseline = character.textBaseline || "alphabetic", this.ascentDescentMode = ascentDescentMode;
	    const lineHeight = calculateLineHeight(character.lineHeight, this.fontSize);
	    this.lineHeight = "number" == typeof lineHeight ? lineHeight > this.fontSize ? lineHeight : this.fontSize : Math.floor(1.2 * this.fontSize), this.height = this.lineHeight;
	    const {
	      ascent: ascent,
	      height: height,
	      descent: descent,
	      width: width
	    } = measureTextCanvas(text, character, this.ascentDescentMode);
	    let halfDetaHeight = 0,
	      deltaAscent = 0,
	      deltaDescent = 0;
	    this.height > height && (halfDetaHeight = (this.height - height) / 2, deltaAscent = Math.ceil(halfDetaHeight), deltaDescent = Math.floor(halfDetaHeight)), "top" === this.textBaseline ? (this.ascent = halfDetaHeight, this.descent = height - halfDetaHeight) : "bottom" === this.textBaseline ? (this.ascent = height - halfDetaHeight, this.descent = halfDetaHeight) : "middle" === this.textBaseline ? (this.ascent = this.height / 2, this.descent = this.height / 2) : (this.ascent = ascent + deltaAscent, this.descent = descent + deltaDescent), this.length = text.length, this.width = width || 0, this.text = text || "", this.newLine = newLine || !1, this.character = character, this.left = 0, this.top = 0, this.ellipsis = "normal", this.ellipsisWidth = 0, this.ellipsisOtherParagraphWidth = 0, this.space = character.space, this.dx = null !== (_a = character.dx) && void 0 !== _a ? _a : 0, this.dy = null !== (_b = character.dy) && void 0 !== _b ? _b : 0, "vertical" === character.direction && (this.direction = character.direction, this.widthOrigin = this.width, this.heightOrigin = this.height, this.width = this.heightOrigin, this.height = this.widthOrigin, this.lineHeight = this.height), this.ellipsisStr = "...";
	  }
	  updateWidth() {
	    const {
	      width: width
	    } = measureTextCanvas(this.text, this.character, this.ascentDescentMode);
	    this.width = width, "vertical" === this.direction && (this.widthOrigin = this.width, this.width = this.heightOrigin, this.height = this.widthOrigin);
	  }
	  drawBackground(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
	    if ("" === this.text || "\n" === this.text || !this.character.background || this.character.backgroundOpacity && !(this.character.backgroundOpacity > 0)) return;
	    let baseline = top + ascent,
	      text = this.text,
	      left = this.left + deltaLeft;
	    baseline += this.top;
	    let direction = this.direction;
	    if (this.verticalEllipsis) text = this.ellipsisStr, direction = "vertical", baseline -= this.ellipsisWidth / 2;else {
	      if ("hide" === this.ellipsis) return;
	      if ("add" === this.ellipsis) text += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left -= this.ellipsisWidth);else if ("replace" === this.ellipsis) {
	        const index = getStrByWithCanvas(text, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
	        if (text = text.slice(0, index), text += this.ellipsisStr, "right" === textAlign || "end" === textAlign) if ("vertical" === direction) ;else {
	          const {
	            width: width
	          } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
	          left -= this.ellipsisWidth - width;
	        }
	      }
	    }
	    const lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + lineHeight);
	    return Object.assign(Object.assign({}, lrtb), {
	      fillStyle: this.character.background,
	      globalAlpha: this.character.backgroundOpacity
	    });
	  }
	  draw(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
	    var _a;
	    let baseline = top + ascent,
	      text = this.text,
	      left = this.left + deltaLeft + (null !== (_a = this.space) && void 0 !== _a ? _a : 0) / 2;
	    baseline += this.top;
	    let direction = this.direction;
	    if (this.verticalEllipsis) text = this.ellipsisStr, direction = "vertical", baseline -= this.ellipsisWidth / 2;else {
	      if ("hide" === this.ellipsis) return;
	      if ("add" === this.ellipsis) text += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left -= this.ellipsisWidth);else if ("replace" === this.ellipsis) {
	        const index = getStrByWithCanvas(text, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
	        if (text = text.slice(0, index), text += this.ellipsisStr, "right" === textAlign || "end" === textAlign) if ("vertical" === direction) ;else {
	          const {
	            width: width
	          } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
	          left -= this.ellipsisWidth - width;
	        }
	      }
	    }
	    switch (this.character.script) {
	      case "super":
	        baseline -= this.ascent * (1 / 3);
	        break;
	      case "sub":
	        baseline += this.descent / 2;
	    }
	    "vertical" === direction && (ctx.save(), ctx.rotateAbout(Math.PI / 2, left, baseline), ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2), ctx.translate(left, baseline), left = 0, baseline = 0);
	    const {
	      lineWidth = 1
	    } = this.character;
	    if (this.character.stroke && lineWidth && ctx.strokeText(text, left + this.dx, baseline + this.dy), this.character.fill && ctx.fillText(text, left + this.dx, baseline + this.dy), this.character.fill) if (this.character.lineThrough || this.character.underline) {
	      if (this.character.underline) {
	        const top = 1 + baseline,
	          lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
	        ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
	      }
	      if (this.character.lineThrough) {
	        const top = 1 + baseline - this.ascent / 2,
	          lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
	        ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
	      }
	    } else if ("underline" === this.character.textDecoration) {
	      const top = 1 + baseline,
	        lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
	      ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
	    } else if ("line-through" === this.character.textDecoration) {
	      const top = 1 + baseline - this.ascent / 2,
	        lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
	      ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
	    }
	    "vertical" === direction && ctx.restore();
	  }
	  getWidthWithEllips(direction) {
	    let text = this.text;
	    const width = "vertical" === direction ? this.height : this.width;
	    if ("hide" === this.ellipsis) return width;
	    if ("add" === this.ellipsis) return width + this.ellipsisWidth;
	    if ("replace" === this.ellipsis) {
	      const index = getStrByWithCanvas(text, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
	      text = text.slice(0, index), text += this.ellipsisStr;
	      const {
	        width: measureWidth
	      } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
	      return width + this.ellipsisWidth - measureWidth;
	    }
	    return width;
	  }
	}
	function seperateParagraph(paragraph, index) {
	  const text1 = paragraph.text.slice(0, index),
	    text2 = paragraph.text.slice(index);
	  return [new Paragraph(text1, paragraph.newLine, paragraph.character, paragraph.ascentDescentMode), new Paragraph(text2, !0, paragraph.character, paragraph.ascentDescentMode)];
	}

	const IMAGE_UPDATE_TAG_KEY = ["width", "height", "image", ...GRAPHIC_UPDATE_TAG_KEY];
	class Image extends Graphic {
	  constructor(params) {
	    super(params), this.type = "image", this.numberType = IMAGE_NUMBER_TYPE, this.loadImage(this.attribute.image);
	  }
	  getImageElement() {
	    const {
	      image: image
	    } = this.attribute;
	    if (!image || !this.resources) return null;
	    const res = this.resources.get(image);
	    return "success" !== res.state ? null : res.data;
	  }
	  get width() {
	    return this.tryUpdateAABBBounds(), this._actualWidth;
	  }
	  get height() {
	    return this.tryUpdateAABBBounds(), this._actualHeight;
	  }
	  get repeatX() {
	    var _a;
	    return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : "no-repeat";
	  }
	  set repeatX(repeatX) {
	    this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);
	  }
	  get repeatY() {
	    var _a;
	    return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : "no-repeat";
	  }
	  set repeatY(repeatY) {
	    this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);
	  }
	  get image() {
	    return this.attribute.image;
	  }
	  set image(image) {
	    image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));
	  }
	  imageLoadSuccess(url, image, cb) {
	    super.imageLoadSuccess(url, image, () => {
	      this.successCallback && this.successCallback();
	    }), this.addUpdateBoundTag();
	  }
	  imageLoadFail(url, cb) {
	    super.imageLoadFail(url, () => {
	      this.failCallback && this.failCallback();
	    });
	  }
	  setAttributes(params, forceUpdateTag, context) {
	    return params.image && this.loadImage(params.image), super.setAttributes(params, forceUpdateTag, context);
	  }
	  setAttribute(key, value, forceUpdateTag, context) {
	    return "image" === key && this.loadImage(value), super.setAttribute(key, value, forceUpdateTag, context);
	  }
	  getGraphicTheme() {
	    return getTheme(this).image;
	  }
	  updateAABBBounds(attribute, imageTheme, aabbBounds) {
	    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
	      const {
	        maxWidth = imageTheme.maxWidth,
	        maxHeight = imageTheme.maxHeight
	      } = attribute;
	      let {
	        width: width,
	        height: height
	      } = attribute;
	      if (null == width || null == height) {
	        const imageElement = this.getImageElement();
	        if (imageElement) {
	          const imageWidth = imageElement.width,
	            imageHeight = imageElement.height;
	          if (null != width) height = width * (imageHeight / imageWidth);else if (null != height) width = height * (imageWidth / imageHeight);else {
	            const imageRatio = imageWidth / imageHeight;
	            imageRatio > maxWidth / maxHeight ? (width = maxWidth, height = maxWidth / imageRatio) : (height = maxHeight, width = maxHeight * imageRatio);
	          }
	        } else width = maxWidth, height = maxHeight;
	      }
	      this._actualWidth = width, this._actualHeight = height, aabbBounds.set(0, 0, width, height);
	    }
	    const {
	      tb1: tb1,
	      tb2: tb2
	    } = application.graphicService.updateTempAABBBounds(aabbBounds);
	    return updateBoundsOfCommonOuterBorder(attribute, imageTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, imageTheme, !1, this), aabbBounds;
	  }
	  getDefaultAttribute(name) {
	    return DefaultImageAttribute[name];
	  }
	  needUpdateTags(keys) {
	    return super.needUpdateTags(keys, IMAGE_UPDATE_TAG_KEY);
	  }
	  needUpdateTag(key) {
	    return super.needUpdateTag(key, IMAGE_UPDATE_TAG_KEY);
	  }
	  clone() {
	    return new Image(Object.assign({}, this.attribute));
	  }
	  getNoWorkAnimateAttr() {
	    return Image.NOWORK_ANIMATE_ATTR;
	  }
	}
	Image.NOWORK_ANIMATE_ATTR = Object.assign({
	  image: 1,
	  repeatX: 1,
	  repeatY: 1
	}, NOWORK_ANIMATE_ATTR);
	function createImage(attributes) {
	  return new Image(attributes);
	}

	class RichTextIcon extends Image {
	  constructor(params) {
	    if (super(params), this._x = 0, this._y = 0, this._hovered = !1, this._marginArray = [0, 0, 0, 0], "always" === params.backgroundShowMode && (this._hovered = !0), params.margin) {
	      const marginArray = parsePadding(params.margin);
	      this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
	    }
	    this.onBeforeAttributeUpdate = (val, attributes, key) => {
	      if (isArray$1(key) && -1 !== key.indexOf("margin") || "margin" === key) if (attributes.margin) {
	        const marginArray = parsePadding(attributes.margin);
	        this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
	      } else this._marginArray = [0, 0, 0, 0];
	    };
	  }
	  get width() {
	    var _a;
	    return (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + this._marginArray[1] + this._marginArray[3];
	  }
	  get height() {
	    var _a;
	    return (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + this._marginArray[0] + this._marginArray[2];
	  }
	  tryUpdateAABBBounds() {
	    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
	    this.doUpdateAABBBounds();
	    const {
	        width = DefaultImageAttribute.width,
	        height = DefaultImageAttribute.height
	      } = this.attribute,
	      {
	        backgroundWidth = width,
	        backgroundHeight = height
	      } = this.attribute,
	      expandX = (backgroundWidth - width) / 2,
	      expandY = (backgroundHeight - height) / 2;
	    return this._AABBBounds.expand([0, 2 * expandX, 2 * expandY, 0]), this._AABBBounds;
	  }
	  setHoverState(hovered) {
	    "hover" === this.attribute.backgroundShowMode && this._hovered !== hovered && (this._hovered = hovered);
	  }
	}

	class Line {
	  constructor(left, width, baseline, ascent, descent, lineBuffer, direction, isWidthMax) {
	    this.left = left, this.width = width, this.baseline = baseline, this.ascent = ascent, this.descent = descent, this.top = baseline - ascent, this.paragraphs = lineBuffer.map(p => p), this.textAlign = (this.paragraphs[0] instanceof RichTextIcon ? this.paragraphs[0].attribute.textAlign : this.paragraphs[0].character.textAlign) || "left", this.direction = direction, this.directionKey = DIRECTION_KEY[this.direction], this.actualWidth = 0;
	    let maxHeight = 0;
	    this.paragraphs.forEach((word, index) => {
	      if (0 === index && word instanceof Paragraph) {
	        const result = regFirstSpace.exec(word.text);
	        0 !== (null == result ? void 0 : result.index) && (word.text = word.text.slice(null == result ? void 0 : result.index), word.updateWidth());
	      }
	      this.actualWidth += word[this.directionKey.width], maxHeight = Math.max(word[this.directionKey.height], maxHeight);
	    }), this.height = maxHeight, this.blankWidth = isWidthMax ? 0 : this.width - this.actualWidth, this.calcOffset(width, isWidthMax);
	  }
	  calcOffset(width, isWidthMax) {
	    const directionKey = this.directionKey,
	      maxHeight = this.height;
	    let x = this.left,
	      spacing = 0;
	    this.actualWidth < width && !isWidthMax && ("right" === this.textAlign || "end" === this.textAlign ? x = width - this.actualWidth : "center" === this.textAlign ? x = (width - this.actualWidth) / 2 : "justify" === this.textAlign && (this.paragraphs.length < 2 ? x = (width - this.actualWidth) / 2 : spacing = (width - this.actualWidth) / (this.paragraphs.length - 1))), this.paragraphs.map(function (paragraph) {
	      paragraph instanceof RichTextIcon ? (paragraph["_" + directionKey.x] = x, x += paragraph[directionKey.width] + spacing, paragraph["_" + directionKey.y] = "top" === paragraph.attribute.textBaseline ? 0 : "bottom" === paragraph.attribute.textBaseline ? maxHeight - paragraph.height : (maxHeight - paragraph.height) / 2) : (paragraph[directionKey.left] = x, x += paragraph[directionKey.width] + spacing);
	    });
	  }
	  draw(ctx, lastLine, x, y, drawEllipsis, drawIcon) {
	    if (drawEllipsis && (lastLine || this.paragraphs.some(p => p.overflow))) {
	      let emptyOverflow = !0,
	        skipEllipsis = !1;
	      for (let i = this.paragraphs.length - 1; i >= 0; i--) {
	        const paragraph = this.paragraphs[i];
	        if (paragraph.overflow) emptyOverflow = emptyOverflow && "" === paragraph.text;else if (emptyOverflow) {
	          skipEllipsis = !0;
	          break;
	        }
	      }
	      let otherParagraphWidth = 0;
	      if (!skipEllipsis) for (let i = this.paragraphs.length - 1; i >= 0; i--) {
	        const paragraph = this.paragraphs[i];
	        if (paragraph.overflow) {
	          if ("" === paragraph.text) break;
	          continue;
	        }
	        if (paragraph instanceof RichTextIcon) break;
	        if ("vertical" === this.direction && "vertical" !== paragraph.direction) {
	          paragraph.verticalEllipsis = !0;
	          break;
	        }
	        const ellipsis = !0 === drawEllipsis ? "..." : drawEllipsis || "";
	        paragraph.ellipsisStr = ellipsis;
	        const {
	            width: width
	          } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode),
	          ellipsisWidth = width || 0;
	        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
	          lastLine && (paragraph.ellipsis = "add");
	          break;
	        }
	        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
	          paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
	          break;
	        }
	        paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
	      }
	    }
	    let fillStyle = "",
	      globalAlpha = -1,
	      currBgList = [];
	    const bgList = [currBgList];
	    this.paragraphs.forEach((paragraph, index) => {
	      if (paragraph instanceof RichTextIcon) return;
	      const data = paragraph.drawBackground(ctx, y, this.ascent, x, 0 === index, this.textAlign, this.height);
	      data && (fillStyle === data.fillStyle && globalAlpha === data.globalAlpha || (currBgList = [], bgList.push(currBgList), fillStyle = data.fillStyle, globalAlpha = data.globalAlpha), currBgList.push(data));
	    }), bgList.forEach(bg => {
	      if (0 === bg.length) return;
	      const data = bg[0],
	        end = bg[bg.length - 1];
	      ctx.fillStyle = data.fillStyle, ctx.globalAlpha = data.globalAlpha, ctx.fillRect(data.left, data.top, end.right - data.left, end.bottom - data.top);
	    }), this.paragraphs.forEach((paragraph, index) => {
	      if (paragraph instanceof RichTextIcon) return paragraph.setAttributes({
	        x: x + paragraph._x,
	        y: y + paragraph._y
	      }), void drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, this.ascent);
	      const b = {
	        x1: this.left,
	        y1: this.top,
	        x2: this.left + this.actualWidth,
	        y2: this.top + this.height
	      };
	      applyStrokeStyle(ctx, paragraph.character), applyFillStyle(ctx, paragraph.character, b), paragraph.draw(ctx, y, this.ascent, x, 0 === index, this.textAlign, this.height);
	    });
	  }
	  getWidthWithEllips(ellipsis) {
	    let otherParagraphWidth = 0;
	    for (let i = this.paragraphs.length - 1; i >= 0; i--) {
	      const paragraph = this.paragraphs[i];
	      if (paragraph instanceof RichTextIcon) break;
	      const {
	          width: width
	        } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode),
	        ellipsisWidth = width || 0;
	      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
	        paragraph.ellipsis = "add", paragraph.ellipsisWidth = ellipsisWidth;
	        break;
	      }
	      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
	        paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
	        break;
	      }
	      paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
	    }
	    let width = 0;
	    return this.paragraphs.forEach((paragraph, index) => {
	      width += paragraph instanceof RichTextIcon ? paragraph.width : paragraph.getWidthWithEllips(this.direction);
	    }), width;
	  }
	}

	class Wrapper {
	  constructor(frame) {
	    this.frame = frame, this.width = this.frame.width, this.height = this.frame.height, this.lineWidth = 0, this.y = this.frame.top, this.maxAscent = 0, this.maxDescent = 0, this.maxAscentForBlank = 0, this.maxDescentForBlank = 0, this.lineBuffer = [], this.direction = frame.layoutDirection, this.directionKey = DIRECTION_KEY[this.direction];
	  }
	  store(paragraph) {
	    if (paragraph instanceof RichTextIcon) {
	      this.frame.icons.set(paragraph.richtextId, paragraph), this.lineBuffer.push(paragraph), this.lineWidth += paragraph[this.directionKey.width];
	      let iconAscent = 0,
	        iconDescent = 0;
	      "top" === paragraph.attribute.textBaseline ? (iconAscent = 0, iconDescent = paragraph.height) : "bottom" === paragraph.attribute.textBaseline ? (iconAscent = paragraph.height, iconDescent = 0) : (iconAscent = paragraph.height / 2, iconDescent = paragraph.height / 2), this.maxAscent = Math.max(this.maxAscent, iconAscent), this.maxDescent = Math.max(this.maxDescent, iconDescent);
	    } else this.lineBuffer.push(paragraph), 0 !== paragraph.text.length ? (this.lineWidth += paragraph[this.directionKey.width], this.maxAscent = Math.max(this.maxAscent, paragraph.ascent), this.maxDescent = Math.max(this.maxDescent, paragraph.descent)) : (this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent), this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent));
	  }
	  send() {
	    if (0 === this.lineBuffer.length) return;
	    const maxAscent = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent,
	      maxDescent = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent,
	      line = new Line(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, "horizontal" === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax);
	    this.frame.lines.push(line), this.frame.actualHeight += line.height, this.y += line.height, this.lineBuffer.length = 0, this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
	  }
	  deal(paragraph, singleLine = !1) {
	    paragraph instanceof RichTextIcon ? "horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : 0 === this.lineBuffer.length ? (this.store(paragraph), this.send()) : (this.send(), this.deal(paragraph)) : "number" != typeof this.width || this.width < 0 || (paragraph.newLine && this.send(), (0 !== paragraph.text.length || this.newLine) && ("horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : this.lineWidth === this[this.directionKey.width] ? (this.send(), this.deal(paragraph)) : this.cut(paragraph, singleLine)));
	  }
	  cut(paragraph, singleLine) {
	    const availableWidth = this[this.directionKey.width] - this.lineWidth || 0,
	      guessIndex = Math.ceil(availableWidth / paragraph[this.directionKey.width] * paragraph.length) || 0,
	      index = getStrByWithCanvas(paragraph.text, availableWidth, paragraph.character, guessIndex, "break-word" === this.frame.wordBreak);
	    if (0 !== index) {
	      const [p1, p2] = seperateParagraph(paragraph, index);
	      this.store(p1), singleLine ? this.send() : this.deal(p2);
	    } else 0 !== this.lineBuffer.length && (this.send(), this.deal(paragraph));
	  }
	}

	let supportIntl = !1;
	try {
	  supportIntl = Intl && "function" == typeof Intl.Segmenter;
	} catch (e) {
	  supportIntl = !1;
	}
	const RICHTEXT_UPDATE_TAG_KEY = ["width", "height", "ellipsis", "wordBreak", "verticalDirection", "maxHeight", "maxWidth", "textAlign", "textBaseline", "textConfig", "layoutDirection", "fill", "stroke", "fontSize", "fontFamily", "fontStyle", "fontWeight", "lineWidth", "opacity", "fillOpacity", "strokeOpacity", ...GRAPHIC_UPDATE_TAG_KEY];
	class RichText extends Graphic {
	  constructor(params) {
	    super(params), this.type = "richtext", this._currentHoverIcon = null, this.numberType = RICHTEXT_NUMBER_TYPE, this.onBeforeAttributeUpdate = (val, attributes, key) => {
	      for (const key in val) if ("hoverIconId" === key) {
	        if (val[key] === attributes[key]) continue;
	        const icon = this._frameCache.icons.get(val[key]);
	        this.updateHoverIconState(icon);
	      }
	    };
	  }
	  get width() {
	    var _a;
	    return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : DefaultRichTextAttribute.width;
	  }
	  set width(w) {
	    this.attribute.width !== w && (this.attribute.width = w, this.addUpdateShapeAndBoundsTag());
	  }
	  get height() {
	    var _a;
	    return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : DefaultRichTextAttribute.height;
	  }
	  set height(h) {
	    this.attribute.height !== h && (this.attribute.height = h, this.addUpdateShapeAndBoundsTag());
	  }
	  get maxWidth() {
	    return this.attribute.maxWidth;
	  }
	  set maxWidth(mw) {
	    this.attribute.maxWidth !== mw && (this.attribute.maxWidth = mw, this.addUpdateShapeAndBoundsTag());
	  }
	  get maxHeight() {
	    return this.attribute.maxHeight;
	  }
	  set maxHeight(mh) {
	    this.attribute.maxHeight !== mh && (this.attribute.maxHeight = mh, this.addUpdateShapeAndBoundsTag());
	  }
	  get ellipsis() {
	    var _a;
	    return null !== (_a = this.attribute.ellipsis) && void 0 !== _a ? _a : DefaultRichTextAttribute.ellipsis;
	  }
	  set ellipsis(e) {
	    this.attribute.ellipsis !== e && (this.attribute.ellipsis = e, this.addUpdateShapeAndBoundsTag());
	  }
	  get wordBreak() {
	    var _a;
	    return null !== (_a = this.attribute.wordBreak) && void 0 !== _a ? _a : DefaultRichTextAttribute.wordBreak;
	  }
	  set wordBreak(wb) {
	    this.attribute.wordBreak !== wb && (this.attribute.wordBreak = wb, this.addUpdateShapeAndBoundsTag());
	  }
	  get verticalDirection() {
	    var _a;
	    return null !== (_a = this.attribute.verticalDirection) && void 0 !== _a ? _a : DefaultRichTextAttribute.verticalDirection;
	  }
	  set verticalDirection(vd) {
	    this.attribute.verticalDirection !== vd && (this.attribute.verticalDirection = vd, this.addUpdateShapeAndBoundsTag());
	  }
	  get textAlign() {
	    var _a;
	    return null !== (_a = this.attribute.textAlign) && void 0 !== _a ? _a : DefaultRichTextAttribute.textAlign;
	  }
	  set textAlign(align) {
	    this.attribute.textAlign !== align && (this.attribute.textAlign = align, this.addUpdateShapeAndBoundsTag());
	  }
	  get textBaseline() {
	    var _a;
	    return null !== (_a = this.attribute.textBaseline) && void 0 !== _a ? _a : DefaultRichTextAttribute.textBaseline;
	  }
	  set textBaseline(baseline) {
	    this.attribute.textBaseline !== baseline && (this.attribute.textBaseline = baseline, this.addUpdateShapeAndBoundsTag());
	  }
	  get textConfig() {
	    var _a;
	    return null !== (_a = this.attribute.textConfig) && void 0 !== _a ? _a : DefaultRichTextAttribute.textConfig;
	  }
	  set textConfig(config) {
	    this.attribute.textConfig = config, this.addUpdateShapeAndBoundsTag();
	  }
	  getGraphicTheme() {
	    return getTheme(this).richtext;
	  }
	  static AllSingleCharacter(cache) {
	    if (cache.lines) {
	      return cache.lines.every(line => line.paragraphs.every(item => !(item.text && isString$1(item.text) && RichText.splitText(item.text).length > 1)));
	    }
	    return cache.every(item => item.isComposing || !(item.text && isString$1(item.text) && RichText.splitText(item.text).length > 1));
	  }
	  static splitText(text) {
	    if (supportIntl) {
	      const segmenter = new Intl.Segmenter(void 0, {
	          granularity: "grapheme"
	        }),
	        segments = [];
	      for (const {
	        segment: segment
	      } of segmenter.segment(text)) segments.push(segment);
	      return segments;
	    }
	    return Array.from(text);
	  }
	  static TransformTextConfig2SingleCharacter(textConfig) {
	    const tc = [];
	    return textConfig.forEach(item => {
	      const textList = RichText.splitText(item.text.toString());
	      if (isString$1(item.text) && textList.length > 1) for (let i = 0; i < textList.length; i++) {
	        const t = textList[i];
	        tc.push(Object.assign(Object.assign({}, item), {
	          text: t
	        }));
	      } else tc.push(item);
	    }), tc;
	  }
	  updateAABBBounds(attribute, richtextTheme, aabbBounds) {
	    var _a, _b, _c, _d;
	    const {
	      width = richtextTheme.width,
	      height = richtextTheme.height,
	      maxWidth = richtextTheme.maxWidth,
	      maxHeight = richtextTheme.maxHeight,
	      textAlign = richtextTheme.textAlign,
	      textBaseline = null !== (_b = null !== (_a = attribute.textBaseline) && void 0 !== _a ? _a : richtextTheme.textBaseline) && void 0 !== _b ? _b : "top",
	      editOptions: editOptions
	    } = attribute;
	    if (width > 0 && height > 0) aabbBounds.set(0, 0, width, height);else {
	      const frameCache = this.getFrameCache(),
	        {
	          width: actualWidth,
	          height: actualHeight
	        } = frameCache.getActualSize();
	      let contentWidth = width || actualWidth || 0,
	        contentHeight = height || actualHeight || 0;
	      contentHeight = "number" == typeof maxHeight && contentHeight > maxHeight ? maxHeight : contentHeight || 0, contentWidth = "number" == typeof maxWidth && contentWidth > maxWidth ? maxWidth : contentWidth || 0, aabbBounds.set(0, 0, contentWidth, contentHeight);
	    }
	    editOptions && editOptions.keepHeightWhileEmpty && !aabbBounds.height() && !(null === (_c = attribute.textConfig) || void 0 === _c ? void 0 : _c.length) && (aabbBounds.y2 = aabbBounds.y1 + (null !== (_d = attribute.fontSize) && void 0 !== _d ? _d : 12), aabbBounds.x2 = aabbBounds.x1 + 2);
	    let deltaY = 0;
	    switch (textBaseline) {
	      case "top":
	        deltaY = 0;
	        break;
	      case "middle":
	        deltaY = -aabbBounds.height() / 2;
	        break;
	      case "bottom":
	        deltaY = -aabbBounds.height();
	    }
	    let deltaX = 0;
	    switch (textAlign) {
	      case "left":
	        deltaX = 0;
	        break;
	      case "center":
	        deltaX = -aabbBounds.width() / 2;
	        break;
	      case "right":
	        deltaX = -aabbBounds.width();
	    }
	    return height || ("middle" === this.verticalDirection ? deltaY -= aabbBounds.height() / 2 : "bottom" === this.verticalDirection && (deltaY -= aabbBounds.height())), aabbBounds.translate(deltaX, deltaY), application.graphicService.updateTempAABBBounds(aabbBounds), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || application.graphicService.updateHTMLTextAABBBounds(attribute, richtextTheme, aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, richtextTheme, !1, this), 0 === aabbBounds.width() && 0 === aabbBounds.height() && aabbBounds.clear(), aabbBounds;
	  }
	  needUpdateTags(keys) {
	    return super.needUpdateTags(keys, RICHTEXT_UPDATE_TAG_KEY);
	  }
	  needUpdateTag(key) {
	    return super.needUpdateTag(key, RICHTEXT_UPDATE_TAG_KEY);
	  }
	  getFrameCache() {
	    return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), this._frameCache;
	  }
	  get cliped() {
	    const frameCache = this.getFrameCache();
	    if (frameCache.actualHeight > frameCache.height) return !0;
	    const {
	      disableAutoWrapLine: disableAutoWrapLine
	    } = this.attribute;
	    if (disableAutoWrapLine) for (let i = 0; i < frameCache.lines.length; i++) {
	      const l = frameCache.lines[i];
	      for (let j = 0; j < l.paragraphs.length; j++) {
	        const p = l.paragraphs[j];
	        if (p.overflow && "" !== p.text) return !0;
	      }
	    }
	    return !1;
	  }
	  combinedStyleToCharacter(config) {
	    const {
	        fill: fill,
	        stroke: stroke,
	        fontSize: fontSize,
	        fontFamily: fontFamily,
	        fontStyle: fontStyle,
	        fontWeight: fontWeight,
	        lineWidth: lineWidth,
	        opacity: opacity,
	        fillOpacity: fillOpacity,
	        lineHeight: lineHeight,
	        strokeOpacity: strokeOpacity,
	        upgradeAttrs: upgradeAttrs
	      } = this.attribute,
	      out = Object.assign({
	        fill: fill,
	        stroke: stroke,
	        fontSize: fontSize,
	        fontFamily: fontFamily,
	        fontStyle: fontStyle,
	        fontWeight: fontWeight,
	        lineWidth: lineWidth,
	        opacity: opacity,
	        fillOpacity: fillOpacity,
	        strokeOpacity: strokeOpacity
	      }, config);
	    return (null == upgradeAttrs ? void 0 : upgradeAttrs.lineHeight) && (out.lineHeight = lineHeight), out;
	  }
	  doUpdateFrameCache(tc) {
	    var _a;
	    const {
	        maxWidth: maxWidth,
	        maxHeight: maxHeight,
	        width: width,
	        height: height,
	        ellipsis: ellipsis,
	        wordBreak: wordBreak,
	        verticalDirection: verticalDirection,
	        textAlign: textAlign,
	        textBaseline: textBaseline,
	        layoutDirection: layoutDirection,
	        singleLine: singleLine,
	        disableAutoWrapLine: disableAutoWrapLine,
	        editable: editable,
	        ascentDescentMode: ascentDescentMode,
	        upgradeAttrs: upgradeAttrs
	      } = this.attribute,
	      enableMultiBreakLine = upgradeAttrs && upgradeAttrs.multiBreakLine;
	    let {
	      textConfig: _tc = []
	    } = this.attribute;
	    editable && _tc.length > 0 && !RichText.AllSingleCharacter(_tc) && (_tc = RichText.TransformTextConfig2SingleCharacter(_tc), this.attribute.textConfig = _tc);
	    const paragraphs = [],
	      textConfig = null != tc ? tc : _tc;
	    for (let i = 0; i < textConfig.length; i++) if ("image" in textConfig[i]) {
	      const config = this.combinedStyleToCharacter(textConfig[i]);
	      config.lineWidth = void 0;
	      const iconCache = config.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config.id);
	      if (iconCache) paragraphs.push(iconCache);else {
	        const icon = new RichTextIcon(config);
	        icon.successCallback = () => {
	          var _a;
	          this.addUpdateBoundTag(), null === (_a = this.stage) || void 0 === _a || _a.renderNextFrame();
	        }, icon.richtextId = config.id, paragraphs.push(icon);
	      }
	    } else {
	      const richTextConfig = this.combinedStyleToCharacter(textConfig[i]);
	      if (isNumber$1(richTextConfig.text) && (richTextConfig.text = `${richTextConfig.text}`), richTextConfig.text && richTextConfig.text.includes("\n")) {
	        const textParts = richTextConfig.text.split("\n");
	        for (let j = 0; j < textParts.length; j++) if (0 === j) paragraphs.push(new Paragraph(textParts[j], !1, richTextConfig, ascentDescentMode));else if (textParts[j] || i === textConfig.length - 1) paragraphs.push(new Paragraph(textParts[j], !0, richTextConfig, ascentDescentMode));else {
	          const nextRichTextConfig = this.combinedStyleToCharacter(textConfig[i + 1]);
	          paragraphs.push(new Paragraph(textParts[j], !0, nextRichTextConfig, ascentDescentMode));
	        }
	      } else richTextConfig.text && paragraphs.push(new Paragraph(richTextConfig.text, !1, richTextConfig, ascentDescentMode));
	    }
	    const maxWidthFinite = "number" == typeof maxWidth && Number.isFinite(maxWidth) && maxWidth > 0,
	      maxHeightFinite = "number" == typeof maxHeight && Number.isFinite(maxHeight) && maxHeight > 0,
	      richTextWidthEnable = "number" == typeof width && Number.isFinite(width) && width > 0 && (!maxWidthFinite || width <= maxWidth),
	      richTextHeightEnable = "number" == typeof height && Number.isFinite(height) && height > 0 && (!maxHeightFinite || height <= maxHeight),
	      frame = new Frame(0, 0, (richTextWidthEnable ? width : maxWidthFinite ? maxWidth : 0) || 0, (richTextHeightEnable ? height : maxHeightFinite ? maxHeight : 0) || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || "horizontal", !richTextWidthEnable && maxWidthFinite, !richTextHeightEnable && maxHeightFinite, singleLine || !1, null === (_a = this._frameCache) || void 0 === _a ? void 0 : _a.icons),
	      wrapper = new Wrapper(frame);
	    if (wrapper.newLine = enableMultiBreakLine, disableAutoWrapLine) {
	      let lineCount = 0,
	        skip = !1;
	      for (let i = 0; i < paragraphs.length; i++) {
	        const p = paragraphs[i];
	        skip ? (p.overflow = !0, p.left = 1 / 0, p.top = 1 / 0, !p.newLine && frame.lines[frame.lines.length - 1].paragraphs.push(p)) : wrapper.deal(p, !0), frame.lines.length !== lineCount && (lineCount = frame.lines.length, wrapper.lineBuffer.length = 0, p.overflow = !0, p.left = 1e3, p.top = 1e3, frame.lines[frame.lines.length - 1].paragraphs.push(p), skip = !0), p.newLine && (skip = !1, wrapper.lineWidth = 0), wrapper.send();
	      }
	    } else for (let i = 0; i < paragraphs.length; i++) wrapper.deal(paragraphs[i]);
	    wrapper.send();
	    if (!("horizontal" === frame.layoutDirection ? richTextWidthEnable : richTextHeightEnable)) {
	      const frameSize = frame.getActualSizeWidthEllipsis();
	      let offsetSize = "horizontal" === frame.layoutDirection ? frameSize.width : frameSize.height;
	      ("horizontal" === frame.layoutDirection ? maxWidthFinite : maxHeightFinite) && (offsetSize = Math.min(offsetSize, "horizontal" === frame.layoutDirection ? maxWidth : maxHeight)), frame.lines.forEach(function (l) {
	        l.calcOffset(offsetSize, !1);
	      });
	    }
	    enableMultiBreakLine && frame.lines.forEach(item => {
	      const lastParagraphs = item.paragraphs;
	      item.paragraphs = item.paragraphs.filter(p => "" !== p.text), 0 === item.paragraphs.length && lastParagraphs.length && (lastParagraphs[0].text = "\n", item.paragraphs.push(lastParagraphs[0]));
	    }), this._frameCache = frame;
	  }
	  clone() {
	    return new RichText(Object.assign({}, this.attribute));
	  }
	  setStage(stage, layer) {
	    super.setStage(stage, layer);
	    this.getFrameCache().icons.forEach(icon => {
	      icon.setStage(stage, layer);
	    });
	  }
	  bindIconEvent() {
	    this.addEventListener("pointermove", e => {
	      const pickedIcon = this.pickIcon(e.global);
	      pickedIcon && pickedIcon === this._currentHoverIcon || (pickedIcon ? this.setAttribute("hoverIconId", pickedIcon.richtextId) : !pickedIcon && this._currentHoverIcon && this.setAttribute("hoverIconId", void 0));
	    }), this.addEventListener("pointerleave", e => {
	      this._currentHoverIcon && this.setAttribute("hoverIconId", void 0);
	    });
	  }
	  updateHoverIconState(pickedIcon) {
	    var _a, _b, _c, _d, _e;
	    pickedIcon ? (null === (_a = this._currentHoverIcon) || void 0 === _a || _a.setHoverState(!1), this._currentHoverIcon = pickedIcon, this._currentHoverIcon.setHoverState(!0), null === (_b = this.stage) || void 0 === _b || _b.setCursor(pickedIcon.attribute.cursor), null === (_c = this.stage) || void 0 === _c || _c.renderNextFrame()) : (this._currentHoverIcon.setHoverState(!1), this._currentHoverIcon = null, null === (_d = this.stage) || void 0 === _d || _d.setCursor(), null === (_e = this.stage) || void 0 === _e || _e.renderNextFrame());
	  }
	  pickIcon(point) {
	    const frameCache = this.getFrameCache(),
	      {
	        e: x,
	        f: y
	      } = this.globalTransMatrix;
	    let pickIcon;
	    return frameCache.icons.forEach((icon, key) => {
	      var _a, _b;
	      const bounds = icon.AABBBounds.clone();
	      bounds.translate(icon._marginArray[3], icon._marginArray[0]), bounds.containsPoint({
	        x: point.x - x,
	        y: point.y - y
	      }) && (pickIcon = icon, pickIcon.globalX = (null !== (_a = pickIcon.attribute.x) && void 0 !== _a ? _a : 0) + x + icon._marginArray[3], pickIcon.globalY = (null !== (_b = pickIcon.attribute.y) && void 0 !== _b ? _b : 0) + y + icon._marginArray[0]);
	    }), pickIcon;
	  }
	  getNoWorkAnimateAttr() {
	    return RichText.NOWORK_ANIMATE_ATTR;
	  }
	}
	RichText.NOWORK_ANIMATE_ATTR = Object.assign({
	  ellipsis: 1,
	  wordBreak: 1,
	  verticalDirection: 1,
	  textAlign: 1,
	  textBaseline: 1,
	  textConfig: 1,
	  layoutDirection: 1
	}, NOWORK_ANIMATE_ATTR);
	function createRichText(attributes) {
	  return new RichText(attributes);
	}

	const PATH_UPDATE_TAG_KEY = ["path", "customPath", ...GRAPHIC_UPDATE_TAG_KEY];
	class Path extends Graphic {
	  constructor(params) {
	    super(params), this.type = "path", this.numberType = PATH_NUMBER_TYPE;
	  }
	  get pathShape() {
	    return this.tryUpdateAABBBounds(), this.getParsedPathShape();
	  }
	  isValid() {
	    return super.isValid() && this._isValid();
	  }
	  _isValid() {
	    const {
	      path: path
	    } = this.attribute;
	    return null != path && "" !== path;
	  }
	  getParsedPathShape() {
	    const pathTheme = this.getGraphicTheme();
	    if (!this.valid) return pathTheme.path;
	    const attribute = this.attribute;
	    return attribute.path instanceof CustomPath2D ? attribute.path : (isNil$1(this.cache) && this.doUpdatePathShape(), this.cache instanceof CustomPath2D ? this.cache : pathTheme.path);
	  }
	  getGraphicTheme() {
	    return getTheme(this).path;
	  }
	  updateAABBBounds(attribute, pathTheme, aabbBounds) {
	    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
	      const pathShape = this.getParsedPathShape();
	      aabbBounds.union(pathShape.getBounds());
	    }
	    const {
	      tb1: tb1,
	      tb2: tb2
	    } = application.graphicService.updateTempAABBBounds(aabbBounds);
	    updateBoundsOfCommonOuterBorder(attribute, pathTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
	    const {
	      lineJoin = pathTheme.lineJoin
	    } = attribute;
	    return application.graphicService.transformAABBBounds(attribute, aabbBounds, pathTheme, "miter" === lineJoin, this), aabbBounds;
	  }
	  doUpdateAABBBounds(full) {
	    return this.doUpdatePathShape(), super.doUpdateAABBBounds(full);
	  }
	  doUpdatePathShape() {
	    const attribute = this.attribute;
	    isString$1(attribute.path, !0) ? this.cache = new CustomPath2D().fromString(attribute.path) : attribute.customPath && (this.cache = new CustomPath2D(), attribute.customPath(this.cache, this));
	  }
	  needUpdateTags(keys) {
	    return super.needUpdateTags(keys, PATH_UPDATE_TAG_KEY);
	  }
	  needUpdateTag(key) {
	    return super.needUpdateTag(key, PATH_UPDATE_TAG_KEY);
	  }
	  toCustomPath() {
	    return new CustomPath2D().fromCustomPath2D(this.getParsedPathShape(), 0, 0);
	  }
	  clone() {
	    return new Path(Object.assign({}, this.attribute));
	  }
	  getNoWorkAnimateAttr() {
	    return Path.NOWORK_ANIMATE_ATTR;
	  }
	}
	Path.NOWORK_ANIMATE_ATTR = Object.assign({
	  path: 1,
	  customPath: 1
	}, NOWORK_ANIMATE_ATTR);
	function createPath(attributes) {
	  return new Path(attributes);
	}

	const AREA_UPDATE_TAG_KEY = ["segments", "points", "curveType", "curveTension", ...GRAPHIC_UPDATE_TAG_KEY];
	class Area extends Graphic {
	  constructor(params) {
	    super(params), this.type = "area", this.numberType = AREA_NUMBER_TYPE;
	  }
	  isValid() {
	    return super.isValid() && this._isValid();
	  }
	  _isValid() {
	    if (this.pathProxy) return !0;
	    const {
	      points: points,
	      segments: segments
	    } = this.attribute;
	    return segments ? 0 !== segments.length : !!points && 0 !== points.length;
	  }
	  getGraphicTheme() {
	    return getTheme(this).area;
	  }
	  updateAABBBounds(attribute, areaTheme, aabbBounds) {
	    this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds) : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds)), application.graphicService.updateTempAABBBounds(aabbBounds), this.setWidthHeightWithoutTransform(aabbBounds);
	    const {
	      lineJoin = areaTheme.lineJoin
	    } = attribute;
	    return application.graphicService.transformAABBBounds(attribute, aabbBounds, areaTheme, "miter" === lineJoin, this), aabbBounds;
	  }
	  updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
	    const {
	        points = areaTheme.points
	      } = attribute,
	      b = aabbBounds;
	    return points.forEach(p => {
	      var _a, _b;
	      b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
	    }), b;
	  }
	  updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
	    const {
	        segments = areaTheme.segments
	      } = attribute,
	      b = aabbBounds;
	    return segments.forEach(s => {
	      s.points.forEach(p => {
	        var _a, _b;
	        b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
	      });
	    }), b;
	  }
	  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
	    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
	  }
	  needUpdateTags(keys) {
	    return super.needUpdateTags(keys, AREA_UPDATE_TAG_KEY);
	  }
	  needUpdateTag(key) {
	    return super.needUpdateTag(key, AREA_UPDATE_TAG_KEY);
	  }
	  toCustomPath() {
	    let path = super.toCustomPath();
	    if (path) return path;
	    path = new CustomPath2D();
	    const attribute = this.attribute,
	      segments = attribute.segments,
	      parsePoints = points => {
	        if (points && points.length) {
	          let isFirst = !0;
	          const basePoints = [];
	          if (points.forEach(point => {
	            var _a, _b;
	            !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), basePoints.push({
	              x: null !== (_a = point.x1) && void 0 !== _a ? _a : point.x,
	              y: null !== (_b = point.y1) && void 0 !== _b ? _b : point.y
	            }), isFirst = !1);
	          }), basePoints.length) {
	            for (let i = basePoints.length - 1; i >= 0; i--) path.lineTo(basePoints[i].x, basePoints[i].y);
	            path.closePath();
	          }
	        }
	      };
	    return attribute.points ? parsePoints(attribute.points) : segments && segments.length && segments.forEach(seg => {
	      parsePoints(seg.points);
	    }), path;
	  }
	  clone() {
	    return new Area(Object.assign({}, this.attribute));
	  }
	  getNoWorkAnimateAttr() {
	    return Area.NOWORK_ANIMATE_ATTR;
	  }
	}
	Area.NOWORK_ANIMATE_ATTR = Object.assign({
	  segments: 1,
	  curveType: 1
	}, NOWORK_ANIMATE_ATTR);
	function createArea(attributes) {
	  return new Area(attributes);
	}

	const ARC_UPDATE_TAG_KEY = ["innerRadius", "outerRadius", "startAngle", "endAngle", "cornerRadius", "padAngle", "padRadius", "cap", ...GRAPHIC_UPDATE_TAG_KEY];
	class Arc extends Graphic {
	  constructor(params) {
	    super(params), this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
	  }
	  isValid() {
	    return super.isValid() && this._isValid();
	  }
	  _isValid() {
	    const {
	      startAngle: startAngle,
	      endAngle: endAngle,
	      outerRadius: outerRadius,
	      innerRadius: innerRadius
	    } = this.attribute;
	    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(outerRadius) && this._validNumber(innerRadius);
	  }
	  getParsedCornerRadius() {
	    const arcTheme = this.getGraphicTheme(),
	      {
	        cornerRadius = arcTheme.cornerRadius,
	        innerPadding = arcTheme.innerPadding,
	        outerPadding = arcTheme.outerPadding
	      } = this.attribute;
	    let {
	      outerRadius = arcTheme.outerRadius,
	      innerRadius = arcTheme.innerRadius
	    } = this.attribute;
	    if (outerRadius += outerPadding, innerRadius -= innerPadding, 0 === cornerRadius || "0%" === cornerRadius) return 0;
	    const deltaRadius = Math.abs(outerRadius - innerRadius),
	      parseCR = cornerRadius => Math.min(isNumber$1(cornerRadius, !0) ? cornerRadius : deltaRadius * parseFloat(cornerRadius) / 100, deltaRadius / 2);
	    if (isArray$1(cornerRadius)) {
	      const crList = cornerRadius.map(cr => parseCR(cr) || 0);
	      return 0 === crList.length ? [crList[0], crList[0], crList[0], crList[0]] : 2 === crList.length ? [crList[0], crList[1], crList[0], crList[1]] : (3 === crList.length && crList.push(0), crList);
	    }
	    return parseCR(cornerRadius);
	  }
	  getParsedAngle() {
	    const arcTheme = this.getGraphicTheme();
	    let {
	      startAngle = arcTheme.startAngle,
	      endAngle = arcTheme.endAngle
	    } = this.attribute;
	    const {
	        cap = arcTheme.cap
	      } = this.attribute,
	      sign = endAngle - startAngle >= 0 ? 1 : -1,
	      deltaAngle = endAngle - startAngle;
	    if (startAngle = clampAngleByRadian(startAngle), endAngle = startAngle + deltaAngle, cap && abs(deltaAngle) < pi2 - epsilon) {
	      let startCap = 1,
	        endCap = 1;
	      cap.length && (startCap = Number(cap[0]), endCap = Number(cap[1]));
	      let {
	        outerRadius = arcTheme.outerRadius,
	        innerRadius = arcTheme.innerRadius
	      } = this.attribute;
	      const {
	        outerPadding = arcTheme.outerPadding,
	        innerPadding = arcTheme.innerPadding
	      } = this.attribute;
	      outerRadius += outerPadding, innerRadius -= innerPadding;
	      const capWidth = Math.abs(outerRadius - innerRadius) / 2,
	        capAngle = capWidth / outerRadius;
	      if (capWidth > epsilon && outerRadius > epsilon) return {
	        startAngle: startAngle - sign * capAngle * startCap,
	        endAngle: endAngle + sign * capAngle * endCap,
	        sc: sign * capAngle * startCap,
	        ec: sign * capAngle * endCap
	      };
	    }
	    return {
	      startAngle: startAngle,
	      endAngle: endAngle
	    };
	  }
	  getParsePadAngle(startAngle, endAngle) {
	    const arcTheme = this.getGraphicTheme(),
	      {
	        innerPadding = arcTheme.innerPadding,
	        outerPadding = arcTheme.outerPadding,
	        padAngle = arcTheme.padAngle
	      } = this.attribute;
	    let {
	      outerRadius = arcTheme.outerRadius,
	      innerRadius = arcTheme.innerRadius
	    } = this.attribute;
	    outerRadius += outerPadding, innerRadius -= innerPadding;
	    const {
	        padRadius = sqrt$1(outerRadius * outerRadius + innerRadius * innerRadius)
	      } = this.attribute,
	      deltaAngle = abs(endAngle - startAngle);
	    let outerStartAngle = startAngle,
	      outerEndAngle = endAngle,
	      innerStartAngle = startAngle,
	      innerEndAngle = endAngle;
	    const halfPadAngle = padAngle / 2;
	    let innerDeltaAngle = deltaAngle,
	      outerDeltaAngle = deltaAngle;
	    if (halfPadAngle > epsilon && padRadius > epsilon) {
	      const sign = endAngle > startAngle ? 1 : -1;
	      let p0 = asin(Number(padRadius) / innerRadius * sin(halfPadAngle)),
	        p1 = asin(Number(padRadius) / outerRadius * sin(halfPadAngle));
	      return (innerDeltaAngle -= 2 * p0) > epsilon ? (p0 *= sign, innerStartAngle += p0, innerEndAngle -= p0) : (innerDeltaAngle = 0, innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2), (outerDeltaAngle -= 2 * p1) > epsilon ? (p1 *= sign, outerStartAngle += p1, outerEndAngle -= p1) : (outerDeltaAngle = 0, outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2), {
	        outerStartAngle: outerStartAngle,
	        outerEndAngle: outerEndAngle,
	        innerStartAngle: innerStartAngle,
	        innerEndAngle: innerEndAngle,
	        innerDeltaAngle: innerDeltaAngle,
	        outerDeltaAngle: outerDeltaAngle
	      };
	    }
	    return {
	      outerStartAngle: outerStartAngle,
	      outerEndAngle: outerEndAngle,
	      innerStartAngle: innerStartAngle,
	      innerEndAngle: innerEndAngle,
	      innerDeltaAngle: innerDeltaAngle,
	      outerDeltaAngle: outerDeltaAngle
	    };
	  }
	  getGraphicTheme() {
	    return getTheme(this).arc;
	  }
	  updateAABBBounds(attribute, arcTheme, aabbBounds, full) {
	    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds));
	    const {
	      tb1: tb1,
	      tb2: tb2
	    } = application.graphicService.updateTempAABBBounds(aabbBounds);
	    updateBoundsOfCommonOuterBorder(attribute, arcTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.setWidthHeightWithoutTransform(aabbBounds);
	    const {
	      lineJoin = arcTheme.lineJoin
	    } = attribute;
	    return application.graphicService.transformAABBBounds(attribute, aabbBounds, arcTheme, "miter" === lineJoin, this), aabbBounds;
	  }
	  updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) {
	    let {
	      outerRadius = arcTheme.outerRadius,
	      innerRadius = arcTheme.innerRadius
	    } = attribute;
	    const {
	      outerPadding = arcTheme.outerPadding,
	      innerPadding = arcTheme.innerPadding
	    } = attribute;
	    return outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius && (outerRadius = innerRadius), aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius), aabbBounds;
	  }
	  updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds) {
	    let {
	      outerRadius = arcTheme.outerRadius,
	      innerRadius = arcTheme.innerRadius
	    } = attribute;
	    const {
	      outerPadding = arcTheme.outerPadding,
	      innerPadding = arcTheme.innerPadding
	    } = attribute;
	    if (outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius) {
	      const temp = outerRadius;
	      outerRadius = innerRadius, innerRadius = temp;
	    }
	    let {
	      endAngle = arcTheme.endAngle,
	      startAngle = arcTheme.startAngle
	    } = attribute;
	    if (startAngle > endAngle) {
	      const temp = startAngle;
	      startAngle = endAngle, endAngle = temp;
	    }
	    return outerRadius <= epsilon ? aabbBounds.set(0, 0, 0, 0) : Math.abs(endAngle - startAngle) > pi2 - epsilon ? aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius) : (circleBounds(startAngle, endAngle, outerRadius, aabbBounds), circleBounds(startAngle, endAngle, innerRadius, aabbBounds)), aabbBounds;
	  }
	  needUpdateTags(keys) {
	    return super.needUpdateTags(keys, ARC_UPDATE_TAG_KEY);
	  }
	  needUpdateTag(key) {
	    return super.needUpdateTag(key, ARC_UPDATE_TAG_KEY);
	  }
	  toCustomPath() {
	    var _a, _b, _c, _d;
	    let path = super.toCustomPath();
	    if (path) return path;
	    const attribute = this.attribute,
	      {
	        startAngle: startAngle,
	        endAngle: endAngle
	      } = this.getParsedAngle();
	    let innerRadius = (null !== (_a = attribute.innerRadius) && void 0 !== _a ? _a : 0) - (null !== (_b = attribute.innerPadding) && void 0 !== _b ? _b : 0),
	      outerRadius = (null !== (_c = attribute.outerRadius) && void 0 !== _c ? _c : 0) - (null !== (_d = attribute.outerPadding) && void 0 !== _d ? _d : 0);
	    const deltaAngle = abs(endAngle - startAngle),
	      clockwise = endAngle > startAngle;
	    if (outerRadius < innerRadius) {
	      const temp = outerRadius;
	      outerRadius = innerRadius, innerRadius = temp;
	    }
	    if (path = new CustomPath2D(), outerRadius <= epsilon) path.moveTo(0, 0);else if (deltaAngle >= pi2 - epsilon) path.moveTo(0 + outerRadius * cos(startAngle), 0 + outerRadius * sin(startAngle)), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (path.moveTo(0 + innerRadius * cos(endAngle), 0 + innerRadius * sin(endAngle)), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise));else {
	      const xors = outerRadius * cos(startAngle),
	        yors = outerRadius * sin(startAngle),
	        xire = innerRadius * cos(endAngle),
	        yire = innerRadius * sin(endAngle);
	      path.moveTo(0 + xors, 0 + yors), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), path.lineTo(0 + xire, 0 + yire), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise), path.closePath();
	    }
	    return path;
	  }
	  clone() {
	    return new Arc(Object.assign({}, this.attribute));
	  }
	  getNoWorkAnimateAttr() {
	    return Arc.NOWORK_ANIMATE_ATTR;
	  }
	}
	Arc.NOWORK_ANIMATE_ATTR = Object.assign({
	  cap: 1
	}, NOWORK_ANIMATE_ATTR);
	function createArc(attributes) {
	  return new Arc(attributes);
	}

	class Arc3d extends Arc {
	  constructor(params) {
	    super(params), this.type = "arc3d", this.numberType = ARC3D_NUMBER_TYPE;
	  }
	  updateAABBBounds(attribute, arcTheme, aabbBounds) {
	    const stage = this.stage;
	    if (!stage || !stage.camera) return aabbBounds;
	    const {
	        outerRadius = arcTheme.outerRadius,
	        height = 0
	      } = attribute,
	      r = outerRadius + height;
	    return aabbBounds.setValue(-r, -r, r, r), application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, arcTheme, !1, this), aabbBounds;
	  }
	  getNoWorkAnimateAttr() {
	    return Arc3d.NOWORK_ANIMATE_ATTR;
	  }
	}
	Arc3d.NOWORK_ANIMATE_ATTR = Object.assign({
	  cap: 1
	}, NOWORK_ANIMATE_ATTR);
	function createArc3d(attributes) {
	  return new Arc3d(attributes);
	}

	const POLYGON_UPDATE_TAG_KEY = ["points", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
	class Polygon extends Graphic {
	  constructor(params) {
	    super(params), this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
	  }
	  isValid() {
	    return super.isValid() && this._isValid();
	  }
	  _isValid() {
	    const {
	      points: points
	    } = this.attribute;
	    return points && points.length >= 2;
	  }
	  getGraphicTheme() {
	    return getTheme(this).polygon;
	  }
	  updateAABBBounds(attribute, polygonTheme, aabbBounds) {
	    this.updatePathProxyAABBBounds(aabbBounds) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds), application.graphicService.updateTempAABBBounds(aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
	    const {
	      lineJoin = polygonTheme.lineJoin
	    } = attribute;
	    return application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, "miter" === lineJoin, this), aabbBounds;
	  }
	  updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds) {
	    const {
	      points = polygonTheme.points
	    } = attribute;
	    return points.forEach(p => {
	      aabbBounds.add(p.x, p.y);
	    }), aabbBounds;
	  }
	  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
	    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
	  }
	  needUpdateTags(keys) {
	    return super.needUpdateTags(keys, POLYGON_UPDATE_TAG_KEY);
	  }
	  needUpdateTag(key) {
	    return super.needUpdateTag(key, POLYGON_UPDATE_TAG_KEY);
	  }
	  toCustomPath() {
	    let path = super.toCustomPath();
	    if (path) return path;
	    const points = this.attribute.points;
	    return path = new CustomPath2D(), points.forEach((point, index) => {
	      0 === index ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y);
	    }), path.closePath(), path;
	  }
	  clone() {
	    return new Polygon(Object.assign({}, this.attribute));
	  }
	  getNoWorkAnimateAttr() {
	    return Polygon.NOWORK_ANIMATE_ATTR;
	  }
	}
	Polygon.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
	function createPolygon(attributes) {
	  return new Polygon(attributes);
	}

	class Pyramid3d extends Polygon {
	  constructor(params) {
	    super(params), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
	  }
	  updateAABBBounds(attribute, polygonTheme, aabbBounds) {
	    const stage = this.stage;
	    if (!stage || !stage.camera) return aabbBounds;
	    return this.findFace().vertices.forEach(v => {
	      const x = v[0],
	        y = v[1];
	      aabbBounds.add(x, y);
	    }), application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, !1, this), aabbBounds;
	  }
	  findFace() {
	    const {
	        points: points
	      } = this.attribute,
	      kList = points.map((p, i) => {
	        const p1 = 3 === i ? points[0] : points[i + 1],
	          dx = p.x - p1.x;
	        return 0 === dx ? 0 : (p.y - p1.y) / dx;
	      }),
	      pointsMap = points.map(p => ({
	        p: p,
	        d: 0
	      }));
	    let find = !1,
	      maxD = 0;
	    for (let i = 0; i < kList.length - 1; i++) {
	      for (let j = i + 1; j < kList.length; j++) {
	        if (kList[i] === kList[j]) {
	          find = !0;
	          const d1 = PointService.distancePP(pointsMap[i].p, pointsMap[i + 1].p);
	          pointsMap[i].d = d1, pointsMap[i + 1].d = d1, maxD = max(maxD, d1);
	          const d2 = PointService.distancePP(pointsMap[j].p, pointsMap[j + 1].p);
	          pointsMap[j].d = d2, pointsMap[j + 1].d = d2, maxD = max(maxD, d2);
	        }
	        if (find) break;
	      }
	      if (find) break;
	    }
	    for (let i = points.length - 1; i >= 0; i--) {
	      const p = points[i];
	      pointsMap.unshift({
	        p: p,
	        d: 0
	      });
	    }
	    for (let i = 0; i < points.length; i++) {
	      const delta = (maxD - pointsMap[i + points.length].d) / 2;
	      pointsMap[i].d += delta, pointsMap[i + points.length].d += delta;
	    }
	    const faces = {
	      polygons: [],
	      vertices: [],
	      edges: []
	    };
	    return pointsMap.forEach(p => {
	      faces.vertices.push([p.p.x, p.p.y, p.d]);
	    }), faces.polygons.push({
	      polygon: [0, 4, 5, 1],
	      normal: [0, -1, 0]
	    }), faces.polygons.push({
	      polygon: [7, 6, 2, 3],
	      normal: [0, 1, 0]
	    }), faces.polygons.push({
	      polygon: [0, 4, 7, 3],
	      normal: [-1, 0, 0]
	    }), faces.polygons.push({
	      polygon: [1, 5, 6, 2],
	      normal: [1, 0, 0]
	    }), faces.polygons.push({
	      polygon: [0, 1, 2, 3],
	      normal: [0, 0, -1]
	    }), faces.polygons.push({
	      polygon: [4, 5, 6, 7],
	      normal: [0, 0, 1]
	    }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
	  }
	  _isValid() {
	    return super._isValid() && 4 === this.attribute.points.length;
	  }
	  getNoWorkAnimateAttr() {
	    return Pyramid3d.NOWORK_ANIMATE_ATTR;
	  }
	}
	Pyramid3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
	function createPyramid3d(attributes) {
	  return new Pyramid3d(attributes);
	}

	class ShadowRoot extends Group {
	  constructor(graphic) {
	    super({
	      x: 0,
	      y: 0
	    }), this.type = "shadowroot", this.shadowHost = graphic;
	  }
	  clearUpdateBoundTag() {
	    super.clearUpdateBoundTag(), this.shadowHost && this.shadowHost.clearUpdateBoundTag();
	  }
	  addUpdateBoundTag() {
	    super.addUpdateBoundTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
	  }
	  addUpdateShapeAndBoundsTag() {
	    super.addUpdateShapeAndBoundsTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
	  }
	  tryUpdateGlobalTransMatrix(clearTag = !0) {
	    if (this.shouldUpdateGlobalMatrix()) {
	      const m = this.transMatrix;
	      this._globalTransMatrix ? this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f) : this._globalTransMatrix = m.clone(), this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
	    }
	    return this._globalTransMatrix;
	  }
	  doUpdateGlobalMatrix() {
	    if (this.shadowHost) {
	      const parentMatrix = this.shadowHost.globalTransMatrix;
	      this._globalTransMatrix.multiply(parentMatrix.a, parentMatrix.b, parentMatrix.c, parentMatrix.d, parentMatrix.e, parentMatrix.f);
	    }
	  }
	  tryUpdateGlobalAABBBounds() {
	    return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this._AABBBounds.clone(), this.shadowHost && this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix), this._globalAABBBounds;
	  }
	}
	function createShadowRoot(graphic) {
	  return new ShadowRoot(graphic);
	}

	class GraphicCreator {
	  constructor() {
	    this.store = new Map();
	  }
	  RegisterGraphicCreator(name, cb) {
	    this.store.set(name, cb), this[name] = cb;
	  }
	  CreateGraphic(name, params) {
	    const cb = this.store.get(name);
	    return cb ? cb(params) : null;
	  }
	}
	const graphicCreator = new GraphicCreator();

	let text;
	function getTextBounds(params) {
	  return text || (text = graphicCreator.CreateGraphic("text", {})), text.initAttributes(params), text.AABBBounds;
	}

	var __decorate$v = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$n = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$m = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	class DefaultBaseBackgroundRenderContribution {
	  constructor() {
	    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
	  }
	  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
	    var _a;
	    const {
	      background: background,
	      backgroundOpacity = null !== (_a = graphic.attribute.fillOpacity) && void 0 !== _a ? _a : graphicAttribute.backgroundOpacity,
	      opacity = graphicAttribute.opacity,
	      backgroundMode = graphicAttribute.backgroundMode,
	      backgroundFit = graphicAttribute.backgroundFit,
	      backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio,
	      backgroundScale = graphicAttribute.backgroundScale,
	      backgroundOffsetX = graphicAttribute.backgroundOffsetX,
	      backgroundOffsetY = graphicAttribute.backgroundOffsetY,
	      backgroundClip = graphicAttribute.backgroundClip
	    } = graphic.attribute;
	    if (background) if (graphic.backgroundImg && graphic.resources) {
	      const res = graphic.resources.get(background);
	      if ("success" !== res.state || !res.data) return;
	      if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
	        const groupAttribute = getTheme(graphic.parent).group,
	          {
	            scrollX = groupAttribute.scrollX,
	            scrollY = groupAttribute.scrollY
	          } = graphic.parent.attribute;
	        context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);
	      }
	      backgroundClip && context.clip();
	      const b = graphic.AABBBounds;
	      context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, this.doDrawImage(context, res.data, b, {
	        backgroundMode: backgroundMode,
	        backgroundFit: backgroundFit,
	        backgroundKeepAspectRatio: backgroundKeepAspectRatio,
	        backgroundScale: backgroundScale,
	        backgroundOffsetX: backgroundOffsetX,
	        backgroundOffsetY: backgroundOffsetY
	      }), context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
	    } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, context.fillStyle = background, context.fill(), context.highPerformanceRestore();
	  }
	  doDrawImage(context, data, b, params) {
	    const {
	        backgroundMode: backgroundMode,
	        backgroundFit: backgroundFit,
	        backgroundKeepAspectRatio: backgroundKeepAspectRatio,
	        backgroundScale = 1,
	        backgroundOffsetX = 0,
	        backgroundOffsetY = 0
	      } = params,
	      targetW = b.width(),
	      targetH = b.height();
	    let w = targetW,
	      h = targetH;
	    if ("no-repeat" === backgroundMode) {
	      if (backgroundFit) {
	        if (backgroundKeepAspectRatio) {
	          const maxScale = Math.max(targetW / data.width, targetH / data.height);
	          context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, data.width * maxScale * backgroundScale, data.height * maxScale * backgroundScale);
	        } else context.drawImage(data, b.x1, b.y1, b.width(), b.height());
	      } else {
	        const resW = data.width * backgroundScale,
	          resH = data.height * backgroundScale;
	        context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, resW, resH);
	      }
	    } else {
	      if (backgroundFit && "repeat" !== backgroundMode && (data.width || data.height)) {
	        const resW = data.width,
	          resH = data.height;
	        if ("repeat-x" === backgroundMode) {
	          w = resW * (targetH / resH), h = targetH;
	        } else if ("repeat-y" === backgroundMode) {
	          h = resH * (targetW / resW), w = targetW;
	        }
	        const dpr = context.dpr,
	          canvas = canvasAllocate.allocate({
	            width: w,
	            height: h,
	            dpr: dpr
	          }),
	          ctx = canvas.getContext("2d");
	        ctx && (ctx.inuse = !0, ctx.clearMatrix(), ctx.setTransformForCurrent(!0), ctx.clearRect(0, 0, w, h), ctx.drawImage(data, 0, 0, w, h), data = canvas.nativeCanvas), canvasAllocate.free(canvas);
	      }
	      const dpr = context.dpr,
	        pattern = context.createPattern(data, backgroundMode);
	      pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), context.fillStyle = pattern, context.translate(b.x1, b.y1), context.fillRect(0, 0, targetW, targetH), context.translate(-b.x1, -b.y1);
	    }
	  }
	}
	const defaultBaseBackgroundRenderContribution = new DefaultBaseBackgroundRenderContribution();
	let DefaultBaseInteractiveRenderContribution = class {
	  constructor(subRenderContribitions) {
	    this.subRenderContribitions = subRenderContribitions, this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
	  }
	  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
	    this._subRenderContribitions || (this._subRenderContribitions = this.subRenderContribitions.getContributions()), this._subRenderContribitions.forEach(c => {
	      c.render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options);
	    });
	  }
	};
	DefaultBaseInteractiveRenderContribution = __decorate$v([injectable(), __param$m(0, inject(ContributionProvider)), __param$m(0, named(InteractiveSubRenderContribution)), __metadata$n("design:paramtypes", [Object])], DefaultBaseInteractiveRenderContribution);
	class DefaultBaseClipRenderBeforeContribution {
	  constructor() {
	    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
	  }
	  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
	    var _a, _b;
	    const {
	      clipConfig: clipConfig
	    } = graphic.attribute;
	    if (!clipConfig) return;
	    const clipPath = graphic.getClipPath();
	    if (!clipPath) return;
	    const draw = !(fillCb || strokeCb),
	      b = graphic.AABBBounds,
	      width = null !== (_a = graphic.attribute.width) && void 0 !== _a ? _a : b.width(),
	      height = null !== (_b = graphic.attribute.height) && void 0 !== _b ? _b : b.height();
	    draw && context.save(), context.beginPath(), !1 === clipPath.draw(context, [width, height], x + width / 2, y + height / 2, 0) && context.closePath(), fillCb && fillCb(context, graphic.attribute, graphicAttribute, !0), draw && context.clip();
	  }
	}
	const defaultBaseClipRenderBeforeContribution = new DefaultBaseClipRenderBeforeContribution();
	class DefaultBaseClipRenderAfterContribution {
	  constructor() {
	    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
	  }
	  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
	    const {
	      clipConfig: clipConfig
	    } = graphic.attribute;
	    if (!clipConfig) return;
	    graphic.getClipPath() && (fillCb || strokeCb || context.restore());
	  }
	}
	const defaultBaseClipRenderAfterContribution = new DefaultBaseClipRenderAfterContribution();

	function formatRatio(ratio) {
	  return ratio <= .5 ? 4 * ratio - 1 : -4 * ratio + 3;
	}
	function drawWave(ctx, ratio, boundsWidth, boundsHeight, textureOptions, offsetX, offsetY) {
	  const {
	    fill = "orange",
	    percent = .6,
	    frequency = 4,
	    opacity: opacity,
	    phi = 0
	  } = textureOptions;
	  let {
	    amplitude = 10
	  } = textureOptions;
	  amplitude *= formatRatio(ratio);
	  const height = boundsHeight * (1 - percent),
	    width = boundsWidth,
	    step = Math.max(Math.round(width / 70), 2);
	  ctx.beginPath(), ctx.moveTo(0 + offsetX, boundsHeight + offsetY), ctx.lineTo(0 + offsetX, height + offsetY);
	  const delta = width / frequency * ratio,
	    c = width / Math.PI / (2 * frequency);
	  for (let i = 0; i < width; i += step) {
	    const y = amplitude * Math.sin((i + delta + phi) / c + phi);
	    ctx.lineTo(i + offsetX, height + y + offsetY);
	  }
	  ctx.lineTo(width + offsetX, boundsHeight + offsetY), ctx.closePath(), ctx.fillStyle = fill, isFinite(opacity) && (ctx.globalAlpha = opacity), ctx.fill();
	}
	class DefaultBaseTextureRenderContribution {
	  constructor() {
	    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 10, this._tempSymbolGraphic = null;
	  }
	  createCommonPattern(size, padding, color, targetContext, cb) {
	    const r = (size - 2 * padding) / 2,
	      dpr = targetContext.dpr,
	      canvas = canvasAllocate.allocate({
	        width: size,
	        height: size,
	        dpr: dpr
	      }),
	      ctx = canvas.getContext("2d");
	    if (!ctx) return null;
	    ctx.inuse = !0, ctx.clearMatrix(), ctx.setTransformForCurrent(!0), ctx.clearRect(0, 0, size, size), cb(r, ctx);
	    const pattern = targetContext.createPattern(canvas.nativeCanvas, "repeat");
	    return pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), canvasAllocate.free(canvas), pattern;
	  }
	  createCirclePattern(size, padding, color, targetContext) {
	    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
	      ctx.fillStyle = color, ctx.arc(r, r, r, 0, pi2), ctx.fill();
	    });
	  }
	  createDiamondPattern(size, padding, color, targetContext) {
	    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
	      const x = size / 2,
	        y = x;
	      ctx.fillStyle = color, ctx.moveTo(x, y - r), ctx.lineTo(r + x, y), ctx.lineTo(x, y + r), ctx.lineTo(x - r, y), ctx.closePath(), ctx.fill();
	    });
	  }
	  createRectPattern(size, padding, color, targetContext) {
	    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
	      const x = padding,
	        y = x;
	      ctx.fillStyle = color, ctx.fillRect(x, y, 2 * r, 2 * r);
	    });
	  }
	  createVerticalLinePattern(size, padding, color, targetContext) {
	    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
	      const x = padding;
	      ctx.fillStyle = color, ctx.fillRect(x, 0, 2 * r, size);
	    });
	  }
	  createHorizontalLinePattern(size, padding, color, targetContext) {
	    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
	      const y = padding;
	      ctx.fillStyle = color, ctx.fillRect(0, y, size, 2 * r);
	    });
	  }
	  createBiasLRLinePattern(size, padding, color, targetContext) {
	    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
	      ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(0, 0), ctx.lineTo(size, size);
	      const dx = size / 2,
	        dy = -dx;
	      ctx.moveTo(dx, dy), ctx.lineTo(dx + size, dy + size), ctx.moveTo(-dx, -dy), ctx.lineTo(-dx + size, -dy + size), ctx.stroke();
	    });
	  }
	  createBiasRLLinePattern(size, padding, color, targetContext) {
	    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
	      ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(size, 0), ctx.lineTo(0, size);
	      const dx = size / 2,
	        dy = dx;
	      ctx.moveTo(size + dx, dy), ctx.lineTo(dx, dy + size), ctx.moveTo(size - dx, -dy), ctx.lineTo(-dx, -dy + size), ctx.stroke();
	    });
	  }
	  createGridPattern(size, padding, color, targetContext) {
	    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
	      const x = padding,
	        y = x;
	      ctx.fillStyle = color, ctx.fillRect(x, y, r, r), ctx.fillRect(x + r, y + r, r, r);
	    });
	  }
	  initTextureMap(ctx, stage) {
	    this.textureMap = new Map();
	  }
	  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
	    this.textureMap || this.initTextureMap(context, graphic.stage);
	    const {
	      texture = graphicAttribute.texture,
	      textureColor = graphicAttribute.textureColor,
	      textureSize = graphicAttribute.textureSize,
	      texturePadding = graphicAttribute.texturePadding
	    } = graphic.attribute;
	    texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
	  }
	  drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding) {
	    var _a;
	    const {
	      textureRatio = graphicAttribute.textureRatio,
	      textureOptions = null
	    } = graphic.attribute;
	    let pattern = this.textureMap.get(texture);
	    if (!pattern) switch (texture) {
	      case "circle":
	        pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
	        break;
	      case "diamond":
	        pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
	        break;
	      case "rect":
	        pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
	        break;
	      case "vertical-line":
	        pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
	        break;
	      case "horizontal-line":
	        pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
	        break;
	      case "bias-lr":
	        pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
	        break;
	      case "bias-rl":
	        pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
	        break;
	      case "grid":
	        pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
	    }
	    if (textureOptions && textureOptions.dynamicTexture) {
	      const {
	          gridConfig = {},
	          useNewCanvas: useNewCanvas
	        } = textureOptions,
	        b = graphic.AABBBounds;
	      x = b.x1, y = b.y1;
	      const originalContext = context;
	      let newCanvas;
	      if (useNewCanvas) {
	        newCanvas = canvasAllocate.allocate({
	          width: b.width(),
	          height: b.height(),
	          dpr: context.dpr
	        });
	        const ctx = newCanvas.getContext("2d");
	        ctx.clearRect(0, 0, b.width(), b.height()), x = 0, y = 0, context = ctx;
	      }
	      if (originalContext.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
	        const {
	          scrollX = 0,
	          scrollY = 0
	        } = graphic.parent.attribute;
	        originalContext.setTransformFromMatrix(graphic.parent.globalTransMatrix), originalContext.translate(scrollX, scrollY, !0);
	      }
	      originalContext.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), originalContext.clip();
	      const width = b.width(),
	        height = b.height(),
	        padding = texturePadding,
	        cellSize = textureSize,
	        gridColumns = gridConfig.columns ? gridConfig.columns : Math.ceil(width / cellSize),
	        gridRows = gridConfig.rows ? gridConfig.rows : Math.ceil(height / cellSize),
	        gutterColumn = gridConfig.gutterColumn ? gridConfig.gutterColumn : 2 * padding,
	        gutterRow = gridConfig.gutterRow ? gridConfig.gutterRow : 2 * padding;
	      this._tempSymbolGraphic || (this._tempSymbolGraphic = createSymbol({}));
	      const sizeW = gridConfig.columns ? width / gridConfig.columns : cellSize,
	        sizeH = gridConfig.rows ? height / gridConfig.rows : cellSize;
	      this._tempSymbolGraphic.setAttributes({
	        size: [sizeW - gutterColumn, sizeH - gutterRow],
	        symbolType: texture
	      });
	      const parsedPath = this._tempSymbolGraphic.getParsedPath();
	      for (let i = 0; i < gridRows; i++) for (let j = 0; j < gridColumns; j++) {
	        const _x = x + cellSize / 2 + j * cellSize,
	          _y = y + cellSize / 2 + i * cellSize;
	        null === (_a = textureOptions.beforeDynamicTexture) || void 0 === _a || _a.call(textureOptions, context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height()), context.beginPath(), !1 === parsedPath.draw(context, Math.min(sizeW - gutterColumn, sizeH - gutterRow), _x, _y, 0) && context.closePath(), context.fillStyle = textureColor, textureOptions.dynamicTexture(context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height());
	      }
	      useNewCanvas && (originalContext.globalAlpha = 1, originalContext.drawImage(newCanvas.nativeCanvas, 0, 0, newCanvas.nativeCanvas.width, newCanvas.nativeCanvas.height, b.x1, b.y1, b.width() * originalContext.dpr, b.height() * originalContext.dpr)), originalContext.restore();
	    } else if (pattern) context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = pattern, context.fill(), context.highPerformanceRestore();else if ("wave" === texture) {
	      context.save(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.clip();
	      const b = graphic.AABBBounds;
	      drawWave(context, textureRatio, b.width(), b.height(), Object.assign(Object.assign({}, textureOptions || {}), {
	        fill: textureColor
	      }), x + b.x1 - x, y + b.y1 - y), context.restore();
	    }
	  }
	}
	const defaultBaseTextureRenderContribution = new DefaultBaseTextureRenderContribution();

	class DefaultArcRenderContribution {
	  constructor() {
	    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
	  }
	  drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb) {
	    const {
	        outerBorder: outerBorder,
	        innerBorder: innerBorder
	      } = arc.attribute,
	      doOuterBorder = outerBorder && !1 !== outerBorder.visible,
	      doInnerBorder = innerBorder && !1 !== innerBorder.visible;
	    if (!doOuterBorder && !doInnerBorder) return;
	    const {
	      innerPadding = arcAttribute.innerPadding,
	      outerPadding = arcAttribute.outerPadding,
	      startAngle = arcAttribute.startAngle,
	      endAngle = arcAttribute.endAngle,
	      opacity = arcAttribute.opacity,
	      x: originX = arcAttribute.x,
	      y: originY = arcAttribute.y,
	      scaleX = arcAttribute.scaleX,
	      scaleY = arcAttribute.scaleY,
	      keepStrokeScale = arcAttribute.keepStrokeScale
	    } = arc.attribute;
	    let {
	      innerRadius = arcAttribute.innerRadius,
	      outerRadius = arcAttribute.outerRadius
	    } = arc.attribute;
	    outerRadius += outerPadding, innerRadius -= innerPadding;
	    const renderBorder = (borderStyle, key) => {
	      const doStroke = !(!borderStyle || !borderStyle.stroke),
	        {
	          distance = arcAttribute[key].distance
	        } = borderStyle,
	        d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
	        deltaAngle = distance / outerRadius,
	        sign = "outerBorder" === key ? 1 : -1;
	      if (arc.setAttributes({
	        outerRadius: outerRadius + sign * d,
	        innerRadius: innerRadius - sign * d,
	        startAngle: startAngle - sign * deltaAngle,
	        endAngle: endAngle + sign * deltaAngle
	      }), context.beginPath(), drawArcPath$1(arc, context, x, y, outerRadius + sign * d, innerRadius - sign * d), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), strokeCb) strokeCb(context, borderStyle, arcAttribute[key]);else if (doStroke) {
	        const lastOpacity = arcAttribute[key].opacity;
	        arcAttribute[key].opacity = opacity, context.setStrokeStyle(arc, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, arcAttribute[key]), arcAttribute[key].opacity = lastOpacity, context.stroke();
	      }
	    };
	    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder"), arc.setAttributes({
	      outerRadius: outerRadius,
	      innerRadius: innerRadius,
	      startAngle: startAngle,
	      endAngle: endAngle
	    });
	  }
	}
	const defaultArcRenderContribution = new DefaultArcRenderContribution();
	const defaultArcTextureRenderContribution = defaultBaseTextureRenderContribution;
	const defaultArcBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

	const halfPi = pi / 2;
	function createRectPath(path, x, y, width, height, rectCornerRadius, roundCorner = !0, edgeCb) {
	  let cornerRadius;
	  if (Array.isArray(roundCorner) && (edgeCb = roundCorner, roundCorner = !0), width < 0 && (x += width, width = -width), height < 0 && (y += height, height = -height), isNumber$1(rectCornerRadius, !0)) cornerRadius = [rectCornerRadius = abs(rectCornerRadius), rectCornerRadius, rectCornerRadius, rectCornerRadius];else if (Array.isArray(rectCornerRadius)) {
	    const cornerRadiusArr = rectCornerRadius;
	    let cr0, cr1;
	    switch (cornerRadiusArr.length) {
	      case 0:
	        cornerRadius = [0, 0, 0, 0];
	        break;
	      case 1:
	        cr0 = abs(cornerRadiusArr[0]), cornerRadius = [cr0, cr0, cr0, cr0];
	        break;
	      case 2:
	      case 3:
	        cr0 = abs(cornerRadiusArr[0]), cr1 = abs(cornerRadiusArr[1]), cornerRadius = [cr0, cr1, cr0, cr1];
	        break;
	      default:
	        cornerRadius = cornerRadiusArr, cornerRadius[0] = abs(cornerRadius[0]), cornerRadius[1] = abs(cornerRadius[1]), cornerRadius[2] = abs(cornerRadius[2]), cornerRadius[3] = abs(cornerRadius[3]);
	    }
	  } else cornerRadius = [0, 0, 0, 0];
	  if (width < 0 || cornerRadius[0] + cornerRadius[1] + cornerRadius[2] + cornerRadius[3] < 1e-12) return path.rect(x, y, width, height);
	  const [leftTop, rightTop, rightBottom, leftBottom] = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]],
	    maxCornerRadius = Math.min(width / 2, height / 2),
	    _cornerRadius = [Math.min(maxCornerRadius, cornerRadius[0]), Math.min(maxCornerRadius, cornerRadius[1]), Math.min(maxCornerRadius, cornerRadius[2]), Math.min(maxCornerRadius, cornerRadius[3])],
	    leftTopPoint1 = [leftTop[0] + _cornerRadius[0], leftTop[1]],
	    leftTopPoint2 = [leftTop[0], leftTop[1] + _cornerRadius[0]],
	    rightTopPoint1 = [rightTop[0] - _cornerRadius[1], rightTop[1]],
	    rightTopPoint2 = [rightTop[0], rightTop[1] + _cornerRadius[1]],
	    rightBottomPoint1 = [rightBottom[0] - _cornerRadius[2], rightBottom[1]],
	    rightBottomPoint2 = [rightBottom[0], rightBottom[1] - _cornerRadius[2]],
	    leftBottomPoint1 = [leftBottom[0] + _cornerRadius[3], leftBottom[1]],
	    leftBottomPoint2 = [leftBottom[0], leftBottom[1] - _cornerRadius[3]];
	  if (path.moveTo(leftTopPoint1[0], leftTopPoint1[1]), roundCorner) {
	    if (edgeCb && edgeCb[0] ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1]) : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), !arrayEqual(rightTopPoint1, rightTopPoint2)) {
	      edgeCb && edgeCb[0] && path.moveTo(rightTopPoint1[0], rightTopPoint1[1]);
	      const centerX = rightTopPoint1[0],
	        centerY = rightTopPoint1[1] + _cornerRadius[1];
	      path.arc(centerX, centerY, _cornerRadius[1], -halfPi, 0, !1);
	    }
	    if (edgeCb && edgeCb[1] ? edgeCb[1](rightTopPoint2[0], rightTopPoint2[1], rightBottomPoint2[0], rightBottomPoint2[1]) : path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]), !arrayEqual(rightBottomPoint1, rightBottomPoint2)) {
	      const centerX = rightBottomPoint2[0] - _cornerRadius[2],
	        centerY = rightBottomPoint2[1];
	      edgeCb && edgeCb[1] && path.moveTo(rightBottomPoint2[0], rightBottomPoint2[1]), path.arc(centerX, centerY, _cornerRadius[2], 0, halfPi, !1);
	    }
	    if (edgeCb && edgeCb[2] ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1]) : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), !arrayEqual(leftBottomPoint1, leftBottomPoint2)) {
	      const centerX = leftBottomPoint1[0],
	        centerY = leftBottomPoint1[1] - _cornerRadius[3];
	      edgeCb && edgeCb[2] && path.moveTo(leftBottomPoint1[0], leftBottomPoint1[1]), path.arc(centerX, centerY, _cornerRadius[3], halfPi, pi, !1);
	    }
	    if (edgeCb && edgeCb[3] ? edgeCb[3](leftBottomPoint2[0], leftBottomPoint2[1], leftTopPoint2[0], leftTopPoint2[1]) : path.lineTo(leftTopPoint2[0], leftTopPoint2[1]), !arrayEqual(leftTopPoint1, leftTopPoint2)) {
	      const centerX = leftTopPoint1[0],
	        centerY = leftTopPoint1[1] + _cornerRadius[0];
	      edgeCb && edgeCb[3] && path.moveTo(leftTopPoint2[0], leftTopPoint2[1]), path.arc(centerX, centerY, _cornerRadius[0], pi, pi + halfPi, !1);
	    }
	  } else edgeCb && edgeCb[0] ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1]) : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), edgeCb && edgeCb[1] ? edgeCb[1](rightTopPoint1[0], rightTopPoint1[1], rightBottomPoint1[0], rightBottomPoint1[1]) : path.lineTo(rightBottomPoint1[0], rightBottomPoint1[1]), edgeCb && edgeCb[2] ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1]) : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), edgeCb && edgeCb[2] ? edgeCb[2](leftBottomPoint1[0], leftBottomPoint1[1], leftTopPoint1[0], leftTopPoint1[1]) : path.lineTo(leftTopPoint1[0], leftTopPoint1[1]);
	  return !edgeCb && path.closePath(), path;
	}

	var __decorate$u = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var d,
	    c = arguments.length,
	    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	class DefaultRectRenderContribution {
	  constructor() {
	    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
	  }
	  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
	    const {
	        outerBorder: outerBorder,
	        innerBorder: innerBorder
	      } = rect.attribute,
	      doOuterBorder = outerBorder && !1 !== outerBorder.visible,
	      doInnerBorder = innerBorder && !1 !== innerBorder.visible;
	    if (!doOuterBorder && !doInnerBorder) return;
	    const {
	      cornerRadius = rectAttribute.cornerRadius,
	      cornerType = rectAttribute.cornerType,
	      opacity = rectAttribute.opacity,
	      x: originX = rectAttribute.x,
	      y: originY = rectAttribute.y,
	      scaleX = rectAttribute.scaleX,
	      scaleY = rectAttribute.scaleY,
	      x1: x1,
	      y1: y1,
	      keepStrokeScale = rectAttribute.keepStrokeScale
	    } = rect.attribute;
	    let {
	      width: width,
	      height: height
	    } = rect.attribute;
	    width = (null != width ? width : x1 - x) || 0, height = (null != height ? height : y1 - y) || 0;
	    const renderBorder = (borderStyle, key) => {
	      const doStroke = !(!borderStyle || !borderStyle.stroke),
	        sign = "outerBorder" === key ? -1 : 1,
	        {
	          distance = rectAttribute[key].distance
	        } = borderStyle,
	        d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
	        nextX = x + sign * d,
	        nextY = y + sign * d,
	        dw = 2 * d;
	      if (0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(num => 0 === num) ? (context.beginPath(), context.rect(nextX, nextY, width - sign * dw, height - sign * dw)) : (context.beginPath(), createRectPath(context, nextX, nextY, width - sign * dw, height - sign * dw, cornerRadius, "bevel" !== cornerType)), context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), strokeCb) strokeCb(context, borderStyle, rectAttribute[key]);else if (doStroke) {
	        const lastOpacity = rectAttribute[key].opacity;
	        rectAttribute[key].opacity = opacity, context.setStrokeStyle(rect, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, rectAttribute[key]), rectAttribute[key].opacity = lastOpacity, context.stroke();
	      }
	    };
	    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
	  }
	}
	let SplitRectBeforeRenderContribution = class {
	  constructor() {
	    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
	  }
	  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
	    const {
	      stroke = groupAttribute.stroke
	    } = group.attribute;
	    Array.isArray(stroke) && stroke.some(s => !1 === s) && (doFillOrStroke.doStroke = !1);
	  }
	};
	SplitRectBeforeRenderContribution = __decorate$u([injectable()], SplitRectBeforeRenderContribution);
	let SplitRectAfterRenderContribution = class {
	  constructor() {
	    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
	  }
	  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
	    const {
	      x1: x1,
	      y1: y1,
	      x: originX = groupAttribute.x,
	      y: originY = groupAttribute.y,
	      stroke = groupAttribute.stroke,
	      cornerRadius = groupAttribute.cornerRadius,
	      cornerType = groupAttribute.cornerType
	    } = rect.attribute;
	    let {
	      width: width,
	      height: height
	    } = rect.attribute;
	    if (width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0, Array.isArray(stroke) && stroke.some(s => !1 === s)) {
	      if (context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute), !(0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(num => 0 === num))) {
	        let lastStroke,
	          lastStrokeI = 0;
	        return createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType, new Array(4).fill(0).map((_, i) => (x1, y1, x2, y2) => {
	          stroke[i] && (lastStrokeI === i - 1 && stroke[i] === lastStroke || (context.setStrokeStyle(rect, Object.assign(Object.assign({}, rect.attribute), {
	            stroke: stroke[i]
	          }), x, y, groupAttribute), context.beginPath(), context.moveTo(x1, y1), lastStroke = stroke[i]), lastStrokeI = i, context.lineTo(x2, y2), context.stroke(), 3 === i && context.beginPath());
	        })), void context.stroke();
	      }
	      if (context.beginPath(), context.moveTo(x, y), stroke[0] ? context.lineTo(x + width, y) : context.moveTo(x + width, y), stroke[1] ? context.lineTo(x + width, y + height) : context.moveTo(x + width, y + height), stroke[2] ? context.lineTo(x, y + height) : context.moveTo(x, y + height), stroke[3]) {
	        const adjustY = stroke[0] ? y - context.lineWidth / 2 : y;
	        context.lineTo(x, adjustY);
	      } else context.moveTo(x, y);
	      context.stroke();
	    }
	  }
	};
	SplitRectAfterRenderContribution = __decorate$u([injectable()], SplitRectAfterRenderContribution);
	const defaultRectRenderContribution = new DefaultRectRenderContribution();
	const defaultRectTextureRenderContribution = defaultBaseTextureRenderContribution;
	const defaultRectBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

	class DefaultImageRenderContribution extends DefaultRectRenderContribution {
	  constructor() {
	    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
	  }
	  drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
	    return super.drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
	  }
	}
	const defaultImageRenderContribution = new DefaultImageRenderContribution();
	const defaultImageBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

	class DefaultSymbolRenderContribution {
	  constructor() {
	    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
	  }
	  drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb) {
	    const parsedPath = symbol.getParsedPath();
	    if (!parsedPath) return;
	    const {
	        outerBorder: outerBorder,
	        innerBorder: innerBorder
	      } = symbol.attribute,
	      doOuterBorder = outerBorder && !1 !== outerBorder.visible,
	      doInnerBorder = innerBorder && !1 !== innerBorder.visible;
	    if (!doOuterBorder && !doInnerBorder) return;
	    const {
	        size = symbolAttribute.size,
	        opacity = symbolAttribute.opacity,
	        x: originX = symbolAttribute.x,
	        y: originY = symbolAttribute.y,
	        scaleX = symbolAttribute.scaleX,
	        scaleY = symbolAttribute.scaleY,
	        keepStrokeScale = symbolAttribute.keepStrokeScale
	      } = symbol.attribute,
	      renderBorder = (borderStyle, key) => {
	        const doStroke = !(!borderStyle || !borderStyle.stroke),
	          {
	            distance = symbolAttribute[key].distance
	          } = borderStyle,
	          d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
	          sign = "outerBorder" === key ? 1 : -1;
	        if (context.beginPath(), !1 === parsedPath.drawOffset(context, size, x, y, sign * d) && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), strokeCb) strokeCb(context, borderStyle, symbolAttribute[key]);else if (doStroke) {
	          const lastOpacity = symbolAttribute[key].opacity;
	          symbolAttribute[key].opacity = opacity, context.setStrokeStyle(symbol, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute[key]), symbolAttribute[key].opacity = lastOpacity, context.stroke();
	        }
	      };
	    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
	  }
	}
	class DefaultSymbolClipRangeStrokeRenderContribution {
	  constructor() {
	    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
	  }
	  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
	    const {
	        clipRange = graphicAttribute.clipRange,
	        x: originX = graphicAttribute.x,
	        y: originY = graphicAttribute.y,
	        z = graphicAttribute.z,
	        size = graphicAttribute.size,
	        scaleX = graphicAttribute.scaleX,
	        scaleY = graphicAttribute.scaleY
	      } = graphic.attribute,
	      parsedPath = graphic.getParsedPath();
	    if (!(parsedPath && clipRange < 1 && clipRange > 0)) return;
	    context.beginPath(), parsedPath.drawWithClipRange && parsedPath.drawWithClipRange(context, size, x, y, clipRange, z, (p, a) => {
	      var _a, _b, _c, _d;
	      if (graphic._parsedPath.svgCache) {
	        const obj = Object.assign({}, a);
	        obj.fill = null !== (_a = a.fill) && void 0 !== _a ? _a : graphic.attribute.fill, obj.opacity = null !== (_b = a.opacity) && void 0 !== _b ? _b : graphic.attribute.opacity, obj.fillOpacity = graphic.attribute.fillOpacity, obj.stroke = null !== (_c = a.stroke) && void 0 !== _c ? _c : graphic.attribute.stroke, obj.lineWidth = null !== (_d = a.lineWidth) && void 0 !== _d ? _d : graphic.attribute.lineWidth, a = obj;
	      }
	      a.stroke && (strokeCb ? strokeCb(context, graphic.attribute, graphicAttribute) : sVisible && (context.setStrokeStyle(graphic, a, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute), context.stroke()));
	    }), doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, graphic.attribute, graphicAttribute) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute), context.stroke()));
	  }
	}
	const defaultSymbolRenderContribution = new DefaultSymbolRenderContribution();
	const defaultSymbolClipRangeStrokeRenderContribution = new DefaultSymbolClipRangeStrokeRenderContribution();
	const defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution;
	const defaultSymbolBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

	const result = {
	  x: 0,
	  y: 0,
	  z: 0,
	  lastModelMatrix: null
	};
	class BaseRender {
	  init(contributions) {
	    contributions && (this._renderContribitions = contributions.getContributions()), this._renderContribitions || (this._renderContribitions = []), this.builtinContributions || (this.builtinContributions = []), this.builtinContributions.push(defaultBaseClipRenderBeforeContribution), this.builtinContributions.push(defaultBaseClipRenderAfterContribution), this.builtinContributions.forEach(item => this._renderContribitions.push(item)), this._renderContribitions.length && (this._renderContribitions.sort((a, b) => b.order - a.order), this._beforeRenderContribitions = this._renderContribitions.filter(c => c.time === BaseRenderContributionTime.beforeFillStroke), this._afterRenderContribitions = this._renderContribitions.filter(c => c.time === BaseRenderContributionTime.afterFillStroke));
	  }
	  reInit() {
	    this.init(this.graphicRenderContributions);
	  }
	  beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params) {
	    this._beforeRenderContribitions && this._beforeRenderContribitions.forEach(c => {
	      if (c.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
	        if (!(Array.isArray(c.supportedAppName) ? c.supportedAppName : [c.supportedAppName]).includes(graphic.stage.params.context.appName)) return;
	      }
	      c.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params);
	    });
	  }
	  afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params) {
	    this._afterRenderContribitions && this._afterRenderContribitions.forEach(c => {
	      if (c.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
	        if (!(Array.isArray(c.supportedAppName) ? c.supportedAppName : [c.supportedAppName]).includes(graphic.stage.params.context.appName)) return;
	      }
	      c.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params);
	    });
	  }
	  drawPathProxy(graphic, context, x, y, drawContext, params, fillCb, strokeCb) {
	    if (!graphic.pathProxy) return !1;
	    const themeAttributes = getTheme(graphic, null == params ? void 0 : params.theme)[graphic.type.replace("3d", "")],
	      {
	        fill = themeAttributes.fill,
	        stroke = themeAttributes.stroke,
	        opacity = themeAttributes.opacity,
	        fillOpacity = themeAttributes.fillOpacity,
	        lineWidth = themeAttributes.lineWidth,
	        strokeOpacity = themeAttributes.strokeOpacity,
	        visible = themeAttributes.visible,
	        x: originX = themeAttributes.x,
	        y: originY = themeAttributes.y
	      } = graphic.attribute,
	      fVisible = fillVisible(opacity, fillOpacity, fill),
	      sVisible = strokeVisible(opacity, strokeOpacity),
	      doFill = runFill(fill),
	      doStroke = runStroke(stroke, lineWidth);
	    if (!visible) return !0;
	    if (!doFill && !doStroke) return !0;
	    if (!(fVisible || sVisible || fillCb || strokeCb)) return !0;
	    context.beginPath();
	    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
	    return renderCommandList(path.commandList, context, x, y), context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes), this.beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb), doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.fill())), this.afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb), !0;
	  }
	  valid(graphic, defaultAttribute, fillCb, strokeCb) {
	    const {
	        fill = defaultAttribute.fill,
	        background: background,
	        stroke = defaultAttribute.stroke,
	        opacity = defaultAttribute.opacity,
	        fillOpacity = defaultAttribute.fillOpacity,
	        lineWidth = defaultAttribute.lineWidth,
	        strokeOpacity = defaultAttribute.strokeOpacity,
	        visible = defaultAttribute.visible
	      } = graphic.attribute,
	      fVisible = fillVisible(opacity, fillOpacity, fill),
	      sVisible = strokeVisible(opacity, strokeOpacity),
	      doFill = runFill(fill, background),
	      doStroke = runStroke(stroke, lineWidth);
	    return !(!graphic.valid || !visible) && !(!doFill && !doStroke) && !!(fVisible || sVisible || fillCb || strokeCb || background) && {
	      fVisible: fVisible,
	      sVisible: sVisible,
	      doFill: doFill,
	      doStroke: doStroke
	    };
	  }
	  transform(graphic, graphicAttribute, context, use3dMatrixIn3dMode = !1) {
	    const {
	        x = graphicAttribute.x,
	        y = graphicAttribute.y,
	        z = graphicAttribute.z,
	        scaleX = graphicAttribute.scaleX,
	        scaleY = graphicAttribute.scaleY,
	        angle = graphicAttribute.angle,
	        postMatrix: postMatrix
	      } = graphic.attribute,
	      lastModelMatrix = context.modelMatrix,
	      camera = context.camera;
	    result.x = x, result.y = y, result.z = z, result.lastModelMatrix = lastModelMatrix;
	    const shouldTransform3d = camera && (use3dMatrixIn3dMode || shouldUseMat4(graphic)),
	      onlyTranslate = shouldTransform3d ? graphic.transMatrix.onlyTranslate() && !postMatrix : 1 === scaleX && 1 === scaleY && 0 === angle && !postMatrix;
	    if (shouldTransform3d) {
	      const nextModelMatrix = mat4Allocate.allocate(),
	        modelMatrix = mat4Allocate.allocate();
	      getModelMatrix(modelMatrix, graphic, graphicAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), result.x = 0, result.y = 0, result.z = 0, context.modelMatrix = nextModelMatrix, context.setTransform(1, 0, 0, 1, 0, 0, !0), mat4Allocate.free(modelMatrix);
	    }
	    if (onlyTranslate && !lastModelMatrix) {
	      const point = graphic.getOffsetXY(graphicAttribute);
	      result.x += point.x, result.y += point.y, result.z = z, context.setTransformForCurrent();
	    } else if (shouldTransform3d) result.x = 0, result.y = 0, result.z = 0, context.setTransform(1, 0, 0, 1, 0, 0, !0);else if (camera && context.project) {
	      const point = graphic.getOffsetXY(graphicAttribute);
	      result.x += point.x, result.y += point.y, this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle);
	    } else context.transformFromMatrix(graphic.transMatrix, !0), result.x = 0, result.y = 0, result.z = 0;
	    return result;
	  }
	  transformUseContext2d(graphic, graphicAttribute, z, context) {
	    const camera = context.camera;
	    if (this.camera = camera, camera) {
	      const bounds = graphic.AABBBounds,
	        width = bounds.x2 - bounds.x1,
	        height = bounds.y2 - bounds.y1,
	        p1 = context.project(0, 0, z),
	        p2 = context.project(width, 0, z),
	        p3 = context.project(width, height, z),
	        _p1 = {
	          x: 0,
	          y: 0
	        },
	        _p2 = {
	          x: width,
	          y: 0
	        },
	        _p3 = {
	          x: width,
	          y: height
	        };
	      context.camera = null;
	      const denom = 1 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y),
	        m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom,
	        m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom,
	        m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom,
	        m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom,
	        dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) + _p1.y * (_p2.x * p3.x - _p3.x * p2.x) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) * denom,
	        dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) + _p1.y * (_p2.x * p3.y - _p3.x * p2.y) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) * denom;
	      context.setTransform(m11, m12, m21, m22, dx, dy, !0);
	    }
	  }
	  restoreTransformUseContext2d(graphic, graphicAttribute, z, context) {
	    this.camera && (context.camera = this.camera);
	  }
	  transformWithoutTranslate(context, x, y, z, scaleX, scaleY, angle) {
	    const p = context.project(x, y, z);
	    context.translate(p.x, p.y, !1), context.scale(scaleX, scaleY, !1), context.rotate(angle, !1), context.translate(-p.x, -p.y, !1), context.setTransformForCurrent();
	  }
	  _draw(graphic, defaultAttr, computed3dMatrix, drawContext, params, themeAttribute) {
	    const {
	      context: context
	    } = drawContext;
	    if (!context) return;
	    const {
	      renderable: renderable
	    } = graphic.attribute;
	    if (!1 === renderable) return;
	    context.highPerformanceSave();
	    const data = this.transform(graphic, defaultAttr, context, computed3dMatrix),
	      {
	        x: x,
	        y: y,
	        z: z,
	        lastModelMatrix: lastModelMatrix
	      } = data;
	    this.z = z, this.drawPathProxy(graphic, context, x, y, drawContext, params) || (this.drawShape(graphic, context, x, y, drawContext, params, null, null, themeAttribute), this.z = 0, context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();
	  }
	}

	var __decorate$t = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$m = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$l = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasArcRender = class extends BaseRender {
	  constructor(graphicRenderContributions) {
	    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = ARC_NUMBER_TYPE, this.builtinContributions = [defaultArcRenderContribution, defaultArcBackgroundRenderContribution, defaultArcTextureRenderContribution], this.init(graphicRenderContributions);
	  }
	  drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {
	    const capAngle = _ea - _sa,
	      data = arc.getParsedAngle(),
	      startAngle = data.startAngle;
	    let endAngle = data.endAngle;
	    endAngle = _ea;
	    const clockwise = endAngle > startAngle;
	    let collapsedToLine = !1;
	    if (outerRadius < innerRadius) {
	      const temp = outerRadius;
	      outerRadius = innerRadius, innerRadius = temp;
	    }
	    const {
	      outerDeltaAngle: outerDeltaAngle,
	      xors: xors,
	      yors: yors,
	      xirs: xirs,
	      yirs: yirs,
	      limitedOcr: limitedOcr,
	      outerCornerRadiusStart: outerCornerRadiusStart,
	      outerCornerRadiusEnd: outerCornerRadiusEnd,
	      maxOuterCornerRadius: maxOuterCornerRadius,
	      xore: xore,
	      yore: yore,
	      xire: xire,
	      yire: yire,
	      limitedIcr: limitedIcr,
	      innerDeltaAngle: innerDeltaAngle,
	      innerStartAngle: innerStartAngle,
	      innerCornerRadiusStart: innerCornerRadiusStart,
	      innerCornerRadiusEnd: innerCornerRadiusEnd,
	      maxInnerCornerRadius: maxInnerCornerRadius
	    } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
	    if (limitedOcr > epsilon) {
	      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr),
	        cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr),
	        t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)),
	        t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
	      if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);else {
	        const a1 = endAngle - capAngle - .03,
	          a2 = atan2(t1.y11, t1.x11);
	        context.arc(cx, cy, outerRadius, a1, a2, !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
	      }
	    } else context.moveTo(cx + xors, cy + yors);
	    if (!(innerRadius > epsilon) || innerDeltaAngle < .001) context.lineTo(cx + xire, cy + yire), collapsedToLine = !0;else if (limitedIcr > epsilon) {
	      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr),
	        cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr),
	        t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)),
	        t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
	      if (context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
	        const arcEndAngle = atan2(t1.y01, t1.x01);
	        context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);
	      } else {
	        cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
	        const a1 = atan2(t0.cy + t0.y11, t0.cx + t0.x11),
	          a2 = endAngle - capAngle - .03;
	        context.arc(cx, cy, innerRadius, a1, a2, clockwise);
	      }
	    } else context.lineTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
	    return collapsedToLine;
	  }
	  drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb, arcAttribute) {
	    arcAttribute = null != arcAttribute ? arcAttribute : getTheme(arc, null == params ? void 0 : params.theme).arc;
	    const {
	        fill = arcAttribute.fill,
	        stroke = arcAttribute.stroke,
	        x: originX = arcAttribute.x,
	        y: originY = arcAttribute.y,
	        fillStrokeOrder = arcAttribute.fillStrokeOrder
	      } = arc.attribute,
	      data = this.valid(arc, arcAttribute, fillCb, strokeCb);
	    if (!data) return;
	    const {
	        fVisible: fVisible,
	        sVisible: sVisible,
	        doFill: doFill,
	        doStroke: doStroke
	      } = data,
	      {
	        outerPadding = arcAttribute.outerPadding,
	        innerPadding = arcAttribute.innerPadding,
	        cap = arcAttribute.cap,
	        forceShowCap = arcAttribute.forceShowCap
	      } = arc.attribute;
	    let {
	      outerRadius = arcAttribute.outerRadius,
	      innerRadius = arcAttribute.innerRadius
	    } = arc.attribute;
	    outerRadius += outerPadding, innerRadius -= innerPadding;
	    let conicalOffset = 0;
	    const tempChangeConicalColor = (isBoolean$1(cap) && cap || cap[0]) && "conical" === fill.gradient;
	    if (tempChangeConicalColor) {
	      const {
	        sc: sc,
	        startAngle: startAngle,
	        endAngle: endAngle
	      } = arc.getParsedAngle();
	      abs(endAngle - startAngle) < pi2 - epsilon && (conicalOffset = sc || 0, fill.startAngle -= conicalOffset, fill.endAngle -= conicalOffset);
	    }
	    let beforeRenderContribitionsRuned = !1;
	    const {
	      isFullStroke: isFullStroke,
	      stroke: arrayStroke
	    } = parseStroke(stroke);
	    if ((doFill || isFullStroke) && (context.beginPath(), drawArcPath$1(arc, context, x, y, outerRadius, innerRadius), beforeRenderContribitionsRuned = !0, context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), fillStrokeOrder ? (this._runStroke(arc, context, x, y, arcAttribute, doStroke, isFullStroke, sVisible, strokeCb), this._runFill(arc, context, x, y, arcAttribute, doFill, fVisible, originX, originY, fillCb)) : (this._runFill(arc, context, x, y, arcAttribute, doFill, fVisible, originX, originY, fillCb), this._runStroke(arc, context, x, y, arcAttribute, doStroke, isFullStroke, sVisible, strokeCb))), !isFullStroke && doStroke) {
	      context.beginPath();
	      drawArcPath$1(arc, context, x, y, outerRadius, innerRadius, arrayStroke);
	      beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke());
	    }
	    if ((isBoolean$1(cap) && cap || cap[1]) && forceShowCap) {
	      const {
	        startAngle: sa,
	        endAngle: ea
	      } = arc.getParsedAngle();
	      if (abs(ea - sa) >= pi2 - epsilon) {
	        context.beginPath();
	        const capAngle = Math.abs(outerRadius - innerRadius) / 2 / outerRadius,
	          {
	            endAngle = arcAttribute.endAngle,
	            fill = arcAttribute.fill
	          } = arc.attribute,
	          startAngle = endAngle;
	        this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, startAngle, startAngle + capAngle), beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
	        const _runFill = () => {
	            if (doFill) {
	              const color = fill;
	              if ("conical" === color.gradient) {
	                const lastColor = getConicGradientAt(0, 0, endAngle, color);
	                fillCb || fillVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = lastColor, context.fill());
	              }
	            }
	          },
	          _runStroke = () => {
	            doStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()));
	          };
	        _runFill(), _runStroke();
	      }
	    }
	    this.afterRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), tempChangeConicalColor && (fill.startAngle += conicalOffset, fill.endAngle += conicalOffset);
	  }
	  _runFill(arc, context, x, y, arcAttribute, doFill, fVisible, originX, originY, fillCb) {
	    doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.fill()));
	  }
	  _runStroke(arc, context, x, y, arcAttribute, doStroke, isFullStroke, sVisible, strokeCb) {
	    doStroke && isFullStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()));
	  }
	  draw(arc, renderService, drawContext, params) {
	    const arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc;
	    this._draw(arc, arcAttribute, !1, drawContext, params, arcAttribute);
	  }
	};
	DefaultCanvasArcRender = __decorate$t([injectable(), __param$l(0, inject(ContributionProvider)), __param$l(0, named(ArcRenderContribution)), __metadata$m("design:paramtypes", [Object])], DefaultCanvasArcRender);

	function drawSegItem(ctx, curve, endPercent, params) {
	  if (!curve.p1) return;
	  const {
	    offsetX = 0,
	    offsetY = 0,
	    offsetZ = 0
	  } = params || {};
	  if (1 === endPercent) curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ);else if (curve.p2 && curve.p3) {
	    const [curve1] = divideCubic(curve, endPercent);
	    ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
	  } else {
	    const p = curve.getPointAt(endPercent);
	    ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
	  }
	}

	function drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ) {
	  var _a;
	  let p0 = curve.p0,
	    newDefined0 = defined0;
	  if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (p0 = lastCurve.p0), curve.defined) defined0 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), newDefined0 = !defined0);else {
	    const {
	      originP1: originP1,
	      originP2: originP2
	    } = curve;
	    let validP;
	    if (originP1 && !1 !== originP1.defined && !lastCurve ? validP = p0 : originP1 && !1 !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), defined0) {
	      newDefined0 = !defined0;
	      const x = validP ? validP.x : curve.p0.x,
	        y = validP ? validP.y : curve.p0.y;
	      path.moveTo(x + offsetX, y + offsetY, offsetZ);
	    } else validP && (newDefined0 = !defined0, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
	  }
	  return newDefined0;
	}
	function drawSegments(path, segPath, percent, clipRangeByDimension, params) {
	  const {
	    offsetX = 0,
	    offsetY = 0,
	    offsetZ = 0,
	    mode = "none",
	    drawConnect = !1
	  } = params || {};
	  if (drawConnect && "none" === mode) return;
	  if (!segPath) return;
	  let needMoveTo = !0;
	  const {
	    curves: curves
	  } = segPath;
	  if (percent >= 1) {
	    if (drawConnect) {
	      let lastCurve,
	        defined0 = !0;
	      curves.forEach((curve, i) => {
	        curve.originP1 !== curve.originP2 ? (defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ), lastCurve = curve) : lastCurve = curve;
	      });
	    } else curves.forEach(curve => {
	      curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
	    });
	    return;
	  }
	  if (percent <= 0) return;
	  let direction;
	  "x" === clipRangeByDimension ? direction = Direction.ROW : "y" === clipRangeByDimension ? direction = Direction.COLUMN : "auto" === clipRangeByDimension && (direction = segPath.direction);
	  const totalDrawLength = percent * segPath.tryUpdateLength(direction);
	  let drawedLengthUntilLast = 0,
	    defined0 = !0,
	    lastCurve = null;
	  for (let i = 0, n = curves.length; i < n; i++) {
	    const curve = curves[i],
	      curCurveLength = curve.getLength(direction),
	      _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
	    if (drawedLengthUntilLast += curCurveLength, _p < 0) break;
	    if (drawConnect) {
	      if (curve.originP1 === curve.originP2) {
	        lastCurve = curve;
	        continue;
	      }
	      defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ), lastCurve = curve;
	    } else {
	      if (!curve.defined) {
	        needMoveTo = !0;
	        continue;
	      }
	      needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, min(_p, 1), params), needMoveTo = !1;
	    }
	  }
	}
	function drawIncrementalSegments(path, lastSeg, segments, params) {
	  const {
	      offsetX = 0,
	      offsetY = 0
	    } = params || {},
	    startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];
	  path.moveTo(startP.x + offsetX, startP.y + offsetY), segments.points.forEach(p => {
	    !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
	  });
	}

	var __decorate$s = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var d,
	    c = arguments.length,
	    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	let DefaultCanvasLineRender = class extends BaseRender {
	  constructor() {
	    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
	  }
	  draw(line, renderService, drawContext, params) {
	    const lineAttribute = getTheme(line, null == params ? void 0 : params.theme).line;
	    this._draw(line, lineAttribute, !1, drawContext, params);
	  }
	  drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
	    var _a;
	    if (!cache) return;
	    context.beginPath();
	    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
	    drawSegments(context, cache, clipRange, clipRangeByDimension, {
	      offsetX: offsetX,
	      offsetY: offsetY,
	      offsetZ: z
	    }), line.cache && !isArray$1(line.cache) && line.cache.curves.every(c => c.defined) && line.attribute.curveType && line.attribute.curveType.includes("Closed") && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute);
	    const {
	      x: originX = 0,
	      x: originY = 0
	    } = attribute;
	    return !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke())), !1;
	  }
	  drawLinearLineHighPerformance(line, context, fill, stroke, fillOpacity, strokeOpacity, offsetX, offsetY, lineAttribute, drawContext, params, fillCb, strokeCb) {
	    var _a;
	    context.beginPath();
	    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
	      {
	        points: points
	      } = line.attribute,
	      startP = points[0];
	    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
	    for (let i = 1; i < points.length; i++) {
	      const p = points[i];
	      context.lineTo(p.x + offsetX, p.y + offsetY, z);
	    }
	    context.setShadowBlendStyle && context.setShadowBlendStyle(line, line.attribute, lineAttribute);
	    const {
	      x: originX = 0,
	      x: originY = 0
	    } = line.attribute;
	    !1 !== fill && (fillCb ? fillCb(context, line.attribute, lineAttribute) : fillOpacity && (context.setCommonStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, line.attribute, lineAttribute) : strokeOpacity && (context.setStrokeStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.stroke()));
	  }
	  drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
	    const lineAttribute = getTheme(line, null == params ? void 0 : params.theme).line,
	      {
	        fill = lineAttribute.fill,
	        stroke = lineAttribute.stroke,
	        fillOpacity = lineAttribute.fillOpacity,
	        strokeOpacity = lineAttribute.strokeOpacity,
	        segments: segments,
	        points: points,
	        closePath: closePath,
	        curveTension = lineAttribute.curveTension,
	        connectedType = lineAttribute.connectedType
	      } = line.attribute;
	    if (!this.valid(line, lineAttribute, fillCb, strokeCb)) return;
	    let {
	      curveType = lineAttribute.curveType
	    } = line.attribute;
	    closePath && "linear" === curveType && (curveType = "linearClosed");
	    const {
	      clipRange = lineAttribute.clipRange,
	      clipRangeByDimension = lineAttribute.clipRangeByDimension
	    } = line.attribute;
	    if (1 === clipRange && !segments && !points.some(p => !1 === p.defined) && "linear" === curveType) return this.drawLinearLineHighPerformance(line, context, !!fill, !!stroke, fillOpacity, strokeOpacity, x, y, lineAttribute, drawContext, params, fillCb, strokeCb);
	    function parsePoint(points, connectedType) {
	      return "none" === connectedType ? points : points.filter(p => !1 !== p.defined);
	    }
	    if (line.shouldUpdateShape()) {
	      const {
	          points: points,
	          segments: segments
	        } = line.attribute,
	        _points = points;
	      if (segments && segments.length) {
	        let startPoint, lastSeg;
	        if (line.cache = segments.map((seg, index) => {
	          if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastSeg = {
	            endX: seg.points[0].x,
	            endY: seg.points[0].y,
	            curves: [{
	              defined: !1 !== seg.points[0].defined
	            }]
	          }), null;
	          1 === index ? startPoint = {
	            x: lastSeg.endX,
	            y: lastSeg.endY,
	            defined: lastSeg.curves[lastSeg.curves.length - 1].defined
	          } : index > 1 && (startPoint.x = lastSeg.endX, startPoint.y = lastSeg.endY, startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined);
	          const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
	            startPoint: startPoint,
	            curveTension: curveTension
	          });
	          return lastSeg = data, data;
	        }).filter(item => !!item), "linearClosed" === curveType) {
	          let startP;
	          for (let i = 0; i < line.cache.length; i++) {
	            const cacheItem = line.cache[i];
	            for (let i = 0; i < cacheItem.curves.length; i++) if (cacheItem.curves[i].defined) {
	              startP = cacheItem.curves[i].p0;
	              break;
	            }
	            if (startP) break;
	          }
	          line.cache[line.cache.length - 1] && line.cache[line.cache.length - 1].lineTo(startP.x, startP.y, !0);
	        }
	      } else {
	        if (!points || !points.length) return line.cache = null, void line.clearUpdateShapeTag();
	        line.cache = calcLineCache(parsePoint(_points, connectedType), curveType, {
	          curveTension: curveTension
	        });
	      }
	      line.clearUpdateShapeTag();
	    }
	    if (Array.isArray(line.cache)) {
	      const segments = line.attribute.segments.filter(item => item.points.length);
	      if (1 === segments[0].points.length && segments.shift(), 1 === clipRange) {
	        let skip = !1;
	        line.cache.forEach((cache, index) => {
	          skip || (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, segments[index], [lineAttribute, line.attribute], clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb));
	        });
	      } else {
	        const totalLength = line.cache.reduce((l, c) => l + c.getLength(), 0),
	          totalDrawLength = clipRange * totalLength;
	        let drawedLengthUntilLast = 0,
	          skip = !1;
	        line.cache.forEach((cache, index) => {
	          if (skip) return;
	          const curSegLength = cache.getLength(),
	            _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
	          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, segments[index], [lineAttribute, line.attribute], min(_cr, 1), clipRangeByDimension, x, y, line, fillCb, strokeCb));
	        });
	      }
	    } else this.drawSegmentItem(context, line.cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);
	  }
	};
	DefaultCanvasLineRender = __decorate$s([injectable()], DefaultCanvasLineRender);

	var __decorate$r = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$l = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$k = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasRectRender = class extends BaseRender {
	  constructor(graphicRenderContributions) {
	    super(), this.graphicRenderContributions = graphicRenderContributions, this.type = "rect", this.numberType = RECT_NUMBER_TYPE, this.builtinContributions = [defaultRectRenderContribution, defaultRectBackgroundRenderContribution, defaultRectTextureRenderContribution], this.init(graphicRenderContributions);
	  }
	  drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb, rectAttribute) {
	    rectAttribute = null != rectAttribute ? rectAttribute : getTheme(rect, null == params ? void 0 : params.theme).rect;
	    const {
	      fill = rectAttribute.fill,
	      background: background,
	      stroke = rectAttribute.stroke,
	      cornerRadius = rectAttribute.cornerRadius,
	      cornerType = rectAttribute.cornerType,
	      opacity = rectAttribute.opacity,
	      fillOpacity = rectAttribute.fillOpacity,
	      lineWidth = rectAttribute.lineWidth,
	      strokeOpacity = rectAttribute.strokeOpacity,
	      visible = rectAttribute.visible,
	      x1: x1,
	      y1: y1,
	      x: originX = rectAttribute.x,
	      y: originY = rectAttribute.y,
	      fillStrokeOrder = rectAttribute.fillStrokeOrder,
	      drawStrokeWhenZeroWH = rectAttribute.drawStrokeWhenZeroWH
	    } = rect.attribute;
	    let {
	      width: width,
	      height: height
	    } = rect.attribute;
	    width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0;
	    const fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill),
	      sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height, drawStrokeWhenZeroWH),
	      doFill = runFill(fill, background),
	      doStroke = runStroke(stroke, lineWidth);
	    if (!rect.valid || !visible) return;
	    if (!doFill && !doStroke) return;
	    if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
	    0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(num => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType));
	    const doFillOrStroke = {
	      doFill: doFill,
	      doStroke: doStroke
	    };
	    context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), this.beforeRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb, doFillOrStroke), fillStrokeOrder ? (this._runStroke(rect, context, x, y, rectAttribute, doFillOrStroke, sVisible, originX, originY, strokeCb), this._runFill(rect, context, x, y, rectAttribute, doFillOrStroke, fVisible, originX, originY, fillCb)) : (this._runFill(rect, context, x, y, rectAttribute, doFillOrStroke, fVisible, originX, originY, fillCb), this._runStroke(rect, context, x, y, rectAttribute, doFillOrStroke, sVisible, originX, originY, strokeCb)), this.afterRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
	  }
	  _runFill(rect, context, x, y, rectAttribute, doFillOrStroke, fVisible, originX, originY, fillCb) {
	    doFillOrStroke.doFill && (fillCb ? fillCb(context, rect.attribute, rectAttribute) : fVisible && (context.setCommonStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.fill()));
	  }
	  _runStroke(rect, context, x, y, rectAttribute, doFillOrStroke, sVisible, originX, originY, strokeCb) {
	    doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, rect.attribute, rectAttribute) : sVisible && (context.setStrokeStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.stroke()));
	  }
	  draw(rect, renderService, drawContext, params) {
	    const rectAttribute = getTheme(rect, null == params ? void 0 : params.theme).rect;
	    this._draw(rect, rectAttribute, !1, drawContext, params, rectAttribute);
	  }
	};
	DefaultCanvasRectRender = __decorate$r([injectable(), __param$k(0, inject(ContributionProvider)), __param$k(0, named(RectRenderContribution)), __metadata$l("design:paramtypes", [Object])], DefaultCanvasRectRender);

	var __decorate$q = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$k = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$j = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasSymbolRender = class extends BaseRender {
	  constructor(graphicRenderContributions) {
	    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = SYMBOL_NUMBER_TYPE, this.builtinContributions = [defaultSymbolRenderContribution, defaultSymbolBackgroundRenderContribution, defaultSymbolTextureRenderContribution, defaultSymbolClipRangeStrokeRenderContribution], this.init(graphicRenderContributions);
	  }
	  drawShape(symbol, context, x, y, drawContext, params, fillCb, strokeCb, symbolAttribute) {
	    var _a;
	    symbolAttribute = null != symbolAttribute ? symbolAttribute : getTheme(symbol, null == params ? void 0 : params.theme).symbol;
	    const {
	        size = symbolAttribute.size,
	        x: originX = symbolAttribute.x,
	        y: originY = symbolAttribute.y,
	        scaleX = symbolAttribute.scaleX,
	        scaleY = symbolAttribute.scaleY,
	        fillStrokeOrder = symbolAttribute.fillStrokeOrder,
	        clipRange = symbolAttribute.clipRange
	      } = symbol.attribute,
	      data = this.valid(symbol, symbolAttribute, fillCb, strokeCb);
	    if (!data) return;
	    const {
	        fVisible: fVisible,
	        sVisible: sVisible,
	        doFill: doFill,
	        doStroke: doStroke
	      } = data,
	      parsedPath = symbol.getParsedPath();
	    if (!parsedPath) return;
	    const {
	        keepDirIn3d = symbolAttribute.keepDirIn3d
	      } = symbol.attribute,
	      z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
	    context.beginPath();
	    let _x = x,
	      _y = y,
	      _z = z;
	    const camera = context.camera;
	    if (keepDirIn3d && camera && context.project) {
	      const p = context.project(x, y, z);
	      context.camera = null, isArray$1(size) ? [size[0] * scaleX, size[1] * scaleY] : size * scaleX, _x = p.x, _y = p.y, _z = void 0;
	    }
	    !1 === parsedPath.draw(context, size, _x, _y, _z, (p, a) => {
	      var _a, _b, _c, _d;
	      if (symbol._parsedPath.svgCache) {
	        const obj = Object.assign({}, a);
	        obj.fill = null !== (_a = a.fill) && void 0 !== _a ? _a : symbol.attribute.fill, obj.opacity = null !== (_b = a.opacity) && void 0 !== _b ? _b : symbol.attribute.opacity, obj.fillOpacity = symbol.attribute.fillOpacity, obj.stroke = null !== (_c = a.stroke) && void 0 !== _c ? _c : symbol.attribute.stroke, obj.lineWidth = null !== (_d = a.lineWidth) && void 0 !== _d ? _d : symbol.attribute.lineWidth, a = obj;
	      }
	      const _runFill = () => {
	          a.fill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : (context.setCommonStyle(symbol, a, originX - x, originY - y, symbolAttribute), context.fill()));
	        },
	        _runStroke = () => {
	          a.stroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && clipRange >= 1 && (context.setStrokeStyle(symbol, a, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
	        };
	      fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke());
	    }) && context.closePath(), context.camera = camera, context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), this.beforeRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb), fillStrokeOrder ? (this._runStroke(symbol, context, x, y, symbolAttribute, doStroke, sVisible, originX, originY, parsedPath, clipRange, scaleX, scaleY, strokeCb), this._runFill(symbol, context, x, y, symbolAttribute, doFill, fVisible, originX, originY, parsedPath, fillCb)) : (this._runFill(symbol, context, x, y, symbolAttribute, doFill, fVisible, originX, originY, parsedPath, fillCb), this._runStroke(symbol, context, x, y, symbolAttribute, doStroke, sVisible, originX, originY, parsedPath, clipRange, scaleX, scaleY, strokeCb)), this.afterRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
	  }
	  _runFill(symbol, context, x, y, symbolAttribute, doFill, fVisible, originX, originY, parsedPath, fillCb) {
	    doFill && !parsedPath.isSvg && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : fVisible && (context.setCommonStyle(symbol, symbol.attribute, originX - x, originY - y, symbolAttribute), context.fill()));
	  }
	  _runStroke(symbol, context, x, y, symbolAttribute, doStroke, sVisible, originX, originY, parsedPath, clipRange, scaleX, scaleY, strokeCb) {
	    doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && clipRange >= 1 && (context.setStrokeStyle(symbol, symbol.attribute, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
	  }
	  draw(symbol, renderService, drawContext, params) {
	    const symbolAttribute = getTheme(symbol, null == params ? void 0 : params.theme).symbol;
	    this._draw(symbol, symbolAttribute, !1, drawContext, params);
	  }
	};
	DefaultCanvasSymbolRender = __decorate$q([injectable(), __param$j(0, inject(ContributionProvider)), __param$j(0, named(SymbolRenderContribution)), __metadata$k("design:paramtypes", [Object])], DefaultCanvasSymbolRender);

	class DefaultBoundsAllocate {
	  constructor() {
	    this.pools = [];
	    for (let i = 0; i < 10; i++) this.pools.push(new AABBBounds());
	  }
	  allocate(x1, y1, x2, y2) {
	    if (!this.pools.length) return new AABBBounds().setValue(x1, y1, x2, y2);
	    const b = this.pools.pop();
	    return b.x1 = x1, b.y1 = y1, b.x2 = x2, b.y2 = y2, b;
	  }
	  allocateByObj(b) {
	    if (!this.pools.length) return new AABBBounds(b);
	    const _b = this.pools.pop();
	    return _b.x1 = b.x1, _b.y1 = b.y1, _b.x2 = b.x2, _b.y2 = b.y2, _b;
	  }
	  free(b) {
	    this.pools.push(b);
	  }
	  get length() {
	    return this.pools.length;
	  }
	  release(...params) {
	    this.pools = [];
	  }
	}
	const boundsAllocate = new DefaultBoundsAllocate();

	class DefaultTextBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
	  constructor() {
	    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
	  }
	  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
	    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l;
	    const {
	      backgroundMode = graphicAttribute.backgroundMode,
	      backgroundFit = graphicAttribute.backgroundFit,
	      backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio
	    } = graphic.attribute;
	    let matrix,
	      {
	        background: background
	      } = graphic.attribute;
	    if (!background) return;
	    const restore = () => {
	      "richtext" === graphic.type && (context.restore(), context.save(), matrix && context.setTransformFromMatrix(matrix, !0, 1));
	    };
	    let b;
	    "richtext" === graphic.type && (matrix = context.currentMatrix.clone(), context.restore(), context.save(), context.setTransformForCurrent());
	    const shouldReCalBounds = isObject$1(background) && background.background,
	      onlyTranslate = graphic.transMatrix.onlyTranslate();
	    if (shouldReCalBounds) {
	      const _b = graphic.AABBBounds,
	        x = (null !== (_a = background.x) && void 0 !== _a ? _a : _b.x1) + (null !== (_c = background.dx) && void 0 !== _c ? _c : 0),
	        y = (null !== (_d = background.y) && void 0 !== _d ? _d : _b.y1) + (null !== (_e = background.dy) && void 0 !== _e ? _e : 0),
	        w = null !== (_f = background.width) && void 0 !== _f ? _f : _b.width(),
	        h = null !== (_g = background.height) && void 0 !== _g ? _g : _b.height();
	      if (b = boundsAllocate.allocate(x, y, x + w, y + h), background = background.background, !onlyTranslate) {
	        const w = b.width(),
	          h = b.height();
	        b.set((null !== (_h = background.x) && void 0 !== _h ? _h : 0) + (null !== (_j = background.dx) && void 0 !== _j ? _j : 0), (null !== (_k = background.y) && void 0 !== _k ? _k : 0) + (null !== (_l = background.dy) && void 0 !== _l ? _l : 0), w, h);
	      }
	    } else b = graphic.AABBBounds, onlyTranslate || (b = getTextBounds(Object.assign(Object.assign({}, graphic.attribute), {
	      angle: 0,
	      scaleX: 1,
	      scaleY: 1,
	      x: 0,
	      y: 0,
	      dx: 0,
	      dy: 0
	    })).clone());
	    if (graphic.backgroundImg && graphic.resources) {
	      const res = graphic.resources.get(background);
	      if ("success" !== res.state || !res.data) return void restore();
	      context.highPerformanceSave(), onlyTranslate && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), this.doDrawImage(context, res.data, b, {
	        backgroundMode: backgroundMode,
	        backgroundFit: backgroundFit,
	        backgroundKeepAspectRatio: backgroundKeepAspectRatio
	      }), context.highPerformanceRestore(), context.setTransformForCurrent();
	    } else {
	      const {
	        backgroundCornerRadius: backgroundCornerRadius
	      } = graphic.attribute;
	      context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = background, backgroundCornerRadius ? (createRectPath(context, b.x1, b.y1, b.width(), b.height(), backgroundCornerRadius, !0), context.fill()) : context.fillRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore();
	    }
	    shouldReCalBounds && boundsAllocate.free(b), restore();
	  }
	}
	const defaultTextBackgroundRenderContribution = new DefaultTextBackgroundRenderContribution();

	var __decorate$p = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$j = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$i = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasTextRender = class extends BaseRender {
	  constructor(graphicRenderContributions) {
	    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = TEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init(graphicRenderContributions);
	  }
	  drawShape(text, context, x, y, drawContext, params, fillCb, strokeCb) {
	    var _a, _b, _c;
	    const textAttribute = getTheme(text, null == params ? void 0 : params.theme).text,
	      {
	        text: str,
	        underline = textAttribute.underline,
	        lineThrough = textAttribute.lineThrough,
	        keepDirIn3d = textAttribute.keepDirIn3d,
	        direction = textAttribute.direction,
	        fontSize = textAttribute.fontSize,
	        verticalMode = textAttribute.verticalMode,
	        x: originX = textAttribute.x,
	        y: originY = textAttribute.y
	      } = text.attribute,
	      lineHeight = null !== (_a = calculateLineHeight(text.attribute.lineHeight, fontSize)) && void 0 !== _a ? _a : fontSize,
	      data = this.valid(text, textAttribute, fillCb, strokeCb);
	    if (!data) return;
	    const {
	        fVisible: fVisible,
	        sVisible: sVisible,
	        doFill: doFill,
	        doStroke: doStroke
	      } = data,
	      transform3dMatrixToContextMatrix = !keepDirIn3d,
	      z = this.z || 0;
	    context.beginPath(), context.setShadowBlendStyle && context.setShadowBlendStyle(text, text.attribute, textAttribute), this.beforeRenderStep(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb), transform3dMatrixToContextMatrix && this.transformUseContext2d(text, textAttribute, z, context);
	    const drawText = (t, offsetX, offsetY, direction) => {
	      let _x = x + offsetX;
	      const _y = y + offsetY;
	      if (direction) {
	        context.highPerformanceSave(), _x += fontSize;
	        const matrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0);
	        matrix.rotateByCenter(Math.PI / 2, _x, _y), context.transformFromMatrix(matrix, !0), matrixAllocate.free(matrix);
	      }
	      doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), context.strokeText(t, _x, _y, z))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), context.fillText(t, _x, _y, z))), direction && (context.highPerformanceRestore(), context.setTransformForCurrent());
	    };
	    if (context.setTextStyleWithoutAlignBaseline(text.attribute, textAttribute, z), "horizontal" === direction) {
	      const {
	        multilineLayout: multilineLayout
	      } = text;
	      if (!multilineLayout) return void context.highPerformanceRestore();
	      const {
	        xOffset: xOffset,
	        yOffset: yOffset
	      } = multilineLayout.bbox;
	      doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), multilineLayout.lines.forEach(line => {
	        context.strokeText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z);
	      }))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), multilineLayout.lines.forEach(line => {
	        context.fillText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z), this.drawUnderLine(underline, lineThrough, text, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, line.descent, (line.descent - line.ascent) / 2, z, textAttribute, context, {
	          width: line.width
	        });
	      })));
	    } else {
	      let {
	        textAlign = textAttribute.textAlign,
	        textBaseline = textAttribute.textBaseline
	      } = text.attribute;
	      if (!verticalMode) {
	        const t = textAlign;
	        textAlign = null !== (_b = text.getBaselineMapAlign()[textBaseline]) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = text.getAlignMapBaseline()[t]) && void 0 !== _c ? _c : "top";
	      }
	      text.tryUpdateAABBBounds();
	      const cache = text.cache,
	        {
	          verticalList: verticalList
	        } = cache;
	      context.textAlign = "left", context.textBaseline = "top";
	      const totalHeight = lineHeight * verticalList.length;
	      let totalW = 0;
	      verticalList.forEach(verticalData => {
	        const _w = verticalData.reduce((a, b) => a + (b.width || 0), 0);
	        totalW = max(_w, totalW);
	      });
	      let offsetY = 0,
	        offsetX = 0;
	      "bottom" === textBaseline ? offsetX = -totalHeight : "middle" === textBaseline && (offsetX = -totalHeight / 2), "center" === textAlign ? offsetY -= totalW / 2 : "right" === textAlign && (offsetY -= totalW), verticalList.forEach((verticalData, i) => {
	        const currentW = verticalData.reduce((a, b) => a + (b.width || 0), 0),
	          dw = totalW - currentW;
	        let currentOffsetY = offsetY;
	        "center" === textAlign ? currentOffsetY += dw / 2 : "right" === textAlign && (currentOffsetY += dw), verticalData.forEach(item => {
	          const {
	            text: text,
	            width: width,
	            direction: direction
	          } = item;
	          drawText(text, totalHeight - (i + 1) * lineHeight + offsetX, currentOffsetY, direction), currentOffsetY += width;
	        });
	      });
	    }
	    transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text, textAttribute, z, context), this.afterRenderStep(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb);
	  }
	  draw(text, renderService, drawContext, params) {
	    const textAttribute = getTheme(text, null == params ? void 0 : params.theme).text,
	      {
	        keepDirIn3d = textAttribute.keepDirIn3d
	      } = text.attribute,
	      computed3dMatrix = !keepDirIn3d;
	    this._draw(text, textAttribute, computed3dMatrix, drawContext, params);
	  }
	  drawUnderLine(underline, lineThrough, text, anchorX, anchorY, offsetUnderLineY, offsetThroughLineY, z, textAttribute, context, multiOption) {
	    if (lineThrough + underline <= 0) return;
	    const {
	        textAlign = textAttribute.textAlign,
	        fill = textAttribute.fill,
	        opacity = textAttribute.opacity,
	        underlineOffset = textAttribute.underlineOffset,
	        underlineDash = textAttribute.underlineDash,
	        fillOpacity = textAttribute.fillOpacity
	      } = text.attribute,
	      isMulti = !isNil$1(multiOption),
	      w = isMulti ? multiOption.width : text.clipedWidth,
	      offsetX = isMulti ? 0 : textDrawOffsetX(textAlign, w),
	      attribute = {
	        lineWidth: 0,
	        stroke: fill,
	        opacity: opacity,
	        strokeOpacity: fillOpacity
	      };
	    if (underline) {
	      attribute.lineWidth = underline, context.setStrokeStyle(text, attribute, anchorX, anchorY, textAttribute), underlineDash && context.setLineDash(underlineDash), context.beginPath();
	      const dy = anchorY + offsetUnderLineY + underlineOffset;
	      context.moveTo(anchorX + offsetX, dy, z), context.lineTo(anchorX + offsetX + w, dy, z), context.stroke();
	    }
	    if (lineThrough) {
	      attribute.lineWidth = lineThrough, context.setStrokeStyle(text, attribute, anchorX, anchorY, textAttribute), context.beginPath();
	      const dy = anchorY + offsetThroughLineY;
	      context.moveTo(anchorX + offsetX, dy, z), context.lineTo(anchorX + offsetX + w, dy, z), context.stroke();
	    }
	  }
	};
	DefaultCanvasTextRender = __decorate$p([injectable(), __param$i(0, inject(ContributionProvider)), __param$i(0, named(TextRenderContribution)), __metadata$j("design:paramtypes", [Object])], DefaultCanvasTextRender);

	function drawPolygon(path, points, x, y) {
	  if (points && points.length) {
	    path.moveTo(points[0].x + x, points[0].y + y);
	    for (let i = 1; i < points.length; i++) path.lineTo(points[i].x + x, points[i].y + y);
	  }
	}
	function drawRoundedPolygon(path, points, x, y, cornerRadius, closePath = !0) {
	  var _a;
	  if (points.length < 3) return void drawPolygon(path, points, x, y);
	  let startI = 0,
	    endI = points.length - 1;
	  closePath || (startI += 1, endI -= 1, path.moveTo(points[0].x + x, points[0].y + y));
	  for (let i = startI; i <= endI; i++) {
	    const p1 = points[0 === i ? endI : (i - 1) % points.length],
	      angularPoint = points[i % points.length],
	      p2 = points[(i + 1) % points.length],
	      dx1 = angularPoint.x - p1.x,
	      dy1 = angularPoint.y - p1.y,
	      dx2 = angularPoint.x - p2.x,
	      dy2 = angularPoint.y - p2.y,
	      angle = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2,
	      tan = Math.abs(Math.tan(angle));
	    let radius = Array.isArray(cornerRadius) ? null !== (_a = cornerRadius[i % points.length]) && void 0 !== _a ? _a : 0 : cornerRadius,
	      segment = radius / tan;
	    const length1 = getLength(dx1, dy1),
	      length2 = getLength(dx2, dy2),
	      length = Math.min(length1, length2);
	    segment > length && (segment = length, radius = length * tan);
	    const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1),
	      p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2),
	      dx = 2 * angularPoint.x - p1Cross.x - p2Cross.x,
	      dy = 2 * angularPoint.y - p1Cross.y - p2Cross.y,
	      L = getLength(dx, dy),
	      circlePoint = getProportionPoint(angularPoint, getLength(segment, radius), L, dx, dy);
	    let startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);
	    const endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);
	    let sweepAngle = endAngle - startAngle;
	    sweepAngle < 0 && (startAngle = endAngle, sweepAngle = -sweepAngle), sweepAngle > Math.PI && (sweepAngle -= Math.PI), 0 === i ? path.moveTo(p1Cross.x + x, p1Cross.y + y) : path.lineTo(p1Cross.x + x, p1Cross.y + y), sweepAngle && path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius), path.lineTo(p2Cross.x + x, p2Cross.y + y);
	  }
	  closePath || path.lineTo(points[endI + 1].x + x, points[endI + 1].y + y);
	}
	function getLength(dx, dy) {
	  return Math.sqrt(dx * dx + dy * dy);
	}
	function getProportionPoint(point, segment, length, dx, dy) {
	  const factor = segment / length;
	  return {
	    x: point.x - dx * factor,
	    y: point.y - dy * factor
	  };
	}

	const defaultPolygonTextureRenderContribution = defaultBaseTextureRenderContribution;
	const defaultPolygonBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

	var __decorate$o = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$i = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$h = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasPolygonRender = class extends BaseRender {
	  constructor(graphicRenderContributions) {
	    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = POLYGON_NUMBER_TYPE, this.builtinContributions = [defaultPolygonBackgroundRenderContribution, defaultPolygonTextureRenderContribution], this.init(graphicRenderContributions);
	  }
	  drawShape(polygon, context, x, y, drawContext, params, fillCb, strokeCb) {
	    const polygonAttribute = getTheme(polygon, null == params ? void 0 : params.theme).polygon,
	      {
	        points = polygonAttribute.points,
	        cornerRadius = polygonAttribute.cornerRadius,
	        x: originX = polygonAttribute.x,
	        y: originY = polygonAttribute.y,
	        closePath = polygonAttribute.closePath,
	        fillStrokeOrder = polygonAttribute.fillStrokeOrder
	      } = polygon.attribute,
	      data = this.valid(polygon, polygonAttribute, fillCb, strokeCb);
	    if (!data) return;
	    const {
	      fVisible: fVisible,
	      sVisible: sVisible,
	      doFill: doFill,
	      doStroke: doStroke
	    } = data;
	    context.beginPath(), cornerRadius <= 0 || isArray$1(cornerRadius) && cornerRadius.every(num => 0 === num) ? drawPolygon(context.camera ? context : context.nativeContext, points, x, y) : drawRoundedPolygon(context.camera ? context : context.nativeContext, points, x, y, cornerRadius, closePath), closePath && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(polygon, polygon.attribute, polygonAttribute), this.beforeRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
	    const _runFill = () => {
	        doFill && (fillCb ? fillCb(context, polygon.attribute, polygonAttribute) : fVisible && (context.setCommonStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.fill()));
	      },
	      _runStroke = () => {
	        doStroke && (strokeCb ? strokeCb(context, polygon.attribute, polygonAttribute) : sVisible && (context.setStrokeStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.stroke()));
	      };
	    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
	  }
	  draw(polygon, renderService, drawContext, params) {
	    const polygonAttribute = getTheme(polygon, null == params ? void 0 : params.theme).polygon;
	    this._draw(polygon, polygonAttribute, !1, drawContext, params);
	  }
	};
	DefaultCanvasPolygonRender = __decorate$o([injectable(), __param$h(0, inject(ContributionProvider)), __param$h(0, named(PolygonRenderContribution)), __metadata$i("design:paramtypes", [Object])], DefaultCanvasPolygonRender);

	var __decorate$n = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$h = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$g = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	const repeatStr = ["", "repeat-x", "repeat-y", "repeat"];
	let DefaultCanvasImageRender = class extends BaseRender {
	  constructor(graphicRenderContributions) {
	    super(), this.graphicRenderContributions = graphicRenderContributions, this.numberType = IMAGE_NUMBER_TYPE, this.builtinContributions = [defaultImageRenderContribution, defaultImageBackgroundRenderContribution], this.init(graphicRenderContributions);
	  }
	  drawShape(image, context, x, y, drawContext, params, fillCb, strokeCb) {
	    const imageAttribute = getTheme(image).image,
	      {
	        repeatX = imageAttribute.repeatX,
	        repeatY = imageAttribute.repeatY,
	        x: originX = imageAttribute.x,
	        y: originY = imageAttribute.y,
	        cornerRadius = imageAttribute.cornerRadius,
	        fillStrokeOrder = imageAttribute.fillStrokeOrder,
	        cornerType = imageAttribute.cornerType,
	        image: url
	      } = image.attribute,
	      data = this.valid(image, imageAttribute, fillCb);
	    if (!data) return;
	    const {
	      fVisible: fVisible,
	      sVisible: sVisible,
	      doFill: doFill,
	      doStroke: doStroke
	    } = data;
	    if (!url || !image.resources) return;
	    const res = image.resources.get(url);
	    if ("success" !== res.state) return;
	    const width = image.width,
	      height = image.height;
	    context.beginPath();
	    let needRestore = !1;
	    0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(num => 0 === num) ? context.rect(x, y, width, height) : (createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType), needRestore = !0), context.setShadowBlendStyle && context.setShadowBlendStyle(image, image.attribute, imageAttribute);
	    const _runFill = () => {
	        if (doFill) if (fillCb) fillCb(context, image.attribute, imageAttribute);else if (fVisible) {
	          context.setCommonStyle(image, image.attribute, x, y, imageAttribute);
	          let repeat = 0;
	          if ("repeat" === repeatX && (repeat |= 1), "repeat" === repeatY && (repeat |= 2), repeat) {
	            const pattern = context.createPattern(res.data, repeatStr[repeat]);
	            context.fillStyle = pattern, context.translate(x, y, !0), context.fillRect(0, 0, width, height), context.translate(-x, -y, !0);
	          } else context.drawImage(res.data, x, y, width, height);
	        }
	      },
	      _runStroke = () => {
	        doStroke && (strokeCb ? strokeCb(context, image.attribute, imageAttribute) : sVisible && (context.setStrokeStyle(image, image.attribute, originX - x, originY - y, imageAttribute), context.stroke()));
	      };
	    fillStrokeOrder ? (_runStroke(), needRestore && (context.save(), context.clip()), this.beforeRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb), _runFill(), needRestore && context.restore()) : (needRestore && (context.save(), context.clip()), this.beforeRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb), _runFill(), needRestore && context.restore(), _runStroke()), this.afterRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb);
	  }
	  draw(image, renderService, drawContext) {
	    const {
	      image: url
	    } = image.attribute;
	    if (!url || !image.resources) return;
	    const res = image.resources.get(url);
	    if ("loading" === res.state && isString$1(url)) return void ResourceLoader.improveImageLoading(url);
	    if ("success" !== res.state) return;
	    const {
	      context: context
	    } = renderService.drawParams;
	    if (!context) return;
	    const imageAttribute = getTheme(image).image;
	    this._draw(image, imageAttribute, !1, drawContext);
	  }
	};
	DefaultCanvasImageRender = __decorate$n([injectable(), __param$g(0, inject(ContributionProvider)), __param$g(0, named(ImageRenderContribution)), __metadata$h("design:paramtypes", [Object])], DefaultCanvasImageRender);

	const ArcRender = Symbol.for("ArcRender");
	const Arc3dRender = Symbol.for("Arc3dRender");
	const GraphicRender = Symbol.for("GraphicRender");
	const LineRender = Symbol.for("LineRender");
	const PolygonRender = Symbol.for("PolygonRender");
	const RectRender = Symbol.for("RectRender");
	const Rect3DRender = Symbol.for("Rect3DRender");
	const SymbolRender = Symbol.for("SymbolRender");
	const TextRender = Symbol.for("TextRender");
	const RichTextRender = Symbol.for("RichTextRender");
	const Pyramid3dRender = Symbol.for("Pyramid3dRender");
	const ImageRender = Symbol.for("ImageRender");

	var __decorate$m = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var d,
	    c = arguments.length,
	    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	let DefaultIncrementalCanvasLineRender = class extends DefaultCanvasLineRender {
	  constructor() {
	    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
	  }
	  drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
	    if (line.incremental && drawContext.multiGraphicOptions) {
	      const {
	          startAtIdx: startAtIdx,
	          length: length
	        } = drawContext.multiGraphicOptions,
	        {
	          segments = []
	        } = line.attribute;
	      if (startAtIdx > segments.length) return;
	      const lineAttribute = getTheme(line).line,
	        {
	          fill = lineAttribute.fill,
	          stroke = lineAttribute.stroke,
	          opacity = lineAttribute.opacity,
	          fillOpacity = lineAttribute.fillOpacity,
	          strokeOpacity = lineAttribute.strokeOpacity,
	          lineWidth = lineAttribute.lineWidth,
	          visible = lineAttribute.visible
	        } = line.attribute,
	        fVisible = fillVisible(opacity, fillOpacity, fill),
	        sVisible = strokeVisible(opacity, strokeOpacity),
	        doFill = runFill(fill),
	        doStroke = runStroke(stroke, lineWidth);
	      if (!line.valid || !visible) return;
	      if (!doFill && !doStroke) return;
	      if (!(fVisible || sVisible || fillCb || strokeCb)) return;
	      const {
	        context: context
	      } = drawContext;
	      for (let i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(line, context, segments[i - 1], segments[i], line.attribute.segments[i], [lineAttribute, line.attribute], x, y);
	    } else super.drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb);
	  }
	  drawIncreaseSegment(line, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
	    seg && (context.beginPath(), drawIncrementalSegments(context.nativeContext, lastSeg, seg, {
	      offsetX: offsetX,
	      offsetY: offsetY
	    }), context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute), context.setStrokeStyle(line, attribute, offsetX, offsetY, defaultAttribute), context.stroke());
	  }
	};
	DefaultIncrementalCanvasLineRender = __decorate$m([injectable()], DefaultIncrementalCanvasLineRender);

	let _isBrowserEnv;
	function initIsBrowserEnv() {
	  if (null == _isBrowserEnv) try {
	    const canvas = document.createElement("canvas"),
	      ctx = canvas.getContext("2d");
	    _isBrowserEnv = !!(window && canvas.getBoundingClientRect && requestAnimationFrame && window.devicePixelRatio && ctx && ctx.isPointInPath && ctx.isPointInStroke), _isBrowserEnv && (_isBrowserEnv = !!document.createElement);
	  } catch (err) {
	    _isBrowserEnv = !1;
	  }
	}
	function isBrowserEnv() {
	  initIsBrowserEnv();
	  const env = application.global && application.global.env;
	  return env ? "browser" === env : _isBrowserEnv;
	}

	class Factory {
	  static registerPlugin(pluginKey, pluginClass) {
	    Factory._pluginClasses[pluginKey] = pluginClass;
	  }
	  static getPlugin(pluginKey) {
	    return Factory._pluginClasses[pluginKey];
	  }
	}
	Factory._pluginClasses = {};

	class DirectionalLight {
	  constructor(dir, color, ambient = .8) {
	    this.dir = dir, this.color = color, this.colorRgb = ColorStore.Get(color, ColorType.Color1), this.ambient = ambient;
	    const length = sqrt$1(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);
	    this.formatedDir = [dir[0] / length, dir[1] / length, dir[2] / length];
	  }
	  computeColor(normal, color) {
	    const lightDir = this.formatedDir,
	      brightness = min(max((normal[0] * lightDir[0] + normal[1] * lightDir[1] + normal[2] * lightDir[2]) * (1 - this.ambient / 2), 0) + this.ambient, 1);
	    let colorArray;
	    colorArray = isString$1(color) ? ColorStore.Get(color, ColorType.Color1) : color;
	    const lightColorArray = this.colorRgb;
	    return `rgb(${lightColorArray[0] * colorArray[0] * brightness}, ${lightColorArray[1] * colorArray[1] * brightness}, ${lightColorArray[2] * colorArray[2] * brightness})`;
	  }
	}
	const registerDirectionalLight = () => {
	  Factory.registerPlugin("DirectionalLight", DirectionalLight);
	};

	class OrthoCamera {
	  set params(params) {
	    this._params = Object.assign({}, params), this._projectionMatrixCached = this.forceGetProjectionMatrix(), this._viewMatrixCached = this.forceGetViewMatrix();
	  }
	  get params() {
	    return Object.assign({}, this._params);
	  }
	  constructor(params) {
	    this.params = params;
	  }
	  getViewMatrix() {
	    return this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate()), this._viewMatrixCached;
	  }
	  forceGetViewMatrix() {
	    this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate());
	    const {
	      pos: pos,
	      center: center,
	      up: up
	    } = this.params.viewParams;
	    return lookAt(this._viewMatrixCached, pos, center, up), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiplyMat4Mat4(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._viewMatrixCached;
	  }
	  getProjectionMatrix() {
	    return this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate()), this._projectionMatrixCached;
	  }
	  forceGetProjectionMatrix() {
	    this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate());
	    const {
	      left: left,
	      top: top,
	      right: right,
	      bottom: bottom
	    } = this._params;
	    return ortho(this._projectionMatrixCached, left, right, bottom, top, 0, -2e6), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiplyMat4Mat4(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._projectionMatrixCached;
	  }
	  getField() {
	    const {
	      fieldRatio = .8,
	      fieldDepth: fieldDepth,
	      left: left,
	      right: right
	    } = this._params;
	    return (null != fieldDepth ? fieldDepth : right - left) * fieldRatio;
	  }
	  getProjectionScale(z) {
	    const field = this.getField();
	    return field / (field + z);
	  }
	  view(x, y, z) {
	    const outP = [0, 0, 0];
	    return transformMat4(outP, [x, y, z], this._viewMatrixCached), outP;
	  }
	  vp(x, y, z) {
	    const outP = [0, 0, 0],
	      {
	        pos: pos
	      } = this._params.viewParams;
	    transformMat4(outP, [x, y, z], this._viewMatrixCached), x = outP[0], y = outP[1], z = outP[2];
	    const sizeProjection = this.getProjectionScale(z);
	    return {
	      x: x * sizeProjection + pos[0],
	      y: y * sizeProjection + pos[1]
	    };
	  }
	}
	const registerOrthoCamera = () => {
	  Factory.registerPlugin("OrthoCamera", OrthoCamera);
	};

	let loadArcModule = !1;
	const arcModule = new ContainerModule(bind => {
	  loadArcModule || (loadArcModule = !0, bind(DefaultCanvasArcRender).toSelf().inSingletonScope(), bind(ArcRender).to(DefaultCanvasArcRender).inSingletonScope(), bind(GraphicRender).toService(ArcRender), bind(ArcRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ArcRenderContribution));
	});

	let loadRectModule = !1;
	const rectModule = new ContainerModule(bind => {
	  loadRectModule || (loadRectModule = !0, bind(DefaultCanvasRectRender).toSelf().inSingletonScope(), bind(RectRender).to(DefaultCanvasRectRender).inSingletonScope(), bind(GraphicRender).toService(RectRender), bind(SplitRectAfterRenderContribution).toSelf(), bind(SplitRectBeforeRenderContribution).toSelf(), bind(RectRenderContribution).toService(SplitRectAfterRenderContribution), bind(RectRenderContribution).toService(SplitRectBeforeRenderContribution), bind(RectRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, RectRenderContribution));
	});

	let loadLineModule = !1;
	const lineModule = new ContainerModule(bind => {
	  loadLineModule || (loadLineModule = !0, bind(DefaultCanvasLineRender).toSelf().inSingletonScope(), bind(DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope(), bind(LineRender).to(DefaultCanvasLineRender).inSingletonScope(), bind(GraphicRender).toService(LineRender));
	});

	let loadSymbolModule = !1;
	const symbolModule = new ContainerModule(bind => {
	  loadSymbolModule || (loadSymbolModule = !0, bind(DefaultCanvasSymbolRender).toSelf().inSingletonScope(), bind(SymbolRender).to(DefaultCanvasSymbolRender).inSingletonScope(), bind(GraphicRender).toService(SymbolRender), bind(SymbolRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, SymbolRenderContribution));
	});

	let loadTextModule = !1;
	const textModule = new ContainerModule(bind => {
	  loadTextModule || (loadTextModule = !0, bind(TextRender).to(DefaultCanvasTextRender).inSingletonScope(), bind(GraphicRender).toService(TextRender), bind(TextRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, TextRenderContribution));
	});

	let loadPolygonModule = !1;
	const polygonModule = new ContainerModule(bind => {
	  loadPolygonModule || (loadPolygonModule = !0, bind(PolygonRender).to(DefaultCanvasPolygonRender).inSingletonScope(), bind(GraphicRender).toService(PolygonRender), bind(PolygonRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PolygonRenderContribution));
	});

	var __decorate$l = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$g = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  };
	let DefaultCanvasRichTextRender = class extends BaseRender {
	  constructor() {
	    super(), this.numberType = RICHTEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init();
	  }
	  drawShape(richtext, context, x, y, drawContext) {
	    const richtextAttribute = getTheme(richtext).richtext,
	      {
	        strokeOpacity = richtextAttribute.strokeOpacity,
	        opacity = richtextAttribute.opacity,
	        fillOpacity = richtextAttribute.fillOpacity,
	        visible = richtextAttribute.visible
	      } = richtext.attribute;
	    if (!richtext.valid || !visible) return;
	    const fVisible = fillVisible(opacity, fillOpacity, !0),
	      sVisible = fillVisible(opacity, strokeOpacity, !0);
	    if (!fVisible) return;
	    context.setShadowBlendStyle && context.setShadowBlendStyle(richtext, richtext.attribute, richtextAttribute), context.translate(x, y), this.beforeRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
	    richtext.getFrameCache().draw(context, this.drawIcon), this.afterRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
	  }
	  drawIcon(icon, context, x, y, baseline) {
	    var _a;
	    const richtextIconAttribute = getTheme(icon).richtextIcon,
	      {
	        width = richtextIconAttribute.width,
	        height = richtextIconAttribute.height,
	        opacity = richtextIconAttribute.opacity,
	        image: url,
	        backgroundFill = richtextIconAttribute.backgroundFill,
	        backgroundFillOpacity = richtextIconAttribute.backgroundFillOpacity,
	        backgroundStroke = richtextIconAttribute.backgroundStroke,
	        backgroundStrokeOpacity = richtextIconAttribute.backgroundStrokeOpacity,
	        backgroundRadius = richtextIconAttribute.backgroundRadius,
	        margin: margin
	      } = icon.attribute,
	      {
	        backgroundWidth = width,
	        backgroundHeight = height
	      } = icon.attribute;
	    if (margin && (x += icon._marginArray[3], y += icon._marginArray[0]), icon._hovered) {
	      const expandX = (backgroundWidth - width) / 2,
	        expandY = (backgroundHeight - height) / 2;
	      0 === backgroundRadius ? (context.beginPath(), context.rect(x - expandX, y - expandY, backgroundWidth, backgroundHeight)) : (context.beginPath(), createRectPath(context, x - expandX, y - expandY, backgroundWidth, backgroundHeight, backgroundRadius, !0)), backgroundFill && (context.globalAlpha = backgroundFillOpacity, context.fillStyle = backgroundFill, context.fill()), backgroundStroke && (context.globalAlpha = backgroundStrokeOpacity, context.strokeStyle = backgroundStroke, context.stroke());
	    }
	    const res = url && (null === (_a = null == icon ? void 0 : icon.resources) || void 0 === _a ? void 0 : _a.get(url));
	    res && "success" === res.state && (context.globalAlpha = opacity, context.drawImage(res.data, x, y, width, height));
	  }
	  draw(richtext, renderService, drawContext) {
	    const richtextAttribute = getTheme(richtext).richtext;
	    this._draw(richtext, richtextAttribute, !1, drawContext);
	  }
	};
	DefaultCanvasRichTextRender = __decorate$l([injectable(), __metadata$g("design:paramtypes", [])], DefaultCanvasRichTextRender);

	let loadRichtextModule = !1;
	const richtextModule = new ContainerModule(bind => {
	  loadRichtextModule || (loadRichtextModule = !0, bind(RichTextRender).to(DefaultCanvasRichTextRender).inSingletonScope(), bind(GraphicRender).toService(RichTextRender));
	});

	let loadImageModule = !1;
	const imageModule = new ContainerModule(bind => {
	  loadImageModule || (loadImageModule = !0, bind(ImageRender).to(DefaultCanvasImageRender).inSingletonScope(), bind(GraphicRender).toService(ImageRender), bind(ImageRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ImageRenderContribution));
	});

	class Base3dRender extends BaseRender {
	  stroke(x, y, z, face3d, context) {
	    const vertices = face3d.vertices;
	    face3d.edges.forEach(edge => {
	      const p1 = vertices[edge[0]],
	        v1 = {
	          x: x + p1[0],
	          y: y + p1[1],
	          z: z + p1[2]
	        },
	        p2 = vertices[edge[1]],
	        v2 = {
	          x: x + p2[0],
	          y: y + p2[1],
	          z: z + p2[2]
	        };
	      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.stroke();
	    });
	  }
	  fill(x, y, z, face3d, faces, fillColor, context, light, graphic3d, graphic3dAttribute, fillCb) {
	    const rgbArray = ColorStore.Get(fillColor, ColorType.Color255),
	      vertices = face3d.vertices,
	      viewdVerticesZ = vertices.map(v => context.view(v[0], v[1], v[2])[2]),
	      sortFace = [];
	    face3d.polygons.forEach((p, i) => {
	      if (faces && !faces[i]) return;
	      sortFace.push({
	        faceIdx: i,
	        polygon: p
	      });
	      const {
	          polygon: polygon
	        } = p,
	        z1 = viewdVerticesZ[polygon[0]],
	        z2 = viewdVerticesZ[polygon[1]],
	        z3 = viewdVerticesZ[polygon[2]],
	        z4 = viewdVerticesZ[polygon[3]];
	      p.ave_z = z1 + z2 + z3 + z4;
	    }), sortFace.sort((a, b) => b.polygon.ave_z - a.polygon.ave_z), sortFace.forEach(item => {
	      const {
	          polygon: polygon,
	          normal: normal
	        } = item.polygon,
	        p1 = vertices[polygon[0]],
	        p2 = vertices[polygon[1]],
	        p3 = vertices[polygon[2]],
	        p4 = vertices[polygon[3]],
	        v1 = {
	          x: x + p1[0],
	          y: y + p1[1],
	          z: z + p1[2]
	        },
	        v2 = {
	          x: x + p2[0],
	          y: y + p2[1],
	          z: z + p2[2]
	        },
	        v3 = {
	          x: x + p3[0],
	          y: y + p3[1],
	          z: z + p3[2]
	        },
	        v4 = {
	          x: x + p4[0],
	          y: y + p4[1],
	          z: z + p4[2]
	        };
	      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), fillCb ? fillCb(context, graphic3d && graphic3d.attribute, graphic3dAttribute) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, context.fill());
	    });
	  }
	}

	var __decorate$k = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var d,
	    c = arguments.length,
	    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	let DefaultCanvasRect3dRender = class extends Base3dRender {
	  constructor() {
	    super(...arguments), this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
	  }
	  drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {
	    var _a, _b;
	    const rectAttribute = getTheme(rect, null == params ? void 0 : params.theme).rect,
	      {
	        fill = rectAttribute.fill,
	        stroke = rectAttribute.stroke,
	        x1: x1,
	        y1: y1,
	        x: originX,
	        y: originY,
	        opacity = rectAttribute.opacity,
	        fillOpacity = rectAttribute.fillOpacity,
	        lineWidth = rectAttribute.lineWidth,
	        strokeOpacity = rectAttribute.strokeOpacity,
	        visible = rectAttribute.visible,
	        drawStrokeWhenZeroWH = null !== (_a = rectAttribute.drawStrokeWhenZeroWH) && void 0 !== _a && _a
	      } = rect.attribute;
	    let {
	      width: width,
	      height: height
	    } = rect.attribute;
	    width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0;
	    const z = null !== (_b = this.z) && void 0 !== _b ? _b : 0,
	      fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill),
	      sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height, drawStrokeWhenZeroWH),
	      doFill = runFill(fill),
	      doStroke = runStroke(stroke, lineWidth);
	    if (!rect.valid || !visible) return;
	    if (!doFill && !doStroke) return;
	    if (!(fVisible || sVisible || fillCb || strokeCb)) return;
	    const {
	        light: light
	      } = drawContext.stage || {},
	      face3d = rect.findFace();
	    if (!1 !== fill) {
	      context.setCommonStyle(rect, rect.attribute, x, y, rectAttribute);
	      let fc = fill;
	      "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, null, fc, context, light, null, null, fillCb);
	    }
	    !1 !== stroke && (context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute), this.stroke(x, y, z, face3d, context));
	  }
	  draw(rect, renderService, drawContext) {
	    const rectAttribute = getTheme(rect).rect;
	    this._draw(rect, rectAttribute, !1, drawContext);
	  }
	};
	DefaultCanvasRect3dRender = __decorate$k([injectable()], DefaultCanvasRect3dRender);

	let loadRect3dModule = !1;
	const rect3dModule = new ContainerModule(bind => {
	  loadRect3dModule || (loadRect3dModule = !0, bind(Rect3DRender).to(DefaultCanvasRect3dRender).inSingletonScope(), bind(GraphicRender).toService(Rect3DRender));
	});

	var __decorate$j = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var d,
	    c = arguments.length,
	    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	function drawArcPath(arc, context, cx, cy, z, outerRadius, innerRadius) {
	  const {
	      startAngle: startAngle,
	      endAngle: endAngle
	    } = arc.getParsedAngle(),
	    deltaAngle = abs(endAngle - startAngle),
	    clockwise = endAngle > startAngle;
	  let collapsedToLine = !1;
	  if (outerRadius < innerRadius) {
	    const temp = outerRadius;
	    outerRadius = innerRadius, innerRadius = temp;
	  }
	  if (outerRadius <= epsilon) context.moveTo(cx, cy, z);else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle), z), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle), z), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z));else {
	    const {
	        outerDeltaAngle: outerDeltaAngle,
	        innerDeltaAngle: innerDeltaAngle,
	        outerStartAngle: outerStartAngle,
	        outerEndAngle: outerEndAngle,
	        innerEndAngle: innerEndAngle,
	        innerStartAngle: innerStartAngle
	      } = arc.getParsePadAngle(startAngle, endAngle),
	      xors = outerRadius * cos(outerStartAngle),
	      yors = outerRadius * sin(outerStartAngle),
	      xire = innerRadius * cos(innerEndAngle),
	      yire = innerRadius * sin(innerEndAngle);
	    outerDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z)), !(innerRadius > epsilon) || innerDeltaAngle < .001 ? (context.lineTo(cx + xire, cy + yire, z), collapsedToLine = !0) : (context.lineTo(cx + xire, cy + yire, z), context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z));
	  }
	  return context.closePath(), collapsedToLine;
	}
	function drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {
	  const {
	      startAngle: startAngle,
	      endAngle: endAngle
	    } = arc.getParsedAngle(),
	    deltaAngle = abs(endAngle - startAngle),
	    clockwise = endAngle > startAngle;
	  let collapsedToLine = !1;
	  if (radius <= epsilon) context.moveTo(cx, cy, z1);else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + radius * cos(startAngle), cy + radius * sin(startAngle), z1), context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1), context.lineTo(cx + radius * cos(endAngle), cy + radius * sin(endAngle), z2), context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2);else {
	    const {
	        innerouterDeltaAngle: innerouterDeltaAngle,
	        innerouterStartAngle: innerouterStartAngle,
	        innerouterEndAngle: innerouterEndAngle
	      } = getParsePadAngle(startAngle, endAngle),
	      xors = radius * cos(innerouterStartAngle),
	      yors = radius * sin(innerouterStartAngle),
	      xore = radius * cos(innerouterEndAngle),
	      yore = radius * sin(innerouterEndAngle);
	    innerouterDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z1), context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1), context.lineTo(cx + xore, cy + yore, z2), context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2));
	  }
	  return context.closePath(), collapsedToLine;
	}
	let DefaultCanvasArc3DRender = class extends BaseRender {
	  constructor() {
	    super(...arguments), this.numberType = ARC3D_NUMBER_TYPE;
	  }
	  drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
	    var _a;
	    const arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc,
	      {
	        fill = arcAttribute.fill
	      } = arc.attribute,
	      data = this.valid(arc, arcAttribute, fillCb, strokeCb);
	    if (!data) return;
	    const {
	        fVisible: fVisible,
	        sVisible: sVisible,
	        doFill: doFill,
	        doStroke: doStroke
	      } = data,
	      z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
	      {
	        outerPadding = arcAttribute.outerPadding,
	        innerPadding = arcAttribute.innerPadding,
	        height = 10
	      } = arc.attribute;
	    let {
	      outerRadius = arcAttribute.outerRadius,
	      innerRadius = arcAttribute.innerRadius
	    } = arc.attribute;
	    outerRadius += outerPadding, innerRadius -= innerPadding;
	    const rgbArray = ColorStore.Get(fill, ColorType.Color255),
	      {
	        light: light
	      } = drawContext.stage || {},
	      face = drawContext.hack_pieFace,
	      z_face = {
	        top: z,
	        bottom: z + height
	      },
	      n_face = {
	        top: [0, 1, 0],
	        bottom: [0, -1, 0],
	        outside: [1, 0, -1],
	        inside: [1, 0, -1]
	      };
	    "bottom" === face || "top" === face ? (context.beginPath(), drawArcPath(arc, context, x, y, z_face[face], outerRadius, innerRadius), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()))) : "outside" !== face && "inside" !== face || ("inside" === face && (context.save(), context.beginPath(), context.arc(x, y, innerRadius, 0, pi2, !0, z_face.top), context.clip()), context.beginPath(), drawInnerOuterArcPath(arc, context, x, y, z_face.top, z_face.bottom, "outside" === face ? outerRadius : innerRadius, (startAngle, endAngle) => {
	      const {
	        outerDeltaAngle: outerDeltaAngle,
	        innerDeltaAngle: innerDeltaAngle,
	        outerStartAngle: outerStartAngle,
	        outerEndAngle: outerEndAngle,
	        innerEndAngle: innerEndAngle,
	        innerStartAngle: innerStartAngle
	      } = arc.getParsePadAngle(startAngle, endAngle);
	      return "outside" === face ? {
	        innerouterDeltaAngle: outerDeltaAngle,
	        innerouterEndAngle: outerEndAngle,
	        innerouterStartAngle: outerStartAngle
	      } : {
	        innerouterDeltaAngle: innerDeltaAngle,
	        innerouterEndAngle: innerEndAngle,
	        innerouterStartAngle: innerStartAngle
	      };
	    }), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke())), "inside" === face && context.restore());
	  }
	  draw(arc, renderService, drawContext, params) {
	    const arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc;
	    this._draw(arc, arcAttribute, !1, drawContext, params);
	  }
	};
	DefaultCanvasArc3DRender = __decorate$j([injectable()], DefaultCanvasArc3DRender);

	let loadArc3dModule = !1;
	const arc3dModule = new ContainerModule(bind => {
	  loadArc3dModule || (loadArc3dModule = !0, bind(Arc3dRender).to(DefaultCanvasArc3DRender).inSingletonScope(), bind(GraphicRender).toService(Arc3dRender));
	});

	var __decorate$i = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var d,
	    c = arguments.length,
	    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	let DefaultCanvasPyramid3dRender = class extends Base3dRender {
	  constructor() {
	    super(...arguments), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
	  }
	  drawShape(pyramid3d, context, x, y, drawContext, params, fillCb, strokeCb) {
	    var _a;
	    const pyramidAttribute = getTheme(pyramid3d, null == params ? void 0 : params.theme).polygon,
	      {
	        fill = pyramidAttribute.fill,
	        stroke = pyramidAttribute.stroke,
	        face = [!0, !0, !0, !0, !0, !0]
	      } = pyramid3d.attribute,
	      z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
	    if (!this.valid(pyramid3d, pyramidAttribute, fillCb, strokeCb)) return;
	    const {
	        light: light
	      } = drawContext.stage || {},
	      face3d = pyramid3d.findFace();
	    if (!1 !== fill) {
	      context.setCommonStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute);
	      let fc = fill;
	      "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, face, fc, context, light, pyramid3d, pyramidAttribute, fillCb);
	    }
	    !1 !== stroke && (context.setStrokeStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute), this.stroke(x, y, z, face3d, context));
	  }
	  draw(pyramid3d, renderService, drawContext) {
	    const pyramid3dAttribute = getTheme(pyramid3d).polygon;
	    this._draw(pyramid3d, pyramid3dAttribute, !1, drawContext);
	  }
	};
	DefaultCanvasPyramid3dRender = __decorate$i([injectable()], DefaultCanvasPyramid3dRender);

	let loadPyramid3dModule = !1;
	const pyramid3dModule = new ContainerModule(bind => {
	  loadPyramid3dModule || (loadPyramid3dModule = !0, bind(Pyramid3dRender).to(DefaultCanvasPyramid3dRender).inSingletonScope(), bind(GraphicRender).toService(Pyramid3dRender));
	});

	function registerArcGraphic() {
	  graphicCreator.RegisterGraphicCreator("arc", createArc);
	}

	function registerArc3dGraphic() {
	  graphicCreator.RegisterGraphicCreator("arc3d", createArc3d);
	}

	function registerGroupGraphic() {
	  graphicCreator.RegisterGraphicCreator("group", createGroup);
	}

	function registerImageGraphic() {
	  graphicCreator.RegisterGraphicCreator("image", createImage);
	}

	function registerLineGraphic() {
	  graphicCreator.RegisterGraphicCreator("line", createLine);
	}

	function registerPolygonGraphic() {
	  graphicCreator.RegisterGraphicCreator("polygon", createPolygon);
	}

	function registerPyramid3dGraphic() {
	  graphicCreator.RegisterGraphicCreator("pyramid3d", createPyramid3d);
	}

	function registerRectGraphic() {
	  graphicCreator.RegisterGraphicCreator("rect", createRect);
	}

	function registerRect3dGraphic() {
	  graphicCreator.RegisterGraphicCreator("rect3d", createRect3d);
	}

	function registerRichtextGraphic() {
	  graphicCreator.RegisterGraphicCreator("richtext", createRichText);
	}

	function registerSymbolGraphic() {
	  graphicCreator.RegisterGraphicCreator("symbol", createSymbol);
	}

	function registerTextGraphic() {
	  graphicCreator.RegisterGraphicCreator("text", createText);
	}

	function registerShadowRootGraphic() {
	  graphicCreator.RegisterGraphicCreator("shadowRoot", createShadowRoot);
	}

	class ViewTransform3dPlugin {
	  constructor() {
	    this.name = "ViewTransform3dPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.onMouseDown = e => {
	      this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = !0, this.pageX = e.page.x, this.pageY = e.page.y);
	    }, this.onMouseUp = e => {
	      this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = !1);
	    }, this.onMouseMove = e => {
	      var _a, _b;
	      const stage = this.pluginService.stage;
	      if (this.option3d || (this.option3d = stage.option3d), this.option3d && this.mousedown) if (this.pageX && this.pageY) {
	        const deltaX = e.page.x - this.pageX,
	          deltaY = e.page.y - this.pageY;
	        this.pageX = e.page.x, this.pageY = e.page.y;
	        const angle1 = deltaX / 100,
	          angle2 = deltaY / 100;
	        this.option3d.alpha = (null !== (_a = this.option3d.alpha) && void 0 !== _a ? _a : 0) + angle1, this.option3d.beta = (null !== (_b = this.option3d.beta) && void 0 !== _b ? _b : 0) + angle2, stage.set3dOptions(this.option3d), stage.renderNextFrame();
	      } else this.pageX = e.page.x, this.pageY = e.page.y;
	    };
	  }
	  activate(context) {
	    this.pluginService = context;
	    const stage = context.stage;
	    this.option3d = stage.option3d, stage.addEventListener("mousedown", this.onMouseDown), stage.addEventListener("mouseup", this.onMouseUp), stage.addEventListener("mousemove", this.onMouseMove);
	  }
	  deactivate(context) {
	    const stage = context.stage;
	    stage.removeEventListener("mousedown", this.onMouseDown), stage.removeEventListener("mouseup", this.onMouseUp), stage.removeEventListener("mousemove", this.onMouseMove);
	  }
	}
	const registerViewTransform3dPlugin = () => {
	  Factory.registerPlugin("ViewTransform3dPlugin", ViewTransform3dPlugin);
	};

	const is3DChartType = (type) => {
	    return (type === "bar3d" ||
	        type === "funnel3d" ||
	        type === "histogram3d" ||
	        type === "pie3d" ||
	        type === "rangeColumn3d" ||
	        type === "wordCloud3d");
	};
	const is3DAxisChart = (spec) => {
	    return spec.zField || (spec.series && spec.series.some((s) => s.zField));
	};
	const is3DChart = (spec) => {
	    if (!spec) {
	        return false;
	    }
	    if (is3DChartType(spec.type)) {
	        return true;
	    }
	    if (is3DAxisChart(spec)) {
	        return true;
	    }
	    return true;
	};

	class VChart3dPlugin extends vchart.BasePlugin {
	    constructor() {
	        super(VChart3dPlugin.type);
	        this.type = 'VChart3dPlugin';
	    }
	    onInit(service, chartSpec) {
	        var _a;
	        this._is3d = is3DChart(chartSpec);
	        if (this._is3d) {
	            const { globalInstance } = service;
	            const stage = globalInstance.getCompiler().getStage();
	            stage.set3dOptions(Object.assign({}, (_a = globalInstance._option) === null || _a === void 0 ? void 0 : _a.options3d));
	        }
	    }
	    onBeforeInitChart(service, chartSpec, actionSource) {
	        if (!this._is3d) {
	            return;
	        }
	        if (is3DAxisChart(chartSpec)) {
	            chartSpec.layout = {
	                type: 'layout3d'
	            };
	        }
	    }
	}
	VChart3dPlugin.pluginType = 'chart';
	VChart3dPlugin.type = 'VChart3dPlugin';
	const register3DPlugin = () => {
	    vchart.registerChartPlugin(VChart3dPlugin);
	    registerDirectionalLight();
	    registerOrthoCamera();
	    registerViewTransform3dPlugin();
	};

	const bar3dSeriesMark = {
	    ["label"]: { name: "label", type: "text" },
	    ["bar3d"]: { name: "bar3d", type: "rect3d" }
	};

	class Bar3dSeriesSpecTransformer extends vchart.BarSeriesSpecTransformer {
	    _transformLabelSpec(spec) {
	        this._addMarkLabelSpec(spec, "bar3d");
	    }
	}

	const registerBar3dAnimation = () => {
	    vchart.Factory.registerAnimation('bar3d', (params, preset) => {
	        return {
	            appear: vchart.barPresetAnimation(params, preset),
	            enter: vchart.barGrowIn(params, false),
	            exit: vchart.barGrowOut(params, false),
	            disappear: vchart.barGrowOut(params)
	        };
	    });
	};

	const MathPickerContribution = Symbol.for("MathPickerContribution");
	const MathArcPicker = Symbol.for("MathArcPicker");
	const MathImagePicker = Symbol.for("MathImagePicker");
	const MathLinePicker = Symbol.for("MathLinePicker");
	const MathRectPicker = Symbol.for("MathRectPicker");
	const MathSymbolPicker = Symbol.for("MathSymbolPicker");
	const MathTextPicker = Symbol.for("MathTextPicker");
	const MathPolygonPicker = Symbol.for("MathPolygonPicker");
	const CanvasArcPicker = Symbol.for("CanvasArcPicker");
	const CanvasArc3dPicker = Symbol.for("CanvasArc3dPicker");
	const CanvasImagePicker = Symbol.for("CanvasImagePicker");
	const CanvasLinePicker = Symbol.for("CanvasLinePicker");
	const CanvasRectPicker = Symbol.for("CanvasRectPicker");
	const CanvasRect3dPicker = Symbol.for("CanvasRect3dPicker");
	const CanvasSymbolPicker = Symbol.for("CanvasSymbolPicker");
	const CanvasTextPicker = Symbol.for("CanvasTextPicker");
	const CanvasPolygonPicker = Symbol.for("CanvasPolygonPicker");
	const CanvasPyramid3dPicker = Symbol.for("CanvasPyramid3dPicker");
	const CanvasRichTextPicker = Symbol.for("CanvasRichTextPicker");
	const CanvasPickerContribution = Symbol.for("CanvasPickerContribution");

	class PickerBase {
	  contains(graphic, point, params) {
	    if (!graphic.AABBBounds.containsPoint(point)) return !1;
	    if ("imprecise" === graphic.attribute.pickMode) return !0;
	    if (!this.canvasRenderer) return !0;
	    const {
	      pickContext: pickContext
	    } = null != params ? params : {};
	    if (!pickContext) return !1;
	    const attribute = graphic.getGraphicTheme();
	    pickContext.highPerformanceSave();
	    let {
	      x = attribute.x,
	      y = attribute.y
	    } = graphic.attribute;
	    if (graphic.transMatrix.onlyTranslate()) {
	      const point = graphic.getOffsetXY(attribute);
	      x += point.x, y += point.y, pickContext.setTransformForCurrent();
	    } else x = 0, y = 0, pickContext.transformFromMatrix(graphic.transMatrix, !0);
	    let picked = !1,
	      _final = !1;
	    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, {}, null, (context, arcAttribute, themeAttribute, final) => !(!picked && !_final) || (picked = context.isPointInPath(point.x, point.y), _final = final || _final, picked), (context, arcAttribute, themeAttribute, final) => {
	      if (picked || _final) return !0;
	      const lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth,
	        pickStrokeBuffer = arcAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
	        keepStrokeScale = arcAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
	      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), _final = final || _final, picked;
	    }), pickContext.highPerformanceRestore(), picked;
	  }
	}

	var __decorate$h = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$f = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$f = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultMathArcPicker = class extends PickerBase {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
	  }
	};
	DefaultMathArcPicker = __decorate$h([injectable(), __param$f(0, inject(ArcRender)), __metadata$f("design:paramtypes", [Object])], DefaultMathArcPicker);

	let loadArcPick$1 = !1;
	const arcMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadArcPick$1 || (loadArcPick$1 = !0, bind(MathArcPicker).to(DefaultMathArcPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathArcPicker));
	});

	var __decorate$g = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var d,
	    c = arguments.length,
	    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	let DefaultMathImagePicker = class {
	  constructor() {
	    this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
	  }
	  contains(image, point, params) {
	    const {
	      pickContext: pickContext
	    } = null != params ? params : {};
	    return !!pickContext && !!image.AABBBounds.containsPoint(point);
	  }
	};
	DefaultMathImagePicker = __decorate$g([injectable()], DefaultMathImagePicker);

	let loadImagePick$1 = !1;
	const imageMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadImagePick$1 || (loadImagePick$1 = !0, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
	});

	var __decorate$f = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$e = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$e = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultMathLinePicker = class extends PickerBase {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
	  }
	};
	DefaultMathLinePicker = __decorate$f([injectable(), __param$e(0, inject(LineRender)), __metadata$e("design:paramtypes", [Object])], DefaultMathLinePicker);

	let loadLinePick$1 = !1;
	const lineMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadLinePick$1 || (loadLinePick$1 = !0, bind(MathLinePicker).to(DefaultMathLinePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathLinePicker));
	});

	var __decorate$e = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$d = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$d = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultMathPolygonPicker = class extends PickerBase {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
	  }
	};
	DefaultMathPolygonPicker = __decorate$e([injectable(), __param$d(0, inject(PolygonRender)), __metadata$d("design:paramtypes", [Object])], DefaultMathPolygonPicker);

	let loadPolygonPick$1 = !1;
	const polygonMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadPolygonPick$1 || (loadPolygonPick$1 = !0, bind(MathPolygonPicker).to(DefaultMathPolygonPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPolygonPicker));
	});

	const _bounds = new AABBBounds();
	class RectPickerBase {
	  constructor() {
	    this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
	  }
	  contains(rect, point, params) {
	    if (!rect.AABBBounds.containsPoint(point)) return !1;
	    if ("imprecise" === rect.attribute.pickMode) return !0;
	    const {
	      pickContext: pickContext
	    } = null != params ? params : {};
	    if (!pickContext) return !1;
	    const rectAttribute = rect.getGraphicTheme(),
	      {
	        cornerRadius = rectAttribute.cornerRadius
	      } = rect.attribute;
	    let {
	      x = rectAttribute.x,
	      y = rectAttribute.y
	    } = rect.attribute;
	    pickContext.highPerformanceSave();
	    let onlyTranslate = !0;
	    if (rect.transMatrix.onlyTranslate()) {
	      const point = rect.getOffsetXY(rectAttribute);
	      x += point.x, y += point.y, pickContext.setTransformForCurrent();
	    } else x = 0, y = 0, onlyTranslate = !1, pickContext.transformFromMatrix(rect.transMatrix, !0);
	    let picked = !0;
	    if (!onlyTranslate || rect.shadowRoot || isNumber$1(cornerRadius, !0) && 0 !== cornerRadius || isArray$1(cornerRadius) && cornerRadius.some(num => 0 !== num)) picked = !1, this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, (context, rectAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), picked), (context, rectAttribute, themeAttribute) => {
	      if (picked) return !0;
	      const lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth,
	        pickStrokeBuffer = rectAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
	        keepStrokeScale = rectAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
	      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), picked;
	    });else {
	      const {
	        fill = rectAttribute.fill,
	        stroke = rectAttribute.stroke,
	        lineWidth = rectAttribute.lineWidth
	      } = rect.attribute;
	      if (fill) picked = !0;else if (stroke) {
	        const bounds = rect.AABBBounds;
	        _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), picked = !_bounds.containsPoint(point);
	      }
	    }
	    return pickContext.highPerformanceRestore(), picked;
	  }
	}

	var __decorate$d = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$c = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$c = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultMathRectPicker = class extends RectPickerBase {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer;
	  }
	};
	DefaultMathRectPicker = __decorate$d([injectable(), __param$c(0, inject(RectRender)), __metadata$c("design:paramtypes", [Object])], DefaultMathRectPicker);

	let loadRectPick$1 = !1;
	const rectMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadRectPick$1 || (loadRectPick$1 = !0, bind(MathRectPicker).to(DefaultMathRectPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathRectPicker));
	});

	let loadRichTextPick = !1;
	const richTextMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadRichTextPick || (loadRichTextPick = !0, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
	});

	var __decorate$c = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$b = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$b = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultMathSymbolPicker = class extends PickerBase {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
	  }
	};
	DefaultMathSymbolPicker = __decorate$c([injectable(), __param$b(0, inject(SymbolRender)), __metadata$b("design:paramtypes", [Object])], DefaultMathSymbolPicker);

	let loadSymbolPick$1 = !1;
	const symbolMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadSymbolPick$1 || (loadSymbolPick$1 = !0, bind(MathSymbolPicker).to(DefaultMathSymbolPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathSymbolPicker));
	});

	var __decorate$b = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	  var d,
	    c = arguments.length,
	    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	  return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	let DefaultMathTextPicker = class {
	  constructor() {
	    this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
	  }
	  contains(text, point, params) {
	    return !!text.AABBBounds.containsPoint(point);
	  }
	};
	DefaultMathTextPicker = __decorate$b([injectable()], DefaultMathTextPicker);

	let loadTextPick$1 = !1;
	const textMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadTextPick$1 || (loadTextPick$1 = !0, bind(MathTextPicker).to(DefaultMathTextPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathTextPicker));
	});

	var __decorate$a = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$a = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$a = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasArcPicker = class extends PickerBase {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
	  }
	};
	DefaultCanvasArcPicker = __decorate$a([injectable(), __param$a(0, inject(ArcRender)), __metadata$a("design:paramtypes", [Object])], DefaultCanvasArcPicker);

	let loadArcPick = !1;
	const arcCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadArcPick || (loadArcPick = !0, bind(CanvasArcPicker).to(DefaultCanvasArcPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArcPicker));
	});

	var __decorate$9 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$9 = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$9 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasRectPicker = class extends RectPickerBase {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer;
	  }
	};
	DefaultCanvasRectPicker = __decorate$9([injectable(), __param$9(0, inject(RectRender)), __metadata$9("design:paramtypes", [Object])], DefaultCanvasRectPicker);

	let loadRectPick = !1;
	const rectCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadRectPick || (loadRectPick = !0, bind(CanvasRectPicker).to(DefaultCanvasRectPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRectPicker));
	});

	class BaseLinePicker extends BaseRender {
	  contains(graphic, point, params) {
	    if (!graphic.AABBBounds.containsPoint(point)) return !1;
	    if ("imprecise" === graphic.attribute.pickMode) return !0;
	    const {
	      pickContext: pickContext
	    } = null != params ? params : {};
	    if (!pickContext) return !1;
	    pickContext.highPerformanceSave();
	    const lineAttribute = graphic.getGraphicTheme(),
	      data = this.transform(graphic, lineAttribute, pickContext),
	      {
	        x: x,
	        y: y,
	        z: z,
	        lastModelMatrix: lastModelMatrix
	      } = data;
	    let pickPoint = point;
	    if (pickContext.camera) {
	      pickPoint = point.clone();
	      const globalMatrix = graphic.parent.globalTransMatrix;
	      pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
	    }
	    this.canvasRenderer.z = z;
	    let picked = !1;
	    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, {}, null, context => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, lineAttribute, themeAttribute) => {
	      if (picked) return !0;
	      const lineWidth = lineAttribute.lineWidth || themeAttribute.lineWidth,
	        pickStrokeBuffer = lineAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
	        keepStrokeScale = lineAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
	      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
	    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
	  }
	}

	var __decorate$8 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$8 = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$8 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasLinePicker = class extends BaseLinePicker {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
	  }
	};
	DefaultCanvasLinePicker = __decorate$8([injectable(), __param$8(0, inject(LineRender)), __metadata$8("design:paramtypes", [Object])], DefaultCanvasLinePicker);

	let loadLinePick = !1;
	const lineCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadLinePick || (loadLinePick = !0, bind(CanvasLinePicker).to(DefaultCanvasLinePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasLinePicker));
	});

	class Base3dPicker extends BaseRender {
	  contains(graphic, point, params) {
	    const {
	      pickContext: pickContext
	    } = null != params ? params : {};
	    if (!pickContext) return !1;
	    const attribute = graphic.getGraphicTheme();
	    pickContext.highPerformanceSave();
	    const data = this.transform(graphic, attribute, pickContext),
	      {
	        x: x,
	        y: y,
	        z: z,
	        lastModelMatrix: lastModelMatrix
	      } = data;
	    let pickPoint = point;
	    if (pickContext.camera) {
	      pickPoint = point.clone();
	      const globalMatrix = graphic.parent.globalTransMatrix;
	      pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
	    }
	    this.canvasRenderer.z = z;
	    let picked = !1;
	    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, params, null, (context, arc3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked)), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
	  }
	}

	var __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$7 = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$7 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasSymbolPicker = class extends Base3dPicker {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
	  }
	  contains(symbol, point, params) {
	    const {
	      pickContext: pickContext
	    } = null != params ? params : {};
	    if (!pickContext) return !1;
	    const parsedPath = symbol.getParsedPath();
	    if (!pickContext.camera) {
	      if (!symbol.AABBBounds.containsPoint(point)) return !1;
	      if (parsedPath.isSvg || "imprecise" === symbol.attribute.pickMode) return !0;
	    }
	    pickContext.highPerformanceSave();
	    const symbolAttribute = symbol.getGraphicTheme(),
	      data = this.transform(symbol, symbolAttribute, pickContext),
	      {
	        x: x,
	        y: y,
	        z: z,
	        lastModelMatrix: lastModelMatrix
	      } = data;
	    let pickPoint = point;
	    if (pickContext.camera) {
	      pickPoint = point.clone();
	      const globalMatrix = symbol.parent.globalTransMatrix;
	      pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
	    }
	    this.canvasRenderer.z = z;
	    let picked = !1;
	    return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, symbolAttribute, themeAttribute) => {
	      if (picked) return !0;
	      const lineWidth = symbolAttribute.lineWidth || themeAttribute.lineWidth,
	        pickStrokeBuffer = symbolAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
	        keepStrokeScale = symbolAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
	      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
	    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
	  }
	};
	DefaultCanvasSymbolPicker = __decorate$7([injectable(), __param$7(0, inject(SymbolRender)), __metadata$7("design:paramtypes", [Object])], DefaultCanvasSymbolPicker);

	let loadSymbolPick = !1;
	const symbolCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadSymbolPick || (loadSymbolPick = !0, bind(CanvasSymbolPicker).to(DefaultCanvasSymbolPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasSymbolPicker));
	});

	var __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$6 = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$6 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasTextPicker = class extends Base3dPicker {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
	  }
	  contains(text, point, params) {
	    const {
	      pickContext: pickContext
	    } = null != params ? params : {};
	    if (!pickContext) return !1;
	    const bounds = text.AABBBounds;
	    if (!pickContext.camera) return !!bounds.containsPoint(point);
	    pickContext.highPerformanceSave();
	    const textAttribute = text.getGraphicTheme(),
	      {
	        keepDirIn3d = textAttribute.keepDirIn3d
	      } = text.attribute,
	      computed3dMatrix = !keepDirIn3d,
	      data = this.transform(text, textAttribute, pickContext, computed3dMatrix),
	      {
	        x: x,
	        y: y,
	        z: z,
	        lastModelMatrix: lastModelMatrix
	      } = data;
	    this.canvasRenderer.z = z;
	    let pickPoint = point;
	    if (pickContext.camera) {
	      pickPoint = point.clone();
	      const globalMatrix = text.parent.globalTransMatrix;
	      pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
	    }
	    let picked = !1;
	    return this.canvasRenderer.drawShape(text, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => {
	      if (picked) return !0;
	      const {
	          fontSize = textAttribute.fontSize,
	          textBaseline = textAttribute.textBaseline,
	          textAlign = textAttribute.textAlign
	        } = text.attribute,
	        bounds = text.AABBBounds,
	        height = bounds.height(),
	        width = bounds.width(),
	        offsetY = textLayoutOffsetY(textBaseline, height, fontSize),
	        offsetX = textDrawOffsetX(textAlign, width);
	      return context.rect(offsetX + x, offsetY + y, width, height, z), picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked;
	    }, (context, symbolAttribute, themeAttribute) => picked), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
	  }
	};
	DefaultCanvasTextPicker = __decorate$6([injectable(), __param$6(0, inject(TextRender)), __metadata$6("design:paramtypes", [Object])], DefaultCanvasTextPicker);

	let loadTextPick = !1;
	const textCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadTextPick || (loadTextPick = !0, bind(CanvasTextPicker).to(DefaultCanvasTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasTextPicker));
	});

	var __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$5 = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$5 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasPolygonPicker = class extends PickerBase {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
	  }
	};
	DefaultCanvasPolygonPicker = __decorate$5([injectable(), __param$5(0, inject(PolygonRender)), __metadata$5("design:paramtypes", [Object])], DefaultCanvasPolygonPicker);

	let loadPolygonPick = !1;
	const polygonCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadPolygonPick || (loadPolygonPick = !0, bind(CanvasPolygonPicker).to(DefaultCanvasPolygonPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPolygonPicker));
	});

	var __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$4 = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$4 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasRichTextPicker = class {
	  constructor(canvasRenderer) {
	    this.canvasRenderer = canvasRenderer, this.type = "richtext", this.numberType = RICHTEXT_NUMBER_TYPE;
	  }
	  contains(richtext, point, params) {
	    return !!richtext.AABBBounds.containsPoint(point);
	  }
	};
	DefaultCanvasRichTextPicker = __decorate$4([injectable(), __param$4(0, inject(RichTextRender)), __metadata$4("design:paramtypes", [Object])], DefaultCanvasRichTextPicker);

	let loadRichtextPick = !1;
	const richtextCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadRichtextPick || (loadRichtextPick = !0, bind(CanvasRichTextPicker).to(DefaultCanvasRichTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRichTextPicker));
	});

	var __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$3 = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$3 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasImagePicker = class extends PickerBase {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
	  }
	};
	DefaultCanvasImagePicker = __decorate$3([injectable(), __param$3(0, inject(ImageRender)), __metadata$3("design:paramtypes", [Object])], DefaultCanvasImagePicker);

	let loadImagePick = !1;
	const imageCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadImagePick || (loadImagePick = !0, bind(CanvasImagePicker).to(DefaultCanvasImagePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasImagePicker));
	});

	var __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$2 = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$2 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasRect3dPicker = class extends Base3dPicker {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE, this.themeType = "rect";
	  }
	};
	DefaultCanvasRect3dPicker = __decorate$2([injectable(), __param$2(0, inject(Rect3DRender)), __metadata$2("design:paramtypes", [Object])], DefaultCanvasRect3dPicker);

	let loadRect3dPick = !1;
	const rect3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadRect3dPick || (loadRect3dPick = !0, bind(CanvasRect3dPicker).to(DefaultCanvasRect3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRect3dPicker));
	});

	var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata$1 = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param$1 = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasArc3dPicker = class extends Base3dPicker {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "arc3d", this.numberType = ARC3D_NUMBER_TYPE, this.themeType = "arc";
	  }
	};
	DefaultCanvasArc3dPicker = __decorate$1([injectable(), __param$1(0, inject(Arc3dRender)), __metadata$1("design:paramtypes", [Object])], DefaultCanvasArc3dPicker);

	let loadArc3dPick = !1;
	const arc3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadArc3dPick || (loadArc3dPick = !0, bind(CanvasArc3dPicker).to(DefaultCanvasArc3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArc3dPicker));
	});

	var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
	    var d,
	      c = arguments.length,
	      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
	    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	  },
	  __metadata = undefined && undefined.__metadata || function (k, v) {
	    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
	  },
	  __param = undefined && undefined.__param || function (paramIndex, decorator) {
	    return function (target, key) {
	      decorator(target, key, paramIndex);
	    };
	  };
	let DefaultCanvasPyramid3dPicker = class extends Base3dPicker {
	  constructor(canvasRenderer) {
	    super(), this.canvasRenderer = canvasRenderer, this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE, this.themeType = "polygon";
	  }
	};
	DefaultCanvasPyramid3dPicker = __decorate([injectable(), __param(0, inject(Pyramid3dRender)), __metadata("design:paramtypes", [Object])], DefaultCanvasPyramid3dPicker);

	let loadPyramid3dPick = !1;
	const pyramid3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
	  loadPyramid3dPick || (loadPyramid3dPick = !0, bind(CanvasPyramid3dPicker).to(DefaultCanvasPyramid3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPyramid3dPicker));
	});

	const browser = isBrowserEnv();

	function _registerArc() {
	  _registerArc.__loaded || (_registerArc.__loaded = !0, registerArcGraphic(), container.load(arcModule), container.load(browser ? arcCanvasPickModule : arcMathPickModule));
	}
	_registerArc.__loaded = !1;
	const registerArc = _registerArc;

	function _registerArc3d() {
	  _registerArc3d.__loaded || (_registerArc3d.__loaded = !0, registerArc3dGraphic(), registerDirectionalLight(), registerOrthoCamera(), container.load(arc3dModule), container.load(arc3dCanvasPickModule));
	}
	_registerArc3d.__loaded = !1;
	const registerArc3d = _registerArc3d;

	function _registerGroup() {
	  _registerGroup.__loaded || (_registerGroup.__loaded = !0, registerGroupGraphic());
	}
	_registerGroup.__loaded = !1;
	const registerGroup = _registerGroup;

	function _registerImage() {
	  _registerImage.__loaded || (_registerImage.__loaded = !0, registerImageGraphic(), container.load(imageModule), container.load(browser ? imageCanvasPickModule : imageMathPickModule));
	}
	_registerImage.__loaded = !1;
	const registerImage = _registerImage;

	function _registerLine() {
	  _registerLine.__loaded || (_registerLine.__loaded = !0, registerLineGraphic(), container.load(lineModule), container.load(browser ? lineCanvasPickModule : lineMathPickModule));
	}
	_registerLine.__loaded = !1;
	const registerLine = _registerLine;

	function _registerPolygon() {
	  _registerPolygon.__loaded || (_registerPolygon.__loaded = !0, registerPolygonGraphic(), container.load(polygonModule), container.load(browser ? polygonCanvasPickModule : polygonMathPickModule));
	}
	_registerPolygon.__loaded = !1;
	const registerPolygon = _registerPolygon;

	function _registerPyramid3d() {
	  _registerPyramid3d.__loaded || (_registerPyramid3d.__loaded = !0, registerPyramid3dGraphic(), registerDirectionalLight(), registerOrthoCamera(), container.load(pyramid3dModule), container.load(pyramid3dCanvasPickModule));
	}
	_registerPyramid3d.__loaded = !1;
	const registerPyramid3d = _registerPyramid3d;

	function _registerRect() {
	  _registerRect.__loaded || (_registerRect.__loaded = !0, registerRectGraphic(), container.load(rectModule), container.load(browser ? rectCanvasPickModule : rectMathPickModule));
	}
	_registerRect.__loaded = !1;
	const registerRect = _registerRect;

	function _registerRect3d() {
	  _registerRect3d.__loaded || (_registerRect3d.__loaded = !0, registerRect3dGraphic(), container.load(rect3dModule), container.load(rect3dCanvasPickModule));
	}
	_registerRect3d.__loaded = !1;
	const registerRect3d = _registerRect3d;

	function _registerRichtext() {
	  _registerRichtext.__loaded || (_registerRichtext.__loaded = !0, registerRichtextGraphic(), container.load(richtextModule), container.load(browser ? richtextCanvasPickModule : richTextMathPickModule));
	}
	_registerRichtext.__loaded = !1;
	const registerRichtext = _registerRichtext;

	function _registerShadowRoot() {
	  _registerShadowRoot.__loaded || (_registerShadowRoot.__loaded = !0, registerShadowRootGraphic());
	}
	_registerShadowRoot.__loaded = !1;
	const registerShadowRoot = _registerShadowRoot;

	function _registerSymbol() {
	  _registerSymbol.__loaded || (_registerSymbol.__loaded = !0, registerSymbolGraphic(), container.load(symbolModule), container.load(browser ? symbolCanvasPickModule : symbolMathPickModule));
	}
	_registerSymbol.__loaded = !1;
	const registerSymbol = _registerSymbol;

	function _registerText() {
	  _registerText.__loaded || (_registerText.__loaded = !0, registerTextGraphic(), container.load(textModule), container.load(browser ? textCanvasPickModule : textMathPickModule));
	}
	_registerText.__loaded = !1;
	const registerText = _registerText;

	class Rect3dMark extends vchart.BaseMark {
	    _getDefaultStyle() {
	        const defaultStyle = Object.assign(Object.assign({}, super._getDefaultStyle()), { width: undefined, height: undefined, length: 3 });
	        return defaultStyle;
	    }
	    setDataLabelType() {
	        return 'rect';
	    }
	    constructor(name, option) {
	        super(name, option);
	        this.type = Rect3dMark.type;
	        this._markConfig.support3d = true;
	    }
	    setMarkConfig(config) {
	        super.setMarkConfig(config);
	        this._markConfig.support3d = true;
	    }
	}
	Rect3dMark.type = "rect3d";
	const registerRect3dMark = () => {
	    vchart.Factory.registerMark(Rect3dMark.type, Rect3dMark);
	    registerShadowRoot();
	    registerRect3d();
	    vchart.registerRectAnimation();
	    vchart.Factory.registerGraphicComponent("rect3d", createRect3d);
	};

	const bar3d = {
	    bar3d: {
	        style: {
	            length: 3
	        }
	    },
	    label: {
	        visible: false,
	        style: {
	            offset: 12,
	            position: 'outside'
	        }
	    }
	};

	class Bar3dSeries extends vchart.BarSeries {
	    constructor() {
	        super(...arguments);
	        this.type = SeriesType3dEnum.bar3d;
	        this._barMarkName = "bar3d";
	        this._barMarkType = "rect3d";
	        this.transformerConstructor = Bar3dSeriesSpecTransformer;
	    }
	}
	Bar3dSeries.type = SeriesType3dEnum.bar3d;
	Bar3dSeries.mark = bar3dSeriesMark;
	Bar3dSeries.builtInTheme = { bar3d };
	Bar3dSeries.transformerConstructor = Bar3dSeriesSpecTransformer;
	const registerBar3dSeries = () => {
	    registerBar3dAnimation();
	    registerRect3dMark();
	    vchart.registerCartesianBandAxis();
	    vchart.registerCartesianLinearAxis();
	    vchart.Factory.registerSeries(Bar3dSeries.type, Bar3dSeries);
	};

	class Layout3d extends vchart.Layout {
	    layoutItems(_chart, items, chartLayoutRect, chartViewBox) {
	        this._layoutInit(_chart, items, chartLayoutRect, chartViewBox);
	        const recompute = {
	            recomputeWidth: this.recomputeWidth,
	            recomputeHeight: this.recomputeHeight
	        };
	        this._layoutNormalItems(items, recompute);
	        const layoutTemp = {
	            left: this.leftCurrent,
	            top: this.topCurrent,
	            right: this.rightCurrent,
	            bottom: this.bottomCurrent
	        };
	        const absoluteItem = items.filter(x => x.layoutType === 'absolute');
	        const zItems = absoluteItem.filter(i => {
	            return i.layoutOrient === 'z';
	        });
	        let extraWH = { width: 0, height: 0 };
	        if (zItems.length) {
	            const layoutRect = zItems[0].getLayoutRect();
	            extraWH = layoutRect;
	        }
	        this.leftCurrent += extraWH.width / 8;
	        this.rightCurrent -= extraWH.width / 8;
	        this.topCurrent += extraWH.height / 8;
	        this.bottomCurrent -= extraWH.height / 8;
	        const { regionItems, relativeItems, relativeOverlapItems, allRelatives, overlapItems } = this._groupItems(items);
	        this.layoutRegionItems(regionItems, relativeItems, relativeOverlapItems, overlapItems, recompute);
	        this._processAutoIndent(regionItems, relativeItems, relativeOverlapItems, overlapItems, allRelatives, layoutTemp, recompute);
	        const absoluteItemExceptZAxis = absoluteItem.filter(i => i.layoutOrient !== 'z');
	        this.layoutAbsoluteItems(absoluteItemExceptZAxis);
	        const xAxis = relativeItems.filter(item => {
	            return item.model.specKey === 'axes' && vchart.isXAxis(item.layoutOrient);
	        })[0];
	        const yAxis = relativeItems.filter(item => {
	            return item.model.specKey === 'axes' && vchart.isYAxis(item.layoutOrient);
	        })[0];
	        if (xAxis && zItems.length) {
	            const sp = xAxis.getLayoutStartPoint();
	            const lr = xAxis.getLayoutRect();
	            const zRect = {
	                x: yAxis.layoutOrient === 'left' ? sp.x + lr.width : sp.x,
	                y: sp.y,
	                width: this._chartLayoutRect.width,
	                height: this._chartLayoutRect.height
	            };
	            zItems[0].model.directionStr = yAxis.layoutOrient === 'left' ? 'r2l' : 'l2r';
	            const xRect = xAxis.getLayoutRect();
	            const yRect = yAxis.getLayoutRect();
	            const box3d = {
	                length: zItems[0].getLayoutRect().width,
	                width: xRect.width,
	                height: yRect.height
	            };
	            xAxis.model.setLayout3dBox && xAxis.model.setLayout3dBox(box3d);
	            yAxis.model.setLayout3dBox && yAxis.model.setLayout3dBox(box3d);
	            zItems[0].model.setLayout3dBox && zItems[0].model.setLayout3dBox(box3d);
	            this.layoutZAxisItems(zItems, zRect);
	        }
	    }
	    layoutZAxisItems(zItems, zRect) {
	        zItems.forEach(item => {
	            item.absoluteLayoutInRect(zRect);
	        });
	    }
	    getItemComputeLayoutRect(item, extraOffset) {
	        if (!extraOffset) {
	            extraOffset = { offsetLeft: 0, offsetRight: 0, offsetTop: 0, offsetBottom: 0 };
	        }
	        const result = {
	            width: this.rightCurrent -
	                this.leftCurrent -
	                item.layoutPaddingLeft -
	                item.layoutPaddingRight -
	                (extraOffset.offsetLeft + extraOffset.offsetRight),
	            height: this.bottomCurrent -
	                this.topCurrent -
	                item.layoutPaddingTop -
	                item.layoutPaddingBottom -
	                (extraOffset.offsetTop + extraOffset.offsetBottom)
	        };
	        return result;
	    }
	    _checkAutoIndent(items) {
	        const result = {
	            top: 0,
	            left: 0,
	            bottom: 0,
	            right: 0
	        };
	        const rightCurrent = this._chartViewBox.x2 - this._chartViewBox.x1 - this.rightCurrent;
	        const bottomCurrent = this._chartViewBox.y2 - this._chartViewBox.y1 - this.bottomCurrent;
	        items.forEach(i => {
	            if (!i.getModelVisible() || !i.autoIndent) {
	                return;
	            }
	            const vOrH = i.layoutOrient === 'left' || i.layoutOrient === 'right';
	            const outer = i.getLastComputeOutBounds();
	            if (vOrH) {
	                result.top = Math.max(result.top, outer.y1 - this.topCurrent);
	                result.bottom = Math.max(result.bottom, outer.y2 - bottomCurrent);
	            }
	            else {
	                result.left = Math.max(result.left, outer.x1 - this.leftCurrent);
	                result.right = Math.max(result.right, outer.x2 - rightCurrent);
	            }
	        });
	        return result;
	    }
	}
	Layout3d.type = 'layout3d';
	const registerLayout3d = () => {
	    vchart.Factory.registerLayout(Layout3d.type, Layout3d);
	};

	class Bar3dChart extends vchart.BarChart {
	    constructor() {
	        super(...arguments);
	        this.transformerConstructor = Bar3dChartSpecTransformer;
	        this.type = "bar3d";
	        this.seriesType = SeriesType3dEnum.bar3d;
	    }
	}
	Bar3dChart.type = "bar3d";
	Bar3dChart.seriesType = SeriesType3dEnum.bar3d;
	Bar3dChart.transformerConstructor = Bar3dChartSpecTransformer;
	const registerBar3dChart = () => {
	    register3DPlugin();
	    registerLayout3d();
	    registerBar3dSeries();
	    vchart.Factory.registerChart(Bar3dChart.type, Bar3dChart);
	};

	const funnel3dSeriesMark = Object.assign(Object.assign({}, vchart.baseSeriesMark), { ["funnel3d"]: { name: "funnel3d", type: "pyramid3d" }, ["transform3d"]: { name: "transform3d", type: "pyramid3d" }, ["transformLabel"]: { name: "transformLabel", type: "text" }, ["outerLabel"]: { name: "outerLabel", type: "text" }, ["outerLabelLine"]: { name: "outerLabelLine", type: "rule" } });

	class Funnel3dSeriesSpecTransformer extends vchart.FunnelSeriesSpecTransformer {
	    _transformLabelSpec(spec) {
	        this._addMarkLabelSpec(spec, "funnel3d");
	        if (spec.isTransform) {
	            this._addMarkLabelSpec(spec, "transform3d", 'transformLabel');
	        }
	    }
	}

	class Pyramid3dMark extends vchart.BasePolygonMark {
	    _getDefaultStyle() {
	        const defaultStyle = super._getDefaultStyle();
	        defaultStyle.stroke = false;
	        return defaultStyle;
	    }
	    constructor(name, option) {
	        super(name, option);
	        this.type = Pyramid3dMark.type;
	        this._markConfig.support3d = true;
	    }
	    setMarkConfig(config) {
	        super.setMarkConfig(config);
	        this._markConfig.support3d = true;
	    }
	}
	Pyramid3dMark.type = "pyramid3d";
	const registerPyramid3dMark = () => {
	    vchart.Factory.registerMark(Pyramid3dMark.type, Pyramid3dMark);
	    registerShadowRoot();
	    registerPyramid3d();
	    vchart.registerPolygonAnimation();
	    vchart.Factory.registerGraphicComponent("pyramid3d", createPyramid3d);
	};

	const funnel3d = vchart.getFunnelTheme(true);

	class Funnel3dSeries extends vchart.FunnelSeries {
	    constructor() {
	        super(...arguments);
	        this.type = SeriesType3dEnum.funnel3d;
	        this._funnelMarkName = "funnel3d";
	        this._funnelMarkType = "pyramid3d";
	        this._transformMarkName = "transform3d";
	        this._transformMarkType = "pyramid3d";
	        this.transformerConstructor = Funnel3dSeriesSpecTransformer;
	    }
	    initMark() {
	        var _a, _b, _c, _d, _e, _f, _g, _h;
	        this._funnelMark = this._createMark(Object.assign(Object.assign({}, Funnel3dSeries.mark.funnel3d), { name: this._funnelMarkName, type: this._funnelMarkType }), {
	            themeSpec: (_a = this._theme) === null || _a === void 0 ? void 0 : _a.funnel3d,
	            key: this._seriesField,
	            isSeriesMark: true
	        }, {
	            support3d: true
	        });
	        if (this._spec.isTransform) {
	            this._funnelTransformMark = this._createMark(Object.assign(Object.assign({}, Funnel3dSeries.mark.transform3d), { name: this._transformMarkName, type: this._transformMarkType }), {
	                themeSpec: (_b = this._theme) === null || _b === void 0 ? void 0 : _b.transform3d,
	                key: this._seriesField,
	                skipBeforeLayouted: false,
	                dataView: this._viewDataTransform.getDataView(),
	                dataProductId: this._viewDataTransform.getProductId()
	            });
	        }
	        if ((_d = (_c = this._spec) === null || _c === void 0 ? void 0 : _c.outerLabel) === null || _d === void 0 ? void 0 : _d.visible) {
	            const { line } = (_e = this._spec.outerLabel) !== null && _e !== void 0 ? _e : {};
	            const { line: lineTheme } = (_g = (_f = this._theme) === null || _f === void 0 ? void 0 : _f.outerLabel) !== null && _g !== void 0 ? _g : {};
	            this._funnelOuterLabelMark.label = this._createMark(Funnel3dSeries.mark.outerLabel, {
	                themeSpec: (_h = this._theme) === null || _h === void 0 ? void 0 : _h.outerLabel,
	                key: this._seriesField,
	                markSpec: this._spec.outerLabel
	            });
	            this._funnelOuterLabelMark.line = this._createMark(Funnel3dSeries.mark.outerLabelLine, {
	                themeSpec: lineTheme,
	                key: this._seriesField,
	                markSpec: line
	            });
	        }
	    }
	    initMarkStyle() {
	        super.initMarkStyle();
	        const funnelMark = this._funnelMark;
	        if (funnelMark) {
	            this.setMarkStyle(funnelMark, {
	                z: _ => {
	                    if (this._isHorizontal()) {
	                        return 0;
	                    }
	                    const points = this.getPoints(_);
	                    const width = Math.max(Math.abs(points[0].x - points[1].x), Math.abs(points[2].x - points[3].x));
	                    return (this._computeMaxSize() - width) / 2;
	                }
	            }, 'normal', vchart.AttributeLevel.Series);
	        }
	    }
	    initLabelMarkStyle(labelMark) {
	        var _a, _b;
	        super.initLabelMarkStyle(labelMark);
	        this.setMarkStyle(labelMark, {
	            z: _ => {
	                if (this._isHorizontal()) {
	                    return 0;
	                }
	                const points = this.getPoints(_);
	                const width = Math.max(Math.abs(points[0].x - points[1].x), Math.abs(points[2].x - points[3].x));
	                return (this._computeMaxSize() - width) / 2;
	            }
	        }, 'normal', vchart.AttributeLevel.Series);
	        this._labelMark = labelMark;
	        if ((_a = this._funnelOuterLabelMark) === null || _a === void 0 ? void 0 : _a.label) ;
	        if ((_b = this._funnelOuterLabelMark) === null || _b === void 0 ? void 0 : _b.line) ;
	    }
	}
	Funnel3dSeries.type = SeriesType3dEnum.funnel3d;
	Funnel3dSeries.mark = funnel3dSeriesMark;
	Funnel3dSeries.builtInTheme = { funnel3d };
	Funnel3dSeries.transformerConstructor = Funnel3dSeriesSpecTransformer;
	const registerFunnel3dSeries = () => {
	    registerPyramid3dMark();
	    vchart.registerTextMark();
	    vchart.registerRuleMark();
	    vchart.Factory.registerSeries(Funnel3dSeries.type, Funnel3dSeries);
	};

	class Funnel3dChart extends vchart.BaseChart {
	    constructor() {
	        super(...arguments);
	        this.transformerConstructor = vchart.FunnelChartSpecTransformer;
	        this.type = "funnel3d";
	        this.seriesType = SeriesType3dEnum.funnel3d;
	    }
	}
	Funnel3dChart.type = "funnel3d";
	Funnel3dChart.seriesType = SeriesType3dEnum.funnel3d;
	Funnel3dChart.transformerConstructor = vchart.FunnelChartSpecTransformer;
	const registerFunnel3dChart = () => {
	    vchart.registerMarkTooltipProcessor();
	    register3DPlugin();
	    registerLayout3d();
	    registerFunnel3dSeries();
	    vchart.Factory.registerChart(Funnel3dChart.type, Funnel3dChart);
	};

	class Histogram3dChart extends vchart.BaseHistogramChart {
	    constructor() {
	        super(...arguments);
	        this.transformerConstructor = vchart.HistogramChartSpecTransformer;
	        this.type = "histogram3d";
	        this.seriesType = SeriesType3dEnum.bar3d;
	    }
	    _setModelOption() {
	        this._modelOption.getDimensionInfo = vchart.getCartesianDimensionInfo;
	        this._modelOption.getDimensionInfoByValue = vchart.getDimensionInfoByValue;
	        this._modelOption.getRectByDimensionData = vchart.getCartesianCrosshairRect;
	    }
	}
	Histogram3dChart.type = "histogram3d";
	Histogram3dChart.seriesType = SeriesType3dEnum.bar3d;
	Histogram3dChart.transformerConstructor = vchart.HistogramChartSpecTransformer;
	const registerHistogram3dChart = () => {
	    vchart.registerGroupTooltipProcessor();
	    vchart.registerDimensionTooltipProcessor();
	    vchart.registerMarkTooltipProcessor();
	    vchart.registerDimensionEvents();
	    vchart.registerDimensionHover();
	    register3DPlugin();
	    registerLayout3d();
	    registerBar3dSeries();
	    vchart.Factory.registerChart(Histogram3dChart.type, Histogram3dChart);
	};

	class Pie3dChartSpecTransformer extends vchart.BasePieChartSpecTransformer {
	    transformSpec(spec) {
	        super.transformSpec(spec);
	        spec.series.forEach((s) => {
	            if (s.type === 'pie3d') {
	                s.angle3d = spec.angle3d;
	            }
	        });
	    }
	}

	class Arc3dMark extends vchart.BaseArcMark {
	    setDataLabelType() {
	        return 'arc';
	    }
	    constructor(name, option) {
	        super(name, option);
	        this.type = Arc3dMark.type;
	        this._markConfig.support3d = true;
	    }
	    setMarkConfig(config) {
	        super.setMarkConfig(config);
	        this._markConfig.support3d = true;
	    }
	}
	Arc3dMark.type = "arc3d";
	const registerArc3dMark = () => {
	    vchart.registerArcAnimation();
	    registerShadowRoot();
	    registerArc3d();
	    vchart.Factory.registerGraphicComponent("arc3d", createArc3d);
	    vchart.Factory.registerMark("arc3d", Arc3dMark);
	};

	const pie3dSeriesMark = Object.assign(Object.assign({}, vchart.baseSeriesMark), { ["pie3d"]: { name: "pie3d", type: "arc3d" }, ["labelLine"]: { name: "labelLine", type: "path" } });

	class Pie3dSeriesSpecTransformer extends vchart.PieSeriesSpecTransformer {
	    _transformLabelSpec(spec) {
	        this._addMarkLabelSpec(spec, "pie3d");
	    }
	}

	const registerPie3dAnimation = () => {
	    vchart.Factory.registerAnimation('pie3d', (params, preset) => {
	        return {
	            appear: vchart.piePresetAnimation(params, preset),
	            enter: vchart.pieEnter(params),
	            exit: vchart.pieExit(params),
	            disappear: vchart.pieDisappear(params)
	        };
	    });
	};

	const pie3d = {
	    outerRadius: 0.6,
	    pie3d: {
	        style: {
	            height: 10,
	            fillOpacity: 1
	        }
	    },
	    label: {
	        visible: false,
	        interactive: true,
	        position: 'outside'
	    }
	};

	class Pie3dSeries extends vchart.BasePieSeries {
	    constructor() {
	        super(...arguments);
	        this.type = SeriesType3dEnum.pie3d;
	        this._pieMarkName = "pie3d";
	        this._pieMarkType = "arc3d";
	        this.transformerConstructor = Pie3dSeriesSpecTransformer;
	    }
	    setAttrFromSpec() {
	        var _a, _b;
	        super.setAttrFromSpec();
	        this._angle3d = (_b = (_a = this._spec) === null || _a === void 0 ? void 0 : _a.angle3d) !== null && _b !== void 0 ? _b : -Math.PI / 3;
	    }
	    initMarkStyle() {
	        super.initMarkStyle();
	        const pieMark = this._pieMark;
	        if (pieMark) {
	            this.setMarkStyle(pieMark, {
	                beta: () => this._angle3d
	            }, 'normal', vchart.AttributeLevel.Series);
	        }
	    }
	    initLabelMarkStyle(textMark, spec = {}) {
	        if (!textMark) {
	            return;
	        }
	        super.initLabelMarkStyle(textMark);
	        this.setMarkStyle(textMark, { support3d: true }, undefined, vchart.AttributeLevel.Mark);
	    }
	}
	Pie3dSeries.type = SeriesType3dEnum.pie3d;
	Pie3dSeries.mark = pie3dSeriesMark;
	Pie3dSeries.builtInTheme = { pie3d };
	Pie3dSeries.transformerConstructor = Pie3dSeriesSpecTransformer;
	const registerPie3dSeries = () => {
	    registerPie3dAnimation();
	    registerArc3dMark();
	    vchart.Factory.registerSeries(Pie3dSeries.type, Pie3dSeries);
	};

	class Pie3dChart extends vchart.BasePieChart {
	    constructor() {
	        super(...arguments);
	        this.transformerConstructor = Pie3dChartSpecTransformer;
	        this.type = "pie3d";
	        this.seriesType = SeriesType3dEnum.pie3d;
	    }
	}
	Pie3dChart.type = "pie3d";
	Pie3dChart.seriesType = SeriesType3dEnum.pie3d;
	Pie3dChart.transformerConstructor = Pie3dChartSpecTransformer;
	const registerPie3dChart = () => {
	    vchart.registerMarkTooltipProcessor();
	    register3DPlugin();
	    registerLayout3d();
	    registerPie3dSeries();
	    vchart.Factory.registerChart(Pie3dChart.type, Pie3dChart);
	};

	class Easing {
	  constructor() {}
	  static linear(t) {
	    return t;
	  }
	  static none() {
	    return this.linear;
	  }
	  static get(amount) {
	    return amount < -1 ? amount = -1 : amount > 1 && (amount = 1), function (t) {
	      return 0 === amount ? t : amount < 0 ? t * (t * -amount + 1 + amount) : t * ((2 - t) * amount + (1 - amount));
	    };
	  }
	  static getPowIn(pow) {
	    return function (t) {
	      return Math.pow(t, pow);
	    };
	  }
	  static getPowOut(pow) {
	    return function (t) {
	      return 1 - Math.pow(1 - t, pow);
	    };
	  }
	  static getPowInOut(pow) {
	    return function (t) {
	      return (t *= 2) < 1 ? .5 * Math.pow(t, pow) : 1 - .5 * Math.abs(Math.pow(2 - t, pow));
	    };
	  }
	  static getBackIn(amount) {
	    return function (t) {
	      return t * t * ((amount + 1) * t - amount);
	    };
	  }
	  static getBackOut(amount) {
	    return function (t) {
	      return --t * t * ((amount + 1) * t + amount) + 1;
	    };
	  }
	  static getBackInOut(amount) {
	    return amount *= 1.525, function (t) {
	      return (t *= 2) < 1 ? t * t * ((amount + 1) * t - amount) * .5 : .5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
	    };
	  }
	  static sineIn(t) {
	    return 1 - Math.cos(t * Math.PI / 2);
	  }
	  static sineOut(t) {
	    return Math.sin(t * Math.PI / 2);
	  }
	  static sineInOut(t) {
	    return -(Math.cos(Math.PI * t) - 1) / 2;
	  }
	  static expoIn(t) {
	    return 0 === t ? 0 : Math.pow(2, 10 * t - 10);
	  }
	  static expoOut(t) {
	    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
	  }
	  static expoInOut(t) {
	    return 0 === t ? 0 : 1 === t ? 1 : t < .5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
	  }
	  static circIn(t) {
	    return -(Math.sqrt(1 - t * t) - 1);
	  }
	  static circOut(t) {
	    return Math.sqrt(1 - --t * t);
	  }
	  static circInOut(t) {
	    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
	  }
	  static bounceOut(t) {
	    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
	  }
	  static bounceIn(t) {
	    return 1 - Easing.bounceOut(1 - t);
	  }
	  static bounceInOut(t) {
	    return t < .5 ? .5 * Easing.bounceIn(2 * t) : .5 * Easing.bounceOut(2 * t - 1) + .5;
	  }
	  static getElasticIn(amplitude, period) {
	    return function (t) {
	      if (0 === t || 1 === t) return t;
	      const s = period / pi2 * Math.asin(1 / amplitude);
	      return -amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period);
	    };
	  }
	  static getElasticOut(amplitude, period) {
	    return function (t) {
	      if (0 === t || 1 === t) return t;
	      const s = period / pi2 * Math.asin(1 / amplitude);
	      return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * pi2 / period) + 1;
	    };
	  }
	  static getElasticInOut(amplitude, period) {
	    return function (t) {
	      const s = period / pi2 * Math.asin(1 / amplitude);
	      return (t *= 2) < 1 ? amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * -.5 : amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * .5 + 1;
	    };
	  }
	  static registerFunc(name, func) {
	    Easing[name] = func;
	  }
	}
	function flicker(t, n) {
	  const step = 1 / n;
	  let flag = 1;
	  for (; t > step;) t -= step, flag *= -1;
	  const v = flag * t / step;
	  return v > 0 ? v : 1 + v;
	}
	Easing.quadIn = Easing.getPowIn(2), Easing.quadOut = Easing.getPowOut(2), Easing.quadInOut = Easing.getPowInOut(2), Easing.cubicIn = Easing.getPowIn(3), Easing.cubicOut = Easing.getPowOut(3), Easing.cubicInOut = Easing.getPowInOut(3), Easing.quartIn = Easing.getPowIn(4), Easing.quartOut = Easing.getPowOut(4), Easing.quartInOut = Easing.getPowInOut(4), Easing.quintIn = Easing.getPowIn(5), Easing.quintOut = Easing.getPowOut(5), Easing.quintInOut = Easing.getPowInOut(5), Easing.backIn = Easing.getBackIn(1.7), Easing.backOut = Easing.getBackOut(1.7), Easing.backInOut = Easing.getBackInOut(1.7), Easing.elasticIn = Easing.getElasticIn(1, .3), Easing.elasticOut = Easing.getElasticOut(1, .3), Easing.elasticInOut = Easing.getElasticInOut(1, .3 * 1.5), Easing.easeInOutQuad = t => (t /= .5) < 1 ? .5 * Math.pow(t, 2) : -.5 * ((t -= 2) * t - 2), Easing.easeOutElastic = x => {
	  const c4 = 2 * Math.PI / 3;
	  return 0 === x ? 0 : 1 === x ? 1 : Math.pow(2, -10 * x) * Math.sin((10 * x - .75) * c4) + 1;
	}, Easing.easeInOutElastic = x => {
	  const c5 = 2 * Math.PI / 4.5;
	  return 0 === x ? 0 : 1 === x ? 1 : x < .5 ? -Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1;
	};
	for (let i = 0; i < 10; i++) Easing[`flicker${i}`] = t => flicker(t, i);
	for (let i = 2; i < 10; i++) Easing[`aIn${i}`] = t => i * t * t + (1 - i) * t;

	function interpolateNumber(from, to, ratio) {
	  return from + (to - from) * ratio;
	}

	class InterpolateUpdateStore {
	  constructor() {
	    this.opacity = (key, from, to, ratio, step, target) => {
	      target.attribute.opacity = interpolateNumber(from, to, ratio);
	    }, this.baseOpacity = (key, from, to, ratio, step, target) => {
	      target.attribute.baseOpacity = interpolateNumber(from, to, ratio);
	    }, this.fillOpacity = (key, from, to, ratio, step, target) => {
	      target.attribute.fillOpacity = interpolateNumber(from, to, ratio);
	    }, this.strokeOpacity = (key, from, to, ratio, step, target) => {
	      target.attribute.strokeOpacity = interpolateNumber(from, to, ratio);
	    }, this.zIndex = (key, from, to, ratio, step, target) => {
	      target.attribute.zIndex = interpolateNumber(from, to, ratio);
	    }, this.backgroundOpacity = (key, from, to, ratio, step, target) => {
	      target.attribute.backgroundOpacity = interpolateNumber(from, to, ratio);
	    }, this.shadowOffsetX = (key, from, to, ratio, step, target) => {
	      target.attribute.shadowOffsetX = interpolateNumber(from, to, ratio);
	    }, this.shadowOffsetY = (key, from, to, ratio, step, target) => {
	      target.attribute.shadowOffsetY = interpolateNumber(from, to, ratio);
	    }, this.shadowBlur = (key, from, to, ratio, step, target) => {
	      target.attribute.shadowBlur = interpolateNumber(from, to, ratio);
	    }, this.fill = (key, from, to, ratio, step, target) => {
	      target.attribute.fill = interpolateColor(from, to, ratio, !1);
	    }, this.fillPure = (key, from, to, ratio, step, target) => {
	      target.attribute.fill = step.fromParsedProps.fill ? interpolatePureColorArrayToStr(step.fromParsedProps.fill, step.toParsedProps.fill, ratio) : step.toParsedProps.fill;
	    }, this.stroke = (key, from, to, ratio, step, target) => {
	      target.attribute.stroke = interpolateColor(from, to, ratio, !1);
	    }, this.strokePure = (key, from, to, ratio, step, target) => {
	      target.attribute.stroke = step.fromParsedProps.stroke ? interpolatePureColorArrayToStr(step.fromParsedProps.stroke, step.toParsedProps.stroke, ratio) : step.toParsedProps.stroke;
	    }, this.width = (key, from, to, ratio, step, target) => {
	      target.attribute.width = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
	    }, this.height = (key, from, to, ratio, step, target) => {
	      target.attribute.height = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
	    }, this.x = (key, from, to, ratio, step, target) => {
	      target.attribute.x = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
	    }, this.y = (key, from, to, ratio, step, target) => {
	      target.attribute.y = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
	    }, this.dx = (key, from, to, ratio, step, target) => {
	      target.attribute.dx = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
	    }, this.dy = (key, from, to, ratio, step, target) => {
	      target.attribute.dy = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
	    }, this.angle = (key, from, to, ratio, step, target) => {
	      target.attribute.angle = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
	    }, this.scaleX = (key, from, to, ratio, step, target) => {
	      target.attribute.scaleX = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
	    }, this.scaleY = (key, from, to, ratio, step, target) => {
	      target.attribute.scaleY = interpolateNumber(from, to, ratio), target.addUpdateBoundTag(), target.addUpdatePositionTag();
	    }, this.lineWidth = (key, from, to, ratio, step, target) => {
	      target.attribute.lineWidth = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
	    }, this.startAngle = (key, from, to, ratio, step, target) => {
	      target.attribute.startAngle = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
	    }, this.endAngle = (key, from, to, ratio, step, target) => {
	      target.attribute.endAngle = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
	    }, this.radius = (key, from, to, ratio, step, target) => {
	      target.attribute.radius = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
	    }, this.outerRadius = (key, from, to, ratio, step, target) => {
	      target.attribute.outerRadius = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
	    }, this.innerRadius = (key, from, to, ratio, step, target) => {
	      target.attribute.innerRadius = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
	    }, this.size = (key, from, to, ratio, step, target) => {
	      target.attribute.size = interpolateNumber(from, to, ratio), target.addUpdateBoundTag();
	    }, this.points = (key, from, to, ratio, step, target) => {
	      target.attribute.points = pointsInterpolation(from, to, ratio), target.addUpdateBoundTag();
	    };
	  }
	}
	const interpolateUpdateStore = new InterpolateUpdateStore();
	function commonInterpolateUpdate(key, from, to, ratio, step, target) {
	  if (Number.isFinite(to) && Number.isFinite(from)) return target.attribute[key] = from + (to - from) * ratio, !0;
	  if (Array.isArray(to) && Array.isArray(from) && to.length === from.length) {
	    const nextList = [];
	    let valid = !0;
	    for (let i = 0; i < to.length; i++) {
	      const v = from[i],
	        val = v + (to[i] - v) * ratio;
	      if (!Number.isFinite(val)) {
	        valid = !1;
	        break;
	      }
	      nextList.push(val);
	    }
	    return valid && (target.attribute[key] = nextList), !0;
	  }
	  return !1;
	}

	function noop() {}
	class Step {
	  constructor(type, props, duration, easing) {
	    var _a;
	    this._startTime = 0, this._hasFirstRun = !1, this._syncAttributeUpdate = () => {
	      this.target.setAttributes(this.target.attribute);
	    }, this.type = type, this.props = props, this.duration = duration, this.easing = easing ? "function" == typeof easing ? easing : null !== (_a = Easing[easing]) && void 0 !== _a ? _a : Easing.linear : Easing.linear, "wait" === type && (this.onUpdate = noop), this.id = Generator.GenAutoIncrementId(), this.syncAttributeUpdate = noop;
	  }
	  bind(target, animate) {
	    this.target = target, this.animate = animate, this.onBind(), this.syncAttributeUpdate();
	  }
	  append(step) {
	    this.next = step, step.prev = this, step.setStartTime(this.getStartTime() + this.duration, !1);
	  }
	  updateDownstreamStartTimes() {
	    let currentStep = this.next,
	      currentStartTime = this._startTime + this.duration;
	    for (; currentStep;) currentStep.setStartTime(currentStartTime, !1), currentStartTime += currentStep.duration, currentStep = currentStep.next;
	    this.animate.updateDuration();
	  }
	  getLastProps() {
	    return this.prev ? this.prev.props || {} : this.animate.getStartProps();
	  }
	  setDuration(duration, updateDownstream = !0) {
	    this.duration = duration, updateDownstream && this.updateDownstreamStartTimes();
	  }
	  getDuration() {
	    return this.duration;
	  }
	  determineInterpolateUpdateFunction() {
	    if (!this.props) return;
	    const funcs = [];
	    this.propKeys.forEach(key => {
	      if ("fill" === key || "stroke" === key) {
	        const from = this.fromProps[key],
	          to = this.props[key];
	        if (isString$1(from) && isString$1(to)) {
	          const fromArray = ColorStore.Get(from, ColorType.Color255),
	            toArray = ColorStore.Get(to, ColorType.Color255);
	          this.fromParsedProps || (this.fromParsedProps = {}), this.toParsedProps || (this.toParsedProps = {}), this.fromParsedProps[key] = fromArray, this.toParsedProps[key] = toArray, funcs.push(interpolateUpdateStore["fill" === key ? "fillPure" : "strokePure"]);
	        } else interpolateUpdateStore[key] ? funcs.push(interpolateUpdateStore[key]) : funcs.push(commonInterpolateUpdate);
	      } else interpolateUpdateStore[key] ? funcs.push(interpolateUpdateStore[key]) : funcs.push(commonInterpolateUpdate);
	    }), this.interpolateUpdateFunctions = funcs;
	  }
	  setStartTime(time, updateDownstream = !0) {
	    this._startTime = time, updateDownstream && this.updateDownstreamStartTimes();
	  }
	  getStartTime() {
	    return this._startTime;
	  }
	  onBind() {
	    "glyph" === this.target.type && (this.syncAttributeUpdate = this._syncAttributeUpdate);
	  }
	  onFirstRun() {}
	  onStart() {
	    if (!this._hasFirstRun) {
	      this._hasFirstRun = !0, this.fromProps = this.getLastProps();
	      const startProps = this.animate.getStartProps();
	      this.propKeys && this.propKeys.forEach(key => {
	        var _a;
	        this.fromProps[key] = null !== (_a = this.fromProps[key]) && void 0 !== _a ? _a : startProps[key];
	      }), this.determineInterpolateUpdateFunction(), this.tryPreventConflict(), this.trySyncStartProps(), this.onFirstRun();
	    }
	  }
	  tryPreventConflict() {
	    const animate = this.animate;
	    this.target.animates.forEach(a => {
	      if (a === animate || a.priority > animate.priority || a.priority === 1 / 0) return;
	      const fromProps = a.getStartProps();
	      this.propKeys.forEach(key => {
	        null != fromProps[key] && a.preventAttr(key);
	      });
	    });
	  }
	  deleteSelfAttr(key) {
	    var _a;
	    delete this.props[key], this.fromProps && delete this.fromProps[key];
	    const index = this.propKeys.indexOf(key);
	    -1 !== index && (this.propKeys.splice(index, 1), null === (_a = this.interpolateUpdateFunctions) || void 0 === _a || _a.splice(index, 1));
	  }
	  trySyncStartProps() {
	    this.propKeys.forEach(key => {
	      this.fromProps[key] = this.animate.target.getComputedAttribute(key);
	    });
	  }
	  update(end, ratio, out) {
	    if (this.onStart(), !this.props || !this.propKeys) return;
	    const easedRatio = this.easing(ratio);
	    this.animate.interpolateUpdateFunction ? this.animate.interpolateUpdateFunction(this.fromProps, this.props, easedRatio, this, this.target) : this.interpolateUpdateFunctions.forEach((func, index) => {
	      if (!this.animate.validAttr(this.propKeys[index])) return;
	      const key = this.propKeys[index];
	      func(key, this.fromProps[key], this.props[key], easedRatio, this, this.target);
	    }), this.onUpdate(end, easedRatio, out), this.syncAttributeUpdate();
	  }
	  onUpdate(end, ratio, out) {}
	  onEnd(cb) {
	    this.target.setAttributes(this.props), cb ? this._endCb = cb : this._endCb && this._endCb(this.animate, this);
	  }
	  getEndProps() {
	    return this.props;
	  }
	  getFromProps() {
	    return this.fromProps;
	  }
	  getMergedEndProps() {
	    return this.getEndProps();
	  }
	  stop() {}
	  release() {}
	}
	class WaitStep extends Step {
	  constructor(type, props, duration, easing) {
	    super(type, props, duration, easing);
	  }
	  onStart() {
	    super.onStart();
	    const fromProps = this.getFromProps();
	    this.target.setAttributes(fromProps);
	  }
	  update(end, ratio, out) {
	    this.onStart();
	  }
	  determineInterpolateUpdateFunction() {}
	}

	class DefaultTimeline extends EventEmitter {
	  get animateCount() {
	    return this._animateCount;
	  }
	  constructor() {
	    super(), this.head = null, this.tail = null, this.animateMap = new Map(), this._animateCount = 0, this._playSpeed = 1, this._totalDuration = 0, this._startTime = 0, this._currentTime = 0, this._animationEndFlag = !0, this.id = Generator.GenAutoIncrementId(), this.paused = !1;
	  }
	  isRunning() {
	    return !this.paused && this._animateCount > 0;
	  }
	  forEachAccessAnimate(cb) {
	    let current = this.head,
	      index = 0;
	    for (; current;) {
	      const next = current.next;
	      cb(current.animate, index), index++, current = next;
	    }
	  }
	  addAnimate(animate) {
	    const newNode = {
	      animate: animate,
	      next: null,
	      prev: null
	    };
	    this.head ? this.tail && (this.tail.next = newNode, newNode.prev = this.tail, this.tail = newNode) : (this.head = newNode, this.tail = newNode), this.animateMap.set(animate, newNode), this._animateCount++, this._totalDuration = Math.max(this._totalDuration, animate.getStartTime() + animate.getDuration());
	  }
	  pause() {
	    this.paused = !0;
	  }
	  resume() {
	    this.paused = !1;
	  }
	  tick(delta) {
	    if (this.paused) return;
	    this._animationEndFlag && (this._animationEndFlag = !1, this.emit("animationStart"));
	    const scaledDelta = delta * this._playSpeed;
	    this._currentTime += scaledDelta, this.forEachAccessAnimate((animate, i) => {
	      animate.status === AnimateStatus.END ? this.removeAnimate(animate, !0) : animate.status !== AnimateStatus.RUNNING && animate.status !== AnimateStatus.INITIAL || animate.advance(scaledDelta);
	    }), 0 === this._animateCount && (this._animationEndFlag = !0, this.emit("animationEnd"));
	  }
	  clear() {
	    this.forEachAccessAnimate(animate => {
	      animate.release();
	    }), this.head = null, this.tail = null, this.animateMap.clear(), this._animateCount = 0, this._totalDuration = 0;
	  }
	  removeAnimate(animate, release = !0) {
	    const node = this.animateMap.get(animate);
	    node && (release && (animate._onRemove && animate._onRemove.forEach(cb => cb()), animate.release()), node.prev ? node.prev.next = node.next : this.head = node.next, node.next ? node.next.prev = node.prev : this.tail = node.prev, this.animateMap.delete(animate), this._animateCount--, animate.getStartTime() + animate.getDuration() >= this._totalDuration && this.recalculateTotalDuration());
	  }
	  recalculateTotalDuration() {
	    this._totalDuration = 0, this.forEachAccessAnimate(animate => {
	      this._totalDuration = Math.max(this._totalDuration, animate.getStartTime() + animate.getDuration());
	    });
	  }
	  getTotalDuration() {
	    return this._totalDuration;
	  }
	  getPlaySpeed() {
	    return this._playSpeed;
	  }
	  setPlaySpeed(speed) {
	    this._playSpeed = speed;
	  }
	  getPlayState() {
	    return this.paused ? "paused" : 0 === this.animateCount ? "stopped" : "playing";
	  }
	  setStartTime(time) {
	    this._startTime = time;
	  }
	  getStartTime() {
	    return this._startTime;
	  }
	  getCurrentTime() {
	    return this._currentTime;
	  }
	  setCurrentTime(time) {
	    this._currentTime = time;
	  }
	}
	const defaultTimeline = new DefaultTimeline();
	defaultTimeline.isGlobal = !0;

	class Animate {
	  constructor(id = Generator.GenAutoIncrementId(), timeline = defaultTimeline, slience) {
	    this.id = id, this.status = AnimateStatus.INITIAL, this._timeline = timeline, timeline.addAnimate(this), this.slience = slience, this._startTime = 0, this._duration = 0, this._totalDuration = 0, this._loopCount = 0, this._currentLoop = 0, this._bounce = !1, this._firstStep = null, this._lastStep = null, this._startProps = {}, this._endProps = {}, this._preventAttrs = new Set(), this.currentTime = 0, this.interpolateUpdateFunction = null, this.priority = 0;
	  }
	  getStartProps() {
	    return this._startProps;
	  }
	  getEndProps() {
	    return this._endProps;
	  }
	  setTimeline(timeline) {
	    this._timeline = timeline;
	  }
	  getTimeline() {
	    return this._timeline;
	  }
	  get timeline() {
	    return this._timeline;
	  }
	  bind(target) {
	    return this.target = target, this.target.animates || (this.target.animates = new Map()), this.target.animates.set(this.id, this), this.onRemove(() => {
	      this.stop(), this.target.animates.delete(this.id);
	    }), this.target.onAnimateBind && !this.slience && this.target.onAnimateBind(this), this.target.animationAttribute || (this.target.animationAttribute = {}), this;
	  }
	  to(props, duration = 300, easing = "linear") {
	    const step = new Step(AnimateStepType.to, props, duration, easing);
	    return step.bind(this.target, this), this.updateStepAfterAppend(step), this;
	  }
	  wait(delay) {
	    const step = new WaitStep(AnimateStepType.wait, {}, delay, "linear");
	    return step.bind(this.target, this), this.updateStepAfterAppend(step), this;
	  }
	  updateStepAfterAppend(step) {
	    this._firstStep ? (this._lastStep.append(step), this._lastStep = step) : (this._firstStep = step, this._lastStep = step), this.parseStepProps(step), this.updateDuration();
	  }
	  parseStepProps(step) {
	    this._lastStep && (step.propKeys = step.propKeys || Object.keys(step.props), Object.keys(this._endProps).forEach(key => {
	      var _a;
	      step.props[key] = null !== (_a = step.props[key]) && void 0 !== _a ? _a : this._endProps[key];
	    }), step.propKeys.forEach(key => {
	      this._endProps[key] = step.props[key];
	    }));
	  }
	  reSyncProps() {
	    if (!this._lastStep) return;
	    this._endProps = {};
	    let currentStep = this._firstStep;
	    for (; currentStep;) Object.keys(this._endProps).forEach(key => {
	      var _a;
	      currentStep.props[key] = null !== (_a = currentStep.props[key]) && void 0 !== _a ? _a : this._endProps[key];
	    }), currentStep.propKeys.forEach(key => {
	      this._endProps[key] = currentStep.props[key];
	    }), currentStep = currentStep.next;
	  }
	  from(props, duration = 300, easing = "linear") {
	    const step = new Step(AnimateStepType.from, props, duration, easing);
	    return this._firstStep ? (this._lastStep.append(step), this._lastStep = step) : (this._firstStep = step, this._lastStep = step), this.updateDuration(), this;
	  }
	  play(customAnimate) {
	    return customAnimate.bind(this.target, this), this.updateStepAfterAppend(customAnimate), this;
	  }
	  pause() {
	    this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.PAUSED);
	  }
	  resume() {
	    this.status === AnimateStatus.PAUSED && (this.status = AnimateStatus.RUNNING);
	  }
	  onStart(cb) {
	    var _a;
	    cb ? (this._onStart || (this._onStart = []), this._onStart.push(cb)) : (null === (_a = this._onStart) || void 0 === _a || _a.forEach(cb => cb()), Object.keys(this._endProps).forEach(key => {
	      this._startProps[key] = this.target.getComputedAttribute(key);
	    }));
	  }
	  onEnd(cb) {
	    var _a;
	    cb ? (this._onEnd || (this._onEnd = []), this._onEnd.push(cb)) : null === (_a = this._onEnd) || void 0 === _a || _a.forEach(cb => cb());
	  }
	  onFrame(cb) {
	    cb && (this._onFrame || (this._onFrame = []), this._onFrame.push(cb));
	  }
	  onRemove(cb) {
	    var _a;
	    cb ? (this._onRemove || (this._onRemove = []), this._onRemove.push(cb)) : null === (_a = this._onRemove) || void 0 === _a || _a.forEach(cb => cb());
	  }
	  preventAttr(key) {
	    this._preventAttrs.add(key), delete this._startProps[key], delete this._endProps[key];
	    let step = this._firstStep;
	    for (; step;) step.deleteSelfAttr(key), step = step.next;
	  }
	  preventAttrs(keys) {
	    keys.forEach(key => this._preventAttrs.add(key));
	  }
	  validAttr(key) {
	    return !this._preventAttrs.has(key);
	  }
	  runCb(cb) {
	    var _a;
	    return null === (_a = this._lastStep) || void 0 === _a || _a.onEnd(cb), this;
	  }
	  startAt(t) {
	    return this._startTime = t, this;
	  }
	  customInterpolate(key, ratio, from, to, target, ret) {
	    return !1;
	  }
	  getFromValue() {
	    return this._startProps;
	  }
	  getToValue() {
	    return this._endProps;
	  }
	  stop(type) {
	    let step = this._firstStep;
	    for (; step;) step.stop(), step = step.next;
	    this.status !== AnimateStatus.END && this.onEnd(), this.status = AnimateStatus.END, this.target && ("start" === type ? this.target.setAttributes(this._startProps) : "end" === type ? this.target.setAttributes(this._endProps) : type && this.target.setAttributes(type));
	  }
	  release() {
	    this.status = AnimateStatus.END, this._onRemove && this._onRemove.forEach(cb => cb()), this._onStart = [], this._onFrame = [], this._onEnd = [], this._onRemove = [], this.forEachStep(step => {
	      step.release();
	    });
	  }
	  getDuration() {
	    return this._duration;
	  }
	  getStartTime() {
	    return this._startTime;
	  }
	  afterAll(list) {
	    if (!list || 0 === list.length) return this;
	    let maxEndTime = 0;
	    return list.forEach(animate => {
	      const endTime = animate.getStartTime() + animate.getTotalDuration();
	      maxEndTime = Math.max(maxEndTime, endTime);
	    }), this.startAt(maxEndTime);
	  }
	  after(animate) {
	    if (!animate) return this;
	    const endTime = animate.getStartTime() + animate.getTotalDuration();
	    return this.startAt(endTime);
	  }
	  parallel(animate) {
	    return animate ? (this.startAt(animate.getStartTime()), this) : this;
	  }
	  loop(n) {
	    return !0 === n ? n = 1 / 0 : !1 === n && (n = 0), this._loopCount = n, this.updateDuration(), this;
	  }
	  bounce(b) {
	    return this._bounce = b, this;
	  }
	  advance(delta) {
	    var _a, _b, _c;
	    if (this.status === AnimateStatus.END) return void console.warn("aaa 动画已经结束，不能推进");
	    const nextTime = this.currentTime + delta;
	    if (nextTime < this._startTime) return void (this.currentTime = nextTime);
	    if (nextTime >= this._startTime + this._totalDuration) return null === (_a = this._lastStep) || void 0 === _a || _a.onUpdate(!0, 1, {}), null === (_b = this._lastStep) || void 0 === _b || _b.onEnd(), this.onEnd(), void (this.status = AnimateStatus.END);
	    this.status = AnimateStatus.RUNNING, this.currentTime <= this._startTime && this.onStart(), this.currentTime = nextTime;
	    let cycleTime = nextTime - this._startTime,
	      newLoop = !1,
	      bounceTime = !1;
	    if (this._loopCount > 0) {
	      cycleTime = (nextTime - this._startTime) % this._duration;
	      const currentLoop = Math.floor((nextTime - this._startTime) / this._duration);
	      newLoop = currentLoop > this._currentLoop, this._currentLoop = currentLoop, bounceTime = this._bounce && currentLoop % 2 == 1, bounceTime && (cycleTime = this._duration - cycleTime);
	    }
	    newLoop && !bounceTime && this.target.setAttributes(this._startProps);
	    let targetStep = null;
	    if (this._lastStep === this._firstStep) targetStep = this._firstStep;else {
	      let currentStep = this._firstStep;
	      for (; currentStep;) {
	        const stepStartTime = currentStep.getStartTime(),
	          stepDuration = currentStep.getDuration();
	        if (cycleTime >= stepStartTime && cycleTime <= stepStartTime + stepDuration) {
	          targetStep = currentStep;
	          break;
	        }
	        currentStep = currentStep.next;
	      }
	    }
	    if (!targetStep) return;
	    targetStep !== this.lastRunStep && (null === (_c = this.lastRunStep) || void 0 === _c || _c.onEnd()), this.lastRunStep = targetStep;
	    const ratio = (cycleTime - targetStep.getStartTime()) / targetStep.getDuration(),
	      isEnd = ratio >= 1;
	    targetStep.update(isEnd, ratio, {}), isEnd && (targetStep.onEnd(), this.lastRunStep = null);
	  }
	  updateDuration() {
	    this._lastStep ? (this._duration = this._lastStep.getStartTime() + this._lastStep.getDuration(), this._totalDuration = this._duration * (this._loopCount + 1)) : this._duration = 0;
	  }
	  getTotalDuration() {
	    return this._totalDuration;
	  }
	  getLoop() {
	    return this._loopCount;
	  }
	  forEachStep(cb) {
	    let step = this._firstStep;
	    for (; step;) cb(step), step = step.next;
	  }
	}

	const performanceRAF = new PerformanceRAF();
	class RAFTickHandler {
	  constructor() {
	    this.released = !1;
	  }
	  tick(interval, cb) {
	    performanceRAF.addAnimationFrameCb(() => {
	      if (!this.released) return cb(this);
	    });
	  }
	  release() {
	    this.released = !0;
	  }
	  getTime() {
	    return Date.now();
	  }
	}
	class DefaultTicker extends EventEmitter {
	  constructor(stage) {
	    super(), this.timelines = [], this.frameTimeHistory = [], this.handleTick = (handler, params) => {
	      const {
	        once = !1
	      } = null != params ? params : {};
	      if (this.ifCanStop()) return this.stop(), !1;
	      const currentTime = handler.getTime();
	      this._lastTickTime = currentTime, this.lastFrameTime < 0 && (this.lastFrameTime = currentTime - this.interval + this.timeOffset, this.frameTimeHistory.push(this.lastFrameTime));
	      const delta = currentTime - this.lastFrameTime,
	        skip = this.checkSkip(delta);
	      return skip || (this._handlerTick(delta), this.lastFrameTime = currentTime, this.frameTimeHistory.push(this.lastFrameTime)), once || handler.tick(this.interval, this.handleTick), !skip;
	    }, this._handlerTick = delta => {
	      this.status === STATUS.RUNNING && (this.tickCounts++, this.timelines.forEach(timeline => {
	        timeline.tick(delta);
	      }), this.emit("tick", delta));
	    }, this.init(), this.lastFrameTime = -1, this.tickCounts = 0, this.stage = stage, this.autoStop = !0, this.interval = 16, this.computeTimeOffsetAndJitter();
	  }
	  bindStage(stage) {
	    this.stage = stage;
	  }
	  computeTimeOffsetAndJitter() {
	    this.timeOffset = Math.floor(Math.random() * this.interval), this._jitter = Math.min(Math.max(.2 * this.interval, 6), .7 * this.interval);
	  }
	  init() {
	    this.interval = 16, this.status = STATUS.INITIAL, application.global.hooks.onSetEnv.tap("graph-ticker", () => {
	      this.initHandler(!1);
	    }), application.global.env && this.initHandler(!1);
	  }
	  addTimeline(timeline) {
	    this.timelines.push(timeline);
	  }
	  remTimeline(timeline) {
	    this.timelines = this.timelines.filter(t => t !== timeline);
	  }
	  getTimelines() {
	    return this.timelines;
	  }
	  initHandler(force = !1) {
	    this.setupTickHandler(force);
	  }
	  setupTickHandler(force = !1) {
	    if (!force && this.tickerHandler) return !0;
	    const handler = new RAFTickHandler();
	    return this.tickerHandler && this.tickerHandler.release(), this.tickerHandler = handler, !0;
	  }
	  setInterval(interval) {
	    this.interval = interval, this.computeTimeOffsetAndJitter();
	  }
	  getInterval() {
	    return this.interval;
	  }
	  setFPS(fps) {
	    this.setInterval(Math.floor(1e3 / fps));
	  }
	  getFPS() {
	    return 1e3 / this.interval;
	  }
	  tick(interval) {
	    this.tickerHandler.tick(interval, handler => this.handleTick(handler, {
	      once: !0
	    }));
	  }
	  tickTo(t) {
	    this.tickerHandler.tickTo && this.tickerHandler.tickTo(t, handler => {
	      this.handleTick(handler, {
	        once: !0
	      });
	    });
	  }
	  pause() {
	    return this.status !== STATUS.INITIAL && (this.status = STATUS.PAUSE, !0);
	  }
	  resume() {
	    return this.status !== STATUS.INITIAL && (this.status = STATUS.RUNNING, !0);
	  }
	  ifCanStop() {
	    if (this.autoStop) {
	      if (!this.timelines.length) return !0;
	      if (this.timelines.every(timeline => !timeline.isRunning())) return !0;
	    }
	    return !1;
	  }
	  start(force = !1) {
	    if (this.status === STATUS.RUNNING) return !1;
	    if (!this.tickerHandler) return !1;
	    if (!force) {
	      if (this.status === STATUS.PAUSE) return !1;
	      if (this.ifCanStop()) return !1;
	    }
	    return this.status = STATUS.RUNNING, this.tickerHandler.tick(0, this.handleTick), !0;
	  }
	  stop() {
	    this.status = STATUS.INITIAL, this.setupTickHandler(!0), this.lastFrameTime = -1;
	  }
	  trySyncTickStatus() {
	    this.status === STATUS.INITIAL && this.timelines.some(timeline => timeline.isRunning()) ? this.start() : this.status === STATUS.RUNNING && this.timelines.every(timeline => !timeline.isRunning()) && this.stop();
	  }
	  release() {
	    var _a;
	    this.stop(), this.timelines = [], null === (_a = this.tickerHandler) || void 0 === _a || _a.release(), this.tickerHandler = null, this.lastFrameTime = -1;
	  }
	  checkSkip(delta) {
	    var _a, _b, _c;
	    if ("performance" === (null === (_c = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.params) || void 0 === _b ? void 0 : _b.optimize) || void 0 === _c ? void 0 : _c.tickRenderMode)) return !1;
	    return delta < this.interval + 2 * (Math.random() - .5) * this._jitter;
	  }
	}

	class AnimationTransitionRegistry {
	  constructor() {
	    this.transitions = new Map(), this.registerDefaultTransitions();
	  }
	  static getInstance() {
	    return AnimationTransitionRegistry.instance || (AnimationTransitionRegistry.instance = new AnimationTransitionRegistry()), AnimationTransitionRegistry.instance;
	  }
	  registerDefaultTransitions() {
	    this.registerTransition("appear", "*", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !1
	    })), this.registerTransition("appear", "appear", () => ({
	      allowTransition: !1,
	      stopOriginalTransition: !1
	    })), this.registerTransition("appear", "disappear", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })), this.registerTransition("appear", "exit", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })), this.registerTransition("normal", "*", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !1
	    })), this.registerTransition("normal", "normal", () => ({
	      allowTransition: !1,
	      stopOriginalTransition: !1
	    })), this.registerTransition("normal", "disappear", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })), this.registerTransition("normal", "exit", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })), this.registerTransition("exit", "*", () => ({
	      allowTransition: !1,
	      stopOriginalTransition: !1
	    })), this.registerTransition("exit", "disappear", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })), this.registerTransition("exit", "enter", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })), this.registerTransition("exit", "exit", () => ({
	      allowTransition: !1,
	      stopOriginalTransition: !1
	    })), this.registerTransition("enter", "*", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !1
	    })), this.registerTransition("enter", "enter", () => ({
	      allowTransition: !1,
	      stopOriginalTransition: !1
	    })), this.registerTransition("enter", "disappear", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })), this.registerTransition("enter", "exit", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })), this.registerTransition("disappear", "*", () => ({
	      allowTransition: !1,
	      stopOriginalTransition: !1
	    })), this.registerTransition("disappear", "appear", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })), this.registerTransition("update", "*", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !1
	    })), this.registerTransition("update", "disappear", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })), this.registerTransition("update", "exit", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })), this.registerTransition("state", "*", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !1
	    })), this.registerTransition("state", "disappear", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })), this.registerTransition("state", "exit", () => ({
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    }));
	  }
	  isTransitionAllowed(fromState, toState, graphic) {
	    var _a, _b, _c, _d;
	    let func = null === (_a = this.transitions.get(fromState)) || void 0 === _a ? void 0 : _a.get(toState);
	    return func ? func(graphic, fromState) : (func = null === (_b = this.transitions.get(fromState)) || void 0 === _b ? void 0 : _b.get("*"), func ? func(graphic, fromState) : (func = null === (_c = this.transitions.get("*")) || void 0 === _c ? void 0 : _c.get(toState), func ? func(graphic, fromState) : (func = null === (_d = this.transitions.get("*")) || void 0 === _d ? void 0 : _d.get("*"), func ? func(graphic, fromState) : {
	      allowTransition: !0,
	      stopOriginalTransition: !0
	    })));
	  }
	  registerTransition(fromState, toState, transition) {
	    let fromStateMap = this.transitions.get(fromState);
	    fromStateMap || (fromStateMap = new Map(), this.transitions.set(fromState, fromStateMap)), fromStateMap.set(toState, transition);
	  }
	}
	AnimationTransitionRegistry.getInstance();

	class AnimateExecutor {
	  static registerBuiltInAnimate(name, animate) {
	    AnimateExecutor.builtInAnimateMap[name] = animate;
	  }
	  constructor(target) {
	    this._animates = [], this._startCallbacks = [], this._endCallbacks = [], this._started = !1, this._activeCount = 0, this._target = target;
	  }
	  get started() {
	    return this._started;
	  }
	  onStart(cb) {
	    cb ? (this._startCallbacks.push(cb), this._started && this._activeCount > 0 && cb()) : this._startCallbacks.forEach(cb => {
	      cb();
	    });
	  }
	  onEnd(cb) {
	    cb ? this._endCallbacks.push(cb) : this._endCallbacks.forEach(cb => {
	      cb();
	    });
	  }
	  _trackAnimation(animate) {
	    this._animates.push(animate), this._activeCount++, 1 !== this._activeCount || this._started || (this._started = !0, this.onStart()), animate.onEnd(() => {
	      this._activeCount--;
	      const index = this._animates.indexOf(animate);
	      index >= 0 && this._animates.splice(index, 1), 0 === this._activeCount && this._started && (this._started = !1, this.onEnd());
	    });
	  }
	  parseParams(params, isTimeline, child) {
	    var _a, _b;
	    const totalTime = this.resolveValue(params.totalTime, void 0, void 0),
	      startTime = this.resolveValue(params.startTime, void 0, 0),
	      parsedParams = Object.assign({}, params);
	    parsedParams.oneByOneDelay = 0, parsedParams.startTime = startTime, parsedParams.totalTime = totalTime;
	    const oneByOne = this.resolveValue(params.oneByOne, child, !1);
	    if (isTimeline) {
	      const timeSlices = parsedParams.timeSlices;
	      isArray$1(timeSlices) || (parsedParams.timeSlices = [timeSlices]);
	      let sliceTime = 0;
	      parsedParams.timeSlices = parsedParams.timeSlices.map(slice => {
	        const delay = this.resolveValue(slice.delay, child, 0),
	          delayAfter = this.resolveValue(slice.delayAfter, child, 0),
	          duration = this.resolveValue(slice.duration, child, 300);
	        return sliceTime += delay + duration + delayAfter, Object.assign(Object.assign({}, slice), {
	          delay: delay,
	          delayAfter: delayAfter,
	          duration: duration
	        });
	      });
	      let oneByOneDelay = 0;
	      oneByOne && (oneByOneDelay = "number" == typeof oneByOne ? oneByOne : oneByOne ? sliceTime : 0), parsedParams.oneByOneDelay = oneByOneDelay;
	      let scale = 1;
	      if (totalTime) {
	        const _totalTime = sliceTime + oneByOneDelay * (this._target.count - 2);
	        scale = totalTime ? totalTime / _totalTime : 1;
	      }
	      parsedParams.timeSlices = parsedParams.timeSlices.map(slice => {
	        let effects = slice.effects;
	        return Array.isArray(effects) || (effects = [effects]), Object.assign(Object.assign({}, slice), {
	          delay: slice.delay * scale,
	          delayAfter: slice.delayAfter * scale,
	          duration: slice.duration * scale,
	          effects: effects.map(effect => {
	            var _a, _b;
	            const custom = null !== (_a = effect.custom) && void 0 !== _a ? _a : AnimateExecutor.builtInAnimateMap[null !== (_b = effect.type) && void 0 !== _b ? _b : "fromTo"],
	              customType = custom && isFunction$1(custom) ? /^class\s/.test(Function.prototype.toString.call(custom)) ? 1 : 2 : 0;
	            return Object.assign(Object.assign({}, effect), {
	              custom: custom,
	              customType: customType
	            });
	          })
	        });
	      }), parsedParams.oneByOneDelay = oneByOneDelay * scale, parsedParams.startTime = startTime * scale;
	    } else {
	      const delay = this.resolveValue(params.delay, child, 0),
	        delayAfter = this.resolveValue(params.delayAfter, child, 0),
	        duration = this.resolveValue(params.duration, child, 300);
	      let oneByOneDelay = 0;
	      oneByOne && (oneByOneDelay = "number" == typeof oneByOne ? oneByOne : oneByOne ? delay + delayAfter + duration : 0), parsedParams.oneByOneDelay = oneByOneDelay, parsedParams.custom = null !== (_a = params.custom) && void 0 !== _a ? _a : AnimateExecutor.builtInAnimateMap[null !== (_b = params.type) && void 0 !== _b ? _b : "fromTo"];
	      const customType = parsedParams.custom && isFunction$1(parsedParams.custom) ? /^class\s/.test(Function.prototype.toString.call(parsedParams.custom)) ? 1 : 2 : 0;
	      if (parsedParams.customType = customType, totalTime) {
	        const _totalTime = delay + delayAfter + duration + oneByOneDelay * (this._target.count - 2),
	          scale = totalTime ? totalTime / _totalTime : 1;
	        parsedParams.delay = delay * scale, parsedParams.delayAfter = delayAfter * scale, parsedParams.duration = duration * scale, parsedParams.oneByOneDelay = oneByOneDelay * scale, parsedParams.startTime = startTime;
	      }
	    }
	    return parsedParams;
	  }
	  execute(params) {
	    Array.isArray(params) ? params.forEach(param => this._execute(param)) : this._execute(params);
	  }
	  _execute(params) {
	    if (params.selfOnly) return this._executeItem(params, this._target, 0, 1);
	    const isTimeline = ("timeSlices" in params);
	    let filteredChildren;
	    isTimeline && params.partitioner && (filteredChildren = (null != filteredChildren ? filteredChildren : this._target.getChildren()).filter(child => {
	      var _a, _b;
	      return params.partitioner(null === (_b = null === (_a = child.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], child, {});
	    })), isTimeline && params.sort && (filteredChildren = null != filteredChildren ? filteredChildren : this._target.getChildren(), filteredChildren.sort((a, b) => {
	      var _a, _b, _c, _d;
	      return params.sort(null === (_b = null === (_a = a.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], null === (_d = null === (_c = b.context) || void 0 === _c ? void 0 : _c.data) || void 0 === _d ? void 0 : _d[0], a, b, {});
	    }));
	    const cb = isTimeline ? (child, index, count) => {
	      const parsedParams = this.parseParams(params, isTimeline, child),
	        animate = this.executeTimelineItem(parsedParams, child, index, count);
	      animate && this._trackAnimation(animate);
	    } : (child, index, count) => {
	      const parsedParams = this.parseParams(params, isTimeline, child),
	        animate = this.executeTypeConfigItem(parsedParams, child, index, count);
	      animate && this._trackAnimation(animate);
	    };
	    filteredChildren ? filteredChildren.forEach((child, index) => cb(child, index, filteredChildren.length)) : this._target.count <= 1 ? cb(this._target, 0, 1) : this._target.forEachChildren((child, index) => cb(child, index, this._target.count - 1));
	  }
	  executeTypeConfigItem(params, graphic, index, count) {
	    var _a, _b, _c, _d, _e, _f, _g, _h;
	    const {
	        type = "fromTo",
	        channel: channel,
	        customParameters: customParameters,
	        easing = "linear",
	        delay = 0,
	        delayAfter = 0,
	        duration = 300,
	        startTime = 0,
	        oneByOneDelay = 0,
	        loop: loop,
	        bounce: bounce,
	        priority = 0,
	        options: options,
	        custom: custom,
	        customType: customType,
	        controlOptions: controlOptions
	      } = params,
	      animate = graphic.animate();
	    animate.priority = priority;
	    const delayValue = isFunction$1(delay) ? delay(null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], graphic, {}) : delay,
	      datum = null === (_d = null === (_c = graphic.context) || void 0 === _c ? void 0 : _c.data) || void 0 === _d ? void 0 : _d[0],
	      indexKey = null === (_e = graphic.context) || void 0 === _e ? void 0 : _e.indexKey;
	    datum && indexKey && (index = null !== (_f = datum[indexKey]) && void 0 !== _f ? _f : index), animate.startAt(startTime);
	    const wait = index * oneByOneDelay + delayValue;
	    wait > 0 && animate.wait(wait);
	    let parsedFromProps = null,
	      props = params.to,
	      from = params.from;
	    props || (parsedFromProps || (parsedFromProps = this.createPropsFromChannel(channel, graphic)), props = parsedFromProps.props), from || (parsedFromProps || (parsedFromProps = this.createPropsFromChannel(channel, graphic)), from = parsedFromProps.from), this._handleRunAnimate(animate, custom, customType, from, props, duration, easing, customParameters, controlOptions, options, type, graphic);
	    let totalDelay = 0;
	    oneByOneDelay && (totalDelay = oneByOneDelay * (count - index - 1));
	    const delayAfterValue = isFunction$1(delayAfter) ? delayAfter(null === (_h = null === (_g = graphic.context) || void 0 === _g ? void 0 : _g.data) || void 0 === _h ? void 0 : _h[0], graphic, {}) : delayAfter;
	    return delayAfterValue > 0 && (totalDelay += delayAfterValue), totalDelay > 0 && animate.wait(totalDelay), loop && loop > 0 && animate.loop(loop), bounce && animate.bounce(!0), animate;
	  }
	  _handleRunAnimate(animate, custom, customType, from, props, duration, easing, customParameters, controlOptions, options, type, graphic) {
	    var _a, _b, _c, _d, _e, _f;
	    if (custom && customType) {
	      const customParams = Object.assign({
	          width: (null === (_a = graphic.stage) || void 0 === _a ? void 0 : _a.width) || 0,
	          height: (null === (_b = graphic.stage) || void 0 === _b ? void 0 : _b.height) || 0,
	          group: this._target.parent
	        }, this.resolveValue(customParameters, graphic)),
	        objOptions = isFunction$1(options) ? options.call(null, null !== (_d = customParams && (null === (_c = customParams.data) || void 0 === _c ? void 0 : _c[0])) && void 0 !== _d ? _d : null === (_f = null === (_e = graphic.context) || void 0 === _e ? void 0 : _e.data) || void 0 === _f ? void 0 : _f[0], graphic, customParams) : options;
	      customParams.options = objOptions, customParams.controlOptions = controlOptions, 1 === customType ? this.createCustomAnimation(animate, custom, from, props, duration, easing, customParams) : 2 === customType && this.createCustomInterpolatorAnimation(animate, custom, props, duration, easing, customParams);
	    } else "to" === type ? animate.to(props, duration, easing) : "from" === type && animate.from(props, duration, easing);
	  }
	  executeTimelineItem(params, graphic, index, count) {
	    var _a, _b, _c, _d;
	    const {
	        timeSlices: timeSlices,
	        startTime = 0,
	        loop: loop,
	        bounce: bounce,
	        oneByOneDelay: oneByOneDelay,
	        priority: priority,
	        controlOptions: controlOptions
	      } = params,
	      datum = null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0],
	      indexKey = null === (_c = graphic.context) || void 0 === _c ? void 0 : _c.indexKey;
	    datum && indexKey && (index = null !== (_d = datum[indexKey]) && void 0 !== _d ? _d : index);
	    const animate = graphic.animate();
	    animate.priority = priority, animate.startAt(startTime), animate.wait(index * oneByOneDelay), loop && loop > 0 && animate.loop(loop), bounce && animate.bounce(!0);
	    return (Array.isArray(timeSlices) ? timeSlices : [timeSlices]).forEach(slice => {
	      this.applyTimeSliceToAnimate(slice, animate, graphic, controlOptions);
	    }), oneByOneDelay && animate.wait(oneByOneDelay * (count - index - 1)), animate;
	  }
	  applyTimeSliceToAnimate(slice, animate, graphic, controlOptions) {
	    var _a, _b, _c, _d;
	    const {
	        effects: effects,
	        duration = 300,
	        delay = 0,
	        delayAfter = 0
	      } = slice,
	      delayValue = isFunction$1(delay) ? delay(null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], graphic, {}) : delay,
	      delayAfterValue = isFunction$1(delayAfter) ? delayAfter(null === (_d = null === (_c = graphic.context) || void 0 === _c ? void 0 : _c.data) || void 0 === _d ? void 0 : _d[0], graphic, {}) : delayAfter;
	    delayValue > 0 && animate.wait(delayValue);
	    (Array.isArray(effects) ? effects : [effects]).forEach(effect => {
	      var _a;
	      const {
	        type = "fromTo",
	        channel: channel,
	        customParameters: customParameters,
	        easing = "linear",
	        options: options
	      } = effect;
	      let parsedFromProps = null,
	        props = effect.to,
	        from = effect.from;
	      props || (parsedFromProps || (parsedFromProps = this.createPropsFromChannel(channel, graphic)), props = parsedFromProps.props), from || (parsedFromProps || (parsedFromProps = this.createPropsFromChannel(channel, graphic)), from = parsedFromProps.from);
	      const custom = null !== (_a = effect.custom) && void 0 !== _a ? _a : AnimateExecutor.builtInAnimateMap[type],
	        customType = effect.customType;
	      this._handleRunAnimate(animate, custom, customType, from, props, duration, easing, customParameters, controlOptions, options, type, graphic);
	    }), delayAfterValue > 0 && animate.wait(delayAfterValue);
	  }
	  createCustomInterpolatorAnimation(animate, interpolator, props, duration, easing, customParams) {
	    const to = props;
	    Object.keys(to).forEach(key => {
	      animate.target.getComputedAttribute(key);
	    }), animate.interpolateUpdateFunction = (from, to, ratio, step, target) => {
	      interpolator(ratio, from, to, step, target, animate.target, customParams);
	    }, animate.to(props, duration, easing);
	  }
	  createCustomAnimation(animate, CustomAnimateConstructor, from, props, duration, easing, customParams) {
	    const customAnimate = new CustomAnimateConstructor(from, props, duration, easing, customParams);
	    animate.play(customAnimate);
	  }
	  createPropsFromChannel(channel, graphic) {
	    const props = {};
	    let from = null;
	    return channel ? (Array.isArray(channel) ? channel.forEach(key => {
	      var _a, _b;
	      const value = null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.diffAttrs) || void 0 === _b ? void 0 : _b[key];
	      void 0 !== value && (props[key] = value);
	    }) : Object.keys(channel).forEach(key => {
	      var _a, _b, _c, _d;
	      const config = channel[key];
	      void 0 !== config.to && ("function" == typeof config.to ? props[key] = config.to(null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], graphic, {}) : props[key] = config.to), void 0 !== config.from && (from || (from = {}), "function" == typeof config.from ? from[key] = config.from(null === (_d = null === (_c = graphic.context) || void 0 === _c ? void 0 : _c.data) || void 0 === _d ? void 0 : _d[0], graphic, {}) : from[key] = config.from);
	    }), {
	      from: from,
	      props: props
	    }) : {
	      from: from,
	      props: props
	    };
	  }
	  resolveValue(value, graphic, defaultValue) {
	    var _a, _b;
	    return void 0 === value ? defaultValue : "function" == typeof value && graphic ? value(null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], graphic, {}) : value;
	  }
	  executeItem(params, graphic, index = 0, count = 1) {
	    return Array.isArray(params) ? params.map(param => this._executeItem(param, graphic, index, count)).filter(Boolean) : [this._executeItem(params, graphic, index, count)].filter(Boolean);
	  }
	  _executeItem(params, graphic, index = 0, count = 1) {
	    if (!graphic) return null;
	    const isTimeline = ("timeSlices" in params);
	    let animate = null;
	    const parsedParams = this.parseParams(params, isTimeline);
	    return animate = isTimeline ? this.executeTimelineItem(parsedParams, graphic, index, count) : this.executeTypeConfigItem(parsedParams, graphic, index, count), animate && this._trackAnimation(animate), animate;
	  }
	  stop(type) {
	    for (; this._animates.length > 0;) {
	      const animate = this._animates.pop();
	      null == animate || animate.stop(type);
	    }
	    this._animates = [], this._activeCount = 0, this._started && (this._started = !1, this.onEnd());
	  }
	}
	AnimateExecutor.builtInAnimateMap = {};

	const AnimationStates = {
	  APPEAR: "appear",
	  DISAPPEAR: "disappear",
	  UPDATE: "update",
	  HIGHLIGHT: "highlight",
	  UNHIGHLIGHT: "unhighlight",
	  SELECT: "select",
	  UNSELECT: "unselect",
	  HOVER: "hover",
	  UNHOVER: "unhover",
	  ACTIVE: "active",
	  INACTIVE: "inactive"
	};
	class AnimationStateStore {
	  constructor(graphic) {
	    this.graphic = graphic;
	  }
	  registerState(state) {
	    this.states || (this.states = new Map()), this.states.set(state.name, state);
	  }
	  clearStates() {
	    var _a;
	    null === (_a = this.states) || void 0 === _a || _a.clear();
	  }
	}
	class AnimationStateManager {
	  constructor(graphic) {
	    this.stateList = null, this.graphic = graphic;
	  }
	  applyState(nextState, animationConfig, callback) {
	    const registry = AnimationTransitionRegistry.getInstance(),
	      shouldStopState = [],
	      shouldApplyState = [];
	    if (this.stateList && this.stateList.length ? nextState.forEach((state, index) => {
	      const result = {
	        allowTransition: !0,
	        stopOriginalTransition: !0
	      };
	      this.stateList.forEach(currState => {
	        const _result = registry.isTransitionAllowed(currState.state, state, this.graphic);
	        result.allowTransition = result.allowTransition && _result.allowTransition;
	      }), result.allowTransition && (shouldApplyState.push({
	        state: state,
	        animationConfig: isArray$1(animationConfig[index]) ? animationConfig[index].map(item => item.animation) : animationConfig[index].animation,
	        executor: new AnimateExecutor(this.graphic)
	      }), this.stateList.forEach(currState => {
	        registry.isTransitionAllowed(currState.state, state, this.graphic).stopOriginalTransition && shouldStopState.push(currState);
	      }));
	    }) : nextState.forEach((state, index) => {
	      shouldApplyState.push({
	        state: state,
	        animationConfig: isArray$1(animationConfig[index]) ? animationConfig[index].map(item => item.animation) : animationConfig[index].animation,
	        executor: new AnimateExecutor(this.graphic)
	      });
	    }), shouldStopState.forEach(state => {
	      state.executor.stop();
	    }), shouldApplyState.length) {
	      shouldApplyState[0].executor.execute(shouldApplyState[0].animationConfig);
	      for (let i = 0; i < shouldApplyState.length; i++) {
	        const nextState = shouldApplyState[i + 1],
	          currentState = shouldApplyState[i];
	        currentState.executor.onEnd(() => {
	          nextState && nextState.executor.execute(nextState.animationConfig), this.stateList = this.stateList.filter(state => state !== currentState), i === shouldApplyState.length - 1 && callback && callback(!1);
	        });
	      }
	    } else callback && callback(!0);
	    this.stateList ? this.stateList = this.stateList.filter(state => !shouldStopState.includes(state)) : this.stateList = [], this.stateList.push(...shouldApplyState);
	  }
	  applyAppearState(animationConfig, callback) {
	    this.applyState([AnimationStates.APPEAR], [{
	      name: AnimationStates.APPEAR,
	      animation: animationConfig
	    }], callback);
	  }
	  applyDisappearState(animationConfig, callback) {
	    this.applyState([AnimationStates.DISAPPEAR], [{
	      name: AnimationStates.DISAPPEAR,
	      animation: animationConfig
	    }], callback);
	  }
	  applyUpdateState(animationConfig, callback) {
	    this.applyState([AnimationStates.UPDATE], [{
	      name: AnimationStates.UPDATE,
	      animation: animationConfig
	    }], callback);
	  }
	  applyHighlightState(animationConfig, callback) {
	    this.applyState([AnimationStates.HIGHLIGHT], [{
	      name: AnimationStates.HIGHLIGHT,
	      animation: animationConfig
	    }], callback);
	  }
	  applyUnhighlightState(animationConfig, callback) {
	    this.applyState([AnimationStates.UNHIGHLIGHT], [{
	      name: AnimationStates.UNHIGHLIGHT,
	      animation: animationConfig
	    }], callback);
	  }
	  stopState(state, type) {
	    var _a;
	    const stateInfo = null === (_a = this.stateList) || void 0 === _a ? void 0 : _a.find(stateInfo => stateInfo.state === state);
	    stateInfo && stateInfo.executor.stop(type);
	  }
	  clearState() {
	    var _a;
	    null === (_a = this.stateList) || void 0 === _a || _a.forEach(state => {
	      state.executor.stop();
	    }), this.stateList = null;
	  }
	  reApplyState(state) {
	    var _a;
	    const stateInfo = null === (_a = this.stateList) || void 0 === _a ? void 0 : _a.find(stateInfo => stateInfo.state === state);
	    if (stateInfo && stateInfo.executor.started) {
	      const stateList = this.stateList.slice();
	      stateInfo.executor.stop(), this.stateList = stateList, stateInfo.executor.execute(stateInfo.animationConfig);
	    }
	  }
	}

	class GraphicStateExtension {
	  _getAnimationStateManager(graphic) {
	    return graphic._animationStateManager || (graphic._animationStateManager = new AnimationStateManager(graphic)), graphic._animationStateManager;
	  }
	  _getAnimationStateStore(graphic) {
	    return graphic._animationStateStore || (graphic._animationStateStore = new AnimationStateStore(graphic)), graphic._animationStateStore;
	  }
	  registerAnimationState(state) {
	    return this._getAnimationStateStore(this).registerState(state), this;
	  }
	  applyAnimationState(state, animationConfig, callback) {
	    return this._getAnimationStateManager(this).applyState(state, animationConfig, callback), this;
	  }
	  applyAppearState(animationConfig, callback) {
	    return this._getAnimationStateManager(this).applyAppearState(animationConfig, callback), this;
	  }
	  applyDisappearState(animationConfig, callback) {
	    return this._getAnimationStateManager(this).applyDisappearState(animationConfig, callback), this;
	  }
	  applyUpdateState(animationConfig, callback) {
	    return this._getAnimationStateManager(this).applyUpdateState(animationConfig, callback), this;
	  }
	  applyHighlightState(animationConfig, callback) {
	    return this._getAnimationStateManager(this).applyHighlightState(animationConfig, callback), this;
	  }
	  applyUnhighlightState(animationConfig, callback) {
	    return this._getAnimationStateManager(this).applyUnhighlightState(animationConfig, callback), this;
	  }
	  stopAnimationState(state, type, deep = !1) {
	    return this._getAnimationStateManager(this).stopState(state, type), deep && this.isContainer && this.forEachChildren(child => {
	      child.stopAnimationState(state, type, deep);
	    }), this;
	  }
	  clearAnimationStates() {
	    const stateManager = this._animationStateManager;
	    return stateManager && stateManager.clearState(), this;
	  }
	  reApplyAnimationState(state, deep = !1) {
	    const stateManager = this._animationStateManager;
	    return stateManager && stateManager.reApplyState(state), deep && this.isContainer && this.forEachChildren(child => {
	      child.reApplyAnimationState(state, deep);
	    }), this;
	  }
	  static extend(graphic) {
	    return new GraphicStateExtension()._getAnimationStateManager(graphic), graphic;
	  }
	}

	class AnimateExtension {
	  getAttributes(final = !1) {
	    return final && this.finalAttribute ? this.finalAttribute : this.attribute;
	  }
	  animate(params) {
	    var _a, _b, _c;
	    const animate = new Animate(null == params ? void 0 : params.id, null !== (_b = null !== (_a = null == params ? void 0 : params.timeline) && void 0 !== _a ? _a : this.stage && this.stage.getTimeline()) && void 0 !== _b ? _b : defaultTimeline, null == params ? void 0 : params.slience);
	    if (animate.bind(this), params) {
	      const {
	        onStart: onStart,
	        onEnd: onEnd,
	        onRemove: onRemove
	      } = params;
	      null != onStart && animate.onStart(onStart), null != onEnd && animate.onEnd(onEnd), null != onRemove && animate.onRemove(onRemove);
	    }
	    return null === (_c = this.stage) || void 0 === _c || _c.ticker.start(), animate;
	  }
	  createTimeline() {
	    return new DefaultTimeline();
	  }
	  createTicker(stage) {
	    return new DefaultTicker(stage);
	  }
	  setFinalAttributes(finalAttribute) {
	    this.finalAttribute || (this.finalAttribute = {}), Object.assign(this.finalAttribute, finalAttribute);
	  }
	  initFinalAttributes(finalAttribute) {
	    this.finalAttribute = finalAttribute;
	  }
	  initAnimateExecutor() {
	    this._animateExecutor || (this._animateExecutor = new AnimateExecutor(this));
	  }
	  executeAnimation(config) {
	    return this.initAnimateExecutor(), this._animateExecutor.execute(config), this;
	  }
	  executeAnimations(configs) {
	    return this.initAnimateExecutor(), configs.forEach(config => {
	      this._animateExecutor.execute(config);
	    }), this;
	  }
	  getFinalAttribute() {
	    return this.finalAttribute;
	  }
	  getGraphicAttribute(key, prev = !1) {
	    return !prev && this.finalAttribute ? this.finalAttribute[key] : this.attribute[key];
	  }
	  pauseAnimation(deep = !1) {
	    this.animates && this.animates.forEach(animate => animate.pause()), deep && this.isContainer && this.forEachChildren(child => {
	      child.pauseAnimation(deep);
	    });
	  }
	  resumeAnimation(deep = !1) {
	    this.animates && this.animates.forEach(animate => animate.resume()), deep && this.isContainer && this.forEachChildren(child => {
	      child.resumeAnimation(deep);
	    });
	  }
	  stopAnimation(deep = !1) {
	    this.animates && this.animates.forEach(animate => animate.stop()), deep && this.isContainer && this.forEachChildren(child => {
	      child.stopAnimation(deep);
	    });
	  }
	}

	function registerAnimate() {
	  mixin(Graphic, GraphicStateExtension), mixin(Graphic, AnimateExtension);
	}

	class ACustomAnimate extends Step {
	  constructor(customFrom, customTo, duration, easing, params) {
	    super("customAnimate", customTo, duration, easing), this.type = "customAnimate", this.customFrom = customFrom, this.params = params, this.from = customFrom, this.to = customTo;
	  }
	  update(end, ratio, out) {
	    if (this.onStart(), !this.props || !this.propKeys) return;
	    const easedRatio = this.easing(ratio);
	    this.onUpdate(end, easedRatio, out), this.syncAttributeUpdate();
	  }
	  setProps(props) {
	    this.props = props, this.propKeys = Object.keys(props), this.animate.reSyncProps();
	  }
	}

	class RotateBySphereAnimate extends ACustomAnimate {
	  onBind() {
	    super.onBind(), this.propKeys = ["x", "y", "z", "alpha", "zIndex"];
	  }
	  onFirstRun() {
	    super.onFirstRun();
	    const finalAttribute = this.target.getFinalAttribute();
	    finalAttribute && this.target.setAttributes(finalAttribute);
	  }
	  onStart() {
	    super.onStart();
	    const {
	        center: center,
	        r: r
	      } = "function" == typeof this.params ? this.params() : this.params,
	      startX = this.target.finalAttribute.x,
	      startY = this.target.finalAttribute.y,
	      startZ = this.target.finalAttribute.z,
	      phi = Math.acos((startY - center.y) / r);
	    let theta = Math.acos((startX - center.x) / r / Math.sin(phi));
	    startZ - center.z < 0 && (theta = pi2 - theta), this.theta = theta, this.phi = phi;
	  }
	  onEnd() {}
	  onUpdate(end, ratio, out) {
	    if (null == this.phi || null == this.theta) return;
	    const target = this.target,
	      {
	        center: center,
	        r: r,
	        cb: cb
	      } = "function" == typeof this.params ? this.params() : this.params,
	      deltaAngle = 2 * Math.PI * ratio,
	      theta = this.theta + deltaAngle,
	      phi = this.phi,
	      x = r * Math.sin(phi) * Math.cos(theta) + center.x,
	      y = r * Math.cos(phi) + center.y,
	      z = r * Math.sin(phi) * Math.sin(theta) + center.z;
	    for (target.attribute.x = x, target.attribute.y = y, target.attribute.z = z, target.attribute.alpha = theta + pi / 2; target.attribute.alpha > pi2;) target.attribute.alpha -= pi2;
	    target.attribute.alpha = pi2 - target.attribute.alpha, target.attribute.zIndex = -1e4 * target.attribute.z, cb && cb(out);
	  }
	}

	const WordCloud3dAnimation = (params) => {
	    return {
	        custom: RotateBySphereAnimate,
	        customParameters: () => params,
	        easing: 'linear',
	        loop: Infinity,
	        duration: 6000
	    };
	};
	const registerWordCloud3dAnimation = () => {
	    vchart.Factory.registerAnimation('wordCloud3d', (params) => ({
	        appear: WordCloud3dAnimation(params)
	    }));
	};

	const wordCloud3d = {
	    word: {
	        padding: 1,
	        style: {
	            textAlign: 'center',
	            textBaseline: 'alphabetic'
	        }
	    }
	};

	class WordCloud3dSeries extends vchart.BaseWordCloudSeries {
	    constructor() {
	        super(...arguments);
	        this.type = SeriesType3dEnum.wordCloud3d;
	    }
	    _wordCloudTransformOption() {
	        var _a;
	        return Object.assign(Object.assign({}, super._wordCloudTransformOption()), { postProjection: (_a = this._spec.postProjection) !== null && _a !== void 0 ? _a : 'StereographicProjection', depth_3d: this._spec.depth_3d });
	    }
	    _wordCloudShapeTransformOption() {
	        var _a;
	        return Object.assign(Object.assign({}, super._wordCloudShapeTransformOption()), { postProjection: (_a = this._spec.postProjection) !== null && _a !== void 0 ? _a : 'StereographicProjection', depth_3d: this._spec.depth_3d });
	    }
	    initMark() {
	        this._wordMark = this._createMark(vchart.BaseWordCloudSeries.mark.word, {
	            groupKey: this._seriesField,
	            isSeriesMark: true
	        }, {
	            support3d: true
	        });
	    }
	    initMarkStyle() {
	        super.initMarkStyle();
	        const wordMark = this._wordMark;
	        if (wordMark) {
	            this.setMarkStyle(wordMark, {
	                z: (datum) => { var _a; return (_a = datum.z) !== null && _a !== void 0 ? _a : 0; }
	            }, 'normal', vchart.AttributeLevel.Series);
	        }
	    }
	    initAnimation() {
	        var _a, _b;
	        const padding = (_a = this._padding) !== null && _a !== void 0 ? _a : {};
	        if (this._wordMark) {
	            this._wordMark.setAnimationConfig(vchart.animationConfig((_b = vchart.Factory.getAnimationInKey('wordCloud3d')) === null || _b === void 0 ? void 0 : _b(() => {
	                var _a;
	                const stage = this.getCompiler().getStage();
	                const width = stage.width - padding.left || 0 - padding.right || 0;
	                const height = stage.height - padding.top || 0 - padding.bottom || 0;
	                const r = Math.max(width, height) / 2;
	                return {
	                    center: { x: r, y: r, z: (_a = this._spec.depth_3d) !== null && _a !== void 0 ? _a : r },
	                    r
	                };
	            }), vchart.userAnimationConfig("word", this._spec, this._markAttributeContext)));
	        }
	    }
	}
	WordCloud3dSeries.type = SeriesType3dEnum.wordCloud3d;
	WordCloud3dSeries.builtInTheme = { wordCloud3d };
	const registerWordCloud3dSeries = () => {
	    vchart.registerTextMark();
	    registerWordCloud3dAnimation();
	    vchart.Factory.registerSeries(WordCloud3dSeries.type, WordCloud3dSeries);
	};
	const registerWordCloudShape3dSeries = () => {
	    registerWordCloud3dSeries();
	};

	class WordCloud3dChartSpecTransformer extends vchart.BaseWordCloudChartSpecTransformer {
	    _getDefaultSeriesSpec(spec) {
	        const series = super._getDefaultSeriesSpec(spec);
	        series.depth_3d = spec.depth_3d;
	        return series;
	    }
	}

	class WordCloud3dChart extends vchart.BaseWordCloudChart {
	    constructor() {
	        super(...arguments);
	        this.transformerConstructor = WordCloud3dChartSpecTransformer;
	        this.type = "wordCloud3d";
	        this.seriesType = SeriesType3dEnum.wordCloud3d;
	    }
	}
	WordCloud3dChart.type = "wordCloud3d";
	WordCloud3dChart.seriesType = SeriesType3dEnum.wordCloud3d;
	WordCloud3dChart.transformerConstructor = WordCloud3dChartSpecTransformer;
	const registerWordCloud3dChart = () => {
	    register3DPlugin();
	    registerWordCloud3dSeries();
	    vchart.Factory.registerChart(WordCloud3dChart.type, WordCloud3dChart);
	};
	const registerWordCloudShape3dChart = () => {
	    register3DPlugin();
	    registerWordCloudShape3dSeries();
	    registerWordCloud3dChart();
	};

	const axisZ = {
	    label: {
	        space: 0
	    }
	};

	const getUpdateAttributeOfZAxis = (axis, ignoreGrid) => {
	    var _a;
	    const regionSize = vchart.getCombinedSizeOfRegions(axis.getRegions());
	    const { width } = axis.getLayoutRect();
	    const axisLength = width;
	    const depth = axis.layout3dBox ? axis.layout3dBox.length : 0;
	    const depthZ = axis.layout3dBox ? axis.layout3dBox.width : 0;
	    const end = { x: depth, y: 0 };
	    const items = axis.getLabelItems(axisLength);
	    const attrs = {
	        start: { x: 0, y: 0 },
	        end,
	        title: {
	            text: axis._spec.title.text || axis._dataFieldText,
	            maxWidth: axis._getTitleLimit(false)
	        },
	        items,
	        scale: axis._scale.clone()
	    };
	    const directionStr = (_a = axis.directionStr) !== null && _a !== void 0 ? _a : 'r2l';
	    let anchor3d = [0, 0];
	    let alpha = -Math.PI / 2;
	    let z = 0;
	    if (directionStr === 'l2r') {
	        z = axis.layout3dBox.length;
	        anchor3d = [0, 0, 0];
	        alpha = Math.PI / 2;
	    }
	    attrs.z = z;
	    attrs.alpha = alpha;
	    attrs.anchor3d = anchor3d;
	    if (!ignoreGrid) {
	        attrs.grid = {
	            type: 'line',
	            start: { x: 0, y: 0 },
	            end,
	            items: items[0],
	            verticalFactor: axis._axisStyle.verticalFactor,
	            depth: depthZ,
	            length: !ignoreGrid ? regionSize.height : 0,
	            alpha,
	            z,
	            anchor3d
	        };
	    }
	    return attrs;
	};

	class Axis3dMixin {
	    setLayout3dBox(box3d) {
	        this.layout3dBox = box3d;
	    }
	    _afterUpdateAttribute(attrs, ignoreGrid) {
	        const isZ = vchart.isZAxis(this._orient);
	        const isX = vchart.isXAxis(this._orient);
	        const isY = vchart.isYAxis(this._orient);
	        let regionHeight = 0;
	        let regionWidth = 0;
	        if (!ignoreGrid) {
	            const regions = this.getRegions();
	            let { x: minX, y: minY } = regions[0].getLayoutStartPoint();
	            let maxX = minX + regions[0].getLayoutRect().width;
	            let maxY = minY + regions[0].getLayoutRect().height;
	            for (let index = 1; index < regions.length; index++) {
	                const region = regions[index];
	                const { x, y } = region.getLayoutStartPoint();
	                const { width, height } = region.getLayoutRect();
	                minX = Math.min(minX, x);
	                maxX = Math.max(maxX, width + x);
	                minY = Math.min(minY, y);
	                maxY = Math.max(maxY, height + y);
	            }
	            regionHeight = Math.abs(maxY - minY);
	            regionWidth = Math.abs(maxX - minX);
	        }
	        let gridLength = 0;
	        let axisLength = 0;
	        const { width, height } = this.getLayoutRect();
	        let end = { x: 0, y: 0 };
	        if (isX) {
	            end = { x: width, y: 0 };
	            gridLength = regionHeight;
	            axisLength = width;
	        }
	        else if (isY) {
	            end = { x: 0, y: height };
	            gridLength = regionWidth;
	            axisLength = height;
	        }
	        const depth = this.layout3dBox ? this.layout3dBox.length : 0;
	        if (!isZ) {
	            const items = this.getLabelItems(axisLength);
	            attrs.grid = {
	                length: gridLength
	            };
	            attrs.start = { x: 0, y: 0 };
	            attrs.text = this._spec.title.text || this._dataFieldText;
	            attrs.maxWidth = this._getTitleLimit(isX);
	            attrs.items = items;
	            attrs.grid = {
	                type: 'line',
	                start: { x: 0, y: 0 },
	                end,
	                items: items[0],
	                depth,
	                length: gridLength
	            };
	            return attrs;
	        }
	        return getUpdateAttributeOfZAxis(this, ignoreGrid);
	    }
	}

	const registerCartesianBandAxis3d = () => {
	    vchart.registerCartesianBandAxis();
	    const AxisCls = vchart.Factory.getComponentInKey(vchart.CartesianBandAxis.type);
	    AxisCls.builtInTheme = Object.assign(Object.assign({}, AxisCls.builtInTheme), { axisZ: Object.assign(Object.assign({}, vchart.CartesianBandAxis.builtInTheme.axisX), axisZ) });
	    mixin(AxisCls, Axis3dMixin);
	};

	const registerCartesianLinearAxis3d = () => {
	    vchart.registerCartesianLinearAxis();
	    const AxisCls = vchart.Factory.getComponentInKey(vchart.CartesianLinearAxis.type);
	    AxisCls.builtInTheme = Object.assign(Object.assign({}, AxisCls.builtInTheme), { axisZ: Object.assign(Object.assign({}, vchart.CartesianLinearAxis.builtInTheme.axisX), axisZ) });
	    mixin(AxisCls, Axis3dMixin);
	};

	const registerCartesianLogAxis3d = () => {
	    vchart.registerCartesianLogAxis();
	    const AxisCls = vchart.Factory.getComponentInKey(vchart.CartesianLogAxis.type);
	    AxisCls.builtInTheme = Object.assign(Object.assign({}, AxisCls.builtInTheme), { axisZ: Object.assign(Object.assign({}, vchart.CartesianLogAxis.builtInTheme.axisX), axisZ) });
	    mixin(AxisCls, Axis3dMixin);
	};

	const registerCartesianSymlogAxis3d = () => {
	    vchart.registerCartesianLogAxis();
	    const AxisCls = vchart.Factory.getComponentInKey(vchart.CartesianSymlogAxis.type);
	    AxisCls.builtInTheme = Object.assign(Object.assign({}, AxisCls.builtInTheme), { axisZ: Object.assign(Object.assign({}, AxisCls.builtInTheme.axisX), axisZ) });
	    mixin(AxisCls, Axis3dMixin);
	};

	const registerCartesianTimeAxis3d = () => {
	    vchart.registerCartesianTimeAxis();
	    const AxisCls = vchart.Factory.getComponentInKey(vchart.CartesianTimeAxis.type);
	    AxisCls.builtInTheme = Object.assign(Object.assign({}, AxisCls.builtInTheme), { axisZ: Object.assign(Object.assign({}, AxisCls.builtInTheme.axisX), axisZ) });
	    mixin(AxisCls, Axis3dMixin);
	};

	const registerAxis3dPlugin = () => {
	    register3DPlugin();
	    registerLayout3d();
	    registerCartesianBandAxis3d();
	    registerCartesianLinearAxis3d();
	    registerCartesianTimeAxis3d();
	    registerCartesianSymlogAxis3d();
	    registerCartesianLogAxis3d();
	};

	const rangeColumn3dSeriesMark = Object.assign(Object.assign({}, bar3dSeriesMark), { ["minLabel"]: { name: "minLabel", type: "text" }, ["maxLabel"]: { name: "maxLabel", type: "text" } });

	const DefaultBandWidth = 6;
	class RangeColumn3dSeries extends vchart.RangeColumnSeries {
	    constructor() {
	        super(...arguments);
	        this.type = SeriesType3dEnum.rangeColumn3d;
	        this._barMarkType = "rect3d";
	        this._barName = SeriesType3dEnum.bar3d;
	    }
	}
	RangeColumn3dSeries.type = SeriesType3dEnum.rangeColumn3d;
	RangeColumn3dSeries.mark = rangeColumn3dSeriesMark;
	const registerRangeColumn3dSeries = () => {
	    registerRect3dMark();
	    vchart.registerCartesianBandAxis();
	    vchart.registerCartesianLinearAxis();
	    vchart.Factory.registerSeries(RangeColumn3dSeries.type, RangeColumn3dSeries);
	};

	class RangeColumn3dSeriesSpecTransformer extends vchart.RangeColumnSeriesSpecTransformer {
	    _transformLabelSpec(spec) {
	        var _a;
	        const labelPosition = (_a = spec.label) === null || _a === void 0 ? void 0 : _a.position;
	        if (labelPosition !== "bothEnd") {
	            this._addMarkLabelSpec(spec, "bar3d");
	        }
	    }
	}

	class RangeColumn3dChartSpecTransformer extends vchart.CartesianChartSpecTransformer {
	    _getDefaultSeriesSpec(spec) {
	        var _a, _b;
	        const series = super._getDefaultSeriesSpec(spec, ['bar3d', 'barGapInGroup']);
	        if (spec.direction === "horizontal") {
	            series.xField = (_a = spec.xField) !== null && _a !== void 0 ? _a : [spec.minField, spec.maxField];
	        }
	        else {
	            series.yField = (_b = spec.yField) !== null && _b !== void 0 ? _b : [spec.minField, spec.maxField];
	        }
	        return series;
	    }
	}

	class RangeColumn3dChart extends vchart.BaseChart {
	    constructor() {
	        super(...arguments);
	        this.transformerConstructor = RangeColumn3dChartSpecTransformer;
	        this.type = "rangeColumn3d";
	        this.seriesType = SeriesType3dEnum.rangeColumn3d;
	    }
	    _setModelOption() {
	        this._modelOption.getDimensionInfo = vchart.getCartesianDimensionInfo;
	        this._modelOption.getDimensionInfoByValue = vchart.getDimensionInfoByValue;
	        this._modelOption.getRectByDimensionData = vchart.getCartesianCrosshairRect;
	    }
	}
	RangeColumn3dChart.type = "rangeColumn3d";
	RangeColumn3dChart.seriesType = SeriesType3dEnum.rangeColumn3d;
	RangeColumn3dChart.transformerConstructor = RangeColumn3dChartSpecTransformer;
	const registerRangeColumn3dChart = () => {
	    vchart.registerDimensionTooltipProcessor();
	    vchart.registerMarkTooltipProcessor();
	    vchart.registerDimensionEvents();
	    vchart.registerDimensionHover();
	    register3DPlugin();
	    registerLayout3d();
	    registerRangeColumn3dSeries();
	    vchart.Factory.registerChart(RangeColumn3dChart.type, RangeColumn3dChart);
	};

	const PICTOGRAM_CHART_TYPE = 'pictogram';
	const PICTOGRAM_SERIES_TYPE = 'pictogram';
	const ELEMENT_HIGHLIGHT_BY_GRPHIC_NAME = 'element-highlight-by-graphic-name';
	const ELEMENT_SELECT_BY_GRPHIC_NAME = 'element-select-by-graphic-name';
	var PictogramMarkNameEnum;
	(function (PictogramMarkNameEnum) {
	    PictogramMarkNameEnum["pictogram"] = "pictogram";
	})(PictogramMarkNameEnum || (PictogramMarkNameEnum = {}));
	const PictogramSeriesMark = Object.assign(Object.assign({}, vchart.baseSeriesMark), { ["pictogram"]: { name: "pictogram", type: "group" } });

	class PictogramChartSpecTransformer extends vchart.BaseChartSpecTransformer {
	    _isValidSeries(type) {
	        return type === PICTOGRAM_SERIES_TYPE;
	    }
	    _getDefaultSeriesSpec(spec) {
	        return super._getDefaultSeriesSpec(spec, [
	            'type',
	            'nameField',
	            'valueField',
	            'svg',
	            'pictogram',
	            'defaultFillColor'
	        ]);
	    }
	    transformSpec(spec) {
	        super.transformSpec(spec);
	        spec.region.forEach((r) => {
	            r.coordinate = 'geo';
	        });
	        super.transformSeriesSpec(spec);
	    }
	}

	const svgSourceMap = new Map();
	let svgDataSet;
	function initSVGDataSet() {
	    if (svgDataSet) {
	        return;
	    }
	    svgDataSet = new DataSet();
	    vchart.registerDataSetInstanceParser(svgDataSet, 'svg', svgParser);
	}
	function registerSVGSource(key, source) {
	    if (svgSourceMap.has(key)) {
	        vchart.warn(`svg source key of '${key}' already exists, will be overwritten.`);
	    }
	    initSVGDataSet();
	    const dataView = new DataView(svgDataSet);
	    dataView.parse(source, {
	        type: 'svg'
	    });
	    svgSourceMap.set(key, dataView);
	}
	function unregisterSVGSource(key) {
	    if (!svgSourceMap.has(key)) {
	        vchart.warn(`map type of '${key}' does not exists.`);
	        return;
	    }
	    svgSourceMap.delete(key);
	}
	function getSVGSource(type) {
	    return svgSourceMap.get(type);
	}
	function clearSVGSource() {
	    svgSourceMap.clear();
	    svgDataSet = null;
	}

	class PictogramSeriesSpecTransformer extends vchart.BaseSeriesSpecTransformer {
	    _getDefaultSpecFromChart(chartSpec) {
	        var _a, _b, _c;
	        const spec = (_a = super._getDefaultSpecFromChart(chartSpec)) !== null && _a !== void 0 ? _a : {};
	        const svg = chartSpec.svg;
	        const elements = (_c = (_b = svgSourceMap.get(svg)) === null || _b === void 0 ? void 0 : _b.latestData) === null || _c === void 0 ? void 0 : _c.elements;
	        if (elements && elements.length) {
	            const names = elements.map(e => e.name).filter(n => isValid$1(n));
	            names.forEach(name => {
	                if (chartSpec[name]) {
	                    spec[name] = chartSpec[name];
	                }
	            });
	        }
	        return spec;
	    }
	}

	class PictogramSeriesTooltipHelper extends vchart.BaseSeriesTooltipHelper {
	    constructor() {
	        super(...arguments);
	        this.dimensionTooltipTitleCallback = (datum) => {
	            var _a;
	            const series = this.series;
	            return (_a = this._getDimensionData(datum)) !== null && _a !== void 0 ? _a : series.getDatumName(datum);
	        };
	        this.markTooltipValueCallback = (datum, params) => {
	            const { measureFields } = this._seriesCacheInfo;
	            if (measureFields[0] && datum.data) {
	                return datum.data[measureFields[0]];
	            }
	        };
	        this.markTooltipKeyCallback = (datum) => {
	            var _a;
	            return (_a = datum.data) === null || _a === void 0 ? void 0 : _a[this.series.getDimensionField()[0]];
	        };
	    }
	}

	const type$1 = 'element-highlight-by-graphic-name';
	class ElementHighlightByGraphicName extends vchart.ElementHighlight {
	    constructor() {
	        super(...arguments);
	        this.type = type$1;
	        this.handleStart = (e) => {
	            if (e && e.item && this.isGraphicInMark(e.item)) {
	                const shouldStart = this.options.shouldStart ? this.options.shouldStart(e) : this._filterByName(e);
	                if (shouldStart) {
	                    const itemKey = this._parseTargetKey(e);
	                    this.start(itemKey);
	                }
	            }
	        };
	        this.handleReset = (e) => {
	            if (e && e.item && this.isGraphicInMark(e.item)) {
	                this.reset();
	            }
	        };
	    }
	    _filterByName(e) {
	        var _a;
	        const name = (_a = e === null || e === void 0 ? void 0 : e.node) === null || _a === void 0 ? void 0 : _a.name;
	        return !!name;
	    }
	    _parseTargetKey(e) {
	        return e.node.name;
	    }
	    start(itemKey) {
	        if (isNil$1(itemKey)) {
	            return;
	        }
	        const { interaction, highlightState, blurState } = this.options;
	        const statedGraphics = interaction.getStatedGraphics(this);
	        const newStatedGraphics = [];
	        this.getMarks().forEach(m => {
	            var _a;
	            (_a = m.getGraphics()) === null || _a === void 0 ? void 0 : _a.forEach(g => {
	                if (g.name === itemKey) {
	                    newStatedGraphics.push(g);
	                }
	            });
	        });
	        interaction.updateStates(this, newStatedGraphics, statedGraphics, highlightState, blurState);
	        interaction.setStatedGraphics(this, newStatedGraphics);
	    }
	    reset() {
	        const { highlightState, blurState, interaction } = this.options;
	        interaction.clearAllStatesOfTrigger(this, highlightState, blurState);
	        interaction.setStatedGraphics(this, []);
	    }
	}
	ElementHighlightByGraphicName.type = type$1;
	const registerElementHighlightByGraphicName = () => {
	    vchart.Factory.registerInteractionTrigger(ElementHighlightByGraphicName.type, ElementHighlightByGraphicName);
	};

	const type = 'element-select-by-graphic-name';
	class ElementSelectByGraphicName extends vchart.ElementSelect {
	    constructor() {
	        super(...arguments);
	        this.type = type;
	    }
	    start(markGraphic) {
	        const name = markGraphic === null || markGraphic === void 0 ? void 0 : markGraphic.name;
	        if (name) {
	            this.getMarks().forEach(mark => {
	                var _a;
	                (_a = mark.getGraphics()) === null || _a === void 0 ? void 0 : _a.forEach(g => {
	                    if (g.name === name) {
	                        super.start(g);
	                    }
	                });
	            });
	        }
	    }
	}
	ElementSelectByGraphicName.type = type;
	const registerElementSelectByGraphicName = () => {
	    vchart.Factory.registerInteractionTrigger(ElementSelectByGraphicName.type, ElementSelectByGraphicName);
	};

	function isValidStrokeOrFill(attr) {
	    var _a;
	    return isValid$1(attr) && attr !== 'none' && !((_a = attr.includes) === null || _a === void 0 ? void 0 : _a.call(attr, 'url'));
	}
	const getLineWidth = (attributes) => {
	    const strokeWidth = parseFloat(attributes.strokeWidth);
	    if (!isNaN(strokeWidth)) {
	        return strokeWidth;
	    }
	    const stroke = attributes.stroke;
	    return stroke && isValidStrokeOrFill(stroke) ? 1 : 0;
	};
	const getFill = (attributes, defaultFill) => {
	    var _a;
	    const fill = (_a = attributes.fill) !== null && _a !== void 0 ? _a : defaultFill;
	    return fill && isValidStrokeOrFill(fill) ? fill : undefined;
	};
	const getStroke = (attributes, defaultStroke) => {
	    var _a;
	    const stroke = (_a = attributes.stroke) !== null && _a !== void 0 ? _a : defaultStroke;
	    return stroke && isValidStrokeOrFill(stroke) ? stroke : false;
	};
	const commonAttributes = (attributes) => {
	    return Object.assign(Object.assign({}, attributes), { x: parseFloat(attributes.x) || undefined, y: parseFloat(attributes.y) || undefined, fillStrokeOrder: false, fill: getFill(attributes), lineWidth: getLineWidth(attributes), stroke: getStroke(attributes) });
	};
	const graphicAttributeTransform = {
	    group: (attributes) => {
	        const common = commonAttributes(attributes);
	        return Object.assign(Object.assign({}, common), { visibleAll: common.visible !== false });
	    },
	    rule: (attributes) => {
	        return Object.assign(Object.assign({}, commonAttributes(attributes)), { x: parseFloat(attributes.x1), y: parseFloat(attributes.y1), x1: parseFloat(attributes.x2), y1: parseFloat(attributes.y2) });
	    },
	    rect: (attributes) => {
	        return Object.assign(Object.assign({}, commonAttributes(attributes)), { fill: getFill(attributes, '#000'), width: parseFloat(attributes.width), height: parseFloat(attributes.height) });
	    },
	    polygon: (attributes) => {
	        return Object.assign(Object.assign({}, commonAttributes(attributes)), { fill: getFill(attributes, '#000'), points: attributes.points
	                .trim()
	                .split(/\s+/)
	                .map((pair) => {
	                const [x, y] = pair.split(',').map(Number);
	                return { x, y };
	            }) });
	    },
	    line: (attributes) => {
	        return Object.assign(Object.assign({}, commonAttributes(attributes)), { points: attributes.points
	                .trim()
	                .split(/\s+/)
	                .map((pair) => {
	                const [x, y] = pair.split(',').map(Number);
	                return { x, y };
	            }) });
	    },
	    path: (attributes) => {
	        return Object.assign(Object.assign({}, commonAttributes(attributes)), { path: attributes.d, fillStrokeOrder: false, fill: getFill(attributes, '#000') });
	    },
	    arc: (attributes) => {
	        var _a;
	        return Object.assign(Object.assign({}, commonAttributes(attributes)), { outerRadius: (_a = attributes.r) !== null && _a !== void 0 ? _a : attributes.ry, x: parseFloat(attributes.cx), y: parseFloat(attributes.cy), startAngle: 0, endAngle: Math.PI * 2, scaleX: parseFloat(attributes.rx) / parseFloat(attributes.ry) || 1, fill: getFill(attributes, '#000') });
	    },
	    text: (attributes, value) => {
	        var _a, _b;
	        return Object.assign(Object.assign({}, commonAttributes(attributes)), { text: value, textAlign: (_a = attributes.textAlign) !== null && _a !== void 0 ? _a : 'left', textBaseLine: (_b = attributes.textAnchor) !== null && _b !== void 0 ? _b : 'middle', anchor: [0, 0], fill: getFill(attributes, '#000') });
	    }
	};
	const pictogram = (data) => {
	    var _a, _b;
	    if (!data || !data[0]) {
	        return {};
	    }
	    const { elements } = data[0].latestData;
	    if (elements && elements.length) {
	        elements.forEach((el, index) => {
	            var _a;
	            el[vchart.DEFAULT_DATA_INDEX] = index;
	            el._uniqueId = `${el.id}-${index}`;
	            el.data = undefined;
	            const { graphicType: type, transform } = el;
	            const finalAttributes = {
	                visible: el.attributes.visibility !== 'hidden' && el.attributes.visibility !== 'collapse'
	            };
	            if (el.graphicType === 'text') {
	                merge(finalAttributes, el._inheritStyle, (_a = el.parent) === null || _a === void 0 ? void 0 : _a._textGroupStyle, el.attributes);
	            }
	            else if (el.graphicType !== 'group') {
	                merge(finalAttributes, el._inheritStyle, el.attributes);
	            }
	            if (graphicAttributeTransform[type]) {
	                el._finalAttributes = graphicAttributeTransform[type](finalAttributes, el.value);
	            }
	            else {
	                el._finalAttributes = finalAttributes;
	            }
	            if (transform) {
	                el._finalAttributes.postMatrix = Object.assign({}, transform);
	            }
	        });
	        const texts = elements.filter(el => el.tagName === 'text');
	        for (let i = 0; i < texts.length; i++) {
	            const textId = texts[i]._uniqueId;
	            const children = elements.filter(el => {
	                let result = false;
	                let parent = el.parent;
	                while (parent) {
	                    if (parent._uniqueId === textId) {
	                        result = true;
	                        break;
	                    }
	                    parent = parent.parent;
	                }
	                return result;
	            });
	            if (children && children.length) {
	                const startX = (_b = (_a = texts[i]._textGroupStyle) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
	                let curX = startX;
	                for (let j = 0; j < children.length; j++) {
	                    const currentChild = children[j];
	                    if (currentChild.graphicType === 'group') {
	                        curX = startX;
	                    }
	                    else if (currentChild.value) {
	                        if (currentChild.parent._textGroupStyle.x === undefined) {
	                            const lastText = children
	                                .slice(0, j)
	                                .reverse()
	                                .find(c => c.graphicType === 'text' && c.value);
	                            if (lastText) {
	                                const width = vchart.measureText(lastText.value, lastText._finalAttributes).width;
	                                curX += width;
	                            }
	                            currentChild._finalAttributes.x = curX;
	                        }
	                    }
	                }
	            }
	        }
	    }
	    return elements;
	};

	class PictogramSeries extends vchart.GeoSeries {
	    constructor() {
	        super(...arguments);
	        this.type = PICTOGRAM_SERIES_TYPE;
	        this._idToMark = new Map();
	    }
	    setAttrFromSpec() {
	        var _a, _b, _c;
	        super.setAttrFromSpec();
	        this.svg = this._spec.svg;
	        this._nameField = this._spec.nameField;
	        this._valueField = this._spec.valueField;
	        if (!this.svg) {
	            (_a = this._option) === null || _a === void 0 ? void 0 : _a.onError(`svg source is not specified !`);
	        }
	        this._parsedSvgResult = (_b = getSVGSource(this.svg)) === null || _b === void 0 ? void 0 : _b.latestData;
	        if (!this._parsedSvgResult) {
	            (_c = this._option) === null || _c === void 0 ? void 0 : _c.onError(`'${this.svg}' is not registered !`);
	        }
	    }
	    getDatumCenter(datum) {
	        return [Number.NaN, Number.NaN];
	    }
	    getDatumName(datum) {
	        return datum.name || datum._nameFromParent;
	    }
	    getMarksWithoutRoot() {
	        return this.getMarks().filter(m => m.name && !m.name.includes('seriesGroup') && !m.name.includes('root') && m !== this._pictogramMark);
	    }
	    _buildMarkAttributeContext() {
	        super._buildMarkAttributeContext();
	        this._markAttributeContext.getTransformMatrix = this.getRootMatrix.bind(this);
	        this._markAttributeContext.coordToPosition = this.coordToPosition.bind(this);
	        this._markAttributeContext.dataToPosition = this.dataToPosition.bind(this);
	    }
	    _defaultHoverConfig(finalHoverSpec) {
	        return {
	            type: ELEMENT_HIGHLIGHT_BY_GRPHIC_NAME,
	            trigger: finalHoverSpec.trigger,
	            triggerOff: 'pointerout',
	            blurState: vchart.STATE_VALUE_ENUM.STATE_HOVER_REVERSE,
	            highlightState: vchart.STATE_VALUE_ENUM.STATE_HOVER
	        };
	    }
	    _defaultSelectConfig(finalSelectSpec) {
	        const isMultiple = finalSelectSpec.mode === 'multiple';
	        const triggerOff = isValid$1(finalSelectSpec.triggerOff)
	            ? finalSelectSpec.triggerOff
	            : isMultiple
	                ? ['empty', 'self']
	                : ['empty', finalSelectSpec.trigger];
	        return {
	            type: ELEMENT_SELECT_BY_GRPHIC_NAME,
	            trigger: finalSelectSpec.trigger,
	            triggerOff: triggerOff,
	            reverseState: vchart.STATE_VALUE_ENUM.STATE_SELECTED_REVERSE,
	            state: vchart.STATE_VALUE_ENUM.STATE_SELECTED,
	            isMultiple
	        };
	    }
	    initMark() {
	        var _a;
	        this._pictogramMark = this._createMark(PictogramSeries.mark.pictogram, {
	            groupKey: this.getDimensionField()[0],
	            isSeriesMark: true,
	            skipBeforeLayouted: true
	        }, {
	            morph: vchart.shouldMarkDoMorph(this._spec, PictogramSeries.mark.pictogram.name)
	        });
	        if (!this._pictogramMark) {
	            return;
	        }
	        this._pictogramMark.setData(this._mapViewData);
	        this._pictogramMark.setUserId(PictogramSeries.mark.pictogram.name);
	        for (const element of this._mapViewData.getDataView().latestData) {
	            const { graphicType: type, name, parent, id, _nameFromParent, _uniqueId } = element;
	            const mark = this._createMark({ type, name: name !== null && name !== void 0 ? name : _nameFromParent }, {
	                groupKey: _uniqueId,
	                isSeriesMark: false,
	                skipBeforeLayouted: true,
	                parent: (_a = this._idToMark.get(parent === null || parent === void 0 ? void 0 : parent._uniqueId)) !== null && _a !== void 0 ? _a : this._pictogramMark
	            }, {
	                morph: vchart.shouldMarkDoMorph(this._spec, PictogramSeries.mark.pictogram.name)
	            });
	            if (mark) {
	                mark.setData(this._mapViewData);
	                mark.setUserId(_uniqueId);
	                this._idToMark.set(_uniqueId, mark);
	                if (mark.type !== 'group') {
	                    mark.setMarkConfig({ graphicName: mark.name });
	                }
	                mark.setTransform([
	                    {
	                        type: 'filter',
	                        callback: (datum) => {
	                            return datum._uniqueId === _uniqueId;
	                        }
	                    }
	                ]);
	            }
	        }
	        this._initLabelMark();
	    }
	    _initLabelMark() {
	        if (this._spec.label.visible !== true) {
	            return;
	        }
	        const labelMark = this._createMark(PictogramSeries.mark.label, {
	            isSeriesMark: false,
	            parent: this._pictogramMark,
	            groupKey: '_uniqueId',
	            skipBeforeLayouted: true
	        });
	        if (labelMark) {
	            this._labelMark = labelMark;
	            this._labelMark.setData(this._mapViewData);
	        }
	    }
	    initLabelMarkStyle() {
	        if (!this._labelMark) {
	            return;
	        }
	        this.setMarkStyle(this._labelMark, {
	            visible: (d) => !!this._validElement(d),
	            x: (d) => { var _a; return (_a = this.dataToPosition(d, true)) === null || _a === void 0 ? void 0 : _a.x; },
	            y: (d) => { var _a; return (_a = this.dataToPosition(d, true)) === null || _a === void 0 ? void 0 : _a.y; },
	            text: (d) => d[this.nameField],
	            textAlign: 'center',
	            textBaseline: 'middle'
	        }, vchart.STATE_VALUE_ENUM.STATE_NORMAL, vchart.AttributeLevel.Series);
	    }
	    initMarkStyle() {
	        const { root, viewBoxRect } = this._parsedSvgResult;
	        const elements = this._mapViewData.getDataView().latestData;
	        if (root) {
	            this.setMarkStyle(this._pictogramMark, graphicAttributeTransform.group(root.attributes), 'normal', vchart.AttributeLevel.Built_In);
	            if (root.transform) {
	                this.setMarkStyle(this._pictogramMark, {
	                    postMatrix: () => root.transform
	                }, 'normal', vchart.AttributeLevel.Built_In);
	            }
	            if (viewBoxRect) {
	                this._pictogramMark.setMarkConfig({
	                    clip: true,
	                    clipPath: [createRect(Object.assign(Object.assign({}, viewBoxRect), { fill: true }))]
	                });
	            }
	        }
	        for (const element of elements) {
	            const { _uniqueId, _finalAttributes: attributes } = element;
	            const mark = this._idToMark.get(_uniqueId);
	            const valid = this._validElement(element);
	            if (mark) {
	                this.setMarkStyle(mark, { keepStrokeScale: true }, 'normal', vchart.AttributeLevel.Built_In);
	                if (valid) {
	                    this.initMarkStyleWithSpec(mark, merge({}, this._spec.pictogram, this._spec[mark.name]));
	                    this.setMarkStyle(mark, attributes, 'normal', vchart.AttributeLevel.Series);
	                    mark.setPostProcess('fill', (result, datum) => {
	                        return isValid$1(result) ? result : this._spec.defaultFillColor;
	                    });
	                }
	                else {
	                    mark.setMarkConfig({ interactive: false });
	                    this.setMarkStyle(mark, attributes, 'normal', vchart.AttributeLevel.Built_In);
	                }
	            }
	        }
	        this.initLabelMarkStyle();
	    }
	    _validElement(element) {
	        return element.name || element._nameFromParent;
	    }
	    initTooltip() {
	        this._tooltipHelper = new PictogramSeriesTooltipHelper(this);
	        this.getMarksWithoutRoot().forEach(mark => {
	            if (mark && mark.name) {
	                this._tooltipHelper.activeTriggerSet.mark.add(mark);
	            }
	        });
	    }
	    dataToPosition(datum, global = false) {
	        if (!datum) {
	            return null;
	        }
	        const name = datum[this.nameField];
	        if (!name) {
	            return null;
	        }
	        const mark = this.getMarksWithoutRoot().filter(mark => mark.name === name);
	        if (!mark || mark.length === 0) {
	            return null;
	        }
	        let bounds = new Bounds();
	        if (global) {
	            mark.forEach(m => {
	                bounds = bounds.union(m.getGraphics()[0].globalAABBBounds);
	            });
	        }
	        else {
	            mark.forEach(m => {
	                bounds = bounds.union(m.getProduct().AABBBounds);
	            });
	        }
	        const point = { x: (bounds.x1 + bounds.x2) / 2, y: (bounds.y1 + bounds.y2) / 2 };
	        if (global) {
	            const { x, y } = this.getLayoutStartPoint();
	            point.x -= x;
	            point.y -= y;
	        }
	        return point;
	    }
	    coordToPosition(point) {
	        if (!point) {
	            return null;
	        }
	        const { x, y } = point;
	        const matrix = this.getRootMatrix();
	        if (!matrix) {
	            return null;
	        }
	        const position = {};
	        matrix.getInverse().transformPoint({ x, y }, position);
	        return position;
	    }
	    getRootMatrix() {
	        var _a;
	        return (_a = this.getPictogramRootGraphic()) === null || _a === void 0 ? void 0 : _a.transMatrix;
	    }
	    getPictogramRootGraphic() {
	        return this._pictogramMark.getProduct();
	    }
	    initData() {
	        var _a, _b;
	        super.initData();
	        const parsedSvg = svgSourceMap.get(this.svg);
	        if (!parsedSvg) {
	            (_a = this._option) === null || _a === void 0 ? void 0 : _a.onError('no valid svg found!');
	        }
	        const svgData = new DataView(this._dataSet, { name: `pictogram_${this.id}_data` });
	        vchart.registerDataSetInstanceTransform(this._dataSet, 'pictogram', pictogram);
	        vchart.registerDataSetInstanceTransform(this._dataSet, 'lookup', vchart.lookup);
	        svgData
	            .parse([parsedSvg], {
	            type: 'dataview'
	        })
	            .transform({ type: 'pictogram' })
	            .transform({
	            type: 'lookup',
	            options: {
	                from: () => this.getViewData().latestData,
	                key: 'name',
	                fields: this._nameField,
	                set: (a, b) => {
	                    if (b) {
	                        a.data = b;
	                    }
	                }
	            }
	        })
	            .transform({
	            type: 'lookup',
	            options: {
	                from: () => this.getViewData().latestData,
	                key: '_nameFromParent',
	                fields: this._nameField,
	                set: (a, b) => {
	                    if (b) {
	                        a.data = b;
	                    }
	                }
	            }
	        });
	        (_b = this._data) === null || _b === void 0 ? void 0 : _b.getDataView().target.addListener('change', svgData.reRunAllTransform);
	        this._mapViewData = new vchart.CompilableData(this._option, svgData);
	    }
	    mapViewDataUpdate() {
	        this._mapViewData.updateData();
	    }
	    onLayoutEnd() {
	        var _a;
	        super.onLayoutEnd();
	        (_a = this._mapViewData) === null || _a === void 0 ? void 0 : _a.getDataView().reRunAllTransform();
	    }
	    updateSVGSize() {
	        const { width: regionWidth, height: regionHeight } = this.getLayoutRect();
	        const regionCenterX = regionWidth / 2;
	        const regionCenterY = regionHeight / 2;
	        const root = this.getPictogramRootGraphic();
	        if (root) {
	            const bounds = root.AABBBounds;
	            const { x1, x2, y1, y2 } = root.AABBBounds;
	            const width = bounds.width();
	            const height = bounds.height();
	            const rootCenterX = (x1 + x2) / 2;
	            const rootCenterY = (y1 + y2) / 2;
	            const scaleX = regionWidth / width;
	            const scaleY = regionHeight / height;
	            const scale = Math.min(scaleX, scaleY);
	            root.scale(scale, scale, { x: rootCenterX, y: rootCenterY });
	            root.translate(regionCenterX - rootCenterX, regionCenterY - rootCenterY);
	        }
	    }
	    initEvent() {
	        var _a;
	        super.initEvent();
	        (_a = this._mapViewData.getDataView()) === null || _a === void 0 ? void 0 : _a.target.addListener('change', this.mapViewDataUpdate.bind(this));
	        this.event.on(vchart.ChartEvent.afterMarkLayoutEnd, this.updateSVGSize.bind(this));
	    }
	    handleZoom(e) {
	        const { scale, scaleCenter } = e;
	        if (scale === 1) {
	            return;
	        }
	        const root = this.getPictogramRootGraphic();
	        if (root) {
	            if (!root.attribute.postMatrix) {
	                root.setAttributes({
	                    postMatrix: new Matrix()
	                });
	            }
	            root.scale(scale, scale, scaleCenter);
	        }
	    }
	    handlePan(e) {
	        const { delta } = e;
	        if (delta[0] === 0 && delta[1] === 0) {
	            return;
	        }
	        const root = this.getPictogramRootGraphic();
	        if (root) {
	            if (!root.attribute.postMatrix) {
	                root.setAttributes({
	                    postMatrix: new Matrix()
	                });
	            }
	            root.translate(delta[0], delta[1]);
	        }
	    }
	    getMarkData(datum) {
	        var _a;
	        return (_a = datum.data) !== null && _a !== void 0 ? _a : {};
	    }
	    getMeasureField() {
	        return [this.valueField];
	    }
	    getDimensionField() {
	        return [this.nameField];
	    }
	    _getSeriesInfo(field, keys) {
	        const defaultShapeType = this.getDefaultShapeType();
	        return keys.map(key => {
	            return {
	                key,
	                originalKey: key,
	                style: this.getSeriesStyle({
	                    data: {
	                        [field]: key
	                    }
	                }),
	                shapeType: defaultShapeType
	            };
	        });
	    }
	    release() {
	        this._parsedSvgResult = null;
	        this._idToMark.clear();
	        this._idToMark = null;
	    }
	}
	PictogramSeries.type = PICTOGRAM_SERIES_TYPE;
	PictogramSeries.mark = PictogramSeriesMark;
	PictogramSeries.transformerConstructor = PictogramSeriesSpecTransformer;
	const registerPictogramSeries = () => {
	    vchart.Factory.registerSeries(PictogramSeries.type, PictogramSeries);
	    vchart.Factory.registerImplement('registerSVG', registerSVGSource);
	    vchart.Factory.registerImplement('unregisterSVG', unregisterSVGSource);
	    registerElementHighlightByGraphicName();
	    registerElementSelectByGraphicName();
	};

	class PictogramChart extends vchart.BaseChart {
	    constructor() {
	        super(...arguments);
	        this.transformerConstructor = PictogramChartSpecTransformer;
	        this.type = PICTOGRAM_CHART_TYPE;
	        this.seriesType = PICTOGRAM_SERIES_TYPE;
	    }
	}
	PictogramChart.type = PICTOGRAM_SERIES_TYPE;
	PictogramChart.seriesType = PICTOGRAM_CHART_TYPE;
	PictogramChart.transformerConstructor = PictogramChartSpecTransformer;
	const registerPictogramChart = () => {
	    vchart.registerMarkTooltipProcessor();
	    registerPictogramSeries();
	    vchart.Factory.registerChart(PictogramChart.type, PictogramChart);
	};

	class ImageCloudChartSpecTransformer extends vchart.BaseChartSpecTransformer {
	    transformSpec(spec) {
	        super.transformSpec(spec);
	        this.transformSeriesSpec(spec);
	    }
	    _getDefaultSeriesSpec(spec) {
	        const series = super._getDefaultSeriesSpec(spec, [
	            'urlField',
	            'nameField',
	            'valueField',
	            'imageSize',
	            'imageSizeRange',
	            'ratio',
	            'maskShape',
	            'imageMask',
	            'layoutConfig',
	            'image'
	        ]);
	        return series;
	    }
	}

	const IMAGE_CLOUD_CHART_TYPE = 'imageCloud';
	const IMAGE_CLOUD_SERIES_TYPE = 'imageCloud';
	var ImageCloudMarkNameEnum;
	(function (ImageCloudMarkNameEnum) {
	    ImageCloudMarkNameEnum["image"] = "image";
	    ImageCloudMarkNameEnum["imageMask"] = "imageMask";
	})(ImageCloudMarkNameEnum || (ImageCloudMarkNameEnum = {}));
	const imageCloudSeriesMark = Object.assign(Object.assign({}, vchart.baseSeriesMark), { ["image"]: { name: "image", type: "image" }, ["imageMask"]: { name: "imageMask", type: "rect" } });

	const shapes = {
	  triangleForward: triangleForward,
	  triangleUpright: triangle,
	  triangle: triangle,
	  diamond: diamond,
	  square: square$1,
	  star: star,
	  cardioid: cardioid,
	  circle: circle,
	  pentagon: pentagon
	};
	function diamond() {
	  return function (theta) {
	    const thetaPrime = theta % (2 * Math.PI / 4);
	    return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));
	  };
	}
	function star() {
	  return function (theta) {
	    const thetaPrime = (theta + .955) % (2 * Math.PI / 10);
	    return (theta + .955) % (2 * Math.PI / 5) - 2 * Math.PI / 10 >= 0 ? 1 / (Math.cos(2 * Math.PI / 10 - thetaPrime) + 3.07768 * Math.sin(2 * Math.PI / 10 - thetaPrime)) : 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));
	  };
	}
	function square$1() {
	  return function (theta) {
	    return Math.min(1 / Math.abs(Math.cos(theta)), 1 / Math.abs(Math.sin(theta)));
	  };
	}
	function triangle() {
	  return function (theta) {
	    const thetaPrime = (theta + 3 * Math.PI / 2) % (2 * Math.PI / 3);
	    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));
	  };
	}
	function triangleForward() {
	  return function (theta) {
	    const thetaPrime = theta % (2 * Math.PI / 3);
	    return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));
	  };
	}
	function cardioid() {
	  return function (theta) {
	    return 1 + Math.sin(theta);
	  };
	}
	function circle() {
	  return function () {
	    return 1;
	  };
	}
	function pentagon() {
	  return function (theta) {
	    const thetaPrime = (theta + .955) % (2 * Math.PI / 5);
	    return 1 / (Math.cos(thetaPrime) + .726543 * Math.sin(thetaPrime));
	  };
	}
	function getMaxRadiusAndCenter(shape, size) {
	  const w = size[0],
	    h = size[1];
	  let maxRadius = 1;
	  const center = [size[0] >> 1, size[1] >> 1];
	  switch (shape) {
	    case "cardioid":
	      center[1] = ~~(h / 2.7 * .4), maxRadius = Math.floor(Math.min(w / 2.3, h / 2.6));
	      break;
	    case "triangleForward":
	      maxRadius = h / Math.sqrt(.75) > w ? Math.floor(w / 2) : Math.floor(h / (2 * Math.sqrt(.75)));
	      break;
	    case "triangle":
	    case "triangleUpright":
	      center[1] = ~~(h / 1.5), maxRadius = Math.floor(Math.min(h / 1.5, w / 2));
	      break;
	    case "circle":
	    case "diamond":
	    case "square":
	    case "star":
	    case "pentagon":
	      maxRadius = Math.floor(Math.min(w / 2, h / 2));
	      break;
	    default:
	      maxRadius = Math.floor(Math.max(w / 2, h / 2));
	  }
	  return {
	    maxRadius: maxRadius,
	    center: center
	  };
	}
	const getShapeFunction = type => shapes[type] ? shapes[type]() : shapes.circle();

	const spirals = {
	  archimedean: archimedeanSpiral,
	  rectangular: rectangularSpiral
	};
	function archimedeanSpiral(size) {
	  const e = size[0] / size[1];
	  return t => [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
	}
	function rectangularSpiral(size) {
	  const dx = 4 * size[0] / size[1];
	  let x = 0,
	    y = 0;
	  return t => {
	    const sign = t < 0 ? -1 : 1;
	    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
	      case 0:
	        x += dx;
	        break;
	      case 1:
	        y += 4;
	        break;
	      case 2:
	        x -= dx;
	        break;
	      default:
	        y -= 4;
	    }
	    return [x, y];
	  };
	}

	const generateIsEmptyPixel = (backgroundColor, options, createCanvas) => {
	  const {
	    threshold: threshold,
	    invert = !1
	  } = null != options ? options : {};
	  if (!backgroundColor || "#fff" === backgroundColor) return (imageData, y, x) => {
	    const width = imageData.width;
	    if (0 === imageData.data[y * width * 4 + 4 * x + 3]) return !invert;
	    const r = imageData.data[y * width * 4 + 4 * x + 0],
	      g = imageData.data[y * width * 4 + 4 * x + 1],
	      b = imageData.data[y * width * 4 + 4 * x + 2];
	    if (255 === r && 255 === g && 255 === b) return !invert;
	    if (isValidNumber$1(threshold)) {
	      const grayValue = .3 * r + .59 * g + .11 * b;
	      return invert ? grayValue <= threshold : grayValue >= threshold;
	    }
	    return !1;
	  };
	  const bctx = createCanvas({
	    width: 1,
	    height: 1
	  }).getContext("2d", {
	    willReadFrequently: !0
	  });
	  bctx.fillStyle = backgroundColor, bctx.fillRect(0, 0, 1, 1);
	  const bgPixel = bctx.getImageData(0, 0, 1, 1).data;
	  return (imageData, y, x) => {
	    const width = imageData.width;
	    return [0, 1, 2, 3].every(i => invert ? imageData.data[4 * (y * width + x) + i] !== bgPixel[i] : imageData.data[4 * (y * width + x) + i] === bgPixel[i]);
	  };
	};
	const generateMaskCanvas = (shape, width, height, cacheCanvas, invert = !1, createCanvas) => {
	  let {
	      backgroundColor = "#fff"
	    } = shape,
	    {
	      fill: foregroundColor = "#000"
	    } = shape;
	  invert && ([backgroundColor, foregroundColor] = [foregroundColor, backgroundColor]);
	  const maskCanvas = cacheCanvas || createCanvas({
	      width: width,
	      height: height,
	      dpr: 1
	    }),
	    tempContext = maskCanvas.getContext("2d", {
	      willReadFrequently: !0
	    });
	  if (cacheCanvas) {
	    const prevWidth = cacheCanvas.width,
	      prevHeight = cacheCanvas.height;
	    tempContext.clearRect(0, 0, prevWidth, prevHeight), cacheCanvas.style.width = `${width}px`, cacheCanvas.style.height = `${height}px`, cacheCanvas.width = width, cacheCanvas.height = height;
	  }
	  return tempContext.fillStyle = backgroundColor, tempContext.fillRect(0, 0, maskCanvas.width, maskCanvas.height), "text" === shape.type ? drawTextMask(shape, foregroundColor, maskCanvas.width, maskCanvas.height, tempContext) : "geometric" === shape.type && drawGeometricMask(shape, foregroundColor, maskCanvas.width, maskCanvas.height, tempContext), maskCanvas;
	};
	const drawTextMask = (shape, fillColor, width, height, ctx) => {
	  const {
	    fontFamily = "sans-serif",
	    fontWeight = "normal",
	    fontStyle = "normal",
	    fontVariant = "normal",
	    text: text,
	    hollow: hollow
	  } = shape;
	  let baseFontSize = 12;
	  ctx.font = `${fontStyle} ${fontVariant} ${fontWeight} ${baseFontSize}px ${fontFamily}`, ctx.textAlign = "center", ctx.textBaseline = "middle", ctx.fillStyle = fillColor;
	  const textMetrics = ctx.measureText(text),
	    scale = "normal" !== fontStyle ? 1.1 : 1,
	    actualWidth = isValid$1(textMetrics.actualBoundingBoxRight) && isValid$1(textMetrics.actualBoundingBoxLeft) ? Math.ceil(scale * (Math.abs(textMetrics.actualBoundingBoxRight) + Math.abs(textMetrics.actualBoundingBoxLeft))) : 0,
	    textWidth = Math.max(Math.ceil(textMetrics.width), actualWidth, baseFontSize);
	  if (hollow && (ctx.globalCompositeOperation = "xor"), textWidth > width) {
	    const scale = Math.min(width / textWidth, height / baseFontSize);
	    ctx.fillText(text, width / 2, height / 2), ctx.scale(scale, scale);
	  } else baseFontSize = Math.floor(baseFontSize * width / textWidth), baseFontSize = Math.min(baseFontSize, height), ctx.font = `${fontStyle} ${fontVariant} ${fontWeight} ${baseFontSize}px ${fontFamily}`, ctx.fillText(text, Math.floor(width / 2), Math.floor(height / 2));
	};
	const generatePoints = (center, radius, startAngle = 0, count) => {
	  const angle = 2 * Math.PI / count;
	  return new Array(count).fill(0).map((entry, index) => polarToCartesian(center, radius, startAngle + index * angle));
	};
	const generateCardioidPoints = (center, radius, startAngle = 0, count) => {
	  const angle = 2 * Math.PI / count,
	    func = getShapeFunction("cardioid");
	  return new Array(count).fill(0).map((entry, index) => {
	    const theta = startAngle + index * angle,
	      r = radius * func(theta);
	    return polarToCartesian(center, r, theta);
	  });
	};
	const drawRegularPolygon = (ctx, points) => {
	  ctx.beginPath(), points.forEach((p, index) => {
	    0 === index ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
	  }), ctx.closePath(), ctx.fill();
	};
	const drawCardioid = (ctx, points) => {
	  let prev;
	  ctx.beginPath(), points.forEach((p, index) => {
	    0 === index ? ctx.moveTo(p.x, p.y) : ctx.bezierCurveTo(p.x, p.y, prev.x, prev.y, p.x, p.y), prev = p;
	  }), ctx.closePath(), ctx.fill();
	};
	const drawGeometricMask = (shape, fillColor, width, height, ctx) => {
	  const {
	      hollow: hollow
	    } = shape,
	    {
	      center: center,
	      maxRadius: maxRadius
	    } = getMaxRadiusAndCenter(shape.shape, [width, height]);
	  ctx.fillStyle = fillColor, hollow && (ctx.globalCompositeOperation = "xor");
	  const cx = center[0],
	    cy = center[1];
	  if ("cardioid" === shape.shape) drawCardioid(ctx, generateCardioidPoints({
	    x: cx,
	    y: cy
	  }, maxRadius, 0, 100));else if ("circle" === shape.shape) ctx.beginPath(), ctx.arc(cx, cy, maxRadius, 0, 2 * Math.PI, !0), ctx.fill();else if ("diamond" === shape.shape) drawRegularPolygon(ctx, generatePoints({
	    x: cx,
	    y: cy
	  }, maxRadius, -Math.PI / 2, 4));else if ("square" === shape.shape) drawRegularPolygon(ctx, generatePoints({
	    x: cx,
	    y: cy
	  }, maxRadius, -Math.PI / 4, 4));else if ("pentagon" === shape.shape) drawRegularPolygon(ctx, generatePoints({
	    x: cx,
	    y: cy
	  }, maxRadius, Math.PI / 2, 5));else if ("triangle" === shape.shape || "triangleUpright" === shape.shape) drawRegularPolygon(ctx, generatePoints({
	    x: cx,
	    y: cy
	  }, maxRadius, -Math.PI / 2, 3));else if ("triangleForward" === shape.shape) drawRegularPolygon(ctx, generatePoints({
	    x: cx,
	    y: cy
	  }, maxRadius, 0, 3));else if ("star" === shape.shape) {
	    const outterPoints = generatePoints({
	        x: cx,
	        y: cy
	      }, maxRadius, -Math.PI / 2, 5),
	      innerPoints = generatePoints({
	        x: cx,
	        y: cy
	      }, maxRadius / (2 * Math.cos(Math.PI / 5)), -Math.PI / 2 + Math.PI / 5, 5),
	      points = [];
	    for (let i = 0; i < 5; i++) points.push(outterPoints[i]), points.push(innerPoints[i]);
	    drawRegularPolygon(ctx, points);
	  } else ctx.fillRect(0, 0, width, height);
	};
	function segmentation(segmentationInput) {
	  const {
	      size: size,
	      maskCanvas: maskCanvas
	    } = segmentationInput,
	    imageData = maskCanvas.getContext("2d", {
	      willReadFrequently: !0
	    }).getImageData(0, 0, maskCanvas.width, maskCanvas.height),
	    labels = new Array(size[0] * size[1]).fill(0);
	  let curLabel = 1;
	  const offset = [[0, 1], [1, 0], [-1, 0], [0, -1]];
	  let queue = [];
	  for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) if (0 === labels[i * size[0] + j] && !segmentationInput.isEmptyPixel(imageData, i, j)) {
	    labels[i * size[0] + j] = curLabel, queue.push([i, j]);
	    for (let k = 0; k < queue.length; k++) for (let m = 0; m < 4; m++) {
	      let row = queue[k][0] + offset[m][0],
	        col = queue[k][1] + offset[m][1];
	      row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row, col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col, 0 !== labels[row * size[0] + col] || segmentationInput.isEmptyPixel(imageData, row, col) || (labels[row * size[0] + col] = curLabel, queue.push([row, col]));
	    }
	    curLabel++, queue = [];
	  }
	  const boundaries = {},
	    areas = {},
	    centers = {},
	    maxPoints = {},
	    maxR = {},
	    ratios = {},
	    shapeBounds = {
	      x1: 1 / 0,
	      x2: -1 / 0,
	      y1: 1 / 0,
	      y2: -1 / 0,
	      width: 0,
	      height: 0
	    },
	    boundaryPixels = [];
	  for (let i = 0; i < size[1]; i++) for (let j = 0; j < size[0]; j++) {
	    const label = labels[i * size[0] + j];
	    0 !== label && (isBoundaryPixel(i, j) && (boundaryPixels.push([i, j]), boundaries[label] = boundaries[label] || [], boundaries[label].push([j, i]), maxPoints[label] || (maxPoints[label] = [1 / 0, -1 / 0, 1 / 0, -1 / 0]), i < maxPoints[label][0] && (maxPoints[label][0] = i), i > maxPoints[label][1] && (maxPoints[label][1] = i), j < maxPoints[label][2] && (maxPoints[label][2] = j), j > maxPoints[label][3] && (maxPoints[label][3] = j), j < shapeBounds.x1 && (shapeBounds.x1 = j), j > shapeBounds.x2 && (shapeBounds.x2 = j), i < shapeBounds.y1 && (shapeBounds.y1 = i), i > shapeBounds.y2 && (shapeBounds.y2 = i)), areas[label] = (areas[label] || 0) + 1);
	  }
	  const allBoundaries = [];
	  for (const label in boundaries) {
	    const boundary = boundaries[label],
	      x = ~~(boundary.reduce((acc, cur) => acc + cur[0], 0) / boundary.length),
	      y = ~~(boundary.reduce((acc, cur) => acc + cur[1], 0) / boundary.length);
	    centers[label] = [x, y], allBoundaries.push(...boundary);
	    const [yMin, yMax, xMin, xMax] = maxPoints[label];
	    maxR[label] = ~~Math.max(Math.sqrt((x - xMin) ** 2 + (y - yMin) ** 2), Math.sqrt((x - xMax) ** 2 + (y - yMax) ** 2), Math.sqrt((x - xMin) ** 2 + (y - yMax) ** 2), Math.sqrt((x - xMax) ** 2 + (y - yMin) ** 2)), ratios[label] = (xMax - xMin) / (yMax - yMin);
	  }
	  const regions = Object.keys(centers).map(key => ({
	    label: key - 1,
	    boundary: boundaries[key],
	    area: areas[key],
	    center: centers[key],
	    maxPoint: maxPoints[key],
	    maxR: maxR[key],
	    ratio: ratios[key]
	  }));
	  shapeBounds.width = shapeBounds.x2 - shapeBounds.x1 + 1, shapeBounds.height = shapeBounds.y2 - shapeBounds.y1 + 1;
	  const x = ~~(allBoundaries.reduce((acc, cur) => acc + cur[0], 0) / allBoundaries.length),
	    y = ~~(allBoundaries.reduce((acc, cur) => acc + cur[1], 0) / allBoundaries.length),
	    shapeMaxR = ~~Math.max(Math.sqrt((x - shapeBounds.x1) ** 2 + (y - shapeBounds.y1) ** 2), Math.sqrt((x - shapeBounds.x2) ** 2 + (y - shapeBounds.y2) ** 2), Math.sqrt((x - shapeBounds.x1) ** 2 + (y - shapeBounds.y2) ** 2), Math.sqrt((x - shapeBounds.x2) ** 2 + (y - shapeBounds.y1) ** 2)),
	    shapeRatio = shapeBounds.width / shapeBounds.height,
	    shapeArea = Object.keys(areas).reduce((acc, key) => acc + areas[key], 0),
	    segmentation = {
	      regions: regions,
	      labels: labels,
	      labelNumber: curLabel - 1
	    };
	  if (segmentationInput.blur) {
	    const blur = segmentationInput.blur,
	      blurredLabels = gaussianBlur(labels, size[0], size[1], blur);
	    drawContour(labels, boundaryPixels, size[0], size[1], Math.ceil(blur / 2)).forEach((value, index) => {
	      1 === value && (labels[index] = blurredLabels[index]);
	    });
	  }
	  return Object.assign(segmentationInput, {
	    segmentation: segmentation,
	    shapeBounds: shapeBounds,
	    shapeMaxR: shapeMaxR,
	    shapeRatio: shapeRatio,
	    shapeCenter: [x, y],
	    shapeArea: shapeArea
	  });
	  function isBoundaryPixel(i, j) {
	    const offset = [[0, 1], [1, 0], [-1, 0], [0, -1]];
	    if (0 === i || 0 === j || i === size[1] - 1 || j === size[0] - 1) return !0;
	    for (let k = 0; k < 4; k++) {
	      let row = i + offset[k][0],
	        col = j + offset[k][1];
	      if (row = row < 0 ? 0 : row >= size[1] ? size[1] - 1 : row, col = col < 0 ? 0 : col >= size[0] ? size[0] - 1 : col, 0 === labels[row * size[0] + col]) return !0;
	    }
	    return !1;
	  }
	}
	function generateGaussianKernel1D(size, sigma) {
	  const kernel = new Array(2 * size + 1).fill(0),
	    center = size;
	  let sum = 0;
	  for (let x = -size; x <= size; x++) {
	    const g = Math.exp(-x * x / (2 * sigma * sigma));
	    kernel[x + center] = g, sum += g;
	  }
	  for (let i = 0; i < kernel.length; i++) kernel[i] /= sum;
	  return kernel;
	}
	function gaussianBlur(labels, width, height, blur) {
	  const sigma = blur / 3,
	    size = Math.ceil(blur / 2),
	    kernel = generateGaussianKernel1D(size, sigma),
	    temp = new Array(labels.length).fill(0),
	    result = new Array(labels.length).fill(0);
	  for (let y = 0; y < height; y++) for (let x = 0; x < width; x++) {
	    let sum = 0;
	    for (let i = -size; i <= size; i++) {
	      sum += labels[y * width + Math.min(Math.max(x + i, 0), width - 1)] * kernel[i + size];
	    }
	    temp[y * width + x] = sum;
	  }
	  for (let x = 0; x < width; x++) for (let y = 0; y < height; y++) {
	    let sum = 0;
	    for (let i = -size; i <= size; i++) {
	      sum += temp[Math.min(Math.max(y + i, 0), height - 1) * width + x] * kernel[i + size];
	    }
	    result[y * width + x] = Math.max(0, Math.min(1, sum));
	  }
	  return result;
	}
	function drawContour(labels, boundaryPixels, width, height, thickness = 1) {
	  const result = new Array(labels.length).fill(0);
	  for (const [i, j] of boundaryPixels) if (result[i * width + j] = 1, thickness > 1) for (let di = 1 - thickness; di <= thickness - 1; di++) for (let dj = 1 - thickness; dj <= thickness - 1; dj++) {
	    if (Math.sqrt(di * di + dj * dj) < thickness) {
	      const ni = i + di,
	        nj = j + dj;
	      ni >= 0 && ni < height && nj >= 0 && nj < width && (result[ni * width + nj] = 1);
	    }
	  }
	  return result;
	}
	function removeBorder(image, canvas, isEmptyPixel) {
	  canvas.width = image.width, canvas.height = image.height;
	  const ctx = canvas.getContext("2d", {
	    willReadFrequently: !0
	  });
	  ctx.clearRect(0, 0, canvas.width, canvas.height), ctx.drawImage(image, 0, 0);
	  const width = canvas.width,
	    imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
	  let top = 0,
	    bottom = imageData.height,
	    left = 0,
	    right = imageData.width;
	  const rowBlank = (width, y) => {
	      for (let x = 0; x < width; ++x) if (!isEmptyPixel(imageData, y, x)) return !1;
	      return !0;
	    },
	    columnBlank = (x, y0, y1) => {
	      for (let y = y0; y < y1; ++y) if (!isEmptyPixel(imageData, y, x)) return !1;
	      return !0;
	    };
	  for (; top < bottom && rowBlank(width, top);) ++top;
	  for (; bottom - 1 > top && rowBlank(width, bottom - 1);) --bottom;
	  for (; left < right && columnBlank(left, top, bottom);) ++left;
	  for (; right - 1 > left && columnBlank(right - 1, top, bottom);) --right;
	  const trimmed = ctx.getImageData(left, top, right - left, bottom - top);
	  return canvas.width = trimmed.width, canvas.height = trimmed.height, ctx.clearRect(0, 0, canvas.width, canvas.height), ctx.putImageData(trimmed, 0, 0), canvas;
	}
	function scaleAndMiddleShape(image, size) {
	  const width = image.width,
	    height = image.height;
	  let scale = size[0] / width;
	  height * scale > size[1] && (scale = size[1] / height);
	  const newWidth = Math.floor(scale * width),
	    newHeight = Math.floor(scale * height);
	  return {
	    x: (size[0] - newWidth) / 2,
	    y: (size[1] - newHeight) / 2,
	    width: newWidth,
	    height: newHeight,
	    scale: scale
	  };
	}

	function loadImage(url, createImage) {
	  return url && (isValidUrl$1(url) || isBase64$1(url) || url.startsWith("<svg")) ? new Promise((resolve, reject) => {
	    var _a;
	    const imageMark = createImage({
	        image: url
	      }),
	      imgData = null === (_a = imageMark.resources) || void 0 === _a ? void 0 : _a.get(url);
	    imgData && "success" === imgData.state && imgData.data ? resolve(imgData.data) : (imageMark.successCallback = () => {
	      var _a;
	      if (imageMark) {
	        const imgData = null === (_a = imageMark.resources) || void 0 === _a ? void 0 : _a.get(url);
	        imgData && "success" === imgData.state && imgData.data ? resolve(imgData.data) : reject(new Error("image load failed: " + url));
	      } else reject(new Error("image load failed: " + url));
	    }, imageMark.failCallback = () => {
	      reject(new Error("image load failed: " + url));
	    });
	  }) : null;
	}
	function loadImages(urls, createImage) {
	  return Promise.allSettled(urls.map(url => loadImage(url, createImage)));
	}

	var ScaleEnum;
	!function (ScaleEnum) {
	  ScaleEnum.Identity = "identity", ScaleEnum.Linear = "linear", ScaleEnum.Log = "log", ScaleEnum.Pow = "pow", ScaleEnum.Sqrt = "sqrt", ScaleEnum.Symlog = "symlog", ScaleEnum.Time = "time", ScaleEnum.Quantile = "quantile", ScaleEnum.Quantize = "quantize", ScaleEnum.Threshold = "threshold", ScaleEnum.Ordinal = "ordinal", ScaleEnum.Point = "point", ScaleEnum.Band = "band";
	}(ScaleEnum || (ScaleEnum = {}));
	Object.values(ScaleEnum).forEach(v => {
	});

	function identity(x) {
	  return x;
	}
	const sqrt = x => x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
	const square = x => x < 0 ? -x * x : x * x;
	function normalize(a, b) {
	  if (a = Number(a), b = Number(b), b -= a) return x => (x - a) / b;
	  const result = Number.isNaN(b) ? NaN : .5;
	  return () => result;
	}
	function bimap(domain, range, interpolate) {
	  const d0 = domain[0],
	    d1 = domain[1],
	    r0 = range[0],
	    r1 = range[1];
	  let d0Fuc, r0Fuc;
	  return d1 < d0 ? (d0Fuc = normalize(d1, d0), r0Fuc = interpolate(r1, r0)) : (d0Fuc = normalize(d0, d1), r0Fuc = interpolate(r0, r1)), x => r0Fuc(d0Fuc(x));
	}
	function calculateWholeRangeFromRangeFactor(range, rangeFactor) {
	  const k = (range[1] - range[0]) / (rangeFactor[1] - rangeFactor[0]),
	    b = range[0] - k * rangeFactor[0];
	  return [b, k + b];
	}
	function polymap(domain, range, interpolate) {
	  const j = Math.min(domain.length, range.length) - 1,
	    d = new Array(j),
	    r = new Array(j);
	  let i = -1;
	  for (domain[j] < domain[0] && (domain = domain.slice().reverse(), range = range.slice().reverse()); ++i < j;) d[i] = normalize(domain[i], domain[i + 1]), r[i] = interpolate(range[i], range[i + 1]);
	  return function (x) {
	    const i = bisect(domain, x, 1, j) - 1;
	    return r[i](d[i](x));
	  };
	}

	class BaseScale {
	  constructor() {
	    this._rangeFactorStart = null, this._rangeFactorEnd = null;
	  }
	  _calculateWholeRange(range) {
	    return this._wholeRange ? this._wholeRange : isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && 2 === range.length ? (this._wholeRange = calculateWholeRangeFromRangeFactor(range, [this._rangeFactorStart, this._rangeFactorEnd]), this._wholeRange) : range;
	  }
	  rangeFactor(_, slience, clear) {
	    return _ ? (2 === _.length && _.every(r => r >= 0 && r <= 1) && (this._wholeRange = null, 0 === _[0] && 1 === _[1] ? (this._rangeFactorStart = null, this._rangeFactorEnd = null) : (this._rangeFactorStart = _[0], this._rangeFactorEnd = _[1])), this) : clear ? (this._wholeRange = null, this._rangeFactorStart = null, this._rangeFactorEnd = null, this) : isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) ? [this._rangeFactorStart, this._rangeFactorEnd] : null;
	  }
	  rangeFactorStart(_, slience) {
	    var _a;
	    return isNil$1(_) ? this._rangeFactorStart : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil$1(this._rangeFactorEnd) && 1 !== this._rangeFactorEnd ? (this._rangeFactorStart = _, this._rangeFactorEnd = null !== (_a = this._rangeFactorEnd) && void 0 !== _a ? _a : 1) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
	  }
	  rangeFactorEnd(_, slience) {
	    var _a;
	    return isNil$1(_) ? this._rangeFactorEnd : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil$1(this._rangeFactorStart) && 0 !== this._rangeFactorStart ? (this._rangeFactorEnd = _, this._rangeFactorStart = null !== (_a = this._rangeFactorStart) && void 0 !== _a ? _a : 0) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
	  }
	  generateFishEyeTransform() {
	    var _a;
	    if (!this._fishEyeOptions) return void (this._fishEyeTransform = null);
	    const {
	        distortion = 2,
	        radiusRatio = .1,
	        radius: radius
	      } = this._fishEyeOptions,
	      range = this.range(),
	      first = range[0],
	      last = range[range.length - 1],
	      min = Math.min(first, last),
	      max = Math.max(first, last),
	      focus = clamp$1(null !== (_a = this._fishEyeOptions.focus) && void 0 !== _a ? _a : 0, min, max),
	      rangeRadius = isNil$1(radius) ? (max - min) * radiusRatio : radius;
	    let k0 = Math.exp(distortion);
	    k0 = k0 / (k0 - 1) * rangeRadius;
	    const k1 = distortion / rangeRadius;
	    this._fishEyeTransform = output => {
	      const delta = Math.abs(output - focus);
	      if (delta >= rangeRadius) return output;
	      if (delta <= 1e-6) return focus;
	      const k = k0 * (1 - Math.exp(-delta * k1)) / delta * .75 + .25;
	      return focus + (output - focus) * k;
	    };
	  }
	  unknown(_) {
	    return arguments.length ? (this._unknown = _, this) : this._unknown;
	  }
	  get(key, defaultValue) {
	    var _a;
	    return null !== (_a = null == this ? void 0 : this[key]) && void 0 !== _a ? _a : defaultValue;
	  }
	}

	const {
	  interpolateRgb: interpolateRgb
	} = ColorUtil;
	function interpolate(a, b) {
	  const t = typeof b;
	  let c;
	  if (isNil$1(b) || "boolean" === t) return () => b;
	  if ("number" === t) return interpolateNumber$1(a, b);
	  if ("string" === t) {
	    if (c = Color.parseColorString(b)) {
	      const rgb = interpolateRgb(Color.parseColorString(a), c);
	      return t => rgb(t).formatRgb();
	    }
	    return interpolateNumber$1(Number(a), Number(b));
	  }
	  return b instanceof RGB ? interpolateRgb(a, b) : b instanceof Color ? interpolateRgb(a.color, b.color) : b instanceof Date ? interpolateDate(a, b) : interpolateNumber$1(Number(a), Number(b));
	}

	class ContinuousScale extends BaseScale {
	  constructor(transformer = identity, untransformer = identity) {
	    super(), this._unknown = void 0, this.transformer = transformer, this.untransformer = untransformer, this._forceAlign = !0, this._domain = [0, 1], this._range = [0, 1], this._clamp = identity, this._piecewise = bimap, this._interpolate = interpolate;
	  }
	  calculateVisibleDomain(range) {
	    var _a;
	    if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && 2 === range.length) {
	      return [this.invert(range[0]), this.invert(range[1])];
	    }
	    return null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain;
	  }
	  fishEye(options, slience, clear) {
	    return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
	  }
	  scale(x) {
	    var _a;
	    if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x)) return this._unknown;
	    this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
	    const output = this._output(this.transformer(this._clamp(x)));
	    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
	  }
	  invert(y) {
	    var _a;
	    return this._input || (this._input = this._piecewise(this._calculateWholeRange(this._range), (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), interpolateNumber$1)), this._clamp(this.untransformer(this._input(y)));
	  }
	  domain(_, slience) {
	    var _a;
	    if (!_) return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).slice();
	    this._domainValidator = null, this._niceType = null, this._niceDomain = null;
	    const nextDomain = Array.from(_, toNumber);
	    return this._domain = nextDomain, this.rescale(slience);
	  }
	  range(_, slience) {
	    if (!_) return this._range.slice();
	    const nextRange = Array.from(_);
	    return this._range = nextRange, this.rescale(slience);
	  }
	  rangeRound(_, slience) {
	    const nextRange = Array.from(_);
	    return this._range = nextRange, this._interpolate = interpolateNumberRound, this.rescale(slience);
	  }
	  rescale(slience) {
	    var _a;
	    if (slience) return this;
	    const domain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain,
	      domainLength = domain.length,
	      rangeLength = this._range.length;
	    let n = Math.min(domainLength, rangeLength);
	    if (domainLength && domainLength < rangeLength && this._forceAlign) {
	      const deltaStep = rangeLength - domainLength + 1,
	        last = domain[domainLength - 1],
	        delta = domainLength >= 2 ? (last - domain[domainLength - 2]) / deltaStep : 0;
	      for (let i = 1; i <= deltaStep; i++) domain[domainLength - 2 + i] = last - delta * (deltaStep - i);
	      n = rangeLength;
	    }
	    return this._autoClamp && (this._clamp = clamper(domain[0], domain[n - 1])), this._piecewise = n > 2 ? polymap : bimap, this._output = this._input = null, this._wholeRange = null, this.generateFishEyeTransform(), this;
	  }
	  clamp(_, f, slience) {
	    return arguments.length ? (f ? (this._autoClamp = !1, this._clamp = f) : (this._autoClamp = !!_, this._clamp = _ ? void 0 : identity), this.rescale(slience)) : this._clamp !== identity;
	  }
	  interpolate(_, slience) {
	    return arguments.length ? (this._interpolate = _, this.rescale(slience)) : this._interpolate;
	  }
	  ticks(count = 10) {
	    return [];
	  }
	  tickData(count = 10) {
	    const ticks = this.ticks(count);
	    return (null != ticks ? ticks : []).map((tick, index) => ({
	      index: index,
	      tick: tick,
	      value: (this.scale(tick) - this._range[0]) / (this._range[1] - this._range[0])
	    }));
	  }
	  rangeFactor(_, slience) {
	    return _ ? (super.rangeFactor(_), this._output = this._input = null, this) : super.rangeFactor();
	  }
	  rangeFactorStart(_, slience) {
	    return isNil$1(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this._output = this._input = null, this);
	  }
	  rangeFactorEnd(_, slience) {
	    return isNil$1(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this._output = this._input = null, this);
	  }
	  forceAlignDomainRange(forceAlign) {
	    return arguments.length ? (this._forceAlign = forceAlign, this) : this._forceAlign;
	  }
	}

	const e10 = Math.sqrt(50),
	  e5 = Math.sqrt(10),
	  e2 = Math.sqrt(2),
	  niceNumbers = [1, 2, 5, 10];
	const calculateTicksOfSingleValue = (value, tickCount, noDecimals) => {
	  let step = 1,
	    start = value;
	  const middleIndex = Math.floor((tickCount - 1) / 2),
	    absVal = Math.abs(value);
	  return value >= 0 && value <= Number.MIN_VALUE ? start = 0 : value < 0 && value >= -Number.MIN_VALUE ? start = -(tickCount - 1) : !noDecimals && absVal < 1 ? step = getNickStep(absVal).step : (noDecimals || absVal > 1) && (start = Math.floor(value) - middleIndex * step), step > 0 ? (value > 0 ? start = Math.max(start, 0) : value < 0 && (start = Math.min(start, -(tickCount - 1) * step)), range$1(0, tickCount).map(index => start + index * step)) : value > 0 ? calculateTicksByStep(0, -(tickCount - 1) / step, step) : calculateTicksByStep((tickCount - 1) / step, 0, step);
	};
	const d3Ticks = memoize((start, stop, count, options) => {
	  let reverse,
	    n,
	    ticks,
	    step,
	    i = -1;
	  if (count = +count, (start = +start) === (stop = +stop)) return [start];
	  if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return [start];
	  if ((reverse = stop < start) && (n = start, start = stop, stop = n), step = tickIncrement(start, stop, count).step, !isFinite(step)) return [];
	  if (step > 0) {
	    let r0 = Math.round(start / step),
	      r1 = Math.round(stop / step);
	    for (r0 * step < start && ++r0, r1 * step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) * step;
	  } else if (step < 0 && (null == options ? void 0 : options.noDecimals)) {
	    step = 1;
	    const r0 = Math.ceil(start),
	      r1 = Math.floor(stop);
	    if (!(r0 <= r1)) return [];
	    for (ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = r0 + i;
	  } else {
	    step = -step;
	    let r0 = Math.round(start * step),
	      r1 = Math.round(stop * step);
	    for (r0 / step < start && ++r0, r1 / step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) / step;
	  }
	  return reverse && ticks.reverse(), ticks;
	});
	const calculateTicksByStep = (start, stop, step) => {
	  let n,
	    ticks,
	    i = -1;
	  if (step > 0) {
	    let r0 = Math.floor(start / step),
	      r1 = Math.ceil(stop / step);
	    for ((r0 + 1) * step < start && ++r0, (r1 - 1) * step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) * step;
	  } else {
	    step = -step;
	    let r0 = Math.floor(start * step),
	      r1 = Math.ceil(stop * step);
	    for ((r0 + 1) / step < start && ++r0, (r1 - 1) / step > stop && --r1, ticks = new Array(n = r1 - r0 + 1); ++i < n;) ticks[i] = (r0 + i) / step;
	  }
	  return ticks;
	};
	const appendTicksToCount = (ticks, count, step) => {
	  let n;
	  const firstTick = ticks[0],
	    lastTick = ticks[ticks.length - 1],
	    appendCount = count - ticks.length;
	  if (lastTick <= 0) {
	    const headTicks = [];
	    for (n = appendCount; n >= 1; n--) headTicks.push(firstTick - n * step);
	    return headTicks.concat(ticks);
	  }
	  if (firstTick >= 0) {
	    for (n = 1; n <= appendCount; n++) ticks.push(lastTick + n * step);
	    return ticks;
	  }
	  let headTicks = [];
	  const tailTicks = [];
	  for (n = 1; n <= appendCount; n++) n % 2 == 0 ? headTicks = [firstTick - Math.floor(n / 2) * step].concat(headTicks) : tailTicks.push(lastTick + Math.ceil(n / 2) * step);
	  return headTicks.concat(ticks).concat(tailTicks);
	};
	const ticks = memoize((start, stop, count, options) => {
	  let reverse, ticks, n;
	  if (count = +count, (start = +start) === (stop = +stop)) return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
	  if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0) return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
	  (reverse = stop < start) && (n = start, start = stop, stop = n);
	  const stepRes = tickIncrement(start, stop, count);
	  let step = stepRes.step;
	  if (!isFinite(step)) return [];
	  if (step > 0) {
	    let cur = 1;
	    const {
	        power: power,
	        gap: gap
	      } = stepRes,
	      delatStep = 10 === gap ? 2 * 10 ** power : 1 * 10 ** power;
	    for (; cur <= 5 && (ticks = calculateTicksByStep(start, stop, step), ticks.length > count + 1) && count > 2;) step += delatStep, cur += 1;
	    count > 2 && ticks.length < count - 1 && (ticks = appendTicksToCount(ticks, count, step));
	  } else (null == options ? void 0 : options.noDecimals) && step < 0 && (step = 1), ticks = calculateTicksByStep(start, stop, step);
	  return reverse && ticks.reverse(), ticks;
	});
	const getNickStep = step => {
	  const power = Math.floor(Math.log(step) / Math.LN10),
	    error = step / 10 ** power;
	  let gap = niceNumbers[0];
	  return error >= e10 ? gap = niceNumbers[3] : error >= e5 ? gap = niceNumbers[2] : error >= e2 && (gap = niceNumbers[1]), power >= 0 ? {
	    step: gap * 10 ** power,
	    gap: gap,
	    power: power
	  } : {
	    step: -(10 ** -power) / gap,
	    gap: gap,
	    power: power
	  };
	};
	function tickIncrement(start, stop, count) {
	  const step = (stop - start) / Math.max(0, count);
	  return getNickStep(step);
	}
	function forceTicks(start, stop, count) {
	  let step;
	  if (count = +count, (start = +start) === (stop = +stop) && count > 0) return [start];
	  if (count <= 0 || 0 === (step = forceTickIncrement(start, stop, count)) || !isFinite(step)) return [];
	  const ticks = new Array(count);
	  for (let i = 0; i < count; i++) ticks[i] = start + i * step;
	  return ticks;
	}
	function forceTickIncrement(start, stop, count) {
	  return (stop - start) / Math.max(1, count - 1);
	}
	function stepTicks(start, stop, step) {
	  let n,
	    reverse,
	    i = -1;
	  if (step = +step, (reverse = (stop = +stop) < (start = +start)) && (n = start, start = stop, stop = n), !isFinite(step) || stop - start <= step) return [start];
	  const count = Math.floor((stop - start) / step + 1),
	    ticks = new Array(count);
	  for (; ++i < count;) ticks[i] = start + i * step;
	  return reverse && ticks.reverse(), ticks;
	}
	function niceLinear(d, count = 10) {
	  let prestep,
	    step,
	    i0 = 0,
	    i1 = d.length - 1,
	    start = d[i0],
	    stop = d[i1],
	    maxIter = 10;
	  for (stop < start && (step = start, start = stop, stop = step, step = i0, i0 = i1, i1 = step); maxIter-- > 0;) {
	    if (step = tickIncrement(start, stop, count).step, step === prestep) return d[i0] = start, d[i1] = stop, d;
	    if (step > 0) start = Math.floor(start / step) * step, stop = Math.ceil(stop / step) * step;else {
	      if (!(step < 0)) break;
	      start = Math.ceil(start * step) / step, stop = Math.floor(stop * step) / step;
	    }
	    prestep = step;
	  }
	}
	function parseNiceOptions(originalDomain, option) {
	  const hasForceMin = isNumber$1(option.forceMin),
	    hasForceMax = isNumber$1(option.forceMax);
	  let niceType = null;
	  const niceMinMax = [];
	  let niceDomain = null;
	  const domainValidator = hasForceMin && hasForceMax ? x => x >= option.forceMin && x <= option.forceMax : hasForceMin ? x => x >= option.forceMin : hasForceMax ? x => x <= option.forceMax : null;
	  return hasForceMin ? niceMinMax[0] = option.forceMin : isNumber$1(option.min) && option.min <= Math.min(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[0] = option.min), hasForceMax ? niceMinMax[1] = option.forceMax : isNumber$1(option.max) && option.max >= Math.max(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[1] = option.max), isNumber$1(niceMinMax[0]) && isNumber$1(niceMinMax[1]) ? (niceDomain = originalDomain.slice(), niceDomain[0] = niceMinMax[0], niceDomain[niceDomain.length - 1] = niceMinMax[1]) : niceType = isNumber$1(niceMinMax[0]) || isNumber$1(niceMinMax[1]) ? isNumber$1(niceMinMax[0]) ? "max" : "min" : "all", {
	    niceType: niceType,
	    niceDomain: niceDomain,
	    niceMinMax: niceMinMax,
	    domainValidator: domainValidator
	  };
	}

	class LinearScale extends ContinuousScale {
	  constructor() {
	    super(...arguments), this.type = ScaleEnum.Linear;
	  }
	  clone() {
	    var _a;
	    const scale = new LinearScale();
	    return scale.domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate), this._niceType && (scale._niceType = this._niceType, scale._domainValidator = this._domainValidator, scale._niceDomain = null === (_a = this._niceDomain) || void 0 === _a ? void 0 : _a.slice()), scale;
	  }
	  tickFormat() {
	    return () => {};
	  }
	  d3Ticks(count = 10, options) {
	    const d = this.calculateVisibleDomain(this._range);
	    return d3Ticks(d[0], d[d.length - 1], count, options);
	  }
	  ticks(count = 10, options) {
	    var _a;
	    if (isFunction$1(null == options ? void 0 : options.customTicks)) return options.customTicks(this, count);
	    if (isValid$1(this._rangeFactorStart) && isValid$1(this._rangeFactorEnd) && (this._rangeFactorStart > 0 || this._rangeFactorEnd < 1) && 2 === this._range.length || !this._niceType) return this.d3Ticks(count, options);
	    const curNiceDomain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain,
	      originalDomain = this._domain,
	      start = curNiceDomain[0],
	      stop = curNiceDomain[curNiceDomain.length - 1];
	    let ticksResult = ticks(originalDomain[0], originalDomain[originalDomain.length - 1], count, options);
	    if (!ticksResult.length) return ticksResult;
	    if (this._domainValidator) ticksResult = ticksResult.filter(this._domainValidator);else if ((ticksResult[0] !== start || ticksResult[ticksResult.length - 1] !== stop) && this._niceType) {
	      const newNiceDomain = curNiceDomain.slice();
	      if ("all" === this._niceType ? (newNiceDomain[0] = ticksResult[0], newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()) : "min" === this._niceType && ticksResult[0] !== start ? (newNiceDomain[0] = ticksResult[0], this._niceDomain = newNiceDomain, this.rescale()) : "max" === this._niceType && ticksResult[ticksResult.length - 1] !== stop && (newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()), "all" !== this._niceType) {
	        const min = Math.min(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]),
	          max = Math.max(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]);
	        ticksResult = ticksResult.filter(entry => entry >= min && entry <= max);
	      }
	    }
	    return ticksResult;
	  }
	  forceTicks(count = 10) {
	    const d = this.calculateVisibleDomain(this._range);
	    return forceTicks(d[0], d[d.length - 1], count);
	  }
	  stepTicks(step) {
	    const d = this.calculateVisibleDomain(this._range);
	    return stepTicks(d[0], d[d.length - 1], step);
	  }
	  nice(count = 10, option) {
	    var _a, _b;
	    const originalDomain = this._domain;
	    let niceMinMax = [];
	    if (option) {
	      const res = parseNiceOptions(originalDomain, option);
	      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, this._niceType = res.niceType, res.niceDomain) return this._niceDomain = res.niceDomain, this.rescale(), this;
	    } else this._niceType = "all";
	    if (this._niceType) {
	      const niceDomain = niceLinear(originalDomain.slice(), count);
	      "min" === this._niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === this._niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale();
	    }
	    return this;
	  }
	  niceMin(count = 10) {
	    this._niceType = "min";
	    const maxD = this._domain[this._domain.length - 1],
	      niceDomain = niceLinear(this.domain(), count);
	    return niceDomain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
	  }
	  niceMax(count = 10) {
	    this._niceType = "max";
	    const minD = this._domain[0],
	      niceDomain = niceLinear(this._domain.slice(), count);
	    return niceDomain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
	  }
	}

	class SqrtScale extends LinearScale {
	  constructor() {
	    super(sqrt, square), this.type = ScaleEnum.Sqrt;
	  }
	  clone() {
	    return new SqrtScale().domain(this._domain, !0).range(this._range, !0).unknown(this._unknown).clamp(this.clamp(), null, !0).interpolate(this._interpolate);
	  }
	}

	var IMAGECLOUD_HOOK_EVENT;
	!function (IMAGECLOUD_HOOK_EVENT) {
	  IMAGECLOUD_HOOK_EVENT.BEFORE_IMAGECLOUD_LAYOUT = "beforeImagecloudLayout", IMAGECLOUD_HOOK_EVENT.AFTER_IMAGECLOUD_LAYOUT = "afterImagecloudLayout", IMAGECLOUD_HOOK_EVENT.AFTER_IMAGECLOUD_DRAW = "afterImagecloudDraw";
	}(IMAGECLOUD_HOOK_EVENT || (IMAGECLOUD_HOOK_EVENT = {}));
	function setSize(image, longSideLength) {
	  image.aspectRatio > 1 ? (image.width = longSideLength, image.height = ~~(longSideLength / image.aspectRatio)) : (image.height = longSideLength, image.width = ~~(longSideLength * image.aspectRatio));
	}
	function setSizeByShortSide(image, shortSideLength) {
	  image.aspectRatio > 1 ? (image.height = shortSideLength, image.width = ~~(shortSideLength * image.aspectRatio)) : (image.width = shortSideLength, image.height = ~~(shortSideLength / image.aspectRatio));
	}

	class Layout {
	  constructor(options) {
	    this.progressiveResult = [], this.imageCollageList = [], this.options = options;
	  }
	  preProcess() {
	    const {
	        imageConfig = {},
	        weight: weight
	      } = this.options,
	      {
	        padding = 0
	      } = imageConfig;
	    let images = this.imageCollageList;
	    return images.forEach((img, index) => {
	      !1 === img.valid ? (img.x = -10, img.y = -10, img.width = 0, img.height = 0, img.opacity = 0) : (img.padding = padding, img.weight = simpleField(weight)(this.data[index]), img.datum = this.data[index]);
	    }), images = images.filter(img => !1 !== img.valid).sort((a, b) => b.weight - a.weight), images;
	  }
	  onImageCollageInputReady(images) {
	    images.forEach((img, i) => {
	      if ("fulfilled" === img.status) {
	        const imageElement = img.value,
	          {
	            width: width,
	            height: height
	          } = imageElement;
	        this.imageCollageList.push(Object.assign({}, this.data[i], {
	          aspectRatio: width / height
	        }));
	      } else this.imageCollageList.push(Object.assign({}, this.data[i], {
	        valid: !1
	      }));
	    });
	  }
	  layout(data) {
	    this.data = data, this.loadSegmentationInput(), this.loadImageCollageInput();
	  }
	  loadSegmentationInput() {
	    var _a, _b, _c, _d, _e, _f;
	    const options = this.options,
	      size = options.size,
	      segmentationInput = {
	        shapeUrl: null !== (_a = options.mask) && void 0 !== _a ? _a : {
	          type: "geometric",
	          shape: "rect"
	        },
	        size: size,
	        ratio: options.ratio || .8,
	        tempCanvas: void 0,
	        boardSize: [0, 0],
	        random: !1,
	        randomGenerator: void 0,
	        blur: null === (_b = options.maskConfig) || void 0 === _b ? void 0 : _b.edgeBlur
	      },
	      tempCanvas = this.options.createCanvas({
	        width: size[0],
	        height: size[1]
	      }),
	      tempCtx = tempCanvas.getContext("2d", {
	        willReadFrequently: !0
	      });
	    tempCtx.textAlign = "center", tempCtx.textBaseline = "middle", segmentationInput.tempCanvas = tempCanvas;
	    const boardW = size[0] + 31 >> 5 << 5;
	    if (segmentationInput.boardSize = [boardW, size[1]], segmentationInput.random ? segmentationInput.randomGenerator = Math.random : segmentationInput.randomGenerator = fakeRandom(), this.segmentationInput = segmentationInput, isString$1(segmentationInput.shapeUrl)) {
	      segmentationInput.isEmptyPixel = generateIsEmptyPixel(void 0, {
	        threshold: null !== (_d = null === (_c = options.maskConfig) || void 0 === _c ? void 0 : _c.threshold) && void 0 !== _d ? _d : 200,
	        invert: null === (_e = options.maskConfig) || void 0 === _e ? void 0 : _e.invert
	      }, this.options.createCanvas);
	      const imagePromise = loadImage(segmentationInput.shapeUrl, this.options.createImage);
	      imagePromise ? (this.isMaskImageFinished = !1, this.isLayoutFinished = !1, imagePromise.then(shapeImage => {
	        var _a, _b;
	        this.isMaskImageFinished = !0;
	        const size = options.size,
	          maskCanvas = this.options.createCanvas({
	            width: size[0],
	            height: size[1],
	            dpr: 1
	          });
	        segmentationInput.maskCanvas = maskCanvas;
	        const ctx = maskCanvas.getContext("2d");
	        (null === (_a = options.maskConfig) || void 0 === _a ? void 0 : _a.removeWhiteBorder) && removeBorder(shapeImage, maskCanvas, segmentationInput.isEmptyPixel);
	        const shapeConfig = scaleAndMiddleShape(shapeImage, size);
	        let transparentMaskCanvas;
	        ctx.clearRect(0, 0, size[0], size[1]), ctx.drawImage(shapeImage, shapeConfig.x, shapeConfig.y, shapeConfig.width, shapeConfig.height), this.segmentationOutput = segmentation(this.segmentationInput), "masked" === (null === (_b = this.options.layoutConfig) || void 0 === _b ? void 0 : _b.placement) && (transparentMaskCanvas = this.generateTransparentMaskCanvas(shapeImage, size)), this.segmentationOutput.transparentMaskCanvas = transparentMaskCanvas, this.options.onUpdateMaskCanvas && this.options.onUpdateMaskCanvas(maskCanvas, transparentMaskCanvas);
	      }).catch(error => {
	        this.isMaskImageFinished = !0;
	      })) : (this.isMaskImageFinished = !0, this.isLayoutFinished = !0);
	    } else if (segmentationInput.shapeUrl && ("text" === segmentationInput.shapeUrl.type || "geometric" === segmentationInput.shapeUrl.type)) {
	      segmentationInput.isEmptyPixel = generateIsEmptyPixel(segmentationInput.shapeUrl.backgroundColor, void 0, this.options.createCanvas), "text" !== segmentationInput.shapeUrl.type && "geometric" !== segmentationInput.shapeUrl.type || segmentationInput.shapeUrl.backgroundColor || (segmentationInput.shapeUrl.backgroundColor = "rgba(255,255,255,255)");
	      const maskCanvas = generateMaskCanvas(segmentationInput.shapeUrl, size[0], size[1], void 0, null === (_f = options.maskConfig) || void 0 === _f ? void 0 : _f.invert, this.options.createCanvas);
	      segmentationInput.maskCanvas = maskCanvas, this.segmentationOutput = segmentation(this.segmentationInput), this.options.onUpdateMaskCanvas && this.options.onUpdateMaskCanvas(maskCanvas, maskCanvas), this.isMaskImageFinished = !0;
	    }
	  }
	  loadImageCollageInput() {
	    const data = this.data,
	      imagesPromise = loadImages(data.map(d => simpleField(this.options.image)(d)), this.options.createImage);
	    imagesPromise ? imagesPromise.then(images => {
	      this.onImageCollageInputReady(images), this.isImagesFinished = !0;
	    }).catch(error => {
	      this.isImagesFinished = !0, this.isLayoutFinished = !0, Logger.getInstance().error("image load failed", error);
	    }) : (this.isImagesFinished = !0, this.isLayoutFinished = !0);
	  }
	  canAnimate() {
	    return !0;
	  }
	  unfinished() {
	    return !this.isLayoutFinished;
	  }
	  output() {
	    return this.progressiveResult;
	  }
	  progressiveRun() {
	    if (this.isImagesFinished && this.isMaskImageFinished && !this.isLayoutFinished) {
	      const images = this.preProcess(),
	        layoutResult = this.doLayout(images);
	      this.options && this.options.onLayoutEnd && this.options.onLayoutEnd(layoutResult), this.progressiveResult = this.processOutput(layoutResult), this.isLayoutFinished = !0;
	    }
	  }
	  progressiveOutput() {
	    return this.progressiveResult;
	  }
	  release() {
	    this.segmentationInput = null, this.data = null, this.progressiveResult = null, this.options = null;
	  }
	  calculateImageSize(images, imageConfig = {}, ratio = .45) {
	    const {
	        imageSizeRange: imageSizeRange,
	        padding = 0
	      } = imageConfig,
	      imageSize = isNumber$1(imageConfig.imageSize) ? imageConfig.imageSize : field(imageConfig.imageSize),
	      size = this.options.size;
	    if (imageSize || imageSizeRange) {
	      if (imageSize && !isFunction$1(imageSize)) images.forEach(img => setSize(img, imageSize));else if (imageSizeRange) {
	        const sizeScale = new SqrtScale().domain(extent(images, d => d.weight)).range(imageSizeRange);
	        images.forEach(img => setSize(img, ~~sizeScale.scale(img.weight)));
	      } else if (imageSize && isFunction$1(imageSize) && !imageSizeRange) {
	        const a = .5,
	          [min, max] = extent(images, d => d.weight),
	          picArea = images.reduce((prev, img) => {
	            const r = img.aspectRatio,
	              w = (img.weight - min) / (max - min);
	            return prev + (r > 1 ? 1 / r : r) * (a + (1 - a) * w) ** 2;
	          }, 0),
	          x = ~~Math.sqrt(ratio * size[0] * size[1] / picArea),
	          range = [~~(a * x) - 2 * padding < 0 ? 1 : ~~(a * x) - 2 * padding, ~~x - 2 * padding < 0 ? 1 : ~~x - 2 * padding],
	          sizeScale = new SqrtScale().domain(extent(images, d => d.weight)).range(range);
	        images.forEach(img => setSize(img, ~~sizeScale.scale(img.weight)));
	      } else console.warn("image cloud imageSize error");
	    } else {
	      const imageArea = images.reduce((prev, pic) => {
	        const r = pic.aspectRatio;
	        return prev + (r > 1 ? 1 / r : r);
	      }, 0);
	      let longSideLength = ~~Math.sqrt(ratio * size[0] * size[1] / imageArea);
	      longSideLength = longSideLength - 2 * padding < 0 ? 1 : longSideLength - 2 * padding, images.forEach(img => setSize(img, longSideLength));
	    }
	    return images;
	  }
	  generateTransparentMaskCanvas(shapeImage, size) {
	    var _a;
	    const transparentMaskCanvas = this.options.createCanvas({
	        width: size[0],
	        height: size[1],
	        dpr: 1
	      }),
	      transparentMaskContext = transparentMaskCanvas.getContext("2d");
	    this.segmentationOutput.transparentMaskCanvas = transparentMaskCanvas, (null === (_a = this.options.maskConfig) || void 0 === _a ? void 0 : _a.removeWhiteBorder) && removeBorder(shapeImage, transparentMaskCanvas, this.segmentationInput.isEmptyPixel);
	    const imageData = transparentMaskContext.createImageData(size[0], size[1]),
	      labels = this.segmentationOutput.segmentation.labels;
	    for (let i = 0; i < labels.length; i++) {
	      const color = 0 === labels[i] ? 255 : 0,
	        alpha = 255 * labels[i],
	        pixelIndex = 4 * i;
	      imageData.data[pixelIndex] = color, imageData.data[pixelIndex + 1] = color, imageData.data[pixelIndex + 2] = color, imageData.data[pixelIndex + 3] = alpha;
	    }
	    return transparentMaskContext.clearRect(0, 0, size[0], size[1]), transparentMaskContext.fillStyle = "rgba(255,255,255,0)", transparentMaskContext.fillRect(0, 0, size[0], size[1]), transparentMaskContext.putImageData(imageData, 0, 0), transparentMaskCanvas;
	  }
	  processOutput(images) {
	    var _a;
	    const outputAs = null === (_a = this.options) || void 0 === _a ? void 0 : _a.as;
	    return outputAs && Object.keys(outputAs).forEach(key => {
	      images.forEach(img => {
	        img[outputAs[key]] = img[key], delete img[key];
	      });
	    }), images;
	  }
	}

	class SpiralLayout extends Layout {
	  preProcess() {
	    const images = super.preProcess(),
	      {
	        imageConfig = {},
	        ratio = .45
	      } = this.options;
	    return this.calculateImageSize(images, imageConfig, ratio);
	  }
	  tryPlaceImage(image, size, spiralType, segmentationOutput, fixedImages, dt = 1) {
	    const [width, height] = size,
	      centerX = width / 2,
	      centerY = height / 2,
	      maxR = Math.sqrt(centerX ** 2 + centerY ** 2),
	      spiral = spirals[spiralType](size);
	    let dx,
	      dy,
	      t = -dt;
	    const {
	        segmentation: segmentation
	      } = segmentationOutput,
	      {
	        labels: labels
	      } = segmentation;
	    for (; ([dx, dy] = spiral(t += dt)) && !(Math.min(Math.abs(dx), Math.abs(dy)) >= maxR);) if (dx -= image.width / 2, dy -= image.height / 2, image.visible = !0, image.x = ~~(centerX + dx), image.y = ~~(centerY + dy), image._left = image.x + image.padding, image._top = image.y + image.padding, image._leftWithoutPadding = image.x, image._topWithoutPadding = image.y, fit(image, fixedImages)) {
	      const {
	        x: x,
	        y: y,
	        width: imageWidth,
	        height: imageHeight
	      } = image;
	      let intersect = !1;
	      for (let r = 0; r < imageWidth; r++) {
	        for (let c = 0; c < imageHeight && y + r <= height; c++) {
	          if (x + c > width) continue;
	          if (!!!labels[(y + r) * width + (x + c)]) {
	            intersect = !0;
	            break;
	          }
	        }
	        if (intersect) break;
	      }
	      if (!intersect) {
	        const corners = [{
	          x: image.x,
	          y: image.y
	        }, {
	          x: image.x + image.width,
	          y: image.y
	        }, {
	          x: image.x,
	          y: image.y + image.height
	        }, {
	          x: image.x + image.width,
	          y: image.y + image.height
	        }];
	        let allCornersInShape = !0;
	        for (const corner of corners) if (!labels[corner.y * width + corner.x]) {
	          allCornersInShape = !1;
	          break;
	        }
	        if (!allCornersInShape) continue;
	        return !0;
	      }
	    }
	    return !1;
	  }
	  doLayout(images) {
	    var _a;
	    const {
	        segmentationOutput: segmentationOutput
	      } = this,
	      {
	        layoutConfig = {}
	      } = this.options,
	      size = this.options.size,
	      {
	        spiralType = "archimedean",
	        fillingTimes = 4,
	        minFillingImageSize = 10
	      } = layoutConfig,
	      fixedImages = [],
	      key = Object.keys(images[0]).find(k => k.includes("VGRAMMAR"));
	    for (const image of images) image._widthWithPadding = image.width + 2 * image.padding, image._heightWithPadding = image.height + 2 * image.padding, image.frequency = 1, this.tryPlaceImage(image, size, spiralType, segmentationOutput, fixedImages) && fixedImages.push(image);
	    const minImageWidth = minInArray(fixedImages, (a, b) => a.width - b.width).width,
	      minImageHeight = minInArray(fixedImages, (a, b) => a.height - b.height).height,
	      fixedFillingImages = [];
	    for (let i = 0; i < fillingTimes; i++) {
	      const minWidth = .5 * minImageWidth - 1 * i,
	        minHeight = .5 * minImageHeight - 1 * i;
	      for (const image of images) {
	        const fillingImage = Object.assign({}, image, {
	            visible: !0
	          }),
	          imageSize = Math.max(minFillingImageSize, fillingImage.aspectRatio > 1 ? minWidth : minHeight);
	        setSize(fillingImage, imageSize), fillingImage._widthWithPadding = fillingImage.width + 2 * fillingImage.padding, fillingImage._heightWithPadding = fillingImage.height + 2 * fillingImage.padding, this.tryPlaceImage(fillingImage, size, spiralType, segmentationOutput, [...fixedFillingImages, ...fixedImages], .5) && (image._tempFrequency = (null !== (_a = image._tempFrequency) && void 0 !== _a ? _a : image.frequency) + 1, fillingImage.frequency = image._tempFrequency, fillingImage.distance = Math.sqrt(Math.pow(fillingImage.x - size[0] / 2, 2) + Math.pow(fillingImage.y - size[1] / 2, 2)), fillingImage[key] = `${fillingImage[key]}_${fillingImage.frequency}`, fixedFillingImages.push(fillingImage));
	      }
	    }
	    return [...fixedImages, ...fixedFillingImages].filter(image => image.visible);
	  }
	}
	function fit(image, fixedImages) {
	  for (let i = 0; i < fixedImages.length; i++) if (isOverlap$1(image, fixedImages[i])) return !1;
	  return !0;
	}
	function isOverlap$1(a, b) {
	  return !(a._leftWithoutPadding + a._widthWithPadding < b._leftWithoutPadding || a._topWithoutPadding + a._heightWithPadding < b._topWithoutPadding || a._leftWithoutPadding > b._leftWithoutPadding + b._widthWithPadding || a._topWithoutPadding > b._topWithoutPadding + b._heightWithPadding);
	}

	function rectGridLayout(options) {
	  const {
	      imageConfig = {},
	      size: size,
	      ratio = .1,
	      layoutConfig = {}
	    } = options,
	    {
	      padding = 0,
	      imageSize: imageSize
	    } = imageConfig,
	    [width, height] = size;
	  let shortSideLength;
	  shortSideLength = imageSize || Math.min(width, height) * ratio - 2 * padding, shortSideLength < 0 && (shortSideLength = 1);
	  const {
	    rectAspectRatio = 1
	  } = layoutConfig;
	  let cellWidth, cellHeight;
	  rectAspectRatio > 1 ? (cellWidth = shortSideLength, cellHeight = shortSideLength / rectAspectRatio) : (cellHeight = shortSideLength, cellWidth = shortSideLength * rectAspectRatio);
	  const rows = Math.ceil(height / (cellHeight + padding)),
	    cols = Math.ceil(width / (cellWidth + padding)),
	    center_x = width / 2,
	    center_y = height / 2,
	    cellInfo = new Array(cols * rows);
	  for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
	    const cellCenterX = c * (cellWidth + padding) + cellWidth / 2,
	      cellCenterY = r * (cellHeight + padding) + cellHeight / 2;
	    cellInfo[r * cols + c] = {
	      centerX: cellCenterX,
	      centerY: cellCenterY,
	      x: cellCenterX - cellWidth / 2,
	      y: cellCenterY - cellHeight / 2,
	      row: r,
	      col: c,
	      distance: Math.sqrt(Math.pow(cellCenterX - center_x, 2) + Math.pow(cellCenterY - center_y, 2))
	    };
	  }
	  return {
	    context: Object.assign({}, layoutConfig, {
	      cellWidth: cellWidth,
	      cellHeight: cellHeight,
	      cellInfo: cellInfo,
	      cellCount: cellInfo.length,
	      cellType: "rect",
	      cellPixelCount: cellWidth * cellHeight,
	      eachPixel: (cell, callback) => {
	        const {
	          x: x,
	          y: y
	        } = cell;
	        for (let r = 0; r < cellWidth; r++) for (let c = 0; c < cellHeight && y + r <= height; c++) x + c > width || callback((~~y + r) * width + (~~x + c));
	      },
	      clipPath: `M${-cellWidth / 2} ${-cellHeight / 2} L${cellWidth / 2} ${-cellHeight / 2} L${cellWidth / 2} ${cellHeight / 2} L${-cellWidth / 2} ${cellHeight / 2} Z`
	    }),
	    imageLength: shortSideLength
	  };
	}

	function circleGridLayout(options) {
	  const {
	      imageConfig = {},
	      size: size,
	      ratio = .1,
	      layoutConfig = {}
	    } = options,
	    {
	      padding = 0,
	      imageSize = 0
	    } = imageConfig,
	    [width, height] = size,
	    center_x = width / 2,
	    center_y = height / 2;
	  let circleRadius = 0;
	  circleRadius = imageSize ? imageSize / 2 : Math.min(width, height) * ratio / 2, circleRadius - padding <= 0 && (circleRadius = padding + 1);
	  const circleDiameter = 2 * circleRadius,
	    rowHeight = Math.sqrt(3) / 2 * circleDiameter + padding,
	    cellInfo = [];
	  let index = 0;
	  for (let r = 0; r * rowHeight - circleRadius < height; r++) {
	    const y = r * rowHeight,
	      offsetX = r % 2 == 0 ? 0 : circleRadius;
	    for (let c = -1; c * (circleDiameter + padding) + offsetX - circleRadius < width; c++) {
	      const x = c * (circleDiameter + padding) + offsetX + circleRadius;
	      cellInfo[index++] = {
	        centerX: x,
	        centerY: y,
	        x: x - circleRadius,
	        y: y - circleRadius,
	        row: r,
	        col: c,
	        distance: Math.sqrt(Math.pow(x - center_x, 2) + Math.pow(y - center_y, 2))
	      };
	    }
	  }
	  let cellPixelCount = 0;
	  const rSquared = circleRadius * circleRadius;
	  for (let r = 0; r < circleDiameter; r++) for (let c = 0; c < circleDiameter; c++) {
	    const dx = r - circleRadius,
	      dy = c - circleRadius;
	    dx * dx + dy * dy <= rSquared && cellPixelCount++;
	  }
	  return {
	    context: Object.assign({}, layoutConfig, {
	      cellWidth: circleDiameter,
	      cellHeight: circleDiameter,
	      cellInfo: cellInfo,
	      cellCount: cellInfo.length,
	      cellType: "circle",
	      cellPixelCount: cellPixelCount,
	      eachPixel: (cell, callback) => {
	        const {
	          x: x,
	          y: y
	        } = cell;
	        for (let r = 0; r < circleDiameter; r++) for (let c = 0; c < circleDiameter; c++) {
	          if (r + x < 0 || r + x > width || c + y > height || c + y < 0) continue;
	          const dx = r - circleRadius,
	            dy = c - circleRadius;
	          dx * dx + dy * dy <= rSquared && callback((~~y + r) * width + (~~x + c));
	        }
	      },
	      clipPath: "M 1 0 A 1 1 0 1 0 -1 0 A 1 1 0 1 0 1 0 Z"
	    }),
	    imageLength: circleDiameter
	  };
	}

	function hexagonalGridLayout(options) {
	  const {
	      imageConfig = {},
	      size: size,
	      ratio = .1,
	      layoutConfig = {}
	    } = options,
	    {
	      padding = 0,
	      imageSize: imageSize
	    } = imageConfig,
	    [width, height] = size,
	    center_x = width / 2,
	    center_y = height / 2;
	  let radius;
	  radius = imageSize ? imageSize / 2 : Math.min(width, height) * ratio / 2, radius - padding <= 0 && (radius = padding + 1);
	  const points = [],
	    step = 2 * Math.PI / 6;
	  for (let i = 0; i < 6; i++) {
	    const angle = step * i;
	    points.push({
	      x: (radius - padding / 2) * Math.cos(angle),
	      y: (radius - padding / 2) * Math.sin(angle)
	    });
	  }
	  const diameter = 2 * radius,
	    edgeLength = Math.sin(Math.PI / 6) * diameter,
	    cellHeight = Math.sqrt(3) * edgeLength,
	    gridSpaceX = diameter - edgeLength / 2,
	    gridSpaceY = Math.cos(Math.PI / 6) * diameter,
	    gridOffsetY = gridSpaceY / 2,
	    rows = Math.floor(height / cellHeight),
	    cols = Math.floor(width / edgeLength),
	    cellInfo = [];
	  for (let r = -1; r <= rows + 1; r++) for (let c = -1; c <= cols; c++) {
	    const centerX = c * gridSpaceX,
	      centerY = r * gridSpaceY + (c % 2 ? gridOffsetY : 0);
	    cellInfo.push({
	      centerX: centerX,
	      centerY: centerY,
	      x: centerX - edgeLength,
	      y: centerY - edgeLength,
	      row: r,
	      col: c,
	      distance: Math.sqrt(Math.pow(centerX - center_x, 2) + Math.pow(centerY - center_y, 2))
	    });
	  }
	  let cellPixelCount = 0;
	  const pixelMap = [];
	  for (let r = 0; r <= cellHeight; r++) for (let c = 0; c <= 2 * edgeLength; c++) {
	    const px = c - edgeLength,
	      py = r - cellHeight / 2,
	      q2x = Math.abs(px),
	      q2y = Math.abs(py);
	    q2x <= edgeLength && q2y <= cellHeight / 2 && 2 * q2y + q2x * Math.sqrt(3) <= cellHeight ? (cellPixelCount++, pixelMap.push(!0)) : pixelMap.push(!1);
	  }
	  return {
	    context: Object.assign({}, layoutConfig, {
	      cellHexSideLength: edgeLength,
	      cellHexPoints: points,
	      cellHeight: cellHeight,
	      cellWidth: 2 * edgeLength,
	      cellInfo: cellInfo,
	      cellCount: cellInfo.length,
	      cellType: "hexagonal",
	      cellPixelCount: cellPixelCount,
	      eachPixel: (cell, callback) => {
	        const {
	          x: x,
	          y: y
	        } = cell;
	        let index = 0;
	        for (let r = 0; r <= cellHeight; r++) for (let c = 0; c <= 2 * edgeLength; c++) pixelMap[index++] && callback((~~y + r) * width + (~~x + c));
	      },
	      clipPath: "M 1 0 L 0.5 0.866 L -0.5 0.866 L -1 0 L -0.5 -0.866 L 0.5 -0.866 Z"
	    }),
	    imageLength: diameter - padding
	  };
	}

	const cellLayout = {
	  rect: rectGridLayout,
	  circle: circleGridLayout,
	  hexagonal: hexagonalGridLayout
	};
	class GridLayout extends Layout {
	  preProcess() {
	    var _a;
	    const images = super.preProcess(),
	      {
	        layoutConfig = {}
	      } = this.options,
	      {
	        cellType = "rect"
	      } = layoutConfig,
	      layoutResult = (null !== (_a = cellLayout[cellType]) && void 0 !== _a ? _a : cellLayout.rect)(this.options),
	      {
	        context: context,
	        imageLength: shortSideLength
	      } = layoutResult;
	    return images.forEach(img => setSizeByShortSide(img, shortSideLength)), context.cellInfo.sort((cellA, cellB) => cellA.distance - cellB.distance), this.layoutContext = context, images;
	  }
	  doLayout(images) {
	    const {
	      cellWidth: cellWidth,
	      cellHeight: cellHeight,
	      cellInfo: cellInfo,
	      cellCount: cellCount,
	      clipPath: clipPath,
	      eachPixel: eachPixel,
	      cellPixelCount: cellPixelCount
	    } = this.layoutContext;
	    if (0 === images.length || 0 === cellCount || 0 === cellWidth || 0 === cellHeight || 0 === cellInfo.length) return void (this.isLayoutFinished = !0);
	    const {
	        segmentationOutput: segmentationOutput
	      } = this,
	      {
	        layoutConfig = {}
	      } = this.options,
	      {
	        placement = "default"
	      } = layoutConfig;
	    if ("edge" === placement || "default" === placement) {
	      const {
	          segmentation: segmentation
	        } = segmentationOutput,
	        {
	          labels: labels
	        } = segmentation;
	      cellInfo.forEach(cell => {
	        let intersectPixelCount = 0;
	        eachPixel(cell, index => {
	          labels[index] && intersectPixelCount++;
	        }), cell.intersectPixels = intersectPixelCount;
	      });
	    }
	    const imageCount = images.length,
	      imageVisible = cell => {
	        const {
	          intersectPixels: intersectPixels
	        } = cell;
	        return "default" === placement ? intersectPixels >= .45 * cellPixelCount : "edge" !== placement || intersectPixels > .1 * cellPixelCount && intersectPixels < cellPixelCount;
	      };
	    for (let i = 0; i < imageCount; i++) {
	      const image = images[i],
	        cell = cellInfo[i];
	      cell && (image.x = cell.centerX - image.width / 2, image.y = cell.centerY - image.height / 2, image.clipConfig = {
	        shape: clipPath
	      }, image.frequency = 1, image.visible = imageVisible(cell), image.cell = pickWithout(cell, ["image"]), image.distance = cell.distance, cell.image = image);
	    }
	    const key = Object.keys(images[0]).find(k => k.includes("VGRAMMAR"));
	    if (imageCount < cellCount) for (let i = imageCount; i < cellCount; i++) {
	      const image = images[i - imageCount],
	        cell = cellInfo[i];
	      if (cell) {
	        const repeatImage = Object.assign({}, image);
	        repeatImage.x = cell.centerX - repeatImage.width / 2, repeatImage.y = cell.centerY - repeatImage.height / 2, repeatImage.frequency += 1, repeatImage[key] = `${repeatImage[key]}_${repeatImage.frequency}`, repeatImage.visible = imageVisible(cell), repeatImage.distance = cell.distance, repeatImage.cell = pickWithout(cell, ["image"]), cell.image = repeatImage, images.push(repeatImage);
	      }
	    }
	    return images.filter(img => img.visible);
	  }
	}

	class StackLayout extends Layout {
	  preProcess() {
	    const images = super.preProcess(),
	      {
	        imageConfig = {},
	        ratio = .1
	      } = this.options,
	      cellLayoutMethod = rectGridLayout;
	    return this.layoutContext = cellLayoutMethod(Object.assign({}, this.options, {
	      imageConfig: {
	        imageSize: null
	      }
	    })).context, this.layoutContext.cellInfo.sort((cellA, cellB) => cellA.distance - cellB.distance), this.calculateImageSize(images, imageConfig, ratio);
	  }
	  doLayout(images) {
	    const {
	        segmentationOutput: segmentationOutput
	      } = this,
	      {
	        cellWidth: cellWidth,
	        cellHeight: cellHeight,
	        cellInfo: cellInfo,
	        cellCount: cellCount,
	        eachPixel: eachPixel,
	        cellPixelCount: cellPixelCount
	      } = this.layoutContext;
	    if (0 === images.length || 0 === cellCount || 0 === cellWidth || 0 === cellHeight || 0 === cellInfo.length) return void (this.isLayoutFinished = !0);
	    const {
	        layoutConfig = {}
	      } = this.options,
	      size = this.options.size,
	      {
	        placement = "default",
	        maxAngle = Math.PI / 180 * 45
	      } = layoutConfig;
	    if ("edge" === placement || "default" === placement) {
	      const {
	          segmentation: segmentation
	        } = segmentationOutput,
	        {
	          labels: labels
	        } = segmentation;
	      cellInfo.forEach(cell => {
	        let intersectPixelCount = 0;
	        eachPixel(cell, index => {
	          labels[index] && intersectPixelCount++;
	        }), cell.intersectPixels = intersectPixelCount;
	      });
	    }
	    const imageCount = images.length,
	      maxDistance = Math.sqrt(Math.pow(size[0], 2) + Math.pow(size[1], 2)),
	      imageVisible = cell => {
	        const {
	          intersectPixels: intersectPixels
	        } = cell;
	        return "default" === placement ? intersectPixels > .5 * cellPixelCount : "edge" !== placement || intersectPixels > .1 * cellPixelCount && intersectPixels < cellPixelCount;
	      };
	    for (let i = 0; i < imageCount; i++) {
	      const image = images[i],
	        cell = cellInfo[i];
	      cell && (image.x = cell.centerX - image.width / 2, image.y = cell.centerY - image.height / 2, image.visible = imageVisible(cell), image.cell = `${cell.row}_${cell.col}`, image.angle = Math.random() * (2 * maxAngle) - maxAngle, image.anchor = [image.x + image.width / 2, image.y + image.height / 2], image.zIndex = maxDistance - cell.distance, image.distance = cell.distance, image.frequency = 1, cell.image = image);
	    }
	    const key = Object.keys(images[0]).find(k => k.includes("VGRAMMAR"));
	    if (imageCount < cellCount) for (let i = imageCount; i < cellCount; i++) {
	      const image = images[i - imageCount],
	        cell = cellInfo[i];
	      if (cell) {
	        const repeatImage = Object.assign({}, image);
	        repeatImage.x = cell.centerX - repeatImage.width / 2, repeatImage.y = cell.centerY - repeatImage.height / 2, repeatImage.anchor = [repeatImage.x + repeatImage.width / 2, repeatImage.y + repeatImage.height / 2], repeatImage.angle = Math.random() * (2 * maxAngle) - maxAngle, repeatImage.frequency += 1, repeatImage[key] = `${repeatImage[key]}_${repeatImage.frequency}`, repeatImage.visible = imageVisible(cell), repeatImage.cell = `${cell.row}_${cell.col}`, repeatImage.distance = cell.distance, repeatImage.zIndex = maxDistance - cell.distance, cell.image = repeatImage, images.push(repeatImage);
	      }
	    }
	    return images.filter(img => img.visible);
	  }
	}

	const transform = (options, upstreamData, parameters) => {
	  var _a, _b;
	  const size = isFunction$1(options.size) ? options.size() : options.size;
	  if (options.size = size, !size || isNil$1(size[0]) || isNil$1(size[1]) || size[0] <= 0 || size[1] <= 0) {
	    return Logger.getInstance().info("Wordcloud size dimensions must be greater than 0"), [];
	  }
	  if (options.size = [Math.ceil(size[0]), Math.ceil(size[1])], options.image || Logger.getInstance().error("Imagecloud: image source must be specified."), options.onBeforeLayout && options.onBeforeLayout(), !upstreamData || 0 === upstreamData.length) return [];
	  let layoutConstructor;
	  switch (null !== (_b = null === (_a = options.layoutConfig) || void 0 === _a ? void 0 : _a.layoutMode) && void 0 !== _b ? _b : "spiral") {
	    case "grid":
	      layoutConstructor = GridLayout;
	      break;
	    case "stack":
	      layoutConstructor = StackLayout;
	      break;
	    default:
	      layoutConstructor = SpiralLayout;
	  }
	  const layout = new layoutConstructor(options);
	  return layout.layout(upstreamData), layout.unfinished() ? {
	    progressive: layout
	  } : layout.output();
	};

	class AxialRotateAnimation extends ACustomAnimate {
	    constructor(from, to, duration, easing, params) {
	        var _a;
	        super(from, to, duration, easing, params);
	        this._rotations = (_a = params === null || params === void 0 ? void 0 : params.rotation) !== null && _a !== void 0 ? _a : 1;
	    }
	    onBind() {
	        this._scaleX = this.target.attribute.scaleX;
	        if (!isValidNumber$1(this._rotations)) {
	            this.valid = false;
	        }
	    }
	    onUpdate(end, ratio, out) {
	        var _a;
	        if (this.valid === false) {
	            return;
	        }
	        if (end) {
	            out.scaleX = this._scaleX;
	            return;
	        }
	        const currentAngle = this._rotations * 360 * ratio;
	        const currentAngleInRadians = (currentAngle * Math.PI) / 180;
	        const scaleX = Math.abs(Math.cos(currentAngleInRadians)) * ((_a = this._scaleX) !== null && _a !== void 0 ? _a : 1);
	        this.target.attribute.scaleX = scaleX;
	        this.target.addUpdatePositionTag();
	        this.target.addUpdateShapeAndBoundsTag();
	    }
	}
	function imageCloudPresetAnimation(params, preset) {
	    switch (preset) {
	        case 'axialRotate':
	            return [
	                {
	                    custom: AxialRotateAnimation,
	                    customParameters: {
	                        rotation: 1
	                    },
	                    duration: vchart.DEFAULT_ANIMATION_CONFIG.appear.duration
	                },
	                {
	                    channel: {
	                        y: {
	                            from: (datum, element) => {
	                                return params.height() + element.getFinalAttribute().y;
	                            }
	                        },
	                        fillOpacity: {
	                            from: 0,
	                            to: 1
	                        }
	                    },
	                    easing: 'sineInOut'
	                }
	            ];
	        case 'growIn':
	            return {
	                channel: {
	                    scaleX: {
	                        from: 0,
	                        to: 1
	                    },
	                    scaleY: {
	                        from: 0,
	                        to: 1
	                    },
	                    x: { from: () => params.center().x },
	                    y: { from: () => params.center().y }
	                },
	                duration: vchart.DEFAULT_ANIMATION_CONFIG.appear.duration
	            };
	        case 'scaleIn':
	            return { type: 'scaleIn', duration: vchart.DEFAULT_ANIMATION_CONFIG.appear.duration };
	        case 'fadeIn':
	        default:
	            return { type: 'fadeIn', easing: 'linear', duration: vchart.DEFAULT_ANIMATION_CONFIG.appear.duration };
	    }
	}
	const registerImageCloudAnimation = () => {
	    vchart.Factory.registerAnimation('imageCloud', (params, preset) => ({
	        appear: imageCloudPresetAnimation(params, preset),
	        enter: imageCloudPresetAnimation(params, preset),
	        exit: { type: 'fadeOut' },
	        disappear: { type: 'fadeOut' }
	    }));
	};

	class ImageCloudTooltipHelper extends vchart.BaseSeriesTooltipHelper {
	    constructor() {
	        super(...arguments);
	        this.markTooltipKeyCallback = (datum) => {
	            var _a, _b;
	            return (_b = (_a = this.series) === null || _a === void 0 ? void 0 : _a.getMarkData(datum)) === null || _b === void 0 ? void 0 : _b[this.series.getDimensionField()[0]];
	        };
	        this.markTooltipValueCallback = (datum) => {
	            var _a, _b;
	            const { measureFields } = this._seriesCacheInfo;
	            const data = (_a = this.series) === null || _a === void 0 ? void 0 : _a.getMarkData(datum);
	            if (measureFields[0] && data) {
	                return (_b = data[measureFields[0]]) !== null && _b !== void 0 ? _b : datum.value;
	            }
	            return undefined;
	        };
	        this.dimensionTooltipTitleCallback = (datum) => {
	            var _a;
	            const { dimensionFields } = this._seriesCacheInfo;
	            const data = (_a = this.series) === null || _a === void 0 ? void 0 : _a.getMarkData(datum);
	            if (dimensionFields[0] && data) {
	                return data[dimensionFields[0]];
	            }
	            return undefined;
	        };
	    }
	    get defaultShapeType() {
	        return 'square';
	    }
	}

	class ImageCloudSeries extends vchart.BaseSeries {
	    constructor() {
	        super(...arguments);
	        this.type = IMAGE_CLOUD_SERIES_TYPE;
	    }
	    setValueField(field) {
	        if (isValid$1(field)) {
	            this._valueField = field;
	        }
	    }
	    setAttrFromSpec() {
	        super.setAttrFromSpec();
	        this._nameField = this._spec.nameField;
	        this._valueField = this._spec.valueField;
	        this._urlField = this._spec.urlField;
	    }
	    initMark() {
	        var _a;
	        if ((_a = this._spec.imageMask) === null || _a === void 0 ? void 0 : _a.visible) {
	            this._maskMark = this._createMark(imageCloudSeriesMark.imageMask, {
	                dataView: false,
	                skipBeforeLayouted: true
	            });
	        }
	        this._imageMark = this._createMark(imageCloudSeriesMark.image, {
	            key: datum => `${datum[vchart.DEFAULT_DATA_KEY]}-${datum.frequency}`,
	            isSeriesMark: true,
	            skipBeforeLayouted: true
	        });
	    }
	    initMarkStyle() {
	        this._initImageMarkStyle();
	        this._initMaskMarkStyle();
	    }
	    _initImageMarkStyle() {
	        var _a, _b;
	        if (!this._imageMark) {
	            return;
	        }
	        this._imageMark.setTransform([
	            Object.assign({ type: 'imagecloud' }, this._imageCloudTransformOption())
	        ]);
	        this.setMarkStyle(this._imageMark, {
	            x: (datum) => datum.x,
	            y: (datum) => datum.y,
	            width: (datum) => datum.width,
	            height: (datum) => datum.height,
	            visible: (datum) => datum.visible,
	            angle: (datum) => datum.angle,
	            clipConfig: (datum) => datum.clipConfig,
	            image: (datum) => datum[this._urlField],
	            scaleCenter: ['50%', '50%']
	        }, 'normal', vchart.AttributeLevel.Series);
	        const isMasked = ((_a = this._spec.layoutConfig) === null || _a === void 0 ? void 0 : _a.placement) === 'masked';
	        if (isMasked) {
	            this.setMarkStyle(this._imageMark, {
	                globalCompositeOperation: 'source-atop'
	            }, 'normal', vchart.AttributeLevel.Series);
	            this.setMarkStyle(this._rootMark, {
	                width: () => this._region.getLayoutRect().width,
	                height: () => this._region.getLayoutRect().height,
	                globalCompositeOperation: 'destination-in',
	                clip: true,
	                drawMode: 1
	            }, 'normal', vchart.AttributeLevel.Series);
	        }
	        if (((_b = this._spec.layoutConfig) === null || _b === void 0 ? void 0 : _b.layoutMode) === 'stack') {
	            this.setMarkStyle(this._imageMark, {
	                stroke: 'white',
	                lineWidth: 2,
	                shadowBlur: 6,
	                shadowColor: 'grey'
	            }, 'normal', vchart.AttributeLevel.Series);
	        }
	    }
	    isFillingImage(datum) {
	        return datum._frequency > 1;
	    }
	    _initMaskMarkStyle() {
	        if (!this._maskMark) {
	            return;
	        }
	        this._maskMark.setMarkConfig({ interactive: false });
	        this.setMarkStyle(this._maskMark, {
	            width: () => {
	                return this._region.getLayoutRect().width;
	            },
	            height: () => {
	                return this._region.getLayoutRect().height;
	            }
	        }, 'normal', vchart.AttributeLevel.Series);
	    }
	    initTooltip() {
	        this._tooltipHelper = new ImageCloudTooltipHelper(this);
	        this._imageMark && this._tooltipHelper.activeTriggerSet.mark.add(this._imageMark);
	    }
	    _imageCloudTransformOption() {
	        var _a;
	        return {
	            size: () => {
	                const { width, height } = this._region.getLayoutRect();
	                return [width, height];
	            },
	            image: { field: this._urlField },
	            weight: { field: this._valueField },
	            imageConfig: {
	                imageSize: this._spec.imageSize,
	                imageSizeRange: this._spec.imageSizeRange,
	                padding: (_a = this._spec.image) === null || _a === void 0 ? void 0 : _a.padding
	            },
	            ratio: this._spec.ratio,
	            mask: this._spec.maskShape,
	            maskConfig: this._spec.imageMask,
	            layoutConfig: this._spec.layoutConfig,
	            createCanvas: vchart.vglobal.createCanvas.bind(vchart.vglobal),
	            createImage,
	            onUpdateMaskCanvas: ((inputImage, maskImage) => {
	                var _a;
	                if (inputImage && this._maskMark) {
	                    this._maskMark
	                        .getProduct()
	                        .getChildren()
	                        .forEach((element) => {
	                        element.setAttribute('background', inputImage);
	                    });
	                }
	                if (maskImage && ((_a = this._spec.layoutConfig) === null || _a === void 0 ? void 0 : _a.placement) === 'masked') {
	                    this._rootMark.getProduct().setAttribute('background', maskImage);
	                }
	            }).bind(this),
	            onLayoutFinished: () => {
	                var _a, _b;
	                return (_b = (_a = this._option.globalInstance
	                    .getChart()
	                    .getOption()
	                    .performanceHook) === null || _a === void 0 ? void 0 : _a.afterWordcloudShapeDraw) === null || _b === void 0 ? void 0 : _b.call(_a, this._option.globalInstance);
	            }
	        };
	    }
	    _buildMarkAttributeContext() {
	        super._buildMarkAttributeContext();
	        this._markAttributeContext.isFillingImage = this.isFillingImage.bind(this);
	    }
	    initAnimation() {
	        [this._imageMark].forEach(mark => {
	            var _a, _b;
	            if (mark) {
	                const appearPreset = (_b = (_a = this._spec) === null || _a === void 0 ? void 0 : _a.animationAppear) === null || _b === void 0 ? void 0 : _b.preset;
	                const params = {
	                    center: () => {
	                        const { width, height } = this._region.getLayoutRect();
	                        return { x: width / 2, y: height / 2 };
	                    },
	                    height: () => {
	                        const { height } = this._region.getLayoutRect();
	                        return height;
	                    }
	                };
	                mark.setAnimationConfig(vchart.animationConfig(vchart.Factory.getAnimationInKey('imageCloud')(params, appearPreset), vchart.userAnimationConfig("image", this._spec, this._markAttributeContext)));
	            }
	        });
	    }
	    getDimensionField() {
	        var _a;
	        return [(_a = this._nameField) !== null && _a !== void 0 ? _a : this._spec.urlField];
	    }
	    getMeasureField() {
	        return [this._valueField];
	    }
	    getStatisticFields() {
	        const fields = [];
	        fields.push({ key: this._nameField, operations: ['values'] });
	        fields.push({ key: this._valueField, operations: ['max', 'min'] });
	        return fields;
	    }
	    getActiveMarks() {
	        return [this._imageMark];
	    }
	    getMarkData(datum) {
	        var _a;
	        return (_a = datum === null || datum === void 0 ? void 0 : datum.datum) !== null && _a !== void 0 ? _a : datum;
	    }
	    getGroupFields() {
	        return [];
	    }
	    dataToPosition(data) {
	        return null;
	    }
	    dataToPositionX(data) {
	        var _a;
	        return (_a = this.dataToPosition(data)) === null || _a === void 0 ? void 0 : _a.x;
	    }
	    dataToPositionY(data) {
	        var _a;
	        return (_a = this.dataToPosition(data)) === null || _a === void 0 ? void 0 : _a.y;
	    }
	    valueToPosition(value1, value2) {
	        return null;
	    }
	    getStackGroupFields() {
	        return [];
	    }
	    getStackValueField() {
	        return '';
	    }
	}
	ImageCloudSeries.type = IMAGE_CLOUD_SERIES_TYPE;
	ImageCloudSeries.mark = imageCloudSeriesMark;
	const registerImageCloudSeries = () => {
	    vchart.registerImageMark();
	    registerImageCloudAnimation();
	    vchart.Factory.registerSeries(ImageCloudSeries.type, ImageCloudSeries);
	    vchart.Factory.registerGrammarTransform('imagecloud', {
	        transform: transform
	    });
	};

	class ImageCloudChart extends vchart.BaseChart {
	    constructor() {
	        super(...arguments);
	        this.transformerConstructor = ImageCloudChart.transformerConstructor;
	        this.type = IMAGE_CLOUD_CHART_TYPE;
	        this.seriesType = IMAGE_CLOUD_SERIES_TYPE;
	    }
	}
	ImageCloudChart.type = IMAGE_CLOUD_CHART_TYPE;
	ImageCloudChart.seriesType = IMAGE_CLOUD_SERIES_TYPE;
	ImageCloudChart.transformerConstructor = ImageCloudChartSpecTransformer;
	const registerImageCloudChart = () => {
	    registerImageCloudSeries();
	    vchart.Factory.registerChart(ImageCloudChart.type, ImageCloudChart);
	};

	class CandlestickChartSpecTransformer extends vchart.CartesianChartSpecTransformer {
	    _getDefaultSeriesSpec(spec) {
	        const dataFields = [spec.openField, spec.highField, spec.lowField, spec.closeField];
	        const seriesSpec = super._getDefaultSeriesSpec(spec, [
	            'candlestick',
	            'openField',
	            'highField',
	            'lowField',
	            'closeField',
	            'rising',
	            'falling',
	            'doji'
	        ]);
	        seriesSpec.yField = dataFields;
	        return seriesSpec;
	    }
	    transformSpec(spec) {
	        super.transformSpec(spec);
	        if (!spec.axes) {
	            spec.axes = [
	                {
	                    orient: 'bottom'
	                },
	                {
	                    orient: 'left'
	                }
	            ];
	        }
	        vchart.setDefaultCrosshairForCartesianChart(spec);
	    }
	}

	const CANDLESTICK_MARK_TYPE = 'candlestick';
	class CandlestickMark extends vchart.GlyphMark {
	    constructor() {
	        super(...arguments);
	        this.type = CandlestickMark.type;
	    }
	    setGlyphConfig(cfg) {
	        super.setGlyphConfig(cfg);
	        this._subMarks = {
	            line: { type: 'line', defaultAttributes: { x: 0, y: 0 } },
	            box: { type: 'rect' }
	        };
	        this._positionChannels = ['x', 'boxWidth', 'open', 'close', 'high', 'low'];
	        this._channelEncoder = null;
	        this._positionEncoder = (glyphAttrs, datum, g) => {
	            const { x = g.attribute.x, boxWidth = g.attribute.boxWidth, open = g.attribute.open, close = g.attribute.close, low = g.attribute.low, high = g.attribute.high } = glyphAttrs;
	            const attributes = {};
	            attributes.line = {
	                points: [
	                    {
	                        x: x,
	                        y: low
	                    },
	                    {
	                        x: x,
	                        y: high
	                    }
	                ]
	            };
	            attributes.box = {
	                x: x - boxWidth / 2,
	                x1: x + boxWidth / 2,
	                y: Math.min(open, close),
	                y1: Math.max(open, close),
	                drawStrokeWhenZeroWH: true
	            };
	            return attributes;
	        };
	    }
	    _getDefaultStyle() {
	        const defaultStyle = Object.assign({}, super._getDefaultStyle());
	        return defaultStyle;
	    }
	}
	CandlestickMark.type = CANDLESTICK_MARK_TYPE;
	const registerCandlestickMark = () => {
	    vchart.registerGlyphMark();
	    registerLine();
	    registerRect();
	    vchart.Factory.registerGraphicComponent('line', (attrs) => createLine(attrs));
	    vchart.Factory.registerGraphicComponent('rect', (attrs) => createRect(attrs));
	    vchart.Factory.registerMark(CandlestickMark.type, CandlestickMark);
	};

	const scaleIn = () => {
	    return (graphic) => {
	        const finalAttribute = graphic.getFinalAttribute();
	        const { x, y, open, high, low, close } = finalAttribute;
	        const animateAttributes = { from: { x, y }, to: { x, y } };
	        if (isValidNumber$1(open) && isValidNumber$1(close)) {
	            if (open > close) {
	                animateAttributes.from.open = low;
	                animateAttributes.to.open = open;
	                animateAttributes.from.close = low;
	                animateAttributes.to.close = close;
	                if (isValidNumber$1(high)) {
	                    animateAttributes.from.high = low;
	                    animateAttributes.to.high = high;
	                }
	            }
	            else {
	                animateAttributes.from.open = high;
	                animateAttributes.to.open = open;
	                animateAttributes.from.close = high;
	                animateAttributes.to.close = close;
	                if (isValidNumber$1(low)) {
	                    animateAttributes.from.low = high;
	                    animateAttributes.to.low = low;
	                }
	            }
	        }
	        return animateAttributes;
	    };
	};
	const scaleOut = () => {
	    return (graphic) => {
	        const finalAttribute = graphic.getFinalAttribute();
	        const { x, y, open, high, low, close } = finalAttribute;
	        const animateAttributes = { from: { x, y }, to: { x, y } };
	        if (isValidNumber$1(open) && isValidNumber$1(close)) {
	            if (open > close) {
	                animateAttributes.from.open = open;
	                animateAttributes.to.open = low;
	                animateAttributes.from.close = close;
	                animateAttributes.to.close = low;
	                if (isValidNumber$1(high)) {
	                    animateAttributes.from.high = high;
	                    animateAttributes.to.high = low;
	                }
	            }
	            else {
	                animateAttributes.from.open = open;
	                animateAttributes.to.open = high;
	                animateAttributes.from.close = close;
	                animateAttributes.to.close = high;
	                if (isValidNumber$1(low)) {
	                    animateAttributes.from.low = low;
	                    animateAttributes.to.low = high;
	                }
	            }
	        }
	        return animateAttributes;
	    };
	};
	class CandlestickScaleIn extends ACustomAnimate {
	    constructor(from, to, duration, easing, params) {
	        super(from, to, duration, easing, params);
	    }
	    onBind() {
	        super.onBind();
	        const finalAttribute = this.target.getFinalAttribute();
	        if (finalAttribute) {
	            this.target.setAttributes(finalAttribute);
	        }
	        const { from, to } = this.computeAttribute();
	        this.propKeys = Object.keys(to).filter(key => to[key] != null);
	        this.animate.reSyncProps();
	        this.from = from;
	        this.to = to;
	        this.target.setAttributes(this.from);
	    }
	    computeAttribute() {
	        const attr = scaleIn()(this.target, this.params, this.params.options);
	        return attr;
	    }
	    onUpdate(end, ratio, out) {
	        const attribute = this.target.attribute;
	        this.propKeys.forEach(key => {
	            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
	        });
	        this.target.setAttributes(attribute);
	    }
	}
	class CandlestickScaleOut extends ACustomAnimate {
	    constructor(from, to, duration, easing, params) {
	        super(from, to, duration, easing, params);
	    }
	    onBind() {
	        var _a;
	        if ((_a = this.params) === null || _a === void 0 ? void 0 : _a.diffAttrs) {
	            this.target.setAttributes(this.params.diffAttrs);
	        }
	        const { from, to } = this.computeAttribute();
	        this.propKeys = Object.keys(to).filter(key => to[key] != null);
	        this.animate.reSyncProps();
	        this.from = from;
	        this.to = to;
	        this.target.setAttributes(this.from);
	    }
	    computeAttribute() {
	        const attr = scaleOut()(this.target, this.params, this.params.options);
	        return attr;
	    }
	    onUpdate(end, ratio, out) {
	        const attribute = this.target.attribute;
	        this.propKeys.forEach(key => {
	            attribute[key] = this.from[key] + (this.to[key] - this.from[key]) * ratio;
	        });
	        this.target.setAttributes(attribute);
	    }
	}
	const registerCandlestickScaleAnimation = () => {
	    AnimateExecutor.registerBuiltInAnimate('candlestickScaleIn', CandlestickScaleIn);
	    AnimateExecutor.registerBuiltInAnimate('candlestickScaleOut', CandlestickScaleOut);
	};

	const CANDLESTICK_CHART_TYPE = 'candlestick';
	const CANDLESTICK_SERIES_TYPE = 'candlestick';
	var CANDLESTICK_TOOLTIP_KEYS;
	(function (CANDLESTICK_TOOLTIP_KEYS) {
	    CANDLESTICK_TOOLTIP_KEYS["OPEN"] = "open";
	    CANDLESTICK_TOOLTIP_KEYS["HIGH"] = "high";
	    CANDLESTICK_TOOLTIP_KEYS["LOW"] = "low";
	    CANDLESTICK_TOOLTIP_KEYS["CLOSE"] = "close";
	    CANDLESTICK_TOOLTIP_KEYS["SERIES_FIELD"] = "seriesField";
	})(CANDLESTICK_TOOLTIP_KEYS || (CANDLESTICK_TOOLTIP_KEYS = {}));
	var CandlestickMarkNameEnum;
	(function (CandlestickMarkNameEnum) {
	    CandlestickMarkNameEnum["candlestick"] = "candlestick";
	})(CandlestickMarkNameEnum || (CandlestickMarkNameEnum = {}));
	const CandlestickSeriesMark = Object.assign(Object.assign({}, vchart.baseSeriesMark), { ["candlestick"]: { name: "candlestick", type: 'candlestick' } });

	class CandlestickSeriesTooltipHelper extends vchart.BaseSeriesTooltipHelper {
	    constructor() {
	        super(...arguments);
	        this.getContentKey = (contentType) => (datum) => {
	            switch (contentType) {
	                case CANDLESTICK_TOOLTIP_KEYS.OPEN: {
	                    const openField = this.series.getOpenField();
	                    return openField;
	                }
	                case CANDLESTICK_TOOLTIP_KEYS.HIGH: {
	                    const highField = this.series.getHighField();
	                    return highField;
	                }
	                case CANDLESTICK_TOOLTIP_KEYS.LOW: {
	                    const lowField = this.series.getLowField();
	                    return lowField;
	                }
	                case CANDLESTICK_TOOLTIP_KEYS.CLOSE: {
	                    const closeField = this.series.getCloseField();
	                    return closeField;
	                }
	                case CANDLESTICK_TOOLTIP_KEYS.SERIES_FIELD: {
	                    const seriesField = this.series.getSeriesField();
	                    return seriesField;
	                }
	            }
	            return null;
	        };
	        this.getContentValue = (contentType) => (datum) => {
	            switch (contentType) {
	                case CANDLESTICK_TOOLTIP_KEYS.OPEN: {
	                    const openField = this.series.getOpenField();
	                    return datum[openField];
	                }
	                case CANDLESTICK_TOOLTIP_KEYS.HIGH: {
	                    const highField = this.series.getHighField();
	                    return datum[highField];
	                }
	                case CANDLESTICK_TOOLTIP_KEYS.LOW: {
	                    const lowField = this.series.getLowField();
	                    return datum[lowField];
	                }
	                case CANDLESTICK_TOOLTIP_KEYS.CLOSE: {
	                    const closeField = this.series.getCloseField();
	                    return datum[closeField];
	                }
	                case CANDLESTICK_TOOLTIP_KEYS.SERIES_FIELD: {
	                    const seriesField = this.series.getSeriesField();
	                    return datum[seriesField];
	                }
	            }
	            return null;
	        };
	        this.shapeColorCallback = (datum) => {
	            return this.series.getMarkInName('candlestick').getAttribute('stroke', datum);
	        };
	    }
	    getDefaultContentList(activeType) {
	        return [
	            {
	                key: this.getContentKey(CANDLESTICK_TOOLTIP_KEYS.OPEN),
	                value: this.getContentValue(CANDLESTICK_TOOLTIP_KEYS.OPEN)
	            },
	            {
	                key: this.getContentKey(CANDLESTICK_TOOLTIP_KEYS.HIGH),
	                value: this.getContentValue(CANDLESTICK_TOOLTIP_KEYS.HIGH)
	            },
	            {
	                key: this.getContentKey(CANDLESTICK_TOOLTIP_KEYS.LOW),
	                value: this.getContentValue(CANDLESTICK_TOOLTIP_KEYS.LOW)
	            },
	            {
	                key: this.getContentKey(CANDLESTICK_TOOLTIP_KEYS.CLOSE),
	                value: this.getContentValue(CANDLESTICK_TOOLTIP_KEYS.CLOSE)
	            },
	            {
	                key: this.getContentKey(CANDLESTICK_TOOLTIP_KEYS.SERIES_FIELD),
	                value: this.getContentValue(CANDLESTICK_TOOLTIP_KEYS.SERIES_FIELD)
	            }
	        ];
	    }
	}

	const getCandlestickTheme = () => {
	    const res = {
	        rising: {
	            style: {
	                boxFill: '#FF0000',
	                stroke: '#FF0000'
	            }
	        },
	        falling: {
	            style: {
	                boxFill: '#00AA00',
	                stroke: '#00AA00'
	            }
	        },
	        doji: {
	            style: {
	                boxFill: '#000000',
	                stroke: '#000000'
	            }
	        },
	        candlestick: {
	            style: {
	                lineWidth: 1
	            }
	        }
	    };
	    return res;
	};
	const candlestick = getCandlestickTheme();

	class CandlestickSeries extends vchart.CartesianSeries {
	    constructor() {
	        super(...arguments);
	        this.type = CANDLESTICK_SERIES_TYPE;
	        this._mergedStyles = {
	            rising: {},
	            falling: {},
	            doji: {}
	        };
	    }
	    getOpenField() {
	        return this._openField;
	    }
	    getHighField() {
	        return this._highField;
	    }
	    getLowField() {
	        return this._lowField;
	    }
	    getCloseField() {
	        return this._closeField;
	    }
	    getBoxFill() {
	        return this._boxFill;
	    }
	    getStrokeColor() {
	        return this._strokeColor;
	    }
	    setAttrFromSpec() {
	        var _a, _b, _c, _d, _e, _f, _g, _h;
	        super.setAttrFromSpec();
	        const spec = this._spec;
	        const CandlestickStyle = (_b = (_a = spec.candlestick) === null || _a === void 0 ? void 0 : _a.style) !== null && _b !== void 0 ? _b : {};
	        this._openField = spec.openField;
	        this._highField = spec.highField;
	        this._lowField = spec.lowField;
	        this._closeField = spec.closeField;
	        this._boxWidth = CandlestickStyle.boxWidth;
	        this._boxFill = CandlestickStyle.boxFill;
	        this._strokeColor = CandlestickStyle.strokeColor;
	        this._buildMergedStyles(CandlestickStyle, (_d = (_c = spec.rising) === null || _c === void 0 ? void 0 : _c.style) !== null && _d !== void 0 ? _d : {}, (_f = (_e = spec.falling) === null || _e === void 0 ? void 0 : _e.style) !== null && _f !== void 0 ? _f : {}, (_h = (_g = spec.doji) === null || _g === void 0 ? void 0 : _g.style) !== null && _h !== void 0 ? _h : {});
	    }
	    initMark() {
	        this._candlestickMark = this._createMark(CandlestickSeries.mark.candlestick, {
	            groupKey: this._seriesField,
	            isSeriesMark: true
	        });
	    }
	    initMarkStyle() {
	        var _a;
	        const candlestickMark = this._candlestickMark;
	        if (candlestickMark) {
	            const CandlestickStyles = {
	                fill: (datum) => {
	                    const boxFill = this.mergeStyle(datum).boxFill;
	                    return boxFill;
	                },
	                stroke: (datum) => {
	                    const strokeColor = this.mergeStyle(datum).stroke;
	                    return strokeColor;
	                },
	                lineWidth: (datum) => {
	                    const lineWidth = this.mergeStyle(datum).lineWidth;
	                    return lineWidth;
	                },
	                boxWidth: (_a = this._boxWidth) !== null && _a !== void 0 ? _a : this._getMarkWidth.bind(this),
	                x: this.dataToPositionX.bind(this)
	            };
	            candlestickMark.setGlyphConfig({});
	            this.setMarkStyle(candlestickMark, CandlestickStyles, vchart.STATE_VALUE_ENUM.STATE_NORMAL, vchart.AttributeLevel.Series);
	        }
	    }
	    initCandlestickMarkStyle() {
	        var _a;
	        const candlestickMark = this._candlestickMark;
	        const axisHelper = this._yAxisHelper;
	        if (candlestickMark && axisHelper) {
	            const { dataToPosition } = axisHelper;
	            const scale = (_a = axisHelper === null || axisHelper === void 0 ? void 0 : axisHelper.getScale) === null || _a === void 0 ? void 0 : _a.call(axisHelper, 0);
	            this.setMarkStyle(candlestickMark, {
	                open: (datum) => vchart.valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._openField), {
	                    bandPosition: this._bandPosition
	                }), scale),
	                high: (datum) => vchart.valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._highField), {
	                    bandPosition: this._bandPosition
	                }), scale),
	                low: (datum) => vchart.valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._lowField), {
	                    bandPosition: this._bandPosition
	                }), scale),
	                close: (datum) => vchart.valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._closeField), {
	                    bandPosition: this._bandPosition
	                }), scale)
	            }, vchart.STATE_VALUE_ENUM.STATE_NORMAL, vchart.AttributeLevel.Series);
	        }
	    }
	    init(option) {
	        super.init(option);
	        this.initCandlestickMarkStyle();
	    }
	    _initAnimationSpec(config = {}) {
	        const newConfig = merge({}, config);
	        ['appear', 'enter', 'update', 'exit', 'disappear'].forEach(state => {
	            if (newConfig[state] && newConfig[state].type === 'scaleIn') {
	                newConfig[state].type = 'candlestickScaleIn';
	            }
	            else if (newConfig[state] && newConfig[state].type === 'scaleOut') {
	                newConfig[state].type = 'candlestickScaleOut';
	            }
	        });
	        return newConfig;
	    }
	    initAnimation() {
	        var _a;
	        const animationParams = vchart.getGroupAnimationParams(this);
	        if (this._candlestickMark) {
	            const newDefaultConfig = this._initAnimationSpec((_a = vchart.Factory.getAnimationInKey('scaleInOut')) === null || _a === void 0 ? void 0 : _a());
	            const newConfig = this._initAnimationSpec(vchart.userAnimationConfig(CANDLESTICK_SERIES_TYPE, this._spec, this._markAttributeContext));
	            this._candlestickMark.setAnimationConfig(vchart.animationConfig(newDefaultConfig, newConfig, animationParams));
	        }
	    }
	    initTooltip() {
	        this._tooltipHelper = new CandlestickSeriesTooltipHelper(this);
	        this._candlestickMark && this._tooltipHelper.activeTriggerSet.mark.add(this._candlestickMark);
	    }
	    _buildMergedStyles(baseStyle, risingStyle, fallingStyle, dojiStyle) {
	        this._mergedStyles.rising = merge({}, baseStyle, risingStyle);
	        this._mergedStyles.falling = merge({}, baseStyle, fallingStyle);
	        this._mergedStyles.doji = merge({}, baseStyle, dojiStyle);
	    }
	    mergeStyle(datum) {
	        const open = this.getDatumPositionValues(datum, this._openField)[0];
	        const close = this.getDatumPositionValues(datum, this._closeField)[0];
	        if (open < close) {
	            return this._mergedStyles.rising;
	        }
	        else if (open > close) {
	            return this._mergedStyles.falling;
	        }
	        else {
	            return this._mergedStyles.doji;
	        }
	    }
	    _getMarkWidth() {
	        if (this._autoBoxWidth) {
	            return this._autoBoxWidth;
	        }
	        const bandAxisHelper = this._xAxisHelper;
	        const xField = this._fieldX;
	        const innerBandWidth = bandAxisHelper.getBandwidth(xField.length - 1);
	        const autoBoxWidth = innerBandWidth / xField.length;
	        this._autoBoxWidth = autoBoxWidth;
	        return this._autoBoxWidth;
	    }
	    onLayoutEnd() {
	        super.onLayoutEnd();
	        this._autoBoxWidth = null;
	    }
	    getActiveMarks() {
	        return [this._candlestickMark];
	    }
	}
	CandlestickSeries.type = CANDLESTICK_SERIES_TYPE;
	CandlestickSeries.builtInTheme = { candlestick };
	CandlestickSeries.mark = CandlestickSeriesMark;
	const registerCandlestickSeries = () => {
	    registerCandlestickMark();
	    vchart.registerSymbolMark();
	    vchart.registerScaleInOutAnimation();
	    vchart.registerCartesianBandAxis();
	    vchart.registerCartesianLinearAxis();
	    registerCandlestickScaleAnimation();
	    vchart.Factory.registerSeries(CandlestickSeries.type, CandlestickSeries);
	};

	class CandlestickChart extends vchart.BaseChart {
	    _setModelOption() {
	        this._modelOption.getDimensionInfo = vchart.getCartesianDimensionInfo;
	        this._modelOption.getDimensionInfoByValue = vchart.getDimensionInfoByValue;
	        this._modelOption.getRectByDimensionData = vchart.getCartesianCrosshairRect;
	    }
	}
	CandlestickChart.type = CANDLESTICK_CHART_TYPE;
	CandlestickChart.seriesType = CANDLESTICK_SERIES_TYPE;
	CandlestickChart.transformerConstructor = CandlestickChartSpecTransformer;
	const registerCandlestickChart = () => {
	    vchart.registerDimensionTooltipProcessor();
	    vchart.registerMarkTooltipProcessor();
	    vchart.registerDimensionEvents();
	    vchart.registerDimensionHover();
	    registerCandlestickSeries();
	    vchart.Factory.registerChart(CandlestickChart.type, CandlestickChart);
	};

	const GROUP_ATTRIBUTES = ["x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "visible", "clip", "pickable", "childrenPickable", "zIndex", "cursor"];
	class AbstractComponent extends Group {
	  constructor(attributes, options) {
	    super(attributes), this._skipRenderAttributes = GROUP_ATTRIBUTES, (null == options ? void 0 : options.mode) && (this.mode = options.mode, this.setMode(options.mode)), (null == options ? void 0 : options.skipDefault) && (this.skipDefault = !0), this.setTheme({
	      common: {
	        strokeBoundsBuffer: 0
	      }
	    }), this.attribute = attributes, this.onSetStage(() => {
	      this.render(), this.bindEvents();
	    });
	  }
	  setAttribute(key, value, forceUpdateTag, context) {
	    const params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
	      [key]: value
	    }, this.attribute, key, context);
	    if (params) return this._setAttributes(params, forceUpdateTag);
	    isPlainObject$1(this.attribute[key]) && isPlainObject$1(value) && !isFunction$1(this.attribute[key]) && !isFunction$1(value) ? merge(this.attribute[key], value) : this.attribute[key] = value, this._skipRenderAttributes.includes(key) || this.render(), this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.onAttributeUpdate();
	  }
	  setAttributes(params, forceUpdateTag, context) {
	    return params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params, this._setAttributes(params, forceUpdateTag);
	  }
	  _setAttributes(params, forceUpdateTag) {
	    const keys = Object.keys(params);
	    this._mergeAttributes(params, keys), keys.every(key => this._skipRenderAttributes.includes(key)) || this.render(), this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.onAttributeUpdate();
	  }
	  _mergeAttributes(params, keys) {
	    isNil$1(keys) && (keys = Object.keys(params));
	    for (let i = 0; i < keys.length; i++) {
	      const key = keys[i];
	      !isPlainObject$1(this.attribute[key]) || isFunction$1(this.attribute[key]) || isFunction$1(params[key]) ? this.attribute[key] = params[key] : merge(this.attribute[key], params[key]);
	    }
	  }
	  bindEvents() {}
	  _getNodeId(id) {
	    var _a;
	    return `${null !== (_a = this.id) && void 0 !== _a ? _a : this._uid}-${this.name}-${id}`;
	  }
	  _dispatchEvent(eventName, details) {
	    var _a;
	    const changeEvent = new CustomEvent(eventName, details);
	    changeEvent.manager = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem.manager, this.dispatchEvent(changeEvent);
	  }
	  eventPosToStagePos(e) {
	    var _a, _b;
	    const result = {
	        x: 0,
	        y: 0
	      },
	      stagePoints = null !== (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventPointTransform(e)) && void 0 !== _b ? _b : {
	        x: 0,
	        y: 0
	      };
	    return this.globalTransMatrix.transformPoint(stagePoints, result), result;
	  }
	}

	const DEFAULT_TEXT_FONT_FAMILY = "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol";
	var StateValue;
	!function (StateValue) {
	  StateValue.selected = "selected", StateValue.selectedReverse = "selected_reverse", StateValue.hover = "hover", StateValue.hoverReverse = "hover_reverse";
	}(StateValue || (StateValue = {}));
	const DEFAULT_STATES = {
	  [StateValue.selectedReverse]: {},
	  [StateValue.selected]: {},
	  [StateValue.hover]: {},
	  [StateValue.hoverReverse]: {}
	};

	function traverseGroup(group, cb) {
	  group.forEachChildren(node => {
	    const stopped = cb(node);
	    node.isContainer && !stopped && traverseGroup(node, cb);
	  });
	}
	function removeRepeatPoint(points) {
	  const result = [points[0]];
	  for (let i = 1; i < points.length; i++) points[i].x === points[i - 1].x && points[i].y === points[i - 1].y || result.push(points[i]);
	  return result;
	}
	function isPostiveXAxis(angle) {
	  return angle >= 0 && angle < Math.PI / 2 || angle > 3 * Math.PI / 2 && angle <= 2 * Math.PI;
	}
	function fuzzyEqualNumber(a, b, delta) {
	  return Math.abs(a - b) < delta;
	}
	function getTextAlignAttrOfVerticalDir(autoRotate, lineEndAngle, itemPosition) {
	  return autoRotate ? {
	    textAlign: "right",
	    textBaseline: "middle"
	  } : {
	    textAlign: lineEndAngle < Math.PI && itemPosition.toLocaleLowerCase().includes("top") || lineEndAngle > Math.PI && itemPosition.toLocaleLowerCase().includes("bottom") ? "left" : lineEndAngle < Math.PI && itemPosition.toLocaleLowerCase().includes("bottom") || lineEndAngle > Math.PI && itemPosition.toLocaleLowerCase().includes("top") ? "right" : "center",
	    textBaseline: lineEndAngle < Math.PI && itemPosition.includes("inside") || lineEndAngle > Math.PI && !itemPosition.includes("inside") ? "bottom" : "top"
	  };
	}

	function measureTextSize(text, textSpec, defaultTextTheme = {}) {
	  if (!text) return {
	    width: 0,
	    height: 0
	  };
	  const bounds = getTextBounds({
	    text: text,
	    fontFamily: textSpec.fontFamily || defaultTextTheme.fontFamily || DEFAULT_TEXT_FONT_FAMILY,
	    fontSize: textSpec.fontSize || defaultTextTheme.fontSize || 12,
	    fontWeight: textSpec.fontWeight || defaultTextTheme.fontWeight,
	    textAlign: textSpec.textAlign || "center",
	    textBaseline: textSpec.textBaseline,
	    ellipsis: !!textSpec.ellipsis,
	    maxLineWidth: textSpec.maxLineWidth || 1 / 0,
	    lineHeight: textSpec.fontSize || defaultTextTheme.fontSize || 12
	  });
	  return {
	    width: bounds.width(),
	    height: bounds.height()
	  };
	}
	function isRichText(attributes, typeKey = "type") {
	  return "rich" === getTextType(attributes, typeKey);
	}
	function getTextType(attributes, typeKey = "type") {
	  var _a, _b;
	  return isObject$1(attributes.text) && "type" in attributes.text ? null !== (_a = attributes.text.type) && void 0 !== _a ? _a : "text" : typeKey in attributes && null !== (_b = attributes[typeKey]) && void 0 !== _b ? _b : "text";
	}
	function richTextAttributeTransform(attributes) {
	  var _a, _b;
	  return isValid$1(attributes.maxLineWidth) && (attributes.maxWidth = attributes.maxLineWidth, delete attributes.maxLineWidth), attributes.width = null !== (_a = attributes.width) && void 0 !== _a ? _a : 0, attributes.height = null !== (_b = attributes.height) && void 0 !== _b ? _b : 0, attributes.textConfig = attributes.text.text || attributes.text, attributes;
	}

	const deltaXYToAngle = (y, x) => {
	  const angle = Math.atan2(y, x);
	  return angle < 0 ? angle + 2 * Math.PI : angle;
	};

	function computeOffsetForlimit(shape, bounds) {
	  const {
	      x1: regionMinX,
	      y1: regionMinY,
	      x2: regionMaxX,
	      y2: regionMaxY
	    } = bounds,
	    {
	      x1: x1,
	      y1: y1,
	      x2: x2,
	      y2: y2
	    } = shape.AABBBounds;
	  let dx = 0,
	    dy = 0;
	  return x1 < regionMinX && (dx = regionMinX - x1), y1 < regionMinY && (dy = regionMinY - y1), x2 > regionMaxX && (dx = regionMaxX - x2), y2 > regionMaxY && (dy = regionMaxY - y2), {
	    dx: dx,
	    dy: dy
	  };
	}

	function loadTagComponent() {
	  registerGroup(), registerRect(), registerSymbol(), registerRichtext(), registerText();
	}

	var __rest = undefined && undefined.__rest || function (s, e) {
	  var t = {};
	  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
	  if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
	    var i = 0;
	    for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
	  }
	  return t;
	};
	loadTagComponent();
	class Tag extends AbstractComponent {
	  getBgRect() {
	    return this._bgRect;
	  }
	  getTextShape() {
	    return this._textShape;
	  }
	  constructor(attributes, options) {
	    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, Tag.defaultAttributes, attributes)), this.name = "tag", this._tagStates = [], this._rectStates = [], this._symbolStates = [], this._textStates = [];
	  }
	  render() {
	    var _a, _b, _c;
	    this.cacheStates();
	    const {
	        text = "",
	        textStyle = {},
	        shape = {},
	        panel = {},
	        space = 4,
	        minWidth: minWidth,
	        maxWidth: maxWidth,
	        padding = 4,
	        visible: visible,
	        state: state,
	        type: type,
	        textAlwaysCenter: textAlwaysCenter,
	        containerTextAlign: containerTextAlign
	      } = this.attribute,
	      parsedPadding = normalizePadding(padding),
	      group = this.createOrUpdateChild("tag-content", {
	        x: 0,
	        y: 0,
	        zIndex: 1
	      }, "group");
	    let symbol,
	      tagX = -parsedPadding[3],
	      tagY = -parsedPadding[0],
	      tagWidth = parsedPadding[1] + parsedPadding[3],
	      tagHeight = parsedPadding[0] + parsedPadding[2],
	      textX = 0,
	      symbolPlaceWidth = 0;
	    const {
	        visible: shapeVisible
	      } = shape,
	      shapeStyle = __rest(shape, ["visible"]);
	    if (isBoolean$1(shapeVisible)) {
	      const size = (null == shapeStyle ? void 0 : shapeStyle.size) || 10,
	        maxSize = isNumber$1(size) ? size : Math.max(size[0], size[1]);
	      symbol = group.createOrUpdateChild("tag-shape", Object.assign(Object.assign({
	        symbolType: "circle",
	        size: size,
	        strokeBoundsBuffer: 0
	      }, shapeStyle), {
	        visible: shapeVisible,
	        x: maxSize / 2,
	        y: maxSize / 2
	      }), "symbol"), isEmpty(null == state ? void 0 : state.shape) || (symbol.states = state.shape), shapeVisible && (symbolPlaceWidth = maxSize + space);
	    }
	    let textShape, textWidth, textHeight;
	    tagWidth += symbolPlaceWidth, textX += symbolPlaceWidth;
	    if (isRichText({
	      text: text
	    }) || "rich" === type) {
	      const richTextAttrs = Object.assign(Object.assign(Object.assign({}, richTextAttributeTransform(Object.assign({
	        type: type,
	        text: text
	      }, textStyle))), textStyle), {
	        visible: isValid$1(text) && !1 !== visible,
	        x: textX,
	        y: 0
	      });
	      isNil$1(richTextAttrs.lineHeight) && (richTextAttrs.lineHeight = textStyle.fontSize), textShape = group.createOrUpdateChild("tag-text", richTextAttrs, "richtext"), textWidth = textShape.AABBBounds.width(), textHeight = textShape.AABBBounds.height();
	    } else {
	      const textAttrs = Object.assign(Object.assign({
	        text: isObject$1(text) && "type" in text && "text" === text.type ? text.text : text,
	        visible: isValid$1(text) && !1 !== visible,
	        lineHeight: null == textStyle ? void 0 : textStyle.fontSize
	      }, textStyle), {
	        x: textX,
	        y: 0
	      });
	      isNil$1(textAttrs.lineHeight) && (textAttrs.lineHeight = textStyle.fontSize), textShape = group.createOrUpdateChild("tag-text", textAttrs, "text");
	      const textBounds = measureTextSize(textAttrs.text, textStyle, null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.getTheme()) || void 0 === _b ? void 0 : _b.text);
	      textWidth = textBounds.width, textHeight = textBounds.height;
	    }
	    tagWidth += textWidth;
	    const size = null !== (_c = shape.size) && void 0 !== _c ? _c : 10,
	      maxSize = isNumber$1(size) ? size : Math.max(size[0], size[1]);
	    tagHeight += Math.max(textHeight, shape.visible ? maxSize : 0);
	    const {
	      textAlign: textAlign,
	      textBaseline: textBaseline
	    } = textStyle;
	    (isValid$1(minWidth) || isValid$1(maxWidth)) && (isValid$1(minWidth) && tagWidth < minWidth && (tagWidth = minWidth), isValid$1(maxWidth) && tagWidth > maxWidth && (tagWidth = maxWidth, textShape.setAttribute("maxLineWidth", maxWidth - parsedPadding[1] - parsedPadding[2]))), tagX = 0, tagY = 0;
	    let flag = 0;
	    "left" === textAlign || "start" === textAlign ? flag = 1 : "right" === textAlign || "end" === textAlign ? flag = -1 : "center" === textAlign && (flag = 0), flag ? flag < 0 ? (tagX -= tagWidth, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth), group.setAttribute("x", -parsedPadding[1] - symbolPlaceWidth)) : flag > 0 && group.setAttribute("x", parsedPadding[3]) : (tagX -= tagWidth / 2, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth / 2), group.setAttribute("x", -symbolPlaceWidth / 2));
	    const shouldRight = "right" === containerTextAlign || "end" === containerTextAlign,
	      shouldLeft = "left" === containerTextAlign || "start" === containerTextAlign,
	      updateTextAttrs = (textX, textAlign) => {
	        "richtext" === textShape.type ? textShape.setAttributes({
	          x: textX,
	          textAlign: textAlign,
	          textConfig: array(textShape.attribute.textConfig).map(t => Object.assign(Object.assign({}, t), {
	            textAlign: textAlign
	          }))
	        }) : textShape.setAttributes({
	          x: textX,
	          textAlign: textAlign
	        });
	      };
	    if ((containerTextAlign ? "center" === containerTextAlign : textAlwaysCenter) && flag) {
	      const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3],
	        tsWidth = textWidth + symbolPlaceWidth,
	        textX = 1 === flag ? (containerWidth - tsWidth) / 2 + symbolPlaceWidth + textWidth / 2 : parsedPadding[0] + symbolPlaceWidth - (tagWidth / 2 + tsWidth / 2 - symbolPlaceWidth) + textWidth / 2;
	      if (updateTextAttrs(textX, "center"), symbol) {
	        const symbolX = textX - textWidth / 2 - symbolPlaceWidth + maxSize / 2;
	        symbol.setAttributes({
	          x: symbolX
	        });
	      }
	    }
	    if (shouldLeft && 1 !== flag) {
	      const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3],
	        offset = 0 === flag ? -containerWidth / 2 + symbolPlaceWidth / 2 : -tagWidth + parsedPadding[3] + parsedPadding[1] + symbolPlaceWidth;
	      if (updateTextAttrs(offset + symbolPlaceWidth, "left"), symbol) {
	        const symbolX = offset + maxSize / 2;
	        symbol.setAttributes({
	          x: symbolX
	        });
	      }
	    }
	    if (shouldRight && -1 !== flag) {
	      const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3],
	        textX = 0 === flag ? containerWidth / 2 + symbolPlaceWidth / 2 : containerWidth;
	      if (updateTextAttrs(textX, "right"), symbol) {
	        const symbolX = textX - textWidth - symbolPlaceWidth + maxSize / 2;
	        symbol.setAttributes({
	          x: symbolX
	        });
	      }
	    }
	    "middle" === textBaseline ? (tagY -= tagHeight / 2, symbol && symbol.setAttribute("y", 0)) : "bottom" === textBaseline ? (tagY -= tagHeight, symbol && symbol.setAttribute("y", -textHeight / 2), group.setAttribute("y", -parsedPadding[2])) : "top" === textBaseline && (group.setAttribute("y", parsedPadding[0]), symbol && symbol.setAttribute("y", textHeight / 2)), isEmpty(null == state ? void 0 : state.text) || (textShape.states = state.text);
	    const {
	        visible: bgVisible
	      } = panel,
	      backgroundStyle = __rest(panel, ["visible"]);
	    if (visible && isBoolean$1(bgVisible)) {
	      const bgRect = this.createOrUpdateChild("tag-panel", Object.assign(Object.assign({}, backgroundStyle), {
	        visible: bgVisible && !!text,
	        width: tagWidth,
	        height: tagHeight,
	        x: tagX,
	        y: tagY
	      }), "rect");
	      if (isEmpty(null == state ? void 0 : state.panel) || (bgRect.states = state.panel), backgroundStyle.customShape) {
	        const customShape = backgroundStyle.customShape;
	        bgRect.pathProxy = attrs => customShape(this, attrs, new CustomPath2D());
	      }
	      this._bgRect = bgRect;
	    }
	    this._textShape = textShape, this._symbol = symbol, this.resetStates();
	  }
	  initAttributes(params, options) {
	    params = (null == options ? void 0 : options.skipDefault) ? params : merge({}, Tag.defaultAttributes, params), super.initAttributes(params), this.render();
	  }
	  addState(stateName, keepCurrentStates, hasAnimation) {
	    super.addState(stateName, keepCurrentStates, hasAnimation), this._textShape && this._textShape.addState(stateName, keepCurrentStates, hasAnimation), this._bgRect && this._bgRect.addState(stateName, keepCurrentStates, hasAnimation), this._symbol && this._symbol.addState(stateName, keepCurrentStates, hasAnimation);
	  }
	  removeState(stateName, hasAnimation) {
	    super.removeState(stateName, hasAnimation), this._textShape && this._textShape.removeState(stateName, hasAnimation), this._bgRect && this._bgRect.removeState(stateName, hasAnimation), this._symbol && this._symbol.removeState(stateName, hasAnimation);
	  }
	  cacheStates() {
	    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
	    this._tagStates = null !== (_b = null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.slice()) && void 0 !== _b ? _b : [], this._rectStates = null !== (_e = null === (_d = null === (_c = this._bgRect) || void 0 === _c ? void 0 : _c.currentStates) || void 0 === _d ? void 0 : _d.slice()) && void 0 !== _e ? _e : [], this._symbolStates = null !== (_h = null === (_g = null === (_f = this._symbol) || void 0 === _f ? void 0 : _f.currentStates) || void 0 === _g ? void 0 : _g.slice()) && void 0 !== _h ? _h : [], this._textStates = null !== (_l = null === (_k = null === (_j = this._textShape) || void 0 === _j ? void 0 : _j.currentStates) || void 0 === _k ? void 0 : _k.slice()) && void 0 !== _l ? _l : [], this.clearStates(), null === (_m = this._bgRect) || void 0 === _m || _m.clearStates(), null === (_o = this._symbol) || void 0 === _o || _o.clearStates(), null === (_p = this._textShape) || void 0 === _p || _p.clearStates();
	  }
	  resetStates() {
	    var _a, _b, _c;
	    this._tagStates.length && this.useStates(this._tagStates), this._rectStates.length && (null === (_a = this._bgRect) || void 0 === _a || _a.useStates(this._rectStates)), this._symbolStates.length && (null === (_b = this._symbol) || void 0 === _b || _b.useStates(this._symbolStates)), this._textStates.length && (null === (_c = this._textShape) || void 0 === _c || _c.useStates(this._textStates));
	  }
	}
	Tag.defaultAttributes = {
	  visible: !0,
	  textStyle: {
	    fontSize: 12,
	    fill: "#000",
	    textAlign: "left",
	    textBaseline: "top"
	  },
	  space: 4,
	  padding: 4,
	  shape: {
	    fill: "#000"
	  }
	};

	function loadSegmentComponent() {
	  registerGroup(), registerLine(), registerPolygon(), registerSymbol();
	}
	function loadArcSegmentComponent() {
	  registerGroup(), registerLine(), registerArc(), registerSymbol();
	}

	loadSegmentComponent();
	class Segment extends AbstractComponent {
	  getStartAngle() {
	    return normalizeAngle(this._startAngle);
	  }
	  getEndAngle() {
	    return normalizeAngle(this._endAngle);
	  }
	  getMainSegmentPoints() {
	    return this._mainSegmentPoints;
	  }
	  constructor(attributes, options) {
	    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, Segment.defaultAttributes, attributes)), this.name = "segment", this.key = "segment", this.lines = [];
	  }
	  render() {
	    this.removeAllChild(!0), this._reset();
	    const {
	      startSymbol: startSymbol,
	      endSymbol: endSymbol,
	      lineStyle: lineStyle,
	      state: state,
	      visible = !0,
	      multiSegment: multiSegment,
	      mainSegmentIndex: mainSegmentIndex
	    } = this.attribute;
	    if (!visible) return;
	    this._computeLineAngle();
	    const points = this._getMainSegmentPoints(),
	      startSymbolShape = this._renderSymbol(startSymbol, points, "start"),
	      endSymbolShape = this._renderSymbol(endSymbol, points, "end");
	    if (this.startSymbol = startSymbolShape, this.endSymbol = endSymbolShape, multiSegment) {
	      const points = [...this.attribute.points];
	      if (isValidNumber$1(mainSegmentIndex)) points[mainSegmentIndex] = this._clipPoints(points[mainSegmentIndex]);else {
	        const clipPoints = this._clipPoints(flattenArray(points));
	        points[0][0] = clipPoints[0], points[points.length - 1][points[points.length - 1].length - 1] = clipPoints[clipPoints.length - 1];
	      }
	      points.forEach((point, index) => {
	        var _a, _b;
	        const line = graphicCreator.line(Object.assign(Object.assign({
	          points: point
	        }, isArray$1(lineStyle) ? null !== (_a = lineStyle[index]) && void 0 !== _a ? _a : lineStyle[lineStyle.length - 1] : lineStyle), {
	          fill: !1
	        }));
	        line.name = `${this.name}-line`, line.id = this._getNodeId("line" + index), isEmpty(null == state ? void 0 : state.line) || (line.states = isArray$1(state.line) ? null !== (_b = state.line[index]) && void 0 !== _b ? _b : state.line[state.line.length - 1] : state.line), this.add(line), this.lines.push(line);
	      });
	    } else {
	      let lineCreator = graphicCreator.line;
	      array(lineStyle)[0].cornerRadius && (lineCreator = graphicCreator.polygon);
	      const line = lineCreator(Object.assign(Object.assign({
	        points: this._clipPoints(this.attribute.points)
	      }, array(lineStyle)[0]), {
	        fill: !1,
	        closePath: !1
	      }));
	      line.name = `${this.name}-line`, line.id = this._getNodeId("line"), isEmpty(null == state ? void 0 : state.line) || (line.states = [].concat(state.line)[0]), this.add(line), this.lines.push(line);
	    }
	  }
	  _computeStartRotate(angle) {
	    return angle + Math.PI / 2;
	  }
	  _computeEndRotate(angle) {
	    return angle + Math.PI / 2;
	  }
	  _renderSymbol(attribute, points, dim) {
	    if (!points.length) return;
	    const {
	      autoRotate = !0
	    } = attribute;
	    let symbol;
	    if (attribute && attribute.visible) {
	      const startAngle = this.getStartAngle(),
	        endAngle = this.getEndAngle(),
	        {
	          state: state
	        } = this.attribute,
	        start = points[0],
	        end = points[points.length - 1],
	        {
	          refX = 0,
	          refY = 0,
	          refAngle = 0,
	          style: style,
	          symbolType: symbolType,
	          size = 12
	        } = attribute;
	      let position, rotate;
	      "start" === dim ? (position = {
	        x: start.x + (isValidNumber$1(startAngle) ? refX * Math.cos(startAngle) + refY * Math.cos(startAngle - Math.PI / 2) : 0),
	        y: start.y + (isValidNumber$1(startAngle) ? refX * Math.sin(startAngle) + refY * Math.sin(startAngle - Math.PI / 2) : 0)
	      }, rotate = this._computeStartRotate(this._startAngle)) : (position = {
	        x: end.x + (isValidNumber$1(endAngle) ? refX * Math.cos(endAngle) + refY * Math.cos(endAngle - Math.PI / 2) : 0),
	        y: end.y + (isValidNumber$1(endAngle) ? refX * Math.sin(endAngle) + refY * Math.sin(endAngle - Math.PI / 2) : 0)
	      }, rotate = this._computeEndRotate(this._endAngle)), symbol = graphicCreator.symbol(Object.assign(Object.assign(Object.assign({}, position), {
	        symbolType: symbolType,
	        size: size,
	        angle: autoRotate ? rotate + refAngle : 0,
	        strokeBoundsBuffer: 0
	      }), style)), symbol.name = `${this.name}-${dim}-symbol`, symbol.id = this._getNodeId(`${dim}-symbol`), isEmpty(null == state ? void 0 : state.symbol) || (symbol.states = state.symbol), "start" === dim ? isEmpty(null == state ? void 0 : state.startSymbol) || (symbol.states = state.startSymbol) : isEmpty(null == state ? void 0 : state.endSymbol) || (symbol.states = state.endSymbol), this.add(symbol);
	    }
	    return symbol;
	  }
	  _getMainSegmentPoints() {
	    if (this._mainSegmentPoints) return this._mainSegmentPoints;
	    const {
	      points: originPoints,
	      multiSegment: multiSegment,
	      mainSegmentIndex: mainSegmentIndex
	    } = this.attribute;
	    let points;
	    return points = multiSegment ? isValidNumber$1(mainSegmentIndex) ? originPoints[mainSegmentIndex] : flattenArray(originPoints) : originPoints, this._mainSegmentPoints = points, points;
	  }
	  _clipPoints(points) {
	    const {
	      startSymbol = {},
	      endSymbol = {}
	    } = this.attribute;
	    let pointsAfterClip = points;
	    if (startSymbol.visible) {
	      const startSize = startSymbol.clip ? startSymbol.size || 10 : 0;
	      pointsAfterClip = [{
	        x: points[0].x - startSize / 2 * (Math.cos(this._startAngle) || 0),
	        y: points[0].y - startSize / 2 * (Math.sin(this._startAngle) || 0)
	      }, ...pointsAfterClip.slice(1)];
	    }
	    if (endSymbol.visible) {
	      const endSize = endSymbol.clip ? endSymbol.size || 10 : 0,
	        pointsEnd = {
	          x: points[points.length - 1].x - endSize / 2 * (Math.cos(this._endAngle) || 0),
	          y: points[points.length - 1].y - endSize / 2 * (Math.sin(this._endAngle) || 0)
	        };
	      pointsAfterClip = [...pointsAfterClip.slice(0, pointsAfterClip.length - 1), pointsEnd];
	    }
	    return pointsAfterClip;
	  }
	  _computeLineAngle() {
	    const points = this._getMainSegmentPoints();
	    if (points.length <= 1) return;
	    const start = points[0],
	      startInside = points[1],
	      endInside = points[points.length - 2],
	      end = points[points.length - 1],
	      startVector = [start.x - startInside.x, start.y - startInside.y],
	      startAngle = Math.atan2(startVector[1], startVector[0]),
	      endVector = [end.x - endInside.x, end.y - endInside.y],
	      endAngle = Math.atan2(endVector[1], endVector[0]);
	    this._startAngle = startAngle, this._endAngle = endAngle;
	  }
	  _reset() {
	    this.startSymbol = null, this.endSymbol = null, this._startAngle = null, this._endAngle = null, this._mainSegmentPoints = null;
	  }
	}
	Segment.defaultAttributes = {
	  visible: !0,
	  lineStyle: {
	    lineWidth: 1,
	    stroke: "#000"
	  },
	  startSymbol: {
	    visible: !1,
	    autoRotate: !0,
	    symbolType: "triangle",
	    size: 12,
	    refX: 0,
	    refY: 0,
	    refAngle: 0,
	    style: {
	      fill: "#000",
	      zIndex: 1
	    }
	  },
	  endSymbol: {
	    visible: !1,
	    autoRotate: !0,
	    symbolType: "triangle",
	    size: 12,
	    refX: 0,
	    refY: 0,
	    refAngle: 0,
	    style: {
	      fill: "#000",
	      zIndex: 1
	    }
	  }
	};

	loadArcSegmentComponent();
	class ArcSegment extends Segment {
	  constructor(attributes, options) {
	    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, Segment.defaultAttributes, attributes)), this.name = "arc-segment", this.key = "arc-segment", this.isReverseArc = !1;
	  }
	  getStartAngle() {
	    const tangAng = this.isReverseArc ? this._startAngle + Math.PI / 2 : this._startAngle - Math.PI / 2;
	    return tangAng < 0 ? tangAng + 2 * Math.PI : tangAng > 2 * Math.PI ? tangAng - 2 * Math.PI : tangAng;
	  }
	  getEndAngle() {
	    const tangAng = this.isReverseArc ? this._endAngle - Math.PI / 2 : this._endAngle + Math.PI / 2;
	    return tangAng < 0 ? tangAng + 2 * Math.PI : tangAng > 2 * Math.PI ? tangAng - 2 * Math.PI : tangAng;
	  }
	  getMainSegmentPoints() {
	    return this._mainSegmentPoints;
	  }
	  _computeStartRotate(angle) {
	    return this.isReverseArc ? angle + Math.PI : angle;
	  }
	  _computeEndRotate(angle) {
	    return this.isReverseArc ? angle : angle + Math.PI;
	  }
	  render() {
	    this.removeAllChild(!0), this._reset();
	    const {
	      startSymbol: startSymbol,
	      endSymbol: endSymbol,
	      lineStyle: lineStyle,
	      state: state,
	      visible = !0,
	      radius: radius,
	      startAngle: startAngle,
	      endAngle: endAngle,
	      center: center
	    } = this.attribute;
	    if (!visible) return;
	    this._startAngle = startAngle, this._endAngle = endAngle, this.isReverseArc = startAngle > endAngle;
	    const startPoint = {
	        x: center.x + radius * Math.cos(this._startAngle),
	        y: center.y + radius * Math.sin(this._startAngle)
	      },
	      endPoint = {
	        x: center.x + radius * Math.cos(this._endAngle),
	        y: center.y + radius * Math.sin(this._endAngle)
	      };
	    this._mainSegmentPoints = [startPoint, endPoint];
	    const startSymbolShape = this._renderSymbol(startSymbol, this._mainSegmentPoints, "start"),
	      endSymbolShape = this._renderSymbol(endSymbol, this._mainSegmentPoints, "end");
	    this.startSymbol = startSymbolShape, this.endSymbol = endSymbolShape;
	    const line = graphicCreator.arc(Object.assign({
	      x: center.x,
	      y: center.y,
	      startAngle: startAngle,
	      endAngle: endAngle,
	      innerRadius: radius,
	      outerRadius: radius
	    }, lineStyle));
	    line.name = `${this.name}-line`, line.id = this._getNodeId("arc"), isEmpty(null == state ? void 0 : state.line) || (line.states = [].concat(state.line)[0]), this.add(line), this.line = line;
	  }
	}

	const dispatchHoverState = (e, container, lastHover) => {
	  const target = e.target;
	  return target !== lastHover && target.name && !isEmpty(target.states) ? (target.addState(StateValue.hover, !0), traverseGroup(container, node => {
	    node !== target && node.name && !isEmpty(node.states) && node.addState(StateValue.hoverReverse, !0);
	  }), target) : lastHover;
	};
	const dispatchUnHoverState = (e, container, lastHover) => lastHover ? (traverseGroup(container, node => {
	  node.name && !isEmpty(node.states) && (node.removeState(StateValue.hoverReverse), node.removeState(StateValue.hover));
	}), null) : lastHover;
	const dispatchClickState = (e, container, lastSelect) => {
	  const target = e.target;
	  return lastSelect === target && target.hasState(StateValue.selected) ? (traverseGroup(container, node => {
	    node.name && !isEmpty(node.states) && (node.removeState(StateValue.selectedReverse), node.removeState(StateValue.selected));
	  }), null) : target.name && !isEmpty(target.states) ? (target.addState(StateValue.selected, !0), traverseGroup(container, node => {
	    node !== target && node.name && !isEmpty(node.states) && node.addState(StateValue.selectedReverse, !0);
	  }), target) : lastSelect;
	};

	var IMarkLineLabelPosition;
	!function (IMarkLineLabelPosition) {
	  IMarkLineLabelPosition.start = "start", IMarkLineLabelPosition.startTop = "startTop", IMarkLineLabelPosition.startBottom = "startBottom", IMarkLineLabelPosition.insideStart = "insideStart", IMarkLineLabelPosition.insideStartTop = "insideStartTop", IMarkLineLabelPosition.insideStartBottom = "insideStartBottom", IMarkLineLabelPosition.middle = "middle", IMarkLineLabelPosition.insideMiddleTop = "insideMiddleTop", IMarkLineLabelPosition.insideMiddleBottom = "insideMiddleBottom", IMarkLineLabelPosition.end = "end", IMarkLineLabelPosition.endTop = "endTop", IMarkLineLabelPosition.endBottom = "endBottom", IMarkLineLabelPosition.insideEnd = "insideEnd", IMarkLineLabelPosition.insideEndTop = "insideEndTop", IMarkLineLabelPosition.insideEndBottom = "insideEndBottom";
	}(IMarkLineLabelPosition || (IMarkLineLabelPosition = {}));
	var IMarkAreaLabelPosition;
	!function (IMarkAreaLabelPosition) {
	  IMarkAreaLabelPosition.left = "left", IMarkAreaLabelPosition.right = "right", IMarkAreaLabelPosition.top = "top", IMarkAreaLabelPosition.bottom = "bottom", IMarkAreaLabelPosition.topLeft = "topLeft", IMarkAreaLabelPosition.topRight = "topRight", IMarkAreaLabelPosition.bottomLeft = "bottomLeft", IMarkAreaLabelPosition.bottomRight = "bottomRight", IMarkAreaLabelPosition.middle = "middle", IMarkAreaLabelPosition.insideLeft = "insideLeft", IMarkAreaLabelPosition.insideRight = "insideRight", IMarkAreaLabelPosition.insideTop = "insideTop", IMarkAreaLabelPosition.insideBottom = "insideBottom", IMarkAreaLabelPosition.insideTopLeft = "insideTopLeft", IMarkAreaLabelPosition.insideTopRight = "insideTopRight", IMarkAreaLabelPosition.insideBottomLeft = "insideBottomLeft", IMarkAreaLabelPosition.insideBottomRight = "insideBottomRight";
	}(IMarkAreaLabelPosition || (IMarkAreaLabelPosition = {}));
	var IMarkCommonArcLabelPosition;
	!function (IMarkCommonArcLabelPosition) {
	  IMarkCommonArcLabelPosition.arcInnerStart = "arcInnerStart", IMarkCommonArcLabelPosition.arcInnerEnd = "arcInnerEnd", IMarkCommonArcLabelPosition.arcInnerMiddle = "arcInnerMiddle", IMarkCommonArcLabelPosition.arcOuterStart = "arcOuterStart", IMarkCommonArcLabelPosition.arcOuterEnd = "arcOuterEnd", IMarkCommonArcLabelPosition.arcOuterMiddle = "arcOuterMiddle", IMarkCommonArcLabelPosition.center = "center";
	}(IMarkCommonArcLabelPosition || (IMarkCommonArcLabelPosition = {}));
	var IMarkPointItemPosition;
	!function (IMarkPointItemPosition) {
	  IMarkPointItemPosition.top = "top", IMarkPointItemPosition.bottom = "bottom", IMarkPointItemPosition.middle = "middle", IMarkPointItemPosition.insideTop = "insideTop", IMarkPointItemPosition.insideBottom = "insideBottom", IMarkPointItemPosition.insideMiddle = "insideMiddle";
	}(IMarkPointItemPosition || (IMarkPointItemPosition = {}));

	function loadBaseMarker() {
	  registerGroup(), loadTagComponent(), registerAnimate();
	}
	function loadMarkPointComponent() {
	  loadBaseMarker(), loadSegmentComponent(), loadArcSegmentComponent(), registerSymbol(), registerImage(), registerLine(), registerAnimate();
	}

	class Marker extends AbstractComponent {
	  constructor() {
	    super(...arguments), this.name = "marker", this._onHover = e => {
	      this._lastHover = dispatchHoverState(e, this._container, this._lastHover);
	    }, this._onUnHover = e => {
	      this._lastHover = dispatchUnHoverState(e, this._container, this._lastHover);
	    }, this._onClick = e => {
	      this._lastSelect = dispatchClickState(e, this._container, this._lastSelect);
	    };
	  }
	  transAnimationConfig() {
	    var _a, _b, _c;
	    if (!1 !== this.attribute.animation) {
	      const animation = isObject$1(this.attribute.animation) ? this.attribute.animation : {};
	      this._animationConfig = {
	        enter: merge({}, this.defaultUpdateAnimation, animation, null !== (_a = this.attribute.animationEnter) && void 0 !== _a ? _a : {}),
	        exit: merge({}, this.defaultExitAnimation, animation, null !== (_b = this.attribute.animationExit) && void 0 !== _b ? _b : {}),
	        update: merge({}, this.defaultUpdateAnimation, animation, null !== (_c = this.attribute.animationUpdate) && void 0 !== _c ? _c : {})
	      };
	    }
	  }
	  setAttribute(key, value, forceUpdateTag) {
	    super.setAttribute(key, value, forceUpdateTag), "visible" === key && this.render();
	  }
	  _bindEvent() {
	    var _a, _b, _c;
	    if (!this.attribute.interactive) return;
	    const {
	      hover: hover,
	      select: select
	    } = this.attribute;
	    hover && (null === (_a = this._container) || void 0 === _a || _a.addEventListener("pointermove", this._onHover), null === (_b = this._container) || void 0 === _b || _b.addEventListener("pointerout", this._onUnHover)), select && (null === (_c = this._container) || void 0 === _c || _c.addEventListener("pointerdown", this._onClick));
	  }
	  _releaseEvent() {
	    var _a, _b, _c;
	    null === (_a = this._container) || void 0 === _a || _a.removeEventListener("pointermove", this._onHover), null === (_b = this._container) || void 0 === _b || _b.removeEventListener("pointerout", this._onUnHover), null === (_c = this._container) || void 0 === _c || _c.removeEventListener("pointerdown", this._onClick);
	  }
	  _initContainer() {
	    var _a, _b;
	    const {
	      limitRect = {},
	      clipInRange: clipInRange
	    } = this.attribute;
	    let group;
	    if (clipInRange) {
	      const groupClip = graphicCreator.group(Object.assign(Object.assign({}, limitRect), {
	        clip: !0,
	        pickable: !1
	      }));
	      group = graphicCreator.group({
	        x: -(null !== (_a = limitRect.x) && void 0 !== _a ? _a : 0),
	        y: -(null !== (_b = limitRect.y) && void 0 !== _b ? _b : 0),
	        pickable: !1
	      }), groupClip.add(group), this._containerClip = groupClip, this.add(groupClip);
	    } else group = graphicCreator.group({
	      x: 0,
	      y: 0,
	      pickable: !1
	    }), this.add(group);
	    group.name = "marker-container", this._container = group;
	  }
	  _updateContainer() {
	    var _a, _b;
	    const {
	      limitRect = {},
	      clipInRange: clipInRange
	    } = this.attribute;
	    this._containerClip && this._containerClip.setAttributes(Object.assign({}, limitRect)), this._container.setAttributes({
	      x: clipInRange ? -(null !== (_a = limitRect.x) && void 0 !== _a ? _a : 0) : 0,
	      y: clipInRange ? -(null !== (_b = limitRect.y) && void 0 !== _b ? _b : 0) : 0
	    });
	  }
	  render() {
	    var _a;
	    this.transAnimationConfig(), this.setAttribute("pickable", !1);
	    const markerVisible = null === (_a = this.attribute.visible) || void 0 === _a || _a;
	    !1 === this.attribute.interactive && this.setAttribute("childrenPickable", !1), markerVisible && this.isValidPoints() ? this._container ? (this._updateContainer(), this.updateMarker(), this.markerAnimate("update")) : (this._initContainer(), this.initMarker(this._container), this.markerAnimate("enter")) : (this.markerAnimate("exit"), this._container = null, this.removeAllChild(!0)), this._releaseEvent(), this._bindEvent();
	  }
	  release() {
	    this.markerAnimate("exit"), super.release(), this._releaseEvent(), this._container = null;
	  }
	}

	const DefaultUpdateMarkPointAnimation = {
	  type: "callIn",
	  duration: 500,
	  easing: "linear",
	  delay: 0
	};
	const DefaultExitMarkerAnimation = {
	  type: "fadeOut",
	  duration: 500,
	  easing: "linear",
	  delay: 0
	};

	const FUZZY_EQUAL_DELTA = .001;
	({
	  interactive: !0,
	  startSymbol: {
	    visible: !1,
	    symbolType: "triangle",
	    size: 12,
	    fill: "rgba(46, 47, 50)",
	    lineWidth: 0
	  },
	  endSymbol: {
	    visible: !0,
	    symbolType: "triangle",
	    size: 12,
	    fill: "rgba(46, 47, 50)",
	    lineWidth: 0
	  },
	  label: {
	    position: IMarkLineLabelPosition.end,
	    refX: 0,
	    refY: 0,
	    refAngle: 0,
	    textStyle: {
	      fill: "#fff",
	      stroke: "#fff",
	      lineWidth: 0,
	      fontSize: 10,
	      fontWeight: "normal",
	      fontStyle: "normal"
	    },
	    padding: [2, 2, 4, 4],
	    panel: {
	      visible: !0,
	      cornerRadius: 0,
	      fill: "rgb(48, 115, 242)",
	      fillOpacity: .8
	    }
	  },
	  lineStyle: {
	    stroke: "#b2bacf",
	    lineWidth: 1,
	    lineDash: [2]
	  }
	});
	({
	  interactive: !0,
	  startSymbol: {
	    visible: !1,
	    symbolType: "triangle",
	    size: 12,
	    fill: "rgba(46, 47, 50)",
	    lineWidth: 0
	  },
	  endSymbol: {
	    visible: !0,
	    symbolType: "triangle",
	    size: 12,
	    fill: "rgba(46, 47, 50)",
	    lineWidth: 0
	  },
	  label: {
	    autoRotate: !0,
	    position: IMarkCommonArcLabelPosition.arcOuterMiddle,
	    refX: 0,
	    refY: 0,
	    refAngle: 0,
	    textStyle: {
	      fill: "#fff",
	      stroke: "#fff",
	      lineWidth: 0,
	      fontSize: 10,
	      fontWeight: "normal",
	      fontStyle: "normal"
	    },
	    padding: [2, 2, 4, 4],
	    panel: {
	      visible: !0,
	      cornerRadius: 0,
	      fill: "rgb(48, 115, 242)",
	      fillOpacity: .8
	    }
	  },
	  lineStyle: {
	    stroke: "#b2bacf",
	    lineWidth: 1,
	    lineDash: [2]
	  }
	});
	({
	  interactive: !0,
	  label: {
	    position: IMarkAreaLabelPosition.right,
	    textStyle: {
	      fill: "#fff",
	      stroke: "#fff",
	      lineWidth: 0,
	      fontSize: 10,
	      fontWeight: "normal",
	      fontStyle: "normal"
	    },
	    padding: [2, 2, 4, 4],
	    panel: {
	      visible: !0,
	      cornerRadius: 0,
	      fill: "rgb(48, 115, 242)",
	      fillOpacity: .8
	    }
	  },
	  areaStyle: {
	    fill: "#b2bacf",
	    visible: !0
	  }
	});
	({
	  interactive: !0,
	  label: {
	    autoRotate: !0,
	    position: IMarkCommonArcLabelPosition.arcOuterMiddle,
	    textStyle: {
	      fill: "#fff",
	      stroke: "#fff",
	      lineWidth: 0,
	      fontSize: 10,
	      fontWeight: "normal",
	      fontStyle: "normal"
	    },
	    padding: [2, 2, 4, 4],
	    panel: {
	      visible: !0,
	      cornerRadius: 0,
	      fill: "rgb(48, 115, 242)",
	      fillOpacity: .8
	    }
	  },
	  areaStyle: {
	    fill: "#b2bacf",
	    visible: !0
	  }
	});
	const DEFAULT_MARK_POINT_THEME = {
	  interactive: !0,
	  targetSymbol: {
	    visible: !1,
	    offset: 0,
	    style: {
	      symbolType: "circle",
	      size: 20,
	      fill: !1,
	      stroke: "rgba(46, 47, 50)"
	    }
	  },
	  itemLine: {
	    visible: !0,
	    decorativeLine: {
	      visible: !1,
	      length: 30
	    },
	    startSymbol: {
	      visible: !0,
	      clip: !0,
	      symbolType: "circle",
	      size: 20,
	      style: {
	        fill: !1,
	        stroke: "rgba(46, 47, 50)"
	      }
	    },
	    endSymbol: {
	      visible: !1,
	      clip: !0,
	      symbolType: "triangle",
	      size: 12,
	      style: {
	        fill: !1,
	        stroke: "rgba(46, 47, 50)"
	      }
	    },
	    lineStyle: {
	      stroke: "#000",
	      lineWidth: 1
	    }
	  },
	  itemContent: {
	    type: "text",
	    position: "middle",
	    refX: 10
	  }
	};
	const DEFAULT_MARK_POINT_TEXT_STYLE_MAP = {
	  postiveXAxis: {
	    top: {
	      textAlign: "left",
	      textBaseline: "bottom"
	    },
	    bottom: {
	      textAlign: "left",
	      textBaseline: "top"
	    },
	    middle: {
	      textAlign: "left",
	      textBaseline: "middle"
	    },
	    insideTop: {
	      textAlign: "right",
	      textBaseline: "bottom"
	    },
	    insideBottom: {
	      textAlign: "right",
	      textBaseline: "top"
	    },
	    insideMiddle: {
	      textAlign: "right",
	      textBaseline: "middle"
	    }
	  },
	  negativeXAxis: {
	    top: {
	      textAlign: "right",
	      textBaseline: "bottom"
	    },
	    bottom: {
	      textAlign: "right",
	      textBaseline: "top"
	    },
	    middle: {
	      textAlign: "right",
	      textBaseline: "middle"
	    },
	    insideTop: {
	      textAlign: "left",
	      textBaseline: "bottom"
	    },
	    insideBottom: {
	      textAlign: "left",
	      textBaseline: "top"
	    },
	    insideMiddle: {
	      textAlign: "left",
	      textBaseline: "middle"
	    }
	  }
	};

	loadMarkPointComponent();
	class MarkPoint extends Marker {
	  markerAnimate(state) {
	    MarkPoint._animate && this._animationConfig && MarkPoint._animate([this._line, this._decorativeLine], this._item, this._animationConfig, state);
	  }
	  constructor(attributes, options) {
	    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, MarkPoint.defaultAttributes, attributes)), this.name = "markPoint", this.defaultUpdateAnimation = DefaultUpdateMarkPointAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation, this._isArcLine = !1, this._isStraightLine = !1;
	  }
	  setLabelPos() {}
	  getTextAlignAttr(autoRotate, offsetX, offsetY, lineEndAngle, itemPosition) {
	    return fuzzyEqualNumber(Math.abs(lineEndAngle), Math.PI / 2, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(Math.abs(lineEndAngle), 3 * Math.PI / 2, FUZZY_EQUAL_DELTA) ? getTextAlignAttrOfVerticalDir(autoRotate, lineEndAngle, itemPosition) : isPostiveXAxis(lineEndAngle) ? DEFAULT_MARK_POINT_TEXT_STYLE_MAP.postiveXAxis[itemPosition] : DEFAULT_MARK_POINT_TEXT_STYLE_MAP.negativeXAxis[itemPosition];
	  }
	  setItemAttributes(item, itemContent, newPosition, newItemPosition, itemType) {
	    var _a, _b;
	    if (!item) return;
	    const {
	        autoRotate = !0,
	        refX = 0,
	        refY = 0,
	        refAngle = 0,
	        style: style,
	        position: positionType = IMarkPointItemPosition.middle
	      } = itemContent,
	      {
	        state: state
	      } = this.attribute,
	      lineEndAngle = (null === (_a = this._line) || void 0 === _a ? void 0 : _a.getEndAngle()) || 0,
	      itemRefOffsetX = refX * Math.cos(lineEndAngle) + refY * Math.cos(lineEndAngle - Math.PI / 2),
	      itemRefOffsetY = refX * Math.sin(lineEndAngle) + refY * Math.sin(lineEndAngle - Math.PI / 2);
	    if ("text" === itemType) {
	      const offsetX = newItemPosition.x - newPosition.x,
	        offsetY = newItemPosition.y - newPosition.y;
	      item.setAttributes(Object.assign(Object.assign({}, style), {
	        textStyle: Object.assign(Object.assign({}, this.getTextAlignAttr(autoRotate, offsetX, offsetY, lineEndAngle, null !== (_b = itemContent.position) && void 0 !== _b ? _b : "end")), style.textStyle),
	        state: {
	          panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.textBackground),
	          text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.itemContent)
	        }
	      }));
	    } else ("richText" === itemType || "image" === itemType) && (item.setAttributes({
	      dx: this.getItemDx(item, positionType, style) + (style.dx || 0),
	      dy: this.getItemDy(item, positionType, style) + (style.dy || 0)
	    }), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.itemContent));
	    const itemAngle = isPostiveXAxis(lineEndAngle) ? lineEndAngle : lineEndAngle - Math.PI;
	    item.setAttributes({
	      x: newItemPosition.x + (itemRefOffsetX || 0),
	      y: newItemPosition.y + (itemRefOffsetY || 0),
	      angle: autoRotate && itemAngle + refAngle
	    });
	  }
	  getItemDx(item, position, style) {
	    var _a, _b;
	    const width = null !== (_b = null === (_a = null == item ? void 0 : item.AABBBounds) || void 0 === _a ? void 0 : _a.width()) && void 0 !== _b ? _b : (null == style ? void 0 : style.width) || 0;
	    return position.includes("inside") ? -width : 0;
	  }
	  getItemDy(item, position, style) {
	    var _a, _b;
	    const height = null !== (_b = null === (_a = null == item ? void 0 : item.AABBBounds) || void 0 === _a ? void 0 : _a.height()) && void 0 !== _b ? _b : (null == style ? void 0 : style.height) || 0;
	    return position.includes("top") || position.includes("Top") ? -height : position.includes("middle") || position.includes("Middle") ? -height / 2 : 0;
	  }
	  initItem(itemContent, newPosition, newItemPosition) {
	    const {
	        state: state
	      } = this.attribute,
	      {
	        type = "text",
	        style: style,
	        renderCustomCallback: renderCustomCallback
	      } = itemContent;
	    let item;
	    return "symbol" === type ? (item = graphicCreator.symbol(Object.assign(Object.assign({}, newItemPosition), style)), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.itemContent)) : "text" === type ? item = new Tag(Object.assign(Object.assign({}, newItemPosition), {
	      state: {
	        panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.textBackground),
	        text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.itemContent)
	      }
	    })) : "richText" === type ? (item = graphicCreator.richtext(Object.assign(Object.assign({}, newItemPosition), style)), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.itemContent)) : "image" === type ? (item = graphicCreator.image(Object.assign(Object.assign({}, newItemPosition), style)), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.itemContent)) : "custom" === type && renderCustomCallback && (item = renderCustomCallback(), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.itemContent)), item.name = `mark-point-${type}`, this.setItemAttributes(item, itemContent, newPosition, newItemPosition, type), item;
	  }
	  getItemLineAttr(itemLine, newPosition, newItemPosition) {
	    let points = [],
	      center = {
	        x: 0,
	        y: 0
	      },
	      radius = 0,
	      startAngle = 0,
	      endAngle = 0;
	    const {
	        type = "type-s",
	        arcRatio = .8
	      } = itemLine,
	      itemOffsetX = newItemPosition.x - newPosition.x,
	      itemOffsetY = newItemPosition.y - newPosition.y;
	    if (this._isStraightLine = fuzzyEqualNumber(itemOffsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(itemOffsetY, 0, FUZZY_EQUAL_DELTA), this._isArcLine) {
	      const {
	          x: x1,
	          y: y1
	        } = this.attribute.position,
	        {
	          x: x2,
	          y: y2
	        } = newItemPosition,
	        x0 = (x1 + x2) / 2,
	        y0 = (y1 + y2) / 2,
	        k = y1 === y2 ? 0 : -(x1 - x2) / (y1 - y2),
	        centerX = x0 + arcRatio * (y2 > y1 ? -1 : 1) * x0,
	        centerY = (x => k * (x - x0) + y0)(centerX);
	      startAngle = deltaXYToAngle(y1 - centerY, x1 - centerX), endAngle = deltaXYToAngle(y2 - centerY, x2 - centerX), center = {
	        x: centerX,
	        y: centerY
	      };
	      const R = Math.sqrt((centerX - x1) * (centerX - x1) + (centerY - y1) * (centerY - y1)),
	        r = this.attribute.targetSymbol.style.size / 2;
	      startAngle += 2 * Math.acos(Math.sqrt(1 - r * r / (4 * R * R))), arcRatio > 0 ? endAngle < startAngle && (endAngle += 2 * Math.PI) : startAngle < endAngle && (startAngle += 2 * Math.PI), radius = Math.sqrt((centerX - x1) * (centerX - x1) + (centerY - y1) * (centerY - y1));
	    } else points = "type-do" !== type || this._isStraightLine ? "type-po" !== type || this._isStraightLine ? "type-op" !== type || this._isStraightLine ? [newPosition, newItemPosition] : [newPosition, {
	      x: newPosition.x,
	      y: newItemPosition.y
	    }, newItemPosition] : [newPosition, {
	      x: newItemPosition.x,
	      y: newPosition.y
	    }, newItemPosition] : [newPosition, {
	      x: (newPosition.x + newItemPosition.x) / 2,
	      y: newItemPosition.y
	    }, newItemPosition];
	    return points = removeRepeatPoint(points), {
	      points: points,
	      center: center,
	      radius: radius,
	      startAngle: startAngle,
	      endAngle: endAngle
	    };
	  }
	  reDrawLine(itemLine, pointsAttr) {
	    this._line.release();
	    const {
	        startSymbol: startSymbol,
	        endSymbol: endSymbol,
	        lineStyle: lineStyle,
	        type = "type-s"
	      } = itemLine,
	      {
	        state: state
	      } = this.attribute,
	      lineConstructor = this._isArcLine ? ArcSegment : Segment;
	    this._container.removeChild(this._line), this._line = new lineConstructor(Object.assign(Object.assign({}, pointsAttr), {
	      pickable: !1,
	      startSymbol: startSymbol,
	      endSymbol: endSymbol,
	      lineStyle: lineStyle,
	      visible: itemLine.visible,
	      state: {
	        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
	        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
	        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
	      }
	    })), this._container.add(this._line);
	  }
	  setItemLineAttr(itemLine, newPosition, newItemPosition) {
	    if (this._line) {
	      const {
	          startSymbol: startSymbol,
	          endSymbol: endSymbol,
	          lineStyle: lineStyle,
	          type = "type-s"
	        } = itemLine,
	        {
	          state: state
	        } = this.attribute,
	        pointsAttr = this.getItemLineAttr(itemLine, newPosition, newItemPosition);
	      this._isArcLine && "arc-segment" === this._line.key || !this._isArcLine && "segment" === this._line.key ? this._line.setAttributes(Object.assign(Object.assign({}, pointsAttr), {
	        startSymbol: startSymbol,
	        endSymbol: endSymbol,
	        lineStyle: lineStyle,
	        visible: itemLine.visible,
	        state: {
	          line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
	          startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
	          endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
	        }
	      })) : this.reDrawLine(itemLine, pointsAttr);
	    }
	  }
	  getDecorativeLineAttr(itemLine) {
	    var _a;
	    const decorativeLength = (null === (_a = null == itemLine ? void 0 : itemLine.decorativeLine) || void 0 === _a ? void 0 : _a.length) || 10,
	      itemAngle = this._line.getEndAngle() || 0;
	    return {
	      startPointOffsetX: decorativeLength / 2 * Math.cos(itemAngle - Math.PI / 2),
	      startPointOffsetY: decorativeLength / 2 * Math.sin(itemAngle - Math.PI / 2),
	      endPointOffsetX: -decorativeLength / 2 * Math.cos(itemAngle - Math.PI / 2),
	      endPointOffsetY: -decorativeLength / 2 * Math.sin(itemAngle - Math.PI / 2)
	    };
	  }
	  setDecorativeLineAttr(itemLine, newItemPosition, visible) {
	    var _a;
	    if (this._decorativeLine) {
	      const {
	          lineStyle: lineStyle
	        } = itemLine,
	        {
	          startPointOffsetX: startPointOffsetX,
	          startPointOffsetY: startPointOffsetY,
	          endPointOffsetX: endPointOffsetX,
	          endPointOffsetY: endPointOffsetY
	        } = this.getDecorativeLineAttr(itemLine);
	      this._decorativeLine.setAttributes(Object.assign(Object.assign({
	        points: [{
	          x: newItemPosition.x + startPointOffsetX,
	          y: newItemPosition.y + startPointOffsetY
	        }, {
	          x: newItemPosition.x + endPointOffsetX,
	          y: newItemPosition.y + endPointOffsetY
	        }]
	      }, lineStyle), {
	        visible: visible
	      })), this._decorativeLine.states = merge({}, DEFAULT_STATES, null === (_a = this.attribute.state) || void 0 === _a ? void 0 : _a.line);
	    }
	  }
	  setTargetItemAttributes(targetItem, position) {
	    var _a, _b;
	    this._targetItem && (this._targetItem.setAttributes(Object.assign({
	      x: position.x,
	      y: position.y,
	      visible: null !== (_a = targetItem.visible) && void 0 !== _a && _a,
	      size: targetItem.size
	    }, targetItem.style)), this._targetItem.states = merge({}, DEFAULT_STATES, null === (_b = this.attribute.state) || void 0 === _b ? void 0 : _b.targetItem));
	  }
	  setAllOfItemsAttr(newPosition, newItemPosition) {
	    var _a;
	    const {
	        position: position,
	        itemLine = {},
	        itemContent = {},
	        limitRect: limitRect,
	        targetSymbol: targetSymbol
	      } = this.attribute,
	      {
	        type = "text",
	        confine: confine
	      } = itemContent;
	    if (limitRect && confine) {
	      const {
	          x: x,
	          y: y,
	          width: width,
	          height: height
	        } = limitRect,
	        {
	          dx: dx,
	          dy: dy
	        } = computeOffsetForlimit(this._item, {
	          x1: x,
	          y1: y,
	          x2: x + width,
	          y2: y + height
	        });
	      newItemPosition.x = newItemPosition.x + dx, newItemPosition.y = newItemPosition.y + dy;
	    }
	    this.setTargetItemAttributes(targetSymbol, position), this.setItemLineAttr(itemLine, newPosition, newItemPosition), this.setItemAttributes(this._item, itemContent, newPosition, newItemPosition, type), this.setDecorativeLineAttr(itemLine, newItemPosition, null === (_a = itemLine.decorativeLine) || void 0 === _a ? void 0 : _a.visible);
	  }
	  computeNewPositionAfterTargetItem(position) {
	    var _a, _b;
	    const {
	        itemContent = {},
	        targetSymbol: targetSymbol,
	        itemLine: itemLine
	      } = this.attribute,
	      {
	        offsetX: itemContentOffsetX = 0,
	        offsetY: itemContentOffsetY = 0
	      } = itemContent,
	      {
	        offset: targetSymbolOffset = 0,
	        style: targetSymbolStyle,
	        visible: targetItemvisible = !1,
	        size: targetSymbolSize
	      } = targetSymbol,
	      targetSize = targetItemvisible ? null !== (_b = null !== (_a = targetSymbolStyle.size) && void 0 !== _a ? _a : targetSymbolSize) && void 0 !== _b ? _b : 20 : 0;
	    let targetOffsetAngle;
	    targetOffsetAngle = "type-do" === itemLine.type ? deltaXYToAngle(itemContentOffsetY, itemContentOffsetX / 2) : "type-po" === itemLine.type ? deltaXYToAngle(0, itemContentOffsetX) : "type-op" === itemLine.type ? deltaXYToAngle(itemContentOffsetY, 0) : deltaXYToAngle(itemContentOffsetY, itemContentOffsetX);
	    return {
	      newPosition: {
	        x: position.x + (targetSize / 2 + targetSymbolOffset) * Math.cos(targetOffsetAngle),
	        y: position.y + (targetSize / 2 + targetSymbolOffset) * Math.sin(targetOffsetAngle)
	      },
	      newItemPosition: {
	        x: position.x + (targetSize / 2 + targetSymbolOffset) * Math.cos(targetOffsetAngle) + itemContentOffsetX,
	        y: position.y + (targetSize / 2 + targetSymbolOffset) * Math.sin(targetOffsetAngle) + itemContentOffsetY
	      }
	    };
	  }
	  initMarker(container) {
	    const {
	        position: position,
	        itemContent = {},
	        itemLine: itemLine
	      } = this.attribute,
	      {
	        type: itemLineType = "type-s",
	        arcRatio = .8
	      } = itemLine,
	      {
	        offsetX = 0,
	        offsetY = 0
	      } = itemContent;
	    this._isStraightLine = fuzzyEqualNumber(offsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(offsetY, 0, FUZZY_EQUAL_DELTA), this._isArcLine = "type-arc" === itemLineType && 0 !== arcRatio && !this._isStraightLine;
	    const {
	        newPosition: newPosition,
	        newItemPosition: newItemPosition
	      } = this.computeNewPositionAfterTargetItem(position),
	      line = new (this._isArcLine ? ArcSegment : Segment)({
	        points: [],
	        pickable: !1,
	        center: {
	          x: 0,
	          y: 0
	        },
	        radius: 0,
	        startAngle: 0,
	        endAngle: 0
	      });
	    line.name = "mark-point-line", this._line = line, container.add(line);
	    const decorativeLine = graphicCreator.line({
	      points: []
	    });
	    decorativeLine.name = "mark-point-decorativeLine", this._decorativeLine = decorativeLine, container.add(decorativeLine);
	    const targetItem = graphicCreator.symbol({});
	    targetItem.name = "mark-point-targetItem", this._targetItem = targetItem, container.add(this._targetItem);
	    const item = this.initItem(itemContent, newPosition, newItemPosition);
	    this._item = item, container.add(item), this.setAllOfItemsAttr(newPosition, newItemPosition);
	  }
	  updateMarker() {
	    const {
	        position: position,
	        itemContent = {},
	        itemLine: itemLine
	      } = this.attribute,
	      {
	        type = "text"
	      } = itemContent,
	      {
	        type: itemLineType = "type-s",
	        arcRatio = .8
	      } = itemLine,
	      {
	        offsetX = 0,
	        offsetY = 0
	      } = itemContent;
	    this._isStraightLine = fuzzyEqualNumber(offsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(offsetY, 0, FUZZY_EQUAL_DELTA);
	    const isArcLine = "type-arc" === itemLineType && 0 !== arcRatio && !this._isStraightLine,
	      {
	        newPosition: newPosition,
	        newItemPosition: newItemPosition
	      } = this.computeNewPositionAfterTargetItem(position);
	    isArcLine !== this._isArcLine ? (this._isArcLine = isArcLine, this.reDrawLine(itemLine, {
	      points: [{
	        x: 0,
	        y: 0
	      }],
	      pickable: !1,
	      center: {
	        x: 0,
	        y: 0
	      },
	      radius: 0,
	      startAngle: 0,
	      endAngle: 0
	    })) : this._isArcLine = isArcLine, this.setItemAttributes(this._item, itemContent, newPosition, newItemPosition, type), this.setAllOfItemsAttr(newPosition, newItemPosition);
	  }
	  isValidPoints() {
	    const {
	      position: position
	    } = this.attribute;
	    return !(!isValidNumber$1(position.x) || !isValidNumber$1(position.y));
	  }
	}
	MarkPoint.defaultAttributes = DEFAULT_MARK_POINT_THEME;

	const SERIES_BREAK = 'seriesBreak';

	function generateZigzagPath(start, end, size, angle, isVertical = false) {
	    const path = [];
	    const { x: startX, y: startY } = start;
	    const { x: endX, y: endY } = end;
	    const numZigzags = isVertical ? Math.floor((endY - startY) / (size * 2)) : Math.floor((endX - startX) / (size * 2));
	    const angleRad = (Math.PI / 180) * angle;
	    const deltaX = size * Math.cos(angleRad);
	    const deltaY = size * Math.sin(angleRad);
	    path.push(`M ${startX} ${startY}`);
	    for (let i = 0; i <= numZigzags; i++) {
	        const x = isVertical ? startX + (i % 2 === 0 ? deltaX : -deltaX) : startX + i * size * 2;
	        const y = isVertical ? startY + i * size * 2 : i % 2 === 0 ? startY - deltaY : startY + deltaY;
	        path.push(`L ${x} ${y}`);
	    }
	    path.push(`L ${isVertical ? startX : endX} ${isVertical ? endY : startY}`);
	    return path.join(' ');
	}
	const checkOverlap = (prevData, newEntry) => {
	    const { start, end } = newEntry;
	    const isVertical = start.x === end.x;
	    const equalDim = isVertical ? 'x' : 'y';
	    const diffDim = isVertical ? 'y' : 'x';
	    let needAppend = true;
	    const EPS = 1e-6;
	    if (prevData.length) {
	        prevData.forEach(prevEntry => {
	            if (isNumberClose(prevEntry.start[equalDim], start[equalDim])) {
	                const minDim = Math.min(start[diffDim], end[diffDim]);
	                const maxDim = Math.max(start[diffDim], end[diffDim]);
	                const prevMinDim = Math.min(prevEntry.start[diffDim], prevEntry.end[diffDim]);
	                const prevMaxDim = Math.max(prevEntry.start[diffDim], prevEntry.end[diffDim]);
	                const hasOverlap = !(maxDim < prevMinDim - EPS || minDim > prevMaxDim + EPS);
	                if (hasOverlap) {
	                    prevEntry.start[diffDim] = Math.min(prevMinDim, minDim);
	                    prevEntry.end[diffDim] = Math.max(prevMaxDim, maxDim);
	                    needAppend = false;
	                    return;
	                }
	            }
	        });
	    }
	    if (needAppend) {
	        prevData.push(newEntry);
	    }
	};
	class SeriesBreakComponent extends AbstractComponent {
	    constructor() {
	        super(...arguments);
	        this.name = SERIES_BREAK;
	    }
	    render() {
	        this.removeAllChild();
	        const { data = [] } = this.attribute;
	        if (isEmpty(data)) {
	            return;
	        }
	        const verticalData = [];
	        const horizontalData = [];
	        data.forEach(breakData => {
	            const { start, end } = breakData;
	            const isVertical = start.x === end.x;
	            checkOverlap(isVertical ? verticalData : horizontalData, breakData);
	        });
	        [...verticalData, ...horizontalData].forEach((breakData, id) => {
	            var _a;
	            const { start, end, size = 4, gap = 5, style = {} } = breakData, rest = __rest$1(breakData, ["start", "end", "size", "gap", "style"]);
	            const breakGroup = createGroup({});
	            const isVertical = start.x === end.x;
	            let startPathStart;
	            let startPathEnd;
	            let endPathStart;
	            let endPathEnd;
	            if (isVertical) {
	                startPathStart = {
	                    x: start.x - gap / 2,
	                    y: start.y
	                };
	                startPathEnd = {
	                    x: end.x - gap / 2,
	                    y: end.y
	                };
	                endPathStart = {
	                    x: start.x + gap / 2,
	                    y: start.y
	                };
	                endPathEnd = {
	                    x: end.x + gap / 2,
	                    y: end.y
	                };
	            }
	            else {
	                startPathStart = {
	                    x: start.x,
	                    y: start.y - gap / 2
	                };
	                startPathEnd = {
	                    x: end.x,
	                    y: end.y - gap / 2
	                };
	                endPathStart = {
	                    x: start.x,
	                    y: start.y + gap / 2
	                };
	                endPathEnd = {
	                    x: end.x,
	                    y: end.y + gap / 2
	                };
	            }
	            const startPath = generateZigzagPath(startPathStart, startPathEnd, size, isVertical ? 75 : 15, isVertical);
	            const centerPath = generateZigzagPath(start, end, size, isVertical ? 75 : 15, isVertical);
	            const endPath = generateZigzagPath(endPathStart, endPathEnd, size, isVertical ? 75 : 15, isVertical);
	            breakGroup.add(createPath(Object.assign(Object.assign({ path: startPath, stroke: '#000', lineWidth: 1 }, style), { pickable: false, zIndex: 1 })));
	            breakGroup.add(createPath(Object.assign(Object.assign({ path: endPath, stroke: '#000', lineWidth: 1 }, style), { pickable: false, zIndex: 1 })));
	            breakGroup.add(createPath({
	                path: centerPath,
	                stroke: '#fff',
	                lineWidth: gap,
	                pickable: false,
	                zIndex: 0
	            }));
	            breakGroup.name = 'series-break';
	            breakGroup.data = rest;
	            if (isValid$1(rest.axisId)) {
	                breakGroup.id = `${(_a = rest.axisId) !== null && _a !== void 0 ? _a : ''}_${id}`;
	            }
	            this.add(breakGroup);
	        });
	    }
	}
	const registerSeriesBreak = () => {
	    vchart.Factory.registerGraphicComponent('seriesBreak', (attrs) => new SeriesBreakComponent(attrs));
	};

	function getAllRegionBounds(regions) {
	    let { x: minX, y: minY } = regions[0].getLayoutStartPoint();
	    let maxX = minX + regions[0].getLayoutRect().width;
	    let maxY = minY + regions[0].getLayoutRect().height;
	    for (let index = 1; index < regions.length; index++) {
	        const region = regions[index];
	        const { x, y } = region.getLayoutStartPoint();
	        const { width, height } = region.getLayoutRect();
	        minX = Math.min(minX, x);
	        maxX = Math.max(maxX, width + x);
	        minY = Math.min(minY, y);
	        maxY = Math.max(maxY, height + y);
	    }
	    return {
	        x1: minX,
	        y1: minY,
	        x2: maxX,
	        y2: maxY
	    };
	}

	function isNumberEqual(a, b, precision = 1) {
	    return Math.abs(a - b) < precision;
	}

	const barOffset = 2;
	const lineOffset = 10;
	const areaOffset = 0;
	function getSeriesBreakConfig(axesSpec, axesIndex) {
	    return {
	        type: 'component',
	        componentType: SERIES_BREAK,
	        interactive: true,
	        zIndex: 500,
	        style: {
	            data: (datum, ctx) => {
	                const seriesBreakData = [];
	                const vchart = ctx.vchart;
	                const chart = vchart.getChart();
	                const series = chart.getAllSeries()[0];
	                const isHorizontal = series.direction === 'horizontal';
	                axesSpec.forEach((spec, index) => {
	                    var _a, _b;
	                    const axisId = spec.id;
	                    const axisModel = isValid$1(axisId)
	                        ? chart.getComponentByUserId(axisId)
	                        : axesIndex && isValid$1(axesIndex[index])
	                            ? chart.getComponentByIndex('axes', axesIndex[index])
	                            : (_a = chart.getComponentsByKey('axes').filter((axis) => {
	                                const axisInnerSpec = axis.getSpec();
	                                return axisInnerSpec.breaks === spec.breaks;
	                            })) === null || _a === void 0 ? void 0 : _a[0];
	                    if (!axisModel) {
	                        return;
	                    }
	                    const parsedAxisId = axisId !== null && axisId !== void 0 ? axisId : `${axisModel.type}-${axisModel.id}`;
	                    const regionBounds = getAllRegionBounds(axisModel.getRegions());
	                    array((_b = axisModel._break) === null || _b === void 0 ? void 0 : _b.breaks).forEach((breakConfig) => {
	                        const { range, breakSymbol, gap = 5 } = breakConfig;
	                        const pos1 = axisModel.valueToPosition(range[0]);
	                        const pos2 = axisModel.valueToPosition(range[1]);
	                        const posY = (pos1 + pos2) / 2 + (isHorizontal ? regionBounds.x1 : regionBounds.y1);
	                        chart.getAllSeries().forEach((s) => {
	                            if (s.type === 'bar' || s.type === 'waterfall') {
	                                const mark = s.getMarkInName('bar');
	                                const graphics = mark.getGraphics();
	                                graphics.forEach((element) => {
	                                    const elementBounds = element.AABBBounds;
	                                    let shouldDrawBreak = false;
	                                    let startX;
	                                    let startY;
	                                    let endX;
	                                    let endY;
	                                    if (isHorizontal) {
	                                        shouldDrawBreak =
	                                            elementBounds.x1 < (pos1 + pos2 - gap) / 2 &&
	                                                elementBounds.x2 > (pos1 + pos2 + gap) / 2;
	                                        startX = posY;
	                                        startY = Math.max(elementBounds.y1 + regionBounds.y1 - barOffset, regionBounds.y1);
	                                        endX = posY;
	                                        endY = Math.min(elementBounds.y2 + regionBounds.y1 + barOffset, regionBounds.y2);
	                                    }
	                                    else {
	                                        shouldDrawBreak =
	                                            elementBounds.y1 < (pos1 + pos2 - gap) / 2 &&
	                                                elementBounds.y2 > (pos1 + pos2 + gap) / 2;
	                                        startX = Math.max(elementBounds.x1 + regionBounds.x1 - barOffset, regionBounds.x1);
	                                        startY = posY;
	                                        endX = Math.min(elementBounds.x2 + regionBounds.x1 + barOffset, regionBounds.x2);
	                                        endY = posY;
	                                    }
	                                    if (shouldDrawBreak) {
	                                        seriesBreakData.push({
	                                            start: {
	                                                x: startX,
	                                                y: startY
	                                            },
	                                            end: {
	                                                x: endX,
	                                                y: endY
	                                            },
	                                            gap: gap,
	                                            style: breakSymbol === null || breakSymbol === void 0 ? void 0 : breakSymbol.style,
	                                            axisId: parsedAxisId,
	                                            data: range
	                                        });
	                                    }
	                                });
	                            }
	                            else if (s.type === 'line') {
	                                const mark = s.getMarkInName(s.type);
	                                const graphics = mark.getGraphics();
	                                graphics.forEach(graphicItem => {
	                                    const points = getAreaOrLinePathPoints(graphicItem, 'line');
	                                    points.forEach(linePoints => {
	                                        const intersections = getIntersectionsFromLineAndPolyline(isHorizontal
	                                            ? {
	                                                start: { x: (pos1 + pos2) / 2, y: 0 },
	                                                end: { x: (pos1 + pos2) / 2, y: regionBounds.y2 - regionBounds.y1 }
	                                            }
	                                            : {
	                                                start: { x: 0, y: (pos1 + pos2) / 2 },
	                                                end: { x: regionBounds.x2 - regionBounds.x1, y: (pos1 + pos2) / 2 }
	                                            }, linePoints);
	                                        intersections.forEach(intersection => {
	                                            let start;
	                                            let end;
	                                            if (isHorizontal) {
	                                                start = {
	                                                    x: posY,
	                                                    y: Math.max(intersection[1] + regionBounds.y1 - lineOffset, regionBounds.y1)
	                                                };
	                                                end = {
	                                                    x: posY,
	                                                    y: Math.min(intersection[1] + regionBounds.y1 + lineOffset, regionBounds.y2)
	                                                };
	                                            }
	                                            else {
	                                                start = {
	                                                    x: Math.max(intersection[0] + regionBounds.x1 - lineOffset, regionBounds.x1),
	                                                    y: posY
	                                                };
	                                                end = {
	                                                    x: Math.min(intersection[0] + regionBounds.x1 + lineOffset, regionBounds.x2),
	                                                    y: posY
	                                                };
	                                            }
	                                            seriesBreakData.push({
	                                                start,
	                                                end,
	                                                gap: gap,
	                                                style: breakSymbol === null || breakSymbol === void 0 ? void 0 : breakSymbol.style,
	                                                axisId: parsedAxisId,
	                                                data: range
	                                            });
	                                        });
	                                    });
	                                });
	                            }
	                            else if (s.type === 'area') {
	                                const mark = s.getMarkInName('area');
	                                const graphics = mark.getGraphics();
	                                graphics.forEach(graphicItem => {
	                                    const points = getAreaOrLinePathPoints(graphicItem, 'area');
	                                    points.forEach(areaPoints => {
	                                        const intersections = getIntersectionsFromLineAndPolyline(isHorizontal
	                                            ? {
	                                                start: { x: (pos1 + pos2) / 2, y: 0 },
	                                                end: { x: (pos1 + pos2) / 2, y: regionBounds.y2 - regionBounds.y1 }
	                                            }
	                                            : {
	                                                start: { x: 0, y: (pos1 + pos2) / 2 },
	                                                end: { x: regionBounds.x2 - regionBounds.x1, y: (pos1 + pos2) / 2 }
	                                            }, areaPoints);
	                                        intersections.sort((a, b) => a[0] - b[0]);
	                                        for (let index = 0; index < intersections.length - 1; index++) {
	                                            const lineStart = {
	                                                x: intersections[index][0],
	                                                y: intersections[index][1]
	                                            };
	                                            const lineEnd = {
	                                                x: intersections[index + 1][0],
	                                                y: intersections[index + 1][1]
	                                            };
	                                            if (isPointInPolygon(isHorizontal
	                                                ? {
	                                                    x: lineStart.x,
	                                                    y: (lineStart.y + lineEnd.y) / 2
	                                                }
	                                                : {
	                                                    x: (lineStart.x + lineEnd.x) / 2,
	                                                    y: lineStart.y
	                                                }, areaPoints)) {
	                                                let start;
	                                                let end;
	                                                if (isHorizontal) {
	                                                    start = {
	                                                        x: lineStart.x + regionBounds.x1,
	                                                        y: Math.max(lineStart.y + regionBounds.y1 - areaOffset, regionBounds.y1)
	                                                    };
	                                                    end = {
	                                                        x: lineEnd.x + regionBounds.x1,
	                                                        y: Math.min(lineEnd.y + regionBounds.y1 + areaOffset, regionBounds.y2)
	                                                    };
	                                                }
	                                                else {
	                                                    start = {
	                                                        x: Math.max(lineStart.x + regionBounds.x1 - areaOffset, regionBounds.x1),
	                                                        y: lineStart.y + regionBounds.y1
	                                                    };
	                                                    end = {
	                                                        x: Math.min(lineEnd.x + regionBounds.x1 + areaOffset, regionBounds.x2),
	                                                        y: lineEnd.y + regionBounds.y1
	                                                    };
	                                                }
	                                                seriesBreakData.push({
	                                                    start,
	                                                    end,
	                                                    gap: gap,
	                                                    style: breakSymbol === null || breakSymbol === void 0 ? void 0 : breakSymbol.style,
	                                                    axisId: parsedAxisId,
	                                                    data: range
	                                                });
	                                            }
	                                        }
	                                    });
	                                });
	                            }
	                        });
	                    });
	                });
	                return seriesBreakData;
	            }
	        }
	    };
	}
	function getIntersectionsFromLineAndPolyline(line, points) {
	    const intersections = [];
	    for (let index = 1; index < points.length; index++) {
	        const intersection = getIntersectPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [points[index].x, points[index].y], [points[index - 1].x, points[index - 1].y]);
	        if (intersection &&
	            !intersections.find(point => isNumberEqual(PointService.distancePP({ x: point[0], y: point[1] }, { x: intersection[0], y: intersection[1] }), 0))) {
	            intersections.push(intersection);
	        }
	    }
	    return intersections;
	}
	function getAreaOrLinePathPoints(shape, type) {
	    const { points, segments } = shape.attribute;
	    const pathPoints = [];
	    let eachPathPoints = [];
	    const parsePoints = (points) => {
	        if (points && points.length) {
	            let basePoints = [];
	            points.forEach(point => {
	                var _a, _b;
	                if (point.defined === false) {
	                    pathPoints.push(eachPathPoints);
	                    if (type === 'area' && basePoints.length) {
	                        for (let i = basePoints.length - 1; i >= 0; i--) {
	                            eachPathPoints.push({
	                                x: basePoints[i].x,
	                                y: basePoints[i].y
	                            });
	                        }
	                        eachPathPoints.push(eachPathPoints[0]);
	                    }
	                    eachPathPoints = [];
	                    basePoints = [];
	                }
	                else {
	                    eachPathPoints.push({
	                        x: point.x,
	                        y: point.y
	                    });
	                    type === 'area' && basePoints.push({ x: (_a = point.x1) !== null && _a !== void 0 ? _a : point.x, y: (_b = point.y1) !== null && _b !== void 0 ? _b : point.y });
	                }
	            });
	            if (type === 'area' && basePoints.length) {
	                for (let i = basePoints.length - 1; i >= 0; i--) {
	                    eachPathPoints.push({
	                        x: basePoints[i].x,
	                        y: basePoints[i].y
	                    });
	                }
	                eachPathPoints.push(eachPathPoints[0]);
	            }
	            pathPoints.push(eachPathPoints);
	        }
	    };
	    if (points && points.length) {
	        parsePoints(points);
	    }
	    else if (segments && segments.length) {
	        segments.forEach(seg => {
	            parsePoints(seg.points);
	        });
	    }
	    return pathPoints;
	}
	function isPointInPolygon(point, polygon) {
	    const { x, y } = point;
	    let inside = false;
	    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
	        const { x: xi, y: yi } = polygon[i];
	        const { x: xj, y: yj } = polygon[j];
	        const intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
	        if (intersect) {
	            inside = !inside;
	        }
	    }
	    return inside;
	}
	const appendSeriesBreakConfig = (rawSpec) => {
	    var _a;
	    if ((_a = rawSpec.axes) === null || _a === void 0 ? void 0 : _a.length) {
	        const breakedAxes = rawSpec.axes.filter((axis) => axis.breaks && axis.breaks.length && axis.visible !== false);
	        if (breakedAxes.length) {
	            rawSpec.customMark = array(rawSpec.customMark).filter((obj) => obj.componentType !== SERIES_BREAK);
	            rawSpec.customMark.push(getSeriesBreakConfig(breakedAxes, breakedAxes.map((axisSpec) => {
	                return rawSpec.axes.indexOf(axisSpec);
	            })));
	            return true;
	        }
	    }
	    return false;
	};

	const BAR_LINK = 'barLink';

	class BarLinkComponent extends AbstractComponent {
	    constructor() {
	        super(...arguments);
	        this.name = BAR_LINK;
	    }
	    render() {
	        const { data, linkStyle, areaStyle, styleMap, label, linkType = 'total' } = this.attribute;
	        if (isEmpty(data)) {
	            return;
	        }
	        this.removeAllChild();
	        data.forEach((datum, index) => {
	            var _a, _b, _c, _d, _e;
	            const { linePoints, areaPoints, id = index, color, data: curData } = datum;
	            if (areaPoints && ((_a = styleMap === null || styleMap === void 0 ? void 0 : styleMap[`area-${id}`]) === null || _a === void 0 ? void 0 : _a.visible) !== false) {
	                const area = createArea(Object.assign(Object.assign({ points: areaPoints, fillOpacity: 0.3, fill: color, zIndex: 0 }, areaStyle), styleMap === null || styleMap === void 0 ? void 0 : styleMap[`area-${id}`]));
	                area.name = 'bar-link-area';
	                area.id = `area-${id}`;
	                this.add(area);
	            }
	            if (linePoints &&
	                ((_b = styleMap === null || styleMap === void 0 ? void 0 : styleMap[`line-${id}`]) === null || _b === void 0 ? void 0 : _b.visible) !== false &&
	                ((_c = linkStyle === null || linkStyle === void 0 ? void 0 : linkStyle.lineStyle) === null || _c === void 0 ? void 0 : _c.lineWidth) !== 0 &&
	                ((_d = styleMap === null || styleMap === void 0 ? void 0 : styleMap[`line-${id}`]) === null || _d === void 0 ? void 0 : _d.lineWidth) !== 0) {
	                const { startSymbol = {}, endSymbol = {}, lineStyle } = linkStyle || {};
	                const startSymbolAttrs = cloneDeep(startSymbol);
	                const endSymbolAttrs = cloneDeep(endSymbol);
	                if ((styleMap === null || styleMap === void 0 ? void 0 : styleMap[`line-${id}`]) && styleMap[`line-${id}`].stroke) {
	                    startSymbolAttrs.style = Object.assign(Object.assign({}, startSymbolAttrs.style), { color: styleMap[`line-${id}`].stroke });
	                    endSymbolAttrs.style = Object.assign(Object.assign({}, endSymbolAttrs.style), { color: styleMap[`line-${id}`].stroke });
	                }
	                if (!startSymbolAttrs.symbolType && !startSymbolAttrs.originSymbolType) {
	                    startSymbolAttrs.originSymbolType = 'solidArrow';
	                }
	                if (!endSymbolAttrs.symbolType && !endSymbolAttrs.originSymbolType) {
	                    endSymbolAttrs.originSymbolType = 'solidArrow';
	                }
	                const line = new Segment({
	                    points: linePoints,
	                    startSymbol: Object.assign({ size: 8 }, startSymbolAttrs),
	                    endSymbol: Object.assign({ size: 8 }, endSymbolAttrs),
	                    lineStyle: Object.assign(Object.assign({ lineDash: [3, 3], lineWidth: 1, stroke: '#000' }, lineStyle), styleMap === null || styleMap === void 0 ? void 0 : styleMap[`line-${id}`]),
	                    pickable: true,
	                    childrenPickable: false,
	                    zIndex: 1
	                });
	                line.name = 'bar-link-line';
	                line.id = `line-${id}`;
	                this.add(line);
	            }
	            if ((label === null || label === void 0 ? void 0 : label.visible) && ((_e = styleMap === null || styleMap === void 0 ? void 0 : styleMap[`label-${id}`]) === null || _e === void 0 ? void 0 : _e.visible) !== false) {
	                const { style, formatMethod } = label;
	                const [startData, endData] = curData;
	                let startValue = startData[vchart.STACK_FIELD_END];
	                let endValue = endData[vchart.STACK_FIELD_END];
	                if (linkType === 'value') {
	                    startValue = startData[vchart.STACK_FIELD_END] - startData[vchart.STACK_FIELD_START];
	                    endValue = endData[vchart.STACK_FIELD_END] - endData[vchart.STACK_FIELD_START];
	                }
	                const value = endValue - startValue;
	                const percentage = ((endValue - startValue) / startValue) * 100;
	                const text = createText(Object.assign(Object.assign({ x: (linePoints[0].x + linePoints[1].x) * 0.5, y: (linePoints[0].y + linePoints[1].y) * 0.5, text: formatMethod ? formatMethod(value, percentage, curData) : `${value} ${percentage}`, fontSize: 14, fill: '#000', stroke: '#fff', lineWidth: 1, textAlign: 'center', textBaseline: 'middle', background: '#fff', zIndex: 2 }, style), styleMap === null || styleMap === void 0 ? void 0 : styleMap[`label-${id}`]));
	                text.name = 'bar-link-label';
	                text.id = `label-${id}`;
	                this.add(text);
	            }
	        });
	    }
	}
	const registerBarLink = () => {
	    vchart.Factory.registerGraphicComponent(BAR_LINK, (attrs) => new BarLinkComponent(attrs));
	};

	function groupBarsByFields(elements, groupFields) {
	    const result = {};
	    for (let i = 0; i < elements.length; i++) {
	        const item = elements[i];
	        const itemData = vchart.getDatumOfGraphic(item);
	        const groupKey = groupFields.map(field => itemData[field]).join('-');
	        if (!result[groupKey]) {
	            result[groupKey] = [];
	        }
	        result[groupKey].push(item);
	    }
	    return result;
	}
	function getLinkData(currentElement, nextElement, config) {
	    const { isHorizontal, isXAxisInverse, isYAxisInverse, linkType, doFill, regionStartX, regionStartY } = config;
	    const currentBarBounds = currentElement.AABBBounds;
	    const nextBarBounds = nextElement.AABBBounds;
	    let linePoints;
	    let areaPoints;
	    if (isHorizontal) {
	        linePoints = [
	            {
	                x: (currentBarBounds.x1 + currentBarBounds.x2) / 2 + regionStartX,
	                y: currentBarBounds.y1 + regionStartY
	            },
	            {
	                x: (nextBarBounds.x1 + nextBarBounds.x2) / 2 + regionStartX,
	                y: nextBarBounds.y2 + regionStartY
	            }
	        ];
	        if (isXAxisInverse) {
	            if (linkType === 'total') {
	                linePoints = [
	                    {
	                        x: currentBarBounds.x1 + regionStartX,
	                        y: currentBarBounds.y1 + regionStartY
	                    },
	                    {
	                        x: nextBarBounds.x1 + regionStartX,
	                        y: nextBarBounds.y2 + regionStartY
	                    }
	                ];
	            }
	            if (doFill) {
	                areaPoints = [
	                    {
	                        x: currentBarBounds.x1 + regionStartX,
	                        x1: currentBarBounds.x2 + regionStartX,
	                        y: currentBarBounds.y1 + regionStartY
	                    },
	                    {
	                        x: nextBarBounds.x1 + regionStartX,
	                        x1: nextBarBounds.x2 + regionStartX,
	                        y: nextBarBounds.y2 + regionStartY
	                    }
	                ];
	            }
	        }
	        else {
	            if (linkType === 'total') {
	                linePoints = [
	                    {
	                        x: currentBarBounds.x2 + regionStartX,
	                        y: currentBarBounds.y1 + regionStartY
	                    },
	                    {
	                        x: nextBarBounds.x2 + regionStartX,
	                        y: nextBarBounds.y2 + regionStartY
	                    }
	                ];
	            }
	            if (doFill) {
	                areaPoints = [
	                    {
	                        x: currentBarBounds.x2 + regionStartX,
	                        x1: currentBarBounds.x1 + regionStartX,
	                        y: currentBarBounds.y1 + regionStartY
	                    },
	                    {
	                        x: nextBarBounds.x2 + regionStartX,
	                        x1: nextBarBounds.x1 + regionStartX,
	                        y: nextBarBounds.y2 + regionStartY
	                    }
	                ];
	            }
	        }
	    }
	    else {
	        linePoints = [
	            {
	                x: currentBarBounds.x2 + regionStartX,
	                y: (currentBarBounds.y1 + currentBarBounds.y2) / 2 + regionStartY
	            },
	            {
	                x: nextBarBounds.x1 + regionStartX,
	                y: (nextBarBounds.y1 + nextBarBounds.y2) / 2 + regionStartY
	            }
	        ];
	        if (isYAxisInverse) {
	            if (linkType === 'total') {
	                linePoints = [
	                    {
	                        x: currentBarBounds.x2 + regionStartX,
	                        y: currentBarBounds.y2 + regionStartY
	                    },
	                    {
	                        x: nextBarBounds.x1 + regionStartX,
	                        y: nextBarBounds.y2 + regionStartY
	                    }
	                ];
	            }
	            if (doFill) {
	                areaPoints = [
	                    {
	                        x: currentBarBounds.x2 + regionStartX,
	                        y: currentBarBounds.y2 + regionStartY,
	                        y1: currentBarBounds.y1 + regionStartY
	                    },
	                    {
	                        x: nextBarBounds.x1 + regionStartX,
	                        y: nextBarBounds.y2 + regionStartY,
	                        y1: nextBarBounds.y1 + regionStartY
	                    }
	                ];
	            }
	        }
	        else {
	            if (linkType === 'total') {
	                linePoints = [
	                    {
	                        x: currentBarBounds.x2 + regionStartX,
	                        y: currentBarBounds.y1 + regionStartY
	                    },
	                    {
	                        x: nextBarBounds.x1 + regionStartX,
	                        y: nextBarBounds.y1 + regionStartY
	                    }
	                ];
	            }
	            if (doFill) {
	                areaPoints = [
	                    {
	                        x: currentBarBounds.x2 + regionStartX,
	                        y: currentBarBounds.y1 + regionStartY,
	                        y1: currentBarBounds.y2 + regionStartY
	                    },
	                    {
	                        x: nextBarBounds.x1 + regionStartX,
	                        y: nextBarBounds.y1 + regionStartY,
	                        y1: nextBarBounds.y2 + regionStartY
	                    }
	                ];
	            }
	        }
	    }
	    return {
	        areaPoints,
	        linePoints,
	        data: [vchart.getDatumOfGraphic(currentElement), vchart.getDatumOfGraphic(nextElement)],
	        color: currentElement.attribute.fill
	    };
	}
	function getBarLinkConfig(style = {}, extraStyle) {
	    const { linkType = 'total', doFill } = style, rest = __rest$1(style, ["linkType", "doFill"]);
	    return {
	        type: 'component',
	        componentType: BAR_LINK,
	        zIndex: 500,
	        interactive: false,
	        style: Object.assign(Object.assign({ data: (datum, context) => {
	                const { vchart: vchart$1 } = context;
	                const regions = vchart$1.getChart().getAllRegions();
	                const linkLineData = [];
	                regions.forEach((region) => {
	                    const barSeriesArr = region
	                        .getSeries()
	                        .filter((s) => s.type === 'bar');
	                    const { x: regionStartX, y: regionStartY } = region.getLayoutStartPoint();
	                    if (barSeriesArr.length) {
	                        const groupFields = barSeriesArr[0].getGroupFields();
	                        const allBarElements = [];
	                        barSeriesArr.forEach(barSeries => {
	                            var _a;
	                            const barGraphicElements = (_a = barSeries.getMarkInName('bar')) === null || _a === void 0 ? void 0 : _a.getGraphics();
	                            barGraphicElements.forEach(barElement => {
	                                allBarElements.push(barElement);
	                            });
	                        });
	                        const groupData = groupBarsByFields(allBarElements, groupFields);
	                        Object.values(groupData).forEach((groupedValues) => {
	                            groupedValues.sort((prev, curr) => {
	                                return (vchart.getDatumOfGraphic(prev)[vchart.STACK_FIELD_END] -
	                                    vchart.getDatumOfGraphic(curr)[vchart.STACK_FIELD_END]);
	                            });
	                        });
	                        const barSeries = barSeriesArr[0];
	                        const isHorizontal = barSeries.direction === 'horizontal';
	                        const isYAxisInverse = barSeries.getYAxisHelper().isInverse();
	                        const isXAxisInverse = barSeries.getXAxisHelper().isInverse();
	                        const groupValues = Object.values(groupData);
	                        if (groupValues.length) {
	                            if (isHorizontal) {
	                                const firstElementPosY = groupValues[0][0].AABBBounds.y1;
	                                const lastElementPosY = groupValues[groupValues.length - 1][0].AABBBounds.y1;
	                                if (firstElementPosY < lastElementPosY) {
	                                    groupValues.reverse();
	                                }
	                            }
	                            else {
	                                const firstElementPosX = groupValues[0][0].AABBBounds.x1;
	                                const lastElementPosX = groupValues[groupValues.length - 1][0].AABBBounds.x1;
	                                if (firstElementPosX > lastElementPosX) {
	                                    groupValues.reverse();
	                                }
	                            }
	                        }
	                        for (let index = 0; index < groupValues.length - 1; index++) {
	                            const currentValues = groupValues[index];
	                            const nextValues = groupValues[index + 1];
	                            currentValues.forEach((element, elementIndex) => {
	                                var _a;
	                                const nextElement = (_a = nextValues[elementIndex]) !== null && _a !== void 0 ? _a : nextValues[nextValues.length - 1];
	                                const linkData = getLinkData(element, nextElement, {
	                                    isHorizontal,
	                                    isXAxisInverse,
	                                    isYAxisInverse,
	                                    doFill,
	                                    linkType,
	                                    regionStartX,
	                                    regionStartY
	                                });
	                                linkLineData.push(linkData);
	                            });
	                            if (currentValues.length < nextValues.length) {
	                                const lastElementOfCurrentElement = currentValues[currentValues.length - 1];
	                                for (let i = currentValues.length; i < nextValues.length; i++) {
	                                    const nextElement = nextValues[i];
	                                    const linkData = getLinkData(lastElementOfCurrentElement, nextElement, {
	                                        isHorizontal,
	                                        isXAxisInverse,
	                                        isYAxisInverse,
	                                        doFill,
	                                        linkType,
	                                        regionStartX,
	                                        regionStartY
	                                    });
	                                    linkLineData.push(linkData);
	                                }
	                            }
	                        }
	                    }
	                });
	                return linkLineData;
	            }, linkType }, rest), extraStyle)
	    };
	}
	function appendBarLinkConfig(rawSpec, barLinkSpec) {
	    rawSpec.customMark = array(rawSpec.customMark).filter((obj) => obj.componentType !== BAR_LINK);
	    rawSpec.customMark.push(getBarLinkConfig(barLinkSpec));
	}

	const SERIES_LABEL = 'seriesLabel';

	function range(start, stop, step) {
	    start = +start;
	    stop = +stop;
	    let n = arguments.length;
	    step = n < 2 ? ((stop = start), (start = 0), 1) : n < 3 ? 1 : +step;
	    let i = -1;
	    n = Math.max(0, Math.ceil((stop - start) / step)) | 0;
	    const range = new Array(n);
	    while (++i < n) {
	        range[i] = start + i * step;
	    }
	    return range;
	}
	function ascending(a, b) {
	    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}
	function dodge(positions, separation = 10, maxIter = 10, maxError = 1e-1) {
	    const n = positions.length;
	    if (!positions.every(isFinite)) {
	        return positions;
	    }
	    if (!(n > 1)) {
	        return positions;
	    }
	    const index = range(positions.length);
	    for (let iter = 0; iter < maxIter; ++iter) {
	        index.sort((i, j) => ascending(positions[i], positions[j]));
	        let error = 0;
	        for (let i = 1; i < n; ++i) {
	            let delta = positions[index[i]] - positions[index[i - 1]];
	            if (delta < separation) {
	                delta = (separation - delta) / 2;
	                error = Math.max(error, delta);
	                positions[index[i - 1]] -= delta;
	                positions[index[i]] += delta;
	            }
	        }
	        if (error < maxError) {
	            break;
	        }
	    }
	    return positions;
	}
	function isOverlap(box1, box2) {
	    return !(box2.x1 > box1.x2 || box2.x2 < box1.x1 || box2.y1 > box1.y2 || box2.y2 < box1.y1);
	}
	function dodgeHorizontal(texts, separation = 10, maxIter = 10) {
	    const n = texts.length;
	    let hasOverlap;
	    let iter = 0;
	    do {
	        hasOverlap = false;
	        for (let i = 0; i < n; ++i) {
	            for (let j = i + 1; j < n; ++j) {
	                const box1 = texts[i].AABBBounds;
	                const box2 = texts[j].AABBBounds;
	                if (isOverlap(box1, box2)) {
	                    const delta = separation - (box2.x1 - box1.x2);
	                    if (delta > 0) {
	                        texts[j].attribute.x += delta;
	                        box2.x1 += delta;
	                        box2.x2 += delta;
	                        hasOverlap = true;
	                    }
	                }
	            }
	        }
	        iter++;
	    } while (hasOverlap && iter < maxIter);
	}
	function getSeriesLabelConfig(position, config) {
	    const { label, line } = config;
	    return {
	        type: 'component',
	        componentType: SERIES_LABEL,
	        interactive: false,
	        style: {
	            position,
	            layout: (datum, ctx) => {
	                var _a;
	                const vchart = ctx.vchart;
	                const series = vchart.getChart().getAllSeries()[0];
	                return (_a = series.getSpec().direction) !== null && _a !== void 0 ? _a : 'vertical';
	            },
	            data: (datum, ctx) => {
	                var _a;
	                const vchart = ctx.vchart;
	                const chart = vchart.getChart();
	                const series = chart.getAllSeries()[0];
	                const isTransposed = series.direction === 'horizontal';
	                const bandAxisHelper = (isTransposed ? series.getYAxisHelper() : series.getXAxisHelper());
	                const bandAxisScale = (_a = bandAxisHelper.getScale) === null || _a === void 0 ? void 0 : _a.call(bandAxisHelper, 0);
	                const isBandAxisInverse = bandAxisHelper.isInverse();
	                const dimensionField = series.getDimensionField()[0];
	                const seriesField = series.getSeriesField();
	                const seriesTypes = chart
	                    .getAllSeries()
	                    .map((s) => s.type)
	                    .filter((value, index, self) => {
	                    return self.indexOf(value) === index;
	                });
	                const labelData = [];
	                if (seriesTypes.length === 1 && ['bar', 'area', 'line', 'waterfall'].includes(seriesTypes[0])) {
	                    const positions = position === 'both-ends' ? ['start', 'end'] : [position];
	                    positions.forEach(pos => {
	                        const targetValue = pos === 'end' ? last(bandAxisScale.domain()) : bandAxisScale.domain()[0];
	                        const region = series.getRegion();
	                        const { x: regionStartX, y: regionStartY } = region.getLayoutStartPoint();
	                        let i = 0;
	                        chart.getAllSeries().forEach((s) => {
	                            const mark = s.getMarkInName(seriesTypes[0] === 'waterfall' ? 'bar' : seriesTypes[0]);
	                            const graphics = mark.getGraphics();
	                            graphics.forEach((g) => {
	                                var _a;
	                                const data = g.context.data.find((datum) => datum[dimensionField] === targetValue);
	                                if (data) {
	                                    const graphBounds = g.AABBBounds;
	                                    let point;
	                                    let color;
	                                    if (seriesTypes[0] === 'bar' || seriesTypes[0] === 'waterfall') {
	                                        point =
	                                            pos === 'end'
	                                                ? {
	                                                    x: isTransposed
	                                                        ? (graphBounds.x1 + graphBounds.x2) / 2
	                                                        : isBandAxisInverse
	                                                            ? graphBounds.x1
	                                                            : graphBounds.x2,
	                                                    y: isTransposed
	                                                        ? isBandAxisInverse
	                                                            ? graphBounds.y2
	                                                            : graphBounds.y1
	                                                        : (graphBounds.y1 + graphBounds.y2) / 2
	                                                }
	                                                : {
	                                                    x: isTransposed
	                                                        ? (graphBounds.x1 + graphBounds.x2) / 2
	                                                        : isBandAxisInverse
	                                                            ? graphBounds.x2
	                                                            : graphBounds.x1,
	                                                    y: isTransposed
	                                                        ? isBandAxisInverse
	                                                            ? graphBounds.y1
	                                                            : graphBounds.y2
	                                                        : (graphBounds.y1 + graphBounds.y2) / 2
	                                                };
	                                        color = g.attribute.fill;
	                                    }
	                                    else {
	                                        point = s.dataToPosition(data);
	                                        color = g.attribute.stroke || g.attribute.fill;
	                                    }
	                                    let textAlign;
	                                    let textBaseline;
	                                    if (pos === 'end') {
	                                        textAlign = isTransposed ? 'center' : isBandAxisInverse ? 'end' : 'start';
	                                        textBaseline = isTransposed ? (isBandAxisInverse ? 'top' : 'bottom') : 'middle';
	                                    }
	                                    else {
	                                        textAlign = isTransposed ? 'center' : isBandAxisInverse ? 'start' : 'end';
	                                        textBaseline = isTransposed ? (isBandAxisInverse ? 'bottom' : 'top') : 'middle';
	                                    }
	                                    const labelValue = (_a = data[seriesField]) !== null && _a !== void 0 ? _a : data[dimensionField];
	                                    labelData.push({
	                                        point: {
	                                            x: point.x + regionStartX,
	                                            y: point.y + regionStartY
	                                        },
	                                        label: labelValue,
	                                        color: color,
	                                        textAlign,
	                                        textBaseline,
	                                        series: s,
	                                        datum: data,
	                                        id: `${pos}-${i}`,
	                                        position: pos
	                                    });
	                                    i++;
	                                }
	                            });
	                        });
	                    });
	                }
	                return labelData;
	            },
	            line,
	            label: Object.assign({ space: 12 }, label)
	        }
	    };
	}
	function appendSeriesLabelConfig(rawSpec, seriesLabelSpec) {
	    var _a, _b, _c;
	    rawSpec.customMark = array(rawSpec.customMark).filter((obj) => obj.componentType !== SERIES_LABEL);
	    if (!seriesLabelSpec) {
	        seriesLabelSpec = (_c = (_a = get$1(rawSpec, SERIES_LABEL)) !== null && _a !== void 0 ? _a : get$1((_b = rawSpec.series) === null || _b === void 0 ? void 0 : _b[0], SERIES_LABEL)) !== null && _c !== void 0 ? _c : {};
	    }
	    if (seriesLabelSpec.visible) {
	        const { position = 'end' } = seriesLabelSpec, rest = __rest$1(seriesLabelSpec, ["position"]);
	        rawSpec.customMark.push(getSeriesLabelConfig(position, rest));
	    }
	}

	class SeriesLabelComponent extends AbstractComponent {
	    constructor() {
	        super(...arguments);
	        this.name = SERIES_LABEL;
	    }
	    render() {
	        var _a, _b, _c, _d;
	        this.removeAllChild();
	        const { data, layout, label, line = {} } = this.attribute;
	        if (isEmpty(data)) {
	            return;
	        }
	        const labelStyleMap = (_a = label === null || label === void 0 ? void 0 : label.styleMap) !== null && _a !== void 0 ? _a : {};
	        const adjustedPoints = {};
	        const filteredData = data.filter(datum => { var _a; return ((_a = labelStyleMap[datum.id]) === null || _a === void 0 ? void 0 : _a.visible) !== false; });
	        if (layout === 'vertical') {
	            const lineHeight = ((_c = (_b = label === null || label === void 0 ? void 0 : label.style) === null || _b === void 0 ? void 0 : _b.fontSize) !== null && _c !== void 0 ? _c : 12) * 1.5;
	            const createAndAddTextGraphic = (datum, textPoint, labelStyleMap) => {
	                var _a, _b, _c, _d, _e, _f, _g, _h;
	                const { label: text, color, textAlign, textBaseline, id } = datum;
	                const formatMethod = (_b = (_a = labelStyleMap[id]) === null || _a === void 0 ? void 0 : _a.formatMethod) !== null && _b !== void 0 ? _b : (_c = this.attribute.label) === null || _c === void 0 ? void 0 : _c.formatMethod;
	                const textGraphic = createText(Object.assign(Object.assign(Object.assign(Object.assign({ text: formatMethod
	                        ? formatMethod(text, datum.datum, {
	                            series: datum.series
	                        })
	                        : text }, (_d = this.attribute.label) === null || _d === void 0 ? void 0 : _d.style), textPoint), { textAlign,
	                    textBaseline, fill: (_g = (_f = (_e = this.attribute.label) === null || _e === void 0 ? void 0 : _e.style) === null || _f === void 0 ? void 0 : _f.fill) !== null && _g !== void 0 ? _g : color }), (_h = labelStyleMap[id]) === null || _h === void 0 ? void 0 : _h.style));
	                textGraphic.name = 'series-label-text';
	                textGraphic.id = id;
	                this.add(textGraphic);
	                return textGraphic;
	            };
	            ['start', 'end'].forEach(position => {
	                const posData = filteredData.filter(datum => datum.position === position);
	                const posYArr = posData.map(datum => datum.point.y);
	                const dodgedPosY = dodge(posYArr, lineHeight);
	                posData.forEach((datum, index) => {
	                    var _a;
	                    const textPoint = {
	                        x: datum.point.x + ((_a = label === null || label === void 0 ? void 0 : label.space) !== null && _a !== void 0 ? _a : 8) * (datum.textAlign === 'start' ? 1 : -1),
	                        y: dodgedPosY[index]
	                    };
	                    createAndAddTextGraphic(datum, textPoint, labelStyleMap);
	                    adjustedPoints[datum.id] = textPoint;
	                });
	            });
	        }
	        else {
	            const startTexts = [];
	            const endTexts = [];
	            filteredData.forEach(datum => {
	                var _a, _b, _c, _d, _e;
	                const { point, label: text, color, textAlign, textBaseline, id, position } = datum;
	                const textPoint = {
	                    x: point.x,
	                    y: point.y
	                };
	                const formatMethod = (_b = (_a = labelStyleMap[id]) === null || _a === void 0 ? void 0 : _a.formatMethod) !== null && _b !== void 0 ? _b : label === null || label === void 0 ? void 0 : label.formatMethod;
	                const textGraphic = createText(Object.assign(Object.assign(Object.assign(Object.assign({ text: formatMethod
	                        ? formatMethod(text, datum.datum, {
	                            series: datum.series
	                        })
	                        : text }, label === null || label === void 0 ? void 0 : label.style), textPoint), { textAlign,
	                    textBaseline, fill: (_d = (_c = label === null || label === void 0 ? void 0 : label.style) === null || _c === void 0 ? void 0 : _c.fill) !== null && _d !== void 0 ? _d : color }), (_e = labelStyleMap[id]) === null || _e === void 0 ? void 0 : _e.style));
	                textGraphic.id = id;
	                textGraphic.name = 'series-label-text';
	                this.add(textGraphic);
	                if (position === 'start') {
	                    startTexts.push(textGraphic);
	                }
	                else if (position === 'end') {
	                    endTexts.push(textGraphic);
	                }
	            });
	            startTexts.length && dodgeHorizontal(startTexts, 4, 10);
	            endTexts.length && dodgeHorizontal(endTexts, 4, 10);
	            const labelSpace = (_d = label === null || label === void 0 ? void 0 : label.space) !== null && _d !== void 0 ? _d : 8;
	            [...startTexts, ...endTexts].forEach((text) => {
	                const flag = text.attribute.textBaseline === 'top' ? 1 : -1;
	                text.setAttribute('y', text.attribute.y + labelSpace * flag);
	                adjustedPoints[text.id] = {
	                    x: text.attribute.x,
	                    y: text.attribute.y
	                };
	            });
	        }
	        if (line.visible !== false) {
	            filteredData.forEach(datum => {
	                var _a, _b, _c, _d, _e, _f;
	                const { point: start, color, id } = datum;
	                const end = {
	                    x: adjustedPoints[id].x + ((_c = (_b = (_a = labelStyleMap[id]) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.dx) !== null && _c !== void 0 ? _c : 0),
	                    y: adjustedPoints[id].y + ((_f = (_e = (_d = labelStyleMap[id]) === null || _d === void 0 ? void 0 : _d.style) === null || _e === void 0 ? void 0 : _e.dy) !== null && _f !== void 0 ? _f : 0)
	                };
	                if (line.autoVisible !== false) {
	                    if ((layout === 'vertical' && start.y !== end.y) || (layout === 'horizontal' && start.x !== end.x)) {
	                        const lineShape = createLine(Object.assign({ points: [start, end], lineWidth: 1, stroke: color }, line.style));
	                        lineShape.name = 'series-label-line';
	                        this.add(lineShape);
	                    }
	                }
	                else {
	                    const lineShape = createLine(Object.assign({ points: [start, end], lineWidth: 1, stroke: color }, line.style));
	                    lineShape.name = 'series-label-line';
	                    this.add(lineShape);
	                }
	            });
	        }
	    }
	}
	const registerSeriesLabel = () => {
	    vchart.Factory.registerGraphicComponent('seriesLabel', (attrs) => new SeriesLabelComponent(attrs));
	};

	function overlap(a, b, sep = 0) {
	    return sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);
	}
	function bound(rect) {
	    return {
	        x1: rect.x,
	        x2: rect.x + rect.width,
	        y1: rect.y,
	        y2: rect.y + rect.height
	    };
	}
	function toRect(bound) {
	    return {
	        x: bound.x1,
	        y: bound.y1,
	        width: bound.x2 - bound.x1,
	        height: bound.y2 - bound.y1
	    };
	}
	function layoutByPosition(pairs) {
	    var _a;
	    if (!pairs || pairs.length === 0) {
	        return [];
	    }
	    if (pairs.length === 1) {
	        return [pairs[0].rect];
	    }
	    const _pairs = pairs.map(pair => {
	        var _a;
	        return Object.assign(Object.assign({}, pair), { bound: bound(pair.rect), anchorCandidates: candidatesByOrient((_a = pair.anchors) !== null && _a !== void 0 ? _a : [], pair.point, pair.rect, pair.offset) });
	    });
	    const resultBound = [];
	    resultBound.push(_pairs[0].bound);
	    for (let i = 1; i <= _pairs.length - 1; i++) {
	        const curPair = _pairs[i];
	        const curBound = curPair.bound;
	        let isOverlap = resultBound.some(r => overlap(r, curBound));
	        if (!curPair.anchorCandidates) {
	            continue;
	        }
	        if (isOverlap && ((_a = curPair.anchorCandidates) === null || _a === void 0 ? void 0 : _a.length) > 0) {
	            for (let j = 0; j < curPair.anchorCandidates.length; j++) {
	                const anchor = curPair.anchorCandidates[j];
	                const newBound = {
	                    x1: anchor.x,
	                    y1: anchor.y,
	                    x2: anchor.x + curBound.x2 - curBound.x1,
	                    y2: anchor.y + curBound.y2 - curBound.y1,
	                    anchor
	                };
	                if (!resultBound.some(r => overlap(r, newBound))) {
	                    resultBound.push(newBound);
	                    isOverlap = false;
	                    break;
	                }
	            }
	            if (isOverlap) {
	                resultBound.push(curPair.bound);
	            }
	        }
	        else {
	            resultBound.push(curPair.bound);
	        }
	    }
	    return resultBound.map(bound => toRect(bound));
	}
	function layoutOuter(pairs, features, dataToPosition) {
	    const _points = pairs.map(rect => rect.pointCoord);
	    const { x1, x2, y1, y2 } = getAABBFromPoints(_points);
	    const geoCenter = [(x1 + x2) / 2, (y1 + y2) / 2];
	    const centerPosition = dataToPosition(geoCenter);
	    if (!centerPosition) {
	        return [];
	    }
	    const result = pairs.map(pair => {
	        const rect = pair.rect;
	        const targetPoint = !isPointWithinFeatures(features, pair.pointCoord)
	            ? pair.point
	            : dataToPosition(nearestPoint(features, [pair.pointCoord.x, pair.pointCoord.y], uniformDegree(lineDegree(pair.point, centerPosition))));
	        if (targetPoint) {
	            rect.x = targetPoint.x;
	            rect.y = targetPoint.y;
	        }
	        const degree = uniformDegree(lineDegree(pair.point, centerPosition));
	        let position;
	        const anchors = [];
	        if (degree >= -45 && degree < 45) {
	            position = 'top';
	            anchors.push('left', 'right');
	        }
	        else if (degree >= 45 && degree < 135) {
	            position = 'right';
	        }
	        else if (degree >= -135 && degree < -45) {
	            position = 'left';
	            anchors.push('left');
	        }
	        else {
	            position = 'bottom';
	            anchors.push('left', 'right');
	        }
	        pair.anchors = anchors;
	        pair.offset = 20;
	        pair.rect = placeRectByOrient(pair.rect, position, 0);
	        return pair;
	    });
	    return layoutByPosition(result);
	}
	function uniformDegree(degree) {
	    return degree > 180 ? degree - 360 : degree;
	}
	function lineDegree(start, end) {
	    return (Math.atan2(start.y - end.y, start.x - end.x) * 180) / Math.PI + 90;
	}
	function nearestPoint(features, origin, bearing, distance = 200) {
	    const count = 5621 / distance;
	    let curOrigin = origin;
	    for (let i = 1; i <= count; i++) {
	        const dest = destination(curOrigin, distance, bearing);
	        if (!isPointWithinFeatures(features, dest)) {
	            return [dest.x, dest.y];
	        }
	        curOrigin = [dest.x, dest.y];
	    }
	    return origin;
	}
	function isPointWithinFeatures(features, p) {
	    for (let i = 0; i < features.length; i++) {
	        const inside = isPointInPolygon$1(p, features[i]);
	        if (inside) {
	            return true;
	        }
	    }
	    return false;
	}
	function placeRectByOrient(rect, position, offset = 0) {
	    const result = Object.assign({}, rect);
	    if (position === 'top') {
	        result.x -= rect.width / 2;
	        result.y -= offset + rect.height / 2;
	    }
	    else if (position === 'bottom') {
	        result.x -= rect.width / 2;
	        result.y += offset - rect.height / 2;
	    }
	    else if (position === 'left') {
	        result.x -= offset + rect.width;
	        result.y -= rect.height / 2;
	    }
	    else if (position === 'right') {
	        result.x += offset;
	        result.y -= rect.height / 2;
	    }
	    return result;
	}
	function candidatesByOrient(positions, anchor, rect, offset = 0) {
	    const candidates = [];
	    positions.forEach((p) => {
	        const { x, y } = placeRectByOrient(Object.assign(Object.assign({}, anchor), { width: rect.width, height: rect.height }), p, offset);
	        candidates.push({ x, y });
	    });
	    return candidates;
	}

	const getLabelSpec = () => {
	    return {
	        visible: true,
	        style: {
	            textBaseline: 'middle',
	            textAlign: 'left',
	            fill: 'black',
	            fontSize: 10
	        }
	    };
	};
	const mapLabel = {
	    visible: true,
	    offset: 12,
	    position: 'top',
	    space: 10,
	    nameLabel: getLabelSpec(),
	    valueLabel: getLabelSpec(),
	    background: {
	        visible: true,
	        padding: { top: 4, bottom: 4, left: 6, right: 6 },
	        style: {
	            cornerRadius: 2,
	            lineWidth: 1,
	            fill: 'white',
	            stroke: 'grey'
	        }
	    },
	    leader: {
	        visible: false,
	        style: {
	            lineWidth: 1,
	            stroke: 'black'
	        }
	    }
	};

	class MapLabelSpecTransformer extends vchart.BaseComponentSpecTransformer {
	    _getDefaultSpecFromChart() {
	        return mapLabel;
	    }
	}

	class MapLabelComponent extends vchart.BaseComponent {
	    constructor() {
	        super(...arguments);
	        this.type = 'mapLabel';
	        this.name = ' mapLabel';
	        this.specKey = 'mapLabel';
	        this.transformerConstructor = MapLabelSpecTransformer;
	        this.layoutType = 'none';
	        this.layoutZIndex = vchart.LayoutZIndex.MarkPoint;
	        this._activeDatum = [];
	    }
	    static getSpecInfo(chartSpec) {
	        return vchart.getSpecInfo(chartSpec, this.specKey, this.type, (s) => {
	            return s.visible && isValid$1(s.seriesId);
	        });
	    }
	    setAttrFromSpec() {
	        var _a, _b, _c, _d;
	        this.nameField = (_a = this._spec.nameField) !== null && _a !== void 0 ? _a : (_b = this._series) === null || _b === void 0 ? void 0 : _b.getDimensionField()[0];
	        this.valueField = (_c = this._spec.valueField) !== null && _c !== void 0 ? _c : (_d = this._series) === null || _d === void 0 ? void 0 : _d.getMeasureField()[0];
	    }
	    created() {
	        super.created();
	        if (!!this._spec.visible === false) {
	            return;
	        }
	        this.initRelatedInfo();
	        this.initData();
	        this.initEvent();
	    }
	    initRelatedInfo() {
	        var _a, _b, _c, _d, _e, _f, _g, _h;
	        this._series = this._option.getSeriesInUserIdOrIndex([this._spec.seriesId])[0];
	        if (this._spec.position === 'outer') {
	            this._map = (_b = (_a = this._regions[0].getSeriesInType('map')[0]) === null || _a === void 0 ? void 0 : _a.getMapViewData()) === null || _b === void 0 ? void 0 : _b.latestData;
	            this._longitudeField = (_e = (_d = (_c = this._regions[0]).getSpec) === null || _d === void 0 ? void 0 : _d.call(_c)) === null || _e === void 0 ? void 0 : _e.longitudeField;
	            this._latitudeField = (_h = (_g = (_f = this._regions[0]).getSpec) === null || _g === void 0 ? void 0 : _g.call(_f)) === null || _h === void 0 ? void 0 : _h.latitudeField;
	        }
	    }
	    initData() {
	        const series = this._series;
	        if (!series) {
	            return;
	        }
	        const seriesData = series.getViewData();
	        if (seriesData) {
	            const data = new DataView(this._option.dataSet, { name: `${this.name}_data` });
	            data.parse([seriesData], {
	                type: 'dataview'
	            });
	            data.transform({ type: 'copyDataView', level: vchart.TransformLevel.copyDataView }, false);
	            this._data = new vchart.CompilableData(this._option, data);
	            data.target.addListener('change', () => {
	                if (this._spec.trigger !== 'hover' && this._spec.trigger !== 'click') {
	                    this._activeDatum = this._data.getLatestData();
	                }
	            });
	        }
	    }
	    initEvent() {
	        this.event.on('zoom', { filter: params => this._isRelativeModel(params.model) }, () => {
	            this.handleZoom();
	            return true;
	        });
	        this.event.on('panmove', { filter: params => this._isRelativeModel(params.model) }, e => {
	            this.handlePan(e);
	            return true;
	        });
	        const trigger = this._spec.trigger;
	        if (trigger === 'none') {
	            return;
	        }
	        if (trigger === 'hover') {
	            this.event.on('element-highlight:start', (params) => {
	                const g = params.graphics[0];
	                if (this._isRelativeSeries(g)) {
	                    this._updateDatum(vchart.getDatumOfGraphic(g));
	                }
	            });
	            this.event.on('element-highlight:reset', (params) => {
	                if (this._activeDatum) {
	                    this._updateDatum(null);
	                }
	            });
	        }
	        else if (trigger === 'click') {
	            this.event.on('element-select:start', (params) => {
	                const g = params.graphics[0];
	                if (this._isRelativeSeries(g)) {
	                    this._updateDatum(vchart.getDatumOfGraphic(g));
	                }
	            });
	            this.event.on('elementSelectReset', (params) => {
	                if (this._activeDatum) {
	                    this._updateDatum([]);
	                }
	            });
	        }
	    }
	    handlePan(e) {
	        const { delta } = e;
	        this._markerComponents.forEach(marker => {
	            marker.translate(delta[0], delta[1]);
	        });
	    }
	    handleZoom() {
	        this._updateMarkerLayoutAttribute();
	    }
	    _updateDatum(datum) {
	        this._activeDatum = datum;
	        this._markerComponents.forEach((marker, index) => {
	            var _a;
	            const markerDatum = (_a = this._data) === null || _a === void 0 ? void 0 : _a.getLatestData()[index];
	            if (this._activeDatum.includes(markerDatum)) {
	                marker.setAttribute('visible', true);
	            }
	            else {
	                marker.setAttribute('visible', false);
	            }
	        });
	    }
	    dataToPosition(datum) {
	        return this._series.dataToPosition(datum);
	    }
	    updateLayoutAttribute() {
	        var _a;
	        const markData = (_a = this._data) === null || _a === void 0 ? void 0 : _a.getLatestData();
	        if (!markData || markData.length === 0) {
	            return;
	        }
	        super.updateLayoutAttribute();
	        this._updateMarkerLayoutAttribute();
	    }
	    _updateMarkerLayoutAttribute() {
	        var _a;
	        const layoutPairInfo = [];
	        const markerMarks = [];
	        if (!this._markerComponents) {
	            this._markerComponents = (_a = this._data) === null || _a === void 0 ? void 0 : _a.getLatestData().map((data, index) => {
	                var _a;
	                const cmp = new MarkPoint({
	                    position: undefined,
	                    animation: false
	                });
	                if (cmp) {
	                    cmp.name = `${this.name}_marker_${index}`;
	                    cmp.id = (_a = this._spec.id) !== null && _a !== void 0 ? _a : `${this.name}_marker_${this.id}`;
	                    cmp.setAttribute('zIndex', this.layoutZIndex);
	                }
	                return cmp;
	            });
	        }
	        const markerComponents = this._markerComponents;
	        markerComponents.forEach((marker, index) => {
	            const { pairInfo, contentMarks } = this._evaluateMarker(this._data.getLatestData()[index], index);
	            pairInfo && layoutPairInfo.push(pairInfo);
	            contentMarks && markerMarks.push(contentMarks);
	        });
	        const positionedRects = this._layoutLabels(layoutPairInfo);
	        this._layoutMarkers(positionedRects, markerMarks);
	        this._renderMarkers();
	    }
	    _evaluateMarker(data, index) {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
	        let contentItemCount = 0;
	        let paddingWidth = 0;
	        let paddingHeight = 0;
	        let contentWidth = 0;
	        let contentHeight = 0;
	        const position = this._spec.position || 'top';
	        const offset = this._spec.offset;
	        const padding = vchart.normalizeLayoutPaddingSpec((_a = this._spec.background) === null || _a === void 0 ? void 0 : _a.padding);
	        const space = this._spec.space || 0;
	        paddingWidth += ((padding === null || padding === void 0 ? void 0 : padding.left) || 0) + ((padding === null || padding === void 0 ? void 0 : padding.right) || 0);
	        paddingHeight += ((padding === null || padding === void 0 ? void 0 : padding.top) || 0) + ((padding === null || padding === void 0 ? void 0 : padding.bottom) || 0);
	        const contentMarks = {};
	        const positionAttr = this.dataToPosition(data);
	        const container = graphicCreator.group({});
	        container.name = `${this.name}_marker_itemContainer_${index}`;
	        contentMarks.container = container;
	        if ((_b = this._spec.background) === null || _b === void 0 ? void 0 : _b.visible) {
	            const labelBackground = graphicCreator.rect(vchart.transformToGraphic(Object.assign({}, this._spec.background.style)));
	            labelBackground.setAttributes(positionAttr);
	            contentMarks.labelBackground = labelBackground;
	            container.appendChild(labelBackground);
	        }
	        if ((_c = this._spec.icon) === null || _c === void 0 ? void 0 : _c.visible) {
	            const icon = graphicCreator.symbol(vchart.transformToGraphic(Object.assign({}, this._spec.icon.style)));
	            icon.setAttributes(positionAttr);
	            icon.setAttribute('symbolType', (_e = (_d = this._spec.icon.style) === null || _d === void 0 ? void 0 : _d.symbolType) !== null && _e !== void 0 ? _e : (_f = this._spec.icon.style) === null || _f === void 0 ? void 0 : _f.shape);
	            const iconBound = icon.AABBBounds;
	            const iconHeight = (_g = (iconBound === null || iconBound === void 0 ? void 0 : iconBound.y2) - (iconBound === null || iconBound === void 0 ? void 0 : iconBound.y1)) !== null && _g !== void 0 ? _g : 0;
	            const iconWidth = (_h = (iconBound === null || iconBound === void 0 ? void 0 : iconBound.x2) - (iconBound === null || iconBound === void 0 ? void 0 : iconBound.x1)) !== null && _h !== void 0 ? _h : 0;
	            contentMarks.icon = icon;
	            container.appendChild(icon);
	            contentHeight = iconHeight;
	            contentWidth += iconWidth;
	            contentItemCount++;
	        }
	        if ((_j = this._spec.nameLabel) === null || _j === void 0 ? void 0 : _j.visible) {
	            const nameLabel = graphicCreator.text(vchart.transformToGraphic(Object.assign({}, this._spec.nameLabel.style)));
	            nameLabel.setAttributes(positionAttr);
	            nameLabel.setAttribute('text', data[this.nameField]);
	            const nameLabelBound = nameLabel.AABBBounds;
	            const nameLabelHeight = (_k = (nameLabelBound === null || nameLabelBound === void 0 ? void 0 : nameLabelBound.y2) - (nameLabelBound === null || nameLabelBound === void 0 ? void 0 : nameLabelBound.y1)) !== null && _k !== void 0 ? _k : 0;
	            const nameLabelWidth = (_l = (nameLabelBound === null || nameLabelBound === void 0 ? void 0 : nameLabelBound.x2) - (nameLabelBound === null || nameLabelBound === void 0 ? void 0 : nameLabelBound.x1)) !== null && _l !== void 0 ? _l : 0;
	            contentMarks.nameLabel = nameLabel;
	            container.appendChild(nameLabel);
	            contentHeight = Math.max(contentHeight, nameLabelHeight);
	            contentWidth += nameLabelWidth;
	            contentItemCount++;
	        }
	        if (((_m = this._spec.valueLabel) === null || _m === void 0 ? void 0 : _m.visible) && isValid$1(data[this.valueField])) {
	            const valueLabel = graphicCreator.text(vchart.transformToGraphic(Object.assign({}, this._spec.valueLabel.style)));
	            valueLabel.setAttributes(positionAttr);
	            valueLabel.setAttribute('text', data[this.valueField]);
	            const valueLabelBound = valueLabel.AABBBounds;
	            const valueLabelHeight = (_o = (valueLabelBound === null || valueLabelBound === void 0 ? void 0 : valueLabelBound.y2) - (valueLabelBound === null || valueLabelBound === void 0 ? void 0 : valueLabelBound.y1)) !== null && _o !== void 0 ? _o : 0;
	            const valueLabelWidth = (_p = (valueLabelBound === null || valueLabelBound === void 0 ? void 0 : valueLabelBound.x2) - (valueLabelBound === null || valueLabelBound === void 0 ? void 0 : valueLabelBound.x1)) !== null && _p !== void 0 ? _p : 0;
	            contentMarks.valueLabel = valueLabel;
	            container.appendChild(valueLabel);
	            contentHeight = Math.max(contentHeight, valueLabelHeight);
	            contentWidth += valueLabelWidth;
	            contentItemCount++;
	        }
	        const firstValidMark = Object.values(contentMarks).find(m => !!m && m.type !== 'group');
	        const anchor = {
	            x: firstValidMark === null || firstValidMark === void 0 ? void 0 : firstValidMark.getComputedAttribute('x'),
	            y: firstValidMark === null || firstValidMark === void 0 ? void 0 : firstValidMark.getComputedAttribute('y')
	        };
	        const itemRect = {
	            x: anchor.x,
	            y: anchor.y,
	            width: 0,
	            height: 0
	        };
	        itemRect.width = paddingWidth + contentWidth + (contentItemCount - 1) * space;
	        itemRect.height = paddingHeight + contentHeight;
	        const pairInfo = {
	            rect: itemRect,
	            point: anchor,
	            index
	        };
	        if (position !== 'outer') {
	            const anchors = ['top', 'right', 'left', 'bottom'].filter(a => a !== position);
	            pairInfo.rect = placeRectByOrient(itemRect, position, offset);
	            pairInfo.anchors = anchors;
	            pairInfo.offset = offset;
	        }
	        else {
	            pairInfo.pointCoord = {
	                x: +(data === null || data === void 0 ? void 0 : data[this._longitudeField]),
	                y: +(data === null || data === void 0 ? void 0 : data[this._latitudeField])
	            };
	        }
	        return { pairInfo, contentMarks };
	    }
	    _layoutMarkers(positionedRects, contentMarks) {
	        var _a, _b, _c;
	        for (let i = 0; i < contentMarks.length; i++) {
	            if (!positionedRects[i] || !contentMarks[i]) {
	                return;
	            }
	            const { icon, nameLabel, valueLabel, labelBackground, container } = contentMarks[i];
	            const itemRect = positionedRects[i];
	            const padding = vchart.normalizeLayoutPaddingSpec((_a = this._spec.background) === null || _a === void 0 ? void 0 : _a.padding);
	            const space = this._spec.space || 0;
	            const curY = itemRect.height / 2;
	            let curX = (padding === null || padding === void 0 ? void 0 : padding.left) || 0;
	            [icon, nameLabel, valueLabel].forEach((item, index) => {
	                var _a, _b;
	                if (item) {
	                    const bounds = item.AABBBounds;
	                    let offset = 0;
	                    if (item.type === 'symbol') {
	                        offset += ((_a = bounds.x2 - bounds.x1) !== null && _a !== void 0 ? _a : 0) / 2;
	                    }
	                    item.setAttributes({
	                        x: curX + offset,
	                        y: curY
	                    });
	                    curX += (_b = bounds.x2 - bounds.x1) !== null && _b !== void 0 ? _b : 0;
	                    if (index !== 2) {
	                        curX += space;
	                    }
	                }
	            });
	            labelBackground === null || labelBackground === void 0 ? void 0 : labelBackground.setAttributes({
	                x: 0,
	                y: 0,
	                width: itemRect.width,
	                height: itemRect.height
	            });
	            container === null || container === void 0 ? void 0 : container.setAttributes({
	                dx: -itemRect.width / 2,
	                dy: -itemRect.height / 2
	            });
	            const datum = this._data.getLatestData()[i];
	            const anchor = this.dataToPosition(datum);
	            const regionPos = this.getRegions()[0].getLayoutStartPoint();
	            const showLeader = !!(((_b = this._spec.leader) === null || _b === void 0 ? void 0 : _b.visible) && (icon || nameLabel || valueLabel));
	            this._markerComponents[i].setAttributes({
	                x: regionPos.x,
	                y: regionPos.y,
	                position: anchor,
	                visible: this._activeDatum.includes(datum),
	                itemContent: {
	                    refX: 0,
	                    type: 'custom',
	                    renderCustomCallback: () => container,
	                    autoRotate: false,
	                    offsetX: itemRect.x + itemRect.width / 2 - anchor.x,
	                    offsetY: itemRect.y + itemRect.height / 2 - anchor.y
	                },
	                itemLine: {
	                    visible: showLeader,
	                    type: 'type-po',
	                    lineStyle: vchart.transformToGraphic(Object.assign({}, (_c = this._spec.leader) === null || _c === void 0 ? void 0 : _c.style)),
	                    startSymbol: { visible: false }
	                }
	            });
	        }
	    }
	    _renderMarkers() {
	        if (!this._markerComponents || !this._markerComponents.length) {
	            return;
	        }
	        for (let i = 0; i < this._markerComponents.length; i++) {
	            this.getContainer().add(this._markerComponents[i]);
	        }
	    }
	    _layoutLabels(rects) {
	        const result = this._spec.position === 'outer' && this._map
	            ? layoutOuter(rects, this._map, (coord) => this._series.dataToPosition({
	                [this._longitudeField]: coord[0],
	                [this._latitudeField]: coord[1]
	            }))
	            : layoutByPosition(rects);
	        return result;
	    }
	    _isRelativeModel(model) {
	        var _a, _b, _c;
	        const id = (_b = (_a = this._series.getXAxisHelper()) === null || _a === void 0 ? void 0 : _a.getAxisId()) !== null && _b !== void 0 ? _b : (_c = this._series.getCoordinateHelper()) === null || _c === void 0 ? void 0 : _c.getCoordinateId();
	        return (model === null || model === void 0 ? void 0 : model.id) === id;
	    }
	    _isRelativeSeries(g) {
	        var _a;
	        return ((_a = g.context) === null || _a === void 0 ? void 0 : _a.modelId) === this._series.id;
	    }
	    _getNeedClearVRenderComponents() {
	        return this._markerComponents;
	    }
	    getVRenderComponents() {
	        return this._markerComponents;
	    }
	}
	MapLabelComponent.type = 'mapLabel';
	MapLabelComponent.specKey = 'mapLabel';
	MapLabelComponent.transformerConstructor = MapLabelSpecTransformer;
	const registerMapLabel = (option) => {
	    const vchartConstructor = (option === null || option === void 0 ? void 0 : option.VChart) || vchart.VChart;
	    if (vchartConstructor) {
	        vchartConstructor.useComponent([MapLabelComponent]);
	    }
	};

	exports.BAR_LINK = BAR_LINK;
	exports.Bar3dChart = Bar3dChart;
	exports.Bar3dChartSpecTransformer = Bar3dChartSpecTransformer;
	exports.Bar3dSeries = Bar3dSeries;
	exports.Bar3dSeriesSpecTransformer = Bar3dSeriesSpecTransformer;
	exports.BarLinkComponent = BarLinkComponent;
	exports.CandlestickChart = CandlestickChart;
	exports.CandlestickChartSpecTransformer = CandlestickChartSpecTransformer;
	exports.ConversionFunnelChart = ConversionFunnelChart;
	exports.ConversionFunnelSeries = ConversionFunnelSeries;
	exports.DefaultBandWidth = DefaultBandWidth;
	exports.Funnel3dChart = Funnel3dChart;
	exports.Funnel3dSeries = Funnel3dSeries;
	exports.Funnel3dSeriesSpecTransformer = Funnel3dSeriesSpecTransformer;
	exports.Histogram3dChart = Histogram3dChart;
	exports.ImageCloudChart = ImageCloudChart;
	exports.MapLabelComponent = MapLabelComponent;
	exports.PictogramChart = PictogramChart;
	exports.PictogramChartSpecTransformer = PictogramChartSpecTransformer;
	exports.PictogramSeries = PictogramSeries;
	exports.Pie3dChart = Pie3dChart;
	exports.Pie3dChartSpecTransformer = Pie3dChartSpecTransformer;
	exports.Pie3dSeries = Pie3dSeries;
	exports.Pie3dSeriesSpecTransformer = Pie3dSeriesSpecTransformer;
	exports.RangeColumn3dChart = RangeColumn3dChart;
	exports.RangeColumn3dChartSpecTransformer = RangeColumn3dChartSpecTransformer;
	exports.RangeColumn3dSeries = RangeColumn3dSeries;
	exports.RangeColumn3dSeriesSpecTransformer = RangeColumn3dSeriesSpecTransformer;
	exports.RankingBar = RankingBar;
	exports.RankingList = RankingList;
	exports.SERIES_BREAK = SERIES_BREAK;
	exports.SequenceScatterKDE = SequenceScatterKDE;
	exports.SequenceScatterLink = SequenceScatterLink;
	exports.SequenceScatterPixel = SequenceScatterPixel;
	exports.SeriesBreakComponent = SeriesBreakComponent;
	exports.SeriesLabelComponent = SeriesLabelComponent;
	exports.WordCloud3dChart = WordCloud3dChart;
	exports.WordCloud3dChartSpecTransformer = WordCloud3dChartSpecTransformer;
	exports.WordCloud3dSeries = WordCloud3dSeries;
	exports.appendBarLinkConfig = appendBarLinkConfig;
	exports.appendSeriesBreakConfig = appendSeriesBreakConfig;
	exports.appendSeriesLabelConfig = appendSeriesLabelConfig;
	exports.clearSVGSource = clearSVGSource;
	exports.getBarLinkConfig = getBarLinkConfig;
	exports.getSVGSource = getSVGSource;
	exports.getSeriesBreakConfig = getSeriesBreakConfig;
	exports.getSeriesLabelConfig = getSeriesLabelConfig;
	exports.register3DPlugin = register3DPlugin;
	exports.registerAxis3dPlugin = registerAxis3dPlugin;
	exports.registerBar3dChart = registerBar3dChart;
	exports.registerBar3dSeries = registerBar3dSeries;
	exports.registerBarLink = registerBarLink;
	exports.registerCandlestickChart = registerCandlestickChart;
	exports.registerConversionFunnelChart = registerConversionFunnelChart;
	exports.registerFunnel3dChart = registerFunnel3dChart;
	exports.registerFunnel3dSeries = registerFunnel3dSeries;
	exports.registerHistogram3dChart = registerHistogram3dChart;
	exports.registerImageCloudChart = registerImageCloudChart;
	exports.registerMapLabel = registerMapLabel;
	exports.registerPictogramChart = registerPictogramChart;
	exports.registerPictogramSeries = registerPictogramSeries;
	exports.registerPie3dChart = registerPie3dChart;
	exports.registerPie3dSeries = registerPie3dSeries;
	exports.registerRangeColumn3dChart = registerRangeColumn3dChart;
	exports.registerRangeColumn3dSeries = registerRangeColumn3dSeries;
	exports.registerRankingBarChart = registerRankingBarChart;
	exports.registerRankingList = registerRankingList;
	exports.registerSVGSource = registerSVGSource;
	exports.registerSequenceScatterKDE = registerSequenceScatterKDE;
	exports.registerSequenceScatterLink = registerSequenceScatterLink;
	exports.registerSequenceScatterPixel = registerSequenceScatterPixel;
	exports.registerSeriesBreak = registerSeriesBreak;
	exports.registerSeriesLabel = registerSeriesLabel;
	exports.registerWordCloud3dChart = registerWordCloud3dChart;
	exports.registerWordCloud3dSeries = registerWordCloud3dSeries;
	exports.registerWordCloudShape3dChart = registerWordCloudShape3dChart;
	exports.registerWordCloudShape3dSeries = registerWordCloudShape3dSeries;
	exports.svgSourceMap = svgSourceMap;
	exports.unregisterSVGSource = unregisterSVGSource;

}));
