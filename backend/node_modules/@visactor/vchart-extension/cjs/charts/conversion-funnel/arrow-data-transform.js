"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.conversionArrowTransform = void 0;

const vutils_1 = require("@visactor/vutils"), util_1 = require("./util"), conversionArrowTransform = (arrowSpec, options) => {
    var _a, _b, _c;
    if (!arrowSpec || !(null === (_a = arrowSpec.arrows) || void 0 === _a ? void 0 : _a.length)) return [];
    const {arrows: arrows} = arrowSpec, parsedArrows = parseArrow(arrows, options.categoryField), leftArrows = parsedArrows.filter((arrow => "left" === arrow.position)), rightArrows = parsedArrows.filter((arrow => "right" === arrow.position));
    return [ ...null !== (_b = computeArrows(leftArrows)) && void 0 !== _b ? _b : [], ...null !== (_c = computeArrows(rightArrows)) && void 0 !== _c ? _c : [] ];
};

function parseArrow(arrows, categoryField) {
    return arrows.filter((arrow => (0, vutils_1.isValidNumber)(arrow.from * arrow.to))).map(((arrow, index) => {
        const {from: from, to: to, position: position = "right"} = arrow;
        return Object.assign(Object.assign({}, arrow), {
            position: position,
            distance: arrow.distance || 40,
            from: Math.min(from, to),
            to: Math.max(from, to),
            span: Math.abs(from - to),
            isLayout: !1,
            context: {
                field: categoryField
            },
            layout: {
                level: 0
            },
            id: `${from}-${to}-${position}-${index}`
        });
    }));
}

function computeArrows(arrows) {
    if (0 === (null == arrows ? void 0 : arrows.length)) return null;
    const nodeDegreeMap = new Map;
    return arrows.forEach((arrow => {
        const fromNodeDegree = nodeDegreeMap.get(arrow.from);
        if ((0, vutils_1.isValid)(fromNodeDegree)) {
            const firstNodeWidthSameFromTo = fromNodeDegree.fromArrows.find((node => (0, util_1.isSameArrow)(node, arrow)));
            firstNodeWidthSameFromTo ? arrow.layout.duplicateNode = firstNodeWidthSameFromTo : fromNodeDegree.degree += 1, 
            fromNodeDegree.fromArrows.push(arrow);
        } else nodeDegreeMap.set(arrow.from, {
            fromArrows: [ arrow ],
            toArrows: [],
            totalArrows: [],
            degree: 1
        });
        const toNodeDegree = nodeDegreeMap.get(arrow.to);
        if ((0, vutils_1.isValid)(toNodeDegree)) {
            const firstNodeWidthSameFromTo = toNodeDegree.toArrows.find((node => (0, util_1.isSameArrow)(node, arrow)));
            firstNodeWidthSameFromTo ? arrow.layout.duplicateNode = firstNodeWidthSameFromTo : toNodeDegree.degree += 1, 
            toNodeDegree.toArrows.push(arrow);
        } else nodeDegreeMap.set(arrow.to, {
            toArrows: [ arrow ],
            fromArrows: [],
            totalArrows: [],
            degree: 1
        });
    })), nodeDegreeMap.forEach((node => {
        node.fromArrows.sort(((a, b) => b.span - a.span)), node.toArrows.sort(((a, b) => a.span - b.span)), 
        node.totalArrows = [ ...node.toArrows, ...node.fromArrows ];
    })), arrows.sort(((a, b) => a.span - b.span)).forEach((arrow => {
        var _a;
        const arrowsIsLayout = arrows.filter((arrow => arrow.layout.isLayout)), maxLevelArrow = (0, 
        vutils_1.maxInArray)(arrowsIsLayout, ((cur, curMax) => cur.layout.level - curMax.layout.level));
        let level = null !== (_a = null == maxLevelArrow ? void 0 : maxLevelArrow.layout.level) && void 0 !== _a ? _a : 0;
        for (;level >= 0; ) {
            if (arrowsIsLayout.some((arr => arr.layout.level === level && (0, util_1.isArrowCross)(arr, arrow)))) {
                level += 1;
                break;
            }
            --level;
        }
        arrow.layout.level = Math.max(0, level), arrow.layout.fromTotal = nodeDegreeMap.get(arrow.from).degree, 
        arrow.layout.toTotal = nodeDegreeMap.get(arrow.to).degree;
        const duplicateNode = arrow.layout.duplicateNode;
        duplicateNode ? (arrow.layout.fromIndex = duplicateNode.layout.fromIndex, arrow.layout.toIndex = duplicateNode.layout.toIndex) : (arrow.layout.fromIndex = computeIndex(arrow, nodeDegreeMap.get(arrow.from).totalArrows), 
        arrow.layout.toIndex = computeIndex(arrow, nodeDegreeMap.get(arrow.to).totalArrows)), 
        arrow.layout.isLayout = !0;
    })), arrows;
}

function computeIndex(arrow, totalArrows) {
    let index = 0, duplicateCount = 0;
    for (let i = 0; i < totalArrows.length; i++) {
        const curArrow = totalArrows[i];
        if (curArrow === arrow) {
            index = i - duplicateCount;
            break;
        }
        curArrow.layout.duplicateNode && duplicateCount++;
    }
    return index;
}

//# sourceMappingURL=arrow-data-transform.js.map
exports.conversionArrowTransform = conversionArrowTransform;