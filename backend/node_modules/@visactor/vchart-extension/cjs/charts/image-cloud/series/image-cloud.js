"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerImageCloudSeries = exports.ImageCloudSeries = void 0;

const constant_1 = require("./constant"), vutils_1 = require("@visactor/vutils"), vlayouts_1 = require("@visactor/vlayouts"), animation_1 = require("./animation"), tooltip_helper_1 = require("./tooltip-helper"), vrender_core_1 = require("@visactor/vrender-core"), vchart_1 = require("@visactor/vchart");

class ImageCloudSeries extends vchart_1.BaseSeries {
    constructor() {
        super(...arguments), this.type = constant_1.IMAGE_CLOUD_SERIES_TYPE;
    }
    setValueField(field) {
        (0, vutils_1.isValid)(field) && (this._valueField = field);
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this._nameField = this._spec.nameField, this._valueField = this._spec.valueField, 
        this._urlField = this._spec.urlField;
    }
    initMark() {
        var _a;
        (null === (_a = this._spec.imageMask) || void 0 === _a ? void 0 : _a.visible) && (this._maskMark = this._createMark(constant_1.imageCloudSeriesMark.imageMask, {
            dataView: !1,
            skipBeforeLayouted: !0
        })), this._imageMark = this._createMark(constant_1.imageCloudSeriesMark.image, {
            key: datum => `${datum[vchart_1.DEFAULT_DATA_KEY]}-${datum.frequency}`,
            isSeriesMark: !0,
            skipBeforeLayouted: !0
        });
    }
    initMarkStyle() {
        this._initImageMarkStyle(), this._initMaskMarkStyle();
    }
    _initImageMarkStyle() {
        var _a, _b;
        if (!this._imageMark) return;
        this._imageMark.setTransform([ Object.assign({
            type: "imagecloud"
        }, this._imageCloudTransformOption()) ]), this.setMarkStyle(this._imageMark, {
            x: datum => datum.x,
            y: datum => datum.y,
            width: datum => datum.width,
            height: datum => datum.height,
            visible: datum => datum.visible,
            angle: datum => datum.angle,
            clipConfig: datum => datum.clipConfig,
            image: datum => datum[this._urlField],
            scaleCenter: [ "50%", "50%" ]
        }, "normal", vchart_1.AttributeLevel.Series);
        "masked" === (null === (_a = this._spec.layoutConfig) || void 0 === _a ? void 0 : _a.placement) && (this.setMarkStyle(this._imageMark, {
            globalCompositeOperation: "source-atop"
        }, "normal", vchart_1.AttributeLevel.Series), this.setMarkStyle(this._rootMark, {
            width: () => this._region.getLayoutRect().width,
            height: () => this._region.getLayoutRect().height,
            globalCompositeOperation: "destination-in",
            clip: !0,
            drawMode: 1
        }, "normal", vchart_1.AttributeLevel.Series)), "stack" === (null === (_b = this._spec.layoutConfig) || void 0 === _b ? void 0 : _b.layoutMode) && this.setMarkStyle(this._imageMark, {
            stroke: "white",
            lineWidth: 2,
            shadowBlur: 6,
            shadowColor: "grey"
        }, "normal", vchart_1.AttributeLevel.Series);
    }
    isFillingImage(datum) {
        return datum._frequency > 1;
    }
    _initMaskMarkStyle() {
        this._maskMark && (this._maskMark.setMarkConfig({
            interactive: !1
        }), this.setMarkStyle(this._maskMark, {
            width: () => this._region.getLayoutRect().width,
            height: () => this._region.getLayoutRect().height
        }, "normal", vchart_1.AttributeLevel.Series));
    }
    initTooltip() {
        this._tooltipHelper = new tooltip_helper_1.ImageCloudTooltipHelper(this), this._imageMark && this._tooltipHelper.activeTriggerSet.mark.add(this._imageMark);
    }
    _imageCloudTransformOption() {
        var _a;
        return {
            size: () => {
                const {width: width, height: height} = this._region.getLayoutRect();
                return [ width, height ];
            },
            image: {
                field: this._urlField
            },
            weight: {
                field: this._valueField
            },
            imageConfig: {
                imageSize: this._spec.imageSize,
                imageSizeRange: this._spec.imageSizeRange,
                padding: null === (_a = this._spec.image) || void 0 === _a ? void 0 : _a.padding
            },
            ratio: this._spec.ratio,
            mask: this._spec.maskShape,
            maskConfig: this._spec.imageMask,
            layoutConfig: this._spec.layoutConfig,
            createCanvas: vchart_1.vglobal.createCanvas.bind(vchart_1.vglobal),
            createImage: vrender_core_1.createImage,
            onUpdateMaskCanvas: ((inputImage, maskImage) => {
                var _a;
                inputImage && this._maskMark && this._maskMark.getProduct().getChildren().forEach((element => {
                    element.setAttribute("background", inputImage);
                })), maskImage && "masked" === (null === (_a = this._spec.layoutConfig) || void 0 === _a ? void 0 : _a.placement) && this._rootMark.getProduct().setAttribute("background", maskImage);
            }).bind(this),
            onLayoutFinished: () => {
                var _a, _b;
                return null === (_b = null === (_a = this._option.globalInstance.getChart().getOption().performanceHook) || void 0 === _a ? void 0 : _a.afterWordcloudShapeDraw) || void 0 === _b ? void 0 : _b.call(_a, this._option.globalInstance);
            }
        };
    }
    _buildMarkAttributeContext() {
        super._buildMarkAttributeContext(), this._markAttributeContext.isFillingImage = this.isFillingImage.bind(this);
    }
    initAnimation() {
        [ this._imageMark ].forEach((mark => {
            var _a, _b;
            if (mark) {
                const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, params = {
                    center: () => {
                        const {width: width, height: height} = this._region.getLayoutRect();
                        return {
                            x: width / 2,
                            y: height / 2
                        };
                    },
                    height: () => {
                        const {height: height} = this._region.getLayoutRect();
                        return height;
                    }
                };
                mark.setAnimationConfig((0, vchart_1.animationConfig)(vchart_1.Factory.getAnimationInKey("imageCloud")(params, appearPreset), (0, 
                vchart_1.userAnimationConfig)("image", this._spec, this._markAttributeContext)));
            }
        }));
    }
    getDimensionField() {
        var _a;
        return [ null !== (_a = this._nameField) && void 0 !== _a ? _a : this._spec.urlField ];
    }
    getMeasureField() {
        return [ this._valueField ];
    }
    getStatisticFields() {
        const fields = [];
        return fields.push({
            key: this._nameField,
            operations: [ "values" ]
        }), fields.push({
            key: this._valueField,
            operations: [ "max", "min" ]
        }), fields;
    }
    getActiveMarks() {
        return [ this._imageMark ];
    }
    getMarkData(datum) {
        var _a;
        return null !== (_a = null == datum ? void 0 : datum.datum) && void 0 !== _a ? _a : datum;
    }
    getGroupFields() {
        return [];
    }
    dataToPosition(data) {
        return null;
    }
    dataToPositionX(data) {
        var _a;
        return null === (_a = this.dataToPosition(data)) || void 0 === _a ? void 0 : _a.x;
    }
    dataToPositionY(data) {
        var _a;
        return null === (_a = this.dataToPosition(data)) || void 0 === _a ? void 0 : _a.y;
    }
    valueToPosition(value1, value2) {
        return null;
    }
    getStackGroupFields() {
        return [];
    }
    getStackValueField() {
        return "";
    }
}

exports.ImageCloudSeries = ImageCloudSeries, ImageCloudSeries.type = constant_1.IMAGE_CLOUD_SERIES_TYPE, 
ImageCloudSeries.mark = constant_1.imageCloudSeriesMark;

const registerImageCloudSeries = () => {
    (0, vchart_1.registerImageMark)(), (0, animation_1.registerImageCloudAnimation)(), 
    vchart_1.Factory.registerSeries(ImageCloudSeries.type, ImageCloudSeries), vchart_1.Factory.registerGrammarTransform("imagecloud", {
        transform: vlayouts_1.imagecloudTransform
    });
};

exports.registerImageCloudSeries = registerImageCloudSeries;
//# sourceMappingURL=image-cloud.js.map
