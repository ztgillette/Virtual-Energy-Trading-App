"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.calculateKDE = exports.scottBandwidth = exports.gaussKernel = void 0;

const constant_1 = require("./constant");

function gaussKernel(x) {
    const SQRT2PI2 = Math.sqrt((2 * Math.PI) ** 2);
    return Math.exp(-(x ** 2) / 2) / SQRT2PI2;
}

function scottBandwidth(data) {
    return data.length ** (-1 / 6);
}

function calculateKDE(data, bins = 100, bandwidth) {
    const groupedData = data.reduce(((groups, point) => {
        const label = point.label;
        return groups[label] = groups[label] || [], groups[label].push(point), groups;
    }), {}), kdeResult = [];
    return Object.entries(groupedData).forEach((([label, points]) => {
        const h = bandwidth || scottBandwidth(points), xValues = points.map((d => d.x)), yValues = points.map((d => d.y)), xMin = Math.min(...xValues), xMax = Math.max(...xValues), yMin = Math.min(...yValues), yMax = Math.max(...yValues), xExpand = (xMax - xMin) * constant_1.EXPAND_RATIO, yExpand = (yMax - yMin) * constant_1.EXPAND_RATIO, xExtent_min = xMin - xExpand, yExtent_min = yMin - yExpand, densities = [];
        for (let i = 0; i < bins; i++) for (let j = 0; j < bins; j++) {
            const x = xExtent_min + .1 * i, y = yExtent_min + .1 * j;
            let density = 0;
            for (const point of points) {
                density += gaussKernel(Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2) / h);
            }
            density /= points.length * h * h, densities.push(density), kdeResult.push({
                x: x,
                y: y,
                kde: density,
                label: label
            });
        }
    })), kdeResult;
}

exports.gaussKernel = gaussKernel, exports.scottBandwidth = scottBandwidth, exports.calculateKDE = calculateKDE;
//# sourceMappingURL=utils.js.map
