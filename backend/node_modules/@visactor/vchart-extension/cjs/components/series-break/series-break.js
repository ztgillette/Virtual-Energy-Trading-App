"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerSeriesBreak = exports.SeriesBreakComponent = void 0;

const vrender_components_1 = require("@visactor/vrender-components"), vrender_core_1 = require("@visactor/vrender-core"), vutils_1 = require("@visactor/vutils"), constant_1 = require("./constant"), vchart_1 = require("@visactor/vchart");

function generateZigzagPath(start, end, size, angle, isVertical = !1) {
    const path = [], {x: startX, y: startY} = start, {x: endX, y: endY} = end, numZigzags = isVertical ? Math.floor((endY - startY) / (2 * size)) : Math.floor((endX - startX) / (2 * size)), angleRad = Math.PI / 180 * angle, deltaX = size * Math.cos(angleRad), deltaY = size * Math.sin(angleRad);
    path.push(`M ${startX} ${startY}`);
    for (let i = 0; i <= numZigzags; i++) {
        const x = isVertical ? startX + (i % 2 == 0 ? deltaX : -deltaX) : startX + i * size * 2, y = isVertical ? startY + i * size * 2 : i % 2 == 0 ? startY - deltaY : startY + deltaY;
        path.push(`L ${x} ${y}`);
    }
    return path.push(`L ${isVertical ? startX : endX} ${isVertical ? endY : startY}`), 
    path.join(" ");
}

const checkOverlap = (prevData, newEntry) => {
    const {start: start, end: end} = newEntry, isVertical = start.x === end.x, equalDim = isVertical ? "x" : "y", diffDim = isVertical ? "y" : "x";
    let needAppend = !0;
    prevData.length && prevData.forEach((prevEntry => {
        if ((0, vutils_1.isNumberClose)(prevEntry.start[equalDim], start[equalDim])) {
            const minDim = Math.min(start[diffDim], end[diffDim]), maxDim = Math.max(start[diffDim], end[diffDim]), prevMinDim = Math.min(prevEntry.start[diffDim], prevEntry.end[diffDim]), prevMaxDim = Math.max(prevEntry.start[diffDim], prevEntry.end[diffDim]);
            if (!(maxDim < prevMinDim - 1e-6 || minDim > prevMaxDim + 1e-6)) return prevEntry.start[diffDim] = Math.min(prevMinDim, minDim), 
            prevEntry.end[diffDim] = Math.max(prevMaxDim, maxDim), void (needAppend = !1);
        }
    })), needAppend && prevData.push(newEntry);
};

class SeriesBreakComponent extends vrender_components_1.AbstractComponent {
    constructor() {
        super(...arguments), this.name = constant_1.SERIES_BREAK;
    }
    render() {
        this.removeAllChild();
        const {data: data = []} = this.attribute;
        if ((0, vutils_1.isEmpty)(data)) return;
        const verticalData = [], horizontalData = [];
        data.forEach((breakData => {
            const {start: start, end: end} = breakData, isVertical = start.x === end.x;
            checkOverlap(isVertical ? verticalData : horizontalData, breakData);
        })), [ ...verticalData, ...horizontalData ].forEach(((breakData, id) => {
            var _a;
            const {start: start, end: end, size: size = 4, gap: gap = 5, style: style = {}} = breakData, rest = __rest(breakData, [ "start", "end", "size", "gap", "style" ]), breakGroup = (0, 
            vrender_core_1.createGroup)({}), isVertical = start.x === end.x;
            let startPathStart, startPathEnd, endPathStart, endPathEnd;
            isVertical ? (startPathStart = {
                x: start.x - gap / 2,
                y: start.y
            }, startPathEnd = {
                x: end.x - gap / 2,
                y: end.y
            }, endPathStart = {
                x: start.x + gap / 2,
                y: start.y
            }, endPathEnd = {
                x: end.x + gap / 2,
                y: end.y
            }) : (startPathStart = {
                x: start.x,
                y: start.y - gap / 2
            }, startPathEnd = {
                x: end.x,
                y: end.y - gap / 2
            }, endPathStart = {
                x: start.x,
                y: start.y + gap / 2
            }, endPathEnd = {
                x: end.x,
                y: end.y + gap / 2
            });
            const startPath = generateZigzagPath(startPathStart, startPathEnd, size, isVertical ? 75 : 15, isVertical), centerPath = generateZigzagPath(start, end, size, isVertical ? 75 : 15, isVertical), endPath = generateZigzagPath(endPathStart, endPathEnd, size, isVertical ? 75 : 15, isVertical);
            breakGroup.add((0, vrender_core_1.createPath)(Object.assign(Object.assign({
                path: startPath,
                stroke: "#000",
                lineWidth: 1
            }, style), {
                pickable: !1,
                zIndex: 1
            }))), breakGroup.add((0, vrender_core_1.createPath)(Object.assign(Object.assign({
                path: endPath,
                stroke: "#000",
                lineWidth: 1
            }, style), {
                pickable: !1,
                zIndex: 1
            }))), breakGroup.add((0, vrender_core_1.createPath)({
                path: centerPath,
                stroke: "#fff",
                lineWidth: gap,
                pickable: !1,
                zIndex: 0
            })), breakGroup.name = "series-break", breakGroup.data = rest, (0, vutils_1.isValid)(rest.axisId) && (breakGroup.id = `${null !== (_a = rest.axisId) && void 0 !== _a ? _a : ""}_${id}`), 
            this.add(breakGroup);
        }));
    }
}

exports.SeriesBreakComponent = SeriesBreakComponent;

const registerSeriesBreak = () => {
    vchart_1.Factory.registerGraphicComponent("seriesBreak", (attrs => new SeriesBreakComponent(attrs)));
};

exports.registerSeriesBreak = registerSeriesBreak;
//# sourceMappingURL=series-break.js.map
