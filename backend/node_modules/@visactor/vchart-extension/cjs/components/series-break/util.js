"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.appendSeriesBreakConfig = exports.getSeriesBreakConfig = void 0;

const vutils_1 = require("@visactor/vutils"), element_1 = require("../../utils/element"), math_1 = require("../../utils/math"), constant_1 = require("./constant"), barOffset = 2, lineOffset = 10, areaOffset = 0;

function getSeriesBreakConfig(axesSpec, axesIndex) {
    return {
        type: "component",
        componentType: constant_1.SERIES_BREAK,
        interactive: !0,
        zIndex: 500,
        style: {
            data: (datum, ctx) => {
                const seriesBreakData = [], chart = ctx.vchart.getChart(), isHorizontal = "horizontal" === chart.getAllSeries()[0].direction;
                return axesSpec.forEach(((spec, index) => {
                    var _a, _b;
                    const axisId = spec.id, axisModel = (0, vutils_1.isValid)(axisId) ? chart.getComponentByUserId(axisId) : axesIndex && (0, 
                    vutils_1.isValid)(axesIndex[index]) ? chart.getComponentByIndex("axes", axesIndex[index]) : null === (_a = chart.getComponentsByKey("axes").filter((axis => axis.getSpec().breaks === spec.breaks))) || void 0 === _a ? void 0 : _a[0];
                    if (!axisModel) return;
                    const parsedAxisId = null != axisId ? axisId : `${axisModel.type}-${axisModel.id}`, regionBounds = (0, 
                    element_1.getAllRegionBounds)(axisModel.getRegions());
                    (0, vutils_1.array)(null === (_b = axisModel._break) || void 0 === _b ? void 0 : _b.breaks).forEach((breakConfig => {
                        const {range: range, breakSymbol: breakSymbol, gap: gap = 5} = breakConfig, pos1 = axisModel.valueToPosition(range[0]), pos2 = axisModel.valueToPosition(range[1]), posY = (pos1 + pos2) / 2 + (isHorizontal ? regionBounds.x1 : regionBounds.y1);
                        chart.getAllSeries().forEach((s => {
                            if ("bar" === s.type || "waterfall" === s.type) {
                                s.getMarkInName("bar").getGraphics().forEach((element => {
                                    const elementBounds = element.AABBBounds;
                                    let startX, startY, endX, endY, shouldDrawBreak = !1;
                                    isHorizontal ? (shouldDrawBreak = elementBounds.x1 < (pos1 + pos2 - gap) / 2 && elementBounds.x2 > (pos1 + pos2 + gap) / 2, 
                                    startX = posY, startY = Math.max(elementBounds.y1 + regionBounds.y1 - 2, regionBounds.y1), 
                                    endX = posY, endY = Math.min(elementBounds.y2 + regionBounds.y1 + 2, regionBounds.y2)) : (shouldDrawBreak = elementBounds.y1 < (pos1 + pos2 - gap) / 2 && elementBounds.y2 > (pos1 + pos2 + gap) / 2, 
                                    startX = Math.max(elementBounds.x1 + regionBounds.x1 - 2, regionBounds.x1), startY = posY, 
                                    endX = Math.min(elementBounds.x2 + regionBounds.x1 + 2, regionBounds.x2), endY = posY), 
                                    shouldDrawBreak && seriesBreakData.push({
                                        start: {
                                            x: startX,
                                            y: startY
                                        },
                                        end: {
                                            x: endX,
                                            y: endY
                                        },
                                        gap: gap,
                                        style: null == breakSymbol ? void 0 : breakSymbol.style,
                                        axisId: parsedAxisId,
                                        data: range
                                    });
                                }));
                            } else if ("line" === s.type) {
                                s.getMarkInName(s.type).getGraphics().forEach((graphicItem => {
                                    getAreaOrLinePathPoints(graphicItem, "line").forEach((linePoints => {
                                        getIntersectionsFromLineAndPolyline(isHorizontal ? {
                                            start: {
                                                x: (pos1 + pos2) / 2,
                                                y: 0
                                            },
                                            end: {
                                                x: (pos1 + pos2) / 2,
                                                y: regionBounds.y2 - regionBounds.y1
                                            }
                                        } : {
                                            start: {
                                                x: 0,
                                                y: (pos1 + pos2) / 2
                                            },
                                            end: {
                                                x: regionBounds.x2 - regionBounds.x1,
                                                y: (pos1 + pos2) / 2
                                            }
                                        }, linePoints).forEach((intersection => {
                                            let start, end;
                                            isHorizontal ? (start = {
                                                x: posY,
                                                y: Math.max(intersection[1] + regionBounds.y1 - 10, regionBounds.y1)
                                            }, end = {
                                                x: posY,
                                                y: Math.min(intersection[1] + regionBounds.y1 + 10, regionBounds.y2)
                                            }) : (start = {
                                                x: Math.max(intersection[0] + regionBounds.x1 - 10, regionBounds.x1),
                                                y: posY
                                            }, end = {
                                                x: Math.min(intersection[0] + regionBounds.x1 + 10, regionBounds.x2),
                                                y: posY
                                            }), seriesBreakData.push({
                                                start: start,
                                                end: end,
                                                gap: gap,
                                                style: null == breakSymbol ? void 0 : breakSymbol.style,
                                                axisId: parsedAxisId,
                                                data: range
                                            });
                                        }));
                                    }));
                                }));
                            } else if ("area" === s.type) {
                                s.getMarkInName("area").getGraphics().forEach((graphicItem => {
                                    getAreaOrLinePathPoints(graphicItem, "area").forEach((areaPoints => {
                                        const intersections = getIntersectionsFromLineAndPolyline(isHorizontal ? {
                                            start: {
                                                x: (pos1 + pos2) / 2,
                                                y: 0
                                            },
                                            end: {
                                                x: (pos1 + pos2) / 2,
                                                y: regionBounds.y2 - regionBounds.y1
                                            }
                                        } : {
                                            start: {
                                                x: 0,
                                                y: (pos1 + pos2) / 2
                                            },
                                            end: {
                                                x: regionBounds.x2 - regionBounds.x1,
                                                y: (pos1 + pos2) / 2
                                            }
                                        }, areaPoints);
                                        intersections.sort(((a, b) => a[0] - b[0]));
                                        for (let index = 0; index < intersections.length - 1; index++) {
                                            const lineStart = {
                                                x: intersections[index][0],
                                                y: intersections[index][1]
                                            }, lineEnd = {
                                                x: intersections[index + 1][0],
                                                y: intersections[index + 1][1]
                                            };
                                            if (isPointInPolygon(isHorizontal ? {
                                                x: lineStart.x,
                                                y: (lineStart.y + lineEnd.y) / 2
                                            } : {
                                                x: (lineStart.x + lineEnd.x) / 2,
                                                y: lineStart.y
                                            }, areaPoints)) {
                                                let start, end;
                                                isHorizontal ? (start = {
                                                    x: lineStart.x + regionBounds.x1,
                                                    y: Math.max(lineStart.y + regionBounds.y1 - 0, regionBounds.y1)
                                                }, end = {
                                                    x: lineEnd.x + regionBounds.x1,
                                                    y: Math.min(lineEnd.y + regionBounds.y1 + 0, regionBounds.y2)
                                                }) : (start = {
                                                    x: Math.max(lineStart.x + regionBounds.x1 - 0, regionBounds.x1),
                                                    y: lineStart.y + regionBounds.y1
                                                }, end = {
                                                    x: Math.min(lineEnd.x + regionBounds.x1 + 0, regionBounds.x2),
                                                    y: lineEnd.y + regionBounds.y1
                                                }), seriesBreakData.push({
                                                    start: start,
                                                    end: end,
                                                    gap: gap,
                                                    style: null == breakSymbol ? void 0 : breakSymbol.style,
                                                    axisId: parsedAxisId,
                                                    data: range
                                                });
                                            }
                                        }
                                    }));
                                }));
                            }
                        }));
                    }));
                })), seriesBreakData;
            }
        }
    };
}

function getIntersectionsFromLineAndPolyline(line, points) {
    const intersections = [];
    for (let index = 1; index < points.length; index++) {
        const intersection = (0, vutils_1.getIntersectPoint)([ line.start.x, line.start.y ], [ line.end.x, line.end.y ], [ points[index].x, points[index].y ], [ points[index - 1].x, points[index - 1].y ]);
        intersection && !intersections.find((point => (0, math_1.isNumberEqual)(vutils_1.PointService.distancePP({
            x: point[0],
            y: point[1]
        }, {
            x: intersection[0],
            y: intersection[1]
        }), 0))) && intersections.push(intersection);
    }
    return intersections;
}

function getAreaOrLinePathPoints(shape, type) {
    const {points: points, segments: segments} = shape.attribute, pathPoints = [];
    let eachPathPoints = [];
    const parsePoints = points => {
        if (points && points.length) {
            let basePoints = [];
            if (points.forEach((point => {
                var _a, _b;
                if (!1 === point.defined) {
                    if (pathPoints.push(eachPathPoints), "area" === type && basePoints.length) {
                        for (let i = basePoints.length - 1; i >= 0; i--) eachPathPoints.push({
                            x: basePoints[i].x,
                            y: basePoints[i].y
                        });
                        eachPathPoints.push(eachPathPoints[0]);
                    }
                    eachPathPoints = [], basePoints = [];
                } else eachPathPoints.push({
                    x: point.x,
                    y: point.y
                }), "area" === type && basePoints.push({
                    x: null !== (_a = point.x1) && void 0 !== _a ? _a : point.x,
                    y: null !== (_b = point.y1) && void 0 !== _b ? _b : point.y
                });
            })), "area" === type && basePoints.length) {
                for (let i = basePoints.length - 1; i >= 0; i--) eachPathPoints.push({
                    x: basePoints[i].x,
                    y: basePoints[i].y
                });
                eachPathPoints.push(eachPathPoints[0]);
            }
            pathPoints.push(eachPathPoints);
        }
    };
    return points && points.length ? parsePoints(points) : segments && segments.length && segments.forEach((seg => {
        parsePoints(seg.points);
    })), pathPoints;
}

function isPointInPolygon(point, polygon) {
    const {x: x, y: y} = point;
    let inside = !1;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const {x: xi, y: yi} = polygon[i], {x: xj, y: yj} = polygon[j];
        yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi && (inside = !inside);
    }
    return inside;
}

exports.getSeriesBreakConfig = getSeriesBreakConfig;

const appendSeriesBreakConfig = rawSpec => {
    var _a;
    if (null === (_a = rawSpec.axes) || void 0 === _a ? void 0 : _a.length) {
        const breakedAxes = rawSpec.axes.filter((axis => axis.breaks && axis.breaks.length && !1 !== axis.visible));
        if (breakedAxes.length) return rawSpec.customMark = (0, vutils_1.array)(rawSpec.customMark).filter((obj => obj.componentType !== constant_1.SERIES_BREAK)), 
        rawSpec.customMark.push(getSeriesBreakConfig(breakedAxes, breakedAxes.map((axisSpec => rawSpec.axes.indexOf(axisSpec))))), 
        !0;
    }
    return !1;
};

exports.appendSeriesBreakConfig = appendSeriesBreakConfig;
//# sourceMappingURL=util.js.map
