"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.appendBarLinkConfig = exports.getBarLinkConfig = exports.getLinkData = exports.groupBarsByFields = void 0;

const vchart_1 = require("@visactor/vchart"), vutils_1 = require("@visactor/vutils"), constant_1 = require("./constant");

function groupBarsByFields(elements, groupFields) {
    const result = {};
    for (let i = 0; i < elements.length; i++) {
        const item = elements[i], itemData = (0, vchart_1.getDatumOfGraphic)(item), groupKey = groupFields.map((field => itemData[field])).join("-");
        result[groupKey] || (result[groupKey] = []), result[groupKey].push(item);
    }
    return result;
}

function getLinkData(currentElement, nextElement, config) {
    const {isHorizontal: isHorizontal, isXAxisInverse: isXAxisInverse, isYAxisInverse: isYAxisInverse, linkType: linkType, doFill: doFill, regionStartX: regionStartX, regionStartY: regionStartY} = config, currentBarBounds = currentElement.AABBBounds, nextBarBounds = nextElement.AABBBounds;
    let linePoints, areaPoints;
    return isHorizontal ? (linePoints = [ {
        x: (currentBarBounds.x1 + currentBarBounds.x2) / 2 + regionStartX,
        y: currentBarBounds.y1 + regionStartY
    }, {
        x: (nextBarBounds.x1 + nextBarBounds.x2) / 2 + regionStartX,
        y: nextBarBounds.y2 + regionStartY
    } ], isXAxisInverse ? ("total" === linkType && (linePoints = [ {
        x: currentBarBounds.x1 + regionStartX,
        y: currentBarBounds.y1 + regionStartY
    }, {
        x: nextBarBounds.x1 + regionStartX,
        y: nextBarBounds.y2 + regionStartY
    } ]), doFill && (areaPoints = [ {
        x: currentBarBounds.x1 + regionStartX,
        x1: currentBarBounds.x2 + regionStartX,
        y: currentBarBounds.y1 + regionStartY
    }, {
        x: nextBarBounds.x1 + regionStartX,
        x1: nextBarBounds.x2 + regionStartX,
        y: nextBarBounds.y2 + regionStartY
    } ])) : ("total" === linkType && (linePoints = [ {
        x: currentBarBounds.x2 + regionStartX,
        y: currentBarBounds.y1 + regionStartY
    }, {
        x: nextBarBounds.x2 + regionStartX,
        y: nextBarBounds.y2 + regionStartY
    } ]), doFill && (areaPoints = [ {
        x: currentBarBounds.x2 + regionStartX,
        x1: currentBarBounds.x1 + regionStartX,
        y: currentBarBounds.y1 + regionStartY
    }, {
        x: nextBarBounds.x2 + regionStartX,
        x1: nextBarBounds.x1 + regionStartX,
        y: nextBarBounds.y2 + regionStartY
    } ]))) : (linePoints = [ {
        x: currentBarBounds.x2 + regionStartX,
        y: (currentBarBounds.y1 + currentBarBounds.y2) / 2 + regionStartY
    }, {
        x: nextBarBounds.x1 + regionStartX,
        y: (nextBarBounds.y1 + nextBarBounds.y2) / 2 + regionStartY
    } ], isYAxisInverse ? ("total" === linkType && (linePoints = [ {
        x: currentBarBounds.x2 + regionStartX,
        y: currentBarBounds.y2 + regionStartY
    }, {
        x: nextBarBounds.x1 + regionStartX,
        y: nextBarBounds.y2 + regionStartY
    } ]), doFill && (areaPoints = [ {
        x: currentBarBounds.x2 + regionStartX,
        y: currentBarBounds.y2 + regionStartY,
        y1: currentBarBounds.y1 + regionStartY
    }, {
        x: nextBarBounds.x1 + regionStartX,
        y: nextBarBounds.y2 + regionStartY,
        y1: nextBarBounds.y1 + regionStartY
    } ])) : ("total" === linkType && (linePoints = [ {
        x: currentBarBounds.x2 + regionStartX,
        y: currentBarBounds.y1 + regionStartY
    }, {
        x: nextBarBounds.x1 + regionStartX,
        y: nextBarBounds.y1 + regionStartY
    } ]), doFill && (areaPoints = [ {
        x: currentBarBounds.x2 + regionStartX,
        y: currentBarBounds.y1 + regionStartY,
        y1: currentBarBounds.y2 + regionStartY
    }, {
        x: nextBarBounds.x1 + regionStartX,
        y: nextBarBounds.y1 + regionStartY,
        y1: nextBarBounds.y2 + regionStartY
    } ]))), {
        areaPoints: areaPoints,
        linePoints: linePoints,
        data: [ (0, vchart_1.getDatumOfGraphic)(currentElement), (0, vchart_1.getDatumOfGraphic)(nextElement) ],
        color: currentElement.attribute.fill
    };
}

function getBarLinkConfig(style = {}, extraStyle) {
    const {linkType: linkType = "total", doFill: doFill} = style, rest = __rest(style, [ "linkType", "doFill" ]);
    return {
        type: "component",
        componentType: constant_1.BAR_LINK,
        zIndex: 500,
        interactive: !1,
        style: Object.assign(Object.assign({
            data: (datum, context) => {
                const {vchart: vchart} = context, regions = vchart.getChart().getAllRegions(), linkLineData = [];
                return regions.forEach((region => {
                    const barSeriesArr = region.getSeries().filter((s => "bar" === s.type)), {x: regionStartX, y: regionStartY} = region.getLayoutStartPoint();
                    if (barSeriesArr.length) {
                        const groupFields = barSeriesArr[0].getGroupFields(), allBarElements = [];
                        barSeriesArr.forEach((barSeries => {
                            var _a;
                            (null === (_a = barSeries.getMarkInName("bar")) || void 0 === _a ? void 0 : _a.getGraphics()).forEach((barElement => {
                                allBarElements.push(barElement);
                            }));
                        }));
                        const groupData = groupBarsByFields(allBarElements, groupFields);
                        Object.values(groupData).forEach((groupedValues => {
                            groupedValues.sort(((prev, curr) => (0, vchart_1.getDatumOfGraphic)(prev)[vchart_1.STACK_FIELD_END] - (0, 
                            vchart_1.getDatumOfGraphic)(curr)[vchart_1.STACK_FIELD_END]));
                        }));
                        const barSeries = barSeriesArr[0], isHorizontal = "horizontal" === barSeries.direction, isYAxisInverse = barSeries.getYAxisHelper().isInverse(), isXAxisInverse = barSeries.getXAxisHelper().isInverse(), groupValues = Object.values(groupData);
                        if (groupValues.length) if (isHorizontal) {
                            groupValues[0][0].AABBBounds.y1 < groupValues[groupValues.length - 1][0].AABBBounds.y1 && groupValues.reverse();
                        } else {
                            groupValues[0][0].AABBBounds.x1 > groupValues[groupValues.length - 1][0].AABBBounds.x1 && groupValues.reverse();
                        }
                        for (let index = 0; index < groupValues.length - 1; index++) {
                            const currentValues = groupValues[index], nextValues = groupValues[index + 1];
                            if (currentValues.forEach(((element, elementIndex) => {
                                var _a;
                                const linkData = getLinkData(element, null !== (_a = nextValues[elementIndex]) && void 0 !== _a ? _a : nextValues[nextValues.length - 1], {
                                    isHorizontal: isHorizontal,
                                    isXAxisInverse: isXAxisInverse,
                                    isYAxisInverse: isYAxisInverse,
                                    doFill: doFill,
                                    linkType: linkType,
                                    regionStartX: regionStartX,
                                    regionStartY: regionStartY
                                });
                                linkLineData.push(linkData);
                            })), currentValues.length < nextValues.length) {
                                const lastElementOfCurrentElement = currentValues[currentValues.length - 1];
                                for (let i = currentValues.length; i < nextValues.length; i++) {
                                    const linkData = getLinkData(lastElementOfCurrentElement, nextValues[i], {
                                        isHorizontal: isHorizontal,
                                        isXAxisInverse: isXAxisInverse,
                                        isYAxisInverse: isYAxisInverse,
                                        doFill: doFill,
                                        linkType: linkType,
                                        regionStartX: regionStartX,
                                        regionStartY: regionStartY
                                    });
                                    linkLineData.push(linkData);
                                }
                            }
                        }
                    }
                })), linkLineData;
            },
            linkType: linkType
        }, rest), extraStyle)
    };
}

function appendBarLinkConfig(rawSpec, barLinkSpec) {
    rawSpec.customMark = (0, vutils_1.array)(rawSpec.customMark).filter((obj => obj.componentType !== constant_1.BAR_LINK)), 
    rawSpec.customMark.push(getBarLinkConfig(barLinkSpec));
}

exports.groupBarsByFields = groupBarsByFields, exports.getLinkData = getLinkData, 
exports.getBarLinkConfig = getBarLinkConfig, exports.appendBarLinkConfig = appendBarLinkConfig;
//# sourceMappingURL=util.js.map
