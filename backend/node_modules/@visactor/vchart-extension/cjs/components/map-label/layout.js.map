{"version":3,"sources":["../src/components/map-label/layout.ts"],"names":[],"mappings":"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","file":"layout.js","sourcesContent":["import type { Feature } from '@visactor/vutils';\nimport { isPointInPolygon, destination, getAABBFromPoints } from '@visactor/vutils';\nimport type { IRect, IOrientType, IPoint } from '@visactor/vchart';\n\ntype IBound = {\n  x1: number;\n  x2: number;\n  y1: number;\n  y2: number;\n};\nexport interface IPairInfo {\n  /** 矩形信息 */\n  rect: IRect;\n  /** 对应点的画布坐标 */\n  point: IPoint;\n  /** 对应点的经纬度坐标 */\n  pointCoord?: IPoint;\n  /** 基于锚点的可放置位置 */\n  anchors?: IOrientType[];\n  /** 距离锚点的位置偏移量 */\n  offset?: number;\n  /** 原始顺序 */\n  index: number;\n}\n\nfunction overlap<T extends IBound>(a: T, b: T, sep = 0) {\n  return sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);\n}\n\nexport function bound(rect: IRect): IBound {\n  return {\n    x1: rect.x,\n    x2: rect.x + rect.width,\n    y1: rect.y,\n    y2: rect.y + rect.height\n  };\n}\n\nfunction toRect(bound: IBound): IRect {\n  return {\n    x: bound.x1,\n    y: bound.y1,\n    width: bound.x2 - bound.x1,\n    height: bound.y2 - bound.y1\n  };\n}\n\n/**\n * 根据可选位置进行躲避布局\n * @param pairs\n * @returns\n */\nexport function layoutByPosition(pairs: IPairInfo[]): IRect[] {\n  if (!pairs || pairs.length === 0) {\n    return [];\n  }\n\n  // 只有一个无需布局\n  if (pairs.length === 1) {\n    return [pairs[0].rect];\n  }\n\n  const _pairs = pairs.map(pair => {\n    return {\n      ...pair,\n      bound: bound(pair.rect),\n      anchorCandidates: candidatesByOrient(pair.anchors ?? [], pair.point!, pair.rect, pair.offset)\n    };\n  });\n\n  const resultBound: IBound[] = [];\n  // 默认布局第一个\n  resultBound.push(_pairs[0].bound);\n\n  for (let i = 1; i <= _pairs.length - 1; i++) {\n    const curPair = _pairs[i];\n    const curBound = curPair.bound;\n    // 遍历检测\n    let isOverlap = resultBound.some(r => overlap(r, curBound));\n    if (!curPair.anchorCandidates) {\n      continue;\n    }\n    if (isOverlap && curPair.anchorCandidates?.length > 0) {\n      for (let j = 0; j < curPair.anchorCandidates.length; j++) {\n        const anchor = curPair.anchorCandidates[j];\n        const newBound = {\n          x1: anchor.x,\n          y1: anchor.y,\n          x2: anchor.x + curBound.x2 - curBound.x1,\n          y2: anchor.y + curBound.y2 - curBound.y1,\n          anchor\n        };\n        if (!resultBound.some(r => overlap(r, newBound))) {\n          resultBound.push(newBound);\n          isOverlap = false;\n          break;\n        }\n      }\n      if (isOverlap) {\n        // 所有候选位置都放不下\n        resultBound.push(curPair.bound);\n      }\n    } else {\n      resultBound.push(curPair.bound);\n    }\n  }\n\n  return resultBound.map(bound => toRect(bound));\n}\n\nexport function layoutOuter(\n  pairs: IPairInfo[],\n  features: Feature[],\n  dataToPosition: (coord: number[]) => IPoint | null\n): IRect[] {\n  // 1. 计算包围圆\n  const _points = pairs.map(rect => rect.pointCoord);\n  const { x1, x2, y1, y2 } = getAABBFromPoints(_points);\n  const geoCenter = [(x1 + x2) / 2, (y1 + y2) / 2];\n  const centerPosition = dataToPosition(geoCenter);\n\n  if (!centerPosition) {\n    return [];\n  }\n\n  // 2. 遍历每个rect\n  // anchor与圆心的交点方向，尝试寻找不在地图区域内部的新锚点\n  const result = pairs.map(pair => {\n    const rect = pair.rect;\n    const targetPoint = !isPointWithinFeatures(features, pair.pointCoord!)\n      ? pair.point\n      : dataToPosition(\n          nearestPoint(\n            features,\n            [pair.pointCoord!.x, pair.pointCoord!.y],\n            uniformDegree(lineDegree(pair.point!, centerPosition))\n          )\n        );\n\n    if (targetPoint) {\n      rect.x = targetPoint.x;\n      rect.y = targetPoint.y;\n    }\n    // 3. 根据finalAnchor在包围圆上的位置，调整rect的位置\n    // 将圆根据圆心角划分为4个区域，对应不同的position\n\n    const degree = uniformDegree(lineDegree(pair.point!, centerPosition));\n\n    let position: IOrientType;\n    const anchors: IOrientType[] = [];\n    if (degree >= -45 && degree < 45) {\n      position = 'top';\n      anchors.push('left', 'right');\n    } else if (degree >= 45 && degree < 135) {\n      position = 'right';\n    } else if (degree >= -135 && degree < -45) {\n      position = 'left';\n      anchors.push('left');\n    } else {\n      position = 'bottom';\n      anchors.push('left', 'right');\n    }\n    pair.anchors = anchors;\n    pair.offset = 20;\n    pair.rect = placeRectByOrient(pair.rect, position, 0);\n    return pair;\n  });\n\n  return layoutByPosition(result);\n}\n\nexport function layoutOuter2(\n  pairs: IPairInfo[],\n  features: Feature[],\n  dataToPosition: (coord: number[]) => IPoint | null\n): IRect[] {\n  // 1. 计算几何中心\n  let x = 0;\n  let y = 0;\n  for (let i = 0; i < pairs.length; i++) {\n    x += pairs[i].pointCoord.x;\n    y += pairs[i].pointCoord.y;\n  }\n  x /= pairs.length;\n  y /= pairs.length;\n  const centerPosition = dataToPosition([x, y]);\n  if (!centerPosition) {\n    return [];\n  }\n\n  const count = pairs.length;\n\n  // 2. 按照圆心角排序\n  pairs.sort((a, b) => {\n    return lineDegree(centerPosition, a.point) - lineDegree(centerPosition, b.point);\n  });\n\n  const result = pairs.map((pair, index) => {\n    let degree = (360 / count) * index;\n    const _degree = lineDegree(centerPosition, pair.point);\n    degree = uniformDegree((degree + _degree) / 2);\n    const targetPoint = !isPointWithinFeatures(features, pair.pointCoord)\n      ? pair.point\n      : dataToPosition(nearestPoint(features, [pair.pointCoord.x, pair.pointCoord.y], degree));\n    if (targetPoint) {\n      pair.rect.x = targetPoint.x;\n      pair.rect.y = targetPoint.y;\n    }\n    // 3. 根据finalAnchor在包围圆上的位置，调整rect的位置\n    // 将圆根据圆心角划分为4个区域，对应不同的position\n    let position: IOrientType;\n    const anchors: IOrientType[] = [];\n    if (degree >= -45 && degree < 45) {\n      position = 'top';\n      anchors.push('left', 'right');\n    } else if (degree >= 45 && degree < 135) {\n      position = 'right';\n    } else if (degree >= -135 && degree < -45) {\n      position = 'left';\n      anchors.push('left');\n    } else {\n      position = 'bottom';\n      anchors.push('left', 'right');\n    }\n\n    pair.anchors = anchors;\n    pair.offset = 20;\n    pair.rect = placeRectByOrient(pair.rect, position, 0);\n    return pair;\n  });\n\n  return layoutByPosition(result.sort((a, b) => a.index - b.index));\n}\n\nfunction uniformDegree(degree: number) {\n  return degree > 180 ? degree - 360 : degree;\n}\n\nfunction lineDegree(start: IPoint, end: IPoint) {\n  return (Math.atan2(start.y - end.y, start.x - end.x) * 180) / Math.PI + 90;\n}\n\nfunction nearestPoint(features: Feature[], origin: number[], bearing: number, distance = 200) {\n  const count = 5621 / distance;\n  let curOrigin = origin;\n  for (let i = 1; i <= count; i++) {\n    const dest = destination(curOrigin as unknown as IPoint, distance, bearing);\n    if (!isPointWithinFeatures(features, dest)) {\n      return [dest.x, dest.y];\n    }\n    curOrigin = [dest.x, dest.y];\n  }\n  return origin;\n}\n\nfunction isPointWithinFeatures(features: Feature[], p: IPoint) {\n  for (let i = 0; i < features.length; i++) {\n    const inside = isPointInPolygon(p, features[i] as any);\n    if (inside) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * 以rect左上角为锚点的，根据position位置调整rect布局。\n * @param rect\n * @param position 在锚点的四周位置，'top' | 'bottom' | 'left' | 'right'\n * @param offset rect与锚点间的距离\n * @returns\n */\nexport function placeRectByOrient(rect: IRect, position: IOrientType, offset = 0) {\n  const result: IRect = { ...rect };\n  if (position === 'top') {\n    result.x -= rect.width / 2;\n    result.y -= offset + rect.height / 2;\n  } else if (position === 'bottom') {\n    result.x -= rect.width / 2;\n    result.y += offset - rect.height / 2;\n  } else if (position === 'left') {\n    result.x -= offset + rect.width;\n    result.y -= rect.height / 2;\n  } else if (position === 'right') {\n    result.x += offset;\n    result.y -= rect.height / 2;\n  }\n  return result;\n}\n\nexport function candidatesByOrient(\n  positions: IOrientType[],\n  anchor: IPoint,\n  rect: Pick<IRect, 'width' | 'height'>,\n  offset = 0\n) {\n  const candidates: IPoint[] = [];\n  positions.forEach((p: IOrientType) => {\n    const { x, y } = placeRectByOrient({ ...anchor, width: rect.width, height: rect.height }, p, offset);\n    candidates.push({ x, y });\n  });\n  return candidates;\n}\n"]}