"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.appendSeriesLabelConfig = exports.getSeriesLabelConfig = exports.dodgeHorizontal = exports.dodge = void 0;

const vutils_1 = require("@visactor/vutils"), constant_1 = require("./constant");

function range(start, stop, step) {
    start = +start, stop = +stop;
    let n = arguments.length;
    step = n < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
    let i = -1;
    n = 0 | Math.max(0, Math.ceil((stop - start) / step));
    const range = new Array(n);
    for (;++i < n; ) range[i] = start + i * step;
    return range;
}

function ascending(a, b) {
    return null == a || null == b ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function dodge(positions, separation = 10, maxIter = 10, maxError = .1) {
    const n = positions.length;
    if (!positions.every(isFinite)) return positions;
    if (!(n > 1)) return positions;
    const index = range(positions.length);
    for (let iter = 0; iter < maxIter; ++iter) {
        index.sort(((i, j) => ascending(positions[i], positions[j])));
        let error = 0;
        for (let i = 1; i < n; ++i) {
            let delta = positions[index[i]] - positions[index[i - 1]];
            delta < separation && (delta = (separation - delta) / 2, error = Math.max(error, delta), 
            positions[index[i - 1]] -= delta, positions[index[i]] += delta);
        }
        if (error < maxError) break;
    }
    return positions;
}

function isOverlap(box1, box2) {
    return !(box2.x1 > box1.x2 || box2.x2 < box1.x1 || box2.y1 > box1.y2 || box2.y2 < box1.y1);
}

function dodgeHorizontal(texts, separation = 10, maxIter = 10) {
    const n = texts.length;
    let hasOverlap, iter = 0;
    do {
        hasOverlap = !1;
        for (let i = 0; i < n; ++i) for (let j = i + 1; j < n; ++j) {
            const box1 = texts[i].AABBBounds, box2 = texts[j].AABBBounds;
            if (isOverlap(box1, box2)) {
                const delta = separation - (box2.x1 - box1.x2);
                delta > 0 && (texts[j].attribute.x += delta, box2.x1 += delta, box2.x2 += delta, 
                hasOverlap = !0);
            }
        }
        iter++;
    } while (hasOverlap && iter < maxIter);
}

function getSeriesLabelConfig(position, config) {
    const {label: label, line: line} = config;
    return {
        type: "component",
        componentType: constant_1.SERIES_LABEL,
        interactive: !1,
        style: {
            position: position,
            layout: (datum, ctx) => {
                var _a;
                return null !== (_a = ctx.vchart.getChart().getAllSeries()[0].getSpec().direction) && void 0 !== _a ? _a : "vertical";
            },
            data: (datum, ctx) => {
                var _a;
                const chart = ctx.vchart.getChart(), series = chart.getAllSeries()[0], isTransposed = "horizontal" === series.direction, bandAxisHelper = isTransposed ? series.getYAxisHelper() : series.getXAxisHelper(), bandAxisScale = null === (_a = bandAxisHelper.getScale) || void 0 === _a ? void 0 : _a.call(bandAxisHelper, 0), isBandAxisInverse = bandAxisHelper.isInverse(), dimensionField = series.getDimensionField()[0], seriesField = series.getSeriesField(), seriesTypes = chart.getAllSeries().map((s => s.type)).filter(((value, index, self) => self.indexOf(value) === index)), labelData = [];
                if (1 === seriesTypes.length && [ "bar", "area", "line", "waterfall" ].includes(seriesTypes[0])) {
                    ("both-ends" === position ? [ "start", "end" ] : [ position ]).forEach((pos => {
                        const targetValue = "end" === pos ? (0, vutils_1.last)(bandAxisScale.domain()) : bandAxisScale.domain()[0], region = series.getRegion(), {x: regionStartX, y: regionStartY} = region.getLayoutStartPoint();
                        let i = 0;
                        chart.getAllSeries().forEach((s => {
                            s.getMarkInName("waterfall" === seriesTypes[0] ? "bar" : seriesTypes[0]).getGraphics().forEach((g => {
                                var _a;
                                const data = g.context.data.find((datum => datum[dimensionField] === targetValue));
                                if (data) {
                                    const graphBounds = g.AABBBounds;
                                    let point, color, textAlign, textBaseline;
                                    "bar" === seriesTypes[0] || "waterfall" === seriesTypes[0] ? (point = "end" === pos ? {
                                        x: isTransposed ? (graphBounds.x1 + graphBounds.x2) / 2 : isBandAxisInverse ? graphBounds.x1 : graphBounds.x2,
                                        y: isTransposed ? isBandAxisInverse ? graphBounds.y2 : graphBounds.y1 : (graphBounds.y1 + graphBounds.y2) / 2
                                    } : {
                                        x: isTransposed ? (graphBounds.x1 + graphBounds.x2) / 2 : isBandAxisInverse ? graphBounds.x2 : graphBounds.x1,
                                        y: isTransposed ? isBandAxisInverse ? graphBounds.y1 : graphBounds.y2 : (graphBounds.y1 + graphBounds.y2) / 2
                                    }, color = g.attribute.fill) : (point = s.dataToPosition(data), color = g.attribute.stroke || g.attribute.fill), 
                                    "end" === pos ? (textAlign = isTransposed ? "center" : isBandAxisInverse ? "end" : "start", 
                                    textBaseline = isTransposed ? isBandAxisInverse ? "top" : "bottom" : "middle") : (textAlign = isTransposed ? "center" : isBandAxisInverse ? "start" : "end", 
                                    textBaseline = isTransposed ? isBandAxisInverse ? "bottom" : "top" : "middle");
                                    const labelValue = null !== (_a = data[seriesField]) && void 0 !== _a ? _a : data[dimensionField];
                                    labelData.push({
                                        point: {
                                            x: point.x + regionStartX,
                                            y: point.y + regionStartY
                                        },
                                        label: labelValue,
                                        color: color,
                                        textAlign: textAlign,
                                        textBaseline: textBaseline,
                                        series: s,
                                        datum: data,
                                        id: `${pos}-${i}`,
                                        position: pos
                                    }), i++;
                                }
                            }));
                        }));
                    }));
                }
                return labelData;
            },
            line: line,
            label: Object.assign({
                space: 12
            }, label)
        }
    };
}

function appendSeriesLabelConfig(rawSpec, seriesLabelSpec) {
    var _a, _b, _c;
    if (rawSpec.customMark = (0, vutils_1.array)(rawSpec.customMark).filter((obj => obj.componentType !== constant_1.SERIES_LABEL)), 
    seriesLabelSpec || (seriesLabelSpec = null !== (_c = null !== (_a = (0, vutils_1.get)(rawSpec, constant_1.SERIES_LABEL)) && void 0 !== _a ? _a : (0, 
    vutils_1.get)(null === (_b = rawSpec.series) || void 0 === _b ? void 0 : _b[0], constant_1.SERIES_LABEL)) && void 0 !== _c ? _c : {}), 
    seriesLabelSpec.visible) {
        const {position: position = "end"} = seriesLabelSpec, rest = __rest(seriesLabelSpec, [ "position" ]);
        rawSpec.customMark.push(getSeriesLabelConfig(position, rest));
    }
}

exports.dodge = dodge, exports.dodgeHorizontal = dodgeHorizontal, exports.getSeriesLabelConfig = getSeriesLabelConfig, 
exports.appendSeriesLabelConfig = appendSeriesLabelConfig;
//# sourceMappingURL=util.js.map
