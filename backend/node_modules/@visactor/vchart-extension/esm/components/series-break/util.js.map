{"version":3,"sources":["../src/components/series-break/util.ts"],"names":[],"mappings":"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","file":"util.js","sourcesContent":["/**\n * 支持轴翻转\n */\nimport type { ILinearAxisBreakSpec, ILinearAxisSpec } from '@visactor/vchart/esm/component/axis';\nimport type { ICartesianSeries, IMarkGraphic, ISpec } from '@visactor/vchart';\nimport type { SeriesBreakData } from './type';\nimport type { IPointLike } from '@visactor/vutils';\nimport { array, getIntersectPoint, isValid, PointService } from '@visactor/vutils';\nimport type { Point } from '@visactor/vrender-components';\nimport type { IArea, ILine } from '@visactor/vrender-core';\nimport { getAllRegionBounds } from '../../utils/element';\nimport { isNumberEqual } from '../../utils/math';\nimport { SERIES_BREAK } from './constant';\n\nconst barOffset = 2;\nconst lineOffset = 10;\nconst areaOffset = 0;\n\n/**\n * 获取系列标签的 spec 配置\n * @param position 显示位置\n * @param config 系列标签的样式配置\n * @returns\n */\nexport function getSeriesBreakConfig(axesSpec: ILinearAxisSpec[], axesIndex?: number[]) {\n  return {\n    type: 'component',\n    componentType: SERIES_BREAK,\n    interactive: true,\n    zIndex: 500,\n\n    style: {\n      data: (datum: any, ctx: any) => {\n        const seriesBreakData: SeriesBreakData[] = [];\n        const vchart = ctx.vchart;\n        const chart = vchart.getChart();\n        const series = chart.getAllSeries()[0] as ICartesianSeries;\n        const isHorizontal = series.direction === 'horizontal';\n        axesSpec.forEach((spec: any, index: number) => {\n          const axisId = spec.id;\n          const axisModel = isValid(axisId)\n            ? chart.getComponentByUserId(axisId)\n            : axesIndex && isValid(axesIndex[index])\n            ? chart.getComponentByIndex('axes', axesIndex[index])\n            : chart.getComponentsByKey('axes').filter((axis: { getSpec: () => any }) => {\n                const axisInnerSpec = axis.getSpec();\n\n                return axisInnerSpec.breaks === spec.breaks;\n              })?.[0];\n\n          if (!axisModel) {\n            return;\n          }\n          const parsedAxisId = axisId ?? `${axisModel.type}-${axisModel.id}`;\n\n          const regionBounds = getAllRegionBounds(axisModel.getRegions());\n\n          // todo 这里用到了内部变量，不太安全\n          array(axisModel._break?.breaks).forEach((breakConfig: ILinearAxisBreakSpec) => {\n            const { range, breakSymbol, gap = 5 } = breakConfig;\n            const pos1 = axisModel.valueToPosition(range[0]);\n            const pos2 = axisModel.valueToPosition(range[1]);\n\n            const posY = (pos1 + pos2) / 2 + (isHorizontal ? regionBounds.x1 : regionBounds.y1);\n\n            chart.getAllSeries().forEach((s: ICartesianSeries) => {\n              if (s.type === 'bar' || s.type === 'waterfall') {\n                const mark = s.getMarkInName('bar');\n                const graphics = mark.getGraphics();\n\n                graphics.forEach((element: IMarkGraphic) => {\n                  const elementBounds = element.AABBBounds;\n                  let shouldDrawBreak = false;\n                  let startX;\n                  let startY;\n                  let endX;\n                  let endY;\n                  if (isHorizontal) {\n                    shouldDrawBreak =\n                      elementBounds.x1 < (pos1 + pos2 - (gap as number)) / 2 &&\n                      elementBounds.x2 > (pos1 + pos2 + gap) / 2;\n\n                    startX = posY;\n                    startY = Math.max(elementBounds.y1 + regionBounds.y1 - barOffset, regionBounds.y1);\n\n                    endX = posY;\n                    endY = Math.min(elementBounds.y2 + regionBounds.y1 + barOffset, regionBounds.y2);\n                  } else {\n                    shouldDrawBreak =\n                      elementBounds.y1 < (pos1 + pos2 - (gap as number)) / 2 &&\n                      elementBounds.y2 > (pos1 + pos2 + gap) / 2;\n                    startX = Math.max(elementBounds.x1 + regionBounds.x1 - barOffset, regionBounds.x1);\n                    startY = posY;\n                    endX = Math.min(elementBounds.x2 + regionBounds.x1 + barOffset, regionBounds.x2);\n                    endY = posY;\n                  }\n\n                  if (shouldDrawBreak) {\n                    seriesBreakData.push({\n                      start: {\n                        x: startX,\n                        y: startY\n                      },\n                      end: {\n                        x: endX,\n                        y: endY\n                      },\n                      gap: gap as number,\n                      style: breakSymbol?.style,\n                      axisId: parsedAxisId,\n                      data: range\n                    });\n                  }\n                });\n              } else if (s.type === 'line') {\n                // 求水平直线/垂直线同 line path 的交点\n                const mark = s.getMarkInName(s.type);\n                const graphics = mark.getGraphics();\n                graphics.forEach(graphicItem => {\n                  const points = getAreaOrLinePathPoints(graphicItem, 'line');\n                  points.forEach(linePoints => {\n                    // 开始查找交点\n                    const intersections = getIntersectionsFromLineAndPolyline(\n                      isHorizontal\n                        ? {\n                            start: { x: (pos1 + pos2) / 2, y: 0 },\n                            end: { x: (pos1 + pos2) / 2, y: regionBounds.y2 - regionBounds.y1 }\n                          }\n                        : {\n                            start: { x: 0, y: (pos1 + pos2) / 2 },\n                            end: { x: regionBounds.x2 - regionBounds.x1, y: (pos1 + pos2) / 2 }\n                          },\n                      linePoints\n                    );\n\n                    intersections.forEach(intersection => {\n                      let start;\n                      let end;\n                      if (isHorizontal) {\n                        start = {\n                          x: posY,\n                          y: Math.max(intersection[1] + regionBounds.y1 - lineOffset, regionBounds.y1)\n                        };\n                        end = {\n                          x: posY,\n                          y: Math.min(intersection[1] + regionBounds.y1 + lineOffset, regionBounds.y2)\n                        };\n                      } else {\n                        start = {\n                          x: Math.max(intersection[0] + regionBounds.x1 - lineOffset, regionBounds.x1),\n                          y: posY\n                        };\n                        end = {\n                          x: Math.min(intersection[0] + regionBounds.x1 + lineOffset, regionBounds.x2),\n                          y: posY\n                        };\n                      }\n                      seriesBreakData.push({\n                        start,\n                        end,\n                        gap: gap as number,\n                        style: breakSymbol?.style,\n                        axisId: parsedAxisId,\n                        data: range\n                      });\n                    });\n                  });\n                });\n              } else if (s.type === 'area') {\n                // 默认面积去全部堆叠\n                const mark = s.getMarkInName('area');\n                const graphics = mark.getGraphics();\n                graphics.forEach(graphicItem => {\n                  const points = getAreaOrLinePathPoints(graphicItem, 'area');\n                  points.forEach(areaPoints => {\n                    const intersections = getIntersectionsFromLineAndPolyline(\n                      isHorizontal\n                        ? {\n                            start: { x: (pos1 + pos2) / 2, y: 0 },\n                            end: { x: (pos1 + pos2) / 2, y: regionBounds.y2 - regionBounds.y1 }\n                          }\n                        : {\n                            start: { x: 0, y: (pos1 + pos2) / 2 },\n                            end: { x: regionBounds.x2 - regionBounds.x1, y: (pos1 + pos2) / 2 }\n                          },\n                      areaPoints\n                    );\n\n                    intersections.sort((a, b) => a[0] - b[0]);\n\n                    for (let index = 0; index < intersections.length - 1; index++) {\n                      const lineStart = {\n                        x: intersections[index][0],\n                        y: intersections[index][1]\n                      };\n                      const lineEnd = {\n                        x: intersections[index + 1][0],\n                        y: intersections[index + 1][1]\n                      };\n                      if (\n                        isPointInPolygon(\n                          isHorizontal\n                            ? {\n                                x: lineStart.x,\n                                y: (lineStart.y + lineEnd.y) / 2\n                              }\n                            : {\n                                x: (lineStart.x + lineEnd.x) / 2,\n                                y: lineStart.y\n                              },\n                          areaPoints\n                        )\n                      ) {\n                        let start;\n                        let end;\n                        if (isHorizontal) {\n                          start = {\n                            x: lineStart.x + regionBounds.x1,\n                            y: Math.max(lineStart.y + regionBounds.y1 - areaOffset, regionBounds.y1)\n                          };\n                          end = {\n                            x: lineEnd.x + regionBounds.x1,\n                            y: Math.min(lineEnd.y + regionBounds.y1 + areaOffset, regionBounds.y2)\n                          };\n                        } else {\n                          start = {\n                            x: Math.max(lineStart.x + regionBounds.x1 - areaOffset, regionBounds.x1),\n                            y: lineStart.y + regionBounds.y1\n                          };\n                          end = {\n                            x: Math.min(lineEnd.x + regionBounds.x1 + areaOffset, regionBounds.x2),\n                            y: lineEnd.y + regionBounds.y1\n                          };\n                        }\n                        seriesBreakData.push({\n                          start,\n                          end,\n                          gap: gap as number,\n                          style: breakSymbol?.style,\n                          axisId: parsedAxisId,\n                          data: range\n                        });\n                      }\n                    }\n                  });\n                });\n              }\n            });\n          });\n        });\n\n        return seriesBreakData;\n      }\n    }\n  };\n}\n\nfunction getIntersectionsFromLineAndPolyline(line: { start: Point; end: Point }, points: Point[]) {\n  const intersections: [number, number][] = [];\n  for (let index = 1; index < points.length; index++) {\n    const intersection = getIntersectPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [points[index].x, points[index].y],\n      [points[index - 1].x, points[index - 1].y]\n    );\n    if (\n      intersection &&\n      !intersections.find(point =>\n        isNumberEqual(\n          PointService.distancePP(\n            { x: point[0], y: point[1] },\n            { x: (intersection as [number, number])[0], y: (intersection as [number, number])[1] }\n          ),\n          0\n        )\n      )\n    ) {\n      intersections.push(intersection as [number, number]);\n    }\n  }\n  return intersections;\n}\n\nfunction getAreaOrLinePathPoints(shape: IArea | ILine, type: 'line' | 'area') {\n  const { points, segments } = shape.attribute;\n  const pathPoints: Point[][] = [];\n  let eachPathPoints: Point[] = [];\n  const parsePoints = (points: IPointLike[]) => {\n    if (points && points.length) {\n      let basePoints: IPointLike[] = [];\n      points.forEach(point => {\n        if (point.defined === false) {\n          pathPoints.push(eachPathPoints);\n          if (type === 'area' && basePoints.length) {\n            for (let i = basePoints.length - 1; i >= 0; i--) {\n              eachPathPoints.push({\n                x: basePoints[i].x,\n                y: basePoints[i].y\n              });\n            }\n\n            eachPathPoints.push(eachPathPoints[0]);\n          }\n          eachPathPoints = [];\n          basePoints = [];\n        } else {\n          eachPathPoints.push({\n            x: point.x,\n            y: point.y\n          });\n\n          type === 'area' && basePoints.push({ x: point.x1 ?? point.x, y: point.y1 ?? point.y });\n        }\n      });\n\n      if (type === 'area' && basePoints.length) {\n        for (let i = basePoints.length - 1; i >= 0; i--) {\n          eachPathPoints.push({\n            x: basePoints[i].x,\n            y: basePoints[i].y\n          });\n        }\n        eachPathPoints.push(eachPathPoints[0]);\n      }\n\n      pathPoints.push(eachPathPoints);\n    }\n  };\n\n  if (points && points.length) {\n    parsePoints(points);\n  } else if (segments && segments.length) {\n    segments.forEach(seg => {\n      parsePoints(seg.points);\n    });\n  }\n\n  return pathPoints;\n}\n\nfunction isPointInPolygon(point: Point, polygon: Point[]) {\n  const { x, y } = point;\n  let inside = false;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const { x: xi, y: yi } = polygon[i];\n    const { x: xj, y: yj } = polygon[j];\n\n    const intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n}\n\nexport const appendSeriesBreakConfig = (rawSpec: ISpec) => {\n  if (rawSpec.axes?.length) {\n    const breakedAxes = (rawSpec.axes as any[]).filter(\n      (axis: any) => axis.breaks && axis.breaks.length && (axis as any).visible !== false\n    );\n\n    if (breakedAxes.length) {\n      (rawSpec as any).customMark = array((rawSpec as any).customMark).filter(\n        (obj: any) => obj.componentType !== SERIES_BREAK\n      );\n      (rawSpec as any).customMark.push(\n        getSeriesBreakConfig(\n          breakedAxes as ILinearAxisSpec[],\n          breakedAxes.map((axisSpec: any) => {\n            return rawSpec.axes.indexOf(axisSpec as any);\n          })\n        )\n      );\n      return true;\n    }\n  }\n\n  return false;\n};\n"]}