import { AbstractComponent } from "@visactor/vrender-components";

import { isEmpty } from "@visactor/vutils";

import { Factory } from "@visactor/vchart";

import { createText, createLine } from "@visactor/vrender-core";

import { dodge, dodgeHorizontal } from "./util";

import { SERIES_LABEL } from "./constant";

export class SeriesLabelComponent extends AbstractComponent {
    constructor() {
        super(...arguments), this.name = SERIES_LABEL;
    }
    render() {
        var _a, _b, _c, _d;
        this.removeAllChild();
        const {data: data, layout: layout, label: label, line: line = {}} = this.attribute;
        if (isEmpty(data)) return;
        const labelStyleMap = null !== (_a = null == label ? void 0 : label.styleMap) && void 0 !== _a ? _a : {}, adjustedPoints = {}, filteredData = data.filter((datum => {
            var _a;
            return !1 !== (null === (_a = labelStyleMap[datum.id]) || void 0 === _a ? void 0 : _a.visible);
        }));
        if ("vertical" === layout) {
            const lineHeight = 1.5 * (null !== (_c = null === (_b = null == label ? void 0 : label.style) || void 0 === _b ? void 0 : _b.fontSize) && void 0 !== _c ? _c : 12), createAndAddTextGraphic = (datum, textPoint, labelStyleMap) => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                const {label: text, color: color, textAlign: textAlign, textBaseline: textBaseline, id: id} = datum, formatMethod = null !== (_b = null === (_a = labelStyleMap[id]) || void 0 === _a ? void 0 : _a.formatMethod) && void 0 !== _b ? _b : null === (_c = this.attribute.label) || void 0 === _c ? void 0 : _c.formatMethod, textGraphic = createText(Object.assign(Object.assign(Object.assign(Object.assign({
                    text: formatMethod ? formatMethod(text, datum.datum, {
                        series: datum.series
                    }) : text
                }, null === (_d = this.attribute.label) || void 0 === _d ? void 0 : _d.style), textPoint), {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    fill: null !== (_g = null === (_f = null === (_e = this.attribute.label) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.fill) && void 0 !== _g ? _g : color
                }), null === (_h = labelStyleMap[id]) || void 0 === _h ? void 0 : _h.style));
                return textGraphic.name = "series-label-text", textGraphic.id = id, this.add(textGraphic), 
                textGraphic;
            };
            [ "start", "end" ].forEach((position => {
                const posData = filteredData.filter((datum => datum.position === position)), posYArr = posData.map((datum => datum.point.y)), dodgedPosY = dodge(posYArr, lineHeight);
                posData.forEach(((datum, index) => {
                    var _a;
                    const textPoint = {
                        x: datum.point.x + (null !== (_a = null == label ? void 0 : label.space) && void 0 !== _a ? _a : 8) * ("start" === datum.textAlign ? 1 : -1),
                        y: dodgedPosY[index]
                    };
                    createAndAddTextGraphic(datum, textPoint, labelStyleMap), adjustedPoints[datum.id] = textPoint;
                }));
            }));
        } else {
            const startTexts = [], endTexts = [];
            filteredData.forEach((datum => {
                var _a, _b, _c, _d, _e;
                const {point: point, label: text, color: color, textAlign: textAlign, textBaseline: textBaseline, id: id, position: position} = datum, textPoint = {
                    x: point.x,
                    y: point.y
                }, formatMethod = null !== (_b = null === (_a = labelStyleMap[id]) || void 0 === _a ? void 0 : _a.formatMethod) && void 0 !== _b ? _b : null == label ? void 0 : label.formatMethod, textGraphic = createText(Object.assign(Object.assign(Object.assign(Object.assign({
                    text: formatMethod ? formatMethod(text, datum.datum, {
                        series: datum.series
                    }) : text
                }, null == label ? void 0 : label.style), textPoint), {
                    textAlign: textAlign,
                    textBaseline: textBaseline,
                    fill: null !== (_d = null === (_c = null == label ? void 0 : label.style) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : color
                }), null === (_e = labelStyleMap[id]) || void 0 === _e ? void 0 : _e.style));
                textGraphic.id = id, textGraphic.name = "series-label-text", this.add(textGraphic), 
                "start" === position ? startTexts.push(textGraphic) : "end" === position && endTexts.push(textGraphic);
            })), startTexts.length && dodgeHorizontal(startTexts, 4, 10), endTexts.length && dodgeHorizontal(endTexts, 4, 10);
            const labelSpace = null !== (_d = null == label ? void 0 : label.space) && void 0 !== _d ? _d : 8;
            [ ...startTexts, ...endTexts ].forEach((text => {
                const flag = "top" === text.attribute.textBaseline ? 1 : -1;
                text.setAttribute("y", text.attribute.y + labelSpace * flag), adjustedPoints[text.id] = {
                    x: text.attribute.x,
                    y: text.attribute.y
                };
            }));
        }
        !1 !== line.visible && filteredData.forEach((datum => {
            var _a, _b, _c, _d, _e, _f;
            const {point: start, color: color, id: id} = datum, end = {
                x: adjustedPoints[id].x + (null !== (_c = null === (_b = null === (_a = labelStyleMap[id]) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.dx) && void 0 !== _c ? _c : 0),
                y: adjustedPoints[id].y + (null !== (_f = null === (_e = null === (_d = labelStyleMap[id]) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.dy) && void 0 !== _f ? _f : 0)
            };
            if (!1 !== line.autoVisible) {
                if ("vertical" === layout && start.y !== end.y || "horizontal" === layout && start.x !== end.x) {
                    const lineShape = createLine(Object.assign({
                        points: [ start, end ],
                        lineWidth: 1,
                        stroke: color
                    }, line.style));
                    lineShape.name = "series-label-line", this.add(lineShape);
                }
            } else {
                const lineShape = createLine(Object.assign({
                    points: [ start, end ],
                    lineWidth: 1,
                    stroke: color
                }, line.style));
                lineShape.name = "series-label-line", this.add(lineShape);
            }
        }));
    }
}

export const registerSeriesLabel = () => {
    Factory.registerGraphicComponent("seriesLabel", (attrs => new SeriesLabelComponent(attrs)));
};
//# sourceMappingURL=series-label.js.map
