{"version":3,"sources":["../src/components/series-label/util.ts"],"names":[],"mappings":"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","file":"util.js","sourcesContent":["import type { ICartesianSeries, IMarkGraphic, ISpec } from '@visactor/vchart';\nimport type { IText, TextAlignType, TextBaselineType } from '@visactor/vrender-core';\nimport { last, type IBoundsLike, array, get } from '@visactor/vutils';\nimport type { SeriesLabelAttrs, SeriesLabelData, SeriesLabelSpec } from './type';\nimport { SERIES_LABEL } from './constant';\n\nfunction range(start: number, stop?: any, step?: any) {\n  start = +start;\n  stop = +stop;\n\n  let n = arguments.length;\n  step = n < 2 ? ((stop = start), (start = 0), 1) : n < 3 ? 1 : +step;\n\n  let i = -1;\n  n = Math.max(0, Math.ceil((stop - start) / step)) | 0;\n  const range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n\nfunction ascending(a: number, b: number) {\n  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n\n/**\n * 文本垂直方向的扰动\n * @param positions y 坐标集合\n * @param separation 间距\n * @param maxIter 最大的迭代次数\n * @param maxError\n * @returns\n */\nexport function dodge(positions: number[], separation = 10, maxIter = 10, maxError = 1e-1) {\n  const n = positions.length;\n  if (!positions.every(isFinite)) {\n    return positions;\n  }\n  if (!(n > 1)) {\n    return positions;\n  }\n  const index = range(positions.length);\n  for (let iter = 0; iter < maxIter; ++iter) {\n    index.sort((i, j) => ascending(positions[i], positions[j]));\n    let error = 0;\n    for (let i = 1; i < n; ++i) {\n      let delta = positions[index[i]] - positions[index[i - 1]];\n      if (delta < separation) {\n        delta = (separation - delta) / 2;\n        error = Math.max(error, delta);\n        positions[index[i - 1]] -= delta;\n        positions[index[i]] += delta;\n      }\n    }\n    if (error < maxError) {\n      break;\n    }\n  }\n  return positions;\n}\n\n// 检测两个包围盒是否重叠\nfunction isOverlap(box1: IBoundsLike, box2: IBoundsLike) {\n  return !(box2.x1 > box1.x2 || box2.x2 < box1.x1 || box2.y1 > box1.y2 || box2.y2 < box1.y1);\n}\n\n/**\n * 水平方向的文本扰动算法\n * @param texts 文本实例集合\n * @param separation 间距\n * @param maxIter 最大迭代次数\n */\nexport function dodgeHorizontal(texts: IText[], separation = 10, maxIter = 10) {\n  const n = texts.length;\n  let hasOverlap;\n  let iter = 0;\n  do {\n    hasOverlap = false;\n    for (let i = 0; i < n; ++i) {\n      for (let j = i + 1; j < n; ++j) {\n        const box1 = texts[i].AABBBounds;\n        const box2 = texts[j].AABBBounds;\n        if (isOverlap(box1, box2)) {\n          const delta = separation - (box2.x1 - box1.x2);\n          if (delta > 0) {\n            texts[j].attribute.x += delta;\n            box2.x1 += delta;\n            box2.x2 += delta;\n            hasOverlap = true;\n          }\n        }\n      }\n    }\n    iter++;\n  } while (hasOverlap && iter < maxIter);\n}\n\n/**\n * 获取系列标签的 spec 配置\n * @param position 显示位置\n * @param config 系列标签的样式配置\n * @returns\n */\nexport function getSeriesLabelConfig(\n  position: 'start' | 'end' | 'both-ends',\n  config: Pick<SeriesLabelAttrs, 'line' | 'label'>\n) {\n  const { label, line } = config;\n  return {\n    type: 'component',\n    componentType: SERIES_LABEL,\n    interactive: false,\n    style: {\n      position,\n      layout: (datum: any, ctx: any) => {\n        const vchart = ctx.vchart;\n        const series = vchart.getChart().getAllSeries()[0];\n        return series.getSpec().direction ?? 'vertical';\n      },\n      data: (datum: any, ctx: any) => {\n        const vchart = ctx.vchart;\n        const chart = vchart.getChart();\n        const series = chart.getAllSeries()[0] as ICartesianSeries;\n        const isTransposed = series.direction === 'horizontal';\n        const bandAxisHelper = (isTransposed ? series.getYAxisHelper() : series.getXAxisHelper()) as any;\n        const bandAxisScale = bandAxisHelper.getScale?.(0) as any;\n        const isBandAxisInverse = bandAxisHelper.isInverse();\n        const dimensionField = series.getDimensionField()[0];\n        const seriesField = series.getSeriesField() as string;\n        const seriesTypes = chart\n          .getAllSeries()\n          .map((s: ICartesianSeries) => s.type)\n          .filter((value: string, index: number, self: string[]) => {\n            return self.indexOf(value) === index;\n          });\n        const labelData: SeriesLabelData[] = [];\n\n        // 系列标签目前不支持不同系列的组合图\n        if (seriesTypes.length === 1 && ['bar', 'area', 'line', 'waterfall'].includes(seriesTypes[0])) {\n          const positions = position === 'both-ends' ? ['start', 'end'] : [position];\n          positions.forEach(pos => {\n            const targetValue = pos === 'end' ? last(bandAxisScale.domain()) : bandAxisScale.domain()[0];\n            const region = series.getRegion();\n            const { x: regionStartX, y: regionStartY } = region.getLayoutStartPoint();\n            let i = 0;\n            chart.getAllSeries().forEach((s: ICartesianSeries) => {\n              const mark = s.getMarkInName(seriesTypes[0] === 'waterfall' ? 'bar' : seriesTypes[0]);\n              const graphics = mark.getGraphics();\n\n              graphics.forEach((g: IMarkGraphic) => {\n                const data = g.context.data.find((datum: any) => datum[dimensionField] === targetValue);\n                if (data) {\n                  const graphBounds = g.AABBBounds;\n\n                  let point;\n                  let color;\n                  if (seriesTypes[0] === 'bar' || seriesTypes[0] === 'waterfall') {\n                    point =\n                      pos === 'end'\n                        ? {\n                            x: isTransposed\n                              ? (graphBounds.x1 + graphBounds.x2) / 2\n                              : isBandAxisInverse\n                              ? graphBounds.x1\n                              : graphBounds.x2,\n                            y: isTransposed\n                              ? isBandAxisInverse\n                                ? graphBounds.y2\n                                : graphBounds.y1\n                              : (graphBounds.y1 + graphBounds.y2) / 2\n                          }\n                        : {\n                            x: isTransposed\n                              ? (graphBounds.x1 + graphBounds.x2) / 2\n                              : isBandAxisInverse\n                              ? graphBounds.x2\n                              : graphBounds.x1,\n                            y: isTransposed\n                              ? isBandAxisInverse\n                                ? graphBounds.y1\n                                : graphBounds.y2\n                              : (graphBounds.y1 + graphBounds.y2) / 2\n                          };\n                    color = g.attribute.fill;\n                  } else {\n                    point = s.dataToPosition(data);\n                    color = g.attribute.stroke || g.attribute.fill;\n                  }\n\n                  let textAlign: TextAlignType;\n                  let textBaseline: TextBaselineType;\n                  if (pos === 'end') {\n                    textAlign = isTransposed ? 'center' : isBandAxisInverse ? 'end' : 'start';\n                    textBaseline = isTransposed ? (isBandAxisInverse ? 'top' : 'bottom') : 'middle';\n                  } else {\n                    textAlign = isTransposed ? 'center' : isBandAxisInverse ? 'start' : 'end';\n                    textBaseline = isTransposed ? (isBandAxisInverse ? 'bottom' : 'top') : 'middle';\n                  }\n\n                  const labelValue = data[seriesField] ?? data[dimensionField];\n\n                  labelData.push({\n                    point: {\n                      x: point.x + regionStartX,\n                      y: point.y + regionStartY\n                    },\n                    label: labelValue,\n                    color: color as string,\n                    textAlign,\n                    textBaseline,\n                    series: s,\n                    datum: data,\n                    id: `${pos}-${i}`,\n                    position: pos\n                  });\n                  i++;\n                }\n              });\n            });\n          });\n        }\n\n        return labelData;\n      },\n      line,\n      label: {\n        space: 12,\n        ...label\n      }\n    }\n  };\n}\n\nexport function appendSeriesLabelConfig(rawSpec: ISpec, seriesLabelSpec?: SeriesLabelSpec) {\n  (rawSpec as any).customMark = array((rawSpec as any).customMark).filter(\n    (obj: any) => obj.componentType !== SERIES_LABEL\n  );\n\n  if (!seriesLabelSpec) {\n    seriesLabelSpec = get(rawSpec, SERIES_LABEL) ?? get(rawSpec.series?.[0], SERIES_LABEL) ?? {};\n  }\n  if (seriesLabelSpec.visible) {\n    const { position = 'end', ...rest } = seriesLabelSpec;\n    (rawSpec as any).customMark.push(getSeriesLabelConfig(position, rest));\n  }\n}\n"]}