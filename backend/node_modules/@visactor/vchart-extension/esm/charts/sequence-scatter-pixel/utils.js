import { BACKGROUND_KEY, DATA_KEY } from "./constant";

export function createImageDataFromColorMatrix(colorMatrix, spec) {
    var _a;
    if ("undefined" == typeof document) throw new Error("Canvas rendering requires browser environment with document object");
    const canvas = document.createElement("canvas");
    canvas.width = spec.width, canvas.height = spec.height;
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("Failed to get 2D rendering context from canvas");
    const imageData = ctx.createImageData(spec.width, spec.height);
    for (let y = 0; y < 300; y++) for (let x = 0; x < 300; x++) {
        const rgb = (null === (_a = colorMatrix[y]) || void 0 === _a ? void 0 : _a[x]) || [ 0, 0, 0 ], pixelIndex = 4 * (300 * y + x);
        imageData.data[pixelIndex] = Math.round(255 * rgb[0]), imageData.data[pixelIndex + 1] = Math.round(255 * rgb[1]), 
        imageData.data[pixelIndex + 2] = Math.round(255 * rgb[2]), imageData.data[pixelIndex + 3] = 255;
    }
    return ctx.putImageData(imageData, 0, 0), canvas.toDataURL("image/png");
}

export function processSequenceData(spec) {
    const result = [];
    return Object.keys(spec.data).forEach((inter => {
        let backgroundData = null;
        if (spec.backgroundColors && spec.backgroundColors[inter]) {
            backgroundData = {
                imageData: createImageDataFromColorMatrix(spec.backgroundColors[inter], spec)
            };
        }
        result.push({
            data: [ {
                id: "nodes",
                values: spec.data[inter].map(((d, i) => Object.assign(Object.assign({}, d), {
                    [DATA_KEY]: i
                })))
            }, {
                id: "inter",
                values: [ {
                    inter: inter
                } ]
            }, {
                id: BACKGROUND_KEY,
                values: backgroundData ? [ backgroundData ] : []
            } ]
        });
    })), result;
}
//# sourceMappingURL=utils.js.map
