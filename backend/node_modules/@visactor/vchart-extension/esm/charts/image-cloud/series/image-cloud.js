import { IMAGE_CLOUD_SERIES_TYPE, imageCloudSeriesMark } from "./constant";

import { isValid } from "@visactor/vutils";

import { imagecloudTransform } from "@visactor/vlayouts";

import { registerImageCloudAnimation } from "./animation";

import { ImageCloudTooltipHelper } from "./tooltip-helper";

import { createImage } from "@visactor/vrender-core";

import { animationConfig, AttributeLevel, BaseSeries, DEFAULT_DATA_KEY, Factory, registerImageMark, userAnimationConfig, vglobal } from "@visactor/vchart";

export class ImageCloudSeries extends BaseSeries {
    constructor() {
        super(...arguments), this.type = IMAGE_CLOUD_SERIES_TYPE;
    }
    setValueField(field) {
        isValid(field) && (this._valueField = field);
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this._nameField = this._spec.nameField, this._valueField = this._spec.valueField, 
        this._urlField = this._spec.urlField;
    }
    initMark() {
        var _a;
        (null === (_a = this._spec.imageMask) || void 0 === _a ? void 0 : _a.visible) && (this._maskMark = this._createMark(imageCloudSeriesMark.imageMask, {
            dataView: !1,
            skipBeforeLayouted: !0
        })), this._imageMark = this._createMark(imageCloudSeriesMark.image, {
            key: datum => `${datum[DEFAULT_DATA_KEY]}-${datum.frequency}`,
            isSeriesMark: !0,
            skipBeforeLayouted: !0
        });
    }
    initMarkStyle() {
        this._initImageMarkStyle(), this._initMaskMarkStyle();
    }
    _initImageMarkStyle() {
        var _a, _b;
        if (!this._imageMark) return;
        this._imageMark.setTransform([ Object.assign({
            type: "imagecloud"
        }, this._imageCloudTransformOption()) ]), this.setMarkStyle(this._imageMark, {
            x: datum => datum.x,
            y: datum => datum.y,
            width: datum => datum.width,
            height: datum => datum.height,
            visible: datum => datum.visible,
            angle: datum => datum.angle,
            clipConfig: datum => datum.clipConfig,
            image: datum => datum[this._urlField],
            scaleCenter: [ "50%", "50%" ]
        }, "normal", AttributeLevel.Series);
        "masked" === (null === (_a = this._spec.layoutConfig) || void 0 === _a ? void 0 : _a.placement) && (this.setMarkStyle(this._imageMark, {
            globalCompositeOperation: "source-atop"
        }, "normal", AttributeLevel.Series), this.setMarkStyle(this._rootMark, {
            width: () => this._region.getLayoutRect().width,
            height: () => this._region.getLayoutRect().height,
            globalCompositeOperation: "destination-in",
            clip: !0,
            drawMode: 1
        }, "normal", AttributeLevel.Series)), "stack" === (null === (_b = this._spec.layoutConfig) || void 0 === _b ? void 0 : _b.layoutMode) && this.setMarkStyle(this._imageMark, {
            stroke: "white",
            lineWidth: 2,
            shadowBlur: 6,
            shadowColor: "grey"
        }, "normal", AttributeLevel.Series);
    }
    isFillingImage(datum) {
        return datum._frequency > 1;
    }
    _initMaskMarkStyle() {
        this._maskMark && (this._maskMark.setMarkConfig({
            interactive: !1
        }), this.setMarkStyle(this._maskMark, {
            width: () => this._region.getLayoutRect().width,
            height: () => this._region.getLayoutRect().height
        }, "normal", AttributeLevel.Series));
    }
    initTooltip() {
        this._tooltipHelper = new ImageCloudTooltipHelper(this), this._imageMark && this._tooltipHelper.activeTriggerSet.mark.add(this._imageMark);
    }
    _imageCloudTransformOption() {
        var _a;
        return {
            size: () => {
                const {width: width, height: height} = this._region.getLayoutRect();
                return [ width, height ];
            },
            image: {
                field: this._urlField
            },
            weight: {
                field: this._valueField
            },
            imageConfig: {
                imageSize: this._spec.imageSize,
                imageSizeRange: this._spec.imageSizeRange,
                padding: null === (_a = this._spec.image) || void 0 === _a ? void 0 : _a.padding
            },
            ratio: this._spec.ratio,
            mask: this._spec.maskShape,
            maskConfig: this._spec.imageMask,
            layoutConfig: this._spec.layoutConfig,
            createCanvas: vglobal.createCanvas.bind(vglobal),
            createImage: createImage,
            onUpdateMaskCanvas: ((inputImage, maskImage) => {
                var _a;
                inputImage && this._maskMark && this._maskMark.getProduct().getChildren().forEach((element => {
                    element.setAttribute("background", inputImage);
                })), maskImage && "masked" === (null === (_a = this._spec.layoutConfig) || void 0 === _a ? void 0 : _a.placement) && this._rootMark.getProduct().setAttribute("background", maskImage);
            }).bind(this),
            onLayoutFinished: () => {
                var _a, _b;
                return null === (_b = null === (_a = this._option.globalInstance.getChart().getOption().performanceHook) || void 0 === _a ? void 0 : _a.afterWordcloudShapeDraw) || void 0 === _b ? void 0 : _b.call(_a, this._option.globalInstance);
            }
        };
    }
    _buildMarkAttributeContext() {
        super._buildMarkAttributeContext(), this._markAttributeContext.isFillingImage = this.isFillingImage.bind(this);
    }
    initAnimation() {
        [ this._imageMark ].forEach((mark => {
            var _a, _b;
            if (mark) {
                const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, params = {
                    center: () => {
                        const {width: width, height: height} = this._region.getLayoutRect();
                        return {
                            x: width / 2,
                            y: height / 2
                        };
                    },
                    height: () => {
                        const {height: height} = this._region.getLayoutRect();
                        return height;
                    }
                };
                mark.setAnimationConfig(animationConfig(Factory.getAnimationInKey("imageCloud")(params, appearPreset), userAnimationConfig("image", this._spec, this._markAttributeContext)));
            }
        }));
    }
    getDimensionField() {
        var _a;
        return [ null !== (_a = this._nameField) && void 0 !== _a ? _a : this._spec.urlField ];
    }
    getMeasureField() {
        return [ this._valueField ];
    }
    getStatisticFields() {
        const fields = [];
        return fields.push({
            key: this._nameField,
            operations: [ "values" ]
        }), fields.push({
            key: this._valueField,
            operations: [ "max", "min" ]
        }), fields;
    }
    getActiveMarks() {
        return [ this._imageMark ];
    }
    getMarkData(datum) {
        var _a;
        return null !== (_a = null == datum ? void 0 : datum.datum) && void 0 !== _a ? _a : datum;
    }
    getGroupFields() {
        return [];
    }
    dataToPosition(data) {
        return null;
    }
    dataToPositionX(data) {
        var _a;
        return null === (_a = this.dataToPosition(data)) || void 0 === _a ? void 0 : _a.x;
    }
    dataToPositionY(data) {
        var _a;
        return null === (_a = this.dataToPosition(data)) || void 0 === _a ? void 0 : _a.y;
    }
    valueToPosition(value1, value2) {
        return null;
    }
    getStackGroupFields() {
        return [];
    }
    getStackValueField() {
        return "";
    }
}

ImageCloudSeries.type = IMAGE_CLOUD_SERIES_TYPE, ImageCloudSeries.mark = imageCloudSeriesMark;

export const registerImageCloudSeries = () => {
    registerImageMark(), registerImageCloudAnimation(), Factory.registerSeries(ImageCloudSeries.type, ImageCloudSeries), 
    Factory.registerGrammarTransform("imagecloud", {
        transform: imagecloudTransform
    });
};
//# sourceMappingURL=image-cloud.js.map
