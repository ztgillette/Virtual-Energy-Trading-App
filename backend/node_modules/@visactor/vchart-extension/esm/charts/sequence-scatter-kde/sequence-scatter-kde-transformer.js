import { CommonChartSpecTransformer } from "@visactor/vchart";

import { calculateKDE } from "./utils";

const DATA_KEY = "dataKey";

export class SequenceScatterKDEChartSpecTransformer extends CommonChartSpecTransformer {
    transformSpec(spec) {
        var _a, _b, _c, _d, _e, _f;
        super.transformSpec(spec);
        const dataSpecs = processSequenceData(spec);
        spec.type = "common", spec.dataKey = DATA_KEY, spec.data = dataSpecs[0].data, spec.scales = [ {
            id: "colorScale",
            type: "ordinal",
            specified: {
                0: "rgb(150, 10, 100)",
                1: "rgb(31, 119, 180)",
                2: "rgb(255, 127, 14)",
                3: "rgb(44, 160, 44)",
                4: "rgb(214, 39, 40)",
                5: "rgb(148, 103, 189)",
                6: "rgb(140, 86, 75)",
                7: "rgb(227, 119, 194)",
                8: "rgb(127, 127, 127)",
                9: "rgb(188, 189, 34)",
                10: "rgb(23, 190, 207)"
            }
        }, {
            id: "brighterColorScale",
            type: "ordinal",
            specified: {
                0: "rgb(150, 10, 150)",
                1: "rgb(31, 119, 230)",
                2: "rgb(255, 127, 64)",
                3: "rgb(44, 160, 94)",
                4: "rgb(214, 39, 90)",
                5: "rgb(148, 103, 239)",
                6: "rgb(140, 86, 125)",
                7: "rgb(227, 119, 244)",
                8: "rgb(127, 127, 177)",
                9: "rgb(188, 189, 84)",
                10: "rgb(23, 190, 255)"
            }
        }, ...null !== (_a = spec.scales) && void 0 !== _a ? _a : [] ], spec.series = [ {
            type: "scatter",
            dataIndex: 0,
            xField: spec.xField,
            yField: spec.yField,
            seriesField: spec.seriesField,
            size: 5,
            point: {
                zIndex: 1e3,
                style: {
                    fill: {
                        scale: "colorScale",
                        field: spec.seriesField
                    }
                }
            }
        } ];
        spec.customMark = [ {
            type: "text",
            dataIndex: 1,
            style: Object.assign({
                text: datum => datum.iter,
                x: 10,
                y: () => 10,
                textBaseline: "top",
                textAlign: "left",
                fontSize: 25,
                fontWeight: "bolder",
                fill: "black",
                fillOpacity: .2
            }, null === (_b = spec.infoLabel) || void 0 === _b ? void 0 : _b.style)
        }, {
            type: "symbol",
            dataIndex: 2,
            style: {
                symbolType: "rect",
                x: (datum, ctx) => 54 + (0, ctx.chart.getAllSeries()[0]._markAttributeContext.valueToX)([ datum.x ]),
                y: (datum, ctx) => (0, ctx.chart.getAllSeries()[0]._markAttributeContext.valueToY)([ datum.y ]) + 26,
                size: 5,
                fill: {
                    scale: "brighterColorScale",
                    field: "label"
                },
                fillOpacity: datum => 10 * datum.kde
            }
        } ], spec.tooltip = {
            visible: !0,
            fields: [ "x", "y", "label" ]
        }, spec.player && (spec.player = Object.assign(Object.assign({}, spec.player), {
            specs: dataSpecs
        }), spec.animationAppear = {
            duration: null !== (_d = null === (_c = spec.player) || void 0 === _c ? void 0 : _c.duration) && void 0 !== _d ? _d : 2e3,
            easing: "linear"
        }, spec.animationUpdate = {
            duration: null !== (_f = null === (_e = spec.player) || void 0 === _e ? void 0 : _e.duration) && void 0 !== _f ? _f : 2e3,
            easing: "linear"
        }), spec.axes = [ {
            orient: "left",
            type: "linear",
            nice: !0
        }, {
            orient: "bottom",
            type: "linear",
            nice: !0,
            label: {
                visible: !0
            }
        } ], super.transformSpec(spec);
    }
}

export function processSequenceData(spec) {
    const result = [];
    return Object.keys(spec.data).forEach((iter => {
        const currentData = spec.data[iter].map(((d, i) => Object.assign(Object.assign({}, d), {
            [DATA_KEY]: i
        }))), kdeResults = calculateKDE(currentData, 150);
        result.push({
            data: [ {
                id: "nodes",
                values: currentData
            }, {
                id: "iter",
                values: [ {
                    iter: iter
                } ]
            }, {
                id: "kde",
                values: kdeResults
            } ]
        });
    })), result;
}
//# sourceMappingURL=sequence-scatter-kde-transformer.js.map
