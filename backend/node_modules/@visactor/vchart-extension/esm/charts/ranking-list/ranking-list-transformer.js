import { CommonChartSpecTransformer } from "@visactor/vchart";

import { cloneDeep, TextMeasure } from "@visactor/vutils";

import { defaultSpec } from "./constant";

import { applyVisible, computeDataRange, mergeObjects } from "./utils";

const DATA_KEY = "dataKey", ORDER_KEY = "VCHART_ORDER", SUPPLY_DATA_KEY = "SUPPLY_DATA_KEY", NAME_LABEL_PADDING_RIGHT = 10, NAME_ORDER_PADDING_RIGHT = 5, NAME_SYMBOL_PADDING_RIGHT = 8, CHART_PADDING_LEFT = 5, CHART_PADDING_RIGHT = 5, VALUE_LABEL_PADDING_LEFT = 5, LABEL_PADDING_BOTTOM = 5;

export class RankingListChartSpecTransformer extends CommonChartSpecTransformer {
    constructor() {
        super(...arguments), this.formatMap = {}, this.paginateDataArr = spec => {
            const {scrollSize: scrollSize = 1, pageSize: pageSize = 5} = spec, arr = this.originalData, result = {};
            let pageOrder = 0;
            for (let i = 0; i < arr.length; i += scrollSize) if (pageOrder++, result[`page${pageOrder}`] = arr.slice(i, i + pageSize), 
            i + pageSize - 1 >= arr.length - 1) {
                arr.push(...Array.from({
                    length: i + pageSize - arr.length
                }, (_ => ({
                    [spec.yField]: 100 * Math.random(),
                    [spec.xField]: null,
                    [SUPPLY_DATA_KEY]: !0
                }))));
                break;
            }
            return {
                orderCount: pageOrder,
                result: result
            };
        }, this.processRankingData = spec => {
            const result = [];
            spec.data.forEach(((datum, index) => datum[ORDER_KEY] = index + 1 < 10 ? `0${index + 1}` : index + 1));
            const pagerData = this.paginateDataArr(spec).result, orderCount = this.paginateDataArr(spec).orderCount;
            this.orderCount = orderCount;
            const supplyCount = spec.pageSize - pagerData[`page${orderCount}`].length;
            return pagerData[`page${orderCount}`].push(...Array.from({
                length: supplyCount
            }, (_ => ({
                [spec.yField]: 100 * Math.random(),
                [spec.xField]: null,
                [SUPPLY_DATA_KEY]: !0
            })))), Object.keys(pagerData).forEach((order => {
                result.push({
                    data: [ {
                        id: "datas",
                        values: pagerData[order].map((d => Object.assign(Object.assign({}, d), {
                            [DATA_KEY]: d[spec.yField]
                        })))
                    }, {
                        id: "order",
                        values: [ {
                            order: order
                        } ]
                    } ]
                });
            })), result;
        };
    }
    isSpecValid(spec) {
        const {xField: xField, yField: yField, data: data} = spec;
        return !!(xField && yField && data && 0 !== data.length);
    }
    transformSpec(spec) {
        var _a;
        super.transformSpec(spec), this.isSpecValid(spec) ? (this.normalizeSpec(spec), this.upgradeTextMeasure(spec), 
        this.upgradeFormatMap(spec), this.processData(spec), this.transformBaseSpec(spec), 
        this.transformAnimationSpec(spec), this.transformAxesSpec(spec), spec.extensionMark = [ this.generateBarBackground(spec), ...this.generateDecorateHaloIcons(spec), this.generateRankingIcon(spec), this.generateNameLabel(spec), this.generateOrderLabel(spec), this.generateValueLabel(spec) ], 
        this.transformPaddingSpec(spec), null === (_a = spec.customTransformSpec) || void 0 === _a || _a.call(spec, spec), 
        super.transformSpec(spec)) : spec.series = [];
    }
    normalizeSpec(spec) {
        mergeObjects(spec, defaultSpec), applyVisible(spec, [ "barBackground", "rankingIcon", "decorateHaloIcons", "orderLabel", "nameLabel", "valueLabel" ]);
    }
    upgradeTextMeasure(spec) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        null === (_a = this.nameLabelTextMeasure) || void 0 === _a || _a.release(), null === (_b = this.valueLabelTextMeasure) || void 0 === _b || _b.release(), 
        null === (_c = this.orderLabelTextMeasure) || void 0 === _c || _c.release(), this.nameLabelTextMeasure = new TextMeasure({
            defaultFontParams: null !== (_e = null === (_d = spec.nameLabel) || void 0 === _d ? void 0 : _d.style) && void 0 !== _e ? _e : {}
        }), this.valueLabelTextMeasure = new TextMeasure({
            defaultFontParams: null !== (_g = null === (_f = spec.valueLabel) || void 0 === _f ? void 0 : _f.style) && void 0 !== _g ? _g : {}
        }), this.orderLabelTextMeasure = new TextMeasure({
            defaultFontParams: null !== (_j = null === (_h = spec.orderLabel) || void 0 === _h ? void 0 : _h.style) && void 0 !== _j ? _j : {}
        });
    }
    upgradeFormatMap(spec) {
        this.formatMap[spec.yField] = spec.nameLabel.formatMethod, this.formatMap[spec.xField] = spec.valueLabel.formatMethod, 
        this.formatMap[ORDER_KEY] = spec.orderLabel.formatMethod;
    }
    processData(spec) {
        var _a;
        (null === (_a = spec.data[0]) || void 0 === _a ? void 0 : _a.values) || (this.originalData = spec.data, 
        this.originalSpec = cloneDeep(spec), this.dataSpecs = this.processRankingData(spec), 
        spec.data = this.dataSpecs[0].data);
    }
    transformBaseSpec(spec) {
        var _a, _b, _c;
        spec.type = "common", spec.dataKey = DATA_KEY, spec.series = [ {
            type: "bar",
            direction: "horizontal",
            xField: spec.xField,
            yField: spec.yField,
            barWidth: null !== (_b = null === (_a = spec.bar) || void 0 === _a ? void 0 : _a.height) && void 0 !== _b ? _b : 10,
            bar: Object.assign(Object.assign({}, spec.bar), {
                style: Object.assign(Object.assign({}, null === (_c = spec.bar) || void 0 === _c ? void 0 : _c.style), {
                    x1: 0,
                    visible: datum => {
                        var _a, _b;
                        return !datum[SUPPLY_DATA_KEY] && (null === (_b = null === (_a = spec.bar) || void 0 === _a ? void 0 : _a.style) || void 0 === _b || _b);
                    }
                })
            })
        } ];
    }
    transformAnimationSpec(spec) {
        var _a, _b, _c;
        spec.animationUpdate.enable && this.orderCount > 1 && (spec.player = Object.assign({
            specs: this.dataSpecs,
            auto: !0,
            visible: !1,
            interval: (null !== (_b = null === (_a = spec.animationNormal) || void 0 === _a ? void 0 : _a.interval) && void 0 !== _b ? _b : 1e3) + (null !== (_c = spec.animationUpdate.duration) && void 0 !== _c ? _c : 1e3) / 2,
            loop: !0
        }, spec.player), spec.animationExit = this.getAnimationExit(this.originalSpec), 
        spec.animationEnter = this.getAnimationEnter(this.originalSpec), spec.animationUpdate = this.getAnimationUpdate(this.originalSpec)), 
        spec.animationNormal = this.originalSpec.animationNormal, spec.animationAppear = this.getAnimationAppear(this.originalSpec, "rect");
    }
    transformAxesSpec(spec) {
        const {min: min, max: max} = computeDataRange(this.originalData, spec.xField);
        spec.axes = [ {
            orient: "left",
            type: "band",
            visible: !1,
            inverse: !0,
            paddingOuter: .5
        }, {
            orient: "bottom",
            label: {
                visible: !0
            },
            type: "linear",
            visible: !1,
            min: min,
            max: max
        } ];
    }
    generateBarBackground(spec) {
        var _a;
        return {
            type: spec.barBackground.type,
            dataId: "data",
            visible: !0,
            dataKey: DATA_KEY,
            zIndex: -99,
            state: null === (_a = spec.barBackground) || void 0 === _a ? void 0 : _a.state,
            style: Object.assign(Object.assign({
                x: (datum, ctx) => "symbol" === spec.barBackground.type ? ctx.getRegion().getLayoutRect().width / 2 : 0,
                y: (datum, ctx) => ctx.valueToY([ datum[spec.yField] ]) + ctx.yBandwidth() / 2 - ("symbol" === spec.barBackground.type ? 0 : spec.bar.height / 2),
                size: (datum, ctx) => [ ctx.getRegion().getLayoutRect().width, spec.bar.height ],
                width: (datum, ctx) => ctx.getRegion().getLayoutRect().width,
                height: spec.bar.height
            }, spec.barBackground.style), {
                visible: datum => !datum[SUPPLY_DATA_KEY] && spec.barBackground.style.visible
            }),
            animation: !0,
            animationEnter: this.getAnimationEnter(this.originalSpec),
            animationExit: this.getAnimationExit(this.originalSpec),
            animationAppear: this.getAnimationAppear(this.originalSpec, "barBack"),
            animationUpdate: this.getAnimationUpdate(this.originalSpec)
        };
    }
    generateDecorateHaloIcons(spec) {
        var _a;
        return null === (_a = spec.decorateHaloIcons) || void 0 === _a ? void 0 : _a.map((decorateHaloIcon => ({
            type: "symbol",
            dataId: "data",
            visible: !0,
            dataKey: DATA_KEY,
            state: null == decorateHaloIcon ? void 0 : decorateHaloIcon.state,
            style: Object.assign(Object.assign({
                x: (datum, ctx) => {
                    if (void 0 !== datum[spec.xField] && null !== datum[spec.xField]) return ctx.valueToX([ datum[spec.xField] ]);
                },
                y: (datum, ctx) => ctx.valueToY([ datum[spec.yField] ]) + ctx.yBandwidth() / 2
            }, decorateHaloIcon.style), {
                visible: datum => !datum[SUPPLY_DATA_KEY] && decorateHaloIcon.style.visible
            }),
            animation: !0,
            animationEnter: this.getAnimationEnter(this.originalSpec),
            animationExit: this.getAnimationExit(this.originalSpec),
            animationAppear: this.getAnimationAppear(this.originalSpec, "symbol"),
            animationUpdate: this.getAnimationUpdate(this.originalSpec)
        })));
    }
    generateRankingIcon(spec) {
        return {
            type: "symbol",
            dataId: "data",
            visible: !0,
            dataKey: DATA_KEY,
            state: spec.rankingIcon.state,
            style: Object.assign(Object.assign({
                x: datum => "bothEnd" === spec.labelLayout ? -(10 + this.nameLabelTextMeasure.fullMeasure(this.formatDatum(spec.yField, datum)).width + (spec.orderLabel.style.visible ? 5 + this.orderLabelTextMeasure.fullMeasure(this.formatDatum(ORDER_KEY, datum)).width : 0) + 8) : 5,
                y: (datum, ctx) => "bothEnd" === spec.labelLayout ? ctx.valueToY([ datum[spec.yField] ]) + ctx.yBandwidth() / 2 : ctx.valueToY([ datum[spec.yField] ]) + ctx.yBandwidth() / 2 - spec.bar.height / 2 - 5 - Math.max(this.nameLabelTextMeasure.fullMeasure(this.formatDatum(spec.yField, datum)).height, this.orderLabelTextMeasure.fullMeasure(this.formatDatum(ORDER_KEY, datum)).height) / 2
            }, spec.rankingIcon.style), {
                lineWidth: 0,
                stroke: null,
                visible: datum => !datum[SUPPLY_DATA_KEY] && spec.rankingIcon.style.visible
            }),
            animation: !0,
            animationEnter: this.getAnimationEnter(this.originalSpec),
            animationExit: this.getAnimationExit(this.originalSpec),
            animationAppear: this.getAnimationAppear(this.originalSpec, "text"),
            animationUpdate: this.getAnimationUpdate(this.originalSpec)
        };
    }
    generateNameLabel(spec) {
        var _a;
        return {
            type: "text",
            dataId: "data",
            dataKey: DATA_KEY,
            state: null === (_a = spec.nameLabel) || void 0 === _a ? void 0 : _a.state,
            style: Object.assign(Object.assign({
                text: datum => this.formatDatum(spec.yField, datum),
                x: () => {
                    var _a;
                    return "bothEnd" === spec.labelLayout ? -10 : (spec.rankingIcon.style.visible ? 8 + (null !== (_a = spec.rankingIcon.style.size) && void 0 !== _a ? _a : 10) : 0) + (spec.orderLabel.style.visible ? 5 + this.getMaxDataLabelLens(spec, ORDER_KEY, this.orderLabelTextMeasure) : 0);
                },
                y: (datum, ctx) => "bothEnd" === spec.labelLayout ? ctx.valueToY([ datum[spec.yField] ]) + ctx.yBandwidth() / 2 : ctx.valueToY([ datum[spec.yField] ]) + ctx.yBandwidth() / 2 - spec.bar.height / 2 - 5
            }, spec.nameLabel.style), {
                textAlign: "bothEnd" === spec.labelLayout ? "right" : "left",
                textBaseline: "bothEnd" === spec.labelLayout ? "middle" : "bottom",
                visible: datum => !datum[SUPPLY_DATA_KEY] && spec.nameLabel.style.visible
            }),
            animation: !0,
            animationEnter: this.getAnimationEnter(this.originalSpec),
            animationExit: this.getAnimationExit(this.originalSpec),
            animationAppear: this.getAnimationAppear(this.originalSpec, "text"),
            animationUpdate: this.getAnimationUpdate(this.originalSpec)
        };
    }
    generateOrderLabel(spec) {
        var _a;
        return {
            type: "text",
            dataId: "data",
            dataKey: DATA_KEY,
            state: null === (_a = spec.orderLabel) || void 0 === _a ? void 0 : _a.state,
            style: Object.assign(Object.assign({
                text: datum => this.formatDatum(ORDER_KEY, datum),
                x: datum => {
                    var _a;
                    return "bothEnd" === spec.labelLayout ? -(10 + this.nameLabelTextMeasure.fullMeasure(this.formatDatum(spec.yField, datum)).width + 5) : spec.rankingIcon.style.visible ? 8 + (null !== (_a = spec.rankingIcon.style.size) && void 0 !== _a ? _a : 10) : 0;
                },
                y: (datum, ctx) => "bothEnd" === spec.labelLayout ? ctx.valueToY([ datum[spec.yField] ]) + ctx.yBandwidth() / 2 : ctx.valueToY([ datum[spec.yField] ]) + ctx.yBandwidth() / 2 - spec.bar.height / 2 - 5
            }, spec.orderLabel.style), {
                textAlign: "bothEnd" === spec.labelLayout ? "right" : "left",
                textBaseline: "bothEnd" === spec.labelLayout ? "middle" : "bottom",
                visible: datum => !datum[SUPPLY_DATA_KEY] && spec.orderLabel.style.visible
            }),
            animation: !0,
            animationEnter: this.getAnimationEnter(this.originalSpec),
            animationExit: this.getAnimationExit(this.originalSpec),
            animationAppear: this.getAnimationAppear(this.originalSpec, "text"),
            animationUpdate: this.getAnimationUpdate(this.originalSpec)
        };
    }
    generateValueLabel(spec) {
        var _a;
        return {
            type: "text",
            dataId: "data",
            visible: !0,
            dataKey: DATA_KEY,
            state: null === (_a = spec.valueLabel) || void 0 === _a ? void 0 : _a.state,
            style: Object.assign(Object.assign({
                text: datum => this.formatDatum(spec.xField, datum),
                x: (datum, ctx) => "bothEnd" === spec.labelLayout ? ctx.getRegion().getLayoutRect().width + 5 : ctx.getRegion().getLayoutRect().width,
                y: (datum, ctx) => "bothEnd" === spec.labelLayout ? ctx.valueToY([ datum[spec.yField] ]) + ctx.yBandwidth() / 2 : ctx.valueToY([ datum[spec.yField] ]) + ctx.yBandwidth() / 2 - spec.bar.height / 2 - 5
            }, spec.valueLabel.style), {
                textAlign: "bothEnd" === spec.labelLayout ? "left" : "right",
                textBaseline: "bothEnd" === spec.labelLayout ? "middle" : "bottom",
                visible: datum => !datum[SUPPLY_DATA_KEY] && spec.valueLabel.style.visible
            }),
            animation: !0,
            animationEnter: this.getAnimationEnter(this.originalSpec),
            animationExit: this.getAnimationExit(this.originalSpec),
            animationAppear: this.getAnimationAppear(this.originalSpec, "text"),
            animationUpdate: this.getAnimationUpdate(this.originalSpec)
        };
    }
    transformPaddingSpec(spec) {
        var _a;
        const maxHaloIconSize = spec.decorateHaloIcons.length > 0 ? Math.max(...spec.decorateHaloIcons.map((icon => {
            var _a, _b;
            return null !== (_b = null === (_a = icon.style) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 18;
        }))) : 0;
        spec.padding = Object.assign({
            left: "bothEnd" === spec.labelLayout ? 10 + this.getMaxDataLabelLens(spec, spec.yField, this.nameLabelTextMeasure) + (spec.orderLabel.style.visible ? 5 + this.getMaxDataLabelLens(spec, ORDER_KEY, this.orderLabelTextMeasure) : 0) + (spec.rankingIcon.style.visible ? 8 + (null !== (_a = spec.rankingIcon.style.size) && void 0 !== _a ? _a : 10) : 0) + 5 : 5 + maxHaloIconSize / 2,
            right: "bothEnd" === spec.labelLayout ? 5 + this.getMaxDataLabelLens(spec, spec.xField, this.valueLabelTextMeasure) + 5 : 15,
            top: 0,
            bottom: 0
        }, spec.padding);
    }
    getMaxDataLabelLens(spec, field, textMeasure) {
        const textWidths = this.originalData.map((datum => datum[SUPPLY_DATA_KEY] ? 0 : textMeasure.fullMeasure(this.formatDatum(field, datum)).width));
        return Math.max(...textWidths);
    }
    formatDatum(field, datum) {
        var _a;
        return (null === (_a = this.formatMap) || void 0 === _a ? void 0 : _a[field]) ? this.formatMap[field](datum[field], datum) : datum[field];
    }
    getLabelWidth(padding, width) {
        return width + padding;
    }
    getAnimationExit(spec) {
        var _a, _b, _c, _d, _e;
        return !1 !== (null === (_a = spec.animationUpdate) || void 0 === _a ? void 0 : _a.enable) && {
            type: "moveOut",
            options: {
                direction: "y",
                orient: "negative",
                excludeChannels: [ "x" ],
                point: (datum, graphic) => ({
                    y: graphic.getGraphicAttribute("y") - spec.height / (spec.pageSize + 1) * Math.min(spec.scrollSize, spec.pageSize)
                })
            },
            duration: null !== (_c = null === (_b = spec.animationUpdate) || void 0 === _b ? void 0 : _b.duration) && void 0 !== _c ? _c : 1e3,
            easing: null !== (_e = null === (_d = spec.animationUpdate) || void 0 === _d ? void 0 : _d.easing) && void 0 !== _e ? _e : "linear"
        };
    }
    getAnimationEnter(spec) {
        var _a, _b, _c, _d, _e;
        return !1 !== (null === (_a = spec.animationUpdate) || void 0 === _a ? void 0 : _a.enable) && {
            type: "moveIn",
            options: {
                direction: "y",
                orient: "negative",
                excludeChannels: [ "x" ],
                point: (datum, graphic) => ({
                    y: graphic.getGraphicAttribute("y") + spec.height / (spec.pageSize + 1) * Math.min(spec.scrollSize, spec.pageSize)
                })
            },
            duration: null !== (_c = null === (_b = spec.animationUpdate) || void 0 === _b ? void 0 : _b.duration) && void 0 !== _c ? _c : 1e3,
            easing: null !== (_e = null === (_d = spec.animationUpdate) || void 0 === _d ? void 0 : _d.easing) && void 0 !== _e ? _e : "linear"
        };
    }
    getAnimationAppear(spec, markType) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        return !1 !== (null === (_a = spec.animationAppear) || void 0 === _a ? void 0 : _a.enable) && ("rect" === markType ? {
            type: "growWidthIn",
            oneByOne: !1,
            duration: null !== (_c = null === (_b = spec.animationAppear) || void 0 === _b ? void 0 : _b.duration) && void 0 !== _c ? _c : 1e3,
            easing: null !== (_e = null === (_d = spec.animationAppear) || void 0 === _d ? void 0 : _d.easing) && void 0 !== _e ? _e : "linear",
            options: {}
        } : "symbol" === markType ? {
            channel: {
                x: {
                    from: 0,
                    to: (datum, graphic) => graphic.getGraphicAttribute("x")
                }
            },
            duration: null !== (_g = null === (_f = spec.animationAppear) || void 0 === _f ? void 0 : _f.duration) && void 0 !== _g ? _g : 1e3,
            easing: null !== (_j = null === (_h = spec.animationAppear) || void 0 === _h ? void 0 : _h.easing) && void 0 !== _j ? _j : "linear"
        } : {
            channel: {
                opacity: {
                    from: 0,
                    to: 1
                }
            },
            duration: null !== (_l = null === (_k = spec.animationAppear) || void 0 === _k ? void 0 : _k.duration) && void 0 !== _l ? _l : 1e3,
            easing: null !== (_o = null === (_m = spec.animationAppear) || void 0 === _m ? void 0 : _m.easing) && void 0 !== _o ? _o : "linear"
        });
    }
    getAnimationUpdate(spec) {
        var _a, _b, _c, _d;
        return !1 !== spec.animationUpdate.enable && {
            duration: null !== (_b = null === (_a = spec.animationUpdate) || void 0 === _a ? void 0 : _a.duration) && void 0 !== _b ? _b : 1e3,
            easing: null !== (_d = null === (_c = spec.animationUpdate) || void 0 === _c ? void 0 : _c.easing) && void 0 !== _d ? _d : "linear"
        };
    }
}
//# sourceMappingURL=ranking-list-transformer.js.map
