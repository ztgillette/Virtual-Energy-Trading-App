import { isArray } from "@visactor/vutils";

export const applyVisible = (spec, keyList) => {
    keyList.forEach((key => {
        var _a, _b, _c, _d, _e, _f, _g;
        isArray(spec[key]) ? null === (_a = spec[key]) || void 0 === _a || _a.forEach(((s, i) => {
            var _a, _b, _c;
            spec[key][i] = Object.assign(Object.assign({}, s), {
                style: Object.assign(Object.assign({}, null == s ? void 0 : s.style), {
                    visible: null === (_c = null !== (_b = null === (_a = null == s ? void 0 : s.style) || void 0 === _a ? void 0 : _a.visible) && void 0 !== _b ? _b : null == s ? void 0 : s.visible) || void 0 === _c || _c
                })
            });
        })) : spec[key] = Object.assign(Object.assign({}, spec[key]), {
            style: Object.assign(Object.assign({}, null === (_b = spec[key]) || void 0 === _b ? void 0 : _b.style), {
                visible: null === (_g = null !== (_e = null === (_d = null === (_c = spec[key]) || void 0 === _c ? void 0 : _c.style) || void 0 === _d ? void 0 : _d.visible) && void 0 !== _e ? _e : null === (_f = spec[key]) || void 0 === _f ? void 0 : _f.visible) || void 0 === _g || _g
            })
        });
    }));
};

export const mergeObjects = (objA, objB) => function recursiveMerge(target, source) {
    for (const key in source) "__proto__" !== key && "constructor" !== key && "prototype" !== key && "object" == typeof source[key] && null !== source[key] ? (target.hasOwnProperty(key) || (target[key] = Array.isArray(source[key]) ? [] : {}), 
    recursiveMerge(target[key], source[key])) : target.hasOwnProperty(key) || "object" != typeof target || (target[key] = source[key]);
    return target;
}(objA, objB);

export const computeDataRange = (data, field) => {
    let dataMin, dataMax;
    const datumX = data.map((d => d[field])).filter((d => null != d));
    if (0 === datumX.length) dataMin = 0, dataMax = 1; else {
        dataMin = Math.min(...datumX) - (Math.max(...datumX) - Math.min(...datumX)) / 3, 
        dataMax = (Math.max(...datumX) - dataMin) / .8 + dataMin;
        const delta_value = 10, data = dataMin;
        dataMin === dataMax && (dataMin = data - delta_value, dataMax = (4 * data + delta_value) / 4);
    }
    return {
        min: dataMin,
        max: dataMax
    };
};
//# sourceMappingURL=utils.js.map
