{"version":3,"sources":["../src/charts/ranking-list/utils.ts"],"names":[],"mappings":"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","file":"utils.js","sourcesContent":["import type { Datum } from '@visactor/vchart/src/typings';\nimport { isArray } from '@visactor/vutils';\n\nexport const applyVisible = (spec: any, keyList: string[]) => {\n  keyList.forEach(key => {\n    if (isArray(spec[key])) {\n      spec[key]?.forEach((s: any, i: number) => {\n        spec[key][i] = {\n          ...s,\n          style: {\n            ...s?.style,\n            visible: s?.style?.visible ?? s?.visible ?? true\n          }\n        };\n      });\n    } else {\n      spec[key] = {\n        ...spec[key],\n        style: {\n          ...spec[key]?.style,\n          visible: spec[key]?.style?.visible ?? spec[key]?.visible ?? true\n        }\n      };\n    }\n  });\n};\n\nexport const mergeObjects = (objA: any, objB: any) => {\n  function recursiveMerge(target: any, source: any) {\n    for (const key in source) {\n      if (\n        key !== '__proto__' &&\n        key !== 'constructor' &&\n        key !== 'prototype' &&\n        typeof source[key] === 'object' &&\n        source[key] !== null\n      ) {\n        if (!target.hasOwnProperty(key)) {\n          target[key] = Array.isArray(source[key]) ? [] : {};\n        }\n        recursiveMerge(target[key], source[key]);\n      } else if (!target.hasOwnProperty(key) && typeof target === 'object') {\n        target[key] = source[key];\n      }\n    }\n    return target;\n  }\n  return recursiveMerge(objA, objB);\n};\n\nexport const computeDataRange = (data: Datum[], field: string) => {\n  let dataMin: number;\n  let dataMax: number;\n  const datumX = data.map(d => d[field]).filter(d => typeof d !== 'undefined' && d !== null);\n\n  // 避免数据都为null, 即xField都为null, 导致scale异常, 图表为空\n  // 这里只要设置dataMin和dataMax为任意数字并保证其不想等, 即可达到只显示yField而不显示xField的效果\n  if (datumX.length === 0) {\n    dataMin = 0;\n    dataMax = 1;\n  } else {\n    dataMin = Math.min(...datumX) - (Math.max(...datumX) - Math.min(...datumX)) / 3;\n    dataMax = (Math.max(...datumX) - dataMin) / 0.8 + dataMin;\n    const delta_value = 10; // 可以是任意值, 只要大于0就行, 目的是为了让最小值和最大值不一样, 便于scale做插值计算\n    const data = dataMin;\n    if (dataMin === dataMax) {\n      // 避免domain[0] = domain[1], 导致scale映射有问题\n      // 数学计算:\n      // 1.保证 (dataMax - data) / (data - dataMin) = 4\n      // 2. dataMax > data & dataMin < data => delta_value > 0\n      dataMin = data - delta_value;\n      dataMax = (4 * data + delta_value) / 4;\n    }\n  }\n  return { min: dataMin, max: dataMax };\n};\n"]}