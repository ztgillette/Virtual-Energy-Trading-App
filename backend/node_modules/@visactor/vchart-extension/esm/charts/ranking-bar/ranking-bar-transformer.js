import { BaseChartSpecTransformer } from "@visactor/vchart";

import { isValid } from "@visactor/vutils";

export class RankingBarChartSpecTransformer extends BaseChartSpecTransformer {
    transformSpec(spec) {
        const {timeData: timeData, timeNodes: timeNodes} = processData(spec), {interval: userInterval, xField: xField, yField: yField, color: color, icon: icon, iconPosition: iconPosition, iconShape: iconShape, timeLabel: timeLabel, label: label, nameLabel: nameLabel, xAxis: xAxis, yAxis: yAxis} = spec, interval = userInterval || 1e3, exchangeDuration = Math.min(interval, 500);
        if (spec.type = "common", spec.data = [ {
            id: "timeData",
            values: timeData.get(timeNodes[0])
        }, {
            id: "time",
            values: [ {
                time: timeNodes[0]
            } ]
        } ], spec.color = {
            specified: Object.assign({}, color)
        }, spec.region = [ {
            clip: !0
        } ], spec.series = [ {
            type: "bar",
            id: "ranking-bar",
            dataId: "timeData",
            direction: "horizontal",
            yField: yField,
            xField: xField,
            seriesField: yField,
            extensionMark: [],
            label: labelSpec(label, Object.assign(Object.assign({}, nameLabel), {
                yField: yField
            }))
        } ], spec.axes = axisSpec(xAxis, yAxis), spec.player = {
            type: "continuous",
            auto: !0,
            loop: !1,
            interval: interval,
            specs: timeNodes.map((time => ({
                data: [ {
                    id: "timeData",
                    values: timeData.get(time)
                }, {
                    id: "time",
                    values: [ {
                        time: time
                    } ]
                } ]
            })))
        }, spec.tooltip = {
            visible: !1
        }, spec.customMark = [], transformAnimationSpec(spec, {
            interval: interval,
            exchangeDuration: exchangeDuration
        }), timeLabel && !1 === timeLabel.visible || spec.customMark.push(timeLabelSpec(timeLabel.style)), 
        icon) {
            const icon = iconSpec(iconPosition, iconShape, {
                interval: interval,
                exchangeDuration: exchangeDuration
            });
            spec.series[0].extensionMark.push(icon);
        }
        super.transformSpec(spec);
    }
}

export function processData(spec) {
    const {xField: xField, yField: yField, timeField: timeField, data: data, topN: topN = 10, icon: icon} = spec, timeNodes = new Set, timeData = new Map;
    return data.sort(((d1, d2) => Number(d2[xField]) - Number(d1[xField]))), data.forEach((d => {
        const time = d[timeField];
        isValid(time) && timeNodes.add(time), timeData.has(time) || timeData.set(time, []);
        const currentData = timeData.get(time);
        if (currentData.length < topN) {
            const _d = Object.assign({}, d);
            icon && icon[_d[yField]] && (_d.icon = icon[_d[yField]]), currentData.push(_d);
        }
    })), {
        timeData: timeData,
        timeNodes: Array.from(timeNodes).sort()
    };
}

function transformAnimationSpec(spec, {interval: interval, exchangeDuration: exchangeDuration}) {
    spec.animationAppear = !1, spec.animationUpdate = {
        bar: [ {
            type: "update",
            options: {
                excludeChannels: [ "y" ]
            },
            easing: "linear",
            duration: interval
        }, {
            channel: [ "y" ],
            easing: "circInOut",
            duration: exchangeDuration
        } ],
        axis: {
            duration: interval,
            easing: "linear"
        }
    }, spec.animationEnter = {
        bar: [ {
            type: "moveIn",
            duration: exchangeDuration,
            easing: "cubicInOut",
            options: {
                direction: "y",
                orient: "negative",
                point: (datum, element, param) => ({
                    y: param.groupHeight + element.getBounds().height()
                })
            }
        } ]
    }, spec.animationExit = {
        bar: [ {
            type: "moveOut",
            duration: exchangeDuration,
            easing: "cubicInOut",
            options: {
                direction: "y",
                orient: "negative"
            }
        } ]
    };
}

function labelSpec(label = {}, nameLabel) {
    var _a, _b, _c, _e;
    const spec = [];
    return !1 !== label.visible && spec.push({
        visible: !0,
        overlap: !1,
        style: Object.assign({
            fill: "rgb(64, 64, 64)"
        }, label.style),
        smartInvert: {
            fillStrategy: (null === (_a = label.style) || void 0 === _a ? void 0 : _a.fill) ? "null" : void 0,
            strokeStrategy: (null === (_b = label.style) || void 0 === _b ? void 0 : _b.stroke) ? "null" : void 0
        }
    }), nameLabel.visible && spec.push({
        visible: !0,
        overlap: !1,
        style: Object.assign({}, nameLabel.style),
        smartInvert: {
            fillStrategy: (null === (_c = nameLabel.style) || void 0 === _c ? void 0 : _c.fill) ? "null" : void 0,
            strokeStrategy: (null === (_e = nameLabel.style) || void 0 === _e ? void 0 : _e.stroke) ? "null" : void 0
        },
        position: "bar-end" === nameLabel.position ? "inside-right" : "inside-left",
        formatter: `{${nameLabel.yField}}`
    }), spec;
}

function axisSpec(xAxis = {}, yAxis = {}) {
    const leftAxis = {
        orient: "left",
        type: "band",
        inverse: !0,
        label: {
            style: yAxis.label
        },
        domainLine: {
            style: yAxis.domainLine
        },
        grid: {
            style: yAxis.grid
        }
    }, bottomAxis = {
        orient: "bottom",
        type: "linear",
        nice: !1,
        animation: !0,
        label: {
            style: xAxis.label
        },
        domainLine: {
            style: xAxis.domainLine
        },
        grid: {
            style: xAxis.grid
        },
        innerOffset: {
            right: "10%"
        }
    };
    return xAxis.label && (bottomAxis.label = xAxis.label), [ leftAxis, bottomAxis ];
}

function timeLabelSpec(textStyle = {}) {
    return {
        type: "text",
        dataId: "time",
        style: Object.assign({
            textBaseline: "bottom",
            fontSize: 200,
            textAlign: "end",
            fontWeight: 600,
            text: datum => datum.time,
            x: (datum, ctx) => {
                var _a;
                return (null === (_a = ctx.vchart.getChart().getCanvasRect()) || void 0 === _a ? void 0 : _a.width) - 50;
            },
            y: (datum, ctx) => {
                var _a;
                return (null === (_a = ctx.vchart.getChart().getCanvasRect()) || void 0 === _a ? void 0 : _a.height) - 80;
            },
            fill: "grey",
            fillOpacity: .5
        }, textStyle)
    };
}

function iconSpec(iconPosition = "bar-end", iconShape = "circle", {interval: interval, exchangeDuration: exchangeDuration}) {
    return {
        type: "symbol",
        dataId: "timeData",
        style: {
            symbolType: iconShape,
            stroke: "white",
            lineWidth: 1,
            size: (data, ctx) => {
                var _a, _b;
                const vchart = ctx.vchart, series = null === (_a = vchart.getChart()) || void 0 === _a ? void 0 : _a.getSeriesInIndex(0)[0];
                if (vchart && series) {
                    const bandwidth = null !== (_b = series.getYAxisHelper().getBandwidth(0)) && void 0 !== _b ? _b : 0;
                    return Math.max(bandwidth - 4, 0);
                }
                return 10;
            },
            background: data => data.icon,
            x: (data, ctx) => {
                var _a, _b;
                const vchart = ctx.vchart, series = null === (_a = vchart.getChart()) || void 0 === _a ? void 0 : _a.getSeriesInIndex(0)[0];
                if (vchart && series) {
                    const bandwidth = null !== (_b = series.getYAxisHelper().getBandwidth(0)) && void 0 !== _b ? _b : 0;
                    return "bar-start" === iconPosition ? bandwidth / 2 : "axis" === iconPosition ? -bandwidth / 2 : series.dataToPositionX(data) - bandwidth / 2;
                }
            },
            y: (data, ctx) => {
                var _a, _b;
                const vchart = ctx.vchart, series = null === (_a = vchart.getChart()) || void 0 === _a ? void 0 : _a.getSeriesInIndex(0)[0];
                if (vchart && series) {
                    const bandwidth = null !== (_b = series.getYAxisHelper().getBandwidth(0)) && void 0 !== _b ? _b : 0;
                    return series.dataToPositionY(data) + bandwidth / 2;
                }
            },
            scaleY: "rect" === iconShape ? 1.2 : 1
        },
        animationUpdate: customMarkUpdateAnimation(interval, exchangeDuration),
        animationEnter: [ {
            type: "moveIn",
            duration: exchangeDuration,
            easing: "cubicInOut",
            options: {
                direction: "y",
                orient: "negative",
                point: (datum, element, param) => ({
                    y: param.groupHeight + element.getBounds().height()
                })
            }
        } ],
        animationExit: [ {
            type: "moveOut",
            duration: exchangeDuration,
            easing: "cubicInOut",
            options: {
                direction: "y",
                orient: "negative"
            }
        } ]
    };
}

function customMarkUpdateAnimation(duration, exchangeDuration) {
    return [ {
        duration: exchangeDuration,
        easing: "cubicInOut",
        channel: [ "y" ]
    }, {
        options: {
            excludeChannels: [ "y" ]
        },
        channel: [ "x", "x2", "x1" ],
        easing: "linear",
        duration: duration
    } ];
}
//# sourceMappingURL=ranking-bar-transformer.js.map
