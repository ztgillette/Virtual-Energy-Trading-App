var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import { LayoutZIndex, FunnelChartSpecTransformer } from "@visactor/vchart";

import { isFunction } from "@visactor/vutils";

import { DEFAULT_ARROW_MARK_STYLE, DEFAULT_ARROW_SYMBOL_MARK_STYLE, DEFAULT_ARROW_TEXT_MARK_STYLE, DEFAULT_FUNNEL_BACKGROUND_MARK_STYLE } from "./constants";

export class ConversionFunnelChartSpecTransformer extends FunnelChartSpecTransformer {
    transformSpec(spec) {
        const {conversionArrow: conversionArrow, extensionMark: extensionMark = [], funnelBackground: funnelBackground} = spec;
        if (conversionArrow && conversionArrow.arrows && conversionArrow.arrows.length) {
            const marks = addArrowMark(conversionArrow);
            marks && marks.length && extensionMark.push(...marks);
        }
        if (funnelBackground && funnelBackground.visible) {
            const mark = addFunnelBackgroundMark(funnelBackground);
            mark && extensionMark.push(mark);
        }
        spec.extensionMark = extensionMark, super.transformSpec(spec);
    }
    _getDefaultSeriesSpec(spec) {
        const seriesSpec = super._getDefaultSeriesSpec(spec);
        return seriesSpec.conversionArrow = spec.conversionArrow, seriesSpec.funnelBackground = spec.funnelBackground, 
        seriesSpec;
    }
}

function addArrowMark(arrowSpec) {
    const {arrows: arrows} = arrowSpec, style = __rest(arrowSpec, [ "arrows" ]), leftArrows = arrows.filter((arrow => "left" === arrow.position)), rightGroup = computeArrows(arrows.filter((arrow => "right" === arrow.position)), style), leftGroup = computeArrows(leftArrows, style), result = [];
    return rightGroup && (rightGroup.name = "arrowRight", result.push(rightGroup)), 
    leftGroup && (leftGroup.name = "arrowLeft", result.push(leftGroup)), result;
}

function computeArrows(arrows, style) {
    if (0 === (null == arrows ? void 0 : arrows.length)) return null;
    const {line: line, symbol: symbol, text: text, margin: margin} = style, result = [], rootGroup = {
        type: "group",
        zIndex: LayoutZIndex.Mark + 1,
        children: []
    }, lineMark = generateArrowLineSpec(line, margin);
    lineMark && result.push(lineMark);
    const arrowMark = generateArrowSymbolSpec(symbol, margin);
    arrowMark && result.push(arrowMark);
    const textMark = generateArrowTextSpec(text, margin);
    return textMark && result.push(textMark), rootGroup.children = result, rootGroup;
}

function generateArrowLineSpec(line = {}, margin) {
    const {style: style = {}} = line, rest = __rest(line, [ "style" ]), renderable = (arrow, ctx) => {
        var _a, _b;
        const {from: from, to: to} = arrow, {vchart: vchart} = ctx, data = null === (_b = null === (_a = null == vchart ? void 0 : vchart.getChart()) || void 0 === _a ? void 0 : _a.getSeriesData()) || void 0 === _b ? void 0 : _b.latestData;
        return !(to > data.length - 1 || from > data.length - 1);
    };
    return Object.assign(Object.assign({
        type: "polygon",
        interactive: !1
    }, rest), {
        dataKey: arrow => `${arrow.id}`,
        style: Object.assign(Object.assign(Object.assign({}, DEFAULT_ARROW_MARK_STYLE), style), {
            renderable: renderable,
            points: (arrow, ctx) => {
                if (!renderable(arrow, ctx)) return [];
                let points = arrow.layout.points;
                return points = prepareArrowPoints(arrow, ctx, margin), points;
            }
        })
    });
}

function generateArrowSymbolSpec(symbol = {}, margin) {
    const {style: style = {}} = symbol, rest = __rest(symbol, [ "style" ]);
    return Object.assign(Object.assign({
        type: "symbol",
        interactive: !1,
        dataKey: arrow => `${arrow.id}`
    }, rest), {
        style: Object.assign(Object.assign(Object.assign({}, DEFAULT_ARROW_SYMBOL_MARK_STYLE), style), {
            x: (arrow, ctx) => {
                var _a, _b;
                let points = arrow.layout.points;
                return points = prepareArrowPoints(arrow, ctx, margin), null !== (_b = null === (_a = points[(null == points ? void 0 : points.length) - 1]) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : NaN;
            },
            y: (arrow, ctx) => {
                var _a, _b;
                let points = arrow.layout.points;
                return points = prepareArrowPoints(arrow, ctx, margin), null !== (_b = null === (_a = points[(null == points ? void 0 : points.length) - 1]) || void 0 === _a ? void 0 : _a.y) && void 0 !== _b ? _b : NaN;
            },
            angle: arrow => "left" === arrow.position ? 90 : -90
        })
    });
}

function generateArrowTextSpec(text = {}, margin) {
    const {style: style = {}, formatMethod: formatMethod, textMargin: textMargin = 4} = text, rest = __rest(text, [ "style", "formatMethod", "textMargin" ]);
    return Object.assign(Object.assign({
        type: "text",
        dataKey: arrow => `${arrow.id}`,
        interactive: !1,
        animation: !1
    }, rest), {
        style: Object.assign(Object.assign(Object.assign({}, DEFAULT_ARROW_TEXT_MARK_STYLE), {
            text: (arrow, ctx) => {
                var _a, _b, _c, _d, _e, _f, _g;
                const {text: textContent} = arrow;
                let displayTextContent = textContent;
                if (isFunction(formatMethod)) {
                    const {vchart: vchart} = ctx, {from: from, to: to} = arrow, {field: field} = arrow.context, rawData = null !== (_c = null === (_b = null === (_a = null == vchart ? void 0 : vchart.getChart()) || void 0 === _a ? void 0 : _a.getSeriesData()) || void 0 === _b ? void 0 : _b.latestData) && void 0 !== _c ? _c : [], viewData = null !== (_g = null === (_f = null === (_e = null === (_d = null == vchart ? void 0 : vchart.getChart()) || void 0 === _d ? void 0 : _d.getAllSeries()[0]) || void 0 === _e ? void 0 : _e.getViewData()) || void 0 === _f ? void 0 : _f.latestData) && void 0 !== _g ? _g : [], fromData = viewData.find((datum => datum[field] === rawData[from][field])), toData = viewData.find((datum => datum[field] === rawData[to][field]));
                    displayTextContent = formatMethod(textContent, {
                        arrow: arrow,
                        from: fromData,
                        to: toData
                    });
                }
                return displayTextContent;
            },
            x: (arrow, ctx) => {
                var _a, _b;
                let points = arrow.layout.points;
                return points = prepareArrowPoints(arrow, ctx, margin), null !== (_b = (null === (_a = points[1]) || void 0 === _a ? void 0 : _a.x) + ("left" === arrow.position ? -textMargin : textMargin)) && void 0 !== _b ? _b : NaN;
            },
            y: (arrow, ctx) => {
                var _a, _b, _c;
                let points = arrow.layout.points;
                return points = prepareArrowPoints(arrow, ctx, margin), null !== (_c = ((null === (_a = points[1]) || void 0 === _a ? void 0 : _a.y) + (null === (_b = points[2]) || void 0 === _b ? void 0 : _b.y)) / 2) && void 0 !== _c ? _c : NaN;
            },
            textAlign: arrow => "left" === arrow.position ? "right" : "left",
            textBaseline: "middle"
        }), style)
    });
}

function prepareArrowPoints(arrow, ctx, margin) {
    var _a, _b, _c, _d, _e;
    const {vchart: vchart} = ctx, {from: from, to: to} = arrow, {field: field} = arrow.context, rawData = null === (_b = null === (_a = null == vchart ? void 0 : vchart.getChart()) || void 0 === _a ? void 0 : _a.getSeriesData()) || void 0 === _b ? void 0 : _b.latestData, viewData = null === (_e = null === (_d = null === (_c = null == vchart ? void 0 : vchart.getChart()) || void 0 === _c ? void 0 : _c.getAllSeries()[0]) || void 0 === _d ? void 0 : _d.getViewData()) || void 0 === _e ? void 0 : _e.latestData;
    let points = [];
    if (rawData && rawData.length) {
        const fromDatum = viewData.find((datum => datum[field] === rawData[from][field])), toDatum = viewData.find((datum => datum[field] === rawData[to][field])), firstDatum = viewData[0];
        if (fromDatum && toDatum && firstDatum) {
            points = computeArrowPoints(arrow, ctx.getPoints(fromDatum), ctx.getPoints(toDatum), ctx.getPoints(firstDatum), margin), 
            arrow.layout.points = points;
        }
    }
    return points;
}

function computeArrowPoints(arrow, fromPoints, toPoints, firstPoints, margin = 12) {
    const {layout: layout, distance: distance, position: position} = arrow, {level: level, fromIndex: fromIndex, toIndex: toIndex, fromTotal: fromTotal, toTotal: toTotal} = layout, isRight = "right" === position, fromTop = isRight ? fromPoints[1] : fromPoints[0], fromBottom = isRight ? fromPoints[2] : fromPoints[3], fromHeight = Math.abs(fromTop.y - fromBottom.y), toTop = isRight ? toPoints[1] : toPoints[0], toBottom = isRight ? toPoints[2] : toPoints[3], toHeight = Math.abs(toTop.y - toBottom.y), firstTop = isRight ? firstPoints[1] : firstPoints[0], fromOffset = fromHeight / (fromTotal + 1), toOffset = toHeight / (toTotal + 1), fromY = fromTop.y + fromOffset * (fromIndex + 1), toY = toTop.y + toOffset * (toIndex + 1), sign = isRight ? -1 : 1;
    return [ {
        x: fromTop.x - margin * sign,
        y: fromY
    }, {
        x: firstTop.x - (margin + (level + 1) * distance) * sign,
        y: fromY
    }, {
        x: firstTop.x - (margin + (level + 1) * distance) * sign,
        y: toY
    }, {
        x: toTop.x - margin * sign,
        y: toY
    } ];
}

function addFunnelBackgroundMark(funnelBackground) {
    const {style: style = {}} = funnelBackground, rest = __rest(funnelBackground, [ "style" ]);
    return Object.assign(Object.assign({
        type: "rect"
    }, rest), {
        dataIndex: 0,
        zIndex: 0,
        style: Object.assign(Object.assign(Object.assign({}, DEFAULT_FUNNEL_BACKGROUND_MARK_STYLE), style), {
            x: 0,
            y: (datum, ctx) => ctx.getPoints(datum)[0].y,
            width: (datum, ctx) => {
                const region = ctx.getRegion(), {width: width} = region.getLayoutRect();
                return width;
            },
            height: (datum, ctx) => {
                const points = ctx.getPoints(datum), tl = points[0];
                return points[3].y - tl.y;
            }
        })
    });
}
//# sourceMappingURL=conversion-funnel-transformer.js.map