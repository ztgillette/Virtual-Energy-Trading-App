{"version":3,"sources":["../src/charts/conversion-funnel/arrow-data-transform.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,OAAO,EAAE,aAAa,EAAE,UAAU,EAAE,MAAM,kBAAkB,CAAC;AACtE,OAAO,EAAE,YAAY,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAuBnD,MAAM,CAAC,MAAM,wBAAwB,GAAG,CACtC,SAAmD,EACnD,OAEC,EACD,EAAE;;IACF,IAAI,CAAC,SAAS,IAAI,CAAC,CAAA,MAAA,SAAS,CAAC,MAAM,0CAAE,MAAM,CAAA,EAAE;QAC3C,OAAO,EAAE,CAAC;KACX;IACD,MAAM,EAAE,MAAM,EAAE,GAAG,SAAS,CAAC;IAE7B,MAAM,YAAY,GAAG,UAAU,CAAC,MAAM,EAAE,OAAO,CAAC,aAAa,CAAC,CAAC;IAC/D,MAAM,UAAU,GAAG,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,QAAQ,KAAK,MAAM,CAAC,CAAC;IAC3E,MAAM,WAAW,GAAG,YAAY,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,QAAQ,KAAK,OAAO,CAAC,CAAC;IAE7E,MAAM,IAAI,GAAG,MAAA,aAAa,CAAC,UAAU,CAAC,mCAAI,EAAE,CAAC;IAC7C,MAAM,KAAK,GAAG,MAAA,aAAa,CAAC,WAAW,CAAC,mCAAI,EAAE,CAAC;IAC/C,OAAO,CAAC,GAAG,IAAI,EAAE,GAAG,KAAK,CAAC,CAAC;AAC7B,CAAC,CAAC;AAEF,SAAS,UAAU,CAAC,MAAe,EAAE,aAAqB;IACxD,OAAO,MAAM;SACV,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC,EAAE,CAAC,CAAC;SACrD,GAAG,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE;QACpB,MAAM,EAAE,IAAI,EAAE,EAAE,EAAE,QAAQ,GAAG,OAAO,EAAE,GAAG,KAAK,CAAC;QAC/C,OAAO,gCACF,KAAK,KACR,QAAQ,EACR,QAAQ,EAAE,KAAK,CAAC,QAAQ,IAAI,EAAE,EAC9B,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC,EACxB,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC,EACtB,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,EAAE,CAAC,EACzB,QAAQ,EAAE,KAAK,EACf,OAAO,EAAE;gBACP,KAAK,EAAE,aAAa;aACrB,EACD,MAAM,EAAE;gBACN,KAAK,EAAE,CAAC;aACT,EACD,EAAE,EAAE,GAAG,IAAI,IAAI,EAAE,IAAI,QAAQ,IAAI,KAAK,EAAE,GACf,CAAC;IAC9B,CAAC,CAAC,CAAC;AACP,CAAC;AAED,SAAS,aAAa,CAAC,MAAqB;IAC1C,IAAI,CAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,MAAM,MAAK,CAAC,EAAE;QACxB,OAAO,IAAI,CAAC;KACb;IAED,MAAM,aAAa,GAAG,IAAI,GAAG,EAQ1B,CAAC;IAEJ,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QACrB,MAAM,cAAc,GAAG,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACrD,IAAI,OAAO,CAAC,cAAc,CAAC,EAAE;YAC3B,MAAM,wBAAwB,GAAG,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;YAClG,IAAI,CAAC,wBAAwB,EAAE;gBAC7B,cAAc,CAAC,MAAM,IAAI,CAAC,CAAC;aAC5B;iBAAM;gBACL,KAAK,CAAC,MAAM,CAAC,aAAa,GAAG,wBAAwB,CAAC;aACvD;YACD,cAAc,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACvC;aAAM;YACL,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE;gBAC5B,UAAU,EAAE,CAAC,KAAK,CAAC;gBACnB,QAAQ,EAAE,EAAE;gBACZ,WAAW,EAAE,EAAE;gBACf,MAAM,EAAE,CAAC;aACV,CAAC,CAAC;SACJ;QAED,MAAM,YAAY,GAAG,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QACjD,IAAI,OAAO,CAAC,YAAY,CAAC,EAAE;YACzB,MAAM,wBAAwB,GAAG,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,WAAW,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;YAC9F,IAAI,CAAC,wBAAwB,EAAE;gBAC7B,YAAY,CAAC,MAAM,IAAI,CAAC,CAAC;aAC1B;iBAAM;gBACL,KAAK,CAAC,MAAM,CAAC,aAAa,GAAG,wBAAwB,CAAC;aACvD;YACD,YAAY,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACnC;aAAM;YACL,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,EAAE;gBAC1B,QAAQ,EAAE,CAAC,KAAK,CAAC;gBACjB,UAAU,EAAE,EAAE;gBACd,WAAW,EAAE,EAAE;gBACf,MAAM,EAAE,CAAC;aACV,CAAC,CAAC;SACJ;IACH,CAAC,CAAC,CAAC;IACH,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QAE3B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;QAEhD,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;QAE9C,IAAI,CAAC,WAAW,GAAG,CAAC,GAAG,IAAI,CAAC,QAAQ,EAAE,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC;IAC5D,CAAC,CAAC,CAAC;IAEH,MAAM;SACH,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC;SAC/B,OAAO,CAAC,KAAK,CAAC,EAAE;;QACf,MAAM,cAAc,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAErE,MAAM,aAAa,GAAG,UAAU,CAAC,cAAc,EAAE,CAAC,GAAG,EAAE,MAAM,EAAE,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAE1G,IAAI,KAAK,GAAG,MAAA,aAAa,aAAb,aAAa,uBAAb,aAAa,CAAE,MAAM,CAAC,KAAK,mCAAI,CAAC,CAAC;QAC7C,OAAO,KAAK,IAAI,CAAC,EAAE;YACjB,IAAI,cAAc,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,KAAK,KAAK,IAAI,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,EAAE;gBACtF,KAAK,IAAI,CAAC,CAAC;gBACX,MAAM;aACP;YACD,EAAE,KAAK,CAAC;SACT;QACD,KAAK,CAAC,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;QAExC,KAAK,CAAC,MAAM,CAAC,SAAS,GAAG,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC;QAC9D,KAAK,CAAC,MAAM,CAAC,OAAO,GAAG,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,MAAM,CAAC;QAE1D,MAAM,aAAa,GAAG,KAAK,CAAC,MAAM,CAAC,aAAa,CAAC;QACjD,IAAI,aAAa,EAAE;YACjB,KAAK,CAAC,MAAM,CAAC,SAAS,GAAG,aAAa,CAAC,MAAM,CAAC,SAAS,CAAC;YACxD,KAAK,CAAC,MAAM,CAAC,OAAO,GAAG,aAAa,CAAC,MAAM,CAAC,OAAO,CAAC;SACrD;aAAM;YACL,KAAK,CAAC,MAAM,CAAC,SAAS,GAAG,YAAY,CAAC,KAAK,EAAE,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,WAAW,CAAC,CAAC;YACxF,KAAK,CAAC,MAAM,CAAC,OAAO,GAAG,YAAY,CAAC,KAAK,EAAE,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC;SACrF;QACD,KAAK,CAAC,MAAM,CAAC,QAAQ,GAAG,IAAI,CAAC;IAC/B,CAAC,CAAC,CAAC;IAEL,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,SAAS,YAAY,CAAC,KAAkB,EAAE,WAA0B;IAClE,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,IAAI,cAAc,GAAG,CAAC,CAAC;IACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAC3C,MAAM,QAAQ,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;QAChC,IAAI,QAAQ,KAAK,KAAK,EAAE;YACtB,KAAK,GAAG,CAAC,GAAG,cAAc,CAAC;YAC3B,MAAM;SACP;QACD,IAAI,QAAQ,CAAC,MAAM,CAAC,aAAa,EAAE;YACjC,cAAc,EAAE,CAAC;SAClB;KACF;IACD,OAAO,KAAK,CAAC;AACf,CAAC","file":"arrow-data-transform.js","sourcesContent":["import type { IPointLike } from '@visactor/vutils';\nimport type { IConversionFunnelSpec, Arrow } from './interface';\nimport { isValid, isValidNumber, maxInArray } from '@visactor/vutils';\nimport { isArrowCross, isSameArrow } from './util';\n\nexport interface ParsedArrow extends Arrow {\n  position: 'left' | 'right';\n  distance: number;\n  /** 层级跨度 */\n  span: number;\n  layout: {\n    isLayout: boolean;\n    duplicateNode: ParsedArrow | null;\n    fromIndex: number;\n    toIndex: number;\n    fromTotal: number;\n    toTotal: number;\n    level: number;\n    points: IPointLike[];\n  };\n  context: {\n    field: string;\n  };\n  id: string;\n}\n\nexport const conversionArrowTransform = (\n  arrowSpec: IConversionFunnelSpec['conversionArrow'],\n  options: {\n    categoryField: string;\n  }\n) => {\n  if (!arrowSpec || !arrowSpec.arrows?.length) {\n    return [];\n  }\n  const { arrows } = arrowSpec;\n\n  const parsedArrows = parseArrow(arrows, options.categoryField);\n  const leftArrows = parsedArrows.filter(arrow => arrow.position === 'left');\n  const rightArrows = parsedArrows.filter(arrow => arrow.position === 'right');\n\n  const left = computeArrows(leftArrows) ?? [];\n  const right = computeArrows(rightArrows) ?? [];\n  return [...left, ...right];\n};\n\nfunction parseArrow(arrows: Arrow[], categoryField: string): ParsedArrow[] {\n  return arrows\n    .filter(arrow => isValidNumber(arrow.from * arrow.to))\n    .map((arrow, index) => {\n      const { from, to, position = 'right' } = arrow;\n      return {\n        ...arrow,\n        position,\n        distance: arrow.distance || 40,\n        from: Math.min(from, to),\n        to: Math.max(from, to),\n        span: Math.abs(from - to),\n        isLayout: false,\n        context: {\n          field: categoryField\n        },\n        layout: {\n          level: 0\n        },\n        id: `${from}-${to}-${position}-${index}`\n      } as unknown as ParsedArrow;\n    });\n}\n\nfunction computeArrows(arrows: ParsedArrow[]) {\n  if (arrows?.length === 0) {\n    return null;\n  }\n\n  const nodeDegreeMap = new Map<\n    number,\n    {\n      fromArrows: ParsedArrow[];\n      toArrows: ParsedArrow[];\n      totalArrows: ParsedArrow[];\n      degree: number;\n    }\n  >();\n\n  arrows.forEach(arrow => {\n    const fromNodeDegree = nodeDegreeMap.get(arrow.from);\n    if (isValid(fromNodeDegree)) {\n      const firstNodeWidthSameFromTo = fromNodeDegree.fromArrows.find(node => isSameArrow(node, arrow));\n      if (!firstNodeWidthSameFromTo) {\n        fromNodeDegree.degree += 1;\n      } else {\n        arrow.layout.duplicateNode = firstNodeWidthSameFromTo;\n      }\n      fromNodeDegree.fromArrows.push(arrow);\n    } else {\n      nodeDegreeMap.set(arrow.from, {\n        fromArrows: [arrow],\n        toArrows: [],\n        totalArrows: [],\n        degree: 1\n      });\n    }\n\n    const toNodeDegree = nodeDegreeMap.get(arrow.to);\n    if (isValid(toNodeDegree)) {\n      const firstNodeWidthSameFromTo = toNodeDegree.toArrows.find(node => isSameArrow(node, arrow));\n      if (!firstNodeWidthSameFromTo) {\n        toNodeDegree.degree += 1;\n      } else {\n        arrow.layout.duplicateNode = firstNodeWidthSameFromTo;\n      }\n      toNodeDegree.toArrows.push(arrow);\n    } else {\n      nodeDegreeMap.set(arrow.to, {\n        toArrows: [arrow],\n        fromArrows: [],\n        totalArrows: [],\n        degree: 1\n      });\n    }\n  });\n  nodeDegreeMap.forEach(node => {\n    // 入边，层级跨度越大的越靠下\n    node.fromArrows.sort((a, b) => b.span - a.span);\n    // 出边，层级跨度越大的越靠上\n    node.toArrows.sort((a, b) => a.span - b.span);\n    // 入边在上，出边在下\n    node.totalArrows = [...node.toArrows, ...node.fromArrows];\n  });\n\n  arrows\n    .sort((a, b) => a.span - b.span)\n    .forEach(arrow => {\n      const arrowsIsLayout = arrows.filter(arrow => arrow.layout.isLayout);\n      // 1. 计算当前箭头所在层级\n      const maxLevelArrow = maxInArray(arrowsIsLayout, (cur, curMax) => cur.layout.level - curMax.layout.level);\n\n      let level = maxLevelArrow?.layout.level ?? 0;\n      while (level >= 0) {\n        if (arrowsIsLayout.some(arr => arr.layout.level === level && isArrowCross(arr, arrow))) {\n          level += 1;\n          break;\n        }\n        --level;\n      }\n      arrow.layout.level = Math.max(0, level);\n      // 2. 获取当前箭头所在层级的出入度信息\n      arrow.layout.fromTotal = nodeDegreeMap.get(arrow.from).degree;\n      arrow.layout.toTotal = nodeDegreeMap.get(arrow.to).degree;\n      // 3. 计算 from 和 to 的顺序\n      const duplicateNode = arrow.layout.duplicateNode;\n      if (duplicateNode) {\n        arrow.layout.fromIndex = duplicateNode.layout.fromIndex;\n        arrow.layout.toIndex = duplicateNode.layout.toIndex;\n      } else {\n        arrow.layout.fromIndex = computeIndex(arrow, nodeDegreeMap.get(arrow.from).totalArrows);\n        arrow.layout.toIndex = computeIndex(arrow, nodeDegreeMap.get(arrow.to).totalArrows);\n      }\n      arrow.layout.isLayout = true;\n    });\n\n  return arrows;\n}\n\nfunction computeIndex(arrow: ParsedArrow, totalArrows: ParsedArrow[]) {\n  let index = 0;\n  let duplicateCount = 0;\n  for (let i = 0; i < totalArrows.length; i++) {\n    const curArrow = totalArrows[i];\n    if (curArrow === arrow) {\n      index = i - duplicateCount;\n      break;\n    }\n    if (curArrow.layout.duplicateNode) {\n      duplicateCount++;\n    }\n  }\n  return index;\n}\n"]}