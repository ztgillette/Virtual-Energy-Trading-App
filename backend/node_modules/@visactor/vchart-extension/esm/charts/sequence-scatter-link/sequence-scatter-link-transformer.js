import { CommonChartSpecTransformer } from "@visactor/vchart";

const DATA_KEY = "dataKey";

export class SequenceScatterLinkChartSpecTransformer extends CommonChartSpecTransformer {
    transformSpec(spec) {
        var _a, _b, _c, _d, _e;
        super.transformSpec(spec);
        const dataSpecs = processSequenceData(spec), showTooltip = "neighborhood" !== spec.taskType;
        spec.type = "common", spec.dataKey = DATA_KEY, spec.data = dataSpecs[0].data, spec.series = [ {
            id: "background-series",
            type: "area",
            dataId: "background",
            interactive: !1,
            persent: !0,
            xField: "x",
            yField: "y",
            point: {
                visible: !1
            },
            line: {
                visible: !1
            },
            area: {
                visible: !0,
                interactive: !1,
                style: {
                    background: datum => "neighborhood" === spec.taskType ? "" : `https://lf9-dp-fe-cms-tos.byteorg.com/obj/bit-cloud/sequence-scatter-bgimg-2/${datum.iter}.png`,
                    fill: "transparent",
                    fillOpacity: .5
                }
            },
            hover: {
                enable: !1
            },
            select: {
                enable: !1
            }
        }, {
            id: "line-series",
            type: "line",
            dataId: "endpoints",
            xField: "x",
            yField: "y",
            seriesField: "edgeId",
            animation: !0,
            point: {
                visible: !1
            },
            line: {
                visible: !0,
                style: {
                    stroke: datum => datum.color,
                    lineDash: datum => "same_type" === datum.type ? [ 0, 0 ] : [ 3, 2 ],
                    lineWidth: .8,
                    strokeOpacity: .6
                }
            }
        }, {
            id: "scatter-series",
            type: "scatter",
            dataId: "nodes",
            xField: spec.xField,
            yField: spec.yField,
            seriesField: "label",
            point: {
                state: {
                    hover: {
                        scaleX: 1.5,
                        scaleY: 1.5,
                        fillOpacity: 1
                    },
                    hover_reverse: {
                        scaleX: 1,
                        scaleY: 1,
                        fillOpacity: .3
                    }
                },
                style: {
                    size: () => "neighborhood" === spec.taskType ? 6 : 4,
                    fill: datum => {
                        var _a;
                        return null !== (_a = spec.labelColor[datum.label]) && void 0 !== _a ? _a : "gray";
                    },
                    fillOpacity: datum => datum.confidence
                }
            },
            label: {
                visible: !0,
                style: {
                    visible: () => "neighborhood" == spec.taskType,
                    type: "text",
                    fontFamily: "Console",
                    fontStyle: "italic",
                    fontSize: 12,
                    fill: "black",
                    fillOpacity: .6,
                    text: datum => datum.id
                }
            }
        } ], spec.player && (spec.player = Object.assign(Object.assign({}, spec.player), {
            specs: dataSpecs
        }), spec.animationAppear = {
            duration: null !== (_b = null === (_a = spec.player) || void 0 === _a ? void 0 : _a.duration) && void 0 !== _b ? _b : 2e3,
            easing: "linear"
        }, spec.animationUpdate = {
            duration: null !== (_d = null === (_c = spec.player) || void 0 === _c ? void 0 : _c.duration) && void 0 !== _d ? _d : 2e3,
            easing: "linear"
        }), spec.axes = [ {
            orient: "left",
            type: "linear",
            inverse: !0,
            min: spec.scope[1],
            max: spec.scope[3]
        }, {
            orient: "bottom",
            type: "linear",
            min: spec.scope[0],
            max: spec.scope[2]
        } ], spec.customMark = [ {
            type: "text",
            dataId: "iter",
            style: Object.assign({
                x: 50,
                y: () => 10,
                textBaseline: "top",
                textAlign: "left",
                fontSize: 100,
                fontWeight: "bolder",
                fill: "black",
                fillOpacity: .2
            }, null === (_e = spec.infoLabel) || void 0 === _e ? void 0 : _e.style)
        } ], spec.legends = [ {
            seriesId: "scatter-series",
            visible: !0,
            orient: "right",
            position: "middle",
            data: items => items.map((item => (item.shape.outerBorder = {
                stroke: item.shape.fill,
                distance: 2,
                lineWidth: 1
            }, item))),
            title: {
                visible: !0,
                align: "left",
                textStyle: {
                    text: "Classes",
                    fontFamily: "Console",
                    fontSize: 18,
                    fontWeight: "bold"
                }
            },
            item: {
                visible: !0,
                width: "8%",
                value: {
                    alignRight: !0,
                    style: {
                        fill: "#000",
                        fillOpacity: 1,
                        fontSize: 12
                    },
                    state: {
                        unselected: {
                            fill: "#d8d8d8"
                        }
                    }
                }
            }
        } ], spec.tooltip = {
            visible: showTooltip,
            seriesId: "scatter-series",
            lockAfterClick: !1,
            activeType: "mark",
            trigger: "hover",
            mark: {
                title: {
                    visible: !0,
                    value: "Info"
                },
                content: [ {
                    key: "Label",
                    value: datum => datum.label,
                    shapeType: "circle",
                    shapeSize: 8
                }, {
                    key: "Prediction",
                    value: datum => datum.prediction,
                    shapeType: "circle",
                    shapeSize: 8,
                    shapeFill: datum => {
                        var _a;
                        return null !== (_a = spec.labelColor[datum.prediction]) && void 0 !== _a ? _a : "gray";
                    }
                }, {
                    key: "Confidence",
                    value: datum => datum.confidence.toFixed(2),
                    shapeType: "square",
                    shapeSize: 8,
                    shapeFill: datum => datum.label === datum.prediction ? "green" : "red"
                } ]
            },
            style: {
                panel: {
                    padding: {
                        top: 10,
                        bottom: 15,
                        left: 10,
                        right: 10
                    },
                    backgroundColor: "#fff",
                    border: {
                        color: "#eee",
                        width: 1,
                        radius: 10
                    }
                },
                titleLabel: {
                    fontSize: 20,
                    fontFamily: "Times New Roman",
                    fill: "brown",
                    fontWeight: "bold",
                    textAlign: "center",
                    lineHeight: 24
                },
                keyLabel: {
                    fontSize: 16,
                    fontFamily: "Times New Roman",
                    fill: "black",
                    textAlign: "center",
                    lineHeight: 15,
                    spacing: 10
                },
                valueLabel: {
                    fontSize: 14,
                    fill: "black",
                    textAlign: "center",
                    lineHeight: 15,
                    spacing: 10
                }
            }
        }, spec.dataZoom = [ {
            visible: !1,
            orient: "left",
            filterMode: "axis",
            showDetail: !1,
            roamZoom: {
                enable: !0,
                focus: !0,
                rate: 3
            },
            roamDrag: {
                enable: !0,
                reverse: !0,
                rate: 1
            }
        }, {
            visible: !1,
            orient: "bottom",
            filterMode: "axis",
            showDetail: !1,
            roamZoom: {
                enable: !0,
                focus: !0,
                rate: 3
            },
            roamDrag: {
                enable: !0,
                reverse: !0,
                rate: 1
            }
        } ], super.transformSpec(spec);
    }
}

export function processSequenceData(spec) {
    const result = [];
    return Object.keys(spec.data).forEach((iter => {
        const nodes = spec.data[iter].nodes;
        result.push({
            data: [ {
                id: "nodes",
                values: nodes.map(((d, i) => Object.assign(Object.assign({}, d), {
                    [DATA_KEY]: i
                })))
            }, {
                id: "endpoints",
                values: []
            }, {
                id: "iter",
                values: [ {
                    iter: iter
                } ]
            }, {
                id: "background",
                values: [ {
                    iter: iter,
                    x: spec.scope[0],
                    y: spec.scope[1]
                }, {
                    iter: iter,
                    x: spec.scope[0],
                    y: spec.scope[3]
                }, {
                    iter: iter,
                    x: spec.scope[2],
                    y: spec.scope[3]
                }, {
                    iter: iter,
                    x: spec.scope[2],
                    y: spec.scope[1]
                }, {
                    iter: iter,
                    x: spec.scope[0],
                    y: spec.scope[1]
                } ]
            } ]
        });
    })), result;
}
//# sourceMappingURL=sequence-scatter-link-transformer.js.map
