{"version":3,"sources":["../src/animation/interface.ts"],"names":[],"mappings":"AAKA,MAAM,CAAN,IAAY,kBAUX;AAVD,WAAY,kBAAkB;IAC5B,uCAAiB,CAAA;IACjB,6CAAuB,CAAA;IACvB,qCAAe,CAAA;IACf,uCAAiB,CAAA;IACjB,qCAAe,CAAA;IACf,mCAAa,CAAA;IACb,uCAAiB,CAAA;IAEjB,mCAAa,CAAA;AACf,CAAC,EAVW,kBAAkB,KAAlB,kBAAkB,QAU7B","file":"interface.js","sourcesContent":["import type { ACustomAnimate } from '@visactor/vrender-animate';\nimport type { IGraphic, EasingType } from '@visactor/vrender-core';\nimport type { IMark, IMarkGraphic } from '../mark/interface/common';\nimport type { BaseMark } from '../mark';\n\nexport enum AnimationStateEnum {\n  appear = 'appear',\n  disappear = 'disappear',\n  enter = 'enter',\n  update = 'update',\n  state = 'state',\n  exit = 'exit',\n  normal = 'normal',\n  // for hack\n  none = 'none'\n}\n\nexport type IAnimationState = keyof typeof AnimationStateEnum;\n\nexport interface IAnimateState {\n  animationState: { callback: (datum: any, element: any) => AnimationStateEnum };\n}\n\nexport interface ICartesianGroupAnimationParams {\n  direction: () => 'x' | 'y';\n  orient: () => 'positive' | 'negative';\n  width: () => number;\n  height: () => number;\n}\n\nexport interface IAnimationParameters {\n  width: number;\n  height: number;\n  mark: IMark;\n  group: IMark | null;\n  elementIndex: number;\n  elementCount: number;\n  view: any;\n}\n\nexport type IAnimationChannelInterpolator = (\n  ratio: number,\n  from: any,\n  to: any,\n  nextAttributes: any,\n  datum: any,\n  g: IGraphic,\n  parameters: IAnimationParameters\n) => boolean | void;\n\nexport type GraphicFunctionCallback<T> = (datum: any, g: IGraphic, params: any) => T;\n\nexport type GraphicFunctionValueType<T> = GraphicFunctionCallback<T> | T;\n\n/**\n * state动画，暂时只支持简单配置\n */\nexport interface IStateAnimationConfig {\n  /**\n   * 状态动画的动画时长\n   */\n  duration?: number;\n  /**\n   * 状态动画的缓动函数类型\n   */\n  easing?: EasingType;\n}\n\nexport interface IAnimationControlOptions {\n  /** 当动画状态变更时清空动画 */\n  stopWhenStateChange?: boolean;\n  /** 是否立即应用动画初始状态 */\n  immediatelyApply?: boolean;\n  /** encode 计算图元最终状态时是否忽略循环动画 */\n  ignoreLoopFinalAttributes?: boolean;\n}\n\nexport interface CommonAnimationConfigItem {\n  custom?: IAnimationChannelInterpolator | IAnimationCustomConstructor;\n  customParameters?: GraphicFunctionValueType<any>;\n\n  easing?: EasingType;\n  duration?: GraphicFunctionValueType<number>;\n  delay?: GraphicFunctionValueType<number>;\n  delayAfter?: GraphicFunctionValueType<number>;\n  oneByOne?: GraphicFunctionValueType<boolean | number>;\n  startTime?: GraphicFunctionValueType<number>;\n  totalTime?: GraphicFunctionValueType<number>;\n  /** loop: true 无限循环; loop: 正整数，表示循环的次数 */\n  loop?: boolean | number;\n  /** 动画 effect 配置项 */\n  options?: GraphicFunctionValueType<any>;\n  /** 动画执行相关控制配置项 */\n  controlOptions?: IAnimationControlOptions;\n  /** 该动画是否需要忽略子图元 */\n  selfOnly?: boolean;\n}\n\nexport interface TypeAnimationConfig extends CommonAnimationConfigItem {\n  type: string;\n}\n\nexport type IAnimationChannelFunction = (datum: any, g: IGraphic, mark: IMark) => any;\n\nexport type IAnimationChannelAttrs = Record<\n  string,\n  {\n    from?: any | IAnimationChannelFunction;\n    to?: any | IAnimationChannelFunction;\n  }\n>;\n\nexport interface ChannelAnimationConfig extends CommonAnimationConfigItem {\n  channel: IAnimationChannelAttrs | string[];\n}\n\nexport type IAnimationTypeConfig = TypeAnimationConfig | ChannelAnimationConfig | CommonAnimationConfigItem;\n\nexport interface IAnimationCustomConstructor {\n  new (from: any, to: any, duration: number, ease: EasingType, parameters?: any): ACustomAnimate<any>;\n}\n\nexport type IAnimationEffect = {\n  type?: string;\n  channel?: IAnimationChannelAttrs | string[];\n  custom?: IAnimationChannelInterpolator | IAnimationCustomConstructor;\n  customParameters?: GraphicFunctionValueType<any>;\n  easing?: EasingType;\n  options?: GraphicFunctionValueType<any>;\n};\n\nexport interface IAnimationTimeSlice {\n  effects: IAnimationEffect | IAnimationEffect[];\n  duration?: GraphicFunctionValueType<number>;\n  delay?: GraphicFunctionValueType<number>;\n  delayAfter?: GraphicFunctionValueType<number>;\n}\n\nexport interface IAnimationTimeline {\n  /** 为了方便动画编排，用户可以设置 id 用于识别时间线 */\n  id?: string;\n  /** 时间切片 */\n  timeSlices: IAnimationTimeSlice | IAnimationTimeSlice[];\n  /** 动画开始的相对时间，可以为负数 */\n  startTime?: GraphicFunctionValueType<number>;\n  /** 动画时长 */\n  totalTime?: GraphicFunctionValueType<number>;\n  /** 动画依次执行的延迟 */\n  oneByOne?: GraphicFunctionValueType<number | boolean>;\n  /** loop: true 无限循环; loop: 正整数，表示循环的次数 */\n  loop?: GraphicFunctionValueType<number | boolean>;\n  /** 对图元元素进行划分，和过滤类似，但是不同时间线不能同时作用在相同的元素上 */\n  partitioner?: GraphicFunctionCallback<boolean>;\n  /** 对同一时间线上的元素进行排序 */\n  sort?: (datumA: any, datumB: any, graphicA: IGraphic, graphicB: IGraphic) => number;\n  /** 动画执行相关控制配置项 */\n  controlOptions?: IAnimationControlOptions;\n}\n\nexport type IAnimationConfig = IAnimationTimeline | IAnimationTypeConfig;\n\nexport interface MarkAnimationSpec {\n  disappear?: IAnimationConfig | IAnimationConfig[];\n  appear?: IAnimationConfig | IAnimationConfig[];\n  enter?: IAnimationConfig | IAnimationConfig[];\n  exit?: IAnimationConfig | IAnimationConfig[];\n  update?: IAnimationConfig | IAnimationConfig[];\n  normal?: IAnimationConfig | IAnimationConfig[];\n  state?: IStateAnimationConfig;\n}\n\nexport type MarkAnimationType = keyof MarkAnimationSpec;\n\n/**\n * 动画拆分策略接口\n * 用于定义如何拆分一个动画更新为多个步骤\n */\nexport interface IAnimationSplitStrategy {\n  /**\n   * 策略名称\n   */\n  name: string;\n\n  /**\n   * 检查是否应该应用此策略\n   * @param mark 图表标记\n   * @param graphic 图形元素\n   * @returns 是否应用此策略\n   */\n  shouldApply: (mark: BaseMark<any>, graphic: IMarkGraphic) => boolean;\n\n  /**\n   * 拆分动画更新\n   * @param mark 图表标记\n   * @param graphic 图形元素\n   * @returns 拆分后的动画更新数组（每个元素包含一组属性和执行顺序）\n   */\n  split: (\n    mark: BaseMark<any>,\n    graphic: IMarkGraphic\n  ) => Array<{\n    attrs: Record<string, any>;\n    order: number;\n  }>;\n}\n"]}