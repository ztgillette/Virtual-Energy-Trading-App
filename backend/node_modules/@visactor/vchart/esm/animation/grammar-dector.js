import { AnimationPlanner } from "./animation-planner";

import { DiffState } from "../mark/interface/enum";

import { VerticalBarSplitStrategy } from "./strategy/vertical-bar-split";

import { HorizontalBarSplitStrategy } from "./strategy/horizontal-bar-split";

export class GrammarDetector {
    constructor(mark) {
        this.splitStrategies = [], this.mark = mark, "rect" === mark.type && (this.registerStrategy(new VerticalBarSplitStrategy), 
        this.registerStrategy(new HorizontalBarSplitStrategy));
    }
    registerStrategy(strategy) {
        this.splitStrategies.push(strategy);
    }
    detect(graphics, graphicMap) {
        const exitGraphics = [], updateGraphics = [], enterGraphics = [], appearGraphics = [], fieldX = this.mark.model.fieldX, fieldY = this.mark.model.fieldY;
        return graphics.forEach((g => {
            const context = g.context;
            context.fieldX && (context.originalFieldX = context.fieldX), context.fieldY && (context.originalFieldY = context.fieldY), 
            context.fieldX = fieldX, context.fieldY = fieldY;
            switch (g.context.animationState) {
              case "update":
                updateGraphics.push(g);
                break;

              case "enter":
                enterGraphics.push(g);
                break;

              case "appear":
                appearGraphics.push(g);
                break;

              default:
                g.context.diffState === DiffState.exit ? exitGraphics.push(g) : g.context.diffState === DiffState.enter ? enterGraphics.push(g) : updateGraphics.push(g);
            }
        })), graphicMap.size > graphics.length && graphicMap.forEach(((g, key) => {
            g.context.diffState !== DiffState.exit || g.isExiting || exitGraphics.push(g);
        })), {
            hasExit: exitGraphics.length > 0,
            hasUpdate: updateGraphics.length > 0,
            hasEnter: enterGraphics.length > 0,
            hasAppear: appearGraphics.length > 0,
            exitGraphics: exitGraphics,
            updateGraphics: updateGraphics,
            enterGraphics: enterGraphics,
            appearGraphics: appearGraphics
        };
    }
    createPlanners(result, animationConfig) {
        const planners = [];
        if (result.hasExit && animationConfig.exit && planners.push(new AnimationPlanner("exit", result.exitGraphics, animationConfig.exit)), 
        result.hasUpdate && animationConfig.update) {
            const updateGraphicsByStep = new Map, regularUpdateGraphics = [];
            result.updateGraphics.forEach((graphic => {
                let applied = !1;
                for (const strategy of this.splitStrategies) if (strategy.shouldApply(this.mark, graphic)) {
                    const splitUpdates = strategy.split(this.mark, graphic), graphicWithSteps = {
                        graphic: graphic,
                        steps: splitUpdates
                    };
                    splitUpdates.forEach((update => {
                        const {order: order} = update;
                        updateGraphicsByStep.has(order) || updateGraphicsByStep.set(order, []), updateGraphicsByStep.get(order).push(graphicWithSteps);
                    })), applied = !0;
                    break;
                }
                applied || regularUpdateGraphics.push(graphic);
            })), regularUpdateGraphics.length > 0 && planners.push(new AnimationPlanner("update", regularUpdateGraphics, animationConfig.update));
            const steps = Array.from(updateGraphicsByStep.keys()).sort(((a, b) => a - b));
            steps.forEach((step => {
                const graphicsWithSteps = updateGraphicsByStep.get(step);
                if (graphicsWithSteps && graphicsWithSteps.length > 0) {
                    const graphicsForStep = graphicsWithSteps.map((({graphic: graphic, steps: steps}) => {
                        const stepConfig = steps.find((s => s.order === step));
                        return {
                            graphic: graphic,
                            attrs: (null == stepConfig ? void 0 : stepConfig.attrs) || {}
                        };
                    }));
                    planners.push(new AnimationPlanner("update", graphicsForStep.map((item => item.graphic)), animationConfig.update, (graphics => {
                        graphics.forEach(((g, index) => {
                            const attrs = graphicsForStep[index].attrs, context = g.context;
                            context._originalDiffAttrs || (context._originalDiffAttrs = g.context.diffAttrs), 
                            g.context.diffAttrs = attrs;
                        }));
                    }), (graphics => {
                        step === steps[steps.length - 1] && graphics.forEach((g => {
                            const context = g.context;
                            context._originalDiffAttrs && (g.context.diffAttrs = context._originalDiffAttrs, 
                            delete context._originalDiffAttrs);
                        }));
                    })));
                }
            }));
        }
        return result.hasEnter && animationConfig.enter && planners.push(new AnimationPlanner("enter", result.enterGraphics, animationConfig.enter)), 
        result.hasAppear && animationConfig.appear && planners.push(new AnimationPlanner("appear", result.appearGraphics, animationConfig.appear)), 
        planners;
    }
}
//# sourceMappingURL=grammar-dector.js.map