{"version":3,"sources":["../src/compile/mark/interface.ts"],"names":[],"mappings":"AA+OA,MAAM,CAAN,IAAY,gBAoBX;AApBD,WAAY,gBAAgB;IAC1B,2CAAuB,CAAA;IAEvB,yCAAqB,CAAA;IACrB,yDAAqC,CAAA;IAErC,6DAAyC,CAAA;IACzC,6EAAyD,CAAA;IAEzD,+CAA2B,CAAA;IAC3B,+DAA2C,CAAA;IAG3C,sDAAkC,CAAA;IAClC,0DAAsC,CAAA;IAEtC,iDAA6B,CAAA;IAC7B,uCAAmB,CAAA;IAEnB,2CAAuB,CAAA;AACzB,CAAC,EApBW,gBAAgB,KAAhB,gBAAgB,QAoB3B;AAED,MAAM,CAAN,IAAY,wBAIX;AAJD,WAAY,wBAAwB;IAClC,iEAAqC,CAAA;IACrC,qFAAyD,CAAA;IACzD,uEAA2C,CAAA;AAC7C,CAAC,EAJW,wBAAwB,KAAxB,wBAAwB,QAInC","file":"interface.js","sourcesContent":["import type { IMark, IMarkGraphic, IMarkStateStyle, MarkType } from '../../mark/interface';\nimport type { IModel } from '../../model/interface';\nimport type { GrammarItemCompileOption, GrammarItemInitOption, IGrammarItem, StateValueMap } from '../interface';\nimport type { DataView } from '@visactor/vdataset';\nimport type { Maybe, Datum, StringOrNumber } from '../../typings';\nimport type { IRegion } from '../../region/interface';\nimport type { ICompilableData } from '../data/interface';\nimport type { ICustomPath2D, IGraphic, IGroup } from '@visactor/vrender-core';\nimport type { MarkAnimationSpec } from '../../animation/interface';\n\nexport interface IMarkConfig {\n  clipPath?: IGraphic[] | ((graphics: IGraphic[]) => IGraphic[]);\n  clip?: boolean;\n  zIndex?: number;\n  interactive?: boolean;\n  /**\n   * set customized shape\n   */\n  setCustomizedShape?: (datum: any[], attrs: any, path: ICustomPath2D) => ICustomPath2D;\n  /** 是否开启大数据渲染模式 */\n  large?: boolean;\n  /** 开启大数据渲染优化的阀值，对应的是data的长度 */\n  largeThreshold?: number;\n  /** 分片长度 */\n  progressiveStep?: number;\n  /** 开启分片渲染的阀值，对应的是单系列data的长度 */\n  progressiveThreshold?: number;\n  /**\n   * use 'sequential' for symbol chart\n   * use 'mod' for bar/line chart\n   */\n  // largeChunkMode?: 'sequential' | 'mod';\n  support3d?: boolean;\n  /**\n   * 象形图，给图形设置名称\n   */\n  graphicName?: string | ((g: IMarkConfig) => string);\n  /**\n   * enable global morphing animation of the mark\n   */\n  morph?: boolean;\n  /**\n   * this key will be used to match the mark to morph\n   */\n  morphKey?: string;\n  /**\n   * this key will be used to match the element of two marks to morph\n   * If not specified, we'll use the \"key\" of the mark by default\n   */\n  morphElementKey?: string;\n\n  overflow?: 'scroll' | 'hidden' | 'scroll-x' | 'scroll-y';\n  skipTheme?: boolean;\n\n  /**\n   * 是否开启序列动画能力，默认关闭\n   */\n  useSequentialAnimation?: boolean;\n}\n\nexport interface IMarkStateManager {\n  getStateInfoList: () => IStateInfo[];\n  getStateInfo: (stateValue: StateValue) => IStateInfo;\n  addStateInfo: (stateInfo: IStateInfo) => void;\n  changeStateInfo: (stateInfo: Partial<IStateInfo>) => void;\n  clearStateInfo: (stateValues: StateValue[]) => void;\n  checkOneState: (renderNode: IMarkGraphic, datum: Datum[], state: IStateInfo) => 'in' | 'out' | 'skip';\n  checkState: (renderNode: IMarkGraphic, datum: Datum[]) => StateValue[];\n  getStateMap: () => StateValueMap;\n  updateState: (newState: Partial<StateValueMap>, noRender?: boolean) => void;\n  release: () => void;\n}\n\nexport interface IMarkData extends ICompilableData {\n  setCompiledProductId: (name: string) => any;\n  generateProductId: () => string;\n}\n\nexport interface ICompilableMarkOption extends GrammarItemInitOption {\n  key?: string | ((datum: Datum) => string);\n  /** 分组字段，更多用于 morphing 动画的 element 匹配 */\n  groupKey?: string;\n  /** 是否在dataflow的过程中，布局前跳过该mark */\n  skipBeforeLayouted?: boolean;\n\n  /* VGrammar的组件是否支持3d */\n  mode?: '2d' | '3d';\n  /** don't separate style of mark */\n  noSeparateStyle?: boolean;\n}\n\nexport interface ICompilableMark extends IGrammarItem {\n  // 类型\n  readonly type: MarkType;\n  // id\n  readonly id: number;\n  // name\n  readonly name: string;\n  // key field\n  readonly key?: string | ((datum: Datum) => string);\n  // parent model\n  readonly model: IModel;\n\n  /**\n   * 上报发生了变更，需要更新\n   */\n  commit: (render?: boolean, recursion?: boolean) => void;\n  uncommit: () => void;\n  isCommited: () => boolean;\n\n  // 数据 可以没有\n  getData: () => ICompilableData | undefined;\n  setData: (d: ICompilableData) => void;\n  getDataView: () => DataView | undefined;\n  setDataView: (d: DataView) => void;\n\n  // 状态\n  state: IMarkStateManager;\n  readonly stateStyle: IMarkStateStyle<any>;\n  hasState: (state: string) => boolean;\n  getState: (state: string) => any;\n  updateState: (newState: Record<string, unknown>) => void;\n  /** 更新 mark 样式 */\n  compileEncode: () => void;\n\n  // 动画配置\n  setAnimationConfig: (config: Partial<MarkAnimationSpec>) => void;\n  getAnimationConfig: () => Partial<MarkAnimationSpec>;\n\n  // 是否显示\n  getVisible: () => boolean;\n  setVisible: (visible: boolean) => void;\n\n  // groupKey 配置\n  setGroupKey: (groupKey: string) => void;\n\n  // 用户 id\n  getUserId: () => StringOrNumber | undefined;\n  setUserId: (id: StringOrNumber) => void;\n\n  compile: (option?: IMarkCompileOption) => void;\n\n  getProduct: () => Maybe<IGroup>;\n\n  /** 获取子mark */\n  getMarks: () => ICompilableMark[];\n\n  /** 是否跳过布局阶段 */\n  setSkipBeforeLayouted: (skip: boolean) => void;\n\n  getMarkConfig: () => IMarkConfig;\n  setMarkConfig: (config: IMarkConfig) => void;\n\n  getContext: () => any;\n\n  /** 开始状态动画 */\n  // runAnimationByState: (animationState?: string) => IAnimateArranger;\n  // /** 停止状态动画*/\n  // stopAnimationByState: (animationState?: string) => IAnimate;\n  // /** 暂停状态动画*/\n  // pauseAnimationByState: (animationState: string) => IAnimate;\n  // /** 恢复状态动画*/\n  // resumeAnimationByState: (animationState: string) => IAnimate;\n\n  layout: (layoutCallback: () => void) => void;\n  setDataLabelType?: () => string;\n}\n\nexport interface IMarkCompileOption extends GrammarItemCompileOption {\n  group?: IGroup;\n  context?: any;\n}\n\nexport interface IStateInfo {\n  /** 状态值 */\n  stateValue: StateValue;\n  // 对应的数据维度 可以是多维度\n  // TODO: fields 是否保留\n  fields?: any | null | undefined;\n  /** 筛选数据 */\n  datums?: any[] | null | undefined;\n  /** 筛选数据 */\n  datumKeys?: string[] | null | undefined;\n  /** 筛选 item */\n  items?: any[] | null | undefined;\n  /** 筛选函数 */\n  filter?:\n    | ((\n        datum: any,\n        options: {\n          mark?: IMark;\n          type?: string;\n          renderNode?: IGraphic;\n        }\n      ) => boolean)\n    | null\n    | undefined;\n  cache?: {\n    [key: string]: {\n      [key: string]: boolean;\n    };\n  };\n  /** 状态优先级 */\n  level?: number | undefined;\n}\n// TODO:目前看这个类型没有必要，确认后彻底删除\nexport interface IStateSpec {\n  /** 状态值 */\n  stateValue: StateValue;\n  /** 筛选数据 */\n  datums?: any[] | null | undefined;\n  /** 筛选数据对应字段 */\n  datumKeys?: string[] | null | undefined;\n  /** TODO: 暂时不提供 filter 函数形式 */\n  // filter?:\n  //   | ((datum: any, options: Record<string, any>) => boolean)\n  //   | null\n  //   | undefined;\n  /** 状态优先级 */\n  level?: number | undefined;\n}\n\nexport interface IMarkState {\n  readonly id: number;\n  // 状态\n  getStates: () => IStateInfo[];\n\n  // state 相关\n  getState: (stateValue: StateValue) => IStateInfo | undefined;\n  addState: (stateInfo: IStateInfo) => void;\n  changeState: (stateInfo: Partial<IStateInfo>, update?: boolean) => void;\n  checkState: (item: any, datum: any) => string[];\n\n  clearState: (stateValues: StateValue[], update?: boolean) => void;\n\n  // 更新\n  update: () => void;\n}\n\nexport enum STATE_VALUE_ENUM {\n  STATE_NORMAL = 'normal',\n\n  STATE_HOVER = 'hover',\n  STATE_HOVER_REVERSE = 'hover_reverse',\n\n  STATE_DIMENSION_HOVER = 'dimension_hover',\n  STATE_DIMENSION_HOVER_REVERSE = 'dimension_hover_reverse',\n\n  STATE_SELECTED = 'selected',\n  STATE_SELECTED_REVERSE = 'selected_reverse',\n\n  // todo: 2.0考虑优化\n  STATE_SANKEY_EMPHASIS = 'selected',\n  STATE_SANKEY_EMPHASIS_REVERSE = 'blur',\n\n  STATE_HIGHLIGHT = 'highlight',\n  STATE_BLUR = 'blur',\n\n  STATE_ACTIVE = 'active'\n}\n\nexport enum STATE_VALUE_ENUM_REVERSE {\n  STATE_HOVER_REVERSE = 'hover_reverse',\n  STATE_DIMENSION_HOVER_REVERSE = 'dimension_hover_reverse',\n  STATE_SELECTED_REVERSE = 'selected_reverse'\n}\n\nexport type STATE_NORMAL = typeof STATE_VALUE_ENUM.STATE_NORMAL;\nexport type STATE_HOVER = typeof STATE_VALUE_ENUM.STATE_HOVER;\nexport type STATE_HOVER_REVERSE = typeof STATE_VALUE_ENUM.STATE_HOVER_REVERSE;\nexport type STATE_CUSTOM = string;\n\n// TODO: 待补充\n\nexport type StateValueNot = STATE_HOVER_REVERSE | STATE_CUSTOM;\nexport type StateValue = STATE_NORMAL | STATE_HOVER | STATE_CUSTOM;\nexport type StateValueType = StateValue | StateValueNot;\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface IModelMarkAttributeContext {\n  [key: string]: unknown;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ISeriesMarkAttributeContext extends IModelMarkAttributeContext {\n  // 通用的默认属性值获取，比如color，如果有散点图有sizeScale，则可以获取 size\n  globalScale: (scaleKey: string, value: string | number) => unknown;\n  // 传入seriesField值，获取对应的颜色。\n  // 如果传入 null ，返回的是当前系列对应的第一个颜色值。\n  seriesColor: (seriesValue?: string | number) => string;\n  /**\n   * 获取当前的 region\n   * @returns\n   */\n  getRegion: () => IRegion;\n}\n"]}