{"version":3,"sources":["../src/compile/interface/compilable-item.ts"],"names":[],"mappings":"AAoGA,MAAM,CAAN,IAAY,WAGX;AAHD,WAAY,WAAW;IACrB,4BAAa,CAAA;IACb,4BAAa,CAAA;AACf,CAAC,EAHW,WAAW,KAAX,WAAW,QAGtB","file":"compilable-item.js","sourcesContent":["import type { StringOrNumber } from '../../typings';\nimport type { IColor, IGroup, IStage } from '@visactor/vrender-core';\nimport type { IChart } from '../../chart/interface/chart';\nimport type { IVChart, IVChartRenderOption } from '../../core/interface';\nimport type { IMorphConfig } from '../../animation/spec';\nimport type { IBoundsLike } from '@visactor/vutils';\nimport type { EventSourceType, EventType } from '../../event/interface';\nimport type { IMark, IMarkGraphic } from '../../mark/interface';\nimport type { LayoutState } from '../interface/compiler';\n\nexport type CompilerListenerParameters = {\n  type: EventType;\n  event: Event;\n  source: EventSourceType;\n  item: IMarkGraphic | null;\n  datum: any | null;\n  markId: number | null;\n  modelId: number | null;\n  markUserId: StringOrNumber | null;\n  modelUserId: StringOrNumber | null;\n};\n\nexport interface IProductMap<T extends IGrammarItem> {\n  /** 编译产物 id 和对应的在 vchart 中的 GrammarItem */\n  [productId: string]: IGrammarItemMap<T>;\n}\n\nexport interface IGrammarItemMap<T extends IGrammarItem> {\n  /** GrammarItem id 和 对应的引用 */\n  [id: number]: T;\n}\n\nexport type ICompilerModel = Record<GrammarType, IProductMap<IGrammarItem>>;\n\nexport interface ICompiler {\n  isInited?: boolean;\n  getCanvas: () => HTMLCanvasElement | undefined;\n  getStage: () => IStage | undefined;\n  compile: (ctx: { chart: IChart; vChart: IVChart }, option?: IVChartRenderOption) => void;\n  clear: (ctx: { chart: IChart; vChart: IVChart }, removeGraphicItems?: boolean) => void;\n  renderNextTick: (morphConfig?: IMorphConfig) => void;\n  render: (morphConfig?: IMorphConfig) => void;\n  updateViewBox: (viewBox: IBoundsLike, reRender?: boolean) => void;\n  resize: (width: number, height: number, reRender?: boolean) => void;\n  setBackground: (color: IColor) => void;\n  setSize: (width: number, height: number) => void;\n  setViewBox: (viewBox: IBoundsLike, reRender?: boolean) => void;\n  addEventListener: (\n    source: EventSourceType,\n    type: string,\n    callback: (params: CompilerListenerParameters) => void\n  ) => void;\n  removeEventListener: (\n    source: EventSourceType,\n    type: string,\n    callback: (params: CompilerListenerParameters) => void\n  ) => void;\n  release: () => void;\n  releaseGrammar: (removeGraphicItems: boolean) => void;\n  // addGrammarItem: (grammarItem: IGrammarItem) => void;\n  // removeGrammarItem: (grammarItem: IGrammarItem, reserveVGrammarModel?: boolean) => void;\n\n  addRootMark: (mark: IMark) => any;\n  removeRootMark: (mark: IMark) => any;\n  getRootMarks: () => IMark[];\n\n  updateLayoutTag: () => void;\n  getLayoutState: () => LayoutState;\n  getRootGroup: () => IGroup;\n  getChart: () => IChart;\n}\n\nexport interface ICompilable {\n  /** 获取 compile 对象 */\n  getCompiler: () => ICompiler;\n  /** 获取 vgrammar view */\n  getStage: () => IStage;\n\n  /** 编译总入口 */\n  compile: () => void;\n  /** 编译所有 mark */\n  compileMarks?: (group?: IGroup) => void;\n  /** 编译所有 data */\n  compileData?: () => void;\n\n  /** 清除compile 内容入口 */\n  clear?: () => void;\n\n  /** 全部编译完成 lift circle */\n  afterCompile?: () => void;\n\n  /** 释放总入口 */\n  release: () => void;\n}\n\nexport interface ICompilableInitOption {\n  /** 编译对象 应当由外部提供 */\n  getCompiler: () => ICompiler;\n}\n\nexport enum GrammarType {\n  data = 'data',\n  mark = 'mark'\n}\n\nexport interface ITransformSpec {\n  type: string;\n  [key: string]: any;\n}\n\nexport interface IGrammarItem extends ICompilable {\n  id: number;\n  /** 生成语法元素名称 */\n  generateProductId: () => string;\n  /** 获取语法元素名称 */\n  getProductId: () => string;\n  /** 删除已编译的语法元素 */\n  removeProduct: () => void;\n  // transform\n  setTransform: (transform: ITransformSpec[]) => void;\n}\n\nexport type GrammarItemInitOption = ICompilableInitOption;\n\nexport type GrammarItemCompileOption = Record<string, any>;\n\nexport type StateValueMap = Record<string, unknown>;\n"]}