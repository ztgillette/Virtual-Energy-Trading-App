import { morphPath, multiToOneMorph, oneToMultiMorph } from "@visactor/vrender-animate";

import { isNumber, isValid, isValidNumber } from "@visactor/vutils";

const invokeFunctionType = (value, params, morphData, morphElements) => "function" == typeof value ? value(params, morphData, morphElements) : value, doMorph = (prev, next, config, onEnd, parameters) => {
    var _a;
    const morphData = {
        prev: prev.map((element => {
            var _a, _b;
            return null === (_b = null === (_a = element.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0];
        })),
        next: next.map((element => {
            var _a, _b;
            return null === (_b = null === (_a = element.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0];
        }))
    }, morphElements = {
        prev: prev.slice(),
        next: next.slice()
    }, animation = null !== (_a = config.animation) && void 0 !== _a ? _a : {}, easing = animation.easing, delay = invokeFunctionType(animation.delay, parameters, morphData, morphElements), duration = invokeFunctionType(animation.duration, parameters, morphData, morphElements), oneByOne = invokeFunctionType(animation.oneByOne, parameters, morphData, morphElements), splitPath = invokeFunctionType(animation.splitPath, parameters, morphData, morphElements), individualDelay = isValidNumber(oneByOne) && oneByOne > 0 ? index => isNumber(oneByOne) ? index * oneByOne : !0 === oneByOne ? index * duration : 0 : void 0;
    1 !== prev.length && 0 !== prev.length || 1 !== next.length ? 1 === prev.length && next.length > 1 ? oneToMultiMorph(prev[0], next, {
        delay: delay,
        duration: duration,
        easing: easing,
        onEnd: onEnd,
        individualDelay: individualDelay,
        splitPath: splitPath
    }) : prev.length > 1 && 1 === next.length && multiToOneMorph(prev, next[0], {
        delay: delay,
        duration: duration,
        easing: easing,
        onEnd: onEnd,
        individualDelay: individualDelay,
        splitPath: splitPath
    }) : morphPath(prev[0], next[0], {
        delay: delay,
        duration: duration,
        easing: easing,
        onEnd: onEnd
    });
}, divideElements = (elements, count) => {
    const divideLength = Math.floor(elements.length / count);
    return new Array(count).fill(0).map(((_, index) => elements.slice(divideLength * index, index === count - 1 ? elements.length : divideLength * (index + 1))));
}, appendMorphKeyToGraphics = mark => {
    const config = mark.getMarkConfig();
    if (isValid(config.morphElementKey)) {
        mark.getGraphics().forEach((graphic => {
            var _a, _b;
            const data = null === (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0];
            data && (graphic.context.morphKey = data[config.morphElementKey]);
        }));
    }
};

export const morph = (prevMarks, nextMarks, morphConfig = {}) => {
    const prevGraphics = [], nextGraphics = [];
    prevMarks.forEach((mark => {
        appendMorphKeyToGraphics(mark), prevGraphics.push(...mark.getGraphics());
    })), nextMarks.forEach((mark => {
        appendMorphKeyToGraphics(mark), nextGraphics.push(...mark.getGraphics());
    }));
    const getKey = graphic => {
        var _a, _b, _c;
        return null !== (_b = null === (_a = graphic.context) || void 0 === _a ? void 0 : _a.morphKey) && void 0 !== _b ? _b : null === (_c = graphic.context) || void 0 === _c ? void 0 : _c.key;
    }, prevByKey = new Map, nextByKey = new Map;
    if (prevGraphics.forEach((graphic => {
        const key = getKey(graphic);
        key && (prevByKey.has(key) || prevByKey.set(key, []), prevByKey.get(key).push(graphic));
    })), nextGraphics.forEach((graphic => {
        const key = getKey(graphic);
        key && (nextByKey.has(key) || nextByKey.set(key, []), nextByKey.get(key).push(graphic));
    })), prevByKey.size !== nextByKey.size || !Array.from(prevByKey.keys()).every((k => nextByKey.has(k)))) return !1;
    const updateKeys = [ ...new Set([ ...prevByKey.keys() ].filter((key => nextByKey.has(key)))) ], enterKeys = [ ...nextByKey.keys() ].filter((key => !prevByKey.has(key)));
    let morphCount = 0;
    const onMorphEnd = () => {
        morphCount -= 1, 0 === morphCount && nextMarks.forEach((mark => {}));
    };
    return enterKeys.forEach((key => {
        const nextElements = nextByKey.get(key);
        doMorph([], nextElements, morphConfig, onMorphEnd, {}), morphCount += 1;
    })), updateKeys.forEach((key => {
        const prevElements = prevByKey.get(key), nextElements = nextByKey.get(key), divideCount = Math.min(prevElements.length, nextElements.length);
        if (divideCount > 0) {
            const prevDivide = divideElements(prevElements, divideCount), nextDivide = divideElements(nextElements, divideCount);
            for (let i = 0; i < divideCount; i++) doMorph(prevDivide[i], nextDivide[i], morphConfig, onMorphEnd, {}), 
            morphCount += 1;
        }
    })), 0 === morphCount && onMorphEnd(), !0;
};
//# sourceMappingURL=morph.js.map