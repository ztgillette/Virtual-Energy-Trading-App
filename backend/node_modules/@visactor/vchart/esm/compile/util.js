import { isNil } from "@visactor/vutils";

import { groupData } from "../mark/utils/common";

import { RenderModeEnum } from "../typings/spec/common";

export function toRenderMode(mode) {
    switch (mode) {
      case RenderModeEnum["desktop-browser"]:
      case RenderModeEnum["mobile-browser"]:
        return "browser";

      case RenderModeEnum.node:
      case RenderModeEnum.worker:
        return "node";

      case RenderModeEnum.miniApp:
      case RenderModeEnum["desktop-miniApp"]:
        return "feishu";

      case RenderModeEnum.lynx:
        return "lynx";

      case RenderModeEnum.wx:
        return "wx";

      case RenderModeEnum.tt:
        return "tt";

      case RenderModeEnum.harmony:
        return "harmony";
    }
    return "browser";
}

export function traverseGroupMark(group, apply, filter, leafFirst, stop) {
    const traverse = mark => {
        if (!leafFirst && mark && (!filter || filter(mark))) {
            const res = apply.call(null, mark);
            if (stop && res) return res;
        }
        if ("group" === mark.type) {
            const children = mark.getMarks();
            if (children) for (let i = 0; i < children.length; i++) {
                const res = traverse(children[i]);
                if (res && stop) return res;
            }
        }
        if (leafFirst && mark && (!filter || filter(mark))) {
            const res = apply.call(null, mark);
            if (res && stop) return res;
        }
    };
    return traverse(group);
}

export function findSimpleMarks(groups) {
    const marks = [];
    return groups.forEach((g => {
        traverseGroupMark(g, (m => {
            "group" !== m.type && "component" !== m.type && marks.push(m);
        }));
    })), marks;
}

export function diffUpdateByGroup(prev, next, prevKey, nextKey) {
    const prevGroup = groupData(prev, (datum => prevKey(datum))), nextGroup = groupData(next, (datum => nextKey(datum)));
    let prevAfterDiff = prev, nextAfterDiff = next;
    const update = [];
    return nextGroup.keys.forEach((key => {
        if (!isNil(key)) {
            const prevKeyData = prevGroup.data.get(key), nextKeyData = nextGroup.data.get(key);
            prevKeyData && nextKeyData && (update.push({
                prev: prevKeyData,
                next: nextKeyData
            }), prevAfterDiff = prevAfterDiff.filter((datum => !prevKeyData.includes(datum))), 
            nextAfterDiff = nextAfterDiff.filter((datum => !nextKeyData.includes(datum))));
        }
    })), {
        prev: prevAfterDiff,
        next: nextAfterDiff,
        update: update
    };
}

export function diffMarks(prevMarks, nextMarks, runningConfig) {
    const diffResult = {
        enter: [],
        exit: [],
        update: []
    };
    let prevDiffMarks = [], nextDiffMarks = [];
    prevMarks.forEach((mark => {
        runningConfig.morph && mark.getMarkConfig().morph || runningConfig.morphAll || runningConfig.reuse ? prevDiffMarks.push(mark) : diffResult.exit.push({
            prev: [ mark ]
        });
    })), nextMarks.forEach((mark => {
        runningConfig.morph && mark.getMarkConfig().morph || runningConfig.morphAll || runningConfig.reuse ? nextDiffMarks.push(mark) : diffResult.enter.push({
            next: [ mark ]
        });
    }));
    const keyDiffResult = diffUpdateByGroup(prevDiffMarks, nextDiffMarks, (mark => mark.getMarkConfig().morphKey), (mark => mark.getMarkConfig().morphKey));
    prevDiffMarks = keyDiffResult.prev, nextDiffMarks = keyDiffResult.next, diffResult.update = diffResult.update.concat(keyDiffResult.update);
    const nameDiffResult = diffUpdateByGroup(prevDiffMarks, nextDiffMarks, (mark => `${mark.getUserId()}`), (mark => `${mark.getUserId()}`));
    prevDiffMarks = nameDiffResult.prev, nextDiffMarks = nameDiffResult.next, diffResult.update = diffResult.update.concat(nameDiffResult.update);
    const prevParentGroup = groupData(prevDiffMarks, (mark => {
        var _a, _b;
        return null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.id) || void 0 === _b ? void 0 : _b.call(_a);
    })), nextParentGroup = groupData(nextDiffMarks, (mark => {
        var _a, _b;
        return null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.id) || void 0 === _b ? void 0 : _b.call(_a);
    }));
    return Object.keys(nextParentGroup).forEach((groupName => {
        const prevChildren = prevParentGroup.data.get(groupName), nextChildren = nextParentGroup.data.get(groupName);
        if (prevChildren && nextChildren) {
            for (let i = 0; i < Math.max(prevChildren.length, nextChildren.length); i += 1) {
                const prevChild = prevChildren[i], nextChild = nextChildren[i];
                prevChild && nextChild ? diffResult.update.push({
                    prev: [ prevChild ],
                    next: [ nextChild ]
                }) : prevChild ? diffResult.exit.push({
                    prev: [ prevChild ]
                }) : nextChild && diffResult.enter.push({
                    next: [ nextChild ]
                });
            }
            prevDiffMarks = prevDiffMarks.filter((mark => !prevChildren.includes(mark))), nextDiffMarks = nextDiffMarks.filter((mark => !nextChildren.includes(mark)));
        }
    })), prevDiffMarks.forEach((mark => diffResult.exit.push({
        prev: [ mark ]
    }))), nextDiffMarks.forEach((mark => diffResult.enter.push({
        next: [ mark ]
    }))), diffResult;
}
//# sourceMappingURL=util.js.map