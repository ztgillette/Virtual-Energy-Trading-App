{"version":3,"sources":["../src/compile/morph.ts"],"names":[],"mappings":"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","file":"morph.js","sourcesContent":["import { morphPath, multiToOneMorph, oneToMultiMorph } from '@visactor/vrender-animate';\nimport { isNil, isNumber, isValid, isValidNumber } from '@visactor/vutils';\nimport type { IMark, IMarkGraphic } from '../mark/interface';\nimport type { IMorphConfig } from '../animation/spec';\nimport type { Datum } from '../typings';\n\n/** Morph data for animation */\ninterface MorphData {\n  prev: Datum[];\n  next: Datum[];\n}\n\n/** Elements to morph */\ninterface MorphElements {\n  prev: IMarkGraphic[];\n  next: IMarkGraphic[];\n}\n\n/** Type to allow either a static value or a function that returns a value */\ntype MorphFunctionValueType<T> = T | ((params: any, morphData: MorphData, morphElements: MorphElements) => T);\n\n/**\n * Apply a function value or return the static value\n */\nconst invokeFunctionType = <T>(\n  value: MorphFunctionValueType<T>,\n  params: any,\n  morphData: MorphData,\n  morphElements: MorphElements\n): T => {\n  if (typeof value === 'function') {\n    return (value as Function)(params, morphData, morphElements) as T;\n  }\n  return value;\n};\n\n/**\n * Execute the morphing animation between previous and next elements\n */\nconst doMorph = (\n  prev: IMarkGraphic[],\n  next: IMarkGraphic[],\n  config: IMorphConfig,\n  onEnd: () => void,\n  parameters: any\n) => {\n  const morphData: MorphData = {\n    prev: prev.map(element => element.context?.data?.[0]),\n    next: next.map(element => element.context?.data?.[0])\n  };\n\n  const morphElements: MorphElements = {\n    prev: prev.slice(),\n    next: next.slice()\n  };\n\n  const animation = config.animation ?? {};\n  const easing = animation.easing;\n  const delay = invokeFunctionType(animation.delay as any, parameters, morphData, morphElements);\n  const duration = invokeFunctionType(animation.duration as any, parameters, morphData, morphElements);\n  const oneByOne = invokeFunctionType(animation.oneByOne as any, parameters, morphData, morphElements);\n  const splitPath = invokeFunctionType(animation.splitPath as any, parameters, morphData, morphElements);\n\n  const individualDelay =\n    isValidNumber(oneByOne) && (oneByOne as number) > 0\n      ? (index: number) => {\n          if (isNumber(oneByOne)) {\n            return index * (oneByOne as number);\n          } else if (oneByOne === true) {\n            return index * duration;\n          }\n          return 0;\n        }\n      : undefined;\n\n  // if no previous item or just one, still execute morph animation\n  if ((prev.length === 1 || prev.length === 0) && next.length === 1) {\n    morphPath(prev[0], next[0], { delay, duration, easing, onEnd });\n  } else if (prev.length === 1 && next.length > 1) {\n    oneToMultiMorph(prev[0], next, { delay, duration, easing, onEnd, individualDelay, splitPath });\n  } else if (prev.length > 1 && next.length === 1) {\n    multiToOneMorph(prev, next[0], { delay, duration, easing, onEnd, individualDelay, splitPath });\n  }\n};\n\n/**\n * Divide elements into specified number of groups\n */\nconst divideElements = (elements: IMarkGraphic[], count: number) => {\n  const divideLength = Math.floor(elements.length / count);\n  return new Array(count).fill(0).map((_, index) => {\n    return elements.slice(divideLength * index, index === count - 1 ? elements.length : divideLength * (index + 1));\n  });\n};\n\n/**\n * Add morphKey to each mark's graphics based on mark's morphConfig\n */\nconst appendMorphKeyToGraphics = (mark: IMark) => {\n  const config = mark.getMarkConfig();\n\n  if (isValid(config.morphElementKey)) {\n    const graphics = mark.getGraphics();\n    graphics.forEach(graphic => {\n      const data = graphic.context?.data?.[0];\n      if (data) {\n        (graphic.context as any).morphKey = data[config.morphElementKey];\n      }\n    });\n  }\n};\n\n/**\n * Execute morphing animation between two sets of marks\n */\nexport const morph = (prevMarks: IMark[], nextMarks: IMark[], morphConfig: IMorphConfig = {}) => {\n  // Get all graphics from previous and next marks\n  const prevGraphics: IMarkGraphic[] = [];\n  const nextGraphics: IMarkGraphic[] = [];\n\n  // Get graphics and append morph keys\n  prevMarks.forEach(mark => {\n    appendMorphKeyToGraphics(mark);\n    prevGraphics.push(...mark.getGraphics());\n  });\n\n  nextMarks.forEach(mark => {\n    appendMorphKeyToGraphics(mark);\n    nextGraphics.push(...mark.getGraphics());\n  });\n\n  // Group graphics by morphKey if available\n  const getKey = (graphic: IMarkGraphic) => (graphic.context as any)?.morphKey ?? graphic.context?.key;\n\n  // Group graphics by their keys\n  const prevByKey = new Map<string, IMarkGraphic[]>();\n  const nextByKey = new Map<string, IMarkGraphic[]>();\n\n  prevGraphics.forEach(graphic => {\n    const key = getKey(graphic);\n    if (key) {\n      if (!prevByKey.has(key)) {\n        prevByKey.set(key, []);\n      }\n      prevByKey.get(key).push(graphic);\n    }\n  });\n\n  nextGraphics.forEach(graphic => {\n    const key = getKey(graphic);\n    if (key) {\n      if (!nextByKey.has(key)) {\n        nextByKey.set(key, []);\n      }\n      nextByKey.get(key).push(graphic);\n    }\n  });\n\n  // TODO 这里逻辑有问题，无法实现一对多和多对一的morphing效果。所以如果无法执行一对一动画的话，直接不走morphing了\n  if (!(prevByKey.size === nextByKey.size && Array.from(prevByKey.keys()).every(k => nextByKey.has(k)))) {\n    return false;\n  }\n\n  // Find matching keys for update animation\n  const updateKeys = [...new Set([...prevByKey.keys()].filter(key => nextByKey.has(key)))];\n\n  // Find enter keys (in next but not in prev)\n  const enterKeys = [...nextByKey.keys()].filter(key => !prevByKey.has(key));\n\n  // Track morph operations to know when all are complete\n  let morphCount = 0;\n  const onMorphEnd = () => {\n    morphCount -= 1;\n    if (morphCount === 0) {\n      // Enable animations for next marks after all morphs complete\n      nextMarks.forEach(mark => {\n        // If mark has any animation states that were disabled, re-enable them\n        // This is placeholder logic - actual implementation depends on animation system\n      });\n    }\n  };\n\n  // Handle enter animations\n  enterKeys.forEach(key => {\n    const nextElements = nextByKey.get(key);\n    doMorph([], nextElements, morphConfig, onMorphEnd, {});\n    morphCount += 1;\n  });\n\n  // Handle update animations\n  updateKeys.forEach(key => {\n    const prevElements = prevByKey.get(key);\n    const nextElements = nextByKey.get(key);\n\n    // Handle different count scenarios\n    const divideCount = Math.min(prevElements.length, nextElements.length);\n    if (divideCount > 0) {\n      const prevDivide = divideElements(prevElements, divideCount);\n      const nextDivide = divideElements(nextElements, divideCount);\n\n      for (let i = 0; i < divideCount; i++) {\n        doMorph(prevDivide[i], nextDivide[i], morphConfig, onMorphEnd, {});\n        morphCount += 1;\n      }\n    }\n  });\n\n  // Handle exit animations if needed (not in original sample but might be needed)\n  // This would be similar to enter but with empty next elements\n\n  // If no morphs were started, call onMorphEnd to ensure animations are re-enabled\n  if (morphCount === 0) {\n    onMorphEnd();\n  }\n  return true;\n};\n"]}