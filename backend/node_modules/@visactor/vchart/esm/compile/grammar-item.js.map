{"version":3,"sources":["../src/compile/grammar-item.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAEnD,OAAO,EAAE,OAAO,EAAE,MAAM,iBAAiB,CAAC;AAG1C,MAAM,OAAgB,WAAY,SAAQ,cAAc;IAAxD;;QAIW,OAAE,GAAW,QAAQ,EAAE,CAAC;QAOvB,uBAAkB,GAAW,IAAI,CAAC;IAiC9C,CAAC;IA7BC,YAAY;;QACV,OAAO,MAAA,IAAI,CAAC,kBAAkB,mCAAI,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC7D,CAAC;IAGD,OAAO,CAAC,MAAiC;QACvC,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;IAC/B,CAAC;IAOD,YAAY,CAAC,SAA2B;QACtC,IAAI,CAAC,UAAU,GAAG,SAAS,CAAC;IAC9B,CAAC;IAED,aAAa,CAAU,UAA4B,EAAE,IAAO;QAC1D,IAAI,CAAC,UAAU,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE;YACrC,OAAO,IAAI,CAAC;SACb;QAED,IAAI,OAAO,GAAG,IAAI,CAAC;QACnB,UAAU,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;;YACzB,OAAO,GAAG,MAAA,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,IAAI,CAAC,0CAAE,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QAC/E,CAAC,CAAC,CAAC;QACH,OAAO,OAAY,CAAC;IACtB,CAAC;CACF","file":"grammar-item.js","sourcesContent":["import type { Maybe } from '../typings';\nimport { createID } from '../util/id';\nimport { CompilableBase } from './compilable-base';\nimport type { GrammarItemCompileOption, IGrammarItem, GrammarItemInitOption, ITransformSpec } from './interface';\nimport { Factory } from '../core/factory';\n\n/** 可以直接编译为一个 VGrammar 语法元素的类的统一基类 */\nexport abstract class GrammarItem extends CompilableBase implements IGrammarItem {\n  protected declare _option: GrammarItemInitOption;\n\n  /** id */\n  readonly id: number = createID();\n\n  protected _product: Maybe<any>;\n  /** 获取编译产物 */\n  abstract getProduct(): Maybe<any>;\n\n  /** 已经编译完成的产物的 name */\n  protected _compiledProductId: string = null;\n  /** 生成产物 name */\n  abstract generateProductId(): string;\n  /** 获取产物 name */\n  getProductId() {\n    return this._compiledProductId ?? this.generateProductId();\n  }\n\n  /** 编译入口（尽量不重写这个方法） */\n  compile(option?: GrammarItemCompileOption): void {\n    this._compileProduct(option);\n  }\n\n  /** 编译主过程 */\n  protected abstract _compileProduct(option?: GrammarItemCompileOption): void;\n  abstract removeProduct(): void;\n\n  protected _transform: ITransformSpec[];\n  setTransform(transform: ITransformSpec[]) {\n    this._transform = transform;\n  }\n\n  runTransforms<T = any>(transforms: ITransformSpec[], data: T): T {\n    if (!transforms || !transforms.length) {\n      return data;\n    }\n\n    let current = data;\n    transforms.forEach(entry => {\n      current = Factory.getGrammarTransform(entry.type)?.transform(entry, current);\n    });\n    return current as T;\n  }\n}\n"]}