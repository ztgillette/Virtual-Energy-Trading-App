import { isArray } from "@visactor/vutils";

import { isNumber, isNil, isString, isFunction, couldBeValidNumber, isObject } from "./type";

export function isValidOrient(orient) {
    switch (orient) {
      case "left":
      case "right":
      case "top":
      case "bottom":
        return !0;

      default:
        return !1;
    }
}

export function isPercent(v) {
    return !!isString(v) && (!!v.endsWith("%") && couldBeValidNumber(v.substring(0, v.length - 1)));
}

export function isPercentOffset(v) {
    return !!isObject(v) && ("percent" in v || "offset" in v);
}

export function calcLayoutNumber(v, size, callOp, defaultValue = 0) {
    var _a, _b;
    return isNumber(v) ? v : isPercent(v) ? Number(v.substring(0, v.length - 1)) * size / 100 : isFunction(v) ? v(callOp) : isObject(v) ? size * (null !== (_a = v.percent) && void 0 !== _a ? _a : 0) + (null !== (_b = v.offset) && void 0 !== _b ? _b : 0) : defaultValue;
}

export function calcPadding(paddingSpec, rect, callOp) {
    var _a, _b, _c, _d;
    const result = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
    };
    if (Object.values(paddingSpec).every((value => isNumber(value)))) return result.top = null !== (_a = paddingSpec.top) && void 0 !== _a ? _a : 0, 
    result.right = null !== (_b = paddingSpec.right) && void 0 !== _b ? _b : 0, result.bottom = null !== (_c = paddingSpec.bottom) && void 0 !== _c ? _c : 0, 
    result.left = null !== (_d = paddingSpec.left) && void 0 !== _d ? _d : 0, result;
    return [ {
        orients: [ "left", "right" ],
        size: rect.width
    }, {
        orients: [ "top", "bottom" ],
        size: rect.height
    } ].forEach((p => {
        p.orients.forEach((o => {
            result[o] = calcLayoutNumber(paddingSpec[o], p.size, callOp);
        }));
    })), result;
}

export function boundsInRect(bounds, rect) {
    return bounds ? {
        width: Math.ceil(Math.min(bounds.x2 - bounds.x1, rect.width)),
        height: Math.ceil(Math.min(bounds.y2 - bounds.y1, rect.height))
    } : {
        width: 0,
        height: 0
    };
}

export function normalizeLayoutPaddingSpec(spec) {
    let result = {};
    return isArray(spec) ? (isNil(spec[0]) || (result.top = result.left = result.bottom = result.right = spec[0]), 
    isNil(spec[1]) || (result.left = result.right = spec[1]), isNil(spec[2]) || (result.bottom = spec[2]), 
    isNil(spec[3]) || (result.left = spec[3]), result) : isNumber(spec) || isPercent(spec) || isFunction(spec) || isPercentOffset(spec) ? (result.top = result.left = result.bottom = result.right = spec, 
    result) : isObject(spec) ? (result = Object.assign({}, spec), result) : result;
}

export function convertPoint(point, relativePoint, convert) {
    return convert ? {
        x: point.x + relativePoint.x,
        y: point.y + relativePoint.y
    } : point;
}

export const getActualNumValue = (originValue, total) => {
    const originNumValue = Number(originValue), originStrValue = originValue.toString();
    return isNaN(originNumValue) && "%" === originStrValue[originStrValue.length - 1] ? total * (Number(originStrValue.slice(0, originStrValue.length - 1)) / 100) : originNumValue;
};
//# sourceMappingURL=space.js.map
