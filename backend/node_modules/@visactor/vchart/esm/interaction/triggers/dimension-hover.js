import { isArray } from "@visactor/vutils";

import { DimensionEventEnum } from "../../event/events/dimension/interface";

import { STATE_VALUE_ENUM } from "../../compile/mark/interface";

import { getDatumOfGraphic } from "../../util";

import { BaseTrigger } from "./base";

import { Factory } from "../../core/factory";

const defaultOptions = {
    state: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER,
    reverseState: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER_REVERSE,
    trigger: DimensionEventEnum.dimensionHover
};

export class DimensionHover extends BaseTrigger {
    constructor(options) {
        super(options), this.type = "dimension-hover", this._resetType = [], this.resetAll = () => {
            const {state: state, reverseState: reverseState, interaction: interaction} = this.options, statedGraphics = interaction.getStatedGraphics(this);
            statedGraphics && statedGraphics.length && (interaction.clearAllStatesOfTrigger(this, state, reverseState), 
            this.dispatchEvent("reset", {
                graphics: statedGraphics,
                options: this.options
            }), interaction.setStatedGraphics(this, []));
        }, this.handleStart = params => {
            const interaction = this.options.interaction;
            switch (params.action) {
              case "enter":
                const newStated = this.getStatedGraphics(params);
                interaction.updateStates(this, this.getStatedGraphics(params), interaction.getStatedGraphics(this), this.options.state, this.options.reverseState), 
                interaction.setStatedGraphics(this, newStated);
                break;

              case "leave":
                interaction.clearAllStatesOfTrigger(this, this.options.state, this.options.reverseState), 
                interaction.setStatedGraphics(this, []);
            }
        }, this.options = Object.assign({}, defaultOptions, options), this.updateMarkIdByState([ this.options.state, this.options.reverseState ]);
    }
    getStartState() {
        return this.options.state;
    }
    getResetState() {
        return this.options.reverseState;
    }
    getEvents() {
        return [ {
            type: this.options.trigger,
            handler: this.handleStart
        } ];
    }
    getStatedGraphics(params, reverse = !1) {
        const marks = this.getMarksByState(reverse ? this.options.reverseState : this.options.state), items = [];
        return params.dimensionInfo.forEach((df => {
            df.data.forEach((dd => {
                marks.filter((m => m.model === dd.series && m.getVisible())).forEach((m => {
                    const graphics = m.getGraphics();
                    if (!graphics || !graphics.length) return;
                    const elements = graphics.filter((g => {
                        const datum = getDatumOfGraphic(g);
                        let c;
                        return c = isArray(datum) ? datum.every(((oneData, i) => oneData === dd.datum[i])) : dd.datum.some((dd_d => dd_d === datum)), 
                        reverse ? !c : c;
                    }));
                    items.push(...elements);
                }));
            }));
        })), items;
    }
}

DimensionHover.type = "dimension-hover", DimensionHover.defaultOptions = defaultOptions;

export const registerDimensionHover = () => {
    Factory.registerInteractionTrigger(DimensionHover.type, DimensionHover);
};
//# sourceMappingURL=dimension-hover.js.map
