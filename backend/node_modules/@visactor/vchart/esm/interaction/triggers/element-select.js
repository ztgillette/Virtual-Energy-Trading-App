import { isArray } from "@visactor/vutils";

import { STATE_VALUE_ENUM } from "../../compile/mark/interface";

import { BaseTrigger } from "./base";

import { parseTriggerOffOfSelect } from "./util";

import { Factory } from "../../core/factory";

const defaultOptions = {
    state: STATE_VALUE_ENUM.STATE_SELECTED,
    trigger: "click"
};

export class ElementSelect extends BaseTrigger {
    constructor(options) {
        super(options), this.type = "element-select", this._resetType = [], this.resetAll = () => {
            const {state: state, reverseState: reverseState, interaction: interaction} = this.options, statedGraphics = interaction.getStatedGraphics(this);
            statedGraphics && statedGraphics.length && (interaction.clearAllStatesOfTrigger(this, state, reverseState), 
            this.dispatchEvent("reset", {
                graphics: statedGraphics,
                options: this.options
            }), interaction.setStatedGraphics(this, []));
        }, this.handleStart = e => {
            this.start(e.item);
        }, this.handleReset = e => {
            const {interaction: interaction} = this.options, statedGraphics = interaction.getStatedGraphics(this);
            if (!statedGraphics || !statedGraphics.length) return;
            const markGraphic = e.item, hasActiveElement = markGraphic && this._markSet.getMarkInId(markGraphic.context.markId);
            (this._resetType.includes("view") && !hasActiveElement || this._resetType.includes("self") && hasActiveElement) && this.resetAll();
        }, this.options = Object.assign({}, defaultOptions, options), this.updateMarkIdByState([ this.options.state, this.options.reverseState ]);
    }
    getStartState() {
        return this.options.state;
    }
    getResetState() {
        return this.options.reverseState;
    }
    getEvents() {
        const triggerOff = this.options.triggerOff, trigger = this.options.trigger, events = [ {
            type: trigger,
            handler: this.handleStart
        } ], {eventNames: eventNames, resetType: resetType} = parseTriggerOffOfSelect(triggerOff);
        return eventNames.forEach((evt => {
            evt && (isArray(trigger) ? !trigger.includes(evt) : evt !== trigger) && events.push({
                type: evt,
                handler: this.handleReset
            });
        })), this._resetType = resetType, events;
    }
    start(markGraphic) {
        const {state: state, reverseState: reverseState, isMultiple: isMultiple, interaction: interaction} = this.options, statedGraphics = interaction.getStatedGraphics(this);
        if (markGraphic && this._markSet.getMarkInId(markGraphic.context.markId)) if (markGraphic.hasState(state)) {
            if (this._resetType.includes("self")) {
                const newStatedGraphics = statedGraphics && statedGraphics.filter((g => g !== markGraphic));
                newStatedGraphics && newStatedGraphics.length ? interaction.setStatedGraphics(this, interaction.updateStates(this, newStatedGraphics, statedGraphics, state, reverseState)) : this.resetAll();
            }
        } else {
            this._timer && clearTimeout(this._timer), markGraphic.addState(state, !0);
            const newStatedGraphics = this.options.interaction.updateStates(this, isMultiple && statedGraphics ? [ ...statedGraphics, markGraphic ] : [ markGraphic ], statedGraphics, state, reverseState);
            interaction.setStatedGraphics(this, newStatedGraphics), this.dispatchEvent("start", {
                graphics: newStatedGraphics,
                options: this.options
            }), this._resetType.includes("timeout") && (this._timer = setTimeout((() => {
                this.resetAll();
            }), this.options.triggerOff));
        } else this._resetType.includes("view") && statedGraphics && statedGraphics.length && this.resetAll();
    }
    reset(markGraphic) {
        markGraphic ? this._markSet.getMarkInId(markGraphic.context.markId) && markGraphic.removeState([ this.options.state, this.options.reverseState ]) : this.resetAll();
    }
}

ElementSelect.type = "element-select", ElementSelect.defaultOptions = defaultOptions;

export const registerElementSelect = () => {
    Factory.registerInteractionTrigger(ElementSelect.type, ElementSelect);
};
//# sourceMappingURL=element-select.js.map
