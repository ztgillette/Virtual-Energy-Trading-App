import { isArray } from "@visactor/vutils";

import { MarkSet } from "../../mark/mark-set";

import { groupMarksByState } from "./util";

export class BaseTrigger {
    constructor(options) {
        this._markSet = new MarkSet, this.options = options, options.marks && options.marks.length && options.marks.forEach((m => {
            this.registerMark(m);
        }));
    }
    getMarks() {
        return this._markSet.getMarks();
    }
    getMarksByState(state) {
        if (this._markIdByState && this._markSet) {
            const markIds = this._markIdByState[state];
            return markIds ? this.getMarks().filter((mark => mark && markIds.includes(mark.id))) : [];
        }
        return [];
    }
    registerMark(mark) {
        isArray(mark) ? mark.forEach((m => {
            this._markSet.addMark(m);
        })) : this._markSet.addMark(mark);
    }
    updateMarkIdByState(states) {
        this._markIdByState = groupMarksByState(this.getMarks(), states);
    }
    getMarkIdByState() {
        var _a;
        return null !== (_a = this._markIdByState) && void 0 !== _a ? _a : {};
    }
    isGraphicInStateMark(g, state) {
        var _a;
        const markIdByState = this.getMarkIdByState();
        return markIdByState && markIdByState[state] && markIdByState[state].includes(null === (_a = g.context) || void 0 === _a ? void 0 : _a.markId);
    }
    isGraphicInMark(g) {
        var _a;
        return !!this._markSet.getMarkInId(null === (_a = g.context) || void 0 === _a ? void 0 : _a.markId);
    }
    getStartState() {
        return null;
    }
    getResetState() {
        return null;
    }
    init() {
        const events = this.getEvents();
        events && this.options.event && events.forEach((evt => {
            evt.type && evt.handler && (isArray(evt.type) ? evt.type.forEach((evtType => {
                evtType && "none" !== evtType && this.options.event.on(evtType, evt.handler);
            })) : "none" !== evt.type && this.options.event.on(evt.type, evt.handler));
        }));
    }
    release() {
        const events = this.getEvents();
        events && this.options.event && (null != events ? events : []).forEach((evt => {
            evt.type && evt.handler && (isArray(evt.type) ? evt.type.forEach((evtType => {
                evtType && "none" !== evtType && this.options.event.on(evtType, evt.handler);
            })) : "none" !== evt.type && this.options.event.off(evt.type, evt.handler));
        }));
    }
    start(g) {}
    reset(g) {}
    dispatchEvent(type, params) {
        this.options.event && (this.options.event.emit(`${this.type}:${type}`, params), 
        "start" === type && this.options.onStart ? this.options.onStart(params) : "reset" === type && this.options.onReset ? this.options.onReset(params) : "update" === type && this.options.onUpdate ? this.options.onUpdate(params) : "end" === type && this.options.onEnd && this.options.onEnd(params));
    }
}
//# sourceMappingURL=base.js.map
