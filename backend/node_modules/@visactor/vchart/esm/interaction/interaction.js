export class Interaction {
    constructor() {
        this._stateGraphicsByTrigger = new Map, this._disableTriggerEvent = !1, this._triggerMapByState = new Map;
    }
    setDisableActiveEffect(disable) {
        this._disableTriggerEvent = disable;
    }
    addTrigger(trigger) {
        if (trigger) {
            [ trigger.getStartState(), trigger.getResetState() ].forEach((state => {
                if (state) {
                    const stateTrigger = this._triggerMapByState.get(state);
                    stateTrigger ? !stateTrigger.includes(trigger) && stateTrigger.push(trigger) : this._triggerMapByState.set(state, [ trigger ]);
                }
            }));
        }
    }
    setStatedGraphics(trigger, graphics) {
        this._stateGraphicsByTrigger.set(trigger, graphics);
    }
    getStatedGraphics(trigger) {
        return this._stateGraphicsByTrigger.get(trigger);
    }
    updateStates(trigger, newStatedGraphics, prevStatedGraphics, state, reverseState) {
        return this._disableTriggerEvent ? [] : newStatedGraphics && newStatedGraphics.length ? (state && reverseState ? prevStatedGraphics && prevStatedGraphics.length ? (this.toggleReverseStateOfGraphics(trigger, newStatedGraphics, prevStatedGraphics, reverseState), 
        this.toggleStateOfGraphics(trigger, newStatedGraphics, prevStatedGraphics, state)) : this.addBothStateOfGraphics(trigger, newStatedGraphics, state, reverseState) : state && (prevStatedGraphics && prevStatedGraphics.length ? this.toggleStateOfGraphics(trigger, newStatedGraphics, prevStatedGraphics, state) : this.addStateOfGraphics(trigger, newStatedGraphics, state)), 
        newStatedGraphics) : [];
    }
    toggleReverseStateOfGraphics(trigger, newStatedGraphics, prevStatedGraphics, reverseState) {
        const markIdByState = trigger.getMarkIdByState();
        prevStatedGraphics.forEach((g => {
            var _a;
            if (reverseState && markIdByState[reverseState] && markIdByState[reverseState].includes(g.context.markId)) {
                const m = null === (_a = g.parent) || void 0 === _a ? void 0 : _a.mark, hasAnimation = m.hasAnimationByState && m.hasAnimationByState("state");
                g.addState(reverseState, !0, hasAnimation);
            }
        })), newStatedGraphics.forEach((g => {
            var _a;
            if (reverseState && markIdByState[reverseState] && markIdByState[reverseState].includes(g.context.markId)) {
                const m = null === (_a = g.parent) || void 0 === _a ? void 0 : _a.mark, hasAnimation = m.hasAnimationByState && m.hasAnimationByState("state");
                g.removeState(reverseState, hasAnimation);
            }
        }));
    }
    toggleStateOfGraphics(trigger, newStatedGraphics, prevStatedGraphics, state) {
        const markIdByState = trigger.getMarkIdByState();
        prevStatedGraphics.forEach((g => {
            var _a;
            if (state && markIdByState[state] && markIdByState[state].includes(g.context.markId)) {
                const m = null === (_a = g.parent) || void 0 === _a ? void 0 : _a.mark, hasAnimation = m.hasAnimationByState && m.hasAnimationByState("state");
                g.removeState(state, hasAnimation);
            }
        })), newStatedGraphics.forEach((g => {
            var _a;
            if (state && markIdByState[state] && markIdByState[state].includes(g.context.markId)) {
                const m = null === (_a = g.parent) || void 0 === _a ? void 0 : _a.mark, hasAnimation = m.hasAnimationByState && m.hasAnimationByState("state");
                g.addState(state, !0, hasAnimation);
            }
        }));
    }
    addBothStateOfGraphics(trigger, statedGraphics, state, reverseState) {
        const marks = trigger.getMarks(), markIdByState = trigger.getMarkIdByState();
        marks.forEach((m => {
            var _a;
            const hasReverse = reverseState && markIdByState[reverseState] && markIdByState[reverseState].includes(m.id), hasState = state && markIdByState[state] && markIdByState[state].includes(m.id);
            if (!hasReverse && !hasState) return;
            const hasAnimation = m.hasAnimationByState && m.hasAnimationByState("state");
            null === (_a = m.getGraphics()) || void 0 === _a || _a.forEach((g => {
                statedGraphics && statedGraphics.includes(g) ? hasState && g.addState(state, !0, hasAnimation) : hasReverse && g.addState(reverseState, !0, hasAnimation);
            }));
        }));
    }
    addStateOfGraphics(trigger, statedGraphics, state) {
        const marks = trigger.getMarks(), markIdByState = trigger.getMarkIdByState();
        marks.forEach((mark => {
            var _a;
            const hasState = state && markIdByState[state] && markIdByState[state].includes(mark.id);
            if (!hasState) return;
            const hasAnimation = mark.hasAnimationByState && mark.hasAnimationByState("state");
            null === (_a = mark.getGraphics()) || void 0 === _a || _a.forEach((g => {
                statedGraphics && statedGraphics.includes(g) && hasState && g.addState(state, !0, hasAnimation);
            }));
        }));
    }
    clearAllStatesOfTrigger(trigger, state, reverseState) {
        if (this._disableTriggerEvent) return;
        const statedGraphics = this.getStatedGraphics(trigger);
        if (!statedGraphics || !statedGraphics.length) return;
        const marks = trigger.getMarks(), markIdByState = trigger.getMarkIdByState();
        marks.forEach((mark => {
            if (mark) {
                const graphics = mark.getGraphics(), hasAnimation = mark.hasAnimationByState && mark.hasAnimationByState("state");
                graphics && graphics.length && (reverseState && markIdByState[reverseState] && markIdByState[reverseState].includes(mark.id) && graphics.forEach((g => {
                    g.removeState(reverseState, hasAnimation);
                })), state && markIdByState[state] && markIdByState[state].includes(mark.id) && graphics.forEach((g => {
                    statedGraphics.includes(g) && g.removeState(state, hasAnimation);
                })));
            }
        }));
    }
    clearAllStates() {
        this._disableTriggerEvent || this._triggerMapByState.forEach(((triggers, state) => {
            triggers.forEach((trigger => {
                this.clearAllStatesOfTrigger(trigger, state, trigger.getResetState());
            }));
        }));
    }
    clearByState(stateValue) {
        if (this._disableTriggerEvent) return;
        const triggers = this._triggerMapByState.get(stateValue);
        triggers && triggers.length && triggers.forEach((t => {
            this.clearAllStatesOfTrigger(t, stateValue, t.getResetState()), this.setStatedGraphics(t, []);
        }));
    }
    updateStateOfGraphics(stateValue, markGraphics) {
        if (this._disableTriggerEvent) return;
        const triggers = this._triggerMapByState.get(stateValue);
        triggers && triggers.length && triggers.forEach((t => {
            const newStatedGraphics = markGraphics.filter((mg => t.getMarks().some((m => {
                const graphics = m && m.getGraphics();
                return graphics && graphics.includes(mg);
            }))));
            this.updateStates(t, newStatedGraphics, this.getStatedGraphics(t), t.getStartState(), t.getResetState()), 
            this.setStatedGraphics(t, newStatedGraphics);
        }));
    }
}
//# sourceMappingURL=interaction.js.map
