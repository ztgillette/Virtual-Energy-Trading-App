{"version":3,"sources":["../src/data/transforms/aggregation.ts"],"names":[],"mappings":"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","file":"aggregation.js","sourcesContent":["import type { DataView } from '@visactor/vdataset';\nimport type { IAggrType, IDataPointSpec, IDataPos, IMarkerSupportSeries } from '../../component/marker/interface';\nimport type { Datum, StringOrNumber } from '../../typings';\nimport { array, isArray, isFunction, isPlainObject, isString, isValid } from '@visactor/vutils';\nimport { variance, average, min, max, sum, standardDeviation, median } from '../../util/math';\nimport { isAggrSpec } from '../../component/marker/utils';\nimport type {\n  IOption,\n  IOptionAggr,\n  IOptionAggrField,\n  IOptionCallback,\n  IOptionPos,\n  IOptionWithCoordinates\n} from './interface';\n\nexport const markerMin = (_data: Array<DataView>, opt: IOption) => {\n  const data = _data[0].latestData as Datum[];\n\n  return min(data, opt.field);\n};\nexport const markerMax = (_data: Array<DataView>, opt: IOption) => {\n  const data = _data[0].latestData as Datum[];\n\n  return max(data, opt.field);\n};\n\nexport function markerSum(_data: Array<DataView>, opt: IOption) {\n  const data = _data[0].latestData;\n\n  return sum(data, opt.field);\n}\nexport function markerAverage(_data: Array<DataView>, opt: IOption) {\n  const data = _data[0].latestData;\n\n  return average(data, opt.field);\n}\n\nexport function markerVariance(_data: Array<DataView>, opt: IOption) {\n  const data = _data[0].latestData;\n\n  return variance(data, opt.field);\n}\n\nexport function markerStandardDeviation(_data: Array<DataView>, opt: IOption) {\n  const data = _data[0].latestData;\n\n  return standardDeviation(data, opt.field);\n}\n\nexport function markerMedian(_data: Array<DataView>, opt: IOption) {\n  const data = _data[0].latestData;\n\n  return median(data, opt.field);\n}\n\nexport function markerAggregation(_data: Array<DataView>, options: IOptionWithCoordinates | IOptionAggr[]) {\n  let markerSource: IOptionAggr[];\n  if ((options as IOptionWithCoordinates).coordinates) {\n    const {\n      coordinates: coordinatesInOptions,\n      coordinateType,\n      getSeriesByIdOrIndex,\n      ...rest\n    } = options as IOptionWithCoordinates;\n    let coordinates;\n    if (isFunction(coordinatesInOptions)) {\n      const relativeSeries = (options as IOptionWithCoordinates).getRelativeSeries();\n      coordinates = coordinatesInOptions(relativeSeries.getData().getLatestData(), relativeSeries);\n    } else {\n      coordinates = coordinatesInOptions;\n    }\n    coordinates = array(coordinates);\n    let option: IOptionAggr;\n\n    markerSource = coordinates.map((coordinate: IDataPointSpec) => {\n      const refRelativeSeries = getSeriesByIdOrIndex(coordinate.refRelativeSeriesId, coordinate.refRelativeSeriesIndex);\n\n      if (coordinateType === 'cartesian') {\n        const { xField, yField } = refRelativeSeries.getSpec();\n        const { xFieldDim, xFieldIndex, yFieldDim, yFieldIndex } = coordinate;\n        let bindXField = xField;\n        if (isValid(xFieldIndex)) {\n          bindXField = array(xField)[xFieldIndex];\n        }\n        if (xFieldDim && array(xField).includes(xFieldDim)) {\n          bindXField = xFieldDim;\n        }\n\n        let bindYField = yField;\n        if (isValid(yFieldIndex)) {\n          bindYField = array(yField)[yFieldIndex];\n        }\n        if (yFieldDim && array(yField).includes(yFieldDim)) {\n          bindYField = yFieldDim;\n        }\n\n        option = {\n          x: undefined,\n          y: undefined,\n          ...rest\n        };\n\n        if (isString(coordinate[bindXField]) && isAggrSpec(coordinate[bindXField] as IDataPos)) {\n          option.x = { field: bindXField, aggrType: coordinate[bindXField] as IAggrType };\n        } else {\n          option.x = array(bindXField).map(field => coordinate[field]) as StringOrNumber[];\n        }\n\n        if (isString(coordinate[bindYField]) && isAggrSpec(coordinate[bindYField] as IDataPos)) {\n          option.y = { field: bindYField, aggrType: coordinate[bindYField] as IAggrType };\n        } else {\n          option.y = array(bindYField).map(field => coordinate[field]) as StringOrNumber[];\n        }\n      } else if (coordinateType === 'polar') {\n        const { valueField: radiusField, categoryField: angleField } = refRelativeSeries.getSpec();\n        const { angleFieldDim, angleFieldIndex } = coordinate;\n        let bindAngleField = angleField;\n        if (isValid(angleFieldIndex)) {\n          bindAngleField = array(angleField)[angleFieldIndex];\n        }\n        if (angleFieldDim && array(angleField).includes(angleFieldDim)) {\n          bindAngleField = angleFieldDim;\n        }\n\n        const bindRadiusField = radiusField;\n\n        option = {\n          angle: undefined,\n          radius: undefined,\n          ...rest\n        };\n\n        if (isString(coordinate[bindAngleField]) && isAggrSpec(coordinate[bindAngleField] as IDataPos)) {\n          option.angle = { field: bindAngleField, aggrType: coordinate[bindAngleField] as IAggrType };\n        } else {\n          option.angle = array(bindAngleField).map(field => coordinate[field]) as StringOrNumber[];\n        }\n\n        if (isString(coordinate[bindRadiusField]) && isAggrSpec(coordinate[bindRadiusField] as IDataPos)) {\n          option.radius = { field: bindRadiusField, aggrType: coordinate[bindRadiusField] as IAggrType };\n        } else {\n          option.radius = array(bindRadiusField).map(field => coordinate[field]) as StringOrNumber[];\n        }\n      }\n\n      option.getRefRelativeSeries = () => refRelativeSeries;\n      return option;\n    });\n  } else {\n    markerSource = options as IOptionAggr[];\n  }\n\n  const results: {\n    x: StringOrNumber[] | StringOrNumber | IOptionCallback | null;\n    y: StringOrNumber[] | StringOrNumber | IOptionCallback | null;\n    angle: StringOrNumber[] | StringOrNumber | IOptionCallback | null;\n    radius: StringOrNumber[] | StringOrNumber | IOptionCallback | null;\n    areaName: string | IOptionCallback | null;\n  }[] = [];\n  markerSource.forEach(option => {\n    const result: {\n      x: StringOrNumber[] | StringOrNumber | null;\n      y: StringOrNumber[] | StringOrNumber | null;\n      angle: StringOrNumber[] | StringOrNumber | null;\n      radius: StringOrNumber[] | StringOrNumber | null;\n      areaName: string | null;\n      getRefRelativeSeries?: () => IMarkerSupportSeries;\n    } = { x: null, y: null, angle: null, radius: null, areaName: null };\n\n    if (isValid(option.x)) {\n      const x = option.x;\n\n      if (isArray(x)) {\n        result.x = x.map(item => getFinalValue(item, _data, option)) as StringOrNumber[];\n      } else {\n        result.x = getFinalValue(x, _data, option) as StringOrNumber;\n      }\n    }\n    if (isValid(option.y)) {\n      const y = option.y;\n      if (isArray(y)) {\n        result.y = y.map(item => getFinalValue(item, _data, option)) as StringOrNumber[];\n      } else {\n        result.y = getFinalValue(y, _data, option) as StringOrNumber;\n      }\n    }\n    if (isValid(option.angle)) {\n      const angle = option.angle;\n      if (isArray(angle)) {\n        result.angle = angle.map(item => getFinalValue(item, _data, option)) as StringOrNumber[];\n      } else {\n        result.angle = getFinalValue(angle, _data, option) as StringOrNumber;\n      }\n    }\n    if (isValid(option.radius)) {\n      const radius = option.radius;\n      if (isArray(radius)) {\n        result.radius = radius.map(item => getFinalValue(item, _data, option)) as StringOrNumber[];\n      } else {\n        result.radius = getFinalValue(radius, _data, option) as StringOrNumber;\n      }\n    }\n    if (isValid(option.areaName)) {\n      const name = option.areaName;\n      result.areaName = getFinalValue(name, _data, option) as string;\n    }\n    if (option.getRefRelativeSeries) {\n      result.getRefRelativeSeries = option.getRefRelativeSeries;\n    }\n    results.push(result);\n  });\n\n  return results;\n}\n\nconst aggrMap = {\n  min: markerMin,\n  max: markerMax,\n  sum: markerSum,\n  average: markerAverage,\n  variance: markerVariance,\n  standardDeviation: markerStandardDeviation,\n  median: markerMedian\n};\n\nfunction getFinalValue(source: IOptionPos | IOptionCallback, _data: Array<DataView>, option: IOptionAggr) {\n  const relativeSeries = option.getRelativeSeries();\n  const startSeries = option.getStartRelativeSeries();\n  const endSeries = option.getEndRelativeSeries();\n  const relativeSeriesData = relativeSeries.getData().getLatestData();\n  const startRelativeSeriesData = startSeries.getData().getLatestData();\n  const endRelativeSeriesData = endSeries.getData().getLatestData();\n\n  if (isFunction(source)) {\n    return source(\n      relativeSeriesData,\n      startRelativeSeriesData,\n      endRelativeSeriesData,\n      relativeSeries,\n      startSeries,\n      endSeries\n    ) as StringOrNumber[] | StringOrNumber;\n  }\n  if (isPlainObject(source)) {\n    const { aggrType, field } = source as IOptionAggrField;\n    return aggrMap[aggrType](_data, { field: field });\n  }\n\n  return source;\n}\n"]}