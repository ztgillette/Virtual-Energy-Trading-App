{"version":3,"sources":["../src/data/transforms/pie.ts"],"names":[],"mappings":"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","file":"pie.js","sourcesContent":["import type { DataView } from '@visactor/vdataset';\nimport type { Datum } from '../../typings';\nimport { couldBeValidNumber } from '../../util/type';\nimport { getPercentValue } from '../../util/math';\nimport { ARC_TRANSFORM_VALUE } from '../../constant/polar';\nimport { computeQuadrant, isNil } from '@visactor/vutils';\n\nexport interface IPieOpt {\n  angleField: () => string;\n  startAngle: () => number;\n  endAngle: () => number;\n  minAngle: () => number;\n\n  asStartAngle: string;\n  asEndAngle: string;\n  asMiddleAngle: string;\n  asRadian: string;\n  asRatio: string;\n  asQuadrant: string;\n  asK: string;\n  showAllZero: boolean;\n  supportNegative: boolean;\n  showEmptyCircle: boolean;\n}\n\nfunction transformInvalidValue(value: any) {\n  if (!couldBeValidNumber(value)) {\n    return 0;\n  }\n  return Number.parseFloat(value);\n}\n\nexport const pie = (originData: Array<DataView>, op: IPieOpt) => {\n  const {\n    asStartAngle,\n    asEndAngle,\n    asMiddleAngle,\n    asRadian,\n    asRatio,\n    asQuadrant,\n    asK,\n    showAllZero,\n    supportNegative,\n    showEmptyCircle\n  } = op;\n\n  const angleField = op.angleField();\n  const startAngle = op.startAngle();\n  const endAngle = op.endAngle();\n  const minAngle = op.minAngle();\n\n  const data = originData.map((datum: Datum) => ({ ...datum }));\n  if (!data || data.length === 0) {\n    return data;\n  }\n\n  if (!showAllZero && showEmptyCircle && isDataEmpty(data, angleField, supportNegative)) {\n    return [];\n  }\n\n  const appendArcInfo = (data: Datum, startAngle: number, angle: number) => {\n    data[asStartAngle] = startAngle;\n    data[asEndAngle] = startAngle + angle;\n    data[asMiddleAngle] = startAngle + angle / 2;\n    data[asRadian] = angle;\n    data[asQuadrant] = computeQuadrant(startAngle + angle / 2);\n  };\n\n  let total = 0;\n  let max = -Infinity;\n  let isAllZero = true;\n  for (let index = 0; index < data.length; index++) {\n    const angleFieldValue = supportNegative\n      ? Math.abs(transformInvalidValue(data[index][angleField]))\n      : transformInvalidValue(data[index][angleField]);\n    total += angleFieldValue;\n    max = Math.max(angleFieldValue, max);\n    if (isAllZero && angleFieldValue !== 0) {\n      isAllZero = false;\n    }\n\n    data[index][ARC_TRANSFORM_VALUE] = angleFieldValue;\n  }\n\n  const valueList = data.map(d => Number(d[angleField]));\n  const angleRange = endAngle - startAngle;\n  let lastAngle = startAngle;\n  let restAngle = angleRange;\n  let largeThanMinAngleTotal = 0;\n  const percents = getPercentValue(valueList);\n\n  data.forEach((d, i) => {\n    const angleFieldValue = d[ARC_TRANSFORM_VALUE];\n    const ratio = total ? angleFieldValue / total : 0;\n    let radian = ratio * angleRange;\n\n    if (radian < minAngle) {\n      radian = minAngle;\n      restAngle -= minAngle;\n    } else {\n      largeThanMinAngleTotal += angleFieldValue;\n    }\n\n    const dStartAngle = lastAngle;\n    const dEndAngle = lastAngle + radian;\n\n    d[asRatio] = ratio;\n    d[asK] = max ? angleFieldValue / max : 0;\n    d._percent_ = (percents as number[])[i];\n    appendArcInfo(d, dStartAngle, radian);\n\n    lastAngle = dEndAngle;\n  });\n\n  if (restAngle < angleRange) {\n    if (restAngle <= 1e-3) {\n      const angle = angleRange / data.length;\n      data.forEach((d, index) => {\n        appendArcInfo(d, startAngle + index * angle, angle);\n      });\n    } else {\n      const unitRadian = restAngle / largeThanMinAngleTotal;\n      lastAngle = startAngle;\n      data.forEach(d => {\n        const angle = d[asRadian] === minAngle ? minAngle : d[ARC_TRANSFORM_VALUE] * unitRadian;\n        appendArcInfo(d, lastAngle, angle);\n\n        lastAngle += angle;\n      });\n    }\n  }\n\n  if (total !== 0) {\n    // 数据都为 0 时，起始角和结束角相同，不应该强制赋值\n    // 防止一个扇区的角度会因为浮点数精度问题和传入的 endAngle 不相等\n    data[data.length - 1][asEndAngle] = endAngle;\n  }\n\n  if (isAllZero && showAllZero) {\n    const angle = angleRange / data.length;\n    data.forEach((d, index) => {\n      appendArcInfo(d, startAngle + index * angle, angle);\n    });\n  }\n  return data;\n};\n\nexport const isDataEmpty = (data: Datum[], angleField: string, supportNegative: boolean) => {\n  if (isNil(data)) {\n    return true;\n  }\n  if (data.length === 0) {\n    return true;\n  }\n  if (data.every(datum => transformInvalidValue(datum[angleField]) === 0)) {\n    return true;\n  }\n  // 未支持负数, 并且和为0, 则也认为是空数据\n  if (!supportNegative && data.reduce((sum, datum) => sum + transformInvalidValue(datum[angleField]), 0) === 0) {\n    return true;\n  }\n\n  return false;\n};\n"]}