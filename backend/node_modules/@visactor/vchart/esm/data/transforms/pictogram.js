import { isValid, merge } from "@visactor/vutils";

import { DEFAULT_DATA_INDEX } from "../../constant/data";

import { measureText } from "../../util";

function isValidStrokeOrFill(attr) {
    var _a;
    return isValid(attr) && "none" !== attr && !(null === (_a = attr.includes) || void 0 === _a ? void 0 : _a.call(attr, "url"));
}

const getLineWidth = attributes => {
    const strokeWidth = parseFloat(attributes.strokeWidth);
    if (!isNaN(strokeWidth)) return strokeWidth;
    const stroke = attributes.stroke;
    return stroke && isValidStrokeOrFill(stroke) ? 1 : 0;
}, getFill = (attributes, defaultFill) => {
    var _a;
    const fill = null !== (_a = attributes.fill) && void 0 !== _a ? _a : defaultFill;
    return fill && isValidStrokeOrFill(fill) ? fill : void 0;
}, getStroke = (attributes, defaultStroke) => {
    var _a;
    const stroke = null !== (_a = attributes.stroke) && void 0 !== _a ? _a : defaultStroke;
    return !(!stroke || !isValidStrokeOrFill(stroke)) && stroke;
}, commonAttributes = attributes => Object.assign(Object.assign({}, attributes), {
    x: parseFloat(attributes.x) || void 0,
    y: parseFloat(attributes.y) || void 0,
    fillStrokeOrder: !1,
    fill: getFill(attributes),
    lineWidth: getLineWidth(attributes),
    stroke: getStroke(attributes)
});

export const graphicAttributeTransform = {
    group: attributes => {
        const common = commonAttributes(attributes);
        return Object.assign(Object.assign({}, common), {
            visibleAll: !1 !== common.visible
        });
    },
    rule: attributes => Object.assign(Object.assign({}, commonAttributes(attributes)), {
        x: parseFloat(attributes.x1),
        y: parseFloat(attributes.y1),
        x1: parseFloat(attributes.x2),
        y1: parseFloat(attributes.y2)
    }),
    rect: attributes => Object.assign(Object.assign({}, commonAttributes(attributes)), {
        fill: getFill(attributes, "#000"),
        width: parseFloat(attributes.width),
        height: parseFloat(attributes.height)
    }),
    polygon: attributes => Object.assign(Object.assign({}, commonAttributes(attributes)), {
        fill: getFill(attributes, "#000"),
        points: attributes.points.trim().split(/\s+/).map((pair => {
            const [x, y] = pair.split(",").map(Number);
            return {
                x: x,
                y: y
            };
        }))
    }),
    line: attributes => Object.assign(Object.assign({}, commonAttributes(attributes)), {
        points: attributes.points.trim().split(/\s+/).map((pair => {
            const [x, y] = pair.split(",").map(Number);
            return {
                x: x,
                y: y
            };
        }))
    }),
    path: attributes => Object.assign(Object.assign({}, commonAttributes(attributes)), {
        path: attributes.d,
        fillStrokeOrder: !1,
        fill: getFill(attributes, "#000")
    }),
    arc: attributes => {
        var _a;
        return Object.assign(Object.assign({}, commonAttributes(attributes)), {
            outerRadius: null !== (_a = attributes.r) && void 0 !== _a ? _a : attributes.ry,
            x: parseFloat(attributes.cx),
            y: parseFloat(attributes.cy),
            startAngle: 0,
            endAngle: 2 * Math.PI,
            scaleX: parseFloat(attributes.rx) / parseFloat(attributes.ry) || 1,
            fill: getFill(attributes, "#000")
        });
    },
    text: (attributes, value) => {
        var _a, _b;
        return Object.assign(Object.assign({}, commonAttributes(attributes)), {
            text: value,
            textAlign: null !== (_a = attributes.textAlign) && void 0 !== _a ? _a : "left",
            textBaseLine: null !== (_b = attributes.textAnchor) && void 0 !== _b ? _b : "middle",
            anchor: [ 0, 0 ],
            fill: getFill(attributes, "#000")
        });
    }
};

export const pictogram = data => {
    var _a, _b;
    if (!data || !data[0]) return {};
    const {elements: elements} = data[0].latestData;
    if (elements && elements.length) {
        elements.forEach(((el, index) => {
            var _a;
            el[DEFAULT_DATA_INDEX] = index, el._uniqueId = `${el.id}-${index}`, el.data = void 0;
            const {graphicType: type, transform: transform} = el, finalAttributes = {
                visible: "hidden" !== el.attributes.visibility && "collapse" !== el.attributes.visibility
            };
            "text" === el.graphicType ? merge(finalAttributes, el._inheritStyle, null === (_a = el.parent) || void 0 === _a ? void 0 : _a._textGroupStyle, el.attributes) : "group" !== el.graphicType && merge(finalAttributes, el._inheritStyle, el.attributes), 
            graphicAttributeTransform[type] ? el._finalAttributes = graphicAttributeTransform[type](finalAttributes, el.value) : el._finalAttributes = finalAttributes, 
            transform && (el._finalAttributes.postMatrix = Object.assign({}, transform));
        }));
        const texts = elements.filter((el => "text" === el.tagName));
        for (let i = 0; i < texts.length; i++) {
            const textId = texts[i]._uniqueId, children = elements.filter((el => {
                let result = !1, parent = el.parent;
                for (;parent; ) {
                    if (parent._uniqueId === textId) {
                        result = !0;
                        break;
                    }
                    parent = parent.parent;
                }
                return result;
            }));
            if (children && children.length) {
                const startX = null !== (_b = null === (_a = texts[i]._textGroupStyle) || void 0 === _a ? void 0 : _a.x) && void 0 !== _b ? _b : 0;
                let curX = startX;
                for (let j = 0; j < children.length; j++) {
                    const currentChild = children[j];
                    if ("group" === currentChild.graphicType) curX = startX; else if (currentChild.value && void 0 === currentChild.parent._textGroupStyle.x) {
                        const lastText = children.slice(0, j).reverse().find((c => "text" === c.graphicType && c.value));
                        if (lastText) {
                            curX += measureText(lastText.value, lastText._finalAttributes).width;
                        }
                        currentChild._finalAttributes.x = curX;
                    }
                }
            }
        }
    }
    return elements;
};
//# sourceMappingURL=pictogram.js.map
