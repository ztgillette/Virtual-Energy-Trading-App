import { isEmpty, isEqual, array, isValid } from "@visactor/vutils";

import { ChartEvent } from "../constant/event";

import { LayoutZIndex } from "../constant/layout";

import { AttributeLevel } from "../constant/attribute";

import { LayoutModel } from "../model/layout-model";

import { RegionSpecTransformer } from "./region-transformer";

export class Region extends LayoutModel {
    getMaxWidth() {
        return this._layout.maxWidth;
    }
    setMaxWidth(value) {
        this._layout.maxWidth = value;
    }
    getMaxHeight() {
        return this._layout.maxHeight;
    }
    setMaxHeight(value) {
        this._layout.maxHeight = value;
    }
    getGroupMark() {
        return this._groupMark;
    }
    getInteractionMark() {
        return this._interactionMark;
    }
    getStackInverse() {
        return !0 === this._spec.stackInverse;
    }
    getStackSort() {
        return !0 === this._spec.stackSort;
    }
    constructor(spec, ctx) {
        var _a;
        super(spec, ctx), this.transformerConstructor = RegionSpecTransformer, this.modelType = "region", 
        this.specKey = "region", this.type = Region.type, this._series = [], this.layoutType = "region", 
        this.layoutZIndex = LayoutZIndex.Region, this.seriesDataFilterOver = () => {
            this.event.emit(ChartEvent.regionSeriesDataFilterOver, {
                model: this,
                chart: this.getChart()
            }), this._series.forEach((s => {
                s.getViewDataFilter() && s.reTransformViewData();
            }));
        }, this.getBoundsInRect = () => ({
            x1: this._layout.getLayoutStartPoint().x,
            y1: this._layout.getLayoutStartPoint().y,
            x2: this._layout.getLayoutStartPoint().x + this._layout.getLayoutRect().width,
            y2: this._layout.getLayoutStartPoint().y + this._layout.getLayoutRect().height
        }), this.userId = spec.id, this.coordinate = null !== (_a = spec.coordinate) && void 0 !== _a ? _a : "cartesian";
    }
    _getClipDefaultValue() {
        var _a, _b, _c, _d;
        const chartSpec = this._option.getChart().getSpec(), hasDataZoom = null === (_b = null === (_a = chartSpec.dataZoom) || void 0 === _a ? void 0 : _a.some) || void 0 === _b ? void 0 : _b.call(_a, (entry => {
            var _a;
            return "axis" === (null !== (_a = entry.filterMode) && void 0 !== _a ? _a : "filter");
        })), hasScrollBar = null === (_d = null === (_c = chartSpec.scrollBar) || void 0 === _c ? void 0 : _c.some) || void 0 === _d ? void 0 : _d.call(_c, (entry => {
            var _a;
            return "axis" === (null !== (_a = entry.filterMode) && void 0 !== _a ? _a : "axis");
        }));
        return !(!hasDataZoom && !hasScrollBar) || this._layout.layoutClip;
    }
    created() {
        var _a, _b;
        this.initLayout(), super.created();
        const clip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this._getClipDefaultValue();
        this._groupMark = this._createGroupMark("regionGroup", this.userId, this.layoutZIndex), 
        this._spec.roam && this._groupMark.setMarkConfig({
            interactive: !0
        }), this._interactionMark = this._createGroupMark("regionInteractionGroup", (null !== (_b = this.userId) && void 0 !== _b ? _b : this.type) + "_interaction", LayoutZIndex.Interaction), 
        isEmpty(this._spec.style) || (this._backgroundMark = this._createMark({
            type: "rect",
            name: "regionBackground"
        }, {
            parent: this._groupMark
        }), clip && (this._foregroundMark = this._createMark({
            type: "rect",
            name: "regionForeground"
        }, {
            parent: this._groupMark
        })), [ this._backgroundMark, this._foregroundMark ].forEach((mark => {
            mark && (mark.created(), this.setMarkStyle(mark, {
                width: () => this.getLayoutRect().width,
                height: () => this.getLayoutRect().height
            }, "normal", AttributeLevel.Built_In), this._groupMark.addMark(mark));
        })), this._backgroundMark && this._backgroundMark.setMarkConfig({
            zIndex: LayoutZIndex.SeriesGroup - 1
        }), this._foregroundMark && this._foregroundMark.setMarkConfig({
            zIndex: LayoutZIndex.Mark + 1
        }));
    }
    _createGroupMark(name, userId, zIndex) {
        var _a, _b;
        const groupMark = this._createMark({
            type: "group",
            name: name
        });
        groupMark.setUserId(userId), groupMark.setMarkConfig({
            zIndex: zIndex
        });
        const clip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this._getClipDefaultValue();
        return this.setMarkStyle(groupMark, {
            x: () => this.getLayoutStartPoint().x,
            y: () => this.getLayoutStartPoint().y,
            width: () => this.getLayoutRect().width,
            height: () => this.getLayoutRect().height,
            clip: clip
        }, "normal", AttributeLevel.Built_In), this.setMarkStyle(groupMark, {
            cornerRadius: null === (_b = this._spec.style) || void 0 === _b ? void 0 : _b.cornerRadius
        }, "normal", AttributeLevel.User_Mark), this._marks.addMark(groupMark), groupMark;
    }
    init(option) {
        super.init(option), this.initMark(), this.initSeriesDataflow();
    }
    initMark() {
        this._initBackgroundMarkStyle(), this._initForegroundMarkStyle();
    }
    _initBackgroundMarkStyle() {
        var _a, _b;
        this._backgroundMark && (this.setMarkStyle(this._backgroundMark, Object.assign({
            fillOpacity: (null === (_a = this._spec.style) || void 0 === _a ? void 0 : _a.fill) ? 1 : 0
        }, this._spec.style), "normal", AttributeLevel.User_Mark), (null !== (_b = this._spec.clip) && void 0 !== _b ? _b : this._getClipDefaultValue()) && this.setMarkStyle(this._backgroundMark, {
            strokeOpacity: 0
        }, "normal", AttributeLevel.Built_In));
    }
    _initForegroundMarkStyle() {
        this._foregroundMark && this.setMarkStyle(this._foregroundMark, Object.assign(Object.assign({}, this._spec.style), {
            fillOpacity: 0,
            pickable: !1
        }), "normal", AttributeLevel.User_Mark);
    }
    _compareSpec(spec, prevSpec) {
        const result = super._compareSpec(spec, prevSpec);
        return isEqual(null == prevSpec ? void 0 : prevSpec.style, null == spec ? void 0 : spec.style) || (result.reMake = !0), 
        result;
    }
    reInit(spec) {
        super.reInit(spec), this._initBackgroundMarkStyle(), this._initForegroundMarkStyle();
    }
    addSeries(s) {
        s && (this._series.includes(s) || this._series.push(s));
    }
    removeSeries(s) {
        if (!s) return;
        const index = this._series.findIndex((s_ => s_ === s));
        index >= 0 && this._series.splice(index, 1);
    }
    getSeries(opt = {}) {
        return this._series.filter((s => {
            var _a, _b;
            return (!opt.name || (null == s ? void 0 : s.name) === opt.name) && (!opt.userId || array(opt.userId).includes(s.userId)) && (!isValid(opt.specIndex) || array(opt.specIndex).includes(s.getSpecIndex())) && (!opt.id || s.id === opt.id) && (!opt.type || s.type === opt.type) && (!opt.coordinateType || s.coordinate === opt.coordinateType) && (!opt.dataName || (null === (_b = null === (_a = s.getRawData) || void 0 === _a ? void 0 : _a.call(s)) || void 0 === _b ? void 0 : _b.name) === opt.dataName);
        }));
    }
    getSeriesInName(name) {
        return this.getSeries({
            name: name
        })[0];
    }
    getSeriesInUserId(userId) {
        return this.getSeries({
            userId: userId
        })[0];
    }
    getSeriesInId(id) {
        return this.getSeries({
            id: id
        })[0];
    }
    getSeriesInType(type) {
        return this.getSeries({
            type: type
        });
    }
    getSeriesInCoordinateType(coordinateType) {
        return this.getSeries({
            coordinateType: coordinateType
        });
    }
    getSeriesInDataName(dataName) {
        return this.getSeries({
            dataName: dataName
        });
    }
    initSeriesDataflow() {
        const viewDataFilters = this._series.map((s => {
            var _a;
            return null !== (_a = s.getViewDataFilter()) && void 0 !== _a ? _a : s.getViewData();
        })).filter((v => !!v));
        this._option.dataSet.multipleDataViewAddListener(viewDataFilters, "change", this.seriesDataFilterOver);
    }
    release() {
        super.release(), this._series = [];
    }
    compileMarks(group) {
        this.getMarks().forEach((m => {
            m.compile({
                group: group,
                context: {
                    model: this
                }
            });
        }));
    }
    compile() {
        this.compileMarks();
    }
    onLayoutEnd() {
        this._series.forEach((s => s.onLayoutEnd())), super.onLayoutEnd();
    }
}

Region.type = "region", Region.transformerConstructor = RegionSpecTransformer, Region.specKey = "region";
//# sourceMappingURL=region.js.map
