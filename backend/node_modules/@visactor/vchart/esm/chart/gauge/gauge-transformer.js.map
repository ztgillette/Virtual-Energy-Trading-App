{"version":3,"sources":["../src/chart/gauge/gauge-transformer.ts"],"names":[],"mappings":"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","file":"gauge-transformer.js","sourcesContent":["import { isNil } from '@visactor/vutils';\nimport type { ICircularProgressSeriesSpec, IGaugeSeriesSpec } from '../../series';\nimport { SeriesTypeEnum } from '../../series/interface';\nimport type { AdaptiveSpec, ISeriesSpec } from '../../typings';\nimport { ProgressLikeChartSpecTransformer } from '../polar';\nimport type { IGaugeChartSpec } from './interface';\nimport { LayoutZIndex } from '../../constant/layout';\nimport type { IPolarAxisSpec, IPolarLinearAxisSpec } from '../../component';\n\nexport class GaugeChartSpecTransformer<\n  T extends IGaugeChartSpec = IGaugeChartSpec\n> extends ProgressLikeChartSpecTransformer<AdaptiveSpec<T, 'axes'>> {\n  protected _getDefaultSeriesSpec(spec: T): any {\n    const series = super._getDefaultSeriesSpec(spec);\n\n    series.radiusField = spec.radiusField;\n    series.pin = spec.pin;\n    series.pinBackground = spec.pinBackground;\n    series.pointer = spec.pointer;\n    return series;\n  }\n\n  protected _getDefaultCircularProgressSeriesSpec(spec: T): any {\n    const series: any = super._getDefaultSeriesSpec(spec);\n    series.type = SeriesTypeEnum.circularProgress;\n    return series;\n  }\n\n  transformSpec(spec: AdaptiveSpec<T, 'axes'>): void {\n    super.transformSpec(spec);\n\n    /** 充当仪表图非指针部分的系列 */\n    let backgroundSeries = spec.series?.find(\n      (series: ISeriesSpec) => series.type === SeriesTypeEnum.gauge || series.type === SeriesTypeEnum.circularProgress\n    ) as ICircularProgressSeriesSpec | IGaugeSeriesSpec;\n    if (isNil(backgroundSeries)) {\n      backgroundSeries = spec.gauge ?? this._getDefaultCircularProgressSeriesSpec(spec as any);\n\n      // 补充可能缺失的属性\n      if (backgroundSeries.type === 'circularProgress') {\n        if (isNil(backgroundSeries.radiusField) && isNil(backgroundSeries.categoryField)) {\n          backgroundSeries.radiusField = spec.radiusField ?? (spec.categoryField as string) ?? spec.seriesField;\n        }\n        if (isNil(backgroundSeries.valueField) && isNil(backgroundSeries.angleField)) {\n          backgroundSeries.valueField = spec.valueField ?? spec.angleField;\n        }\n      }\n\n      if (spec.series.length === 1) {\n        spec.series.push(backgroundSeries);\n      } else {\n        spec.series.forEach((s: ISeriesSpec) => {\n          if (s.type !== backgroundSeries.type) {\n            return;\n          }\n          Object.keys(backgroundSeries).forEach(k => {\n            if (!(k in s)) {\n              s[k] = backgroundSeries[k];\n            }\n          });\n        });\n      }\n    }\n\n    if (backgroundSeries.type === SeriesTypeEnum.circularProgress) {\n      this._transformProgressAxisSpec(\n        spec,\n        {\n          orient: 'angle',\n          visible: true,\n          domainLine: {\n            visible: false\n          },\n          grid: {\n            visible: false\n          }\n        },\n        {\n          orient: 'radius',\n          visible: false\n        },\n        {\n          zIndex: LayoutZIndex.Region + 50 // 仪表图特例：轴在 region 上层\n        }\n      );\n    } else {\n      this._transformGaugeAxisSpec(spec);\n    }\n  }\n\n  protected _transformGaugeAxisSpec(spec: AdaptiveSpec<T, 'axes'>): void {\n    if (!spec.axes) {\n      spec.axes = [];\n    }\n    const axesPtr: {\n      radius: IPolarLinearAxisSpec | null;\n      angle: IPolarLinearAxisSpec | null;\n    } = { radius: null, angle: null };\n    (spec.axes ?? []).forEach((axis: IPolarAxisSpec) => {\n      const { orient } = axis;\n      if (orient === 'radius') {\n        axesPtr.radius = axis;\n      }\n      if (orient === 'angle') {\n        axesPtr.angle = axis;\n      }\n    });\n    if (!axesPtr.angle) {\n      axesPtr.angle = {\n        orient: 'angle',\n        visible: true\n      };\n      spec.axes.push(axesPtr.angle);\n    }\n    if (!axesPtr.radius) {\n      axesPtr.radius = {\n        orient: 'radius',\n        visible: false\n      };\n      spec.axes.push(axesPtr.radius);\n    }\n\n    // 自动补充缺失的配置\n    if (isNil(axesPtr.angle.type)) {\n      axesPtr.angle.type = 'linear';\n    }\n    if (isNil(axesPtr.radius.type)) {\n      axesPtr.radius.type = 'linear';\n    }\n    if (isNil(axesPtr.angle.zIndex)) {\n      axesPtr.angle.zIndex = LayoutZIndex.Region + 50; // 仪表图特例：轴在 region 上层\n    }\n  }\n}\n"]}