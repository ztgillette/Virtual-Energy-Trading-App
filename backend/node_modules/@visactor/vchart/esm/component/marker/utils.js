var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import { isValid, isNumber, array, minInArray, maxInArray, isArray, normalizePadding, isFunction } from "@visactor/vutils";

import { isPercent, transformToGraphic } from "../../util";

import { AGGR_TYPE } from "../../constant/marker";

import { isContinuous } from "@visactor/vscale";

function isNeedExtendDomain(domain, datum, autoRange) {
    if (!autoRange) return !1;
    const domainNum = domain.map((n => 1 * n)), min = minInArray(domainNum), max = maxInArray(domainNum);
    return datum < min || datum > max;
}

function getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint) {
    var _a, _b;
    const {relativeSeries: relativeSeries} = refSeries;
    let x;
    return isNumber(datum.x) && isNeedExtendDomain(xDomain, datum.x, autoRange) && (null === (_b = null == relativeSeries ? void 0 : (_a = relativeSeries.getXAxisHelper()).setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", datum.x)), 
    x = isPercent(datum.x) ? convertPercentToValue(datum.x, regionWidth) + regionStartLayoutStartPoint.x : convertDatumToValue(relativeSeries.getXAxisHelper(), [ datum.x ]) + regionStartLayoutStartPoint.x, 
    x;
}

function getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint) {
    var _a, _b;
    const {relativeSeries: relativeSeries} = refSeries;
    let y;
    return isNumber(datum.y) && isNeedExtendDomain(yDomain, datum.y, autoRange) && (null === (_b = null === (_a = relativeSeries.getYAxisHelper()) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_yAxis_extend", datum.y)), 
    y = isPercent(datum.y) ? convertPercentToValue(datum.y, regionHeight) + regionStartLayoutStartPoint.y : convertDatumToValue(relativeSeries.getYAxisHelper(), [ datum.y ]) + regionStartLayoutStartPoint.y, 
    y;
}

function getAngleValue(datum, angleDomain, autoRange, refSeries) {
    var _a, _b;
    const {relativeSeries: relativeSeries} = refSeries;
    return isNumber(datum.angle) && isNeedExtendDomain(angleDomain, datum.angle, autoRange) && (null === (_b = null === (_a = relativeSeries.angleAxisHelper) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_angleAxis_extend", datum.angle)), 
    convertDatumToValue(relativeSeries.angleAxisHelper, [ datum.angle ]);
}

function getRadiusValue(datum, radiusDomain, autoRange, refSeries) {
    var _a, _b;
    const {relativeSeries: relativeSeries} = refSeries;
    return isNumber(datum.radius) && isNeedExtendDomain(radiusDomain, datum.radius, autoRange) && (null === (_b = null === (_a = relativeSeries.radiusAxisHelper) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_radiusAxis_extend", datum.radius)), 
    convertDatumToValue(relativeSeries.radiusAxisHelper, [ datum.radius ]);
}

function convertPercentToValue(percent, relativeLength) {
    return Number(percent.substring(0, percent.length - 1)) * relativeLength / 100;
}

function convertDatumToValue(axisHelper, datum) {
    const scale = axisHelper.getScale(0);
    return isContinuous(scale.type) && scale.domain()[0] === scale.domain()[1] && datum[0] !== scale.domain()[0] ? NaN : axisHelper.dataToPosition(datum);
}

export function isAggrSpec(spec) {
    return AGGR_TYPE.includes(spec);
}

export function xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange) {
    const regionStart = startRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), regionEnd = endRelativeSeries.getRegion(), regionEndLayoutStartPoint = regionEnd.getLayoutStartPoint(), regionWidth = Math.abs(Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x) - Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width)), regionHeight = Math.abs(Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y) - Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height)), refSeries = {
        relativeSeries: relativeSeries,
        startRelativeSeries: startRelativeSeries,
        endRelativeSeries: endRelativeSeries
    }, lines = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, xDomain = relativeSeries.getXAxisHelper().getScale(0).domain(), yDomain = relativeSeries.getYAxisHelper().getScale(0).domain();
    return dataPoints.forEach((datum => {
        const isValidX = isValid(datum.x), isValidY = isValid(datum.y);
        if (isValidX && isValidY) {
            const x = getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint), y = getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint);
            lines.push([ {
                x: x,
                y: y
            } ]);
        } else if (isValidX) {
            const x = getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint), y = Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height), y1 = Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y);
            lines.push([ {
                x: x,
                y: y
            }, {
                x: x,
                y: y1
            } ]);
        } else if (isValidY) {
            const x = Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x), y = getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint), x1 = Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width);
            lines.push([ {
                x: x,
                y: y
            }, {
                x: x1,
                y: y
            } ]);
        }
    })), lines;
}

export function polarLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange) {
    const refSeries = {
        relativeSeries: relativeSeries,
        startRelativeSeries: startRelativeSeries,
        endRelativeSeries: endRelativeSeries
    }, lines = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, angleDomain = relativeSeries.angleAxisHelper.getScale(0).domain(), radiusDomain = relativeSeries.radiusAxisHelper.getScale(0).domain(), regionRadius = Math.min(relativeSeries.getRegion().getLayoutRect().width / 2, relativeSeries.getRegion().getLayoutRect().height / 2);
    return dataPoints.forEach((datum => {
        const isValidAngle = isValid(datum.angle), isValidRadius = isValid(datum.radius);
        if (isValidAngle && isValidRadius) {
            const angle = getAngleValue(datum, angleDomain, autoRange, refSeries), radius = getRadiusValue(datum, radiusDomain, autoRange, refSeries);
            lines.push([ {
                angle: angle,
                radius: radius
            } ]);
        } else if (isValidAngle) {
            const angle = getAngleValue(datum, angleDomain, autoRange, refSeries);
            lines.push([ {
                angle: angle,
                radius: -regionRadius
            }, {
                angle: angle,
                radius: regionRadius
            } ]);
        } else if (isValidRadius) {
            const radius = getRadiusValue(datum, radiusDomain, autoRange, refSeries);
            lines.push([ {
                radius: radius,
                angle: 0
            }, {
                radius: radius,
                angle: 2 * Math.PI
            } ]);
        }
    })), lines;
}

export function geoLayout(data, relativeSeries) {
    const lines = [];
    return (data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData).forEach((datum => {
        isValid(datum.areaName) && lines.push([ {
            x: relativeSeries.nameValueToPosition(datum.areaName).x + relativeSeries.getRegion().getLayoutStartPoint().x,
            y: relativeSeries.nameValueToPosition(datum.areaName).y + relativeSeries.getRegion().getLayoutStartPoint().y
        } ]);
    })), lines;
}

export function cartesianCoordinateLayout(data, relativeSeries, autoRange, coordinatesOffset) {
    const points = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, isArrayCoordinatesOffset = isArray(coordinatesOffset);
    return dataPoints.forEach(((datum, index) => {
        var _a, _b, _c, _d;
        const refRelativeSeries = (null == datum ? void 0 : datum.getRefRelativeSeries) ? datum.getRefRelativeSeries() : relativeSeries, regionStart = refRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), {width: regionWidth, height: regionHeight} = regionStart.getLayoutRect();
        let offsetX = 0, offsetY = 0;
        if (coordinatesOffset) {
            const currentCoordinatesOffset = isArrayCoordinatesOffset ? coordinatesOffset[index] : coordinatesOffset, x = currentCoordinatesOffset.x, y = currentCoordinatesOffset.y;
            x && (offsetX = isPercent(x) ? Number(x.substring(0, x.length - 1)) * regionWidth / 100 : x), 
            y && (offsetY = isPercent(y) ? Number(y.substring(0, y.length - 1)) * regionHeight / 100 : y);
        }
        const xDomain = refRelativeSeries.getXAxisHelper().getScale(0).domain(), yDomain = refRelativeSeries.getYAxisHelper().getScale(0).domain(), xValue = array(datum.x), yValue = array(datum.y);
        1 === xValue.length && isNumber(xValue[0]) && isNeedExtendDomain(xDomain, xValue[0], autoRange) && (null === (_b = null === (_a = refRelativeSeries.getXAxisHelper()) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", xValue[0])), 
        1 === yValue.length && isNumber(yValue[0]) && isNeedExtendDomain(yDomain, yValue[0], autoRange) && (null === (_d = null === (_c = refRelativeSeries.getYAxisHelper()) || void 0 === _c ? void 0 : _c.setExtendDomain) || void 0 === _d || _d.call(_c, "marker_yAxis_extend", yValue[0])), 
        points.push({
            x: convertDatumToValue(refRelativeSeries.getXAxisHelper(), xValue) + regionStartLayoutStartPoint.x + offsetX,
            y: convertDatumToValue(refRelativeSeries.getYAxisHelper(), yValue) + regionStartLayoutStartPoint.y + offsetY
        });
    })), points;
}

export function polarCoordinateLayout(data, relativeSeries, autoRange) {
    const points = [];
    return (data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData).forEach((datum => {
        var _a, _b, _c, _d;
        const refRelativeSeries = (null == datum ? void 0 : datum.getRefRelativeSeries) ? datum.getRefRelativeSeries() : relativeSeries, angleDomain = refRelativeSeries.angleAxisHelper.getScale(0).domain(), radiusDomain = refRelativeSeries.radiusAxisHelper.getScale(0).domain(), angleValue = array(datum.angle), radiusValue = array(datum.radius);
        1 === angleValue.length && isNumber(angleValue[0]) && isNeedExtendDomain(angleDomain, angleValue[0], autoRange) && (null === (_b = null === (_a = refRelativeSeries.angleAxisHelper) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", angleValue[0])), 
        1 === radiusValue.length && isNumber(radiusValue[0]) && isNeedExtendDomain(radiusDomain, radiusValue[0], autoRange) && (null === (_d = null === (_c = refRelativeSeries.radiusAxisHelper) || void 0 === _c ? void 0 : _c.setExtendDomain) || void 0 === _d || _d.call(_c, "marker_yAxis_extend", radiusValue[0])), 
        points.push({
            angle: convertDatumToValue(refRelativeSeries.angleAxisHelper, angleValue),
            radius: convertDatumToValue(refRelativeSeries.radiusAxisHelper, radiusValue)
        });
    })), points;
}

function convertPosition(position, relativeWidth, relativeHeight) {
    let {x: x, y: y} = position;
    return isPercent(x) && (x = convertPercentToValue(x, relativeWidth)), isPercent(y) && (y = convertPercentToValue(y, relativeHeight)), 
    {
        x: x,
        y: y
    };
}

export function positionLayout(positions, series, regionRelative) {
    let transformPositions;
    if (transformPositions = isFunction(positions) ? array(positions(series.getData().getLatestData(), series)) : array(positions), 
    regionRelative) {
        const region = series.getRegion(), {x: regionStartX, y: regionStartY} = region.getLayoutStartPoint(), {width: regionWidth, height: regionHeight} = region.getLayoutRect();
        return transformPositions.map((position => {
            let {x: x, y: y} = convertPosition(position, regionWidth, regionHeight);
            return x += regionStartX, y += regionStartY, {
                x: x,
                y: y
            };
        }));
    }
    const {width: canvasWidth, height: canvasHeight} = series.getOption().getChart().getViewRect();
    return transformPositions.map((position => convertPosition(position, canvasWidth, canvasHeight)));
}

export function computeClipRange(regions) {
    let minX = 1 / 0, maxX = -1 / 0, minY = 1 / 0, maxY = -1 / 0;
    return regions.forEach((region => {
        const regionPos = region.getLayoutStartPoint(), regionRect = region.getLayoutRect();
        regionPos.x < minX && (minX = regionPos.x), regionPos.x + regionRect.width > maxX && (maxX = regionPos.x + regionRect.width), 
        regionPos.y < minY && (minY = regionPos.y), regionPos.y + regionRect.height > maxY && (maxY = regionPos.y + regionRect.height);
    })), {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY
    };
}

export function transformLabelAttributes(label, markerData, markAttributeContext) {
    const {labelBackground: labelBackground = {}, style: style, shape: shape} = label, restLabel = __rest(label, [ "labelBackground", "style", "shape" ]);
    if (!1 !== label.visible) {
        const labelAttrs = restLabel;
        return (null == shape ? void 0 : shape.visible) ? labelAttrs.shape = Object.assign({
            visible: !0
        }, transformToGraphic(shape.style)) : labelAttrs.shape = {
            visible: !1
        }, !1 !== labelBackground.visible ? (labelAttrs.panel = Object.assign({
            visible: !0,
            customShape: labelBackground.customShape
        }, transformStyle(transformToGraphic(labelBackground.style), markerData, markAttributeContext)), 
        isValid(labelBackground.padding) && (labelAttrs.padding = normalizePadding(labelBackground.padding))) : (labelAttrs.panel = {
            visible: !1
        }, labelAttrs.padding = 0), style && (labelAttrs.textStyle = transformStyle(transformToGraphic(style), markerData, markAttributeContext)), 
        labelAttrs;
    }
    return {
        visible: !1
    };
}

export function transformState(state, markerData, markerAttributeContext) {
    for (const stateKey in state) isFunction(state[stateKey]) && (state[stateKey] = state[stateKey](markerData, markerAttributeContext));
    return state;
}

export function transformStyle(style, markerData, markerAttributeContext) {
    return isFunction(style) ? style(markerData, markerAttributeContext) : style;
}

export function transformOffset(offset, region) {
    return isFunction(offset) ? offset(region) : offset;
}

export function computeOffsetFromRegion(point, offset, region) {
    return isValid(point) ? "regionLeft" === offset ? region.getLayoutStartPoint().x - point.x : "regionRight" === offset ? region.getLayoutStartPoint().x + region.getLayoutRect().width - point.x : "regionTop" === offset ? region.getLayoutStartPoint().y - point.y : "regionBottom" === offset ? region.getLayoutStartPoint().y + region.getLayoutRect().height - point.y : offset : offset;
}

export function getProcessInfo(spec) {
    return {
        isXProcess: isValid(spec.x),
        isYProcess: isValid(spec.y),
        isX1Process: isValid(spec.x1),
        isY1Process: isValid(spec.y1),
        isAngleProcess: isValid(spec.angle),
        isRadiusProcess: isValid(spec.radius),
        isAngle1Process: isValid(spec.angle1),
        isRadius1Process: isValid(spec.radius1),
        isCoordinatesProcess: isValid(spec.coordinates),
        isValidProcess: isValid(spec.process)
    };
}

export function getMarkLineProcessInfo(spec) {
    const {isXProcess: isXProcess, isYProcess: isYProcess, isX1Process: isX1Process, isY1Process: isY1Process, isAngleProcess: isAngleProcess, isRadiusProcess: isRadiusProcess, isAngle1Process: isAngle1Process, isRadius1Process: isRadius1Process, isCoordinatesProcess: isCoordinatesProcess, isValidProcess: isValidProcess} = getProcessInfo(spec);
    return {
        doXProcess: isXProcess && !isYProcess && !isY1Process,
        doXYY1Process: isXProcess && isYProcess && isY1Process,
        doYProcess: isYProcess && !isXProcess && !isX1Process,
        doYXX1Process: isYProcess && isXProcess && isX1Process,
        doXYProcess: isXProcess && isYProcess && isX1Process && isY1Process,
        doAngleProcess: isAngleProcess && !isAngle1Process && !isRadiusProcess && !isRadius1Process,
        doRadiusProcess: isRadiusProcess && !isRadius1Process && !isAngleProcess && !isAngle1Process,
        doAngRadRad1Process: isAngleProcess && !isAngle1Process && isRadiusProcess && isRadius1Process,
        doRadAngAng1Process: isRadiusProcess && isAngleProcess && isAngle1Process && !isRadius1Process,
        doRadAngProcess: isAngleProcess && isRadiusProcess && isAngle1Process && isRadius1Process,
        doCoordinatesProcess: isCoordinatesProcess && (!isValidProcess || "process" in spec && "xy" in spec.process)
    };
}

export function getMarkAreaProcessInfo(spec) {
    const {isXProcess: isXProcess, isYProcess: isYProcess, isX1Process: isX1Process, isY1Process: isY1Process, isAngleProcess: isAngleProcess, isRadiusProcess: isRadiusProcess, isAngle1Process: isAngle1Process, isRadius1Process: isRadius1Process, isCoordinatesProcess: isCoordinatesProcess} = getProcessInfo(spec);
    return {
        doXProcess: isXProcess && isX1Process && !isYProcess && !isY1Process,
        doYProcess: isYProcess && isY1Process && !isXProcess && !isX1Process,
        doXYProcess: isXProcess && isX1Process && isYProcess && isY1Process,
        doAngleProcess: isAngleProcess && isAngle1Process && !isRadiusProcess && !isRadius1Process,
        doRadiusProcess: isRadiusProcess && isRadius1Process && !isAngleProcess && !isAngle1Process,
        doRadAngProcess: isAngleProcess && isRadiusProcess && isAngle1Process && isRadius1Process,
        doCoordinatesProcess: isCoordinatesProcess
    };
}

export function getMarkPointProcessInfo(spec) {
    return {
        doXYProcess: isValid(spec.x) && isValid(spec.y),
        doPolarProcess: isValid(spec.angle) && isValid(spec.radius),
        doGeoProcess: isValid(spec.areaName)
    };
}
//# sourceMappingURL=utils.js.map
