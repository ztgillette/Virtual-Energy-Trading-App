var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import { computeClipRange, computeOffsetFromRegion, getMarkPointProcessInfo, transformLabelAttributes, transformOffset, transformState, transformStyle } from "../utils";

import { MarkPoint as MarkPointComponent } from "@visactor/vrender-components";

import { isValid, merge } from "@visactor/vutils";

import { transformToGraphic } from "../../../util/style";

import { BaseMarker } from "../base-marker";

import { LayoutZIndex } from "../../../constant/layout";

export class BaseMarkPoint extends BaseMarker {
    constructor() {
        super(...arguments), this.specKey = "markPoint", this.layoutZIndex = LayoutZIndex.MarkPoint;
    }
    static _getMarkerCoordinateType(markerSpec) {
        const {doPolarProcess: doPolarProcess, doGeoProcess: doGeoProcess} = getMarkPointProcessInfo(markerSpec);
        return "polar" === markerSpec.coordinateType || doPolarProcess ? "polar" : "geo" === markerSpec.coordinateType || doGeoProcess ? "geo" : "cartesian";
    }
    _createMarkerComponent() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7;
        const {itemContent: itemContent = {}, itemLine: itemLine = {}, targetSymbol: targetSymbol = {}} = this._spec, _8 = itemContent, {type: type = "text", text: label, symbol: symbol, image: image, richText: richText, customMark: customMark, textStyle: textStyle, symbolStyle: symbolStyle, imageStyle: imageStyle, richTextStyle: richTextStyle, customMarkStyle: customMarkStyle, style: style = {}, state: state = {}} = _8, restItemContent = __rest(_8, [ "type", "text", "symbol", "image", "richText", "customMark", "textStyle", "symbolStyle", "imageStyle", "richTextStyle", "customMarkStyle", "style", "state" ]);
        let itemContentState = null, itemContentStyle = null, defaultStyle = {};
        "text" === type ? (itemContentState = null !== (_a = null == label ? void 0 : label.state) && void 0 !== _a ? _a : state, 
        defaultStyle = {
            dx: 0,
            dy: 0
        }, itemContentStyle = transformLabelAttributes(merge(defaultStyle, null !== (_b = null != label ? label : textStyle) && void 0 !== _b ? _b : style), this._markerData, this._markAttributeContext)) : "richText" === type ? (itemContentState = null !== (_c = null == richText ? void 0 : richText.state) && void 0 !== _c ? _c : state, 
        defaultStyle = {
            width: 100,
            height: 100
        }, itemContentStyle = transformStyle(merge(defaultStyle, null !== (_e = null !== (_d = null == richText ? void 0 : richText.style) && void 0 !== _d ? _d : richTextStyle) && void 0 !== _e ? _e : style), this._markerData, this._markAttributeContext)) : "symbol" === type ? (itemContentState = null !== (_f = null == symbol ? void 0 : symbol.state) && void 0 !== _f ? _f : state, 
        defaultStyle = {
            symbolType: "star",
            fill: "rgb(48, 115, 242)",
            fillOpacity: .8,
            size: 20
        }, itemContentStyle = transformToGraphic(transformStyle(merge(defaultStyle, null !== (_h = null !== (_g = null == symbol ? void 0 : symbol.style) && void 0 !== _g ? _g : symbolStyle) && void 0 !== _h ? _h : style), this._markerData, this._markAttributeContext))) : "image" === type ? (itemContentState = null !== (_j = null == image ? void 0 : image.state) && void 0 !== _j ? _j : state, 
        defaultStyle = {
            width: 80,
            height: 80
        }, itemContentStyle = transformStyle(merge(defaultStyle, null !== (_l = null !== (_k = null == image ? void 0 : image.style) && void 0 !== _k ? _k : imageStyle) && void 0 !== _l ? _l : style), this._markerData, this._markAttributeContext)) : "custom" === type && (itemContentState = null !== (_m = null == customMark ? void 0 : customMark.state) && void 0 !== _m ? _m : state, 
        itemContentStyle = transformStyle(null !== (_p = null !== (_o = null == customMark ? void 0 : customMark.style) && void 0 !== _o ? _o : customMarkStyle) && void 0 !== _p ? _p : style, this._markerData, this._markAttributeContext));
        const markPointAttrs = {
            zIndex: this.layoutZIndex,
            interactive: null === (_q = this._spec.interactive) || void 0 === _q || _q,
            hover: null === (_r = this._spec.interactive) || void 0 === _r || _r,
            select: null === (_s = this._spec.interactive) || void 0 === _s || _s,
            position: {
                x: 0,
                y: 0
            },
            clipInRange: null !== (_t = this._spec.clip) && void 0 !== _t && _t,
            itemContent: Object.assign(Object.assign({
                type: type,
                offsetX: transformOffset(itemContent.offsetX, this._relativeSeries.getRegion()),
                offsetY: transformOffset(itemContent.offsetX, this._relativeSeries.getRegion())
            }, restItemContent), {
                style: transformStyle(itemContentStyle, this._markerData, this._markAttributeContext)
            }),
            targetSymbol: {
                offset: null !== (_u = targetSymbol.offset) && void 0 !== _u ? _u : 0,
                visible: null !== (_v = targetSymbol.visible) && void 0 !== _v && _v,
                size: null !== (_w = targetSymbol.size) && void 0 !== _w ? _w : 20,
                style: transformStyle(targetSymbol.style, this._markerData, this._markAttributeContext)
            },
            state: {
                line: transformState(null !== (_y = null === (_x = this._spec.itemLine.line) || void 0 === _x ? void 0 : _x.state) && void 0 !== _y ? _y : {}, this._markerData, this._markAttributeContext),
                lineStartSymbol: transformState(null !== (_0 = null === (_z = this._spec.itemLine.startSymbol) || void 0 === _z ? void 0 : _z.state) && void 0 !== _0 ? _0 : {}, this._markerData, this._markAttributeContext),
                lineEndSymbol: transformState(null !== (_2 = null === (_1 = this._spec.itemLine.endSymbol) || void 0 === _1 ? void 0 : _1.state) && void 0 !== _2 ? _2 : {}, this._markerData, this._markAttributeContext),
                itemContent: transformState(itemContentState, this._markerData, this._markAttributeContext),
                textBackground: transformState(null === (_4 = null === (_3 = this._spec.itemContent.text) || void 0 === _3 ? void 0 : _3.labelBackground) || void 0 === _4 ? void 0 : _4.state, this._markerData, this._markAttributeContext),
                targetItem: transformState(null !== (_6 = null === (_5 = this._spec.targetSymbol) || void 0 === _5 ? void 0 : _5.state) && void 0 !== _6 ? _6 : {}, this._markerData, this._markAttributeContext)
            },
            animation: null !== (_7 = this._spec.animation) && void 0 !== _7 && _7,
            animationEnter: this._spec.animationEnter,
            animationExit: this._spec.animationExit,
            animationUpdate: this._spec.animationUpdate
        }, {visible: visible, line: line = {}} = itemLine, restItemLine = __rest(itemLine, [ "visible", "line" ]);
        markPointAttrs.itemLine = !1 !== visible ? Object.assign(Object.assign({}, restItemLine), {
            visible: !0,
            lineStyle: transformToGraphic(line.style)
        }) : {
            visible: !1
        };
        return new MarkPointComponent(markPointAttrs);
    }
    _markerLayout() {
        var _a, _b, _c, _d, _e;
        const spec = this._spec, data = this._markerData, relativeSeries = this._relativeSeries, {point: point} = this._computePointsAttr(), seriesData = this._getRelativeDataView().latestData, dataPoints = data ? data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData : seriesData;
        let limitRect;
        if (spec.clip || (null === (_a = spec.itemContent) || void 0 === _a ? void 0 : _a.confine)) {
            const {minX: minX, maxX: maxX, minY: minY, maxY: maxY} = computeClipRange([ relativeSeries.getRegion() ]);
            limitRect = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
        if (this._markerComponent) {
            const attribute = null !== (_b = this._markerComponent.attribute) && void 0 !== _b ? _b : {}, textStyle = null !== (_d = null === (_c = attribute.itemContent) || void 0 === _c ? void 0 : _c.textStyle) && void 0 !== _d ? _d : {};
            this._markerComponent.setAttributes({
                position: void 0 === point ? {
                    x: null,
                    y: null
                } : point,
                itemContent: Object.assign(Object.assign({}, attribute.itemContent), {
                    textStyle: Object.assign(Object.assign({}, textStyle), {
                        text: (null === (_e = this._spec.itemContent.text) || void 0 === _e ? void 0 : _e.formatMethod) ? this._spec.itemContent.text.formatMethod(dataPoints, seriesData) : textStyle.text
                    }),
                    offsetX: computeOffsetFromRegion(point, attribute.itemContent.offsetX, this._relativeSeries.getRegion()),
                    offsetY: computeOffsetFromRegion(point, attribute.itemContent.offsetY, this._relativeSeries.getRegion())
                }),
                limitRect: limitRect,
                dx: this._layoutOffsetX,
                dy: this._layoutOffsetY
            });
        }
    }
    _initDataView() {
        const spec = this._spec, {doXYProcess: doXYProcess, doPolarProcess: doPolarProcess, doGeoProcess: doGeoProcess} = getMarkPointProcessInfo(spec);
        (isValid(spec.coordinate) || doXYProcess || doPolarProcess || doGeoProcess) && this._initCommonDataView();
    }
}

BaseMarkPoint.specKey = "markPoint";
//# sourceMappingURL=base-mark-point.js.map
