import { BaseComponent } from "../base/base-component";

import { ComponentTypeEnum } from "../interface/type";

import { LayoutZIndex } from "../../constant/layout";

import { array, isEqual, isNil, isPlainObject } from "@visactor/vutils";

import { DiffState } from "../../mark/interface/enum";

import { getActualColor } from "../../core";

export class BaseLabelComponent extends BaseComponent {
    constructor(spec, options) {
        super(spec, options), this.type = ComponentTypeEnum.label, this.name = ComponentTypeEnum.label, 
        this.layoutType = "none", this.layoutZIndex = LayoutZIndex.Label, this._regions = options.getRegionsInIndex(options.regionIndexes);
    }
    _interactiveConfig(labelSpec) {
        const {interactive: interactive} = labelSpec, result = {
            hover: !1,
            select: !1,
            state: labelSpec.state
        };
        if (!0 !== interactive) return result;
        const {hover: hover, select: select} = this._option.getChart().getSpec();
        return !1 === hover && !1 === hover.enable || (result.hover = !0), !1 === select && !1 === select.enable || (result.select = !0), 
        result;
    }
    _compareSpec(spec, prevSpec) {
        const result = super._compareSpec(spec, prevSpec);
        return result.reRender = !0, isEqual(prevSpec, spec) || (result.reMake = !0), result;
    }
    _getDataLabelType(baseMark, type) {
        const markType = baseMark.type;
        return "line" === markType || "area" === markType ? null != type ? type : "line-data" : "rect" === markType ? "rect" : "arc" === markType ? "arc" : "symbol" === markType || "cell" === markType ? "symbol" : baseMark.setDataLabelType ? baseMark.setDataLabelType() : "";
    }
    _setTransformOfComponent(labelComponent, baseMark) {
        labelComponent.setAttributeTransform((({labelStyle: labelStyle, size: size, itemEncoder: itemEncoder}) => {
            const regionSize = size(), defaultFill = getActualColor({
                type: "palette",
                key: "secondaryFontColor"
            }, this.getColorScheme());
            return {
                dataLabels: array(baseMark).map(((mark, labelIndex) => {
                    const labelStyleRes = labelStyle(labelIndex), labelData = [], graphics = mark.getGraphics();
                    if (graphics) return labelStyleRes.data && labelStyleRes.data.length ? labelStyleRes.data.forEach(((d, index) => {
                        if (graphics[index]) {
                            const formattedDatum = itemEncoder(d, {
                                labelIndex: labelIndex
                            });
                            isNil(formattedDatum.fill) && (formattedDatum.fill = defaultFill), isNil(formattedDatum.data) && (formattedDatum.data = d), 
                            labelData.push(formattedDatum);
                        }
                    })) : graphics.forEach((g => {
                        const {data: data, diffState: diffState} = g.context;
                        diffState !== DiffState.exit && data.forEach(((datum, {}) => {
                            const formattedDatum = itemEncoder(datum, {
                                labelIndex: labelIndex
                            });
                            isNil(formattedDatum.fill) && (formattedDatum.fill = defaultFill), isNil(formattedDatum.data) && (formattedDatum.data = datum), 
                            labelData.push(formattedDatum);
                        }));
                    })), isPlainObject(labelStyleRes.overlap) && isNil(labelStyleRes.overlap.size) && (labelStyleRes.overlap.size = Object.assign({}, regionSize)), 
                    Object.assign(Object.assign({
                        smartInvert: !1,
                        baseMarkGroupName: mark.getProductId(),
                        getBaseMarks: () => graphics
                    }, labelStyleRes), {
                        type: this._getDataLabelType(mark, labelStyleRes.type),
                        data: labelData
                    });
                })),
                size: regionSize
            };
        }));
    }
    getVRenderComponents() {
        const labels = [];
        return this.getMarks().forEach((m => {
            const graphicItem = m.getComponent();
            graphicItem && labels.push(graphicItem);
        })), labels;
    }
    clear() {
        super.clear(), this.getMarks().forEach((m => {
            m && m.clearComponent();
        }));
    }
}

BaseLabelComponent.type = ComponentTypeEnum.label;
//# sourceMappingURL=base-label.js.map
