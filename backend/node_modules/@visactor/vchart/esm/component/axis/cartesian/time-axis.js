import { DataView } from "@visactor/vdataset";

import { isXAxis } from "./util/common";

import { isValid, TimeUtil } from "@visactor/vutils";

import { eachSeries } from "../../../util/model";

import { CartesianLinearAxis } from "./linear-axis";

import { ComponentTypeEnum } from "../../interface/type";

import { CompilableData } from "../../../compile/data/compilable-data";

import { Factory } from "../../../core/factory";

import { registerAxis } from "../base-axis";

import { getAxisItem, shouldUpdateAxis } from "../util";

import { mergeSpec } from "@visactor/vutils-extension";

import { continuousTicks, LineAxis, LineAxisGrid } from "@visactor/vrender-components";

import { registerDataSetInstanceTransform } from "../../../data/register";

import { AxisEnum, GridEnum } from "../interface/common";

import { commonAxis } from "../../../theme/builtin/common/component/axis/common-axis";

import { axisX, axisY } from "../../../theme/builtin/common/component/axis/cartesian-axis";

export class CartesianTimeAxis extends CartesianLinearAxis {
    constructor() {
        super(...arguments), this.type = ComponentTypeEnum.cartesianTimeAxis, this._zero = !1, 
        this.effect = {
            scaleUpdate: params => {
                this.computeData(null == params ? void 0 : params.value), eachSeries(this._regions, (s => {
                    isXAxis(this.getOrient()) ? shouldUpdateAxis(s.getXAxisHelper(), this.axisHelper(), isValid(this._seriesUserId) || isValid(this._seriesIndex)) && s.setXAxisHelper(this.axisHelper()) : shouldUpdateAxis(s.getYAxisHelper(), this.axisHelper(), isValid(this._seriesUserId) || isValid(this._seriesIndex)) && s.setYAxisHelper(this.axisHelper());
                }), {
                    userId: this._seriesUserId,
                    specIndex: this._seriesIndex
                });
            }
        };
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec(), this._tick = mergeSpec({}, this._spec.tick, null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[0]);
    }
    _initData() {
        var _a;
        if (super._initData(), null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[1]) {
            const layerTickData = new DataView(this._option.dataSet, {
                name: `${this.type}_${this.id}_layer_1_ticks`
            }).parse(this._scale, {
                type: "scale"
            }).transform({
                type: `${this.type}-ticks`,
                options: Object.assign(Object.assign({}, this._tickTransformOption()), {
                    tickCount: this._spec.layers[1].tickCount,
                    forceTickCount: this._spec.layers[1].forceTickCount,
                    tickStep: this._spec.layers[1].tickStep
                })
            }, !1);
            this._layerTickData = new CompilableData(this._option, layerTickData);
        }
    }
    computeData(updateType) {
        super.computeData(updateType), this._layerTickData && (this._layerTickData.getDataView().reRunAllTransform(), 
        this._layerTickData.updateData());
    }
    created() {
        super.created(), this._layerTickData && (this._axisMark && this._layerTickData.addRelatedMark(this._axisMark), 
        this._gridMark && this._layerTickData.addRelatedMark(this._gridMark));
    }
    _getLabelFormatMethod() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const timeUtil = TimeUtil.getInstance(), timeFormat1 = (null === (_b = null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[1]) || void 0 === _b ? void 0 : _b.timeFormat) || "%Y%m%d", timeFormatter1 = "local" === ((null === (_d = null === (_c = this._spec.layers) || void 0 === _c ? void 0 : _c[1]) || void 0 === _d ? void 0 : _d.timeFormatMode) || "local") ? timeUtil.timeFormat : timeUtil.timeUTCFormat, timeFormat0 = (null === (_f = null === (_e = this._spec.layers) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f.timeFormat) || "%Y%m%d", timeFormatter0 = "local" === ((null === (_h = null === (_g = this._spec.layers) || void 0 === _g ? void 0 : _g[0]) || void 0 === _h ? void 0 : _h.timeFormatMode) || "local") ? timeUtil.timeFormat : timeUtil.timeUTCFormat;
        return (value, datum, index, data, layer) => {
            var _a;
            let timeValue;
            return timeValue = 0 === layer ? timeFormatter0(timeFormat0, value) : timeFormatter1(timeFormat1, value), 
            (null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.formatMethod) ? this._spec.label.formatMethod(timeValue, datum) : timeValue;
        };
    }
    getLabelItems(length) {
        var _a, _b;
        const items = [], tickLatestData = null === (_a = this.getTickData()) || void 0 === _a ? void 0 : _a.getLatestData();
        tickLatestData && tickLatestData.length && items.push(tickLatestData.map((obj => getAxisItem(obj.value, this._getNormalizedValue([ obj.value ], length)))));
        const layerLatestData = null === (_b = this._layerTickData) || void 0 === _b ? void 0 : _b.getLatestData();
        return layerLatestData && layerLatestData.length && items.push(layerLatestData.map((obj => getAxisItem(obj.value, this._getNormalizedValue([ obj.value ], length))))), 
        items;
    }
    registerTicksTransform() {
        const name = `${this.type}-ticks`;
        return registerDataSetInstanceTransform(this._option.dataSet, name, continuousTicks), 
        name;
    }
    transformScaleDomain() {}
}

CartesianTimeAxis.type = ComponentTypeEnum.cartesianTimeAxis, CartesianTimeAxis.specKey = "axes", 
CartesianTimeAxis.builtInTheme = {
    axis: commonAxis,
    axisX: axisX,
    axisY: axisY
};

export const registerCartesianTimeAxis = () => {
    Factory.registerGraphicComponent(AxisEnum.lineAxis, ((attrs, options) => new LineAxis(attrs, options))), 
    Factory.registerGraphicComponent(GridEnum.lineAxisGrid, ((attrs, options) => new LineAxisGrid(attrs, options))), 
    registerAxis(), Factory.registerComponent(CartesianTimeAxis.type, CartesianTimeAxis);
};
//# sourceMappingURL=time-axis.js.map
