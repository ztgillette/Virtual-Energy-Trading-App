import { isValidScaleType } from "@visactor/vscale";

import { isFunction, isNil } from "@visactor/vutils";

import { BaseMark } from "./base-mark";

import { DiffState } from "../interface";

import { isSegmentAttrEqual } from "../utils/line";

import { DEFAULT_DATA_KEY } from "../../constant/data";

export const LINE_SEGMENT_ATTRIBUTES = [ "stroke", "strokeOpacity", "lineDash", "lineDashOffset", "lineCap", "lineJoin", "lineWidth", "miterLimit" ];

export class BaseLineMark extends BaseMark {
    constructor() {
        super(...arguments), this._segmentStyleKeys = [], this._isValidPointChannel = channel => [ "x", "y", "defined" ].includes(channel);
    }
    _getSegmentAttributes() {
        return LINE_SEGMENT_ATTRIBUTES;
    }
    initStyleWithSpec(spec) {
        this._segmentStyleKeys = [], super.initStyleWithSpec(spec);
    }
    setStyle(style, state = "normal", level = 0) {
        if (isNil(style)) return;
        void 0 === this.stateStyle[state] && (this.stateStyle[state] = {});
        const ignoreAttributes = this._getIgnoreAttributes(), segmentAttributes = this._getSegmentAttributes(), isUserLevel = this.isUserLevel(level);
        Object.keys(style).forEach((attr => {
            const attrStyle = style[attr];
            if (isNil(attrStyle) || ignoreAttributes.includes(attr)) return;
            isUserLevel && segmentAttributes.includes(attr) && (isValidScaleType(null == attrStyle ? void 0 : attrStyle.type) || (null == attrStyle ? void 0 : attrStyle.scale) || isFunction(attrStyle)) && (this._segmentStyleKeys.includes(attr) || this._segmentStyleKeys.push(attr));
            const styleConverter = this._filterAttribute(attr, attrStyle, state, level, isUserLevel);
            this.setAttribute(attr, styleConverter, state, level);
        }));
    }
    _getLineSegments(items, points) {
        if (!this._segmentStyleKeys || !this._segmentStyleKeys.length) return null;
        const segments = [];
        let prevSegmentAttrs = null;
        return items.forEach(((item, index) => {
            prevSegmentAttrs && this._segmentStyleKeys.every((key => isSegmentAttrEqual(prevSegmentAttrs[key], item[key], key))) || (segments.length && (segments[segments.length - 1].endIndex = index), 
            prevSegmentAttrs = item, segments.push({
                attrs: prevSegmentAttrs,
                startIndex: index
            }));
        })), segments.length >= 2 ? segments.map((entry => Object.assign(Object.assign({}, entry.attrs), {
            points: points.slice(entry.startIndex, isNil(entry.endIndex) ? points.length : entry.endIndex)
        }))) : null;
    }
    _getPrevPoints(g) {
        const {points: points, segments: segments} = g.attribute;
        return null != points ? points : segments ? segments.reduce(((res, seg) => (seg.points && seg.points.forEach((point => {
            res.push(point);
        })), res)), []) : null;
    }
    _runPointsEncoder(newStyles, g, attrs = {}) {
        var _a, _b, _c;
        const data = g.context.data, lineAttrs = [], points = [], commonAttrs = {}, progressive = null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive, isFirstFrame = progressive && 0 === progressive.currentIndex;
        if (data.forEach(((datum, index) => {
            var _a;
            points[index] = {}, lineAttrs[index] = {}, Object.keys(newStyles).forEach((attrName => {
                this._isValidPointChannel(attrName) ? points[index][attrName] = newStyles[attrName](datum) : this._segmentStyleKeys.includes(attrName) && !progressive ? lineAttrs[index][attrName] = newStyles[attrName](datum) : 0 !== index || progressive && !isFirstFrame || (commonAttrs[attrName] = newStyles[attrName](datum));
            })), points[index].context = null !== (_a = this._keyGetter(datum)) && void 0 !== _a ? _a : index;
        })), progressive) {
            const segments = null !== (_c = null === (_b = g.attribute) || void 0 === _b ? void 0 : _b.segments) && void 0 !== _c ? _c : [];
            return segments.push({
                points: points
            }), isFirstFrame ? Object.assign(Object.assign({}, commonAttrs), {
                segments: segments
            }) : {
                segments: segments
            };
        }
        if (this._segmentStyleKeys && this._segmentStyleKeys.length) {
            const segments = this._getLineSegments(lineAttrs, points);
            if (segments) return Object.assign(Object.assign(Object.assign({}, commonAttrs), lineAttrs[0]), {
                segments: segments,
                points: null
            });
        }
        return Object.assign(Object.assign(Object.assign({}, commonAttrs), lineAttrs[0]), {
            points: points,
            segments: null
        });
    }
    _runEncoderOfGraphic(newStyles, g, attrs = {}) {
        const data = g.context.data;
        return newStyles && Object.keys(newStyles).some(this._isValidPointChannel) && data && data.length ? this._runPointsEncoder(newStyles, g, attrs) : super._runEncoderOfGraphic(newStyles, g, attrs);
    }
    _getDataByKey(data) {
        return this._dataByGroup;
    }
    _runProgressiveJoin() {
        const currentIndex = this.renderContext.progressive.currentIndex, graphics = [];
        this._dataByGroup.keys.forEach(((groupKey, index) => {
            const data = this.renderContext.progressive.groupedData.get(groupKey), groupStep = this.renderContext.progressive.step, dataSlice = data.slice(currentIndex * groupStep, (currentIndex + 1) * groupStep);
            if (0 === currentIndex) {
                const g = {
                    context: Object.assign(Object.assign({}, this._getCommonContext()), {
                        diffState: DiffState.enter,
                        data: dataSlice,
                        uniqueKey: groupKey,
                        key: groupKey,
                        groupKey: groupKey
                    })
                };
                graphics.push(g);
            } else {
                this._graphics[index].context.data = dataSlice;
            }
        }));
        const res = 0 === currentIndex ? graphics : this._graphics;
        return {
            graphicsByGroup: {
                [DEFAULT_DATA_KEY]: res
            },
            graphics: res,
            needUpdate: !1
        };
    }
    _setCommonAttributesToTheme(g) {}
    _addProgressiveGraphic(parent, g) {
        g.incremental = 1, parent.appendChild(g);
    }
}
//# sourceMappingURL=base-line.js.map
