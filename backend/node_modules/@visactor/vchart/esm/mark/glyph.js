import { BaseMark } from "./base/base-mark";

import { createGlyph } from "@visactor/vrender-core";

import { Factory } from "../core/factory";

import { registerGlyph, registerShadowRoot } from "@visactor/vrender-kits";

import { DiffState } from "./interface/enum";

import { merge } from "@visactor/vutils";

export class GlyphMark extends BaseMark {
    constructor() {
        super(...arguments), this._setStateOfGraphic = g => {
            g.clearStates(), g.stateProxy = null, g.context.diffState !== DiffState.enter && g.context.diffState !== DiffState.update || (g.glyphStateProxy = (stateName, nexStates) => {
                var _a;
                const glyphAttrs = {
                    attributes: Object.assign(Object.assign({}, this._runEncoderOfGraphic(null === (_a = this._encoderOfState) || void 0 === _a ? void 0 : _a[stateName], g)), g.runtimeStateCache ? g.runtimeStateCache[stateName] : null)
                };
                return g.glyphStates ? g.glyphStates[stateName] || (g.glyphStates[stateName] = glyphAttrs) : g.glyphStates = {
                    [stateName]: glyphAttrs
                }, glyphAttrs;
            }, g.useStates(g.context.states));
        };
    }
    getSubMarks() {
        return this._subMarks;
    }
    setGlyphConfig(cfg) {
        this._glyphConfig = cfg;
    }
    getGlyphConfig() {
        return this._glyphConfig;
    }
    getPositionChannels() {
        return this._positionChannels;
    }
    _onGlyphAttributeUpdate(glyph) {
        return newAttributes => {
            var _a, _b;
            const positionChannels = this.getPositionChannels();
            let subAttrsMap = positionChannels && this._positionEncoder && Object.keys(newAttributes).some((k => positionChannels.includes(k))) ? this._positionEncoder(newAttributes, null === (_b = null === (_a = null == glyph ? void 0 : glyph.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], glyph) : null;
            return this._channelEncoder && Object.keys(this._channelEncoder).forEach((channel => {
                if (channel in newAttributes) {
                    const channelAttrsMap = this._channelEncoder[channel](newAttributes[channel]);
                    subAttrsMap = subAttrsMap ? merge(subAttrsMap, channelAttrsMap) : channelAttrsMap;
                }
            })), subAttrsMap && glyph.getSubGraphic().forEach((subGraphic => {
                subGraphic && subAttrsMap[subGraphic.name] && subGraphic.setAttributes(subAttrsMap[subGraphic.name]);
            })), newAttributes;
        };
    }
    _createGraphic(attrs = {}) {
        const glyph = createGlyph(attrs);
        glyph.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(glyph);
        const subMarks = this._subMarks;
        if (subMarks) {
            const subGraphics = [];
            Object.keys(subMarks).forEach((name => {
                const subGraphic = Factory.createGraphicComponent(subMarks[name].type, Object.assign({}, subMarks[name].defaultAttributes));
                subGraphic && (subGraphics.push(subGraphic), subGraphic.name = name, subGraphic.onBeforeAttributeUpdate = attrs => attrs);
            })), glyph.setSubGraphic(subGraphics);
        }
        return glyph.onBeforeAttributeUpdate(attrs), glyph;
    }
    _runProgressiveEncoder(graphics) {
        this._runEncoder(graphics);
    }
}

export const registerGlyphMark = () => {
    Factory.registerGraphicComponent("glyph", createGlyph), registerShadowRoot(), registerGlyph();
};
//# sourceMappingURL=glyph.js.map
