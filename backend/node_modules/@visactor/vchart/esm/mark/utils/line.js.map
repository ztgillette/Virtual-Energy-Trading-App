{"version":3,"sources":["../src/mark/utils/line.ts"],"names":[],"mappings":"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","file":"line.js","sourcesContent":["import { isNil, isString, isArray } from '@visactor/vutils';\nimport type { IColor, IColorStop } from '@visactor/vrender-core';\n\nexport const isStopsEqual = (prev: IColorStop[], next: IColorStop[]) => {\n  if (prev === next) {\n    return true;\n  }\n  const prevLength = (prev && prev.length) ?? 0;\n  const nextLength = (next && next.length) ?? 0;\n\n  if (prevLength !== nextLength || prevLength === 0) {\n    return false;\n  }\n\n  return prev.every((prevEntry, prevIndex) => {\n    return (\n      (!prevEntry && !next[prevIndex]) ||\n      (prevEntry &&\n        next[prevIndex] &&\n        prevEntry.color === next[prevIndex].color &&\n        prevEntry.offset === next[prevIndex].offset)\n    );\n  });\n};\n\nconst isColorAttrEqual = (prev: IColor, next: IColor): boolean => {\n  if (prev === next) {\n    return true;\n  }\n\n  if (typeof prev !== typeof next) {\n    return false;\n  }\n\n  if (isString(prev)) {\n    return false;\n  }\n\n  if (isArray(prev)) {\n    if ((prev as any).length !== (next as any).length) {\n      return false;\n    }\n\n    return (prev as any).every((prevEntry: any, index: number) => isColorAttrEqual(prevEntry, (next as any)[index]));\n  }\n\n  if ((prev as any).gradient !== (next as any).gradient) {\n    return false;\n  }\n\n  const prevKeys = Object.keys(prev);\n  const nextKeys = Object.keys(next);\n\n  if (prevKeys.length !== nextKeys.length) {\n    return false;\n  }\n\n  return prevKeys.every(key => {\n    if (key === 'stops') {\n      return isStopsEqual((prev as any)[key], (next as any)[key]);\n    }\n\n    return (prev as any)[key] === (next as any)[key];\n  });\n};\n\nconst isLineDashEqual = (prev: number[], next: number[]) => {\n  if (prev.length !== next.length) {\n    return false;\n  }\n\n  if (prev.join('-') === next.join('-')) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const isSegmentAttrEqual = (prev: any, next: any, key: string) => {\n  if (isNil(prev) && isNil(next)) {\n    return true;\n  }\n\n  if (isNil(prev)) {\n    return false;\n  }\n\n  if (isNil(next)) {\n    return false;\n  }\n\n  if (key === 'lineDash') {\n    return isLineDashEqual(prev, next);\n  }\n\n  if (key === 'stroke' || key === 'fill') {\n    return isColorAttrEqual(prev, next);\n  }\n\n  return prev === next;\n};\n"]}