var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

import { Factory } from "./../core/factory";

import { BaseMark } from "./base/base-mark";

import { registerLine, registerShadowRoot } from "@visactor/vrender-kits";

import { createLine } from "@visactor/vrender-core";

export class RuleMark extends BaseMark {
    constructor() {
        super(...arguments), this.type = RuleMark.type;
    }
    _getDefaultStyle() {
        return Object.assign(Object.assign({}, super._getDefaultStyle()), {
            x1: 0,
            y1: 0
        });
    }
    _transformGraphicAttributes(g, attrs, groupAttrs) {
        const finalAttrs = super._transformGraphicAttributes(g, attrs, groupAttrs), {x: x, x1: x1, y: y, y1: y1} = finalAttrs, rest = __rest(finalAttrs, [ "x", "x1", "y", "y1" ]);
        return Object.assign(Object.assign({}, rest), {
            points: [ {
                x: x,
                y: y
            }, {
                x: x1,
                y: y1
            } ]
        });
    }
    _createGraphic(attrs = {}) {
        return createLine(attrs);
    }
}

RuleMark.type = "rule";

export const registerRuleMark = () => {
    Factory.registerMark(RuleMark.type, RuleMark), registerShadowRoot(), registerLine(), 
    Factory.registerGraphicComponent("line", createLine);
};
//# sourceMappingURL=rule.js.map
