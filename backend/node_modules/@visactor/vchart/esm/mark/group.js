import { Factory } from "./../core/factory";

import { log, warn } from "../util/debug";

import { BaseMark } from "./base/base-mark";

import { DiffState } from "./interface";

import { registerGroup, registerShadowRoot } from "@visactor/vrender-kits";

import { isNil } from "@visactor/vutils";

import { traverseGroupMark } from "../compile/util";

import { getDiffAttributesOfGraphic } from "../util/mark";

export class GroupMark extends BaseMark {
    constructor() {
        super(...arguments), this.type = GroupMark.type, this._marks = [], this._diffState = DiffState.enter;
    }
    getMarks() {
        return this._marks;
    }
    isMarkExist(mark) {
        return void 0 !== this._marks.find((m => m.id === mark.id));
    }
    addMark(mark) {
        return this.isMarkExist(mark) ? (warn("Mark already exists, add mark failed."), 
        !1) : (this._marks.push(mark), !0);
    }
    removeMark(mark) {
        const index = this._marks.findIndex((m => m.id === mark.id || m.name === mark.name));
        return -1 === index ? (warn("Mark does not exists, removeMark failed."), !1) : (this._marks.splice(index, 1), 
        !0);
    }
    getMarkInType(type) {
        return this._marks.filter((m => m.type === type));
    }
    getMarkInId(id) {
        return this._marks.find((m => m.id === id));
    }
    getMarkInUserId(id) {
        let result;
        return traverseGroupMark(this, (m => {
            result = m;
        }), (m => m.getUserId() === id), null, !0), result;
    }
    getMarkInName(name) {
        return this._marks.filter((m => m.name === name));
    }
    _compileProduct(option) {
        super._compileProduct(option), this.getMarks().forEach((mark => {
            mark.compile({
                group: this._product
            });
        }));
    }
    _getAttrsFromConfig(attrs = {}) {
        const configAttrs = super._getAttrsFromConfig(attrs);
        return isNil(this._markConfig.interactive) || (configAttrs.pickable = this._markConfig.interactive), 
        attrs;
    }
    getGraphics() {
        return [ this._product ];
    }
    renderInner() {
        var _a;
        if (!this._product) return;
        const style = null !== (_a = this._simpleStyle) && void 0 !== _a ? _a : this.getAttributesOfState({});
        this._product.context = Object.assign(Object.assign(Object.assign({}, this._product.context), this._getCommonContext()), {
            diffState: this._diffState
        }), this._setAnimationState(this._product);
        const newAttrs = this._getAttrsFromConfig(style);
        if (this._product.context.diffState === DiffState.update) {
            const hasAnimation = this.hasAnimation(), diffAttrs = getDiffAttributesOfGraphic(this._product, newAttrs);
            this._product.context.diffAttrs = diffAttrs, this.hasAnimationByState(this._product.context.animationState) || (hasAnimation ? this._product.setAttributesAndPreventAnimate(diffAttrs) : this._product.setAttributes(diffAttrs)), 
            hasAnimation && this._product.setFinalAttributes(newAttrs);
        } else this._product.setAttributes(newAttrs);
        this.needClear = !0;
    }
    clearExitGraphics() {
        this._diffState = DiffState.update;
    }
    render() {
        this._isCommited && (log(`render mark: ${this.getProductId()}, type is ${this.type}`), 
        this.renderInner(), this.uncommit()), this.getMarks().forEach((mark => {
            mark.render();
        }));
    }
    release() {
        super.release(), this.removeProduct();
    }
}

GroupMark.type = "group";

export const registerGroupMark = () => {
    registerShadowRoot(), registerGroup(), Factory.registerMark(GroupMark.type, GroupMark);
};
//# sourceMappingURL=group.js.map
