import { PREFIX } from "../../constant/base";

import { isNil } from "@visactor/vutils";

import { Factory } from "../../core/factory";

export const OVERLAP_HIDE_KEY = `${PREFIX}_hide_`;

function setVisible(g, visible) {
    g.context.finalAttrs && (g.context.finalAttrs.visible = visible);
}

function reset(graphics) {
    return graphics.forEach((g => {
        g[OVERLAP_HIDE_KEY] && (setVisible(g, !0), g[OVERLAP_HIDE_KEY] = !1);
    })), graphics;
}

function overlapX(graphics, delta, deltaMul) {
    let lastX = -1 / 0, lastR = 0;
    const useDeltaMul = isNil(delta);
    let itemDelta = delta;
    graphics.forEach((g => {
        if (!1 === g.context.finalAttrs.visible) return;
        const r = g.context.finalAttrs.size / 2, currentX = g.context.finalAttrs.x;
        useDeltaMul && (itemDelta = (r + lastR) * deltaMul), Math.abs(currentX - lastX) < itemDelta + lastR + r ? g.context.finalAttrs.forceShow || (g[OVERLAP_HIDE_KEY] = !0, 
        setVisible(g, !1)) : lastX = currentX, lastR = r;
    }));
}

function overlapY(graphics, delta, deltaMul) {
    let lastY = -1 / 0, lastR = 0;
    const useDeltaMul = isNil(delta);
    let itemDelta = delta;
    graphics.forEach((g => {
        if (!1 === g.context.finalAttrs.visible) return;
        const r = g.context.finalAttrs.size / 2, currentY = g.context.finalAttrs.y;
        useDeltaMul && (itemDelta = (r + lastR) * deltaMul), Math.abs(currentY - lastY) < itemDelta + lastR + r ? g.context.finalAttrs.forceShow || (g[OVERLAP_HIDE_KEY] = !0, 
        setVisible(g, !1)) : lastY = currentY, lastR = r;
    }));
}

function overlapXY(graphics, delta, deltaMul) {
    let lastY = -1 / 0, lastR = 0, dis = 0;
    const useDeltaMul = isNil(delta);
    let itemDelta = delta;
    graphics.forEach((g => {
        if (!1 === g.context.finalAttrs.visible) return;
        const r = g.context.finalAttrs.size / 2, {x: currentX, y: currentY} = g.context.finalAttrs;
        useDeltaMul && (itemDelta = (r + lastR) * deltaMul), dis = (-(1 / 0) - currentX) ** 2 + (lastY - currentY) ** 2, 
        dis < (itemDelta + lastR + r) ** 2 ? g.context.finalAttrs.forceShow || (g[OVERLAP_HIDE_KEY] = !0, 
        setVisible(g, !1)) : lastY = currentY, lastR = r;
    }));
}

export const transform = (options, upstreamData) => {
    if (!upstreamData || 0 === upstreamData.length) return upstreamData;
    const {direction: direction, delta: delta, deltaMul: deltaMul = 1, groupBy: groupBy} = options, handleOverlap = graphics => {
        reset(graphics);
        const sortedgraphics = options.sort ? graphics.slice().sort(((a, b) => a.context.finalAttrs.x - b.context.finalAttrs.x)) : graphics;
        0 === direction ? overlapXY(sortedgraphics, delta, deltaMul) : 1 === direction ? overlapX(sortedgraphics, delta, deltaMul) : overlapY(sortedgraphics, delta, deltaMul);
    };
    if (groupBy) {
        const map = upstreamData.reduce(((res, g) => {
            var _a, _b;
            const groupName = null === (_b = null === (_a = g.context.data) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b[groupBy];
            return res[groupName] ? res[groupName].push(g) : res[groupName] = [ g ], res;
        }), {});
        Object.keys(map).forEach((key => {
            handleOverlap(map[key]);
        }));
    } else handleOverlap(upstreamData);
    return upstreamData;
};

export const registerSymbolOverlapTransform = () => {
    Factory.registerGrammarTransform("symbolOverlap", {
        transform: transform,
        runType: "afterEncode"
    });
};
//# sourceMappingURL=symbol-overlap.js.map
