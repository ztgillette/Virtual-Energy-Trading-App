import { isDiscrete } from "@visactor/vscale";

import { getAxis, getDimensionData } from "./common";

import { isNil, maxInArray, minInArray } from "@visactor/vutils";

import { distance, vectorAngle } from "../../../../util/math";

const angleStandardize = (angle, range) => {
    const unit = 2 * Math.PI, min = minInArray(range), max = maxInArray(range);
    return angle < min ? angle += Math.ceil((min - angle) / unit) * unit : angle > max && (angle -= Math.ceil((angle - max) / unit) * unit), 
    angle;
};

export const getPolarDimensionInfo = (chart, pos) => {
    if (!chart) return null;
    const angleAxisList = getAxis(chart, (cmp => "angle" === cmp.getOrient()), pos), radiusAxisList = getAxis(chart, (cmp => "radius" === cmp.getOrient()), pos);
    if (!(angleAxisList && angleAxisList.length || radiusAxisList && radiusAxisList.length)) return null;
    const targetAxisInfo = [], getDimensionField = series => series.getDimensionField()[0], {x: x, y: y} = pos;
    return angleAxisList && angleAxisList.forEach((axis => {
        var _a;
        const angleScale = axis.getScale();
        if (angleScale && isDiscrete(angleScale.type)) {
            const angleDomain = angleScale.domain(), angleRange = angleScale.range(), center = axis.getCenter(), vector = {
                x: x - axis.getLayoutStartPoint().x - center.x,
                y: y - axis.getLayoutStartPoint().y - center.y
            };
            let angle = vectorAngle({
                x: 1,
                y: 0
            }, vector);
            angle = angleStandardize(angle, angleRange);
            const radius = distance(vector), radiusScale = null === (_a = radiusAxisList[0]) || void 0 === _a ? void 0 : _a.getScale(), radiusRange = null == radiusScale ? void 0 : radiusScale.range();
            if ((angle - (null == angleRange ? void 0 : angleRange[0])) * (angle - (null == angleRange ? void 0 : angleRange[1])) > 0 || (radius - (null == radiusRange ? void 0 : radiusRange[0])) * (radius - (null == radiusRange ? void 0 : radiusRange[1])) > 0) return;
            const value = axis.invert(angle);
            if (isNil(value)) return;
            let index = angleDomain.findIndex((v => (null == v ? void 0 : v.toString()) === value.toString()));
            index < 0 && (index = void 0);
            const data = getDimensionData(value, axis, "polar", getDimensionField);
            targetAxisInfo.push({
                index: index,
                value: value,
                position: angleScale.scale(value),
                axis: axis,
                data: data
            });
        }
    })), radiusAxisList && radiusAxisList.forEach((axis => {
        var _a;
        const radiusScale = axis.getScale(), radiusRange = null == radiusScale ? void 0 : radiusScale.range();
        if (radiusScale && isDiscrete(radiusScale.type)) {
            const center = axis.getCenter(), vector = {
                x: x - axis.getLayoutStartPoint().x - center.x,
                y: y - axis.getLayoutStartPoint().y - center.y
            };
            let angle = vectorAngle({
                x: 1,
                y: 0
            }, vector);
            angle < -Math.PI / 2 && (angle = 2 * Math.PI + angle);
            const radius = distance(vector), angleScale = null === (_a = angleAxisList[0]) || void 0 === _a ? void 0 : _a.getScale(), angleRange = null == angleScale ? void 0 : angleScale.range();
            if ((angle - (null == angleRange ? void 0 : angleRange[0])) * (angle - (null == angleRange ? void 0 : angleRange[1])) > 0 || (radius - (null == radiusRange ? void 0 : radiusRange[0])) * (radius - (null == radiusRange ? void 0 : radiusRange[1])) > 0) return;
            const value = radiusScale.invert(radius);
            if (isNil(value)) return;
            let index = radiusScale.domain().findIndex((v => (null == v ? void 0 : v.toString()) === value.toString()));
            index < 0 && (index = void 0);
            const data = getDimensionData(value, axis, "polar", getDimensionField);
            targetAxisInfo.push({
                index: index,
                value: value,
                position: radiusScale.scale(value),
                axis: axis,
                data: data
            });
        }
    })), targetAxisInfo.length ? targetAxisInfo : null;
};
//# sourceMappingURL=polar.js.map
