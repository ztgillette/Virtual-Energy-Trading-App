{"version":3,"sources":["../src/event/events/dimension/util/polar.ts"],"names":[],"mappings":"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","file":"polar.js","sourcesContent":["import type { IChart } from '../../../../chart/interface';\nimport type { IDimensionInfo } from '../interface';\nimport { isDiscrete } from '@visactor/vscale';\nimport { getAxis, getDimensionData } from './common';\nimport type { IPolarSeries } from '../../../../series/interface';\nimport { isNil, maxInArray, minInArray } from '@visactor/vutils';\nimport { distance, vectorAngle } from '../../../../util/math';\nimport type { ILayoutPoint } from '../../../../typings/layout';\nimport type { PolarAxis } from '../../../../component';\n/** 将角度标准化为 range 范围内的角度 */\nconst angleStandardize = (angle: number, range: [number, number]) => {\n  const unit = Math.PI * 2;\n  const min = minInArray(range);\n  const max = maxInArray(range);\n  if (angle < min) {\n    angle += Math.ceil((min - angle) / unit) * unit;\n  } else if (angle > max) {\n    angle -= Math.ceil((angle - max) / unit) * unit;\n  }\n  return angle;\n};\n\nexport const getPolarDimensionInfo = (chart: IChart | undefined, pos: ILayoutPoint): IDimensionInfo[] | null => {\n  if (!chart) {\n    return null;\n  }\n\n  const angleAxisList = getAxis(chart, (cmp: PolarAxis) => cmp.getOrient() === 'angle', pos);\n  const radiusAxisList = getAxis(chart, (cmp: PolarAxis) => cmp.getOrient() === 'radius', pos);\n\n  if ((!angleAxisList || !angleAxisList.length) && (!radiusAxisList || !radiusAxisList.length)) {\n    return null;\n  }\n\n  const targetAxisInfo: IDimensionInfo[] = [];\n\n  const getDimensionField = (series: IPolarSeries) => series.getDimensionField()[0];\n  const { x, y } = pos;\n\n  if (angleAxisList) {\n    angleAxisList.forEach(axis => {\n      const angleScale = axis.getScale();\n      // 限定为离散轴\n      if (angleScale && isDiscrete(angleScale.type)) {\n        const angleDomain = angleScale.domain();\n        const angleRange = angleScale.range();\n        const center = axis.getCenter();\n        const vector = {\n          x: x - axis.getLayoutStartPoint().x - center.x,\n          y: y - axis.getLayoutStartPoint().y - center.y\n        };\n\n        // 计算顺时针角度\n        let angle = vectorAngle({ x: 1, y: 0 }, vector);\n        angle = angleStandardize(angle, angleRange);\n\n        // 计算半径\n        const radius = distance(vector);\n        const radiusScale = radiusAxisList[0]?.getScale(); // FIXME: 想办法获取到和当前角度轴对应的径向轴，而不是取第一个\n        const radiusRange = radiusScale?.range();\n\n        // 判断是否在 range 范围内\n        if (\n          (angle - angleRange?.[0]) * (angle - angleRange?.[1]) > 0 ||\n          (radius - radiusRange?.[0]) * (radius - radiusRange?.[1]) > 0\n        ) {\n          return;\n        }\n\n        const value = axis.invert(angle);\n        if (isNil(value)) {\n          return;\n        }\n        let index: number | undefined = angleDomain.findIndex((v: any) => v?.toString() === value.toString());\n        if (index < 0) {\n          index = undefined;\n        }\n\n        const data = getDimensionData(value, axis, 'polar', getDimensionField);\n        targetAxisInfo.push({ index, value, position: angleScale.scale(value), axis, data });\n      }\n    });\n  }\n  if (radiusAxisList) {\n    radiusAxisList.forEach(axis => {\n      const radiusScale = axis.getScale();\n      const radiusRange = radiusScale?.range();\n\n      // 限定为离散轴\n      if (radiusScale && isDiscrete(radiusScale.type)) {\n        const center = axis.getCenter();\n        const vector = {\n          x: x - axis.getLayoutStartPoint().x - center.x,\n          y: y - axis.getLayoutStartPoint().y - center.y\n        };\n\n        // 计算顺时针角度\n        let angle = vectorAngle({ x: 1, y: 0 }, vector);\n        if (angle < -Math.PI / 2) {\n          angle = Math.PI * 2 + angle;\n        }\n\n        // 计算半径\n        const radius = distance(vector);\n        const angleScale = angleAxisList[0]?.getScale(); // FIXME: 想办法获取到和当前径向轴对应的角度轴，而不是取第一个\n        const angleRange = angleScale?.range();\n\n        // 判断是否在 range 范围内\n        if (\n          (angle - angleRange?.[0]) * (angle - angleRange?.[1]) > 0 ||\n          (radius - radiusRange?.[0]) * (radius - radiusRange?.[1]) > 0\n        ) {\n          return;\n        }\n\n        const value = radiusScale.invert(radius);\n        if (isNil(value)) {\n          return;\n        }\n        const domain = radiusScale.domain();\n        let index: number | undefined = domain.findIndex((v: any) => v?.toString() === value.toString());\n        if (index < 0) {\n          index = undefined;\n        }\n\n        const data = getDimensionData(value, axis, 'polar', getDimensionField);\n        targetAxisInfo.push({ index, value, position: radiusScale.scale(value), axis, data });\n      }\n    });\n  }\n  if (!targetAxisInfo.length) {\n    return null;\n  }\n  return targetAxisInfo;\n};\n"]}