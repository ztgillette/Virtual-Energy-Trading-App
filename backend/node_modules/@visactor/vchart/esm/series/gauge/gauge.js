import { SeriesTypeEnum } from "../interface/type";

import { ProgressLikeSeries } from "../polar/progress-like/progress-like";

import { registerDataSetInstanceTransform } from "../../data/register";

import { SEGMENT_FIELD_END, SEGMENT_FIELD_START } from "../../constant/data";

import { animationConfig, userAnimationConfig } from "../../animation/utils";

import { gaugeSeriesMark } from "./constant";

import { clamper, degreeToRadian, isValid } from "@visactor/vutils";

import { Factory } from "../../core/factory";

import { registerProgressLikeAnimation } from "../polar/progress-like";

import { GaugeSeriesSpecTransformer } from "./gauge-transformer";

import { registerArcMark } from "../../mark/arc";

import { registerPolarLinearAxis } from "../../component/axis/polar";

import { AttributeLevel } from "../../constant/attribute";

import { valueInScaleRange } from "../../util";

import { gauge } from "../../theme/builtin/common/series/gauge";

export class GaugeSeries extends ProgressLikeSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.gauge, this.transformerConstructor = GaugeSeriesSpecTransformer, 
        this._segmentMark = null, this._trackMark = null, this._padAngle = 0;
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec(), this._padAngle = degreeToRadian(null !== (_a = this._spec.padAngle) && void 0 !== _a ? _a : 0);
    }
    initData() {
        var _a;
        super.initData();
        registerDataSetInstanceTransform(this._option.dataSet, "spiltSegment", ((data, op) => {
            const dataCollect = data.slice();
            return dataCollect.sort(((a, b) => a[this._angleField[0]] - b[this._angleField[0]])), 
            dataCollect.forEach(((datum, i) => {
                datum[SEGMENT_FIELD_END] = datum[this._angleField[0]], datum[SEGMENT_FIELD_START] = i > 0 ? dataCollect[i - 1][SEGMENT_FIELD_END] : void 0;
            })), dataCollect;
        })), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
            type: "spiltSegment"
        }, !1);
    }
    initMark() {
        super.initMark(), this._trackMark = this._createMark(GaugeSeries.mark.track, {
            parent: this._arcGroupMark,
            dataView: !1
        }), this._segmentMark = this._createMark(GaugeSeries.mark.segment, {
            parent: this._arcGroupMark,
            isSeriesMark: !0
        });
    }
    initMarkStyle() {
        super.initMarkStyle(), this.initTrackMarkStyle(), this.initSegmentMarkStyle();
    }
    initSegmentMarkStyle() {
        var _a;
        const segmentMark = this._segmentMark;
        segmentMark && this.setMarkStyle(segmentMark, {
            x: () => this.angleAxisHelper.center().x,
            y: () => this.angleAxisHelper.center().y,
            startAngle: this._getAngleValueStart.bind(this),
            endAngle: this._getAngleValueEnd.bind(this),
            innerRadius: () => {
                var _a;
                return this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0);
            },
            outerRadius: () => {
                var _a, _b;
                return this._computeLayoutRadius() * (null !== (_b = null !== (_a = this._spec.radius) && void 0 !== _a ? _a : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
            },
            cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
            boundsMode: "imprecise",
            cornerRadius: this._spec.cornerRadius,
            fill: this.getColorAttribute(),
            zIndex: 200,
            forceShowCap: !0
        });
    }
    generateRadiusStyle(spec) {
        if (!spec) return;
        const style = {};
        return spec.outerRadius && (style.outerRadius = () => this._computeLayoutRadius() * spec.outerRadius), 
        spec.innerRadius && (style.innerRadius = () => this._computeLayoutRadius() * spec.innerRadius), 
        style;
    }
    initMarkStyleWithSpec(mark, spec) {
        if (super.initMarkStyleWithSpec(mark, spec), mark && "segment" === mark.name) {
            const segmentSpec = this.getSpec().segment;
            if (segmentSpec) for (const state in segmentSpec.state || {}) this.setMarkStyle(mark, this.generateRadiusStyle(segmentSpec.state[state]), state, AttributeLevel.User_Mark);
        }
    }
    initTooltip() {
        super.initTooltip(), this._segmentMark && this._tooltipHelper.activeTriggerSet.mark.add(this._segmentMark);
    }
    initTrackMarkStyle() {
        var _a;
        const trackMark = this._trackMark;
        trackMark && this.setMarkStyle(trackMark, {
            x: () => this.angleAxisHelper.center().x,
            y: () => this.angleAxisHelper.center().y,
            startAngle: this._startAngle,
            endAngle: this._endAngle,
            innerRadius: () => {
                var _a;
                return this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0);
            },
            outerRadius: () => {
                var _a, _b;
                return this._computeLayoutRadius() * (null !== (_b = null !== (_a = this._spec.radius) && void 0 !== _a ? _a : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
            },
            cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
            boundsMode: "imprecise",
            cornerRadius: this._spec.cornerRadius,
            zIndex: 100
        });
    }
    _getAngleValueStartWithoutMask(datum) {
        const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum), angle = clamper(startAngle, (startAngle + endAngle) / 2)(startAngle + (endAngle > startAngle ? 1 : -1) * Math.abs(this._padAngle / 2));
        return this._spec.clamp ? valueInScaleRange(angle, this.angleAxisHelper.getScale(0)) : angle;
    }
    _getAngleValueEndWithoutMask(datum) {
        const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum), angle = clamper(endAngle, (startAngle + endAngle) / 2)(endAngle - (endAngle > startAngle ? 1 : -1) * Math.abs(this._padAngle / 2));
        return this._spec.clamp ? valueInScaleRange(angle, this.angleAxisHelper.getScale(0)) : angle;
    }
    _getAngleValueStartWithoutPadAngle(datum) {
        return isValid(datum[SEGMENT_FIELD_START]) ? this.angleAxisHelper.dataToPosition([ datum[SEGMENT_FIELD_START] ]) : this._startAngle;
    }
    _getAngleValueEndWithoutPadAngle(datum) {
        return this.angleAxisHelper.dataToPosition([ datum[SEGMENT_FIELD_END] ]);
    }
    initAnimation() {
        var _a, _b, _c;
        const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._segmentMark.setAnimationConfig(animationConfig(null === (_c = Factory.getAnimationInKey("circularProgress")) || void 0 === _c ? void 0 : _c({
            startAngle: this._startAngle
        }, appearPreset), userAnimationConfig("segment", this._spec, this._markAttributeContext)));
    }
    getDefaultShapeType() {
        return "circle";
    }
    getActiveMarks() {
        return [];
    }
}

GaugeSeries.type = SeriesTypeEnum.gauge, GaugeSeries.mark = gaugeSeriesMark, GaugeSeries.builtInTheme = {
    gauge: gauge
}, GaugeSeries.transformerConstructor = GaugeSeriesSpecTransformer;

export const registerGaugeSeries = () => {
    Factory.registerSeries(GaugeSeries.type, GaugeSeries), registerArcMark(), registerProgressLikeAnimation(), 
    registerPolarLinearAxis();
};
//# sourceMappingURL=gauge.js.map
