import { BarSeries } from "../bar/bar";

import { SeriesTypeEnum } from "../interface/type";

import { registerRectMark } from "../../mark/rect";

import { registerTextMark } from "../../mark/text";

import { registerFadeInOutAnimation } from "../../animation/config";

import { Factory } from "../../core/factory";

import { BarSeriesSpecTransformer } from "../bar/bar-transformer";

import { registerCartesianLinearAxis } from "../../component/axis/cartesian";

import { MOSAIC_CAT_END_PERCENT, MOSAIC_CAT_START_PERCENT, MOSAIC_VALUE_END_PERCENT, MOSAIC_VALUE_START_PERCENT } from "../../constant/data";

import { isNil } from "@visactor/vutils";

import { mosaic } from "../../theme/builtin/common/series/mosaic";

export class MosaicSeries extends BarSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.mosaic, this.transformerConstructor = BarSeriesSpecTransformer;
    }
    get bandWidthField() {
        return this._bandWidthField;
    }
    getStack() {
        return !0;
    }
    getPercent() {
        return this._spec.percent;
    }
    getGroupFields() {
        return "vertical" === this.direction ? this._specXField : this._specYField;
    }
    setAttrFromSpec() {
        super.setAttrFromSpec();
        const isPercent = this.getPercent();
        "horizontal" === this.direction ? (isPercent && (this.setFieldX(MOSAIC_VALUE_END_PERCENT), 
        this.setFieldX2(MOSAIC_VALUE_START_PERCENT)), this.setFieldY(MOSAIC_CAT_END_PERCENT), 
        this.setFieldY2(MOSAIC_CAT_START_PERCENT)) : (isPercent && (this.setFieldY(MOSAIC_VALUE_END_PERCENT), 
        this.setFieldY2(MOSAIC_VALUE_START_PERCENT)), this.setFieldX(MOSAIC_CAT_END_PERCENT), 
        this.setFieldX2(MOSAIC_CAT_START_PERCENT)), this._spec.bandWidthField && (this._bandWidthField = this._spec.bandWidthField);
    }
    parseLabelStyle(labelStyle, labelSpec) {
        if ((null == labelSpec ? void 0 : labelSpec.filterByGroup) && isNil(labelStyle.dataFilter)) {
            const allGroupFields = this.getGroupFields(), {field: field, type: filterType = "max", filter: filter} = labelSpec.filterByGroup;
            delete labelStyle.filterField;
            const fieldIndex = allGroupFields.indexOf(field);
            if (fieldIndex < 0) return;
            const valueField = !!(fieldIndex % 2) ? "min" === filterType ? "horizontal" === this.direction ? this._fieldY2 : this._fieldX2 : "horizontal" === this.direction ? this._fieldY : this._fieldX : "min" === filterType ? "horizontal" === this.direction ? this._fieldX2 : this._fieldY2 : "horizontal" === this.direction ? this._fieldX : this._fieldY, filterFunc = "min" === filterType ? (a, b) => {
                var _a, _b;
                return (null === (_a = a.data) || void 0 === _a ? void 0 : _a[valueField]) < (null === (_b = b.data) || void 0 === _b ? void 0 : _b[valueField]);
            } : (a, b) => {
                var _a, _b;
                return (null === (_a = a.data) || void 0 === _a ? void 0 : _a[valueField]) > (null === (_b = b.data) || void 0 === _b ? void 0 : _b[valueField]);
            };
            labelStyle.dataFilter = data => {
                const filteredData = {};
                return data.forEach((d => {
                    const datum = d.data, fieldValue = null == datum ? void 0 : datum[field];
                    isNil(fieldValue) || filter && !filter(d) || filteredData[fieldValue] && !filterFunc(d, filteredData[fieldValue]) || (filteredData[fieldValue] = d);
                })), data.filter((d => {
                    var _a;
                    const fieldValue = null === (_a = d.data) || void 0 === _a ? void 0 : _a[field];
                    return filteredData[fieldValue] && filteredData[fieldValue] === d;
                }));
            };
        }
        return labelStyle;
    }
}

MosaicSeries.type = SeriesTypeEnum.mosaic, MosaicSeries.builtInTheme = {
    mosaic: mosaic
}, MosaicSeries.transformerConstructor = BarSeriesSpecTransformer;

export const registerMosaicSeries = () => {
    registerRectMark(), registerTextMark(), registerFadeInOutAnimation(), registerCartesianLinearAxis(), 
    Factory.registerSeries(MosaicSeries.type, MosaicSeries);
};
//# sourceMappingURL=mosaic.js.map
