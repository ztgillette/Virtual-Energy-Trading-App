{"version":3,"sources":["../src/series/base/base-series-transformer.ts"],"names":[],"mappings":"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","file":"base-series-transformer.js","sourcesContent":["import { isBoolean, isFunction, isNil, isObject } from '@visactor/vutils';\nimport type { IChartSpecInfo } from '../../chart/interface';\nimport type { ILabelSpec, TransformedLabelSpec } from '../../component/label';\nimport { BaseModelSpecTransformer } from '../../model/base-model-transformer';\nimport type { ISeriesSpec } from '../../typings';\nimport { array, get, isArray, isValid, transformSeriesThemeToMerge } from '../../util';\nimport { mergeSpec } from '@visactor/vutils-extension';\nimport type { ISeriesSpecTransformerResult, SeriesMarkNameEnum } from '../interface';\n// eslint-disable-next-line no-duplicate-imports\nimport type { ISeries } from '../interface';\nimport { getDirectionFromSeriesSpec } from '../util/spec';\nimport { Factory } from '../../core/factory';\n\nexport class BaseSeriesSpecTransformer<T extends ISeriesSpec, K> extends BaseModelSpecTransformer<T, K> {\n  markLabelSpec: Partial<Record<SeriesMarkNameEnum, TransformedLabelSpec[]>> = {};\n  stack: boolean;\n  protected _supportStack: boolean;\n\n  getLabelSpec(markName: string) {\n    return this.markLabelSpec[markName];\n  }\n\n  setLabelSpec(markName: string, label: TransformedLabelSpec | TransformedLabelSpec[]) {\n    this.markLabelSpec[markName] = array(label);\n  }\n\n  addLabelSpec(markName: string, label: TransformedLabelSpec, head = false) {\n    if (!this.markLabelSpec[markName]) {\n      this.markLabelSpec[markName] = [];\n    }\n    if (head) {\n      // 排序靠前的 label 优先布局，尽可能避免碰撞隐藏\n      this.markLabelSpec[markName].unshift(label);\n    } else {\n      this.markLabelSpec[markName].push(label);\n    }\n  }\n\n  getTheme(spec: T, chartSpec: any): K {\n    const direction = getDirectionFromSeriesSpec(spec);\n    const getTheme = this._option?.getTheme;\n    // const { markByName, mark } = chartTheme;\n    const type = this._option.type;\n    // 基本主题\n    const seriesMarkMap = Factory.getSeriesMarkMap(type);\n\n    const theme = seriesMarkMap ? transformSeriesThemeToMerge(getTheme('series', type), type, getTheme) : {};\n    // 区分方向的主题\n    const themeWithDirection = getTheme('series', `${type}_${direction}`);\n    // stack 状态下的主题\n    const stack = this.stack ?? themeWithDirection?.stack ?? theme?.stack;\n    const themeWithStack = stack ? getTheme('series', `${type}_stack`) : undefined;\n    return mergeSpec({}, theme, themeWithDirection, themeWithStack);\n  }\n\n  /** 不建议重写该方法，最好重写对应子步骤 */\n  transformSpec(spec: T, chartSpec: any, chartSpecInfo?: IChartSpecInfo): ISeriesSpecTransformerResult<T, K> {\n    this._transformStack(spec);\n    const result = super.transformSpec(spec, chartSpec, chartSpecInfo);\n    this._transformLabelSpec(result.spec);\n    return {\n      ...result,\n      markLabelSpec: this.markLabelSpec,\n      stack: this.stack\n    };\n  }\n\n  protected _transformLabelSpec(spec: T) {\n    // empty\n  }\n\n  protected _transformStack(spec: T) {\n    if (isBoolean(spec.stack)) {\n      this.stack = spec.stack;\n    }\n    if (isBoolean(spec.percent)) {\n      this.stack = spec.percent || this.stack; // this.stack is `true` in bar/area series\n    }\n\n    if (isNil(this.stack) && this._supportStack && spec.seriesField) {\n      // only set default value of stack to be `true` when series support stack and seriesField is not null\n      this.stack = true;\n    }\n  }\n\n  protected _addMarkLabelSpec<V extends ISeries = ISeries>(\n    spec: T,\n    markName: string | ((spec: ILabelSpec) => string),\n    labelSpecKey: keyof T = 'label' as any,\n    styleHandlerName: keyof V = 'initLabelMarkStyle',\n    hasAnimation: boolean = true,\n    head?: boolean\n  ): void {\n    if (!spec) {\n      return;\n    }\n    const labels = array<ILabelSpec>(spec[labelSpecKey]);\n    labels.forEach(labelSpec => {\n      if (labelSpec && labelSpec.visible) {\n        // animation config priority: option.animation > spec.animation > spec.label.animation\n        const {\n          animation = true,\n          animationUpdate: labelAnimationUpdate = true,\n          animationEnter: labelAnimationEnter = true,\n          animationExit: labelAnimationExit = true\n        } = labelSpec;\n        const { animationUpdate = true, animationEnter = true, animationExit = true } = spec as any;\n        const animationEnabled =\n          this._option.globalInstance?.isAnimationEnable() ?? spec.animation ?? labelSpec.animation;\n        const labelAnimationEnabled = !!animationEnabled && !!hasAnimation;\n\n        this.addLabelSpec(\n          isFunction(markName) ? markName(labelSpec) : markName,\n          {\n            ...labelSpec,\n            animation: labelAnimationEnabled ? animation : false,\n            animationUpdate: labelAnimationEnabled && animationUpdate && labelAnimationUpdate ? animationUpdate : false,\n            animationEnter: labelAnimationEnabled && animationEnter && labelAnimationEnter ? animationEnter : false,\n            animationExit: labelAnimationEnabled && animationEnter && labelAnimationExit ? animationExit : false,\n            getStyleHandler: (series: V) => (series[styleHandlerName] as any)?.bind(series)\n          } as TransformedLabelSpec,\n          head\n        );\n      }\n    });\n  }\n\n  protected _getDefaultSpecFromChart(chartSpec: any): any {\n    const spec = (super._getDefaultSpecFromChart(chartSpec) as any) ?? {};\n    const { outerRadius, innerRadius, direction } = chartSpec;\n    if (isValid(outerRadius)) {\n      spec.outerRadius = outerRadius;\n    }\n    if (isValid(innerRadius)) {\n      spec.innerRadius = innerRadius;\n    }\n\n    if (isValid(direction)) {\n      spec.direction = direction;\n    }\n\n    return Object.keys(spec).length > 0 ? spec : undefined;\n  }\n\n  protected _mergeThemeToSpec(spec: T, chartSpec: any): { spec: T; theme: K } {\n    const theme = this._theme;\n\n    if (this._shouldMergeThemeToSpec()) {\n      const specFromChart = this._getDefaultSpecFromChart(chartSpec);\n      // this._originalSpec + specFromChart + this._theme = spec\n      const merge = (originalSpec: any) => {\n        const result = mergeSpec({}, theme, specFromChart, originalSpec);\n        const labelTheme = (theme as any).label;\n        if (labelTheme && isObject(labelTheme) && isArray(result.label)) {\n          result.label = result.label.map((label: ILabelSpec) => mergeSpec({}, labelTheme, label));\n        }\n        return result;\n      };\n\n      if (isArray(spec)) {\n        return {\n          spec: spec.map(specItem => merge(specItem)) as unknown as T,\n          theme\n        };\n      }\n\n      return {\n        spec: merge(spec),\n        theme\n      };\n    }\n    return { spec, theme };\n  }\n}\n"]}