import { PREFIX } from "../../constant/base";

import { CartesianSeries } from "../cartesian/cartesian";

import { isNil, isValid, isObject, isFunction, isString, isArray, isNumber, isNumeric } from "@visactor/vutils";

import { AttributeLevel } from "../../constant/attribute";

import { SeriesTypeEnum } from "../interface/type";

import { STATE_VALUE_ENUM } from "../../compile/mark/interface";

import { SCATTER_DEFAULT_RANGE_SHAPE, SCATTER_DEFAULT_RANGE_SIZE, SCATTER_DEFAULT_SHAPE, SCATTER_DEFAULT_SHAPE_SCALE_TYPE, SCATTER_DEFAULT_SIZE, SCATTER_DEFAULT_SIZE_SCALE_TYPE } from "../../constant/scatter";

import { animationConfig, shouldMarkDoMorph, userAnimationConfig } from "../../animation/utils";

import { registerScatterAnimation } from "./animation";

import { registerSymbolMark } from "../../mark/symbol";

import { scatterSeriesMark } from "./constant";

import { Factory } from "../../core/factory";

import { ScatterSeriesSpecTransformer } from "./scatter-transformer";

import { getGroupAnimationParams } from "../util/utils";

import { registerCartesianLinearAxis, registerCartesianBandAxis } from "../../component/axis/cartesian";

import { scatter } from "../../theme/builtin/common/series/scatter";

export class ScatterSeries extends CartesianSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.scatter, this.transformerConstructor = ScatterSeriesSpecTransformer, 
        this._invalidType = "zero";
    }
    setAttrFromSpec() {
        super.setAttrFromSpec(), this._size = this._spec.size, this._sizeField = this._spec.sizeField, 
        this._shape = this._spec.shape, this._shapeField = this._spec.shapeField;
    }
    _getSeriesAttribute(field, spec, {defaultScaleType: defaultScaleType, defaultRange: defaultRange}, key) {
        var _a, _b, _c, _d;
        if (isFunction(spec)) return spec;
        if (isArray(spec)) {
            if (isNil(field)) return null === (_a = this._option) || void 0 === _a || _a.onError(`${key}Field is required.`), 
            spec;
            if ("ordinal" !== defaultScaleType && spec.length > 2) return null === (_b = this._option) || void 0 === _b || _b.onError(`${key} length is invalid, specify up to 2 ${key}s.`), 
            spec;
            const scaleName = `${PREFIX}_series_scatter_${this.id}_scale_${key}`;
            return this._option.globalScale.registerModelScale({
                id: scaleName,
                type: defaultScaleType,
                domain: [ {
                    dataId: this._rawData.name,
                    fields: [ field ]
                } ],
                range: spec
            }), {
                scale: scaleName,
                field: field
            };
        }
        if (isObject(spec)) {
            if (isNil(field)) return null === (_c = this._option) || void 0 === _c || _c.onError(`${key}Field is required.`), 
            spec;
            const scaleName = `${PREFIX}_series_scatter_${this.id}_scale_${key}`, visualSpec = Object.assign({
                id: scaleName,
                type: defaultScaleType,
                domain: [ {
                    dataId: this._rawData.name,
                    fields: [ field ]
                } ],
                range: defaultRange
            }, spec);
            return this._option.globalScale.registerModelScale(visualSpec), {
                scale: visualSpec.id,
                field: field
            };
        }
        return null === (_d = this._option) || void 0 === _d || _d.onError(`${key} attribute is invalid.`), 
        spec;
    }
    getSizeAttribute(field, sizeSpec) {
        return isNil(sizeSpec) ? SCATTER_DEFAULT_SIZE : isNumber(sizeSpec) ? sizeSpec : isString(sizeSpec) && isNumeric(sizeSpec) ? parseFloat(sizeSpec) : this._getSeriesAttribute(field, sizeSpec, {
            defaultScaleType: SCATTER_DEFAULT_SIZE_SCALE_TYPE,
            defaultRange: SCATTER_DEFAULT_RANGE_SIZE
        }, "size");
    }
    getShapeAttribute(field, shapeSpec) {
        return isNil(shapeSpec) ? SCATTER_DEFAULT_SHAPE : isString(shapeSpec) ? shapeSpec : this._getSeriesAttribute(field, shapeSpec, {
            defaultScaleType: SCATTER_DEFAULT_SHAPE_SCALE_TYPE,
            defaultRange: SCATTER_DEFAULT_RANGE_SHAPE
        }, "shape");
    }
    initMark() {
        this._symbolMark = this._createMark(ScatterSeries.mark.point, {
            groupKey: this._seriesField,
            isSeriesMark: !0
        }, {
            morph: shouldMarkDoMorph(this._spec, ScatterSeries.mark.point.name),
            morphElementKey: this.getDimensionField()[0]
        });
    }
    initMarkStyle() {
        this.initSymbolMarkStyle();
    }
    initAnimation() {
        var _a, _b, _c;
        const animationParams = getGroupAnimationParams(this), appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._symbolMark.setAnimationConfig(animationConfig(null === (_c = Factory.getAnimationInKey("scatter")) || void 0 === _c ? void 0 : _c({}, appearPreset), userAnimationConfig("point", this._spec, this._markAttributeContext), animationParams));
    }
    initSymbolMarkStyle() {
        const symbolMark = this._symbolMark;
        symbolMark && ("zero" !== this._invalidType && this.setMarkStyle(symbolMark, {
            visible: this._getInvalidDefined.bind(this)
        }), this.setMarkStyle(symbolMark, {
            x: this.dataToPositionX.bind(this),
            y: this.dataToPositionY.bind(this),
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
            fill: this.getColorAttribute(),
            size: isNumber(this._size) || isFunction(this._size) ? this._size : SCATTER_DEFAULT_SIZE,
            symbolType: isString(this._shape) || isFunction(this._shape) ? this._shape : SCATTER_DEFAULT_SHAPE
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), (isValid(this._sizeField) || isValid(this._size)) && this.setMarkStyle(symbolMark, {
            size: this.getSizeAttribute(this._sizeField, this._size)
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.User_Mark), (isValid(this._shapeField) || isValid(this._shape)) && this.setMarkStyle(symbolMark, {
            symbolType: this.getShapeAttribute(this._shapeField, this._shape)
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.User_Mark));
    }
    initTooltip() {
        super.initTooltip(), this._symbolMark && this._tooltipHelper.activeTriggerSet.mark.add(this._symbolMark);
    }
    viewDataStatisticsUpdate(d) {
        super.viewDataStatisticsUpdate(d);
        const allValid = [ this.getDimensionField()[0], this.getStackValueField() ].every((field => {
            var _a, _b, _c;
            return field && (null === (_c = null === (_b = null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[field]) || void 0 === _c ? void 0 : _c.allValid);
        }));
        "zero" === this._invalidType || allValid ? this.setMarkStyle(this._symbolMark, {
            visible: !0
        }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._symbolMark, {
            visible: this._getInvalidDefined.bind(this)
        }, "normal", AttributeLevel.Series), this._symbolMark.getProduct() && this._symbolMark.compileEncode();
    }
    initLabelMarkStyle(labelMark) {
        labelMark && (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
            fill: this.getColorAttribute(),
            text: datum => datum[this.getStackValueField()],
            z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(labelMark, {
            visible: this._getInvalidDefined.bind(this)
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
    }
    handleZoom(e) {
        var _a, _b;
        this.getMarksWithoutRoot().forEach((mark => {
            if (!mark) return;
            const graphics = mark.getGraphics();
            graphics && graphics.length && graphics.forEach(((graphicItem, i) => {
                var _a, _b;
                const datum = null === (_b = null === (_a = null == graphicItem ? void 0 : graphicItem.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], newPosition = this.dataToPosition(datum);
                newPosition && graphicItem && graphicItem.translateTo(newPosition.x, newPosition.y);
            }));
        }));
        const vgrammarLabel = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct();
        vgrammarLabel && vgrammarLabel.evaluate(null, null);
    }
    handlePan(e) {
        this.handleZoom(e);
    }
    getDefaultShapeType() {
        return "circle";
    }
    getActiveMarks() {
        return [ this._symbolMark ];
    }
}

ScatterSeries.type = SeriesTypeEnum.scatter, ScatterSeries.mark = scatterSeriesMark, 
ScatterSeries.builtInTheme = {
    scatter: scatter
}, ScatterSeries.transformerConstructor = ScatterSeriesSpecTransformer;

export const registerScatterSeries = () => {
    registerSymbolMark(), registerScatterAnimation(), registerCartesianBandAxis(), registerCartesianLinearAxis(), 
    Factory.registerSeries(ScatterSeries.type, ScatterSeries);
};
//# sourceMappingURL=scatter.js.map
