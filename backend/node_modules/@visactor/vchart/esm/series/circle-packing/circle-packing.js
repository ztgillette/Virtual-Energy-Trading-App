import { isNil, mixin } from "@visactor/vutils";

import { Factory } from "../../core/factory";

import { SeriesTypeEnum } from "../interface/type";

import { CartesianSeries } from "../cartesian/cartesian";

import { registerDataSetInstanceTransform } from "../../data/register";

import { circlePackingLayout } from "../../data/transforms/circle-packing";

import { STATE_VALUE_ENUM } from "../../compile/mark/interface";

import { DEFAULT_DATA_KEY } from "../../constant/data";

import { AttributeLevel } from "../../constant/attribute";

import { DEFAULT_HIERARCHY_ROOT } from "../../constant/hierarchy";

import { flatten } from "../../data/transforms/flatten";

import { CirclePackingTooltipHelper } from "./tooltip-helper";

import { addHierarchyDataKey, initHierarchyKeyMap } from "../../data/transforms/data-key";

import { addVChartProperty } from "../../data/transforms/add-property";

import { animationConfig, userAnimationConfig } from "../../animation/utils";

import { registerScaleInOutAnimation } from "../../animation/config";

import { registerCirclePackingAnimation } from "./animation";

import { Drillable } from "../../interaction/drill/drillable";

import { registerArcMark } from "../../mark/arc";

import { registerTextMark } from "../../mark/text";

import { circlePackingSeriesMark } from "./constant";

import { appendHierarchyFields } from "../util/hierarchy";

import { circlePacking } from "../../theme/builtin/common/series/circle-packing";

export class CirclePackingSeries extends CartesianSeries {
    constructor() {
        super(...arguments), this.type = SeriesTypeEnum.circlePacking;
    }
    setCategoryField(f) {
        return this._categoryField = f, this._categoryField;
    }
    getCategoryField() {
        return this._categoryField;
    }
    setValueField(f) {
        return this._valueField = f, this._valueField;
    }
    getValueField() {
        return this._valueField;
    }
    getDimensionField() {
        return [ this._categoryField ];
    }
    getMeasureField() {
        return [ this._valueField ];
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), 
        this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : DEFAULT_HIERARCHY_ROOT), 
        this._spec.drill && this.initDrillable({
            event: this.event,
            mode: this._option.mode,
            drillField: () => {
                var _a;
                return null !== (_a = this._spec.drillField) && void 0 !== _a ? _a : DEFAULT_DATA_KEY;
            },
            getRawData: () => this.getRawData()
        }), this._circlePacking = this._spec.circlePacking, this._label = this._spec.label, 
        this._layoutPadding = this._spec.layoutPadding;
    }
    initData() {
        super.initData();
        const rawData = this.getRawData();
        isNil(rawData) || (this._spec.drill && this.initDrillableData(this._dataSet), registerDataSetInstanceTransform(this._dataSet, "circlePackingLayout", circlePackingLayout), 
        registerDataSetInstanceTransform(this._dataSet, "flatten", flatten), rawData.transform({
            type: "circlePackingLayout",
            options: () => ({
                nodeKey: this._categoryField,
                padding: this._layoutPadding,
                includeRoot: !1,
                width: this.getLayoutRect().width || 1,
                height: this.getLayoutRect().height || 1
            })
        }), rawData.transform({
            type: "flatten",
            options: {
                callback: node => {
                    if (node.datum) {
                        const nodeData = node.datum[node.depth];
                        return Object.assign(Object.assign({}, node), nodeData);
                    }
                    return node;
                }
            }
        }));
    }
    _addDataIndexAndKey() {
        const rawData = this.getRawData();
        isNil(null == rawData ? void 0 : rawData.dataSet) || (registerDataSetInstanceTransform(rawData.dataSet, "addVChartProperty", addVChartProperty), 
        rawData.transform({
            type: "addVChartProperty",
            options: {
                beforeCall: initHierarchyKeyMap.bind(this),
                call: addHierarchyDataKey
            }
        }));
    }
    initMark() {
        this._initCirclePackingMark(), this._initLabelMark();
    }
    initMarkStyle() {
        this._initCirclePackingMarkStyle(), this._initLabelMarkStyle();
    }
    _initCirclePackingMark() {
        var _a;
        if (!1 === (null === (_a = this._circlePacking) || void 0 === _a ? void 0 : _a.visible)) return;
        const circlePacking = this._createMark(CirclePackingSeries.mark.circlePacking, {
            isSeriesMark: !0
        });
        this._circlePackingMark = circlePacking;
    }
    _initCirclePackingMarkStyle() {
        isNil(this._circlePackingMark) || this.setMarkStyle(this._circlePackingMark, {
            x: d => d.x,
            y: d => d.y,
            outerRadius: d => d.radius,
            innerRadius: 0,
            startAngle: 0,
            endAngle: 2 * Math.PI,
            fill: this.getColorAttribute(),
            zIndex: d => d.depth
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
    }
    _initLabelMark() {
        var _a;
        if (!1 === (null === (_a = this._label) || void 0 === _a ? void 0 : _a.visible)) return;
        const labelMark = this._createMark(CirclePackingSeries.mark.label, {
            isSeriesMark: !1
        });
        this._labelMark = labelMark;
    }
    _initLabelMarkStyle() {
        isNil(this._labelMark) || this.setMarkStyle(this._labelMark, {
            x: d => d.x,
            y: d => d.y,
            text: d => d.key,
            cursor: "pointer"
        }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
    }
    getStatisticFields() {
        return appendHierarchyFields(super.getStatisticFields(), this._categoryField, this._valueField);
    }
    initTooltip() {
        this._tooltipHelper = new CirclePackingTooltipHelper(this), this._circlePackingMark && this._tooltipHelper.activeTriggerSet.mark.add(this._circlePackingMark), 
        this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
    }
    initAnimation() {
        var _a;
        const appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
        this.getMarksInType("arc").forEach((mark => {
            var _a;
            mark.setAnimationConfig(animationConfig(null === (_a = Factory.getAnimationInKey("circlePacking")) || void 0 === _a ? void 0 : _a(void 0, appearPreset), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
        })), this.getMarksInType("text").forEach((mark => {
            var _a;
            mark.setAnimationConfig(animationConfig(null === (_a = Factory.getAnimationInKey("scaleInOut")) || void 0 === _a ? void 0 : _a(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
        }));
    }
    initEvent() {
        super.initEvent(), this._spec.drill && this.bindDrillEvent();
    }
    onLayoutEnd() {
        super.onLayoutEnd(), this._rawData.reRunAllTransform();
    }
    _noAnimationDataKey(datum, index) {}
    getActiveMarks() {
        return [ this._circlePackingMark ];
    }
    getMarkData(datum) {
        return (null == datum ? void 0 : datum.datum) ? datum.datum[datum.datum.length - 1] : datum;
    }
}

CirclePackingSeries.type = SeriesTypeEnum.circlePacking, CirclePackingSeries.mark = circlePackingSeriesMark, 
CirclePackingSeries.builtInTheme = {
    circlePacking: circlePacking
}, mixin(CirclePackingSeries, Drillable);

export const registerCirclePackingSeries = () => {
    Factory.registerSeries(CirclePackingSeries.type, CirclePackingSeries), registerArcMark(), 
    registerTextMark(), registerScaleInOutAnimation(), registerCirclePackingAnimation();
};
//# sourceMappingURL=circle-packing.js.map
