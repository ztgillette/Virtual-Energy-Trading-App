import { computeRatio, getInnerMostElements } from "./utils";

import { isEmpty, maxInArray, minInArray } from "@visactor/vutils";

const computeInnerAngleRange = (graphics, startAngle, endAngle) => {
    if (isEmpty(graphics)) return [ startAngle, endAngle ];
    return [ minInArray(graphics.map((m => 1 * m.getFinalAttribute().startAngle))), maxInArray(graphics.map((m => 1 * m.getFinalAttribute().endAngle))) ];
};

export const sunburstEnter = params => ({
    channel: {
        startAngle: {
            from: (d, graphic) => {
                const {startAngle: startAngle, endAngle: endAngle} = params.animationInfo(), innerElements = getInnerMostElements(graphic.parent.children), angleRange = computeInnerAngleRange(innerElements, startAngle, endAngle);
                return computeRatio(graphic.getFinalAttribute().startAngle, angleRange) * (endAngle - startAngle) + startAngle;
            },
            to: (d, graphic) => graphic.getFinalAttribute().startAngle
        },
        endAngle: {
            from: (d, graphic) => {
                const {startAngle: startAngle, endAngle: endAngle} = params.animationInfo(), innerElements = getInnerMostElements(graphic.parent.children), angleRange = computeInnerAngleRange(innerElements, startAngle, endAngle);
                return computeRatio(graphic.getFinalAttribute().endAngle, angleRange) * (endAngle - startAngle) + startAngle;
            },
            to: (d, graphic) => graphic.getFinalAttribute().endAngle
        },
        outerRadius: {
            from: (d, graphic) => graphic.getFinalAttribute().innerRadius,
            to: (d, graphic) => graphic.getFinalAttribute().outerRadius
        },
        innerRadius: {
            from: (d, graphic) => graphic.getFinalAttribute().innerRadius,
            to: (d, graphic) => graphic.getFinalAttribute().innerRadius
        }
    }
});
//# sourceMappingURL=enter.js.map
