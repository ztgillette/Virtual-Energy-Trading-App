{"version":3,"sources":["../src/compile/util.ts"],"names":[],"mappings":"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","file":"util.js","sourcesContent":["import { isNil } from '@visactor/vutils';\nimport type { IMorphConfig } from '../animation/spec';\nimport type { IGroupMark, IMark, IMarkRaw } from '../mark/interface';\nimport { MarkTypeEnum } from '../mark/interface';\nimport { groupData } from '../mark/utils/common';\nimport type { DiffResult } from '../typings/common';\nimport type { RenderMode } from '../typings/spec';\n// eslint-disable-next-line no-duplicate-imports\nimport { RenderModeEnum } from '../typings/spec/common';\n\n// TODO: feishu => lark\nexport function toRenderMode(mode: RenderMode): any {\n  switch (mode) {\n    case RenderModeEnum['desktop-browser']:\n    case RenderModeEnum['mobile-browser']:\n      return 'browser';\n    case RenderModeEnum.node:\n    case RenderModeEnum.worker:\n      return 'node';\n    case RenderModeEnum.miniApp:\n    case RenderModeEnum['desktop-miniApp']:\n      return 'feishu';\n    case RenderModeEnum.lynx:\n      return 'lynx';\n    case RenderModeEnum.wx:\n      return 'wx';\n    case RenderModeEnum.tt:\n      return 'tt';\n    case RenderModeEnum.harmony:\n      return 'harmony';\n  }\n  return 'browser';\n}\n\nexport function traverseGroupMark<T>(\n  group: IMark,\n  apply: (mark: IMark) => T,\n  filter?: (mark: IMark) => boolean,\n  leafFirst?: boolean,\n  stop?: boolean\n): T | undefined {\n  const traverse = (mark: IMark): T | undefined => {\n    if (!leafFirst) {\n      if (mark && (!filter || filter(mark))) {\n        const res = apply.call(null, mark);\n\n        if (stop && res) {\n          return res;\n        }\n      }\n    }\n\n    if (mark.type === MarkTypeEnum.group) {\n      const children: IMark[] = (mark as IGroupMark).getMarks();\n\n      if (children) {\n        for (let i = 0; i < children.length; i++) {\n          const res = traverse(children[i]);\n\n          if (res && stop) {\n            return res;\n          }\n        }\n      }\n    }\n\n    if (leafFirst) {\n      if (mark && (!filter || filter(mark))) {\n        const res = apply.call(null, mark);\n\n        if (res && stop) {\n          return res;\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  return traverse(group);\n}\n\nexport function findSimpleMarks(groups: IMark[]): IMark[] {\n  const marks: IMark[] = [];\n\n  groups.forEach(g => {\n    traverseGroupMark(g, (m: IMark) => {\n      if (m.type !== MarkTypeEnum.group && m.type !== MarkTypeEnum.component) {\n        marks.push(m);\n      }\n    });\n  });\n\n  return marks;\n}\n\nexport function diffUpdateByGroup(\n  prev: IMark[],\n  next: IMark[],\n  prevKey: (datum: IMark) => string,\n  nextKey: (datum: IMark) => string\n) {\n  const prevGroup = groupData<IMark>(prev, datum => prevKey(datum as IMark));\n  const nextGroup = groupData<IMark>(next, datum => nextKey(datum as IMark));\n\n  let prevAfterDiff = prev;\n  let nextAfterDiff = next;\n  const update: { prev: IMark[]; next: IMark[] }[] = [];\n  nextGroup.keys.forEach(key => {\n    if (!isNil(key)) {\n      const prevKeyData = prevGroup.data.get(key);\n      const nextKeyData = nextGroup.data.get(key);\n      if (prevKeyData && nextKeyData) {\n        update.push({ prev: prevKeyData, next: nextKeyData });\n        prevAfterDiff = prevAfterDiff.filter(datum => !prevKeyData.includes(datum));\n        nextAfterDiff = nextAfterDiff.filter(datum => !nextKeyData.includes(datum));\n      }\n    }\n  });\n  return {\n    prev: prevAfterDiff,\n    next: nextAfterDiff,\n    update\n  };\n}\n\nexport function diffMarks(\n  prevMarks: IMark[],\n  nextMarks: IMark[],\n  runningConfig: IMorphConfig\n): DiffResult<IMark[], IMark[]> {\n  const diffResult: DiffResult<IMark[], IMark[]> = {\n    enter: [],\n    exit: [],\n    update: []\n  };\n\n  let prevDiffMarks: IMark[] = [];\n  let nextDiffMarks: IMark[] = [];\n\n  // filter out marks & specs which will not morph\n  prevMarks.forEach(mark => {\n    if ((runningConfig.morph && mark.getMarkConfig().morph) || runningConfig.morphAll || runningConfig.reuse) {\n      prevDiffMarks.push(mark);\n    } else {\n      diffResult.exit.push({ prev: [mark] });\n    }\n  });\n  nextMarks.forEach(mark => {\n    if ((runningConfig.morph && mark.getMarkConfig().morph) || runningConfig.morphAll || runningConfig.reuse) {\n      nextDiffMarks.push(mark);\n    } else {\n      diffResult.enter.push({ next: [mark] });\n    }\n  });\n\n  // 1. match by custom key\n  const keyDiffResult = diffUpdateByGroup(\n    prevDiffMarks,\n    nextDiffMarks,\n    mark => mark.getMarkConfig().morphKey,\n    mark => mark.getMarkConfig().morphKey\n  );\n  prevDiffMarks = keyDiffResult.prev;\n  nextDiffMarks = keyDiffResult.next;\n  diffResult.update = diffResult.update.concat(keyDiffResult.update);\n\n  // 2. match by name\n  const nameDiffResult = diffUpdateByGroup(\n    prevDiffMarks,\n    nextDiffMarks,\n    mark => `${mark.getUserId()}`,\n    mark => `${mark.getUserId()}`\n  );\n  prevDiffMarks = nameDiffResult.prev;\n  nextDiffMarks = nameDiffResult.next;\n  diffResult.update = diffResult.update.concat(nameDiffResult.update);\n\n  // 3. match by index\n\n  // FIXME: mark index cannot be get before executing, index is decided by remove/order for now\n  const prevParentGroup = groupData(prevDiffMarks, mark => mark.group?.id?.());\n  const nextParentGroup = groupData(nextDiffMarks, mark => mark.group?.id?.());\n\n  Object.keys(nextParentGroup).forEach(groupName => {\n    const prevChildren = prevParentGroup.data.get(groupName);\n    const nextChildren = nextParentGroup.data.get(groupName);\n    if (prevChildren && nextChildren) {\n      for (let i = 0; i < Math.max(prevChildren.length, nextChildren.length); i += 1) {\n        const prevChild = prevChildren[i];\n        const nextChild = nextChildren[i];\n        if (prevChild && nextChild) {\n          diffResult.update.push({ prev: [prevChild], next: [nextChild] });\n        } else if (prevChild) {\n          diffResult.exit.push({ prev: [prevChild] });\n        } else if (nextChild) {\n          diffResult.enter.push({ next: [nextChild] });\n        }\n      }\n\n      prevDiffMarks = prevDiffMarks.filter(mark => !prevChildren.includes(mark));\n      nextDiffMarks = nextDiffMarks.filter(mark => !nextChildren.includes(mark));\n    }\n  });\n\n  // 4. handle unmatched marks\n  prevDiffMarks.forEach(mark => diffResult.exit.push({ prev: [mark] }));\n  nextDiffMarks.forEach(mark => diffResult.enter.push({ next: [mark] }));\n\n  return diffResult;\n}\n"]}