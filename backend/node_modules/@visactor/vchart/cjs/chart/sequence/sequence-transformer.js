"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.SequenceChartSpecTransformer = void 0;

const vutils_1 = require("@visactor/vutils"), vdataset_1 = require("@visactor/vdataset"), base_1 = require("../base"), series_1 = require("../../series"), util_1 = require("../../util"), scroll_bar_1 = require("../../constant/scroll-bar");

class SequenceChartSpecTransformer extends base_1.BaseChartSpecTransformer {
    _getSeriesDataLength(spec, seriesSpec) {
        var _a, _b;
        if (seriesSpec.data) {
            const _d = (0, vutils_1.array)(seriesSpec.data)[0];
            return _d instanceof vdataset_1.DataView ? null === (_a = _d.latestData) || void 0 === _a ? void 0 : _a.length : null === (_b = _d.values) || void 0 === _b ? void 0 : _b.length;
        }
        const dataTemp = (0, vutils_1.array)(spec.data).find(((_d, index) => seriesSpec.dataId ? _d instanceof vdataset_1.DataView ? _d.name === seriesSpec.dataId : _d.id === seriesSpec.dataId : seriesSpec.dataIndex === index));
        return dataTemp ? dataTemp instanceof vdataset_1.DataView ? dataTemp.latestData.length : dataTemp.values.length : 0;
    }
    addAttrToComponentSpec(componentSpec, attr, value) {
        return Array.isArray(componentSpec) ? componentSpec[0][attr] = value : componentSpec[attr] = value, 
        componentSpec;
    }
    addPaddingRow(rowHeight, rowNum, size) {
        rowHeight.push({
            index: rowNum,
            size: size
        });
    }
    addOrientAxes(region, elements, rowNum, spec) {
        region.push({
            id: `regionAxesRow${rowNum}`
        }), elements.push({
            modelId: `axesRow${rowNum}`,
            col: 1,
            row: rowNum
        }), spec.axes[0].id = `axesRow${rowNum}`, spec.axes[0].regionIndex = Array.from(Array(spec.series.length), ((_, index) => "top" === spec.axes[0].orient ? index + 1 : index));
    }
    transformSpec(spec) {
        var _a, _b, _c, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        super.transformSpec(spec);
        let rowNum = 0;
        const elements = [], region = [], axes = [], scrollBar = [], rowHeight = [], stage = this._option.getCompiler().getStage(), viewLayoutRect_height = (stage.viewWidth, 
        stage.viewHeight);
        let componentsHeight = 0;
        if (null == spec ? void 0 : spec.legends) {
            elements.push({
                modelId: `legendRow${rowNum}`,
                col: 1,
                row: rowNum
            }), this.addAttrToComponentSpec(spec.legends, "id", `legendRow${rowNum}`);
            const legendSpec = (0, vutils_1.array)(spec.legends);
            let legendHeight = null !== (_a = legendSpec[0].height) && void 0 !== _a ? _a : 40;
            if (legendSpec[0].padding) {
                const legendPadding = (0, util_1.normalizeLayoutPaddingSpec)(legendSpec[0].padding);
                legendHeight += Number(null !== (_b = null == legendPadding ? void 0 : legendPadding.bottom) && void 0 !== _b ? _b : 0), 
                legendHeight += Number(null !== (_c = null == legendPadding ? void 0 : legendPadding.top) && void 0 !== _c ? _c : 0), 
                legendSpec[0].offsetY = Number(null !== (_f = null === (_e = legendSpec[0]) || void 0 === _e ? void 0 : _e.offsetY) && void 0 !== _f ? _f : 0) + Number(null !== (_g = null == legendPadding ? void 0 : legendPadding.top) && void 0 !== _g ? _g : 0);
            }
            rowHeight.push({
                index: rowNum,
                size: legendHeight
            }), componentsHeight += legendHeight, rowNum++;
        }
        (null == spec ? void 0 : spec.dataZoom) && (elements.push({
            modelId: `dataZoomRow${rowNum}`,
            col: 1,
            row: rowNum
        }), this.addAttrToComponentSpec(spec.dataZoom, "id", `dataZoomRow${rowNum}`), componentsHeight += 60, 
        rowNum++, this.addPaddingRow(rowHeight, rowNum, 10), componentsHeight += 10, rowNum++), 
        componentsHeight += 60, null !== spec.axes && "top" !== (null === (_j = null === (_h = null == spec ? void 0 : spec.axes) || void 0 === _h ? void 0 : _h[0]) || void 0 === _j ? void 0 : _j.orient) || (this.addOrientAxes(region, elements, rowNum, spec), 
        rowNum++);
        const seriesRegionNum = spec.series.filter((d => d.type !== series_1.SeriesTypeEnum.link)).length, defaultSeriesRowHeight = (viewLayoutRect_height - componentsHeight - 20 * seriesRegionNum) / seriesRegionNum, leftAppendPadding = (null === (_k = null == spec ? void 0 : spec.appendPadding) || void 0 === _k ? void 0 : _k.left) || 0, rightAppendPadding = (null === (_l = null == spec ? void 0 : spec.appendPadding) || void 0 === _l ? void 0 : _l.right) || 0;
        null === (_m = null == spec ? void 0 : spec.series) || void 0 === _m || _m.forEach((seriesSpec => {
            var _a, _b;
            if ([ series_1.SeriesTypeEnum.bar, series_1.SeriesTypeEnum.line, series_1.SeriesTypeEnum.area, series_1.SeriesTypeEnum.dot ].includes(seriesSpec.type)) {
                if (elements.push({
                    modelId: `${seriesSpec.type}Row${rowNum}`,
                    col: 1,
                    row: rowNum
                }), elements.push({
                    modelId: `axesLeftRow${rowNum}`,
                    col: 0,
                    row: rowNum
                }), region.push({
                    id: `${seriesSpec.type}Row${rowNum}`,
                    clip: !1
                }), rowHeight.push({
                    index: rowNum,
                    size: (null == seriesSpec ? void 0 : seriesSpec.height) || defaultSeriesRowHeight
                }), axes.push({
                    orient: "left",
                    id: `axesLeftRow${rowNum}`,
                    type: seriesSpec.type === series_1.SeriesTypeEnum.dot ? "band" : "linear",
                    visible: seriesSpec.type !== series_1.SeriesTypeEnum.dot,
                    title: {
                        visible: !0,
                        autoRotate: !1,
                        style: {
                            text: null == seriesSpec ? void 0 : seriesSpec.barTitle,
                            dx: -20,
                            textBaseline: "middle",
                            textAlign: "end"
                        }
                    },
                    grid: {
                        visible: "boolean" != typeof (null === (_a = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _a ? void 0 : _a.visible) || (null === (_b = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _b ? void 0 : _b.visible),
                        style: (datum, index) => {
                            var _a, _b, _c, _e, _f;
                            let lineWidth = 0;
                            if (0 === index) {
                                const style = null === (_a = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _a ? void 0 : _a.style;
                                lineWidth = null !== (_c = null !== (_b = null == style ? void 0 : style.lineWidth) && void 0 !== _b ? _b : null == style ? void 0 : style.strokeWidth) && void 0 !== _c ? _c : 1;
                            }
                            return {
                                lineWidth: lineWidth,
                                stroke: (null === (_f = null === (_e = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.stroke) || "#dfdfdf",
                                lineDash: [ 0, 0 ]
                            };
                        }
                    },
                    domainLine: {
                        visible: !1
                    },
                    tick: {
                        visible: !1
                    },
                    label: {
                        visible: !1
                    },
                    regionIndex: region.length - 1
                }), seriesSpec.type === series_1.SeriesTypeEnum.dot) {
                    elements.push({
                        modelId: `scrollBarRightRow${rowNum}`,
                        col: 2,
                        row: rowNum
                    });
                    const dataLength = this._getSeriesDataLength(spec, seriesSpec);
                    let ratio = 0;
                    dataLength && (ratio = ((null == seriesSpec ? void 0 : seriesSpec.height) || defaultSeriesRowHeight) / (30 * dataLength)), 
                    scrollBar.push(Object.assign({
                        orient: "right",
                        visible: seriesSpec.type === series_1.SeriesTypeEnum.dot && ratio < 1,
                        id: `scrollBarRightRow${rowNum}`,
                        start: 0,
                        end: Math.min(ratio, 1),
                        filterMode: "axis",
                        regionIndex: region.length - 1,
                        axisId: `axesLeftRow${rowNum}`
                    }, (0, vutils_1.array)(null == spec ? void 0 : spec.scrollBar)[0]));
                }
                seriesSpec.regionIndex = region.length - 1, rowNum++, this.addPaddingRow(rowHeight, rowNum, (null == seriesSpec ? void 0 : seriesSpec.padding) || 20), 
                rowNum++, seriesSpec.leftAppendPadding = leftAppendPadding, seriesSpec.type === series_1.SeriesTypeEnum.dot && (seriesSpec.title.style.dx = -leftAppendPadding, 
                seriesSpec.subTitle.style.dx = -leftAppendPadding);
            }
        })), this.addPaddingRow(rowHeight, rowNum, 20), rowNum++, null === (_o = null == spec ? void 0 : spec.series) || void 0 === _o || _o.forEach((seriesSpec => {
            if (seriesSpec.type === series_1.SeriesTypeEnum.link) {
                const dotRowNum = seriesSpec.dotSeriesIndex + 1;
                elements.push({
                    modelId: `${seriesSpec.type}Row${dotRowNum}`,
                    col: 1,
                    row: dotRowNum - 1
                }), seriesSpec.regionIndex = spec.series[seriesSpec.dotSeriesIndex].regionIndex, 
                seriesSpec.leftAppendPadding = leftAppendPadding, seriesSpec.height = spec.series[seriesSpec.dotSeriesIndex].height, 
                seriesSpec.clipHeight = spec.series[seriesSpec.dotSeriesIndex].clipHeight;
            }
        })), (null == spec ? void 0 : spec.legends) && this.addAttrToComponentSpec(spec.legends, "regionIndex", [ region.length - 1 ]), 
        "bottom" === (null === (_q = null === (_p = null == spec ? void 0 : spec.axes) || void 0 === _p ? void 0 : _p[0]) || void 0 === _q ? void 0 : _q.orient) && (this.addOrientAxes(region, elements, rowNum, spec), 
        rowNum++);
        const layout = {
            type: "grid",
            col: 4,
            row: rowNum,
            colWidth: [ {
                index: 0,
                size: leftAppendPadding
            }, {
                index: 2,
                size: scroll_bar_1.SCROLL_BAR_DEFAULT_SIZE
            }, {
                index: 3,
                size: rightAppendPadding
            } ],
            rowHeight: rowHeight,
            elements: elements
        };
        spec.layout = layout, spec.region = region, null === (_r = spec.axes) || void 0 === _r || _r.push(...axes), 
        spec.scrollBar = scrollBar;
    }
}

exports.SequenceChartSpecTransformer = SequenceChartSpecTransformer;
//# sourceMappingURL=sequence-transformer.js.map
