"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Factory = void 0;

const vdataset_1 = require("@visactor/vdataset");

class Factory {
    static registerChart(key, chart) {
        Factory._charts[key] = chart;
    }
    static registerSeries(key, series) {
        Factory._series[key] = series;
    }
    static registerComponent(key, cmp, alwaysCheck, createOrder) {
        Factory._components[key] = {
            cmp: cmp,
            alwaysCheck: alwaysCheck,
            createOrder: null != createOrder ? createOrder : 0
        };
    }
    static registerGraphicComponent(key, creator) {
        Factory._graphicComponents[key] = creator;
    }
    static createGraphicComponent(componentType, attrs, options) {
        const compCreator = Factory._graphicComponents[componentType];
        return compCreator ? compCreator(attrs, options) : null;
    }
    static registerMark(key, mark) {
        Factory._marks[key] = mark;
    }
    static registerRegion(key, region) {
        Factory._regions[key] = region;
    }
    static registerTransform(key, transform) {
        Factory.transforms[key] = transform;
    }
    static registerGrammarTransform(type, transform) {
        Factory._grammarTransforms[type] = transform;
    }
    static getGrammarTransform(type) {
        return Factory._grammarTransforms[type];
    }
    static registerLayout(key, layout) {
        Factory._layout[key] = layout;
    }
    static registerAnimation(key, animation) {
        Factory._animations[key] = animation;
    }
    static registerImplement(key, implement) {
        Factory._implements[key] = implement;
    }
    static registerChartPlugin(key, plugin) {
        Factory._chartPlugin[key] = plugin;
    }
    static registerVChartPlugin(key, plugin) {
        Factory._vChartPlugin[key] = plugin;
    }
    static registerComponentPlugin(key, plugin) {
        Factory._componentPlugin[key] = plugin;
    }
    static createChart(chartType, spec, options) {
        if (!Factory._charts[chartType]) return null;
        return new (0, Factory._charts[chartType])(spec, options);
    }
    static getChart(chartType) {
        return Factory._charts[chartType];
    }
    static createChartSpecTransformer(chartType, option) {
        if (!Factory._charts[chartType]) return null;
        const ChartConstructor = Factory._charts[chartType];
        return new (0, ChartConstructor.transformerConstructor)(Object.assign({
            seriesType: ChartConstructor.seriesType
        }, option));
    }
    static createRegion(regionType, spec, options) {
        if (!Factory._regions[regionType]) return null;
        return new (0, Factory._regions[regionType])(spec, options);
    }
    static createRegionSpecTransformer(regionType, options) {
        if (!Factory._regions[regionType]) return null;
        return new (0, Factory._regions[regionType].transformerConstructor)(options);
    }
    static createSeries(seriesType, spec, options) {
        if (!Factory._series[seriesType]) return null;
        return new (0, Factory._series[seriesType])(spec, options);
    }
    static createSeriesSpecTransformer(seriesType, options) {
        if (!Factory._series[seriesType]) return null;
        return new (0, Factory._series[seriesType].transformerConstructor)(options);
    }
    static createMark(markType, name, options) {
        if (!Factory._marks[markType]) return null;
        const markInstance = new (0, Factory._marks[markType])(name, options);
        return "group" === markInstance.type && markInstance.setMarkConfig({
            interactive: !1
        }), markInstance;
    }
    static getComponents() {
        return Object.values(Factory._components);
    }
    static getComponentInKey(name) {
        return Factory._components[name].cmp;
    }
    static getLayout() {
        return Object.values(Factory._layout);
    }
    static getLayoutInKey(name) {
        return Factory._layout[name];
    }
    static getSeries() {
        return Object.values(Factory._series);
    }
    static getSeriesInType(type) {
        return Factory._series[type];
    }
    static getRegionInType(type) {
        return Factory._regions[type];
    }
    static getAnimationInKey(key) {
        return Factory._animations[key];
    }
    static getImplementInKey(key) {
        return Factory._implements[key];
    }
    static getSeriesMarkMap(seriesType) {
        return Factory._series[seriesType] ? Factory._series[seriesType].mark : {};
    }
    static getSeriesBuiltInTheme(themeKey) {
        for (const key in Factory._series) {
            const item = Factory._series[key];
            if (item && item.builtInTheme && item.builtInTheme[themeKey]) return item.builtInTheme[themeKey];
        }
        return null;
    }
    static getComponentBuiltInTheme(themeKey) {
        for (const key in Factory._components) {
            const item = Factory._components[key];
            if (item && item.cmp && item.cmp.builtInTheme && item.cmp.builtInTheme[themeKey]) return item.cmp.builtInTheme[themeKey];
        }
        return null;
    }
    static getChartPlugins() {
        return Object.values(Factory._chartPlugin);
    }
    static getVChartPlugins() {
        return Object.values(Factory._vChartPlugin);
    }
    static getComponentPlugins() {
        return Object.values(Factory._componentPlugin);
    }
    static getComponentPluginInType(type) {
        return Factory._componentPlugin[type];
    }
    static registerFormatter(func) {
        this._formatter = func;
    }
    static getFormatter() {
        return this._formatter;
    }
    static createInteractionTrigger(interactionType, options) {
        const Ctor = Factory._interactionTriggers[interactionType];
        return Ctor ? new Ctor(options) : null;
    }
    static hasInteractionTrigger(interactionType) {
        return !!Factory._interactionTriggers[interactionType];
    }
    static getComposedEvent(eType) {
        return Factory._composedEventMap[eType];
    }
}

exports.Factory = Factory, Factory._charts = {}, Factory._series = {}, Factory._components = {}, 
Factory._graphicComponents = {}, Factory._marks = {}, Factory._regions = {}, Factory._animations = {}, 
Factory._implements = {}, Factory._chartPlugin = {}, Factory._vChartPlugin = {}, 
Factory._componentPlugin = {}, Factory.transforms = {
    fields: vdataset_1.fields,
    filter: vdataset_1.filter,
    fold: vdataset_1.fold
}, Factory.dataParser = {
    csv: vdataset_1.csvParser,
    dsv: vdataset_1.dsvParser,
    tsv: vdataset_1.tsvParser
}, Factory._layout = {}, Factory._grammarTransforms = {}, Factory._stageEventPlugins = {}, 
Factory.registerStageEventPlugin = (type, Plugin) => {
    Factory._stageEventPlugins[type] = Plugin;
}, Factory.getStageEventPlugin = type => Factory._stageEventPlugins[type], Factory._interactionTriggers = {}, 
Factory.registerInteractionTrigger = (interactionType, interaction) => {
    Factory._interactionTriggers[interactionType] = interaction;
}, Factory._composedEventMap = {}, Factory.registerComposedEvent = (eType, composedEvent) => {
    Factory._composedEventMap[eType] = composedEvent;
}, Factory._tooltipProcessors = {}, Factory.registerTooltipProcessor = (type, processor) => {
    Factory._tooltipProcessors[type] = processor;
}, Factory.createTooltipProcessor = (type, tooltip) => {
    const Cror = Factory._tooltipProcessors[type];
    return Cror ? new Cror(tooltip) : null;
};
//# sourceMappingURL=factory.js.map