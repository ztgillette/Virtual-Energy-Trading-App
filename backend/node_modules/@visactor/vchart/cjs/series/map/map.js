"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerMapSeries = exports.MapSeries = void 0;

const vutils_1 = require("@visactor/vutils"), vdataset_1 = require("@visactor/vdataset"), geo_source_1 = require("./geo-source"), lookup_1 = require("../../data/transforms/lookup"), geo_1 = require("../geo/geo"), map_1 = require("../../data/transforms/map"), copy_data_view_1 = require("../../data/transforms/copy-data-view"), register_1 = require("../../data/register"), tooltip_helper_1 = require("./tooltip-helper"), data_1 = require("../../constant/data"), attribute_1 = require("../../constant/attribute"), type_1 = require("../interface/type"), utils_1 = require("../../animation/utils"), config_1 = require("../../animation/config"), path_1 = require("../../mark/path"), constant_1 = require("./constant"), factory_1 = require("../../core/factory"), geo_2 = require("../../component/geo"), initialize_1 = require("../../data/initialize"), map_transformer_1 = require("./map-transformer"), data_2 = require("../../compile/data"), map_2 = require("../../theme/builtin/common/series/map");

class MapSeries extends geo_1.GeoSeries {
    constructor() {
        super(...arguments), this.type = type_1.SeriesTypeEnum.map, this.transformerConstructor = map_transformer_1.MapSeriesSpecTransformer, 
        this._areaCache = new Map;
    }
    getNameMap() {
        return this._nameMap;
    }
    get areaPath() {
        return this._areaCache;
    }
    setAttrFromSpec() {
        var _a, _b;
        super.setAttrFromSpec(), this.map = this._spec.map, this._nameMap = this._spec.nameMap, 
        this._nameField = this._spec.nameField, this._valueField = this._spec.valueField, 
        this._spec.nameProperty && (this._nameProperty = this._spec.nameProperty), this._spec.centroidProperty && (this._centroidProperty = this._spec.centroidProperty), 
        this.map || null === (_a = this._option) || void 0 === _a || _a.onError(`map type '${this.map}' is not specified !`), 
        geo_source_1.geoSourceMap.get(this.map) || null === (_b = this._option) || void 0 === _b || _b.onError(`'${this.map}' data is not registered !`);
    }
    initData() {
        var _a, _b;
        super.initData(), (0, register_1.registerDataSetInstanceTransform)(this._dataSet, "copyDataView", copy_data_view_1.copyDataView), 
        (0, register_1.registerDataSetInstanceTransform)(this._dataSet, "map", map_1.map), 
        (0, register_1.registerDataSetInstanceTransform)(this._dataSet, "lookup", lookup_1.lookup);
        const features = geo_source_1.geoSourceMap.get(this.map);
        features || null === (_a = this._option) || void 0 === _a || _a.onError("no valid map data found!");
        const mapData = new vdataset_1.DataView(this._dataSet, {
            name: `map_${this.id}_data`
        });
        mapData.parse([ features ], {
            type: "dataview"
        }).transform({
            type: "copyDataView",
            options: {
                deep: !0
            },
            level: initialize_1.TransformLevel.copyDataView
        }).transform({
            type: "map",
            options: {
                nameMap: this._nameMap,
                nameProperty: this._nameProperty
            }
        }).transform({
            type: "lookup",
            options: {
                from: () => {
                    var _a;
                    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.getLatestData();
                },
                key: map_1.DEFAULT_MAP_LOOK_UP_KEY,
                fields: this._nameField,
                set: (feature, datum) => {
                    datum && Object.keys(datum).forEach((key => {
                        key in feature || (feature[key] = datum[key]);
                    }));
                }
            }
        }), null === (_b = this._data) || void 0 === _b || _b.getDataView().target.addListener("change", mapData.reRunAllTransform), 
        this._mapViewData = new data_2.CompilableData(this._option, mapData);
    }
    compileData() {
        var _a;
        super.compileData(), null === (_a = this._mapViewData) || void 0 === _a || _a.compile();
    }
    initMark() {
        this._pathMark = this._createMark(MapSeries.mark.area, {
            groupKey: this.getDimensionField()[0],
            isSeriesMark: !0
        }, {
            morph: (0, utils_1.shouldMarkDoMorph)(this._spec, MapSeries.mark.area.name),
            morphElementKey: this.getDimensionField()[0]
        }), this._pathMark.setData(this._mapViewData);
    }
    initMarkStyle() {
        const pathMark = this._pathMark;
        pathMark && (this.setMarkStyle(pathMark, {
            fill: datum => {
                var _a, _b, _c, _d;
                return (0, vutils_1.isValid)(datum[null !== (_a = this._seriesField) && void 0 !== _a ? _a : data_1.DEFAULT_DATA_SERIES_FIELD]) ? (null !== (_b = this._option.globalScale.getScale("color")) && void 0 !== _b ? _b : this._getDefaultColorScale()).scale(datum[null !== (_c = this._seriesField) && void 0 !== _c ? _c : data_1.DEFAULT_DATA_SERIES_FIELD]) : null === (_d = this._spec) || void 0 === _d ? void 0 : _d.defaultFillColor;
            },
            path: this.getPath.bind(this)
        }, "normal", attribute_1.AttributeLevel.Series), pathMark.setPostProcess("fill", (result => (0, 
        vutils_1.isValid)(result) ? result : this._spec.defaultFillColor)), this.setMarkStyle(pathMark, {
            smoothScale: !0
        }, "normal", attribute_1.AttributeLevel.Built_In));
    }
    initLabelMarkStyle(labelMark) {
        labelMark && (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
            text: datum => this.getDatumName(datum),
            x: datum => {
                var _a;
                return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.x;
            },
            y: datum => {
                var _a;
                return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.y;
            }
        }));
    }
    initAnimation() {
        var _a;
        this._pathMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_a = factory_1.Factory.getAnimationInKey("fadeInOut")) || void 0 === _a ? void 0 : _a(), (0, 
        utils_1.userAnimationConfig)("area", this._spec, this._markAttributeContext)));
    }
    initTooltip() {
        this._tooltipHelper = new tooltip_helper_1.MapSeriesTooltipHelper(this), this._pathMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pathMark);
    }
    getPath(datum) {
        var _a;
        const area = this._areaCache.get(datum[data_1.DEFAULT_DATA_INDEX]);
        if (area) return area.shape;
        const shape = null === (_a = this._coordinateHelper) || void 0 === _a ? void 0 : _a.shape(datum);
        return this._areaCache.set(datum[data_1.DEFAULT_DATA_INDEX], {
            shape: shape
        }), shape;
    }
    onEvaluateEnd() {
        this._mapViewData.updateData();
    }
    getDimensionField() {
        return [ this.nameField ];
    }
    getMeasureField() {
        return [ this.valueField ];
    }
    release() {
        super.release(), this._areaCache.clear(), this._nameMap = {}, this._mapViewData = null;
    }
    handleZoom(e) {
        var _a;
        const {scale: scale, scaleCenter: scaleCenter} = e;
        if (1 === scale) return;
        const pathGroup = this.getRootMark().getProduct();
        pathGroup && (pathGroup.attribute.postMatrix || pathGroup.setAttributes({
            postMatrix: new vutils_1.Matrix
        }), pathGroup.scale(scale, scale, scaleCenter));
        const vgrammarLabel = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent();
        vgrammarLabel && vgrammarLabel.renderInner();
    }
    handlePan(e) {
        var _a;
        const {delta: delta} = e;
        if (0 === delta[0] && 0 === delta[1]) return;
        const pathGroup = this.getRootMark().getProduct();
        pathGroup && (pathGroup.attribute.postMatrix || pathGroup.setAttributes({
            postMatrix: new vutils_1.Matrix
        }), pathGroup.translate(delta[0], delta[1]));
        const vgrammarLabel = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent();
        vgrammarLabel && vgrammarLabel.renderInner();
    }
    getDatumCenter(datum) {
        var _a, _b, _c, _d;
        return this._centroidProperty && (null === (_a = datum.properties) || void 0 === _a ? void 0 : _a[this._centroidProperty]) ? null === (_b = datum.properties) || void 0 === _b ? void 0 : _b[this._centroidProperty] : (0, 
        vutils_1.isValidNumber)(datum.centroidX * datum.centroidY) ? [ datum.centroidX, datum.centroidY ] : (null === (_c = datum.properties) || void 0 === _c ? void 0 : _c.center) ? datum.properties.center : (null === (_d = datum.properties) || void 0 === _d ? void 0 : _d.centroid) ? datum.properties.centroid : [ Number.NaN, Number.NaN ];
    }
    getDatumName(datum) {
        var _a;
        if (datum[this.nameField]) return datum[this.nameField];
        const name = null === (_a = datum.properties) || void 0 === _a ? void 0 : _a[this._nameProperty];
        if (name) {
            if (this._spec.nameMap && this._spec.nameMap[name]) return this._spec.nameMap[name];
            if (this._spec.showDefaultName || !this._spec.nameMap) return name;
        }
        return "";
    }
    dataToPositionX(data) {
        var _a;
        return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 
        0;
    }
    dataToPositionY(data) {
        var _a;
        return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 
        0;
    }
    viewDataUpdate(d) {
        var _a, _b, _c;
        super.viewDataUpdate(d), null === (_b = null === (_a = this._mapViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform(), 
        null === (_c = this._mapViewData) || void 0 === _c || _c.updateData();
    }
    _getDataIdKey() {
        return data_1.DEFAULT_DATA_INDEX;
    }
    getActiveMarks() {
        return [ this._pathMark ];
    }
}

exports.MapSeries = MapSeries, MapSeries.type = type_1.SeriesTypeEnum.map, MapSeries.mark = constant_1.mapSeriesMark, 
MapSeries.builtInTheme = {
    map: map_2.map
}, MapSeries.transformerConstructor = map_transformer_1.MapSeriesSpecTransformer;

const registerMapSeries = () => {
    (0, geo_2.registerGeoCoordinate)(), (0, path_1.registerPathMark)(), factory_1.Factory.registerSeries(MapSeries.type, MapSeries), 
    factory_1.Factory.registerImplement("registerMap", geo_source_1.registerMapSource), 
    factory_1.Factory.registerImplement("unregisterMap", geo_source_1.unregisterMapSource), 
    (0, config_1.registerFadeInOutAnimation)();
};

exports.registerMapSeries = registerMapSeries;
//# sourceMappingURL=map.js.map
