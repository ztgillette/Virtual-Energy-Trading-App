"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerMosaicSeries = exports.MosaicSeries = void 0;

const bar_1 = require("../bar/bar"), type_1 = require("../interface/type"), rect_1 = require("../../mark/rect"), text_1 = require("../../mark/text"), config_1 = require("../../animation/config"), factory_1 = require("../../core/factory"), bar_transformer_1 = require("../bar/bar-transformer"), cartesian_1 = require("../../component/axis/cartesian"), data_1 = require("../../constant/data"), vutils_1 = require("@visactor/vutils"), mosaic_1 = require("../../theme/builtin/common/series/mosaic");

class MosaicSeries extends bar_1.BarSeries {
    constructor() {
        super(...arguments), this.type = type_1.SeriesTypeEnum.mosaic, this.transformerConstructor = bar_transformer_1.BarSeriesSpecTransformer;
    }
    get bandWidthField() {
        return this._bandWidthField;
    }
    getStack() {
        return !0;
    }
    getPercent() {
        return this._spec.percent;
    }
    getGroupFields() {
        return "vertical" === this.direction ? this._specXField : this._specYField;
    }
    setAttrFromSpec() {
        super.setAttrFromSpec();
        const isPercent = this.getPercent();
        "horizontal" === this.direction ? (isPercent && (this.setFieldX(data_1.MOSAIC_VALUE_END_PERCENT), 
        this.setFieldX2(data_1.MOSAIC_VALUE_START_PERCENT)), this.setFieldY(data_1.MOSAIC_CAT_END_PERCENT), 
        this.setFieldY2(data_1.MOSAIC_CAT_START_PERCENT)) : (isPercent && (this.setFieldY(data_1.MOSAIC_VALUE_END_PERCENT), 
        this.setFieldY2(data_1.MOSAIC_VALUE_START_PERCENT)), this.setFieldX(data_1.MOSAIC_CAT_END_PERCENT), 
        this.setFieldX2(data_1.MOSAIC_CAT_START_PERCENT)), this._spec.bandWidthField && (this._bandWidthField = this._spec.bandWidthField);
    }
    parseLabelStyle(labelStyle, labelSpec) {
        if ((null == labelSpec ? void 0 : labelSpec.filterByGroup) && (0, vutils_1.isNil)(labelStyle.dataFilter)) {
            const allGroupFields = this.getGroupFields(), {field: field, type: filterType = "max", filter: filter} = labelSpec.filterByGroup;
            delete labelStyle.filterField;
            const fieldIndex = allGroupFields.indexOf(field);
            if (fieldIndex < 0) return;
            const valueField = !!(fieldIndex % 2) ? "min" === filterType ? "horizontal" === this.direction ? this._fieldY2 : this._fieldX2 : "horizontal" === this.direction ? this._fieldY : this._fieldX : "min" === filterType ? "horizontal" === this.direction ? this._fieldX2 : this._fieldY2 : "horizontal" === this.direction ? this._fieldX : this._fieldY, filterFunc = "min" === filterType ? (a, b) => {
                var _a, _b;
                return (null === (_a = a.data) || void 0 === _a ? void 0 : _a[valueField]) < (null === (_b = b.data) || void 0 === _b ? void 0 : _b[valueField]);
            } : (a, b) => {
                var _a, _b;
                return (null === (_a = a.data) || void 0 === _a ? void 0 : _a[valueField]) > (null === (_b = b.data) || void 0 === _b ? void 0 : _b[valueField]);
            };
            labelStyle.dataFilter = data => {
                const filteredData = {};
                return data.forEach((d => {
                    const datum = d.data, fieldValue = null == datum ? void 0 : datum[field];
                    (0, vutils_1.isNil)(fieldValue) || filter && !filter(d) || filteredData[fieldValue] && !filterFunc(d, filteredData[fieldValue]) || (filteredData[fieldValue] = d);
                })), data.filter((d => {
                    var _a;
                    const fieldValue = null === (_a = d.data) || void 0 === _a ? void 0 : _a[field];
                    return filteredData[fieldValue] && filteredData[fieldValue] === d;
                }));
            };
        }
        return labelStyle;
    }
}

exports.MosaicSeries = MosaicSeries, MosaicSeries.type = type_1.SeriesTypeEnum.mosaic, 
MosaicSeries.builtInTheme = {
    mosaic: mosaic_1.mosaic
}, MosaicSeries.transformerConstructor = bar_transformer_1.BarSeriesSpecTransformer;

const registerMosaicSeries = () => {
    (0, rect_1.registerRectMark)(), (0, text_1.registerTextMark)(), (0, config_1.registerFadeInOutAnimation)(), 
    (0, cartesian_1.registerCartesianLinearAxis)(), factory_1.Factory.registerSeries(MosaicSeries.type, MosaicSeries);
};

exports.registerMosaicSeries = registerMosaicSeries;
//# sourceMappingURL=mosaic.js.map
