"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerCircularProgressSeries = exports.CircularProgressSeries = void 0;

const vutils_1 = require("@visactor/vutils"), type_1 = require("../../interface/type"), utils_1 = require("../../../animation/utils"), progress_like_1 = require("../../polar/progress-like/progress-like"), arc_1 = require("../../../mark/arc"), constant_1 = require("./constant"), data_1 = require("../../../constant/data"), attribute_1 = require("../../../constant/attribute"), factory_1 = require("../../../core/factory"), progress_like_2 = require("../../polar/progress-like"), config_1 = require("../../../animation/config"), circular_transformer_1 = require("./circular-transformer"), polar_1 = require("../../../component/axis/polar"), circular_progress_1 = require("../../../theme/builtin/common/series/circular-progress");

class CircularProgressSeries extends progress_like_1.ProgressLikeSeries {
    constructor() {
        super(...arguments), this.type = type_1.SeriesTypeEnum.circularProgress, this.transformerConstructor = circular_transformer_1.CircularProgressSeriesSpecTransformer, 
        this._progressMark = null, this._trackMark = null, this._getRadiusValueStart = datum => {
            if (this.getGroupFields().length > 1) {
                const value = this.radiusAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields()));
                if ((0, vutils_1.isValidNumber)(value)) return value;
            }
            return this.radiusAxisHelper.dataToPosition([ datum[this._radiusField[0]] ]);
        }, this._getRadiusValueEnd = datum => {
            var _a, _b;
            if (this.getGroupFields().length > 1) {
                const value = this.radiusAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields())) + (null === (_b = (_a = this.radiusAxisHelper).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, this._groups ? this._groups.fields.length - 1 : 0));
                if ((0, vutils_1.isValidNumber)(value)) return value;
            }
            return this.radiusAxisHelper.dataToPosition([ datum[this._radiusField[0]] ]) + this.radiusAxisHelper.getScale(0).step();
        };
    }
    getStackGroupFields() {
        return this.getGroupFields();
    }
    getGroupFields() {
        return this._radiusField;
    }
    initMark() {
        super.initMark(), this._initTrackMark(), this._initProgressMark();
    }
    initMarkStyle() {
        super.initMarkStyle(), this._initTrackMarkStyle(), this._initProgressMarkStyle();
    }
    _initProgressMark() {
        return this._progressMark = this._createMark(CircularProgressSeries.mark.progress, {
            parent: this._arcGroupMark,
            isSeriesMark: !0
        }, {
            morph: (0, utils_1.shouldMarkDoMorph)(this._spec, "progress")
        }), this._progressMark;
    }
    _initProgressMarkStyle() {
        var _a;
        const progressMark = this._progressMark;
        progressMark && this.setMarkStyle(progressMark, {
            x: () => this.angleAxisHelper.center().x,
            y: () => this.angleAxisHelper.center().y,
            startAngle: this._getAngleValueStart,
            endAngle: this._getAngleValueEnd,
            innerRadius: this._getRadiusValueStart,
            outerRadius: this._getRadiusValueEnd,
            cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
            boundsMode: "imprecise",
            cornerRadius: this._spec.cornerRadius,
            fill: this.getColorAttribute(),
            zIndex: 200,
            forceShowCap: !0
        }, "normal", attribute_1.AttributeLevel.Series);
    }
    getInteractionTriggers() {
        const marks = [];
        return this._trackMark && marks.push(this._trackMark), this._progressMark && marks.push(this._progressMark), 
        this._parseInteractionConfig(marks);
    }
    initTooltip() {
        super.initTooltip(), this._progressMark && this._tooltipHelper.activeTriggerSet.mark.add(this._progressMark);
    }
    _initTrackMark() {
        return this._trackMark = this._createMark(CircularProgressSeries.mark.track, {
            parent: this._arcGroupMark
        }), this._trackMark.setMarkConfig({
            morph: !1,
            morphKey: null,
            morphElementKey: null
        }), this._trackMark;
    }
    _initTrackMarkStyle() {
        const trackMark = this._trackMark;
        trackMark && this.setMarkStyle(trackMark, {
            visible: datum => {
                const range = this.angleAxisHelper.getScale(0).range(), min = Math.min(range[0], range[range.length - 1]), startValue = this._getAngleValueStartWithoutMask(datum);
                return Math.abs(startValue - min) <= 1e-14;
            },
            x: () => this.angleAxisHelper.center().x,
            y: () => this.angleAxisHelper.center().y,
            startAngle: () => {
                const fieldName = this.getStack() ? data_1.STACK_FIELD_START : this._angleField[0], domain = this.angleAxisHelper.getScale(0).domain();
                return this._getAngleValueStart({
                    [fieldName]: domain[0]
                });
            },
            endAngle: () => {
                const fieldName = this.getStack() ? data_1.STACK_FIELD_END : this._angleField[0], domain = this.angleAxisHelper.getScale(0).domain();
                return this._getAngleValueEnd({
                    [fieldName]: domain[domain.length - 1]
                });
            },
            innerRadius: this._getRadiusValueStart,
            outerRadius: this._getRadiusValueEnd,
            cornerRadius: this._spec.cornerRadius,
            fill: this.getColorAttribute(),
            zIndex: 100
        }, "normal", attribute_1.AttributeLevel.Series);
    }
    initAnimation() {
        var _a, _b, _c, _d;
        const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._progressMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_c = factory_1.Factory.getAnimationInKey("circularProgress")) || void 0 === _c ? void 0 : _c({
            startAngle: this._startAngle
        }, appearPreset), (0, utils_1.userAnimationConfig)("progress", this._spec, this._markAttributeContext))), 
        this._trackMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_d = factory_1.Factory.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), (0, 
        utils_1.userAnimationConfig)("track", this._spec, this._markAttributeContext)));
    }
    getActiveMarks() {
        return [ this._progressMark ];
    }
}

exports.CircularProgressSeries = CircularProgressSeries, CircularProgressSeries.type = type_1.SeriesTypeEnum.circularProgress, 
CircularProgressSeries.mark = constant_1.circularProgressSeriesMark, CircularProgressSeries.builtInTheme = {
    circularProgress: circular_progress_1.circularProgress
}, CircularProgressSeries.transformerConstructor = circular_transformer_1.CircularProgressSeriesSpecTransformer;

const registerCircularProgressSeries = () => {
    factory_1.Factory.registerSeries(CircularProgressSeries.type, CircularProgressSeries), 
    (0, arc_1.registerArcMark)(), (0, progress_like_2.registerProgressLikeAnimation)(), 
    (0, config_1.registerFadeInOutAnimation)(), (0, polar_1.registerPolarBandAxis)(), 
    (0, polar_1.registerPolarLinearAxis)();
};

exports.registerCircularProgressSeries = registerCircularProgressSeries;
//# sourceMappingURL=circular.js.map
