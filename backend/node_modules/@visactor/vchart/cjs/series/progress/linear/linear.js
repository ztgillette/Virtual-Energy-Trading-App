"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerLinearProgressSeries = exports.LinearProgressSeries = void 0;

const cartesian_1 = require("../../cartesian/cartesian"), type_1 = require("../../interface/type"), scale_1 = require("../../../util/scale"), attribute_1 = require("../../../constant/attribute"), utils_1 = require("../../../animation/utils"), animation_1 = require("./animation"), tooltip_helper_1 = require("./tooltip-helper"), rect_1 = require("../../../mark/rect"), constant_1 = require("./constant"), factory_1 = require("../../../core/factory"), config_1 = require("../../../animation/config"), vutils_1 = require("@visactor/vutils"), linear_progress_1 = require("../../../theme/builtin/common/series/linear-progress");

class LinearProgressSeries extends cartesian_1.CartesianSeries {
    constructor() {
        super(...arguments), this.type = type_1.SeriesTypeEnum.linearProgress, this._progressMark = null, 
        this._trackMark = null, this._defaultProgressCustomShape = (datum, attrs, path) => {
            var _a, _b;
            const cornerRadius = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.cornerRadius, width = (0, 
            vutils_1.isValid)(attrs.width) ? attrs.width : attrs.x1 - attrs.x, height = (0, 
            vutils_1.isValid)(attrs.height) ? attrs.height : attrs.y1 - attrs.y, x0 = Math.min(0, width), x1 = Math.max(0, width), y0 = Math.min(0, height), y1 = Math.max(0, height);
            if (cornerRadius > 0) {
                let realCornerRadius = cornerRadius;
                if ("vertical" === (null === (_b = this._spec) || void 0 === _b ? void 0 : _b.direction)) {
                    if (realCornerRadius = Math.min(Math.abs(width / 2), cornerRadius), 2 * realCornerRadius > Math.abs(height)) {
                        const angle = Math.acos((realCornerRadius - Math.abs(height) / 2) / realCornerRadius);
                        return path.moveTo(x0 + realCornerRadius, y0), path.arc(x0 + realCornerRadius, y0 + realCornerRadius, realCornerRadius, 1.5 * Math.PI, 1.5 * Math.PI - angle, !0), 
                        path.arc(x0 + realCornerRadius, y1 - realCornerRadius, realCornerRadius, angle + Math.PI / 2, Math.PI / 2, !0), 
                        path.lineTo(x1 - cornerRadius, y1), path.arc(x1 - realCornerRadius, y1 - realCornerRadius, realCornerRadius, Math.PI / 2, Math.PI / 2 - angle, !0), 
                        path.arc(x1 - realCornerRadius, y0 + realCornerRadius, realCornerRadius, -Math.PI / 2 + angle, -Math.PI / 2, !0), 
                        path.lineTo(x0 + realCornerRadius, y0), path.closePath(), path;
                    }
                } else if (realCornerRadius = Math.min(Math.abs(height / 2), cornerRadius), 2 * realCornerRadius > Math.abs(width)) {
                    const angle = Math.acos((realCornerRadius - Math.abs(width) / 2) / realCornerRadius);
                    return path.moveTo(x0, y0 + realCornerRadius), path.arc(x0 + realCornerRadius, y0 + realCornerRadius, realCornerRadius, Math.PI, Math.PI + angle), 
                    path.arc(x1 - realCornerRadius, y0 + realCornerRadius, realCornerRadius, -angle, 0), 
                    path.lineTo(x1, y1 - realCornerRadius), path.arc(x1 - realCornerRadius, y1 - realCornerRadius, realCornerRadius, 0, angle), 
                    path.arc(x0 + realCornerRadius, y1 - realCornerRadius, realCornerRadius, Math.PI - angle, Math.PI), 
                    path.closePath(), path;
                }
                path.moveTo(x0, y0 + realCornerRadius), path.arc(x0 + realCornerRadius, y0 + realCornerRadius, realCornerRadius, Math.PI, 1.5 * Math.PI), 
                path.lineTo(x1 - realCornerRadius, y0), path.arc(x1 - realCornerRadius, y0 + realCornerRadius, realCornerRadius, -Math.PI / 2, 0), 
                path.lineTo(x1, y1 - realCornerRadius), path.arc(x1 - realCornerRadius, y1 - realCornerRadius, realCornerRadius, 0, Math.PI / 2), 
                path.lineTo(x0 + realCornerRadius, y1), path.arc(x0 + realCornerRadius, y1 - realCornerRadius, realCornerRadius, Math.PI / 2, Math.PI), 
                path.closePath();
            } else path.moveTo(x0, y0), path.lineTo(x1, y0), path.lineTo(x1, y1), path.lineTo(x0, y1), 
            path.closePath();
            return path;
        };
    }
    initMark() {
        this._initTrackMark(), this._initProgressMark();
    }
    initMarkStyle() {
        this._initTrackMarkStyle(), this._initProgressMarkStyle();
    }
    _initProgressMark() {
        var _a;
        return this._progressMark = this._createMark(LinearProgressSeries.mark.progress, {
            isSeriesMark: !0
        }), (0, vutils_1.isNil)(null === (_a = this._spec.progress) || void 0 === _a ? void 0 : _a.customShape) && this._progressMark.setMarkConfig({
            setCustomizedShape: this._defaultProgressCustomShape
        }), this._progressMark;
    }
    _initProgressMarkStyle() {
        var _a, _b, _c, _d;
        const progressMark = this._progressMark;
        if (progressMark) if ("vertical" === this._spec.direction) {
            const progress = this._spec.progress || {}, leftPadding = null !== (_a = progress.leftPadding) && void 0 !== _a ? _a : 0, rightPadding = null !== (_b = progress.rightPadding) && void 0 !== _b ? _b : 0;
            this.setMarkStyle(progressMark, {
                x: datum => {
                    var _a, _b;
                    return (0, scale_1.valueInScaleRange)(this.dataToPositionX(datum), null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), !0) - this._spec.bandWidth / 2 + leftPadding;
                },
                y1: datum => {
                    var _a, _b;
                    return (0, scale_1.valueInScaleRange)(this.dataToPositionY(datum), null === (_b = null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0));
                },
                y: () => {
                    var _a, _b, _c;
                    const value = null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.dataToPosition([ 0 ], {
                        bandPosition: this._bandPosition
                    });
                    return this._spec.clamp ? (0, scale_1.valueInScaleRange)(value, null === (_c = null === (_b = this._yAxisHelper) || void 0 === _b ? void 0 : _b.getScale) || void 0 === _c ? void 0 : _c.call(_b, 0)) : value;
                },
                width: this._spec.bandWidth - leftPadding - rightPadding,
                cornerRadius: this._spec.cornerRadius,
                fill: this.getColorAttribute()
            }, "normal", attribute_1.AttributeLevel.Series);
        } else {
            const progress = this._spec.progress || {}, topPadding = null !== (_c = progress.topPadding) && void 0 !== _c ? _c : 0, bottomPadding = null !== (_d = progress.bottomPadding) && void 0 !== _d ? _d : 0;
            this.setMarkStyle(progressMark, {
                x1: datum => {
                    var _a, _b;
                    return (0, scale_1.valueInScaleRange)(this.dataToPositionX(datum), null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0));
                },
                y: datum => {
                    var _a, _b;
                    return (0, scale_1.valueInScaleRange)(this.dataToPositionY(datum), null === (_b = null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), !0) - this._spec.bandWidth / 2 + topPadding;
                },
                height: this._spec.bandWidth - topPadding - bottomPadding,
                x: () => {
                    var _a, _b, _c;
                    const value = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.dataToPosition([ 0 ], {
                        bandPosition: this._bandPosition
                    });
                    return this._spec.clamp ? (0, scale_1.valueInScaleRange)(value, null === (_c = null === (_b = this._xAxisHelper) || void 0 === _b ? void 0 : _b.getScale) || void 0 === _c ? void 0 : _c.call(_b, 0)) : value;
                },
                cornerRadius: this._spec.cornerRadius,
                fill: this.getColorAttribute()
            }, "normal", attribute_1.AttributeLevel.Series);
        }
    }
    _initTrackMark() {
        return this._trackMark = this._createMark(LinearProgressSeries.mark.track), this._trackMark;
    }
    _initTrackMarkStyle() {
        const trackMark = this._trackMark;
        trackMark && ("vertical" === this._spec.direction ? this.setMarkStyle(trackMark, {
            x: datum => {
                var _a, _b;
                return (0, scale_1.valueInScaleRange)(this.dataToPositionX(datum), null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), !0) - this._spec.bandWidth / 2;
            },
            y: 0,
            width: this._spec.bandWidth,
            height: () => this._scaleY.range()[0],
            cornerRadius: this._spec.cornerRadius
        }, "normal", attribute_1.AttributeLevel.Series) : this.setMarkStyle(trackMark, {
            x: 0,
            y: datum => {
                var _a, _b;
                return (0, scale_1.valueInScaleRange)(this.dataToPositionY(datum), null === (_b = null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), !0) - this._spec.bandWidth / 2;
            },
            height: this._spec.bandWidth,
            width: () => this._scaleX.range()[1],
            cornerRadius: this._spec.cornerRadius
        }, "normal", attribute_1.AttributeLevel.Series));
    }
    getInteractionTriggers() {
        const marks = [];
        return this._trackMark && marks.push(this._trackMark), this._progressMark && marks.push(this._progressMark), 
        this._parseInteractionConfig(marks);
    }
    initAnimation() {
        var _a, _b, _c, _d;
        const animationParams = {
            direction: this.direction
        }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._progressMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_c = factory_1.Factory.getAnimationInKey("linearProgress")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), (0, 
        utils_1.userAnimationConfig)("progress", this._spec, this._markAttributeContext))), 
        this._trackMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_d = factory_1.Factory.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), (0, 
        utils_1.userAnimationConfig)("track", this._spec, this._markAttributeContext)));
    }
    initTooltip() {
        this._tooltipHelper = new tooltip_helper_1.LinearProgressSeriesTooltipHelper(this), 
        this._progressMark && this._tooltipHelper.activeTriggerSet.mark.add(this._progressMark), 
        this._trackMark && this._tooltipHelper.activeTriggerSet.mark.add(this._trackMark);
    }
    getActiveMarks() {
        return [ this._progressMark ];
    }
}

exports.LinearProgressSeries = LinearProgressSeries, LinearProgressSeries.type = type_1.SeriesTypeEnum.linearProgress, 
LinearProgressSeries.mark = constant_1.linearProgressSeriesMark, LinearProgressSeries.builtInTheme = {
    linearProgress: linear_progress_1.linearProgress
};

const registerLinearProgressSeries = () => {
    (0, rect_1.registerRectMark)(), (0, animation_1.registerLinearProgressAnimation)(), 
    (0, config_1.registerFadeInOutAnimation)(), factory_1.Factory.registerSeries(LinearProgressSeries.type, LinearProgressSeries);
};

exports.registerLinearProgressSeries = registerLinearProgressSeries;
//# sourceMappingURL=linear.js.map
