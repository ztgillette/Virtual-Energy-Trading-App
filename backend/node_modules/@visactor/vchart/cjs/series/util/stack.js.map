{"version":3,"sources":["../src/series/util/stack.ts"],"names":[],"mappings":"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","file":"stack.js","sourcesContent":["import type { IBaseScale } from '@visactor/vscale';\nimport type { IStackCacheNode } from '../../util/data';\nimport { valueInScaleRange } from '../../util/scale';\nimport type { ISeries } from '../interface/series';\n\nexport function stackWithMinHeight(\n  stackCache: IStackCacheNode,\n  stackInverse: boolean,\n  context: {\n    isVertical: boolean;\n    start: string;\n    end: string;\n    startMethod: string;\n    endMethod: string;\n    axisHelper: string;\n  }\n) {\n  if (stackCache.values.length > 0) {\n    // temp\n    let lastY: number;\n    // 如果进行了夸系列的排序\n    if (stackCache.sortDatums.length) {\n      let sortDatums = stackCache.sortDatums;\n      if (stackInverse) {\n        sortDatums = stackCache.sortDatums.slice().reverse();\n      }\n      for (let index = 0; index < sortDatums.length; index++) {\n        lastY = computeOneDatumY(\n          sortDatums[index].datum,\n          lastY,\n          sortDatums[index].series,\n          context,\n          sortDatums[index].series[context.axisHelper].getScale?.(0),\n          index === 0\n        );\n      }\n    } else {\n      // 使用基于系列数据顺序的排序\n      // stack one group\n      let seriesInfo = stackCache.series;\n      if (stackInverse) {\n        seriesInfo = seriesInfo.slice().reverse();\n      }\n      seriesInfo.forEach(({ s, values }, sIndex) => {\n        const seriesScale = s[context.axisHelper].getScale?.(0);\n        // stack\n        for (let index = 0; index < values.length; index++) {\n          const obj = values[stackInverse ? values.length - 1 - index : index];\n          lastY = computeOneDatumY(obj, lastY, s, context, seriesScale, index === 0 && sIndex === 0);\n        }\n      });\n    }\n  }\n  for (const key in stackCache.nodes) {\n    stackWithMinHeight(stackCache.nodes[key], stackInverse, context);\n  }\n}\n\nfunction computeOneDatumY(\n  obj: any,\n  lastY: number,\n  s: ISeries,\n  context: {\n    isVertical: boolean;\n    start: string;\n    end: string;\n    startMethod: string;\n    endMethod: string;\n    axisHelper: string;\n  },\n  seriesScale: IBaseScale,\n  isFirst: boolean\n) {\n  // stack info in series\n  const barMinHeight = s.getSpec().barMinHeight;\n  const inverse = s[context.axisHelper].isInverse();\n\n  const y1 = valueInScaleRange(s[context.startMethod](obj), seriesScale);\n  let y = valueInScaleRange(s[context.endMethod](obj), seriesScale);\n\n  if (isFirst) {\n    lastY = y1;\n  }\n\n  let height = Math.abs(y1 - y);\n  if (height < barMinHeight) {\n    height = barMinHeight;\n  }\n\n  let flag = 1;\n  if (y < y1) {\n    flag = -1;\n  } else if (y === y1) {\n    flag = context.isVertical ? (inverse ? 1 : -1) : inverse ? -1 : 1;\n  }\n  y = lastY + flag * height;\n  obj[context.start] = lastY;\n  obj[context.end] = y;\n  return y;\n}\n"]}