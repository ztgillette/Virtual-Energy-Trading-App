"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerVennAnimation = exports.VennOverlapAnimation = exports.vennOverlapPresetAnimation = exports.vennCirclePresetAnimation = void 0;

const vrender_animate_1 = require("@visactor/vrender-animate"), vlayouts_1 = require("@visactor/vlayouts"), factory_1 = require("../../core/factory"), vennCirclePresetAnimation = preset => {
    switch (preset) {
      case "fadeIn":
      default:
        return {
            type: "fadeIn"
        };

      case "growIn":
        return {
            type: "growRadiusIn"
        };

      case "scaleIn":
        return {
            type: "scaleIn"
        };
    }
};

exports.vennCirclePresetAnimation = vennCirclePresetAnimation;

const vennOverlapPresetAnimation = preset => {
    switch (preset) {
      case "fadeIn":
      default:
        return {
            type: "fadeIn"
        };

      case "scaleIn":
        return {
            type: "scaleIn"
        };
    }
};

exports.vennOverlapPresetAnimation = vennOverlapPresetAnimation;

class VennOverlapAnimation extends vrender_animate_1.ACustomAnimate {
    onBind() {
        var _a, _b;
        this.fromCircles = {}, null === (_a = (0, vlayouts_1.getCirclesFromArcs)(this.target.attribute.arcs)) || void 0 === _a || _a.forEach((c => {
            this.fromCircles[c.setId] = c;
        })), this.toCircles = {}, null === (_b = (0, vlayouts_1.getCirclesFromArcs)(this.target.getFinalAttribute().arcs)) || void 0 === _b || _b.forEach((c => {
            this.toCircles[c.setId] = c;
        }));
    }
    onUpdate(end, ratio, out) {
        const circles = [];
        Object.keys(this.fromCircles).forEach((key => {
            const fromC = this.fromCircles[key], toC = this.toCircles[key];
            fromC && toC && circles.push({
                radius: fromC.radius + (toC.radius - fromC.radius) * ratio,
                x: fromC.x + (toC.x - fromC.x) * ratio,
                y: fromC.y + (toC.y - fromC.y) * ratio,
                setId: key
            });
        }));
        const arcs = (0, vlayouts_1.getArcsFromCircles)(circles);
        this.target.setAttributes({
            arcs: arcs,
            path: (0, vlayouts_1.getPathFromArcs)(arcs)
        });
    }
}

exports.VennOverlapAnimation = VennOverlapAnimation;

const registerVennAnimation = () => {
    factory_1.Factory.registerAnimation("vennCircle", ((params, preset) => ({
        appear: (0, exports.vennCirclePresetAnimation)(preset),
        enter: {
            type: "growRadiusIn"
        },
        exit: {
            type: "growRadiusOut"
        },
        disappear: {
            type: "growRadiusOut"
        }
    }))), factory_1.Factory.registerAnimation("vennOverlap", ((params, preset) => ({
        appear: (0, exports.vennOverlapPresetAnimation)(preset),
        update: {
            custom: VennOverlapAnimation
        },
        enter: {
            type: "fadeIn"
        },
        exit: {
            type: "fadeOut"
        },
        disappear: {
            type: "fadeOut"
        }
    })));
};

exports.registerVennAnimation = registerVennAnimation;
//# sourceMappingURL=animation.js.map
