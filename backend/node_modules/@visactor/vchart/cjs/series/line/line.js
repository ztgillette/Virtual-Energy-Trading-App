"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerLineSeries = exports.LineSeries = void 0;

const cartesian_1 = require("../cartesian/cartesian"), type_1 = require("../interface/type"), line_mixin_1 = require("../mixin/line-mixin"), vutils_1 = require("@visactor/vutils"), utils_1 = require("../../animation/utils"), config_1 = require("../../animation/config"), constant_1 = require("./constant"), line_1 = require("../../mark/line"), symbol_1 = require("../../mark/symbol"), factory_1 = require("../../core/factory"), line_mixin_transformer_1 = require("../mixin/line-mixin-transformer"), utils_2 = require("../util/utils"), cartesian_2 = require("../../component/axis/cartesian"), symbol_overlap_1 = require("../../mark/transform/symbol-overlap"), data_sampling_1 = require("../../mark/transform/data-sampling"), line_2 = require("../../theme/builtin/common/series/line");

class LineSeries extends cartesian_1.CartesianSeries {
    constructor() {
        super(...arguments), this.type = type_1.SeriesTypeEnum.line, this.transformerConstructor = line_mixin_transformer_1.LineLikeSeriesSpecTransformer, 
        this._sortDataByAxis = !1;
    }
    compile() {
        super.compile(), this.addSamplingCompile(), this.addOverlapCompile();
    }
    initMark() {
        var _a;
        const seriesMark = null !== (_a = this._spec.seriesMark) && void 0 !== _a ? _a : "line";
        this.initLineMark("line" === seriesMark), this.initSymbolMark("point" === seriesMark);
    }
    initTooltip() {
        super.initTooltip();
        const {group: group, mark: mark} = this._tooltipHelper.activeTriggerSet;
        this._lineMark && group.add(this._lineMark), this._symbolMark && (mark.add(this._symbolMark), 
        group.add(this._symbolMark));
    }
    initMarkStyle() {
        this.initLineMarkStyle(this._direction), this.initSymbolMarkStyle();
    }
    initAnimation() {
        var _a, _b, _c, _d;
        const lineAnimationParams = {
            direction: this.direction
        }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        if (this._lineMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_c = factory_1.Factory.getAnimationInKey("line")) || void 0 === _c ? void 0 : _c(lineAnimationParams, appearPreset), (0, 
        utils_1.userAnimationConfig)("line", this._spec, this._markAttributeContext))), 
        this._symbolMark) {
            const animationParams = (0, utils_2.getGroupAnimationParams)(this);
            this._symbolMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_d = factory_1.Factory.getAnimationInKey("scaleInOut")) || void 0 === _d ? void 0 : _d(), (0, 
            utils_1.userAnimationConfig)("point", this._spec, this._markAttributeContext), animationParams));
        }
    }
    onLayoutEnd() {
        super.onLayoutEnd(), this.reCompileSampling();
    }
    getSeriesStyle(datum) {
        var _a;
        const isLineAsSeriesMark = "point" !== (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.seriesMark);
        return attribute => {
            var _a, _b;
            return isLineAsSeriesMark && "fill" === attribute && (attribute = "stroke"), null !== (_b = null === (_a = this._seriesMark) || void 0 === _a ? void 0 : _a.getAttribute(attribute, datum)) && void 0 !== _b ? _b : void 0;
        };
    }
    getDefaultShapeType() {
        return "circle";
    }
    getActiveMarks() {
        return [ this._lineMark, this._symbolMark ];
    }
}

exports.LineSeries = LineSeries, LineSeries.type = type_1.SeriesTypeEnum.line, LineSeries.mark = constant_1.lineSeriesMark, 
LineSeries.builtInTheme = {
    line: line_2.line
}, LineSeries.transformerConstructor = line_mixin_transformer_1.LineLikeSeriesSpecTransformer, 
(0, vutils_1.mixin)(LineSeries, line_mixin_1.LineLikeSeriesMixin);

const registerLineSeries = () => {
    (0, data_sampling_1.registerDataSamplingTransform)(), (0, symbol_overlap_1.registerSymbolOverlapTransform)(), 
    (0, line_1.registerLineMark)(), (0, symbol_1.registerSymbolMark)(), (0, config_1.registerLineAnimation)(), 
    (0, config_1.registerScaleInOutAnimation)(), (0, cartesian_2.registerCartesianBandAxis)(), 
    (0, cartesian_2.registerCartesianLinearAxis)(), factory_1.Factory.registerSeries(LineSeries.type, LineSeries);
};

exports.registerLineSeries = registerLineSeries;
//# sourceMappingURL=line.js.map
