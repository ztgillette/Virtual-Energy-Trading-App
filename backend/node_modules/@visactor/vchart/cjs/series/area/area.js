"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerAreaSeries = exports.AreaSeries = void 0;

const vutils_1 = require("@visactor/vutils"), line_mixin_1 = require("../mixin/line-mixin"), cartesian_1 = require("../cartesian/cartesian"), attribute_1 = require("../../constant/attribute"), scale_1 = require("../../util/scale"), type_1 = require("../interface/type"), vutils_2 = require("@visactor/vutils"), utils_1 = require("../../animation/utils"), interpolate_1 = require("../../typings/interpolate"), line_1 = require("../../mark/line"), area_1 = require("../../mark/area"), symbol_1 = require("../../mark/symbol"), tooltip_helpter_1 = require("./tooltip-helpter"), constant_1 = require("./constant"), factory_1 = require("../../core/factory"), animation_1 = require("./animation"), area_transformer_1 = require("./area-transformer"), utils_2 = require("../util/utils"), cartesian_2 = require("../../component/axis/cartesian"), data_1 = require("../../constant/data"), symbol_overlap_1 = require("../../mark/transform/symbol-overlap"), data_sampling_1 = require("../../mark/transform/data-sampling"), area_2 = require("../../theme/builtin/common/series/area");

class AreaSeries extends cartesian_1.CartesianSeries {
    constructor() {
        super(...arguments), this.type = type_1.SeriesTypeEnum.area, this.transformerConstructor = area_transformer_1.AreaSeriesSpecTransformer, 
        this._sortDataByAxis = !1;
    }
    initMark() {
        var _a;
        const seriesMark = null !== (_a = this._spec.seriesMark) && void 0 !== _a ? _a : "area", isAreaMarkVisible = this._isAreaVisible() || this._isLineVisible();
        this._areaMark = this._createMark(AreaSeries.mark.area, {
            groupKey: this._seriesField,
            isSeriesMark: isAreaMarkVisible && "point" !== seriesMark
        }, {
            morphElementKey: this.getDimensionField()[0]
        }), this.initSymbolMark("point" === seriesMark);
    }
    initMarkStyle() {
        this.initAreaMarkStyle(), this.initSymbolMarkStyle();
    }
    initAreaMarkStyle() {
        var _a, _b, _c, _d, _e;
        const userCurveType = null !== (_c = null === (_b = null === (_a = this.getSpec().area) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.curveType) && void 0 !== _c ? _c : null === (_e = null === (_d = this.getSpec().line) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.curveType, curveType = userCurveType === interpolate_1.DEFAULT_SMOOTH_INTERPOLATE ? "horizontal" === this._direction ? "monotoneY" : "monotoneX" : userCurveType, areaMark = this._areaMark;
        if (areaMark) {
            const isAreaVisible = this._isAreaVisible(), isLineVisible = this._isLineVisible();
            isAreaVisible || isLineVisible ? areaMark.setVisible(!0) : areaMark.setVisible(!1), 
            "horizontal" === this._direction ? this.setMarkStyle(this._areaMark, {
                x: this.dataToPositionX.bind(this),
                x1: datum => {
                    var _a, _b;
                    return (0, scale_1.valueInScaleRange)(this.dataToPositionX1(datum), null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0));
                },
                y: this.dataToPositionY.bind(this),
                y1: this.dataToPositionY.bind(this),
                z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
                orient: this._direction
            }, "normal", attribute_1.AttributeLevel.Series) : this.setMarkStyle(this._areaMark, {
                x: this.dataToPositionX.bind(this),
                x1: this.dataToPositionX.bind(this),
                y1: datum => {
                    var _a, _b;
                    return (0, scale_1.valueInScaleRange)(this.dataToPositionY1(datum), null === (_b = null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0));
                },
                y: this.dataToPositionY.bind(this),
                z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
            }, "normal", attribute_1.AttributeLevel.Series), this.setMarkStyle(areaMark, {
                fill: !!isAreaVisible && this.getColorAttribute(),
                stroke: !!isLineVisible && this.getColorAttribute()
            }, "normal", attribute_1.AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(areaMark, {
                defined: this._getInvalidDefined.bind(this),
                connectedType: this._getInvalidConnectType()
            }, "normal", attribute_1.AttributeLevel.Series), this.getStack() && this.setMarkStyle(areaMark, {
                zIndex: datum => -datum[data_1.STACK_FIELD_END]
            }, "normal", attribute_1.AttributeLevel.Series), this.setMarkStyle(areaMark, {
                curveType: curveType
            }, "normal", attribute_1.AttributeLevel.Built_In), Object.keys(areaMark.stateStyle).forEach((state => {
                areaMark.stateStyle[state].stroke && areaMark.setPostProcess("stroke", (result => [ result, !1, !1, !1 ]), state);
            }));
        }
    }
    initAnimation() {
        var _a, _b, _c, _d;
        const areaAnimationParams = {
            direction: this.direction
        }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
        if (this._lineMark && this._lineMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_b = factory_1.Factory.getAnimationInKey("line")) || void 0 === _b ? void 0 : _b(areaAnimationParams, appearPreset), (0, 
        utils_1.userAnimationConfig)("line", this._spec, this._markAttributeContext))), 
        this._areaMark && this._areaMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_c = factory_1.Factory.getAnimationInKey("area")) || void 0 === _c ? void 0 : _c(areaAnimationParams, appearPreset), (0, 
        utils_1.userAnimationConfig)("area", this._spec, this._markAttributeContext))), 
        this._symbolMark) {
            const animationParams = (0, utils_2.getGroupAnimationParams)(this);
            this._symbolMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_d = factory_1.Factory.getAnimationInKey("scaleInOut")) || void 0 === _d ? void 0 : _d(), (0, 
            utils_1.userAnimationConfig)("point", this._spec, this._markAttributeContext), animationParams));
        }
    }
    _isAreaVisible() {
        var _a;
        const areaSpec = this._spec.area || {};
        return !1 !== areaSpec.visible && !1 !== (null === (_a = areaSpec.style) || void 0 === _a ? void 0 : _a.visible);
    }
    _isLineVisible() {
        var _a;
        const lineSpec = this._spec.line || {};
        return !1 !== lineSpec.visible && !1 !== (null === (_a = lineSpec.style) || void 0 === _a ? void 0 : _a.visible);
    }
    initTooltip() {
        this._tooltipHelper = new tooltip_helpter_1.AreaSeriesTooltipHelper(this);
        const {group: group, mark: mark} = this._tooltipHelper.activeTriggerSet;
        this._areaMark && group.add(this._areaMark), this._lineMark && group.add(this._lineMark), 
        this._symbolMark && (mark.add(this._symbolMark), group.add(this._symbolMark));
    }
    viewDataStatisticsUpdate(d) {
        super.viewDataStatisticsUpdate(d), this.encodeDefined(this._areaMark, "defined");
    }
    compile() {
        super.compile(), this.addSamplingCompile(), this.addOverlapCompile();
    }
    getDefaultShapeType() {
        return "square";
    }
    getActiveMarks() {
        return [ this._areaMark, this._symbolMark, this._lineMark ];
    }
    onLayoutEnd() {
        super.onLayoutEnd(), this.reCompileSampling();
    }
    getSeriesStyle(datum) {
        return attribute => {
            var _a, _b, _c, _d, _e;
            const seriesMarkType = null !== (_a = this._spec.seriesMark) && void 0 !== _a ? _a : "area";
            let result = null !== (_c = null === (_b = this._seriesMark) || void 0 === _b ? void 0 : _b.getAttribute(attribute, datum)) && void 0 !== _c ? _c : void 0;
            return "fill" !== attribute || result && "line" !== seriesMarkType || (attribute = "stroke", 
            result = null !== (_e = null === (_d = this._seriesMark) || void 0 === _d ? void 0 : _d.getAttribute(attribute, datum)) && void 0 !== _e ? _e : void 0), 
            "stroke" === attribute && (0, vutils_1.isArray)(result) ? result[0] : result;
        };
    }
}

exports.AreaSeries = AreaSeries, AreaSeries.type = type_1.SeriesTypeEnum.area, AreaSeries.builtInTheme = {
    area: area_2.area
}, AreaSeries.mark = constant_1.areaSeriesMark, AreaSeries.transformerConstructor = area_transformer_1.AreaSeriesSpecTransformer, 
(0, vutils_2.mixin)(AreaSeries, line_mixin_1.LineLikeSeriesMixin);

const registerAreaSeries = () => {
    (0, data_sampling_1.registerDataSamplingTransform)(), (0, symbol_overlap_1.registerSymbolOverlapTransform)(), 
    (0, line_1.registerLineMark)(), (0, area_1.registerAreaMark)(), (0, symbol_1.registerSymbolMark)(), 
    (0, animation_1.registerAreaSeriesAnimation)(), (0, cartesian_2.registerCartesianBandAxis)(), 
    (0, cartesian_2.registerCartesianLinearAxis)(), factory_1.Factory.registerSeries(AreaSeries.type, AreaSeries);
};

exports.registerAreaSeries = registerAreaSeries;
//# sourceMappingURL=area.js.map
