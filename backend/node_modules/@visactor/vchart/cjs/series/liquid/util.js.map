{"version":3,"sources":["../src/series/liquid/util.ts"],"names":[],"mappings":";;;AAEO,MAAM,SAAS,GAAG,CAAC,UAA2B,EAAE,IAAY,EAAE,EAAE;IACrE,IAAI,UAAU,KAAK,MAAM,EAAE;QACzB,OAAO,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;KACxB;IACD,OAAO,UAAU,CAAC;AACpB,CAAC,CAAC;AALW,QAAA,SAAS,aAKpB;AAUF,SAAS,GAAG,CAAC,CAAS,EAAE,CAAS,EAAE,MAAc;IAC/C,MAAM,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;IAC3B,MAAM,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC;IAClC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAGhB,MAAM,EAAE,GAAG,CAAC,CAAC;IACb,MAAM,EAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACzB,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;IAC9C,MAAM,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAC/B,MAAM,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAG/B,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;IACnB,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;IAGnB,MAAM,GAAG,GAAG,CAAC,CAAC;IACd,MAAM,GAAG,GAAG,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;IAErC,OAAO;UACC,EAAE,IAAI,EAAE;UACR,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,EAAE,GAAG,CAAC,IAAI,EAAE;UACjC,GAAG,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;UAC5B,GAAG,IAAI,GAAG,IAAI,EAAE,IAAI,EAAE;;KAE3B,CAAC;AACN,CAAC","file":"util.js","sourcesContent":["import type { LiquidShapeType } from './interface';\n\nexport const getShapes = (shapesType: LiquidShapeType, size: number) => {\n  if (shapesType === 'drop') {\n    return pin(0, 0, size);\n  }\n  return shapesType;\n};\n\n/* Adapted from liquid shapes by ai-qing-hai and hustcc\n * https://github.com/antvis/G2\n * Licensed under the MIT\n\n * url: https://github.com/antvis/G2/blob/v5/src/shape/liquid/shapes.ts\n * License: https://github.com/antvis/G2/blob/v5/LICENSE\n * @license\n */\nfunction pin(x: number, y: number, radius: number) {\n  const w = (radius * 4) / 3;\n  const h = Math.max(w, radius * 2);\n  const r = w / 2;\n\n  // Attrs of the upper circle.\n  const cx = x;\n  const cy = r + y - h / 2;\n  const theta = Math.asin(r / ((h - r) * 0.85));\n  const dy = Math.sin(theta) * r;\n  const dx = Math.cos(theta) * r;\n\n  // The start point of the path.\n  const x0 = cx - dx;\n  const y0 = cy + dy;\n\n  // Control point.\n  const cpX = x;\n  const cpY = cy + r / Math.sin(theta);\n\n  return `\n      M ${x0} ${y0}\n      A ${r} ${r} 0 1 1 ${x0 + dx * 2} ${y0}\n      Q ${cpX} ${cpY} ${x} ${y + h / 2}\n      Q ${cpX} ${cpY} ${x0} ${y0}\n      Z \n    `;\n}\n"]}