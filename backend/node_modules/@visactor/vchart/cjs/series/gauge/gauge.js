"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerGaugeSeries = exports.GaugeSeries = void 0;

const type_1 = require("../interface/type"), progress_like_1 = require("../polar/progress-like/progress-like"), register_1 = require("../../data/register"), data_1 = require("../../constant/data"), utils_1 = require("../../animation/utils"), constant_1 = require("./constant"), vutils_1 = require("@visactor/vutils"), factory_1 = require("../../core/factory"), progress_like_2 = require("../polar/progress-like"), gauge_transformer_1 = require("./gauge-transformer"), arc_1 = require("../../mark/arc"), polar_1 = require("../../component/axis/polar"), attribute_1 = require("../../constant/attribute"), util_1 = require("../../util"), gauge_1 = require("../../theme/builtin/common/series/gauge");

class GaugeSeries extends progress_like_1.ProgressLikeSeries {
    constructor() {
        super(...arguments), this.type = type_1.SeriesTypeEnum.gauge, this.transformerConstructor = gauge_transformer_1.GaugeSeriesSpecTransformer, 
        this._segmentMark = null, this._trackMark = null, this._padAngle = 0;
    }
    setAttrFromSpec() {
        var _a;
        super.setAttrFromSpec(), this._padAngle = (0, vutils_1.degreeToRadian)(null !== (_a = this._spec.padAngle) && void 0 !== _a ? _a : 0);
    }
    initData() {
        var _a;
        super.initData();
        (0, register_1.registerDataSetInstanceTransform)(this._option.dataSet, "spiltSegment", ((data, op) => {
            const dataCollect = data.slice();
            return dataCollect.sort(((a, b) => a[this._angleField[0]] - b[this._angleField[0]])), 
            dataCollect.forEach(((datum, i) => {
                datum[data_1.SEGMENT_FIELD_END] = datum[this._angleField[0]], datum[data_1.SEGMENT_FIELD_START] = i > 0 ? dataCollect[i - 1][data_1.SEGMENT_FIELD_END] : void 0;
            })), dataCollect;
        })), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
            type: "spiltSegment"
        }, !1);
    }
    initMark() {
        super.initMark(), this._trackMark = this._createMark(GaugeSeries.mark.track, {
            parent: this._arcGroupMark,
            dataView: !1
        }), this._segmentMark = this._createMark(GaugeSeries.mark.segment, {
            parent: this._arcGroupMark,
            isSeriesMark: !0
        });
    }
    initMarkStyle() {
        super.initMarkStyle(), this.initTrackMarkStyle(), this.initSegmentMarkStyle();
    }
    initSegmentMarkStyle() {
        var _a;
        const segmentMark = this._segmentMark;
        segmentMark && this.setMarkStyle(segmentMark, {
            x: () => this.angleAxisHelper.center().x,
            y: () => this.angleAxisHelper.center().y,
            startAngle: this._getAngleValueStart.bind(this),
            endAngle: this._getAngleValueEnd.bind(this),
            innerRadius: () => {
                var _a;
                return this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0);
            },
            outerRadius: () => {
                var _a, _b;
                return this._computeLayoutRadius() * (null !== (_b = null !== (_a = this._spec.radius) && void 0 !== _a ? _a : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
            },
            cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
            boundsMode: "imprecise",
            cornerRadius: this._spec.cornerRadius,
            fill: this.getColorAttribute(),
            zIndex: 200,
            forceShowCap: !0
        });
    }
    generateRadiusStyle(spec) {
        if (!spec) return;
        const style = {};
        return spec.outerRadius && (style.outerRadius = () => this._computeLayoutRadius() * spec.outerRadius), 
        spec.innerRadius && (style.innerRadius = () => this._computeLayoutRadius() * spec.innerRadius), 
        style;
    }
    initMarkStyleWithSpec(mark, spec) {
        if (super.initMarkStyleWithSpec(mark, spec), mark && "segment" === mark.name) {
            const segmentSpec = this.getSpec().segment;
            if (segmentSpec) for (const state in segmentSpec.state || {}) this.setMarkStyle(mark, this.generateRadiusStyle(segmentSpec.state[state]), state, attribute_1.AttributeLevel.User_Mark);
        }
    }
    initTooltip() {
        super.initTooltip(), this._segmentMark && this._tooltipHelper.activeTriggerSet.mark.add(this._segmentMark);
    }
    initTrackMarkStyle() {
        var _a;
        const trackMark = this._trackMark;
        trackMark && this.setMarkStyle(trackMark, {
            x: () => this.angleAxisHelper.center().x,
            y: () => this.angleAxisHelper.center().y,
            startAngle: this._startAngle,
            endAngle: this._endAngle,
            innerRadius: () => {
                var _a;
                return this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0);
            },
            outerRadius: () => {
                var _a, _b;
                return this._computeLayoutRadius() * (null !== (_b = null !== (_a = this._spec.radius) && void 0 !== _a ? _a : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
            },
            cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
            boundsMode: "imprecise",
            cornerRadius: this._spec.cornerRadius,
            zIndex: 100
        });
    }
    _getAngleValueStartWithoutMask(datum) {
        const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum), angle = (0, 
        vutils_1.clamper)(startAngle, (startAngle + endAngle) / 2)(startAngle + (endAngle > startAngle ? 1 : -1) * Math.abs(this._padAngle / 2));
        return this._spec.clamp ? (0, util_1.valueInScaleRange)(angle, this.angleAxisHelper.getScale(0)) : angle;
    }
    _getAngleValueEndWithoutMask(datum) {
        const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum), angle = (0, 
        vutils_1.clamper)(endAngle, (startAngle + endAngle) / 2)(endAngle - (endAngle > startAngle ? 1 : -1) * Math.abs(this._padAngle / 2));
        return this._spec.clamp ? (0, util_1.valueInScaleRange)(angle, this.angleAxisHelper.getScale(0)) : angle;
    }
    _getAngleValueStartWithoutPadAngle(datum) {
        return (0, vutils_1.isValid)(datum[data_1.SEGMENT_FIELD_START]) ? this.angleAxisHelper.dataToPosition([ datum[data_1.SEGMENT_FIELD_START] ]) : this._startAngle;
    }
    _getAngleValueEndWithoutPadAngle(datum) {
        return this.angleAxisHelper.dataToPosition([ datum[data_1.SEGMENT_FIELD_END] ]);
    }
    initAnimation() {
        var _a, _b, _c;
        const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
        this._segmentMark.setAnimationConfig((0, utils_1.animationConfig)(null === (_c = factory_1.Factory.getAnimationInKey("circularProgress")) || void 0 === _c ? void 0 : _c({
            startAngle: this._startAngle
        }, appearPreset), (0, utils_1.userAnimationConfig)("segment", this._spec, this._markAttributeContext)));
    }
    getDefaultShapeType() {
        return "circle";
    }
    getActiveMarks() {
        return [];
    }
}

exports.GaugeSeries = GaugeSeries, GaugeSeries.type = type_1.SeriesTypeEnum.gauge, 
GaugeSeries.mark = constant_1.gaugeSeriesMark, GaugeSeries.builtInTheme = {
    gauge: gauge_1.gauge
}, GaugeSeries.transformerConstructor = gauge_transformer_1.GaugeSeriesSpecTransformer;

const registerGaugeSeries = () => {
    factory_1.Factory.registerSeries(GaugeSeries.type, GaugeSeries), (0, arc_1.registerArcMark)(), 
    (0, progress_like_2.registerProgressLikeAnimation)(), (0, polar_1.registerPolarLinearAxis)();
};

exports.registerGaugeSeries = registerGaugeSeries;
//# sourceMappingURL=gauge.js.map
