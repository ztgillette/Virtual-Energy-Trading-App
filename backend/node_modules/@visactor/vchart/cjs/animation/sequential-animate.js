"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerSequentialAnimate = void 0;

const vutils_1 = require("@visactor/vutils"), grammar_dector_1 = require("./grammar-dector"), mark_1 = require("../mark");

class SequentialAnimate {
    registerAnimationSplitStrategy(strategy) {
        this._grammarDetector || (this._grammarDetector = new grammar_dector_1.GrammarDetector(this)), 
        this._grammarDetector.registerStrategy(strategy);
    }
    getGrammarDetector() {
        return this.initGrammarDetector(), this._grammarDetector;
    }
    initGrammarDetector() {
        this._grammarDetector || (this._grammarDetector = new grammar_dector_1.GrammarDetector(this));
    }
    _runSequentialAnimations(graphics) {
        this.initGrammarDetector();
        const animationConfig = this.getAnimationConfig(), detectionResult = this._grammarDetector.detect(graphics, this._graphicMap), planners = this._grammarDetector.createPlanners(detectionResult, animationConfig);
        this._executePlanners(planners, 0);
    }
    _executePlanners(planners, index) {
        if (index >= planners.length) return;
        const planner = planners[index];
        planner.execute(this._product, (() => {
            this._executePlanners(planners, index + 1), "exit" === planner.state && planner.graphics.forEach((g => {
                g.isExiting && (this._graphicMap.delete(g.context.uniqueKey), g.parent && g.parent.removeChild(g), 
                g.release && g.release());
            }));
        }));
    }
}

function registerSequentialAnimate() {
    (0, vutils_1.mixin)(mark_1.BaseMark, SequentialAnimate);
}

exports.registerSequentialAnimate = registerSequentialAnimate;
//# sourceMappingURL=sequential-animate.js.map