{"version":3,"sources":["../src/animation/grammar-dector.ts"],"names":[],"mappings":"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","file":"grammar-dector.js","sourcesContent":["/**\n * 检测语法变化，注册策略针对不同的语法变化，创建不同的planner去依次执行\n * 可以注册的策略有：\n * 1. 如果有数据删除，分为两个planner，先走exit动画，再走其他的动画\n * 2. 如果有数据添加，分为两个planner，先走其他的动画，最后走Enter动画\n * 3. 如果是一般的更新，那么正常走update，也就是一个planner就行\n * 4. 如果有数据维度变化\n *    -   1. 堆积变分组，先执行band方向的插值，在进行value方向的插值\n *    -   2. 分组变堆积，先执行value方向的插值，再执行band方向的插值\n */\nimport { AnimationPlanner } from './animation-planner';\nimport type { IMarkGraphic } from '../mark/interface';\nimport { DiffState } from '../mark/interface/enum';\nimport type { IAnimationConfig, IAnimationSplitStrategy } from './interface';\nimport type { BaseMark } from '../mark';\nimport { VerticalBarSplitStrategy } from './strategy/vertical-bar-split';\nimport { HorizontalBarSplitStrategy } from './strategy/horizontal-bar-split';\n\nexport interface IDetectionResult {\n  hasExit: boolean;\n  hasUpdate: boolean;\n  hasEnter: boolean;\n  hasAppear: boolean;\n  exitGraphics: IMarkGraphic[];\n  updateGraphics: IMarkGraphic[];\n  enterGraphics: IMarkGraphic[];\n  appearGraphics: IMarkGraphic[];\n}\n\nexport class GrammarDetector {\n  private mark: BaseMark<any>;\n  private splitStrategies: IAnimationSplitStrategy[] = [];\n\n  constructor(mark: BaseMark<any>) {\n    this.mark = mark;\n    if (mark.type === 'rect') {\n      // 注册默认策略\n      this.registerStrategy(new VerticalBarSplitStrategy());\n      this.registerStrategy(new HorizontalBarSplitStrategy());\n    }\n  }\n\n  /**\n   * 注册动画拆分策略\n   * @param strategy 动画拆分策略\n   */\n  registerStrategy(strategy: IAnimationSplitStrategy): void {\n    this.splitStrategies.push(strategy);\n  }\n\n  /**\n   * 检测图形的变化类型\n   * @param graphics 要分析的图形列表\n   * @returns 一个检测结果，指示需要哪些类型的动画\n   */\n  detect(graphics: IMarkGraphic[], graphicMap: Map<string, IMarkGraphic>): IDetectionResult {\n    const exitGraphics: IMarkGraphic[] = [];\n    const updateGraphics: IMarkGraphic[] = [];\n    const enterGraphics: IMarkGraphic[] = [];\n    const appearGraphics: IMarkGraphic[] = [];\n\n    const fieldX = (this.mark.model as any).fieldX;\n    const fieldY = (this.mark.model as any).fieldY;\n\n    graphics.forEach(g => {\n      // 保存field信息以便进行堆积/分组变化的检测\n      const context = g.context;\n\n      // 保存原始fieldX/fieldY以供比较\n      if (context.fieldX) {\n        context.originalFieldX = context.fieldX;\n      }\n      if (context.fieldY) {\n        context.originalFieldY = context.fieldY;\n      }\n\n      // 更新为当前field\n      context.fieldX = fieldX;\n      context.fieldY = fieldY;\n\n      const state = g.context.animationState;\n      switch (state) {\n        case 'update':\n          updateGraphics.push(g);\n          break;\n        case 'enter':\n          enterGraphics.push(g);\n          break;\n        case 'appear':\n          appearGraphics.push(g);\n          break;\n        default:\n          // 对于未知状态，根据diffState确定\n          if (g.context.diffState === DiffState.exit) {\n            exitGraphics.push(g);\n          } else if (g.context.diffState === DiffState.enter) {\n            enterGraphics.push(g);\n          } else {\n            updateGraphics.push(g);\n          }\n      }\n    });\n\n    if (graphicMap.size > graphics.length) {\n      graphicMap.forEach((g, key) => {\n        if (g.context.diffState === DiffState.exit && !g.isExiting) {\n          exitGraphics.push(g);\n        }\n      });\n    }\n\n    return {\n      hasExit: exitGraphics.length > 0,\n      hasUpdate: updateGraphics.length > 0,\n      hasEnter: enterGraphics.length > 0,\n      hasAppear: appearGraphics.length > 0,\n      exitGraphics,\n      updateGraphics,\n      enterGraphics,\n      appearGraphics\n    };\n  }\n\n  /**\n   * 根据检测到的变化创建动画Planner\n   * @param result 检测结果\n   * @param animationConfig 动画配置\n   * @returns 一个动画Planner数组，按顺序执行\n   */\n  createPlanners(result: IDetectionResult, animationConfig: Record<string, IAnimationConfig[]>): AnimationPlanner[] {\n    const planners: AnimationPlanner[] = [];\n\n    // 按顺序创建Planner\n    if (result.hasExit && animationConfig.exit) {\n      planners.push(new AnimationPlanner('exit', result.exitGraphics, animationConfig.exit));\n    }\n\n    // 对更新动画进行分析和拆分\n    if (result.hasUpdate && animationConfig.update) {\n      // 检查是否可以应用拆分策略\n      type GraphicWithSteps = {\n        graphic: IMarkGraphic;\n        steps: Array<{ attrs: Record<string, any>; order: number }>;\n      };\n\n      const updateGraphicsByStep: Map<number, GraphicWithSteps[]> = new Map();\n      const regularUpdateGraphics: IMarkGraphic[] = [];\n\n      // 根据策略拆分每个图形的更新\n      result.updateGraphics.forEach(graphic => {\n        let applied = false;\n\n        for (const strategy of this.splitStrategies) {\n          if (strategy.shouldApply(this.mark, graphic)) {\n            // 应用策略拆分更新\n            const splitUpdates = strategy.split(this.mark, graphic);\n\n            // 保存图形和它的更新步骤关系\n            const graphicWithSteps: GraphicWithSteps = {\n              graphic,\n              steps: splitUpdates\n            };\n\n            // 为每个步骤创建分组\n            splitUpdates.forEach(update => {\n              const { order } = update;\n\n              // 按顺序分组\n              if (!updateGraphicsByStep.has(order)) {\n                updateGraphicsByStep.set(order, []);\n              }\n              updateGraphicsByStep.get(order).push(graphicWithSteps);\n            });\n\n            applied = true;\n            break;\n          }\n        }\n\n        // 如果没有应用任何策略，把图形放入常规更新组\n        if (!applied) {\n          regularUpdateGraphics.push(graphic);\n        }\n      });\n\n      // 添加常规更新Planner（如果有常规更新）\n      if (regularUpdateGraphics.length > 0) {\n        planners.push(new AnimationPlanner('update', regularUpdateGraphics, animationConfig.update));\n      }\n\n      // 按顺序添加拆分后的更新Planner\n      const steps = Array.from(updateGraphicsByStep.keys()).sort((a, b) => a - b);\n      steps.forEach(step => {\n        const graphicsWithSteps = updateGraphicsByStep.get(step);\n        if (graphicsWithSteps && graphicsWithSteps.length > 0) {\n          // 为这个步骤创建一个特殊的planner，它会在执行前设置对应的diffAttrs\n          const graphicsForStep = graphicsWithSteps.map(({ graphic, steps }) => {\n            // 找到当前步骤对应的attrs\n            const stepConfig = steps.find(s => s.order === step);\n            return {\n              graphic,\n              attrs: stepConfig?.attrs || {}\n            };\n          });\n\n          planners.push(\n            new AnimationPlanner(\n              'update',\n              graphicsForStep.map(item => item.graphic),\n              animationConfig.update,\n              // 传入一个预处理函数，在执行动画前设置正确的diffAttrs\n              (graphics: IMarkGraphic[]) => {\n                graphics.forEach((g: IMarkGraphic, index: number) => {\n                  const attrs = graphicsForStep[index].attrs;\n                  // 暂存原始diffAttrs\n                  const context = g.context as any;\n                  if (!context._originalDiffAttrs) {\n                    context._originalDiffAttrs = g.context.diffAttrs;\n                  }\n                  // 设置当前步骤的diffAttrs\n                  g.context.diffAttrs = attrs;\n                });\n              },\n              // 传入一个后处理函数，在执行动画后恢复原始diffAttrs\n              (graphics: IMarkGraphic[]) => {\n                // 只有最后一个步骤才需要恢复，因为中间步骤会被下一个步骤覆盖\n                if (step === steps[steps.length - 1]) {\n                  graphics.forEach((g: IMarkGraphic) => {\n                    const context = g.context as any;\n                    if (context._originalDiffAttrs) {\n                      g.context.diffAttrs = context._originalDiffAttrs;\n                      delete context._originalDiffAttrs;\n                    }\n                  });\n                }\n              }\n            )\n          );\n        }\n      });\n    }\n\n    if (result.hasEnter && animationConfig.enter) {\n      planners.push(new AnimationPlanner('enter', result.enterGraphics, animationConfig.enter));\n    }\n\n    if (result.hasAppear && animationConfig.appear) {\n      planners.push(new AnimationPlanner('appear', result.appearGraphics, animationConfig.appear));\n    }\n\n    return planners;\n  }\n}\n"]}