{"version":3,"sources":["../src/animation/sequential-animate.ts"],"names":[],"mappings":";;;AAAA,6CAAyC;AAGzC,qDAAmD;AAEnD,kCAAmC;AAEnC,MAAM,iBAAiB;IAMrB,8BAA8B,CAAC,QAAiC;QAC9D,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE;YAC1B,IAAI,CAAC,gBAAgB,GAAG,IAAI,gCAAe,CAAC,IAAW,CAAC,CAAC;SAC1D;QACD,IAAI,CAAC,gBAAgB,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;IACnD,CAAC;IAED,kBAAkB;QAChB,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED,mBAAmB;QACjB,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE;YAC1B,IAAI,CAAC,gBAAgB,GAAG,IAAI,gCAAe,CAAC,IAAW,CAAC,CAAC;SAC1D;IACH,CAAC;IAGS,wBAAwB,CAAC,QAAwB;QACzD,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,MAAM,eAAe,GAAI,IAAY,CAAC,kBAAkB,EAAE,CAAC;QAG3D,MAAM,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,QAAQ,EAAG,IAAY,CAAC,WAAW,CAAC,CAAC;QAG1F,MAAM,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC,cAAc,CACnD,eAAe,EACf,eAAgE,CACjE,CAAC;QAGF,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;IACrC,CAAC;IAOO,gBAAgB,CAAC,QAA4B,EAAE,KAAa;QAClE,IAAI,KAAK,IAAI,QAAQ,CAAC,MAAM,EAAE;YAC5B,OAAO;SACR;QAED,MAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;QAChC,OAAO,CAAC,OAAO,CAAE,IAAY,CAAC,QAAQ,EAAE,GAAG,EAAE;YAE3C,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;YAG3C,IAAI,OAAO,CAAC,KAAK,KAAK,MAAM,EAAE;gBAC5B,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;oBAC3B,IAAI,CAAC,CAAC,SAAS,EAAE;wBACd,IAAY,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;wBACtD,IAAI,CAAC,CAAC,MAAM,EAAE;4BACZ,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;yBACzB;wBACD,IAAI,CAAC,CAAC,OAAO,EAAE;4BACb,CAAC,CAAC,OAAO,EAAE,CAAC;yBACb;qBACF;gBACH,CAAC,CAAC,CAAC;aACJ;QAqBH,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AAED,SAAgB,yBAAyB;IACvC,IAAA,cAAK,EAAC,eAAQ,EAAE,iBAAiB,CAAC,CAAC;AACrC,CAAC;AAFD,8DAEC","file":"sequential-animate.js","sourcesContent":["import { mixin } from '@visactor/vutils';\nimport type { IMarkGraphic } from '../core';\nimport type { AnimationPlanner } from './animation-planner';\nimport { GrammarDetector } from './grammar-dector';\nimport type { IAnimationConfig, IAnimationSplitStrategy } from './interface';\nimport { BaseMark } from '../mark';\n\nclass SequentialAnimate {\n  protected _grammarDetector: GrammarDetector;\n  /**\n   * 注册自定义动画拆分策略\n   * @param strategy 动画拆分策略\n   */\n  registerAnimationSplitStrategy(strategy: IAnimationSplitStrategy): void {\n    if (!this._grammarDetector) {\n      this._grammarDetector = new GrammarDetector(this as any);\n    }\n    this._grammarDetector.registerStrategy(strategy);\n  }\n\n  getGrammarDetector() {\n    this.initGrammarDetector();\n    return this._grammarDetector;\n  }\n\n  initGrammarDetector() {\n    if (!this._grammarDetector) {\n      this._grammarDetector = new GrammarDetector(this as any);\n    }\n  }\n\n  // 处理动画序列\n  protected _runSequentialAnimations(graphics: IMarkGraphic[]) {\n    this.initGrammarDetector();\n    const animationConfig = (this as any).getAnimationConfig();\n\n    // 使用 GrammarDetector 检测变化类型\n    const detectionResult = this._grammarDetector.detect(graphics, (this as any)._graphicMap);\n\n    // 根据检测结果创建动画planners\n    const planners = this._grammarDetector.createPlanners(\n      detectionResult,\n      animationConfig as unknown as Record<string, IAnimationConfig[]>\n    );\n\n    // 按顺序执行planner\n    this._executePlanners(planners, 0);\n  }\n\n  /**\n   * 按顺序执行planner\n   * @param planners\n   * @param index\n   */\n  private _executePlanners(planners: AnimationPlanner[], index: number) {\n    if (index >= planners.length) {\n      return;\n    }\n\n    const planner = planners[index];\n    planner.execute((this as any)._product, () => {\n      // 执行下一个planner\n      this._executePlanners(planners, index + 1);\n\n      // 如果这个planner是exit，那么结束之后就删除它\n      if (planner.state === 'exit') {\n        planner.graphics.forEach(g => {\n          if (g.isExiting) {\n            (this as any)._graphicMap.delete(g.context.uniqueKey);\n            if (g.parent) {\n              g.parent.removeChild(g);\n            }\n            if (g.release) {\n              g.release();\n            }\n          }\n        });\n      }\n\n      // 如果这是最后一个planner并且它是一个'enter'动画，则运行normal动画\n      // if (index === planners.length - 1 && planner.state === 'enter') {\n      //   // 在enter完成后执行normal动画\n      //   const normalConfig = (this.getAnimationConfig() as any).normal?.[0];\n      //   if (normalConfig && this._product) {\n      //     // 停止normal动画并重置为初始属性\n      //     (this._product as IGroup).stopAnimationState('normal', 'end');\n\n      //     (this._product as IGroup).applyAnimationState(\n      //       ['normal'],\n      //       [\n      //         {\n      //           name: 'normal',\n      //           animation: normalConfig\n      //         }\n      //       ]\n      //     );\n      //   }\n      // }\n    });\n  }\n}\n\nexport function registerSequentialAnimate() {\n  mixin(BaseMark, SequentialAnimate);\n}\n"]}