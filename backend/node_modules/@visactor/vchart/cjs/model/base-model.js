"use strict";

var __rest = this && this.__rest || function(s, e) {
    var t = {};
    for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
    if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
    }
    return t;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseModel = void 0;

const id_1 = require("../util/id"), event_1 = require("../event/event"), vutils_1 = require("@visactor/vutils"), factory_1 = require("../core/factory"), mark_set_1 = require("../mark/mark-set"), compilable_base_1 = require("../compile/compilable-base"), base_1 = require("../constant/base"), base_model_transformer_1 = require("./base-model-transformer"), vutils_extension_1 = require("@visactor/vutils-extension");

class BaseModel extends compilable_base_1.CompilableBase {
    getSpec() {
        return this._spec || {};
    }
    getSpecPath() {
        var _a;
        return null === (_a = this._option) || void 0 === _a ? void 0 : _a.specPath;
    }
    getSpecInfoPath() {
        var _a, _b, _c;
        return null !== (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.specInfoPath) && void 0 !== _b ? _b : null === (_c = this._option) || void 0 === _c ? void 0 : _c.specPath;
    }
    getData() {
        return this._data;
    }
    get layout() {
        return this._layout;
    }
    getOption() {
        return this._option;
    }
    getMarks() {
        var _a, _b;
        return null !== (_b = null === (_a = this._marks) || void 0 === _a ? void 0 : _a.getMarks()) && void 0 !== _b ? _b : [];
    }
    getMarkNameMap() {
        var _a;
        return null === (_a = this._marks) || void 0 === _a ? void 0 : _a.getMarkNameMap();
    }
    getMarkSet() {
        return this._marks;
    }
    getChart() {
        return this._option.getChart();
    }
    get _theme() {
        var _a;
        return null === (_a = this.getSpecInfo()) || void 0 === _a ? void 0 : _a.theme;
    }
    constructor(spec, option) {
        var _a;
        super(option), this.transformerConstructor = base_model_transformer_1.BaseModelSpecTransformer, 
        this.type = "null", this.modelType = "null", this.userId = void 0, this._data = null, 
        this._layout = null, this.specKey = "", this._marks = new mark_set_1.MarkSet, this._lastLayoutRect = null, 
        this.id = (0, id_1.createID)(), this.userId = spec.id, this._spec = spec, this.effect = {}, 
        this.event = new event_1.Event(option.eventDispatcher, option.mode), null === (_a = option.map) || void 0 === _a || _a.set(this.id, this);
    }
    _releaseEvent() {
        this.event.release();
    }
    created() {
        this.setAttrFromSpec();
    }
    init(option) {}
    afterInit() {}
    getVisible() {
        var _a;
        return !1 !== (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.visible);
    }
    onLayoutStart(layoutRect, viewRect) {
        var _a;
        null === (_a = this._layout) || void 0 === _a || _a.onLayoutStart(layoutRect, viewRect);
    }
    onLayoutEnd() {
        var _a;
        null === (_a = this._layout) || void 0 === _a || _a.onLayoutEnd(), this.getMarks().forEach((m => m.commit(!1, !0)));
    }
    onEvaluateEnd(ctx) {}
    onBeforeRender() {}
    onDataUpdate() {}
    beforeRelease() {}
    clear() {
        this.getMarks().forEach((m => {
            var _a;
            return null === (_a = m.clear) || void 0 === _a ? void 0 : _a.call(m);
        }));
    }
    release() {
        var _a;
        this._releaseEvent(), this._spec = void 0, this.getMarks().forEach((m => m.release())), 
        null === (_a = this._data) || void 0 === _a || _a.release(), this._data = null, 
        this._marks.clear(), super.release();
    }
    updateSpec(spec) {
        var _a;
        const result = this._compareSpec(spec, this._spec);
        return (result.reRender || result.reMake || result.reCompile) && (null === (_a = this._layout) || void 0 === _a || _a.setWillLayoutTag()), 
        this._spec = spec, result;
    }
    _compareSpec(spec, prevSpec) {
        return {
            change: !1,
            reMake: !1,
            reRender: !1,
            reSize: !1,
            reCompile: !1
        };
    }
    reInit(spec) {
        spec && (this._spec = spec), this.setAttrFromSpec();
    }
    updateLayoutAttribute() {}
    setAttrFromSpec() {
        var _a;
        null === (_a = this._layout) || void 0 === _a || _a.setAttrFromSpec(this._spec, this._option.getChartViewRect());
    }
    _convertMarkStyle(style) {
        return Object.assign({}, style);
    }
    setMarkStyle(mark, style, state, level) {
        (0, vutils_1.isValid)(mark) && (0, vutils_1.isValid)(style) && mark.setStyle(this._convertMarkStyle(style), state, level);
    }
    initMarkStyleWithSpec(mark, spec) {
        if (!(0, vutils_1.isValid)(mark) || !(0, vutils_1.isValid)(spec)) return;
        const {style: style, state: state} = spec, newSpec = Object.assign({}, spec);
        style && (newSpec.style = this._convertMarkStyle(style)), state && (newSpec.state = {}, 
        Object.keys(state).forEach((key => {
            newSpec.state[key] = this._convertMarkStyle(state[key]);
        }))), mark.initStyleWithSpec(newSpec);
    }
    stateKeyToSignalName(key, opt) {
        let name = `${base_1.PREFIX}_${this.modelType}_${this.type}_${this.id}_${key}`;
        return opt && (name += `_${opt}`), name;
    }
    compileData() {
        var _a;
        null === (_a = this._data) || void 0 === _a || _a.compile();
    }
    compileMarks(group) {
        this.getMarks().forEach((m => {
            m.compile({
                group: group
            });
        }));
    }
    _createMark(markInfo, option = {}, config) {
        const {type: type, name: name} = markInfo, {parent: parent} = option, others = __rest(option, [ "parent" ]), m = factory_1.Factory.createMark(type, name, Object.assign({
            model: this,
            map: this._option.map,
            getCompiler: this.getCompiler,
            globalScale: this._option.globalScale
        }, others));
        return parent ? parent.addMark(m) : this.getCompiler().addRootMark(m), m && (m.created(), 
        config && m.setMarkConfig(config)), m;
    }
    _getDataIdKey() {}
    getColorScheme() {
        var _a, _b;
        return null === (_b = (_a = this._option).getTheme) || void 0 === _b ? void 0 : _b.call(_a, "colorScheme");
    }
    getSpecInfo() {
        var _a, _b, _c;
        const specInfo = null !== (_c = null === (_b = (_a = this._option).getSpecInfo) || void 0 === _b ? void 0 : _b.call(_a)) && void 0 !== _c ? _c : {};
        return (0, vutils_extension_1.getProperty)(specInfo, this.getSpecInfoPath());
    }
    getSpecIndex() {
        const path = this.getSpecPath();
        if (!(null == path ? void 0 : path.length)) return 0;
        const index = Number(path[path.length - 1]);
        return isNaN(index) ? 0 : index;
    }
    updateAnimateStateCallback(callback) {
        this._aniamtionStateCallback = callback;
    }
    getAnimationStateCallback() {
        return this._aniamtionStateCallback;
    }
}

exports.BaseModel = BaseModel;
//# sourceMappingURL=base-model.js.map
