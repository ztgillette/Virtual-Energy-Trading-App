"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.GlobalScale = void 0;

const vutils_1 = require("@visactor/vutils"), vscale_1 = require("@visactor/vscale"), scale_1 = require("../util/scale"), type_1 = require("../util/type"), data_1 = require("../util/data");

class GlobalScale {
    constructor(spec, chart) {
        this._scaleSpecMap = new Map, this._scaleMap = new Map, this._modelScaleSpecMap = new Map, 
        this._markAttributeScaleMap = new Map, this._spec = null, this._chart = null, this.getStatisticalFields = dataId => {
            const result = [];
            return this._scaleSpecMap.forEach(((v, k) => {
                (0, type_1.isDataDomainSpec)(v.domain) && v.domain.forEach((spec => {
                    spec.dataId === dataId && spec.fields.forEach((key => {
                        (0, data_1.mergeFields)(result, [ {
                            key: key,
                            operations: (0, vscale_1.isContinuous)(v.type) ? [ "max", "min" ] : [ "values" ]
                        } ]);
                    }));
                }));
            })), this._markAttributeScaleMap.forEach(((specList, scaleName) => {
                const scale = this.getScale(scaleName);
                specList.forEach((spec => {
                    this._getSeriesBySeriesId(spec.seriesId).getRawData().name === dataId && spec.field && (0, 
                    data_1.mergeFields)(result, [ {
                        key: spec.field,
                        operations: (0, vscale_1.isContinuous)(scale.type) ? [ "max", "min" ] : [ "values" ]
                    } ]);
                }));
            })), result;
        }, this._spec = spec, this._chart = chart, this._setAttrFromSpec();
    }
    _createFromSpec(s) {
        if (!s.id) return null;
        let scale = this._scaleMap.get(s.id);
        return scale || (scale = "ordinal" === s.type && "color" === s.id ? (0, scale_1.createScale)("colorOrdinal") : (0, 
        scale_1.createScale)(s.type)), scale ? ((0, vutils_1.isArray)(s.range) && scale.range(s.range), 
        (0, vutils_1.isArray)(s.domain) && ((0, type_1.isDataDomainSpec)(s.domain) || scale.domain(s.domain)), 
        s.specified && scale.specified && scale.specified(s.specified), s.clamp && scale.clamp && scale.clamp(s.clamp), 
        scale) : null;
    }
    _setAttrFromSpec() {
        var _a;
        if (!(null === (_a = this._spec) || void 0 === _a ? void 0 : _a.length)) return;
        const newScaleMap = new Map, newScaleSpecMap = new Map;
        this._spec.forEach((s => {
            const scale = this._createFromSpec(s);
            scale && (newScaleMap.set(s.id, scale), newScaleSpecMap.set(s.id, s));
        })), this._modelScaleSpecMap.forEach((s => {
            const scale = this._createFromSpec(s);
            scale && (newScaleMap.set(s.id, scale), newScaleSpecMap.set(s.id, s));
        })), this._scaleSpecMap = newScaleSpecMap, this._scaleMap = newScaleMap;
    }
    updateSpec(spec) {
        const result = {
            change: !1,
            reMake: !1,
            reRender: !1,
            reSize: !1,
            reCompile: !1
        };
        if ((0, vutils_1.isEqual)(spec, this._spec)) return result;
        result.change = !0;
        for (let i = 0; i < spec.length; i++) {
            const s = spec[i], scale = this._scaleMap.get(s.id);
            if (!scale) return result.reMake = !0, result;
            const lastSpec = this._spec.find((_s => _s.id === s.id));
            if (!lastSpec.id) return result.reMake = !0, result;
            if (lastSpec.type !== s.type) return result.reMake = !0, result;
            if (!(0, vutils_1.isEqual)(lastSpec.specified, s.specified)) return result.reMake = !0, 
            result;
            s.range && !(0, vutils_1.isEqual)(s.range, scale.range()) && (scale.range(s.range), 
            result.reRender = !0), (0, type_1.isDataDomainSpec)(s.domain) ? result.reRender = !0 : (0, 
            vutils_1.isEqual)(s.domain, scale.domain()) || (scale.domain(s.domain), result.reRender = !0), 
            this._scaleSpecMap.set(s.id, s);
        }
        return this._spec = spec, result;
    }
    registerModelScale(spec) {
        const scale = this._createFromSpec(spec);
        scale && (this._modelScaleSpecMap.set(spec.id, spec), this._scaleSpecMap.set(spec.id, spec), 
        this._scaleMap.set(spec.id, scale));
    }
    removeModelScale(filter) {
        this._modelScaleSpecMap.forEach((spec => {
            filter(spec) && (this._modelScaleSpecMap.delete(spec.id), this._scaleSpecMap.delete(spec.id), 
            this._scaleMap.delete(spec.id));
        }));
    }
    getScale(user_id) {
        return this._scaleMap.get(user_id);
    }
    getScaleSpec(user_id) {
        return this._scaleSpecMap.get(user_id);
    }
    _getSeriesByRawDataId(id) {
        const series = this._chart.getAllSeries();
        for (let i = 0; i < series.length; i++) {
            const s = series[i];
            if (s.getRawData().name === id) return s;
        }
        return null;
    }
    _getSeriesBySeriesId(id) {
        const series = this._chart.getAllSeries();
        for (let i = 0; i < series.length; i++) {
            const s = series[i];
            if (s.id === id) return s;
        }
        return null;
    }
    updateScaleDomain(defaultDomain) {
        this._scaleSpecMap.forEach(((scaleSpec, id) => {
            const scale = this._scaleMap.get(id);
            if (!scale) return;
            if (!(0, type_1.isDataDomainSpec)(scaleSpec.domain)) return scaleSpec.domain && 0 !== scaleSpec.domain.length || scale.domain(defaultDomain), 
            void this._updateMarkScale(id, scale, scale.domain().slice());
            let domain;
            domain = (0, vscale_1.isContinuous)(scaleSpec.type) ? [ null, null ] : new Set, 
            scaleSpec.domain.forEach((spec => {
                const series = this._getSeriesByRawDataId(spec.dataId);
                if (!series) return;
                const isContinuousField = (0, vscale_1.isContinuous)(scaleSpec.type);
                spec.fields.forEach((key => {
                    const statistics = series.getRawDataStatisticsByField(key, isContinuousField);
                    statistics && (isContinuousField ? ((0, vutils_1.isNil)(domain[0]) ? domain[0] = statistics.min : domain[0] = Math.min(statistics.min, domain[0]), 
                    (0, vutils_1.isNil)(domain[1]) ? domain[1] = statistics.max : domain[1] = Math.max(statistics.max, domain[1])) : statistics.values.forEach((value => {
                        domain.add(value);
                    })));
                }));
            }));
            const scaleDomain = domain;
            (0, vscale_1.isContinuous)(scaleSpec.type) || (domain = Array.from(domain)), scale.domain(domain), 
            this._updateMarkScale(id, scale, scaleDomain);
        }));
    }
    _updateMarkScale(id, scale, domain) {
        const list = this._markAttributeScaleMap.get(id);
        list && 0 !== list.length && list.forEach((info => {
            if (!info.field || !info.markScale || info.markScale === scale) return;
            if ((0, vutils_1.isNil)(info.changeDomain) || "none" === info.changeDomain || (0, 
            vutils_1.isNil)(info.seriesId)) return void ((0, vscale_1.isContinuous)(scale.type) ? info.markScale.domain(domain) : scale.domain(Array.from(domain)));
            const series = this._getSeriesBySeriesId(info.seriesId), isContinuousScale = (0, 
            vscale_1.isContinuous)(scale.type), statistics = series.getRawDataStatisticsByField(info.field, isContinuousScale);
            if (!(0, vutils_1.isEmpty)(statistics)) return "expand" === info.changeDomain ? (isContinuousScale ? (domain[0] = Math.min(domain[0], statistics.min), 
            domain[1] = Math.max(domain[1], statistics.max)) : (statistics.values.forEach((value => {
                domain.add(value);
            })), domain = Array.from(domain)), void info.markScale.domain(domain)) : void ("replace" !== info.changeDomain || (isContinuousScale ? info.markScale.domain([ statistics.min, statistics.max ]) : info.markScale.domain(statistics.values)));
            (0, vscale_1.isContinuous)(scale.type) ? info.markScale.domain(domain) : scale.domain(Array.from(domain));
        }));
    }
    registerMarkAttributeScale(spec, seriesId) {
        const scale = this._scaleMap.get(spec.scale);
        let list = this._markAttributeScaleMap.get(spec.scale);
        list || (list = [], this._markAttributeScaleMap.set(spec.scale, list));
        let markScale = scale;
        return ((0, vutils_1.isNil)(spec.field) || !(0, vutils_1.isNil)(spec.changeDomain) && "none" !== spec.changeDomain && !(0, 
        vutils_1.isNil)(seriesId)) && (markScale = scale.clone()), list.push(Object.assign(Object.assign({}, spec), {
            seriesId: seriesId,
            markScale: markScale
        })), markScale;
    }
}

exports.GlobalScale = GlobalScale;
//# sourceMappingURL=global-scale.js.map
