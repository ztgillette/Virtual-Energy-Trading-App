"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerSymbolOverlapTransform = exports.transform = exports.OVERLAP_HIDE_KEY = void 0;

const base_1 = require("../../constant/base"), vutils_1 = require("@visactor/vutils"), factory_1 = require("../../core/factory");

function setVisible(g, visible) {
    g.context.finalAttrs && (g.context.finalAttrs.visible = visible);
}

function reset(graphics) {
    return graphics.forEach((g => {
        g[exports.OVERLAP_HIDE_KEY] && (setVisible(g, !0), g[exports.OVERLAP_HIDE_KEY] = !1);
    })), graphics;
}

function overlapX(graphics, delta, deltaMul) {
    let lastX = -1 / 0, lastR = 0;
    const useDeltaMul = (0, vutils_1.isNil)(delta);
    let itemDelta = delta;
    graphics.forEach((g => {
        if (!1 === g.context.finalAttrs.visible) return;
        const r = g.context.finalAttrs.size / 2, currentX = g.context.finalAttrs.x;
        useDeltaMul && (itemDelta = (r + lastR) * deltaMul), Math.abs(currentX - lastX) < itemDelta + lastR + r ? g.context.finalAttrs.forceShow || (g[exports.OVERLAP_HIDE_KEY] = !0, 
        setVisible(g, !1)) : lastX = currentX, lastR = r;
    }));
}

function overlapY(graphics, delta, deltaMul) {
    let lastY = -1 / 0, lastR = 0;
    const useDeltaMul = (0, vutils_1.isNil)(delta);
    let itemDelta = delta;
    graphics.forEach((g => {
        if (!1 === g.context.finalAttrs.visible) return;
        const r = g.context.finalAttrs.size / 2, currentY = g.context.finalAttrs.y;
        useDeltaMul && (itemDelta = (r + lastR) * deltaMul), Math.abs(currentY - lastY) < itemDelta + lastR + r ? g.context.finalAttrs.forceShow || (g[exports.OVERLAP_HIDE_KEY] = !0, 
        setVisible(g, !1)) : lastY = currentY, lastR = r;
    }));
}

function overlapXY(graphics, delta, deltaMul) {
    let lastY = -1 / 0, lastR = 0, dis = 0;
    const useDeltaMul = (0, vutils_1.isNil)(delta);
    let itemDelta = delta;
    graphics.forEach((g => {
        if (!1 === g.context.finalAttrs.visible) return;
        const r = g.context.finalAttrs.size / 2, {x: currentX, y: currentY} = g.context.finalAttrs;
        useDeltaMul && (itemDelta = (r + lastR) * deltaMul), dis = (-(1 / 0) - currentX) ** 2 + (lastY - currentY) ** 2, 
        dis < (itemDelta + lastR + r) ** 2 ? g.context.finalAttrs.forceShow || (g[exports.OVERLAP_HIDE_KEY] = !0, 
        setVisible(g, !1)) : lastY = currentY, lastR = r;
    }));
}

exports.OVERLAP_HIDE_KEY = `${base_1.PREFIX}_hide_`;

const transform = (options, upstreamData) => {
    if (!upstreamData || 0 === upstreamData.length) return upstreamData;
    const {direction: direction, delta: delta, deltaMul: deltaMul = 1, groupBy: groupBy} = options, handleOverlap = graphics => {
        reset(graphics);
        const sortedgraphics = options.sort ? graphics.slice().sort(((a, b) => a.context.finalAttrs.x - b.context.finalAttrs.x)) : graphics;
        0 === direction ? overlapXY(sortedgraphics, delta, deltaMul) : 1 === direction ? overlapX(sortedgraphics, delta, deltaMul) : overlapY(sortedgraphics, delta, deltaMul);
    };
    if (groupBy) {
        const map = upstreamData.reduce(((res, g) => {
            var _a, _b;
            const groupName = null === (_b = null === (_a = g.context.data) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b[groupBy];
            return res[groupName] ? res[groupName].push(g) : res[groupName] = [ g ], res;
        }), {});
        Object.keys(map).forEach((key => {
            handleOverlap(map[key]);
        }));
    } else handleOverlap(upstreamData);
    return upstreamData;
};

exports.transform = transform;

const registerSymbolOverlapTransform = () => {
    factory_1.Factory.registerGrammarTransform("symbolOverlap", {
        transform: exports.transform,
        runType: "afterEncode"
    });
};

exports.registerSymbolOverlapTransform = registerSymbolOverlapTransform;
//# sourceMappingURL=symbol-overlap.js.map
