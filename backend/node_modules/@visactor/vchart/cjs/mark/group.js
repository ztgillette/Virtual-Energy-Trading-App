"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerGroupMark = exports.GroupMark = void 0;

const factory_1 = require("./../core/factory"), debug_1 = require("../util/debug"), base_mark_1 = require("./base/base-mark"), interface_1 = require("./interface"), vrender_kits_1 = require("@visactor/vrender-kits"), vutils_1 = require("@visactor/vutils"), util_1 = require("../compile/util"), mark_1 = require("../util/mark");

class GroupMark extends base_mark_1.BaseMark {
    constructor() {
        super(...arguments), this.type = GroupMark.type, this._marks = [], this._diffState = interface_1.DiffState.enter;
    }
    getMarks() {
        return this._marks;
    }
    isMarkExist(mark) {
        return void 0 !== this._marks.find((m => m.id === mark.id));
    }
    addMark(mark) {
        return this.isMarkExist(mark) ? ((0, debug_1.warn)("Mark already exists, add mark failed."), 
        !1) : (this._marks.push(mark), !0);
    }
    removeMark(mark) {
        const index = this._marks.findIndex((m => m.id === mark.id || m.name === mark.name));
        return -1 === index ? ((0, debug_1.warn)("Mark does not exists, removeMark failed."), 
        !1) : (this._marks.splice(index, 1), !0);
    }
    getMarkInType(type) {
        return this._marks.filter((m => m.type === type));
    }
    getMarkInId(id) {
        return this._marks.find((m => m.id === id));
    }
    getMarkInUserId(id) {
        let result;
        return (0, util_1.traverseGroupMark)(this, (m => {
            result = m;
        }), (m => m.getUserId() === id), null, !0), result;
    }
    getMarkInName(name) {
        return this._marks.filter((m => m.name === name));
    }
    _compileProduct(option) {
        super._compileProduct(option), this.getMarks().forEach((mark => {
            mark.compile({
                group: this._product
            });
        }));
    }
    _getAttrsFromConfig(attrs = {}) {
        const configAttrs = super._getAttrsFromConfig(attrs);
        return (0, vutils_1.isNil)(this._markConfig.interactive) || (configAttrs.pickable = this._markConfig.interactive), 
        attrs;
    }
    getGraphics() {
        return [ this._product ];
    }
    renderInner() {
        var _a;
        if (!this._product) return;
        const style = null !== (_a = this._simpleStyle) && void 0 !== _a ? _a : this.getAttributesOfState({});
        this._product.context = Object.assign(Object.assign(Object.assign({}, this._product.context), this._getCommonContext()), {
            diffState: this._diffState
        }), this._setAnimationState(this._product);
        const newAttrs = this._getAttrsFromConfig(style);
        if (this._product.context.diffState === interface_1.DiffState.update) {
            const hasAnimation = this.hasAnimation(), diffAttrs = (0, mark_1.getDiffAttributesOfGraphic)(this._product, newAttrs);
            this._product.context.diffAttrs = diffAttrs, this.hasAnimationByState(this._product.context.animationState) || (hasAnimation ? this._product.setAttributesAndPreventAnimate(diffAttrs) : this._product.setAttributes(diffAttrs)), 
            hasAnimation && this._product.setFinalAttributes(newAttrs);
        } else this._product.setAttributes(newAttrs);
        this.needClear = !0;
    }
    clearExitGraphics() {
        this._diffState = interface_1.DiffState.update;
    }
    render() {
        this._isCommited && ((0, debug_1.log)(`render mark: ${this.getProductId()}, type is ${this.type}`), 
        this.renderInner(), this.uncommit()), this.getMarks().forEach((mark => {
            mark.render();
        }));
    }
    release() {
        super.release(), this.removeProduct();
    }
}

exports.GroupMark = GroupMark, GroupMark.type = "group";

const registerGroupMark = () => {
    (0, vrender_kits_1.registerShadowRoot)(), (0, vrender_kits_1.registerGroup)(), factory_1.Factory.registerMark(GroupMark.type, GroupMark);
};

exports.registerGroupMark = registerGroupMark;
//# sourceMappingURL=group.js.map
