"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerGlyphMark = exports.GlyphMark = void 0;

const base_mark_1 = require("./base/base-mark"), vrender_core_1 = require("@visactor/vrender-core"), factory_1 = require("../core/factory"), vrender_kits_1 = require("@visactor/vrender-kits"), enum_1 = require("./interface/enum"), vutils_1 = require("@visactor/vutils");

class GlyphMark extends base_mark_1.BaseMark {
    constructor() {
        super(...arguments), this._setStateOfGraphic = g => {
            g.clearStates(), g.stateProxy = null, g.context.diffState !== enum_1.DiffState.enter && g.context.diffState !== enum_1.DiffState.update || (g.glyphStateProxy = (stateName, nexStates) => {
                var _a;
                const glyphAttrs = {
                    attributes: Object.assign(Object.assign({}, this._runEncoderOfGraphic(null === (_a = this._encoderOfState) || void 0 === _a ? void 0 : _a[stateName], g)), g.runtimeStateCache ? g.runtimeStateCache[stateName] : null)
                };
                return g.glyphStates ? g.glyphStates[stateName] || (g.glyphStates[stateName] = glyphAttrs) : g.glyphStates = {
                    [stateName]: glyphAttrs
                }, glyphAttrs;
            }, g.useStates(g.context.states));
        };
    }
    getSubMarks() {
        return this._subMarks;
    }
    setGlyphConfig(cfg) {
        this._glyphConfig = cfg;
    }
    getGlyphConfig() {
        return this._glyphConfig;
    }
    getPositionChannels() {
        return this._positionChannels;
    }
    _onGlyphAttributeUpdate(glyph) {
        return newAttributes => {
            var _a, _b;
            const positionChannels = this.getPositionChannels();
            let subAttrsMap = positionChannels && this._positionEncoder && Object.keys(newAttributes).some((k => positionChannels.includes(k))) ? this._positionEncoder(newAttributes, null === (_b = null === (_a = null == glyph ? void 0 : glyph.context) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b[0], glyph) : null;
            return this._channelEncoder && Object.keys(this._channelEncoder).forEach((channel => {
                if (channel in newAttributes) {
                    const channelAttrsMap = this._channelEncoder[channel](newAttributes[channel]);
                    subAttrsMap = subAttrsMap ? (0, vutils_1.merge)(subAttrsMap, channelAttrsMap) : channelAttrsMap;
                }
            })), subAttrsMap && glyph.getSubGraphic().forEach((subGraphic => {
                subGraphic && subAttrsMap[subGraphic.name] && subGraphic.setAttributes(subAttrsMap[subGraphic.name]);
            })), newAttributes;
        };
    }
    _createGraphic(attrs = {}) {
        const glyph = (0, vrender_core_1.createGlyph)(attrs);
        glyph.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(glyph);
        const subMarks = this._subMarks;
        if (subMarks) {
            const subGraphics = [];
            Object.keys(subMarks).forEach((name => {
                const subGraphic = factory_1.Factory.createGraphicComponent(subMarks[name].type, Object.assign({}, subMarks[name].defaultAttributes));
                subGraphic && (subGraphics.push(subGraphic), subGraphic.name = name, subGraphic.onBeforeAttributeUpdate = attrs => attrs);
            })), glyph.setSubGraphic(subGraphics);
        }
        return glyph.onBeforeAttributeUpdate(attrs), glyph;
    }
    _runProgressiveEncoder(graphics) {
        this._runEncoder(graphics);
    }
}

exports.GlyphMark = GlyphMark;

const registerGlyphMark = () => {
    factory_1.Factory.registerGraphicComponent("glyph", vrender_core_1.createGlyph), 
    (0, vrender_kits_1.registerShadowRoot)(), (0, vrender_kits_1.registerGlyph)();
};

exports.registerGlyphMark = registerGlyphMark;
//# sourceMappingURL=glyph.js.map
