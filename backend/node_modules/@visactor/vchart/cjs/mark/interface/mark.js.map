{"version":3,"sources":["../src/mark/interface/mark.ts"],"names":[],"mappings":"","file":"mark.js","sourcesContent":["import type { IGraphic } from '@visactor/vrender-core';\nimport type { IMarkSpec } from '../../typings';\nimport type {\n  IArcMarkSpec,\n  IAreaMarkSpec,\n  IBoxPlotMarkSpec,\n  ICellMarkSpec,\n  ICommonSpec,\n  IComposedTextMarkSpec,\n  IGroupMarkSpec,\n  IImageMarkSpec,\n  ILineMarkSpec,\n  ILinkPathMarkSpec,\n  IPathMarkSpec,\n  IPolygonMarkSpec,\n  IRectMarkSpec,\n  IRippleMarkSpec,\n  IRuleMarkSpec,\n  ISymbolMarkSpec\n} from '../../typings/visual';\nimport type { IMark, IMarkRaw } from './common';\nimport type { MarkType } from './type';\n\nexport interface IComponentMark extends IMarkRaw<ICommonSpec> {\n  getComponent: () => IGraphic;\n  clearComponent: () => void;\n  setAttributeTransform: (t: (attrs: any) => any) => any;\n}\n\nexport interface IGlyphMark<T extends ICommonSpec = ICommonSpec, C = any> extends IMarkRaw<T> {\n  setGlyphConfig: (cfg: C) => void;\n  getGlyphConfig: () => C;\n\n  getSubMarks: () => Record<\n    string,\n    {\n      type: MarkType;\n      defaultAttributes?: any;\n    }\n  >;\n\n  getPositionChannels: () => string[];\n}\n\nexport interface ILabelMark extends ITextMark {\n  skipEncode: boolean;\n\n  getRule: () => string;\n  setRule: (rule: string) => void;\n\n  getTarget: () => IMark;\n  setTarget: (target: IMark) => void;\n\n  getComponent: () => IComponentMark;\n  setComponent: (component: IComponentMark) => void;\n}\n\nexport type ITextMark = IMarkRaw<IComposedTextMarkSpec> & { getTextType: () => 'text' | 'rich' };\n\nexport type ITextSpec<T> = IMarkSpec<T> & { textType?: 'rich' | 'text' };\n\nexport type IPolygonMark = IMarkRaw<IPolygonMarkSpec>;\n\nexport type IArcMark = IMarkRaw<IArcMarkSpec>;\n\nexport type IAreaMark = IMarkRaw<IAreaMarkSpec>;\n\nexport type IBoxPlotMark = IMarkRaw<IBoxPlotMarkSpec>;\n\nexport type ICellMark = IMarkRaw<ICellMarkSpec>;\n\nexport type IImageMark = IMarkRaw<IImageMarkSpec>;\n\nexport type ILineMark = IMarkRaw<ILineMarkSpec>;\n\nexport type ILinkPathMark = IMarkRaw<ILinkPathMarkSpec>;\n\nexport type IPathMark = IMarkRaw<IPathMarkSpec>;\n\nexport type IRectMark = IMarkRaw<IRectMarkSpec>;\n\nexport type IRippleMark = IMarkRaw<IRippleMarkSpec>;\n\nexport type IRuleMark = IMarkRaw<IRuleMarkSpec>;\n\nexport type ISymbolMark = IMarkRaw<ISymbolMarkSpec>;\n\nexport interface IGroupMark extends IMarkRaw<IGroupMarkSpec> {\n  // groupMark的zIndex只能配在外层，encode里不生效，且无法写成signal\n  // {type:'group', zIndex: 100} ✅\n  // {type:'group', encode:{enter:{zIndex:{value:100}}}} ❌\n  // {type:'group', zIndex: {signal: }} ❌\n\n  addMark: (m: IMark) => boolean;\n  removeMark: (m: IMark) => boolean;\n  // TODO: 这里可能会出现mark嵌套的问题\n  getMarks: () => IMark[];\n  getMarkInType: (type: MarkType) => IMark[];\n  getMarkInId: (id: number) => IMark | undefined;\n  getMarkInName: (name: string) => IMark[] | undefined;\n}\n\nexport interface ILinkPathConfig {\n  direction?: 'horizontal' | 'vertical' | 'LR' | 'RL' | 'TB' | 'BL' | 'radial';\n}\n"]}