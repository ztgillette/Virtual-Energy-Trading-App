{"version":3,"sources":["../src/mark/interface/common.ts"],"names":[],"mappings":"","file":"common.js","sourcesContent":["import type { IGlobalScale } from '../../scale/interface';\nimport type { ICommonSpec, VisualType, ValueType, FunctionType } from '../../typings/visual';\nimport type { IModel } from '../../model/interface';\nimport type { IBaseScale } from '@visactor/vscale';\nimport type { MarkType, MarkTypeEnum } from './type';\nimport type {\n  ICompilableMark,\n  ICompilableMarkOption,\n  IMarkConfig,\n  IModelMarkAttributeContext,\n  StateValueType\n} from '../../compile/mark/interface';\nimport type { Datum, StringOrNumber } from '../../typings';\nimport type { IGraphic } from '@visactor/vrender-core';\nimport type { IGroupMark } from './mark';\nimport type { IAnimationConfig } from '../../animation/interface';\nimport type { ICompiler } from '../../compile/interface';\n\nexport interface VisualScaleType {\n  scale: IBaseScale;\n  field: StringOrNumber;\n  changeDomain?: 'none' | 'replace' | 'expand'; //default 'none'\n}\n\nexport type MarkInputStyle<T> = StyleConvert<T> | VisualType<T>;\n\n/** 用户将属性类型转化为 mark-style 中某个属性的 style */\nexport type StyleConvert<T> = ValueType<T> | FunctionType<T> | VisualScaleType;\n\n/** mark-style 中某个属性的样式信息，包含层级等信息 */\nexport interface IAttrConfig<A, R extends ICommonSpec> {\n  level: number;\n  style: StyleConvert<A>;\n  referer?: IMarkRaw<R>;\n  postProcess?: (result: A, ...args: Parameters<FunctionType<A>>) => A;\n}\n/** mark-style 中某状态下的一组样式信息 */\nexport type IAttrs<T extends ICommonSpec> = {\n  [K in keyof T]: IAttrConfig<T[K], T>;\n};\n\nexport type IMarkProgressiveConfig = {\n  /** 是否开启大数据渲染模式，开启后会降低渲染的精度 */\n  large?: boolean;\n  /** 开启大数据渲染优化的阀值，对应的是data的长度;推荐 largeThreshold < progressiveThreshold  */\n  largeThreshold?: number;\n  /** 分片长度 */\n  progressiveStep?: number;\n  /** 开启分片渲染的阀值，对应的是单系列data的长度 */\n  progressiveThreshold?: number;\n};\n\n/** mark-state-style */\nexport type IMarkStateStyle<T extends ICommonSpec> = Record<StateValueType, Partial<IAttrs<T>>>;\n\n/** mark-style 一组style */\nexport type IMarkStyle<T extends ICommonSpec> = {\n  [key in keyof T]: MarkInputStyle<T[key]>;\n};\n\nexport type DiffStateValues = 'update' | 'enter' | 'exit';\n\nexport type AnimationStateValues = 'appear' | 'enter' | 'update' | 'exit' | 'disappear' | 'none' | 'state';\n\nexport interface IGraphicContext {\n  /**\n   * 编译器\n   */\n  compiler: ICompiler;\n  /**\n   * mark的类型\n   */\n  markType: MarkTypeEnum;\n  /**\n   * 图形所属mark对应的id，自增id\n   */\n  markId: number;\n  /**\n   * 图形所属model对应的id，自增id\n   */\n  modelId: number;\n  /**\n   * 图形所属mark对应的用户设置id\n   */\n  markUserId?: number | string;\n  /**\n   * 图形所属model对应的用户设置id\n   */\n  modelUserId?: number | string;\n  /**\n   * 数据对比状态\n   */\n  diffState?: DiffStateValues;\n  /**\n   * 是否正在被复用的图元\n   */\n  reusing?: boolean;\n  /**\n   * 复用图元时，保存的上一次的旧属性（用于平滑的过渡动画）\n   */\n  lastAttrs?: Record<string, any>;\n  /**\n   * 用于判定这个图元是第几个，在OneByOne动画中控制顺序\n   */\n  indexKey?: string;\n  /**\n   * 差异的属性\n   */\n  diffAttrs?: Record<string, any>;\n  /**\n   * 更新后最终的属性\n   */\n  finalAttrs?: Record<string, any>;\n  /**\n   * 用于保存mark对应series的fieldX\n   */\n  fieldX?: string[];\n  /**\n   * 用于保存mark对应series的fieldX\n   */\n  originalFieldX?: string[];\n  /**\n   * 用于保存mark对应series的fieldY\n   */\n  fieldY?: string[];\n  /**\n   * 用于保存mark对应series的fieldY\n   */\n  originalFieldY?: string[];\n  /**\n   * 动画状态管理: 'appear' / 'enter' / 'update' / 'exit' / 'disappear'\n   */\n  animationState?: AnimationStateValues;\n  /**\n   * 数据\n   */\n  data?: Datum[];\n  /**\n   * 用于区分图形的唯一key，\n   * 对于line/mark而言，和`groupKey` 是一致的\n   * 对于其他图元，由 `groupKey` 和 `key` 拼装得到\n   */\n  uniqueKey?: string;\n  /**\n   * 唯一key\n   */\n  key?: string;\n  /**\n   * 分组key\n   */\n  groupKey?: string;\n  /**\n   * 状态\n   */\n  states?: string[];\n  /**\n   * 图元总数量\n   */\n  graphicCount?: number;\n  /**\n   * 图元索引顺序\n   */\n  graphicIndex?: number;\n  /**\n   * 状态动画配置\n   */\n  stateAnimateConfig?: IAnimationConfig | IAnimationConfig[];\n}\n\nexport interface IMarkGraphic extends IGraphic {\n  /**\n   * 缓存运行时的状态编码数据\n   */\n  runtimeStateCache?: Record<string, any>;\n\n  /**\n   * 上下文数据\n   */\n  context?: IGraphicContext;\n\n  /**\n   * 是否正在退场\n   */\n  isExiting?: boolean;\n}\n\n/**********   mark  ***************/\nexport interface IMarkRaw<T extends ICommonSpec> extends ICompilableMark {\n  readonly stateStyle: IMarkStateStyle<T>;\n\n  getAttributesOfState: (datum: Datum, state?: StateValueType) => Partial<T>;\n  getAttribute: <U extends keyof T>(key: U, datum: any, state?: StateValueType) => unknown;\n  setAttribute: <U extends keyof T>(attr: U, style: StyleConvert<T[U]>, state?: StateValueType, level?: number) => void;\n\n  // 需要支持优先级并且可以使用优先级覆盖\n  /** @deprecated VChart 层尽量使用 IModel.setMarkStyle() */\n  setStyle: (style: Partial<IMarkStyle<T>>, state?: StateValueType, level?: number) => void;\n  setSimpleStyle: (s: T) => void;\n  getSimpleStyle: () => T;\n\n  setReferer: (mark: IMarkRaw<T>, styleKey?: string, state?: StateValueType) => void;\n\n  /** @deprecated VChart 层尽量使用 IModel.initMarkStyleWithSpec() */\n  initStyleWithSpec: (spec: any) => void;\n\n  created: () => void;\n\n  setPostProcess: <U extends keyof T, A>(\n    key: U,\n    postProcessFunc: IAttrConfig<A, T>['postProcess'],\n    state?: StateValueType\n  ) => void;\n\n  /** 更新某一个状态 */\n  updateMarkState: (key: string) => void;\n\n  render: () => void;\n  renderInner: () => void;\n\n  getGraphics: () => IMarkGraphic[];\n\n  reuse: (mark: IMark) => void;\n  prepareMorph: (mark: IMark) => void;\n\n  clearExitGraphics: () => void;\n\n  /** 是否启动了增量渲染模式 */\n  isProgressive: () => boolean;\n  /** 是否正在执行增量渲染 */\n  isDoingProgressive: () => boolean;\n  /** 清除增量渲染相关状态 */\n  clearProgressive: () => void;\n  /** 从第一帧开始增量计算 */\n  restartProgressive: () => void;\n  /** 分片执行 */\n  renderProgressive: () => void;\n  /** 增量流程后，是否执行动画 */\n  canAnimateAfterProgressive: () => boolean;\n  /** 执行动画 */\n  runAnimation: () => void;\n  /** 是否需要清除旧的数据 */\n  needClear?: boolean;\n  /** 禁用状态动画 */\n  disableAnimationByState: (state: string | string[]) => void;\n  /** 启用状态动画 */\n  enableAnimationByState: (state: string | string[]) => void;\n}\n\nexport type IMark = IMarkRaw<ICommonSpec>;\n\nexport interface ICompileMarkConfig extends IMarkConfig {\n  /** morph 配置开关 */\n  morph?: boolean;\n\n  /** morph元素的唯一key */\n  morphElementKey?: string;\n  /**\n   * 是否支持 3d\n   */\n  support3d?: boolean;\n  /**\n   * 裁剪配置\n   * @since 1.10.0\n   */\n  clip?: boolean;\n  /** skip theme of vgrammar or not */\n  skipTheme?: boolean;\n}\n\nexport interface IMarkOption extends ICompilableMarkOption {\n  model: IModel;\n  map: Map<StringOrNumber, IModel | IMark>;\n\n  globalScale: IGlobalScale;\n  seriesId?: number;\n\n  /** 组件 mark 的具体类型 */\n  componentType?: string;\n  attributeContext?: IModelMarkAttributeContext;\n\n  /** 父级 mark */\n  parent?: IGroupMark | false;\n}\nexport interface IMarkConstructor {\n  type: MarkType;\n  constructorType?: MarkType;\n  new (name: string, options: IMarkOption): IMark;\n}\n\nexport interface IComponentMarkConstructor {\n  type: MarkType;\n  constructorType?: MarkType;\n  new (componentType: string, name: string, options: IMarkOption): IMark;\n}\n\nexport type MarkConstructor = IMarkConstructor | IComponentMarkConstructor;\n\nexport interface IMarkDataInitOption extends IMarkOption {\n  mark: IMark;\n}\n\nexport type ISamplingMethod = 'lttb' | 'min' | 'max' | 'sum' | 'average';\n\nexport interface IDataSamping {\n  /**\n   * 是否使用额外的 activePoint 显示交互点，可以在点隐藏时显示被交互的点\n   * @default false\n   * @since 1.3.0\n   */\n  activePoint?: boolean;\n  /**\n   * 数据采样 - 采样方法\n   * @since 1.6.0\n   */\n  sampling?: ISamplingMethod;\n  /**\n   * 数据采样 - 采样系数\n   * @since 1.6.0\n   * @default 1\n   */\n  samplingFactor?: number;\n}\n\nexport interface IMarkOverlap {\n  /**\n   * 标记点之间的距离，px\n   * @since 1.6.0\n   */\n  pointDis?: number;\n  /**\n   * 标记点之间的距离， pointSize 的倍数\n   * @since 1.6.0\n   * @default 1\n   */\n  pointDisMul?: number;\n  /**\n   * 是否允许标记图形相互覆盖\n   * @since 1.6.0\n   * @default false\n   */\n  markOverlap?: boolean;\n}\n\nexport type GroupedData<T> = {\n  // iterating over array is faster than set\n  keys: string[];\n  // operation on map is faster than object\n  data: Map<string, T[]>;\n};\n\nexport interface IProgressiveTransformResult<Output = any> {\n  /** is progressive finished */\n  unfinished: () => boolean;\n  /** return all the result */\n  output: () => Output;\n  /** the output result of current progressive run */\n  progressiveOutput: () => Output;\n  /** run in progressive mode */\n  progressiveRun: () => void;\n  /** release the progressive context */\n  release: () => void;\n  /**\n   * can animate after progressive\n   */\n  canAnimate?: () => boolean;\n}\n\nexport type IMarkDataTransform<Options = any, Input = any, Output = any> = (\n  options: Options,\n  data: Input\n) => Output | IProgressiveTransformResult<Output>;\n\nexport interface ProgressiveContext {\n  currentIndex: number;\n  totalStep: number;\n  step: number;\n  data: any[];\n  groupKeys?: string[];\n  groupedData?: Map<string, any[]>;\n}\n"]}