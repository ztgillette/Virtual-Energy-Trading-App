"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.runEncoder = exports.groupData = exports.curveTypeTransform = exports.isMultiDatumMark = exports.MultiDatumMark = void 0;

const data_1 = require("../../constant/data");

function isMultiDatumMark(type) {
    return exports.MultiDatumMark.includes(type);
}

function curveTypeTransform(type, direction) {
    return "monotone" === type ? "horizontal" === direction ? "monotoneY" : "monotoneX" : type;
}

function groupData(data, groupBy, sort) {
    const groupedData = new Map;
    if (!data || 0 === data.length) return {
        keys: [],
        data: groupedData
    };
    if (!groupBy) return groupedData.set(data_1.DEFAULT_KEY, sort ? data.slice().sort(sort) : data.slice()), 
    {
        keys: [ data_1.DEFAULT_KEY ],
        data: groupedData
    };
    if (1 === data.length) {
        const key = groupBy(data[0], 0);
        return groupedData.set(key, [ data[0] ]), {
            keys: [ key ],
            data: groupedData
        };
    }
    const keys = new Set;
    return data.forEach(((entry, index) => {
        var _a;
        const key = groupBy(entry, index), lastData = null !== (_a = groupedData.get(key)) && void 0 !== _a ? _a : [];
        lastData.push(entry), groupedData.set(key, lastData), keys.add(key);
    })), sort && keys.forEach((key => {
        groupedData.get(key).sort(sort);
    })), {
        keys: Array.from(keys),
        data: groupedData
    };
}

exports.MultiDatumMark = [ "line", "area", "trail" ], exports.isMultiDatumMark = isMultiDatumMark, 
exports.curveTypeTransform = curveTypeTransform, exports.groupData = groupData;

const runEncoder = (styles, datum, attrs = {}) => (styles && Object.keys(styles).forEach((attrName => {
    attrs[attrName] = styles[attrName](datum);
})), attrs);

exports.runEncoder = runEncoder;
//# sourceMappingURL=common.js.map
