"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.isSegmentAttrEqual = exports.isStopsEqual = void 0;

const vutils_1 = require("@visactor/vutils"), isStopsEqual = (prev, next) => {
    var _a, _b;
    if (prev === next) return !0;
    const prevLength = null !== (_a = prev && prev.length) && void 0 !== _a ? _a : 0;
    return prevLength === (null !== (_b = next && next.length) && void 0 !== _b ? _b : 0) && 0 !== prevLength && prev.every(((prevEntry, prevIndex) => !prevEntry && !next[prevIndex] || prevEntry && next[prevIndex] && prevEntry.color === next[prevIndex].color && prevEntry.offset === next[prevIndex].offset));
};

exports.isStopsEqual = isStopsEqual;

const isColorAttrEqual = (prev, next) => {
    if (prev === next) return !0;
    if (typeof prev != typeof next) return !1;
    if ((0, vutils_1.isString)(prev)) return !1;
    if ((0, vutils_1.isArray)(prev)) return prev.length === next.length && prev.every(((prevEntry, index) => isColorAttrEqual(prevEntry, next[index])));
    if (prev.gradient !== next.gradient) return !1;
    const prevKeys = Object.keys(prev), nextKeys = Object.keys(next);
    return prevKeys.length === nextKeys.length && prevKeys.every((key => "stops" === key ? (0, 
    exports.isStopsEqual)(prev[key], next[key]) : prev[key] === next[key]));
}, isLineDashEqual = (prev, next) => prev.length === next.length && prev.join("-") === next.join("-"), isSegmentAttrEqual = (prev, next, key) => !(!(0, 
vutils_1.isNil)(prev) || !(0, vutils_1.isNil)(next)) || !(0, vutils_1.isNil)(prev) && (!(0, 
vutils_1.isNil)(next) && ("lineDash" === key ? isLineDashEqual(prev, next) : "stroke" === key || "fill" === key ? isColorAttrEqual(prev, next) : prev === next));

exports.isSegmentAttrEqual = isSegmentAttrEqual;
//# sourceMappingURL=line.js.map
