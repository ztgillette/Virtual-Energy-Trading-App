"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Event = void 0;

const factory_1 = require("../core/factory");

class Event {
    getComposedEventMap() {
        return this._composedEventMap;
    }
    constructor(eventDispatcher, mode) {
        this._composedEventMap = new Map, this._eventDispatcher = eventDispatcher, this._mode = mode;
    }
    on(eType, query, callback) {
        const handler = "function" == typeof query ? {
            query: null,
            callback: query
        } : {
            query: query,
            callback: callback
        }, ComposedEventCtor = factory_1.Factory.getComposedEvent(eType);
        if (ComposedEventCtor) {
            const composedEvent = new ComposedEventCtor(this._eventDispatcher, this._mode);
            composedEvent.register(eType, handler), this._composedEventMap.set(callback, {
                eventType: eType,
                event: composedEvent
            });
        } else this._eventDispatcher.register(eType, handler);
        return this;
    }
    off(eType, query, cb) {
        var _a, _b;
        const callback = null != cb ? cb : query;
        if (factory_1.Factory.getComposedEvent(eType)) if (callback) null === (_a = this._composedEventMap.get(callback)) || void 0 === _a || _a.event.unregister(), 
        this._composedEventMap.delete(callback); else for (const entry of this._composedEventMap.entries()) entry[1].eventType === eType && (null === (_b = this._composedEventMap.get(entry[0])) || void 0 === _b || _b.event.unregister(), 
        this._composedEventMap.delete(entry[0])); else if (callback) {
            const handler = {
                callback: callback,
                query: null,
                filter: {
                    nodeName: null,
                    type: eType,
                    level: null,
                    source: query.source,
                    markName: null,
                    filter: null,
                    userId: null
                }
            };
            this._eventDispatcher.unregister(eType, handler);
        } else this._eventDispatcher.unregister(eType);
        return this;
    }
    emit(eType, params, level) {
        return this._eventDispatcher.dispatch(eType, params, level), this;
    }
    prevent(eType, except) {
        return this._eventDispatcher.prevent(eType, except), this;
    }
    allow(eType) {
        return this._eventDispatcher.allow(eType), this;
    }
    release() {
        this._eventDispatcher.clear(), this._composedEventMap.clear();
    }
}

exports.Event = Event;
//# sourceMappingURL=event.js.map
