"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerElementActiveByLegend = exports.ElementActiveByLegend = void 0;

const factory_1 = require("../../core/factory"), base_1 = require("./base"), event_1 = require("../../constant/event"), vutils_1 = require("@visactor/vutils"), util_1 = require("./util"), interface_1 = require("../../compile/mark/interface"), type = "element-active-by-legend", defaultOptions = {
    state: interface_1.STATE_VALUE_ENUM.STATE_ACTIVE,
    filterType: "groupKey"
};

class ElementActiveByLegend extends base_1.BaseTrigger {
    constructor(options) {
        super(options), this.type = type, this.handleStart = e => {
            var _a, _b;
            const event = e.event;
            event && this.start(null === (_b = null === (_a = event.detail) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b.id);
        }, this.handleReset = e => {
            this.resetAll();
        }, this.options = Object.assign({}, defaultOptions, options), this.updateMarkIdByState([ this.options.state ]);
    }
    getEvents() {
        return [ {
            type: event_1.ChartEvent.legendItemHover,
            handler: this.handleStart
        }, {
            type: event_1.ChartEvent.legendItemUnHover,
            handler: this.handleReset
        } ];
    }
    getStartState() {
        return this.options.state;
    }
    start(itemKey) {
        if ((0, vutils_1.isNil)(itemKey)) return;
        const {interaction: interaction, state: state} = this.options, filterValue = (0, 
        util_1.generateFilterValue)(this.options), statedGraphics = interaction.getStatedGraphics(this), newStatedGraphics = [];
        this.getMarks().forEach((m => {
            var _a;
            null === (_a = m.getGraphics()) || void 0 === _a || _a.forEach((g => {
                filterValue(g) === itemKey && newStatedGraphics.push(g);
            }));
        })), interaction.updateStates(this, newStatedGraphics, statedGraphics, state), interaction.setStatedGraphics(this, newStatedGraphics);
    }
    resetAll() {
        const {interaction: interaction, state: state} = this.options;
        interaction.clearAllStatesOfTrigger(this, state), interaction.setStatedGraphics(this, []);
    }
    reset(g) {
        const {state: state, interaction: interaction} = this.options;
        if (g) {
            const statedGraphics = interaction.getStatedGraphics(this);
            statedGraphics && statedGraphics.includes(g) && (g.removeState(state), interaction.setStatedGraphics(this, statedGraphics.filter((sg => sg !== g))));
        } else this.resetAll();
    }
}

exports.ElementActiveByLegend = ElementActiveByLegend, ElementActiveByLegend.type = type, 
ElementActiveByLegend.defaultOptions = defaultOptions;

const registerElementActiveByLegend = () => {
    factory_1.Factory.registerInteractionTrigger(type, ElementActiveByLegend);
};

exports.registerElementActiveByLegend = registerElementActiveByLegend;
//# sourceMappingURL=element-active-by-legend.js.map
