"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.registerDimensionHover = exports.DimensionHover = void 0;

const vutils_1 = require("@visactor/vutils"), interface_1 = require("../../event/events/dimension/interface"), interface_2 = require("../../compile/mark/interface"), util_1 = require("../../util"), base_1 = require("./base"), factory_1 = require("../../core/factory"), defaultOptions = {
    state: interface_2.STATE_VALUE_ENUM.STATE_DIMENSION_HOVER,
    reverseState: interface_2.STATE_VALUE_ENUM.STATE_DIMENSION_HOVER_REVERSE,
    trigger: interface_1.DimensionEventEnum.dimensionHover
};

class DimensionHover extends base_1.BaseTrigger {
    constructor(options) {
        super(options), this.type = "dimension-hover", this._resetType = [], this.resetAll = () => {
            const {state: state, reverseState: reverseState, interaction: interaction} = this.options, statedGraphics = interaction.getStatedGraphics(this);
            statedGraphics && statedGraphics.length && (interaction.clearAllStatesOfTrigger(this, state, reverseState), 
            this.dispatchEvent("reset", {
                graphics: statedGraphics,
                options: this.options
            }), interaction.setStatedGraphics(this, []));
        }, this.handleStart = params => {
            const interaction = this.options.interaction;
            switch (params.action) {
              case "enter":
                const newStated = this.getStatedGraphics(params);
                interaction.updateStates(this, this.getStatedGraphics(params), interaction.getStatedGraphics(this), this.options.state, this.options.reverseState), 
                interaction.setStatedGraphics(this, newStated);
                break;

              case "leave":
                interaction.clearAllStatesOfTrigger(this, this.options.state, this.options.reverseState), 
                interaction.setStatedGraphics(this, []);
            }
        }, this.options = Object.assign({}, defaultOptions, options), this.updateMarkIdByState([ this.options.state, this.options.reverseState ]);
    }
    getStartState() {
        return this.options.state;
    }
    getResetState() {
        return this.options.reverseState;
    }
    getEvents() {
        return [ {
            type: this.options.trigger,
            handler: this.handleStart
        } ];
    }
    getStatedGraphics(params, reverse = !1) {
        const marks = this.getMarksByState(reverse ? this.options.reverseState : this.options.state), items = [];
        return params.dimensionInfo.forEach((df => {
            df.data.forEach((dd => {
                marks.filter((m => m.model === dd.series && m.getVisible())).forEach((m => {
                    const graphics = m.getGraphics();
                    if (!graphics || !graphics.length) return;
                    const elements = graphics.filter((g => {
                        const datum = (0, util_1.getDatumOfGraphic)(g);
                        let c;
                        return c = (0, vutils_1.isArray)(datum) ? datum.every(((oneData, i) => oneData === dd.datum[i])) : dd.datum.some((dd_d => dd_d === datum)), 
                        reverse ? !c : c;
                    }));
                    items.push(...elements);
                }));
            }));
        })), items;
    }
}

exports.DimensionHover = DimensionHover, DimensionHover.type = "dimension-hover", 
DimensionHover.defaultOptions = defaultOptions;

const registerDimensionHover = () => {
    factory_1.Factory.registerInteractionTrigger(DimensionHover.type, DimensionHover);
};

exports.registerDimensionHover = registerDimensionHover;
//# sourceMappingURL=dimension-hover.js.map
