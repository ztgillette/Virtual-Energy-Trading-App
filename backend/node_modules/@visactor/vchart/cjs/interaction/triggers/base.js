"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseTrigger = void 0;

const vutils_1 = require("@visactor/vutils"), mark_set_1 = require("../../mark/mark-set"), util_1 = require("./util");

class BaseTrigger {
    constructor(options) {
        this._markSet = new mark_set_1.MarkSet, this.options = options, options.marks && options.marks.length && options.marks.forEach((m => {
            this.registerMark(m);
        }));
    }
    getMarks() {
        return this._markSet.getMarks();
    }
    getMarksByState(state) {
        if (this._markIdByState && this._markSet) {
            const markIds = this._markIdByState[state];
            return markIds ? this.getMarks().filter((mark => mark && markIds.includes(mark.id))) : [];
        }
        return [];
    }
    registerMark(mark) {
        (0, vutils_1.isArray)(mark) ? mark.forEach((m => {
            this._markSet.addMark(m);
        })) : this._markSet.addMark(mark);
    }
    updateMarkIdByState(states) {
        this._markIdByState = (0, util_1.groupMarksByState)(this.getMarks(), states);
    }
    getMarkIdByState() {
        var _a;
        return null !== (_a = this._markIdByState) && void 0 !== _a ? _a : {};
    }
    isGraphicInStateMark(g, state) {
        var _a;
        const markIdByState = this.getMarkIdByState();
        return markIdByState && markIdByState[state] && markIdByState[state].includes(null === (_a = g.context) || void 0 === _a ? void 0 : _a.markId);
    }
    isGraphicInMark(g) {
        var _a;
        return !!this._markSet.getMarkInId(null === (_a = g.context) || void 0 === _a ? void 0 : _a.markId);
    }
    getStartState() {
        return null;
    }
    getResetState() {
        return null;
    }
    init() {
        const events = this.getEvents();
        events && this.options.event && events.forEach((evt => {
            evt.type && evt.handler && ((0, vutils_1.isArray)(evt.type) ? evt.type.forEach((evtType => {
                evtType && "none" !== evtType && this.options.event.on(evtType, evt.handler);
            })) : "none" !== evt.type && this.options.event.on(evt.type, evt.handler));
        }));
    }
    release() {
        const events = this.getEvents();
        events && this.options.event && (null != events ? events : []).forEach((evt => {
            evt.type && evt.handler && ((0, vutils_1.isArray)(evt.type) ? evt.type.forEach((evtType => {
                evtType && "none" !== evtType && this.options.event.on(evtType, evt.handler);
            })) : "none" !== evt.type && this.options.event.off(evt.type, evt.handler));
        }));
    }
    start(g) {}
    reset(g) {}
    dispatchEvent(type, params) {
        this.options.event && (this.options.event.emit(`${this.type}:${type}`, params), 
        "start" === type && this.options.onStart ? this.options.onStart(params) : "reset" === type && this.options.onReset ? this.options.onReset(params) : "update" === type && this.options.onUpdate ? this.options.onUpdate(params) : "end" === type && this.options.onEnd && this.options.onEnd(params));
    }
}

exports.BaseTrigger = BaseTrigger;
//# sourceMappingURL=base.js.map
