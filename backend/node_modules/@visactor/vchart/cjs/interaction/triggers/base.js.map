{"version":3,"sources":["../src/interaction/triggers/base.ts"],"names":[],"mappings":"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","file":"base.js","sourcesContent":["import { isArray } from '@visactor/vutils';\nimport type { IBaseTriggerOptions, ITrigger, ITriggerEventHandler } from '../interface/trigger';\nimport type { IMark, IMarkGraphic } from '../../mark/interface/common';\nimport { MarkSet } from '../../mark/mark-set';\nimport { groupMarksByState } from './util';\n\nexport abstract class BaseTrigger<T extends IBaseTriggerOptions> implements ITrigger<T> {\n  options: T;\n  type: string;\n\n  protected _markSet: MarkSet = new MarkSet();\n\n  protected _markIdByState: Record<string, number[]>;\n\n  constructor(options: T) {\n    this.options = options;\n\n    if (options.marks && options.marks.length) {\n      options.marks.forEach(m => {\n        this.registerMark(m);\n      });\n    }\n  }\n\n  getMarks(): IMark[] {\n    return this._markSet.getMarks();\n  }\n\n  getMarksByState(state: string): IMark[] {\n    if (this._markIdByState && this._markSet) {\n      const markIds = this._markIdByState[state];\n\n      return markIds ? this.getMarks().filter(mark => mark && markIds.includes(mark.id)) : [];\n    }\n\n    return [];\n  }\n\n  registerMark(mark: IMark | IMark[]) {\n    if (isArray(mark)) {\n      mark.forEach(m => {\n        this._markSet.addMark(m);\n      });\n    } else {\n      this._markSet.addMark(mark);\n    }\n  }\n\n  updateMarkIdByState(states: string[]) {\n    this._markIdByState = groupMarksByState(this.getMarks(), states);\n  }\n\n  getMarkIdByState() {\n    return this._markIdByState ?? {};\n  }\n\n  isGraphicInStateMark(g: IMarkGraphic, state: string) {\n    const markIdByState = this.getMarkIdByState();\n\n    return markIdByState && markIdByState[state] && markIdByState[state].includes(g.context?.markId);\n  }\n\n  isGraphicInMark(g: IMarkGraphic) {\n    return !!this._markSet.getMarkInId(g.context?.markId);\n  }\n\n  protected abstract getEvents(): Array<{ type: string | string[]; handler: ITriggerEventHandler }>;\n\n  getStartState(): string {\n    return null;\n  }\n\n  getResetState(): string {\n    return null;\n  }\n\n  init() {\n    const events = this.getEvents();\n\n    if (events && this.options.event) {\n      events.forEach(evt => {\n        if (evt.type && evt.handler) {\n          if (isArray(evt.type)) {\n            evt.type.forEach(evtType => {\n              evtType && evtType !== 'none' && this.options.event.on(evtType, evt.handler);\n            });\n          } else {\n            evt.type !== 'none' && this.options.event.on(evt.type, evt.handler);\n          }\n        }\n      });\n    }\n  }\n\n  release() {\n    // unbind events\n    const events = this.getEvents();\n\n    if (events && this.options.event) {\n      (events ?? []).forEach(evt => {\n        if (evt.type && evt.handler) {\n          if (isArray(evt.type)) {\n            evt.type.forEach(evtType => {\n              evtType && evtType !== 'none' && this.options.event.on(evtType, evt.handler);\n            });\n          } else {\n            evt.type !== 'none' && this.options.event.off(evt.type, evt.handler);\n          }\n        }\n      });\n    }\n  }\n\n  start(g: IMarkGraphic | string) {\n    // do nothing\n  }\n\n  reset(g?: IMarkGraphic) {\n    // do nothing\n  }\n\n  protected dispatchEvent(type: 'start' | 'reset' | 'update' | 'end', params: any) {\n    if (this.options.event) {\n      this.options.event.emit(`${this.type}:${type}`, params);\n\n      if (type === 'start' && this.options.onStart) {\n        this.options.onStart(params);\n      } else if (type === 'reset' && this.options.onReset) {\n        this.options.onReset(params);\n      } else if (type === 'update' && this.options.onUpdate) {\n        this.options.onUpdate(params);\n      } else if (type === 'end' && this.options.onEnd) {\n        this.options.onEnd(params);\n      }\n    }\n  }\n}\n"]}