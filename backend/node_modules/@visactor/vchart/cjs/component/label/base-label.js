"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.BaseLabelComponent = void 0;

const base_component_1 = require("../base/base-component"), type_1 = require("../interface/type"), layout_1 = require("../../constant/layout"), vutils_1 = require("@visactor/vutils"), enum_1 = require("../../mark/interface/enum"), core_1 = require("../../core");

class BaseLabelComponent extends base_component_1.BaseComponent {
    constructor(spec, options) {
        super(spec, options), this.type = type_1.ComponentTypeEnum.label, this.name = type_1.ComponentTypeEnum.label, 
        this.layoutType = "none", this.layoutZIndex = layout_1.LayoutZIndex.Label, this._regions = options.getRegionsInIndex(options.regionIndexes);
    }
    _interactiveConfig(labelSpec) {
        const {interactive: interactive} = labelSpec, result = {
            hover: !1,
            select: !1,
            state: labelSpec.state
        };
        if (!0 !== interactive) return result;
        const {hover: hover, select: select} = this._option.getChart().getSpec();
        return !1 === hover && !1 === hover.enable || (result.hover = !0), !1 === select && !1 === select.enable || (result.select = !0), 
        result;
    }
    _compareSpec(spec, prevSpec) {
        const result = super._compareSpec(spec, prevSpec);
        return result.reRender = !0, (0, vutils_1.isEqual)(prevSpec, spec) || (result.reMake = !0), 
        result;
    }
    _getDataLabelType(baseMark, type) {
        const markType = baseMark.type;
        return "line" === markType || "area" === markType ? null != type ? type : "line-data" : "rect" === markType ? "rect" : "arc" === markType ? "arc" : "symbol" === markType || "cell" === markType ? "symbol" : baseMark.setDataLabelType ? baseMark.setDataLabelType() : "";
    }
    _setTransformOfComponent(labelComponent, baseMark) {
        labelComponent.setAttributeTransform((({labelStyle: labelStyle, size: size, itemEncoder: itemEncoder}) => {
            const regionSize = size(), defaultFill = (0, core_1.getActualColor)({
                type: "palette",
                key: "secondaryFontColor"
            }, this.getColorScheme());
            return {
                dataLabels: (0, vutils_1.array)(baseMark).map(((mark, labelIndex) => {
                    const labelStyleRes = labelStyle(labelIndex), labelData = [], graphics = mark.getGraphics();
                    if (graphics) return labelStyleRes.data && labelStyleRes.data.length ? labelStyleRes.data.forEach(((d, index) => {
                        if (graphics[index]) {
                            const formattedDatum = itemEncoder(d, {
                                labelIndex: labelIndex
                            });
                            (0, vutils_1.isNil)(formattedDatum.fill) && (formattedDatum.fill = defaultFill), 
                            (0, vutils_1.isNil)(formattedDatum.data) && (formattedDatum.data = d), labelData.push(formattedDatum);
                        }
                    })) : graphics.forEach((g => {
                        const {data: data, diffState: diffState} = g.context;
                        diffState !== enum_1.DiffState.exit && data.forEach(((datum, {}) => {
                            const formattedDatum = itemEncoder(datum, {
                                labelIndex: labelIndex
                            });
                            (0, vutils_1.isNil)(formattedDatum.fill) && (formattedDatum.fill = defaultFill), 
                            (0, vutils_1.isNil)(formattedDatum.data) && (formattedDatum.data = datum), labelData.push(formattedDatum);
                        }));
                    })), (0, vutils_1.isPlainObject)(labelStyleRes.overlap) && (0, vutils_1.isNil)(labelStyleRes.overlap.size) && (labelStyleRes.overlap.size = Object.assign({}, regionSize)), 
                    Object.assign(Object.assign({
                        smartInvert: !1,
                        baseMarkGroupName: mark.getProductId(),
                        getBaseMarks: () => graphics
                    }, labelStyleRes), {
                        type: this._getDataLabelType(mark, labelStyleRes.type),
                        data: labelData
                    });
                })),
                size: regionSize
            };
        }));
    }
    getVRenderComponents() {
        const labels = [];
        return this.getMarks().forEach((m => {
            const graphicItem = m.getComponent();
            graphicItem && labels.push(graphicItem);
        })), labels;
    }
    clear() {
        super.clear(), this.getMarks().forEach((m => {
            m && m.clearComponent();
        }));
    }
}

exports.BaseLabelComponent = BaseLabelComponent, BaseLabelComponent.type = type_1.ComponentTypeEnum.label;
//# sourceMappingURL=base-label.js.map
