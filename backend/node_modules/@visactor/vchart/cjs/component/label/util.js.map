{"version":3,"sources":["../src/component/label/util.ts"],"names":[],"mappings":"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","file":"util.js","sourcesContent":["import type { WaterfallSeries } from './../../series/waterfall/waterfall';\nimport type { Datum } from '../../typings/common';\nimport { Direction } from '../../typings/space';\nimport type { BaseLabelAttrs, LabelItem, OverlapAttrs, Strategy } from '@visactor/vrender-components';\nimport { SeriesTypeEnum, type ICartesianSeries } from '../../series/interface';\nimport { isBoolean, isFunction, isObject, isString } from '@visactor/vutils';\nimport { createText } from '@visactor/vrender-core';\nimport type { IWaterfallSeriesSpec } from '../../series/waterfall/interface';\nimport type { ILabelInfo, ILabelSpec } from './interface';\nimport { getFormatFunction } from '../util';\nimport { DEFAULT_DATA_SERIES_FIELD } from '../../core';\n\nexport const labelRuleMap = {\n  rect: barLabel,\n  symbol: symbolLabel,\n  arc: pieLabel,\n  point: pointLabel,\n  'line-data': lineDataLabel,\n  stackLabel: stackLabel,\n  line: LineLabel,\n  area: LineLabel,\n  rect3d: barLabel,\n  arc3d: pieLabel,\n  treemap: treemapLabel,\n  venn: vennLabel\n};\n\nexport function defaultLabelConfig(rule: string, labelInfo: ILabelInfo) {\n  const { labelSpec } = labelInfo;\n  if (labelSpec.overlap && !isObject(labelSpec.overlap)) {\n    labelSpec.overlap = {};\n  }\n  const processor = (labelRuleMap as any)[rule] ?? labelRuleMap.point;\n\n  if (labelInfo.series.type === SeriesTypeEnum.sankey) {\n    return sankeyLabel(labelInfo);\n  }\n  return processor(labelInfo);\n}\n\nexport function textAttribute(\n  labelInfo: ILabelInfo,\n  datum: Datum,\n  formatMethod?: ILabelSpec['formatMethod'],\n  formatter?: ILabelSpec['formatter']\n) {\n  const { labelMark, series } = labelInfo;\n  const field = series.getMeasureField()[0];\n  const textAttribute = labelMark.getAttributesOfState(datum);\n\n  if (!('text' in textAttribute)) {\n    textAttribute.text = textAttribute.text ?? datum[field];\n  }\n  if (!('textType' in textAttribute)) {\n    textAttribute.textType = labelInfo.labelSpec.textType ?? 'text';\n  }\n  textAttribute.data = datum;\n\n  if (series.type !== SeriesTypeEnum.sankey) {\n    const { formatFunc, args } = getFormatFunction(\n      formatMethod,\n      formatter,\n      textAttribute.text as string | number,\n      datum\n    );\n    if (formatFunc) {\n      textAttribute._originText = textAttribute.text;\n      textAttribute.text = formatFunc(...args, { series });\n    }\n  }\n\n  return textAttribute;\n}\n\nfunction uniformLabelPosition(position?: ILabelSpec['position']) {\n  if (isFunction(position)) {\n    return (datum: Datum) => {\n      return position(datum.data);\n    };\n  }\n  return position;\n}\n\n/**\n * symbol 图元标签规则。\n */\nexport function symbolLabel(labelInfo: ILabelInfo) {\n  const { series, labelSpec } = labelInfo;\n\n  // encode position config\n  const defaultPosition = (series as ICartesianSeries).direction === 'horizontal' ? 'right' : 'top';\n  const position = uniformLabelPosition(labelSpec.position) ?? defaultPosition;\n\n  // encode overlap config\n  let overlap: OverlapAttrs | boolean;\n  if (labelSpec.overlap === false) {\n    overlap = false;\n  } else {\n    overlap = {\n      // clampForce: true,\n      strategy: (labelSpec.overlap as OverlapAttrs)?.strategy ?? symbolLabelOverlapStrategy(),\n      avoidBaseMark: position !== 'center'\n    };\n  }\n\n  return { position, overlap };\n}\n\nexport function lineDataLabel(labelInfo: ILabelInfo) {\n  const result = symbolLabel(labelInfo);\n  if (!isBoolean(result.overlap)) {\n    result.overlap.avoidBaseMark = false;\n    result.overlap.clampForce = false;\n  }\n  return result;\n}\n\nfunction symbolLabelOverlapStrategy() {\n  const strategy: Strategy[] = [\n    {\n      type: 'position',\n      position: ['top', 'bottom', 'right', 'left', 'top-right', 'top-left', 'bottom-left', 'bottom-right']\n    }\n  ];\n\n  return strategy;\n}\n\n/**\n *\n */\nexport function barLabel(labelInfo: ILabelInfo) {\n  const { series, labelSpec = {} as ILabelSpec } = labelInfo;\n\n  // encode position config\n  const originPosition = uniformLabelPosition(labelSpec.position) ?? 'outside';\n  const direction = (series as ICartesianSeries).direction ?? 'vertical';\n  const isInverse =\n    (series as ICartesianSeries).direction === 'horizontal'\n      ? (series as ICartesianSeries).getXAxisHelper()?.isInverse()\n      : (series as ICartesianSeries).getYAxisHelper()?.isInverse();\n\n  let position = originPosition as BaseLabelAttrs['position'];\n\n  position = (datum: Datum) => {\n    const { data } = datum;\n\n    const labelPosition =\n      (typeof labelSpec.position === 'function'\n        ? (labelSpec.position as (a: Datum) => string)(data)\n        : labelSpec.position) ?? 'outside';\n\n    if (labelPosition === 'outside') {\n      const dataField = series.getMeasureField()[0];\n      const positionMap = { vertical: ['top', 'bottom'], horizontal: ['right', 'left'] };\n      const index = (data?.[dataField] >= 0 && isInverse) || (data?.[dataField] < 0 && !isInverse) ? 1 : 0;\n      return positionMap[direction][index];\n    }\n\n    return labelPosition;\n  };\n\n  // encode overlap config\n  let overlap;\n  if (labelSpec.overlap === false) {\n    overlap = false;\n  } else {\n    overlap = {\n      strategy: (labelSpec.overlap as OverlapAttrs)?.strategy ?? barLabelOverlapStrategy(series as ICartesianSeries)\n    };\n  }\n\n  // encode smartInvert\n  let smartInvert = false;\n  if (isString(originPosition) && originPosition.includes('inside')) {\n    smartInvert = true;\n  }\n\n  return { position, overlap, smartInvert };\n}\n\nfunction barLabelOverlapStrategy(series: ICartesianSeries) {\n  const strategy: Strategy[] = [\n    {\n      type: 'position',\n      position: (data: any) => {\n        const { data: datum } = data;\n        const dataField = series.getMeasureField()[0];\n        const isInverse =\n          (series as ICartesianSeries).direction === 'horizontal'\n            ? (series as ICartesianSeries).getXAxisHelper()?.isInverse()\n            : (series as ICartesianSeries).getYAxisHelper()?.isInverse();\n        if (isInverse) {\n          if (datum?.[dataField] >= 0) {\n            return series.direction === 'horizontal' ? ['left', 'inside-left'] : ['bottom', 'inside-bottom'];\n          }\n          return series.direction === 'horizontal' ? ['right', 'inside-right'] : ['top', 'inside-top'];\n        }\n        if (datum?.[dataField] >= 0) {\n          return series.direction === 'horizontal' ? ['right', 'inside-right'] : ['top', 'inside-top'];\n        }\n        return series.direction === 'horizontal' ? ['left', 'inside-left'] : ['bottom', 'inside-bottom'];\n      }\n    }\n  ];\n\n  return strategy;\n}\n\n/**\n * 无关图元，指定x/y坐标的标签配置规则\n */\nexport function pointLabel(labelInfo: ILabelInfo) {\n  const { labelSpec } = labelInfo;\n\n  // encode overlap config\n  let overlap;\n  if (labelSpec.overlap === false) {\n    overlap = false;\n  } else {\n    overlap = {\n      clampForce: false,\n      avoidBaseMark: false\n    };\n  }\n\n  return { position: 'center', overlap };\n}\n\n/**\n * pie 图元标签配置规则\n */\n\nexport function pieLabel(labelInfo: ILabelInfo) {\n  const { labelSpec } = labelInfo;\n  // encode position config\n  const labelPosition = uniformLabelPosition(labelSpec.position) ?? 'outside';\n  const position = labelPosition as BaseLabelAttrs['position'];\n\n  // encode smartInvert\n  let smartInvert;\n  if (labelSpec.smartInvert) {\n    smartInvert = labelSpec.smartInvert;\n  } else {\n    smartInvert = isString(labelPosition) && labelPosition.includes('inside');\n  }\n\n  return { position, smartInvert };\n}\n\n/**\n * 瀑布图堆积标签配置规则\n */\n\nexport function stackLabelX(datum2: Datum, series: WaterfallSeries, pos: string, offset: number) {\n  if (series.direction === Direction.horizontal) {\n    if (pos === 'middle') {\n      return (series.totalPositionX(datum2, 'end') + series.totalPositionY(datum2, 'start')) * 0.5;\n    } else if (pos === 'max') {\n      return series.totalPositionX(datum2, datum2.end >= datum2.start ? 'end' : 'start') + offset;\n    } else if (pos === 'min') {\n      return series.totalPositionX(datum2, datum2.end >= datum2.start ? 'start' : 'end') - offset;\n    }\n    return series.totalPositionX(datum2, 'end') + (datum2.end >= datum2.start ? offset : -offset);\n  }\n  return series.totalPositionX(datum2, 'index', 0.5);\n}\nexport function stackLabelY(datum2: Datum, series: WaterfallSeries, pos: string, offset: number) {\n  if (series.direction === Direction.horizontal) {\n    return series.totalPositionY(datum2, 'index', 0.5);\n  }\n  if (pos === 'middle') {\n    return (series.totalPositionY(datum2, 'end') + series.totalPositionY(datum2, 'start')) * 0.5;\n  } else if (pos === 'max') {\n    return series.totalPositionY(datum2, datum2.end >= datum2.start ? 'end' : 'start') - offset;\n  } else if (pos === 'min') {\n    return series.totalPositionY(datum2, datum2.end >= datum2.start ? 'start' : 'end') + offset;\n  }\n  return series.totalPositionY(datum2, 'end') + (datum2.end >= datum2.start ? -offset : offset);\n}\n\nexport function stackLabel(\n  labelInfo: ILabelInfo,\n  datumTransform?: (data: any) => any,\n  attributeTransform?: (label: LabelItem, datum: Datum, att: any) => any\n) {\n  const series = labelInfo.series as WaterfallSeries;\n  const labelSpec = labelInfo.labelSpec || ({} as IWaterfallSeriesSpec['stackLabel']);\n  const totalData = series.getTotalData();\n  return {\n    customLayoutFunc: (labels: LabelItem[]) => {\n      return labels.map(label => {\n        const pos = labelSpec.position || 'withChange';\n        const offset = labelSpec.offset || 0;\n\n        const datum = datumTransform ? datumTransform(label.data) : label.data;\n        const attribute = textAttribute(labelInfo, datum, labelSpec.formatMethod);\n\n        attribute.x = stackLabelX(datum, series, pos, offset);\n        attribute.y = stackLabelY(datum, series, pos, offset);\n        if (series.direction === Direction.horizontal) {\n          attribute.textAlign =\n            pos === 'middle'\n              ? 'center'\n              : (pos === 'withChange' && datum.end - datum.start >= 0) || pos === 'max'\n              ? 'left'\n              : 'right';\n        } else {\n          attribute.textBaseline =\n            pos === 'middle'\n              ? pos\n              : (pos === 'withChange' && datum.end - datum.start >= 0) || pos === 'max'\n              ? 'bottom'\n              : 'top';\n        }\n        attributeTransform?.(label, datum, attribute);\n        return createText({ ...attribute, id: label.id } as any);\n      });\n    },\n    dataFilter: (labels: LabelItem[]) => {\n      const result: LabelItem[] = [];\n      totalData.forEach((total: any) => {\n        const label = labels.find(labelItem => {\n          return total.index === labelItem.data?.[series.getDimensionField()[0]];\n        });\n        if (label) {\n          label.data = total;\n          result.push(label);\n        }\n      });\n      return result;\n    },\n    overlap: {\n      strategy: [] as any\n    }\n  };\n}\n\n/**\n * treemap 非叶子节点标签配置规则\n */\nexport function treemapLabel(labelInfo: ILabelInfo) {\n  return {\n    customLayoutFunc: (labels: LabelItem[], text: any) => text,\n    overlap: false\n  };\n}\n\n/**\n * venn 标签配置规则\n */\nexport function vennLabel(labelInfo: ILabelInfo) {\n  return {\n    customLayoutFunc: (labels: LabelItem[], text: any) => text,\n    smartInvert: true\n  };\n}\n\n/**\n * line 图元标签\n */\n\nexport function LineLabel(labelInfo: ILabelInfo) {\n  const { labelSpec, series } = labelInfo;\n\n  const seriesData = series.getViewDataStatistics?.().latestData?.[series.getSeriesField()]?.values;\n  const data = seriesData\n    ? seriesData.map((d: Datum, index: number) => ({ [series.getSeriesField()]: d, index }))\n    : [\n        {\n          index: 0,\n          [DEFAULT_DATA_SERIES_FIELD]: series.getSeriesKeys()[0]\n        }\n      ];\n  return {\n    position: labelSpec.position ?? 'end',\n    data,\n    overlap: {\n      avoidBaseMark: false,\n      clampForce: false\n    }\n  };\n}\n\nexport function sankeyLabel(labelInfo: ILabelInfo) {\n  const { series, labelSpec = {} as ILabelSpec } = labelInfo;\n  // encode position config\n  const originPosition = uniformLabelPosition(labelSpec.position) ?? 'outside';\n  const direction = (series as ICartesianSeries).direction;\n  let position = originPosition as BaseLabelAttrs['position'];\n\n  if (isString(originPosition)) {\n    if (direction === 'vertical') {\n      if (originPosition === 'inside-start') {\n        position = (datum: Datum) => {\n          return 'inside-left';\n        };\n      } else if (originPosition === 'inside-middle') {\n        position = (datum: Datum) => {\n          return 'center';\n        };\n      } else if (originPosition === 'inside-end') {\n        position = (datum: Datum) => {\n          return 'inside-right';\n        };\n      } else {\n        position = (datum: Datum) => {\n          return 'bottom';\n        };\n      }\n    } else {\n      if (originPosition === 'inside-start') {\n        position = (datum: Datum) => {\n          return 'inside-left';\n        };\n      } else if (originPosition === 'inside-middle') {\n        position = (datum: Datum) => {\n          return 'center';\n        };\n      } else if (originPosition === 'inside-end') {\n        position = (datum: Datum) => {\n          return 'inside-right';\n        };\n      } else if (originPosition === 'outside') {\n        position = (datum: Datum) => {\n          return 'right';\n        };\n      }\n    }\n  }\n  // encode overlap config\n  let overlap;\n  if (labelSpec.overlap === false) {\n    overlap = false;\n  } else {\n    overlap =\n      isString(originPosition) && originPosition.includes('inside')\n        ? false\n        : {\n            strategy:\n              (labelSpec.overlap as OverlapAttrs)?.strategy ?? sankeyLabelOverlapStrategy(series as ICartesianSeries)\n          };\n  }\n\n  return {\n    position,\n    overlap,\n    smartInvert: false,\n    offset: 0,\n    syncState: true\n  };\n}\n\nfunction sankeyLabelOverlapStrategy(series: ICartesianSeries) {\n  const strategy: Strategy[] = [\n    {\n      type: 'position',\n      position: (data: any) => {\n        return series.direction === 'horizontal' ? ['right', 'left'] : ['bottom', 'top'];\n      }\n    }\n  ];\n\n  return strategy;\n}\n"]}