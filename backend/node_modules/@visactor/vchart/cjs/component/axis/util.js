"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.shouldUpdateAxis = exports.getAxisItem = exports.isDiscreteAxis = exports.isValidPolarAxis = exports.isValidCartesianAxis = exports.getLinearAxisSpecDomain = exports.getAxisLabelOffset = exports.transformAxisLineStyle = exports.DEFAULT_TITLE_STYLE = void 0;

const vutils_1 = require("@visactor/vutils"), style_1 = require("../../util/style");

function transformAxisLineStyle(lineCfg) {
    return (lineCfg = (0, style_1.transformComponentStyle)(lineCfg)).startSymbol = (0, 
    style_1.transformComponentStyle)(lineCfg.startSymbol), lineCfg.endSymbol = (0, style_1.transformComponentStyle)(lineCfg.endSymbol), 
    lineCfg;
}

function getAxisLabelOffset(axisSpec) {
    let labelOffset = 0;
    return (0, vutils_1.get)(axisSpec, "tick.visible") && (labelOffset += (0, vutils_1.get)(axisSpec, "tick.tickSize")), 
    (0, vutils_1.get)(axisSpec, "label.visible") && (labelOffset += (0, vutils_1.get)(axisSpec, "label.space")), 
    labelOffset;
}

function getLinearAxisSpecDomain(axisSpec, defaultDomain) {
    var _a, _b, _c, _d, _e, _f;
    return {
        min: null !== (_c = null !== (_a = axisSpec.min) && void 0 !== _a ? _a : null === (_b = axisSpec.range) || void 0 === _b ? void 0 : _b.min) && void 0 !== _c ? _c : null == defaultDomain ? void 0 : defaultDomain.min,
        max: null !== (_f = null !== (_d = axisSpec.max) && void 0 !== _d ? _d : null === (_e = axisSpec.range) || void 0 === _e ? void 0 : _e.max) && void 0 !== _f ? _f : null == defaultDomain ? void 0 : defaultDomain.max
    };
}

function isValidCartesianAxis(spec) {
    const orient = null == spec ? void 0 : spec.orient;
    return "top" === orient || "bottom" === orient || "left" === orient || "right" === orient || "z" === orient;
}

function isValidPolarAxis(spec) {
    const orient = null == spec ? void 0 : spec.orient;
    return "angle" === orient || "radius" === orient;
}

exports.DEFAULT_TITLE_STYLE = {
    left: {
        textAlign: "center",
        textBaseline: "bottom"
    },
    right: {
        textAlign: "center",
        textBaseline: "bottom"
    },
    radius: {},
    angle: {}
}, exports.transformAxisLineStyle = transformAxisLineStyle, exports.getAxisLabelOffset = getAxisLabelOffset, 
exports.getLinearAxisSpecDomain = getLinearAxisSpecDomain, exports.isValidCartesianAxis = isValidCartesianAxis, 
exports.isValidPolarAxis = isValidPolarAxis;

const isDiscreteAxis = axisType => "band" === axisType || "ordinal" === axisType || "point" === axisType;

function getAxisItem(value, normalizedValue) {
    return {
        id: value,
        label: value,
        value: normalizedValue,
        rawValue: value
    };
}

function shouldUpdateAxis(preHelper, curHelper, forceUpdate) {
    return forceUpdate || !preHelper || preHelper.getAxisId() === curHelper.getAxisId();
}

exports.isDiscreteAxis = isDiscreteAxis, exports.getAxisItem = getAxisItem, exports.shouldUpdateAxis = shouldUpdateAxis;
//# sourceMappingURL=util.js.map
