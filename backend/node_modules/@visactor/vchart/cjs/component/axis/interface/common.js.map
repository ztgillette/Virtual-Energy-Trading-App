{"version":3,"sources":["../src/component/axis/interface/common.ts"],"names":[],"mappings":";;;AAsHA,IAAY,QAGX;AAHD,WAAY,QAAQ;IAClB,iCAAqB,CAAA;IACrB,qCAAyB,CAAA;AAC3B,CAAC,EAHW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAGnB;AAED,IAAY,QAGX;AAHD,WAAY,QAAQ;IAClB,yCAA6B,CAAA;IAC7B,6CAAiC,CAAA;AACnC,CAAC,EAHW,QAAQ,GAAR,gBAAQ,KAAR,gBAAQ,QAGnB","file":"common.js","sourcesContent":["import type { IContinuousScale, IBaseScale, CustomTicksFunc } from '@visactor/vscale';\nimport type { CoordinateType, Datum, IPolarOrientType, StringOrNumber } from '../../../typings';\nimport type { IComponent } from '../../interface/common';\nimport type { ICartesianAxisSpec } from '../cartesian/interface';\nimport type { ITextGraphicAttribute } from '@visactor/vrender-core';\nimport type { IComponentMark } from '../../../mark/interface';\n\nexport interface StatisticsDomain {\n  domain: any[];\n  index: { [key in StringOrNumber]: number };\n}\n\nexport interface IAxis extends IComponent {\n  valueToPosition: (value: any) => number;\n  getScale: () => IBaseScale;\n  getScales: () => IBaseScale[];\n  getOrient: () => ICartesianAxisSpec['orient'] | IPolarOrientType;\n  getInverse: () => boolean;\n  getCoordinateType: () => CoordinateType;\n  visible: boolean;\n  // 标记轴的方向，左到右，右到左，上到下，下到上\n  directionStr?: 'l2r' | 'r2l' | 't2b' | 'b2t';\n}\n\nexport interface IAxisItem<T> {\n  /**\n   * 是否显示\n   */\n  visible?: boolean;\n  /**\n   * 样式配置\n   */\n  style?: Omit<T, 'visible'>;\n}\n\nexport interface IAxisItemTheme<T> {\n  /**\n   * 是否显示\n   */\n  visible?: boolean;\n  /**\n   * 主题样式配置\n   */\n  style?: Omit<T, 'visible'>;\n}\nexport type AxisAnimationPreset = 'groupFadeIn' | 'fadeIn' | 'grow';\n\nexport type ITickCallbackOption = {\n  axisLength?: number;\n  labelStyle?: ITextGraphicAttribute;\n};\n\nexport type StyleCallback<T> = (value: any, index: number, datum: Datum, data: Datum[]) => T;\nexport type AxisType = 'linear' | 'ordinal' | 'band' | 'point' | 'time' | 'log' | 'symlog';\n\nexport interface IAxisLocationCfg {\n  bandPosition?: number;\n  datum?: Datum;\n}\n\nexport interface ITickCalculationCfg {\n  /** tick步长 */\n  tickStep?: number;\n  /**\n   * 期望的连续轴tick数量\n   * The desired number of ticks draw on linear axis.\n   * @default 5\n   * @description 建议的tick数量，并不保证结果一定是配置值\n   * @since 1.4.0 后支持函数回调。\n   */\n  tickCount?: number | ((option: ITickCallbackOption) => number);\n  /**\n   * 强制设置tick数量\n   * The exact number of ticks draw on linear axis. Might lead to decimal step.\n   * @default 5\n   * @description 强制设置的tick数量，可能由于数据范围导致tick值为小数\n   */\n  forceTickCount?: number;\n  /**\n   * 连续轴 tick 生成算法：\n   * 'average': 尽可能均分；\n   * 'd3'：与 d3 默认逻辑一致，以 [1, 2, 5] 为基数生成；\n   * CustomTicksFunc: 自定义tick生成算法\n   * @default 'average'\n   * @since 1.3.0\n   *\n   * @typedef {function} CustomTicksFunc\n   * @param {IContinuousScale} scale - 连续轴的比例尺对象\n   * @param {number} tickCount - 生成tick的数量\n   * @returns {number[]} - 生成的 tick 数组\n   * @since 1.12.0\n   *\n   * @example\n   * // 自定义 tick 生成函数示例\n   * const customTickFunc: CustomTicksFunc = (scale, tickCount=5) => {\n   *   const domain = scale.domain();\n   *   const step = (domain[domain.length - 1] - domain[0]) / (tickCount - 1);\n   *   return Array.from({ length: tickCount }, (_, i) => domain[0] + i * step);\n   * };\n   */\n  tickMode?: 'average' | 'd3' | CustomTicksFunc<IContinuousScale>;\n  /**\n   * 连续轴，是否避免小数 tick。\n   * @default false\n   * @description 当配置了 tickStep 或 forceTickCount 时不生效。\n   * @since 1.3.0\n   */\n  noDecimals?: boolean;\n}\n\nexport interface IBandAxisLayer extends Omit<ITickCalculationCfg, 'noDecimals' | 'tickMode'> {\n  /**\n   * 是否显示\n   * @default true\n   */\n  visible?: boolean;\n}\n\nexport enum AxisEnum {\n  lineAxis = 'lineAxis',\n  circleAxis = 'circleAxis'\n}\n\nexport enum GridEnum {\n  lineAxisGrid = 'lineAxisGrid',\n  circleAxisGrid = 'circleAxisGrid'\n}\n"]}