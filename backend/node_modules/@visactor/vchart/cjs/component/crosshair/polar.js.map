{"version":3,"sources":["../src/component/crosshair/polar.ts"],"names":[],"mappings":";;;AAGA,4CAAsD;AAGtD,qEAAiH;AAGjH,iCAAuC;AAEvC,6CAAoD;AAEpD,0CAAwF;AACxF,gDAA6C;AAE7C,yCAA+D;AAC/D,qCAA4C;AAE5C,kCAAsC;AAEtC,8EAA2E;AAE3E,MAAa,cAAoE,SAAQ,oBAAgB;IAUvG,MAAM,CAAC,WAAW,CAAC,SAAc;QAC/B,OAAO,IAAA,kBAAW,EAAsB,SAAS,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAsB,EAAE,EAAE;YACrG,OAAO,CAAC,CAAC,CAAC,aAAa,IAAI,CAAC,CAAC,aAAa,CAAC,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,UAAU,IAAI,CAAC,CAAC,UAAU,CAAC,OAAO,KAAK,KAAK,CAAC,CAAC;QACpH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,YAAY,IAAO,EAAE,OAAyB;QAC5C,KAAK,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAVvB,SAAI,GAAG,wBAAiB,CAAC,cAAc,CAAC;QACxC,SAAI,GAAW,wBAAiB,CAAC,cAAc,CAAC;QAW9C,IAAI,CAAC,aAAa,GAAG;YACnB,aAAa,EAAE;gBACb,QAAQ,EAAE,OAAO;gBACjB,cAAc,EAAE,QAAQ;gBACxB,YAAY,EAAE,IAAI,GAAG,EAAE;gBACvB,UAAU,EAAE;oBACV,GAAG,EAAE,IAAI;iBACV;aACF;YACD,UAAU,EAAE;gBACV,QAAQ,EAAE,QAAQ;gBAClB,cAAc,EAAE,OAAO;gBACvB,YAAY,EAAE,IAAI,GAAG,EAAE;gBACvB,UAAU,EAAE;oBACV,GAAG,EAAE,IAAI;iBACV;aACF;SACF,CAAC;IACJ,CAAC;IAKD,YAAY,CAAC,KAAqB,EAAE,IAAW;QAC7C,IAAK,IAAI,CAAC,SAAS,EAAkC,KAAK,QAAQ,EAAE;YAClE,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE;gBAClE,KAAK;gBACL,IAAI;aACL,CAAC,CAAC;SACJ;aAAM;YACL,IAAI,CAAC,aAAa,CAAC,aAAa,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE;gBACrE,KAAK;gBACL,IAAI;aACL,CAAC,CAAC;SACJ;IACH,CAAC;IAMO,oBAAoB,CAAC,SAAiB,EAAE,SAAiB;QAC/D,MAAM,YAAY,GAAG,IAAI,CAAC,mBAAmB,CAAa,UAAU,CAAC,CAAC;QACtE,MAAM,aAAa,GAAG,IAAI,CAAC,mBAAmB,CAAa,OAAO,CAAC,CAAC;QACpE,OAAO;YACL,YAAY,EAAE,IAAI,CAAC,kBAAkB,CAAa,YAAY,EAAE,SAAS,EAAE,SAAS,CAAC;YACrF,aAAa,EAAE,IAAI,CAAC,kBAAkB,CAAa,aAAa,EAAE,SAAS,EAAE,SAAS,CAAC;SACxF,CAAC;IACJ,CAAC;IAES,gBAAgB,CAAC,IAAgB,EAAE,KAAa;QACxD,MAAM,EAAE,CAAC,EAAE,UAAU,EAAE,CAAC,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;QACpE,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC5C,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC;YAChC,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC;YAC7B,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC;SAC9B,CAAC,CAAC;QAEH,OAAO,KAAK,CAAC;IACf,CAAC;IAES,gBAAgB,CACxB,SAAiB,EACjB,SAAiB,EACjB,WAAyB,EACzB,UAA8B;QAE9B,IAAI,CAAC,GAAG,SAAS,CAAC;QAClB,IAAI,CAAC,GAAG,SAAS,CAAC;QAElB,IAAI,WAAW,IAAI,WAAW,CAAC,MAAM,EAAE;YACrC,IAAI,UAAU,KAAK,WAAW,EAAE;gBAC9B,MAAM,aAAa,GAAI,WAAgC,CAAC,CAAC,CAAC,CAAC;gBAE3D,IAAI,aAAa,CAAC,IAAI,EAAE;oBACtB,MAAM,YAAY,GAAI,aAAa,CAAC,IAAmB,CAAC,YAAY,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;oBAC/E,MAAM,QAAQ,GAAG,aAAa,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,QAAQ,CAAC;oBAC7D,MAAM,KAAK,GAAG,QAAQ;wBACpB,CAAC,CAAC;4BACE,MAAM,EAAE,aAAa,CAAC,QAAQ;4BAC9B,KAAK,EAAE,YAAY,CAAC,KAAK;yBAC1B;wBACH,CAAC,CAAC;4BACE,MAAM,EAAE,YAAY,CAAC,MAAM;4BAC3B,KAAK,EAAE,aAAa,CAAC,QAAQ;yBAC9B,CAAC;oBACN,MAAM,UAAU,GAAI,aAAa,CAAC,IAAmB,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;oBAC1E,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC;oBACjB,CAAC,GAAG,UAAU,CAAC,CAAC,CAAC;iBAClB;aACF;iBAAM,IAAI,UAAU,KAAK,MAAM,EAAE;gBAChC,MAAM,aAAa,GAAI,WAAgC,CAAC,CAAC,CAAC,CAAC;gBAC3D,MAAM,GAAG,GAAG,aAAa,CAAC,MAAM,CAAC,cAAc,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBAExE,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;gBACV,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;aACX;SACF;QAED,IAAI,CAAC,cAAc,EAAE,CAAC;QAGtB,MAAM,EAAE,YAAY,EAAE,aAAa,EAAE,GAAG,IAAI,CAAC,oBAAoB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACxE,IAAI,YAAY,CAAC,IAAI,KAAK,CAAC,IAAI,aAAa,CAAC,IAAI,KAAK,CAAC,EAAE;YACvD,IAAI,IAAI,CAAC,YAAY,EAAE;gBACrB,OAAO;aACR;YAED,IAAI,CAAC,IAAI,EAAE,CAAC;YACZ,OAAO;SACR;QAGD,YAAY,IAAI,IAAI,CAAC,iBAAiB,CAAC,YAAY,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,eAAe,CAAC,CAAC;QAChF,aAAa,IAAI,IAAI,CAAC,iBAAiB,CAAC,aAAa,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,YAAY,CAAC,CAAC;QAE/E,IAAI,CAAC,aAAa,EAAE,CAAC;IACvB,CAAC;IAED,aAAa,CAAC,YAAsB;QAClC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YAChB,OAAO;SACR;QACD,MAAM,MAAM,GAAG,IAAA,qBAAc,EAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAiB,CAAC;QACtE,IAAI,CAAC,MAAM,EAAE;YACX,OAAO;SACR;QAED,IAAA,qBAAa,EAAC,IAAI,CAAC,aAAa,EAAE,MAAM,EAAE,YAAY,aAAZ,YAAY,cAAZ,YAAY,GAAI,IAAI,CAAC,YAAY,CAAC,CAAC;QAE7E,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YAC9C,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;QAC7B,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,cAAc,CAAC,SAAiB;;QACtC,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,aAAa,EAAE,UAAU,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;QACrG,IAAI,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,QAAQ,IAAI,IAAI,CAAC,YAAY,CAAC,EAAE;YAC3D,OAAO;SACR;QAED,MAAM,SAAS,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;QACtC,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,IAAI,EAAE,GAAG,SAAS,CAAC;QAC9D,IAAI,OAAO,EAAE;YACX,MAAM,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;YACpD,MAAM,MAAM,GAAG,MAAA,MAAA,IAAI,CAAC,KAAK,CAAC,UAAU,0CAAE,IAAI,0CAAE,MAAM,CAAC;YACnD,MAAM,aAAa,GAAG,IAAA,uBAAe,EAAC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE,gBAAgB,EAAE,MAAM,CAAC,CAAC;YAE/F,IAAI,aAAa,EAAE;gBACjB,aAAa,CAAC,aAAa,CAAC,aAA+B,CAAC,CAAC;aAC9D;iBAAM;gBACL,IAAI,SAAS,CAAC;gBAEd,IAAI,QAAQ,KAAK,OAAO,EAAE;oBACxB,MAAM,aAAa,GAAG,UAAU,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC;oBAErE,IAAI,aAAa,KAAK,MAAM,EAAE;wBAC5B,SAAS,GAAG,IAAI,kCAAa,iCACvB,aAAgD,KACpD,SAAS,EAAE,UAAU,CAAC,KAAK,EAC3B,MAAM,EAAE,IAAI,CAAC,UAAU,EACvB,QAAQ,EAAE,KAAK,IACf,CAAC;qBACJ;yBAAM,IAAI,aAAa,KAAK,QAAQ,EAAE;wBACrC,SAAS,GAAG,IAAI,oCAAe,iCACzB,aAMF,KACF,WAAW,EAAE,UAAU,CAAC,KAAK,EAC7B,MAAM,EAAE,IAAI,CAAC,UAAU,EACvB,QAAQ,EAAE,KAAK,IACf,CAAC;qBACJ;iBACF;qBAAM;oBACL,MAAM,aAAa,GAAG,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC;oBAEpD,IAAI,aAAa,KAAK,SAAS,EAAE;wBAC/B,SAAS,GAAG,IAAI,qCAAgB,iCAC1B,aAAuC,KAC3C,SAAS,EAAE,UAAU,CAAC,KAAK,EAC3B,MAAM,EAAE,IAAI,CAAC,UAAU,GAAG,CAAC,IAC3B,CAAC;qBACJ;yBAAM;wBACL,SAAS,GAAG,IAAI,oCAAe,iCACzB,aAAsC,KAC1C,SAAS,EAAE,UAAU,CAAC,KAAK,EAC3B,MAAM,EAAE,IAAI,CAAC,UAAU,IACvB,CAAC;qBACJ;iBACF;gBACD,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC,aAAa,GAAG,SAA8B,CAAC;gBAE7E,SAAS,CAAC,GAAG,CAAC,SAA6B,CAAC,CAAC;aAC9C;YAED,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC;YAEzB,IAAI,KAAK,CAAC,OAAO,EAAE;gBACjB,MAAM,UAAU,GAAI,IAAmB,CAAC,SAAS,EAAE,CAAC;gBACpD,MAAM,MAAM,GAAG;oBACb,CAAC,EAAE,UAAU,CAAC,CAAC,GAAG,gBAAgB,CAAC,CAAC;oBACpC,CAAC,EAAE,UAAU,CAAC,CAAC,GAAG,gBAAgB,CAAC,CAAC;iBACrC,CAAC;gBACF,MAAM,MAAM,GACV,QAAQ,KAAK,OAAO;oBAClB,CAAC,CAAC,IAAA,gCAAyB,EAAC,KAAK,CAAC;oBAClC,CAAC,CAAC,IAAA,iCAA0B,EAAE,IAAmB,CAAC,UAAU,CAAC,CAAC;gBAClE,MAAM,KAAK,GACT,QAAQ,KAAK,OAAO;oBAClB,CAAC,CAAC,IAAA,yBAAgB,EAAC,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC;oBAC9D,CAAC,CAAC,IAAA,yBAAgB,EAAC,MAAM,EAAE,aAAa,CAAC,MAAM,EAAG,IAAmB,CAAC,UAAU,CAAC,CAAC;gBAEtF,MAAM,UAAU,+DACX,KAAK,GACL,UAAU,CAAC,KAAK,GAChB,KAAK,KACR,SAAS,kCACJ,MAAA,UAAU,CAAC,KAAK,0CAAE,SAAS,KAC9B,SAAS,EAAE,MAAM,CAAC,KAAK,EACvB,YAAY,EAAE,MAAM,CAAC,QAAQ,KAE/B,MAAM,EAAE,IAAI,CAAC,WAAW,GACzB,CAAC;gBACF,IAAI,CAAC,qBAAqB,CAAC,UAAU,CAAC,GAAG,EAAE,UAAU,EAAE,KAAK,CAAC,EAAE;oBAC7D,KAAK,CAAC,IAAI,GAAG,aAAa,QAAQ,QAAQ,CAAC;oBAC3C,UAAU,CAAC,GAAG,GAAG,KAAK,CAAC;gBACzB,CAAC,CAAC,CAAC;aACJ;iBAAM;gBACL,UAAU,CAAC,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC;aAC5C;SACF;IACH,CAAC;;AA9PH,wCA+PC;AA9PQ,sBAAO,GAAG,WAAW,CAAC;AAEb,2BAAY,GAAG;IAC7B,SAAS,EAAT,qBAAS;CACV,CAAC;AACK,mBAAI,GAAG,wBAAiB,CAAC,cAAc,CAAC;AA2P1C,MAAM,sBAAsB,GAAG,GAAG,EAAE;IACzC,iBAAO,CAAC,iBAAiB,CAAC,cAAc,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;AACjE,CAAC,CAAC;AAFW,QAAA,sBAAsB,0BAEjC","file":"polar.js","sourcesContent":["/* eslint-disable no-duplicate-imports */\nimport type { IPolarSeries } from '../../series/interface/series';\nimport type { IComponentOption } from '../interface';\nimport { ComponentTypeEnum } from '../interface/type';\nimport type { IPolarCrosshairSpec } from './interface';\nimport type { PolygonCrosshairAttrs, CircleCrosshairAttrs } from '@visactor/vrender-components';\nimport { LineCrosshair, SectorCrosshair, CircleCrosshair, PolygonCrosshair } from '@visactor/vrender-components';\nimport type { IPolarAxis } from '../axis/polar/interface';\nimport type { IPoint, IPolarOrientType, StringOrNumber, TooltipActiveType, TooltipData } from '../../typings';\nimport { BaseCrossHair } from './base';\nimport type { Maybe } from '@visactor/vutils';\nimport { polarToCartesian } from '@visactor/vutils';\nimport type { IGroup, INode } from '@visactor/vrender-core';\nimport { angleLabelOrientAttribute, radiusLabelOrientAttribute } from '../../util/math';\nimport { Factory } from '../../core/factory';\nimport type { IModelSpecInfo } from '../../model/interface';\nimport { layoutByValue, layoutCrosshair } from './utils/polar';\nimport { getFirstSeries } from '../../util';\nimport type { IDimensionData, IDimensionInfo } from '../../event/events/dimension/interface';\nimport { getSpecInfo } from '../util';\nimport type { IAxis } from '../axis';\nimport { crosshair } from '../../theme/builtin/common/component/crosshair';\n\nexport class PolarCrossHair<T extends IPolarCrosshairSpec = IPolarCrosshairSpec> extends BaseCrossHair<T> {\n  static specKey = 'crosshair';\n\n  static readonly builtInTheme = {\n    crosshair\n  };\n  static type = ComponentTypeEnum.polarCrosshair;\n  type = ComponentTypeEnum.polarCrosshair;\n  name: string = ComponentTypeEnum.polarCrosshair;\n\n  static getSpecInfo(chartSpec: any): Maybe<IModelSpecInfo[]> {\n    return getSpecInfo<IPolarCrosshairSpec>(chartSpec, this.specKey, this.type, (s: IPolarCrosshairSpec) => {\n      return (s.categoryField && s.categoryField.visible !== false) || (s.valueField && s.valueField.visible !== false);\n    });\n  }\n\n  constructor(spec: T, options: IComponentOption) {\n    super(spec, options);\n\n    this._stateByField = {\n      categoryField: {\n        coordKey: 'angle',\n        anotherAxisKey: 'radius',\n        currentValue: new Map(),\n        labelsComp: {\n          all: null\n        }\n      },\n      valueField: {\n        coordKey: 'radius',\n        anotherAxisKey: 'angle',\n        currentValue: new Map(),\n        labelsComp: {\n          all: null\n        }\n      }\n    };\n  }\n\n  /**\n   * set axis value of crosshair\n   */\n  setAxisValue(datum: StringOrNumber, axis: IAxis) {\n    if ((axis.getOrient() as unknown as IPolarOrientType) === 'radius') {\n      this._stateByField.valueField.currentValue.set(axis.getSpecIndex(), {\n        datum,\n        axis\n      });\n    } else {\n      this._stateByField.categoryField.currentValue.set(axis.getSpecIndex(), {\n        datum,\n        axis\n      });\n    }\n  }\n  /**\n   * 查找所有落在x和y区域的轴\n   * @param relativeX\n   * @param relativeY\n   */\n  private _findAllAxisContains(relativeX: number, relativeY: number) {\n    const angleAxisMap = this._getAxisInfoByField<IPolarAxis>('category');\n    const radiusAxisMap = this._getAxisInfoByField<IPolarAxis>('value');\n    return {\n      angleAxisMap: this._filterAxisByPoint<IPolarAxis>(angleAxisMap, relativeX, relativeY),\n      radiusAxisMap: this._filterAxisByPoint<IPolarAxis>(radiusAxisMap, relativeX, relativeY)\n    };\n  }\n\n  protected _getDatumAtPoint(axis: IPolarAxis, point: IPoint) {\n    const { x: axisStartX, y: axisStartY } = axis.getLayoutStartPoint();\n    const { x, y } = this.getLayoutStartPoint();\n    const datum = axis.positionToData({\n      x: point.x - (axisStartX - x),\n      y: point.y - (axisStartY - y)\n    });\n\n    return datum;\n  }\n\n  protected _layoutCrosshair(\n    relativeX: number,\n    relativeY: number,\n    tooltipData?: TooltipData,\n    activeType?: TooltipActiveType\n  ) {\n    let x = relativeX;\n    let y = relativeY;\n\n    if (tooltipData && tooltipData.length) {\n      if (activeType === 'dimension') {\n        const dimensionInfo = (tooltipData as IDimensionInfo[])[0];\n\n        if (dimensionInfo.axis) {\n          const triggerCoord = (dimensionInfo.axis as IPolarAxis).pointToCoord({ x, y });\n          const isRadius = dimensionInfo.axis.getOrient() === 'radius';\n          const coord = isRadius\n            ? {\n                radius: dimensionInfo.position,\n                angle: triggerCoord.angle\n              }\n            : {\n                radius: triggerCoord.radius,\n                angle: dimensionInfo.position\n              };\n          const uniformPos = (dimensionInfo.axis as IPolarAxis).coordToPoint(coord);\n          x = uniformPos.x;\n          y = uniformPos.y;\n        }\n      } else if (activeType === 'mark') {\n        const dimensionData = (tooltipData as IDimensionData[])[0];\n        const pos = dimensionData.series.dataToPosition(dimensionData.datum[0]);\n\n        x = pos.x;\n        y = pos.y;\n      }\n    }\n    // 删除之前的currValue\n    this.clearAxisValue();\n\n    // 找到所有的包含这个点的轴\n    const { angleAxisMap, radiusAxisMap } = this._findAllAxisContains(x, y);\n    if (angleAxisMap.size === 0 && radiusAxisMap.size === 0) {\n      if (this.enableRemain) {\n        return;\n      }\n      // 隐藏\n      this.hide();\n      return;\n    }\n\n    // 将数据保存到这个对象中，如果不存在，就直接不执行后续逻辑\n    angleAxisMap && this._setAllAxisValues(angleAxisMap, { x, y }, 'categoryField');\n    radiusAxisMap && this._setAllAxisValues(radiusAxisMap, { x, y }, 'valueField');\n\n    this.layoutByValue();\n  }\n\n  layoutByValue(enableRemain?: boolean) {\n    if (!this.enable) {\n      return;\n    }\n    const series = getFirstSeries(this._regions, 'polar') as IPolarSeries;\n    if (!series) {\n      return;\n    }\n\n    layoutByValue(this._stateByField, series, enableRemain ?? this.enableRemain);\n\n    Object.keys(this._stateByField).forEach(field => {\n      this._layoutByField(field);\n    });\n  }\n\n  private _layoutByField(fieldName: string) {\n    const { cacheInfo, attributes, crosshairComp, labelsComp, coordKey } = this._stateByField[fieldName];\n    if (!cacheInfo || (cacheInfo._isCache && this.enableRemain)) {\n      return;\n    }\n\n    const container = this.getContainer();\n    const { visible, labels, coord, sizeRange, axis } = cacheInfo;\n    if (visible) {\n      const layoutStartPoint = this.getLayoutStartPoint();\n      const smooth = this._spec.valueField?.line?.smooth;\n      const positionAttrs = layoutCrosshair(this._stateByField[fieldName], layoutStartPoint, smooth);\n\n      if (crosshairComp) {\n        crosshairComp.setAttributes(positionAttrs as unknown as any);\n      } else {\n        let crosshair;\n\n        if (coordKey === 'angle') {\n          const crosshairType = attributes.type === 'rect' ? 'sector' : 'line';\n          // 创建\n          if (crosshairType === 'line') {\n            crosshair = new LineCrosshair({\n              ...(positionAttrs as { start: IPoint; end: IPoint }),\n              lineStyle: attributes.style,\n              zIndex: this.gridZIndex,\n              pickable: false\n            });\n          } else if (crosshairType === 'sector') {\n            crosshair = new SectorCrosshair({\n              ...(positionAttrs as {\n                center: IPoint;\n                innerRadius: number;\n                radius: number;\n                startAngle: number;\n                endAngle: number;\n              }),\n              sectorStyle: attributes.style,\n              zIndex: this.gridZIndex,\n              pickable: false\n            });\n          }\n        } else {\n          const crosshairType = smooth ? 'circle' : 'polygon';\n\n          if (crosshairType === 'polygon') {\n            crosshair = new PolygonCrosshair({\n              ...(positionAttrs as PolygonCrosshairAttrs),\n              lineStyle: attributes.style,\n              zIndex: this.gridZIndex + 1 // 样式优化：线盖在面上\n            });\n          } else {\n            crosshair = new CircleCrosshair({\n              ...(positionAttrs as CircleCrosshairAttrs),\n              lineStyle: attributes.style,\n              zIndex: this.gridZIndex\n            });\n          }\n        }\n        this._stateByField[fieldName].crosshairComp = crosshair as unknown as IGroup;\n        // 添加至场景树\n        container.add(crosshair as unknown as INode);\n      }\n\n      const label = labels.all;\n      // 文本\n      if (label.visible) {\n        const axisCenter = (axis as IPolarAxis).getCenter();\n        const center = {\n          x: axisCenter.x + layoutStartPoint.x,\n          y: axisCenter.y + layoutStartPoint.y\n        };\n        const orient =\n          coordKey === 'angle'\n            ? angleLabelOrientAttribute(coord)\n            : radiusLabelOrientAttribute((axis as IPolarAxis).startAngle);\n        const point =\n          coordKey === 'angle'\n            ? polarToCartesian(center, sizeRange[1] + label.offset, coord)\n            : polarToCartesian(center, positionAttrs.radius, (axis as IPolarAxis).startAngle);\n\n        const labelAttrs = {\n          ...point,\n          ...attributes.label,\n          ...label,\n          textStyle: {\n            ...attributes.label?.textStyle,\n            textAlign: orient.align,\n            textBaseline: orient.baseline\n          },\n          zIndex: this.labelZIndex\n        };\n        this._updateCrosshairLabel(labelsComp.all, labelAttrs, label => {\n          label.name = `crosshair-${coordKey}-label`;\n          labelsComp.all = label;\n        });\n      } else {\n        labelsComp.all && labelsComp.all.hideAll();\n      }\n    }\n  }\n}\n\nexport const registerPolarCrossHair = () => {\n  Factory.registerComponent(PolarCrossHair.type, PolarCrossHair);\n};\n"]}