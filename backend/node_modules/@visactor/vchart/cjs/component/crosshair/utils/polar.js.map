{"version":3,"sources":["../src/component/crosshair/utils/polar.ts"],"names":[],"mappings":"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","file":"polar.js","sourcesContent":["import type { BandScale } from '@visactor/vscale';\nimport type { IPolarSeries } from '../../../series';\nimport type { CrossHairStateByField, CrossHairStateItem, ICrosshairInfo } from '../interface';\nimport { getAxisLabelOffset } from '../../axis/util';\nimport { PointService, clamp, getAngleByPoint, getIntersectPoint, isValid, polarToCartesian } from '@visactor/vutils';\nimport type { ILinearAxis, IPolarAxis } from '../../axis';\nimport { getFormatFunction } from '../../util';\nimport type { ILayoutPoint } from '../../../typings/layout';\n\nexport const layoutByValue = (\n  stateByField: CrossHairStateByField,\n  series: IPolarSeries,\n  enableRemain: boolean = false\n) => {\n  Object.keys(stateByField).forEach(field => {\n    const { attributes, currentValue, cacheInfo, coordKey } = stateByField[field];\n\n    if (attributes) {\n      const isVisible = !!currentValue.size;\n      const useCache = enableRemain && !isVisible && isValid(cacheInfo);\n      const newInfo = useCache\n        ? cacheInfo\n        : ({\n            coord: 0,\n            axis: null,\n            visible: isVisible,\n            coordRange: [0, 0],\n            sizeRange: [0, 0],\n            labels: {\n              all: { visible: false, text: '', offset: 0 }\n            }\n          } as ICrosshairInfo);\n      if (cacheInfo) {\n        cacheInfo._isCache = useCache;\n      }\n\n      if (field === 'valueField') {\n        (newInfo as any).sides = (series.angleAxisHelper.getScale(0) as BandScale).domain().length;\n      }\n\n      currentValue.forEach(({ axis, datum: value = '' }) => {\n        const niceLabelFormatter = (axis as ILinearAxis).niceLabelFormatter;\n\n        if (attributes.label?.visible) {\n          newInfo.labels.all.visible = true;\n          newInfo.labels.all.defaultFormatter = niceLabelFormatter;\n          newInfo.labels.all.text = value;\n          newInfo.labels.all.offset = getAxisLabelOffset(axis.getSpec());\n        }\n\n        if (field === 'categoryField') {\n          const angle = series.angleAxisHelper.dataToPosition([value]);\n          const bandSize = series.angleAxisHelper.getBandwidth(0);\n          const radius = (axis as IPolarAxis).getOuterRadius();\n\n          newInfo.coord = angle;\n          newInfo.coordRange = [angle - bandSize / 2, angle + bandSize / 2];\n          newInfo.sizeRange = [radius, radius];\n        } else {\n          const angle = (axis as IPolarAxis).startAngle;\n          const radius = series.radiusAxisHelper.dataToPosition([value]);\n\n          newInfo.coord = radius;\n          newInfo.coordRange = [radius, radius];\n          newInfo.sizeRange = [angle, angle];\n        }\n\n        newInfo.axis = axis as IPolarAxis;\n      });\n\n      if (newInfo && !useCache) {\n        if (newInfo.labels.all.visible) {\n          if (attributes && attributes.label) {\n            const label = newInfo.labels.all;\n            const { formatMethod, formatter } = attributes.label;\n            const { formatFunc, args } = getFormatFunction(formatMethod, formatter, label.text, {\n              label: label.text,\n              orient: coordKey\n            });\n            if (formatFunc) {\n              label.text = formatFunc(...args);\n            } else if (label.defaultFormatter) {\n              label.text = label.defaultFormatter(label.text);\n            }\n          }\n        }\n      }\n\n      stateByField[field].cacheInfo = newInfo;\n    }\n  });\n};\n\nexport const layoutCrosshair = (stateItem: CrossHairStateItem, layoutStartPoint: ILayoutPoint, smooth?: boolean) => {\n  const { cacheInfo, coordKey, attributes } = stateItem;\n  const { axis, coord, sizeRange, coordRange } = cacheInfo;\n  const axisCenter = (axis as IPolarAxis).getCenter();\n  const center = {\n    x: axisCenter.x + layoutStartPoint.x,\n    y: axisCenter.y + layoutStartPoint.y\n  };\n\n  if (coordKey === 'angle') {\n    const crosshairType = attributes.type === 'rect' ? 'sector' : 'line';\n\n    if (crosshairType === 'sector') {\n      // angle 轴对应的crosshair\n      return {\n        center,\n        innerRadius: (axis as IPolarAxis).getInnerRadius(),\n        radius: (axis as IPolarAxis).getOuterRadius(),\n        startAngle: coordRange[0],\n        endAngle: coordRange[1]\n      };\n    }\n    // angle 轴对应的crosshair\n    return {\n      start: polarToCartesian(center, (axis as IPolarAxis).getInnerRadius(), coord),\n      end: polarToCartesian(center, (axis as IPolarAxis).getOuterRadius(), coord)\n    };\n  }\n\n  const startAngle = (axis as IPolarAxis).startAngle;\n  const endAngle = (axis as IPolarAxis).endAngle;\n  const sides = cacheInfo.sides;\n\n  let polygonRadius = coord;\n  if (!smooth) {\n    const axisCenter = (axis as IPolarAxis).getCenter();\n    // 需要计算半径\n    // 获取当前点的角度\n    const point = (axis as IPolarAxis).coordToPoint({\n      angle: sizeRange[0],\n      radius: coord\n    });\n    const curAngle = getAngleByPoint(axisCenter, point);\n    const stepAngle = (endAngle - startAngle) / sides;\n    const index = Math.floor((curAngle - startAngle) / stepAngle);\n    const preAngle = index * stepAngle + startAngle;\n    const nextAngle = Math.min((index + 1) * stepAngle + startAngle, endAngle);\n\n    const prePoint = polarToCartesian(axisCenter, coord, preAngle);\n    const nextPoint = polarToCartesian(axisCenter, coord, nextAngle);\n    // 求交点\n    const insertPoint = getIntersectPoint(\n      [nextPoint.x, nextPoint.y],\n      [prePoint.x, prePoint.y],\n      [axisCenter.x, axisCenter.y],\n      [point.x, point.y]\n    );\n    if (insertPoint) {\n      polygonRadius = clamp(\n        PointService.distancePN(point, (insertPoint as [number, number])[0], (insertPoint as [number, number])[1]) +\n          coord,\n        (axis as IPolarAxis).getInnerRadius(),\n        (axis as IPolarAxis).getOuterRadius()\n      );\n    }\n  }\n  return {\n    center,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    radius: polygonRadius,\n    sides\n  };\n};\n"]}