"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.minInArr = exports.maxInArr = exports.peek = exports.array = exports.moveAfterInArray = exports.combineDomains = exports.shallowCompare = void 0;

const vutils_1 = require("@visactor/vutils");

function shallowCompare(arrA, arrB) {
    const setA = new Set((0, vutils_1.array)(arrA)), setB = new Set((0, vutils_1.array)(arrB));
    if (setA.size !== setB.size) return !1;
    for (const v of setA.values()) if (!setB.has(v)) return !1;
    return !0;
}

function combineDomains(domains) {
    const result = [];
    for (let index = 0; index < domains.length; index++) {
        const domain = domains[index];
        0 !== index && domain[0] === result[result.length - 1] || result.push(domain[0]), 
        result.push(domain[1]);
    }
    return result;
}

function moveAfterInArray(array, target, ref) {
    const index = array.indexOf(target), refIndex = array.indexOf(ref);
    index >= 0 && refIndex >= 0 && index < refIndex && (array.splice(index, 1), array.splice(refIndex, 0, target));
}

Object.defineProperty(exports, "array", {
    enumerable: !0,
    get: function() {
        return vutils_1.array;
    }
}), Object.defineProperty(exports, "peek", {
    enumerable: !0,
    get: function() {
        return vutils_1.last;
    }
}), Object.defineProperty(exports, "maxInArr", {
    enumerable: !0,
    get: function() {
        return vutils_1.maxInArray;
    }
}), Object.defineProperty(exports, "minInArr", {
    enumerable: !0,
    get: function() {
        return vutils_1.minInArray;
    }
}), exports.shallowCompare = shallowCompare, exports.combineDomains = combineDomains, 
exports.moveAfterInArray = moveAfterInArray;
//# sourceMappingURL=array.js.map
