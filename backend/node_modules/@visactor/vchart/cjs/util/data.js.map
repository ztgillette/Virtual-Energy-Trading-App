{"version":3,"sources":["../src/util/data.ts"],"names":[],"mappings":"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","file":"data.js","sourcesContent":["import type { DataView } from '@visactor/vdataset';\nimport type { StatisticOperations } from '../data/transforms/interface';\nimport {\n  STACK_FIELD_END,\n  STACK_FIELD_START_PERCENT,\n  STACK_FIELD_END_PERCENT,\n  STACK_FIELD_END_OffsetSilhouette,\n  STACK_FIELD_START_OffsetSilhouette,\n  STACK_FIELD_TOTAL,\n  STACK_FIELD_TOTAL_PERCENT,\n  STACK_FIELD_TOTAL_TOP,\n  STACK_FIELD_START,\n  STACK_FIELD_KEY,\n  STACK_FIELD_TOTAL_BOTTOM,\n  MOSAIC_CAT_START_PERCENT,\n  MOSAIC_CAT_END_PERCENT,\n  MOSAIC_VALUE_START_PERCENT,\n  MOSAIC_VALUE_END_PERCENT\n} from '../constant/data';\nimport { isValid, toValidNumber } from './type';\nimport { max, sum } from './math';\nimport type { ISeries, ISeriesStackDataMeta } from '../series/interface';\nimport type { IRegion } from '../region/interface';\nimport { MosaicSeries } from '../series';\n\nexport function mergeFields(\n  targetFields: {\n    key: string;\n    operations: StatisticOperations;\n  }[],\n  mergeFields: {\n    key: string;\n    operations: StatisticOperations;\n  }[]\n): {\n  key: string;\n  operations: StatisticOperations;\n}[] {\n  for (let i = 0; i < mergeFields.length; i++) {\n    const element = mergeFields[i];\n    const _target = findFields(targetFields, element.key);\n    if (!_target) {\n      targetFields.push(element);\n    } else {\n      _target.operations = [...new Set(_target.operations.concat(element.operations))];\n    }\n  }\n  return targetFields;\n}\n\nfunction findFields(\n  list: {\n    key: string;\n    operations: StatisticOperations;\n  }[],\n  fieldKey: string\n) {\n  return list.find(i => i.key === fieldKey);\n}\n\n// 如果不存在别名就返回 field\nexport function getFieldAlias(dataView: DataView, field: string) {\n  if (!dataView) {\n    return field ?? null;\n  }\n  const fields = dataView.getFields();\n  if (!fields) {\n    return field ?? null;\n  }\n  if (!fields[field]) {\n    return field ?? null;\n  }\n  return fields[field].alias ?? field;\n}\n\nexport interface IStackCacheNode {\n  groupField?: string;\n  values: any[];\n  series: {\n    s: ISeries;\n    values: any[];\n  }[];\n  sortDatums: {\n    datum: any;\n    index: number;\n    series: ISeries;\n  }[];\n  nodes: {\n    [key: string]: IStackCacheNode;\n  };\n  key: string;\n  total?: number;\n}\nexport interface IStackCacheRoot {\n  groupField?: string;\n  total?: number;\n  nodes: {\n    [key: string]: IStackCacheNode;\n  };\n}\n\nexport interface IStackSortCache {\n  [key: string]: {\n    lastIndex: number;\n    sort: { [key: string]: number };\n  };\n}\n\nexport function getRegionStackGroup(region: IRegion, setInitialValue: boolean, filter?: (s: any) => boolean) {\n  const stackSort = region.getStackSort();\n\n  const stackValueGroup: { [key: string]: IStackCacheRoot } = {};\n  // 堆积排序 {维度key: { lastIndex: 0, sort:{[值]: 值序号}}}\n  let stackSortCache: IStackSortCache = null;\n  // 如果有排序\n  if (stackSort) {\n    // 先遍历系列，得到基于 seriesField 的排序信息\n    // 这里性能消耗应该很小\n    stackSortCache = {};\n    region.getSeries().forEach(s => {\n      // 拿到系列的 seriesField 做排序准备\n      const seriesField = s.getSeriesField();\n      if (seriesField) {\n        const fieldInfo = s.getRawDataStatisticsByField(seriesField);\n        if (fieldInfo.values) {\n          if (!stackSortCache[seriesField]) {\n            stackSortCache[seriesField] = { lastIndex: 0, sort: {} };\n          }\n          fieldInfo.values.forEach((v, i) => {\n            if (!(v in stackSortCache[seriesField].sort)) {\n              stackSortCache[seriesField].sort[v] = stackSortCache[seriesField].lastIndex;\n              stackSortCache[seriesField].lastIndex++;\n            }\n          });\n        }\n      }\n    });\n  }\n\n  region.getSeries().forEach(s => {\n    const stackData = s.getStackData();\n    const stackValue = s.getStackValue();\n    const stackValueField = s.getStackValueField();\n    const filterEnable = filter ? filter(s) : true;\n    if (stackData && stackValueField && filterEnable) {\n      stackValueGroup[stackValue] = stackValueGroup[stackValue] ?? {\n        groupField: stackData.groupField,\n        nodes: {}\n      };\n\n      stackGroup(\n        s,\n        stackData,\n        stackValueGroup[stackValue] as IStackCacheNode,\n        stackValueField,\n        setInitialValue,\n        stackSortCache\n      );\n    }\n  });\n  return stackSort\n    ? sortStackValueGroup(stackValueGroup as { [key: string]: IStackCacheNode }, stackSortCache)\n    : stackValueGroup;\n}\n\n// 排序\nexport function sortStackValueGroup(\n  stackValueGroup: { [key: string]: IStackCacheNode },\n  stackSortCache: IStackSortCache\n) {\n  for (const key in stackValueGroup) {\n    if (stackValueGroup[key].sortDatums?.length) {\n      stackValueGroup[key].sortDatums.sort((a, b) => a.index - b.index);\n      stackValueGroup[key].values = stackValueGroup[key].sortDatums.map(sd => sd.datum);\n    } else {\n      sortStackValueGroup(stackValueGroup[key].nodes, stackSortCache);\n    }\n  }\n  return stackValueGroup;\n}\n\nexport function stackTotal(stackData: IStackCacheNode, valueField: string) {\n  if ('values' in stackData && stackData.values.length) {\n    const total = sum(stackData.values, valueField);\n    const percent = max(stackData.values, STACK_FIELD_END_PERCENT);\n\n    stackData.values.forEach(v => {\n      v[STACK_FIELD_TOTAL] = total;\n      v[STACK_FIELD_TOTAL_PERCENT] = percent;\n    });\n\n    return;\n  }\n  for (const key in stackData.nodes) {\n    stackTotal(stackData.nodes[key], valueField);\n  }\n  return;\n}\n\nexport interface IMosaicData {\n  groupField?: string;\n  groupValue?: string;\n  value?: number;\n  end?: number;\n  start?: number;\n  startPercent?: number;\n  endPercent?: number;\n}\n\nexport function stackMosaicTotal(stackData: IStackCacheNode, valueField: string) {\n  if ('values' in stackData && stackData.values.length) {\n    if (isValid(stackData.values[0]?.[STACK_FIELD_TOTAL])) {\n      stackData.total = stackData.values[0]?.[STACK_FIELD_TOTAL];\n    } else {\n      stackData.total = sum(stackData.values, valueField);\n    }\n    return;\n  }\n  for (const key in stackData.nodes) {\n    stackMosaicTotal(stackData.nodes[key], valueField);\n  }\n\n  if (stackData.nodes) {\n    stackData.total = sum(\n      Object.keys(stackData.nodes).map(key => stackData.nodes[key]),\n      'total'\n    );\n  }\n\n  return;\n}\n\nexport function stackMosaic(s: ISeries, stackCache: IStackCacheNode, mosaicData?: IMosaicData[]) {\n  if (stackCache.groupField && stackCache.nodes) {\n    const groupValues = s.getRawDataStatisticsByField(stackCache.groupField, false)?.values || [];\n    const mosaicStackData = {\n      key: `${stackCache.groupField}`,\n      values: groupValues.map(group => {\n        const groupValues = stackCache.nodes[group];\n        let value;\n        if ((s as MosaicSeries).bandWidthField) {\n          value =\n            groupValues.values.find(v => isValid(v[(s as MosaicSeries).bandWidthField]))?.[\n              (s as MosaicSeries).bandWidthField\n            ] ?? groupValues.total;\n        } else {\n          value = groupValues.total;\n        }\n\n        return {\n          groupValue: group,\n          value,\n          end: value\n        };\n      })\n    };\n\n    stack(mosaicStackData as IStackCacheNode, false, true, false, {\n      key: 'groupField',\n      start: 'start',\n      end: 'end',\n      startPercent: 'startPercent',\n      endPercent: 'endPercent'\n    });\n\n    mosaicStackData.values.forEach(stackValue => {\n      (stackCache.nodes[stackValue.groupValue] as any).mosaicData = stackValue;\n    });\n  } else if ('values' in stackCache && stackCache.values.length && mosaicData && mosaicData.length) {\n    const len = mosaicData.length;\n    let catStartPercent = 0;\n    let catEndPercent = 1;\n    let valueStartPercent = 0;\n    let valueEndPercent = 1;\n\n    for (let i = 0; i < len; i++) {\n      if (i % 2 === 0) {\n        const catDelta = catEndPercent - catStartPercent;\n\n        catEndPercent = catStartPercent + mosaicData[i].endPercent * catDelta;\n        catStartPercent = catStartPercent + mosaicData[i].startPercent * catDelta;\n      } else {\n        const valueDelta = valueEndPercent - valueStartPercent;\n\n        valueEndPercent = valueStartPercent + mosaicData[i].endPercent * valueDelta;\n        valueStartPercent = valueStartPercent + mosaicData[i].startPercent * valueDelta;\n      }\n    }\n\n    if (len % 2 === 0) {\n      stackCache.values.forEach(v => {\n        const delta = catEndPercent - catStartPercent;\n        v[MOSAIC_CAT_END_PERCENT] = catStartPercent + delta * v[STACK_FIELD_END_PERCENT];\n        v[MOSAIC_CAT_START_PERCENT] = catStartPercent + delta * v[STACK_FIELD_START_PERCENT];\n        v[MOSAIC_VALUE_END_PERCENT] = valueEndPercent;\n        v[MOSAIC_VALUE_START_PERCENT] = valueStartPercent;\n      });\n    } else {\n      stackCache.values.forEach(v => {\n        const delta = valueEndPercent - valueStartPercent;\n        v[MOSAIC_VALUE_END_PERCENT] = valueStartPercent + delta * v[STACK_FIELD_END_PERCENT];\n        v[MOSAIC_VALUE_START_PERCENT] = valueStartPercent + delta * v[STACK_FIELD_START_PERCENT];\n        v[MOSAIC_CAT_END_PERCENT] = catEndPercent;\n        v[MOSAIC_CAT_START_PERCENT] = catStartPercent;\n      });\n    }\n  }\n\n  for (const key in stackCache.nodes) {\n    stackMosaic(\n      s,\n      stackCache.nodes[key],\n      (stackCache.nodes[key] as any).mosaicData\n        ? mosaicData\n          ? [...mosaicData, (stackCache.nodes[key] as any).mosaicData]\n          : [(stackCache.nodes[key] as any).mosaicData]\n        : null\n    );\n  }\n}\n\nexport function stackOffsetSilhouette(stackCache: IStackCacheNode) {\n  if (!stackCache.values.length) {\n    return;\n  }\n  const centerValue = stackCache.values[stackCache.values.length - 1][STACK_FIELD_END] / 2;\n  for (let j = 0; j < stackCache.values.length; j++) {\n    stackCache.values[j][STACK_FIELD_START_OffsetSilhouette] = stackCache.values[j][STACK_FIELD_START] - centerValue;\n    stackCache.values[j][STACK_FIELD_END_OffsetSilhouette] = stackCache.values[j][STACK_FIELD_END] - centerValue;\n  }\n}\n\nexport function stack(\n  stackCache: IStackCacheNode,\n  stackInverse: boolean,\n  hasPercent?: boolean,\n  hasMinMax?: boolean,\n  fields: {\n    key: string;\n    start: string;\n    end: string;\n    startPercent: string;\n    endPercent: string;\n    min?: string;\n    max?: string;\n  } = {\n    key: STACK_FIELD_KEY,\n    start: STACK_FIELD_START,\n    end: STACK_FIELD_END,\n    startPercent: STACK_FIELD_START_PERCENT,\n    endPercent: STACK_FIELD_END_PERCENT,\n    max: STACK_FIELD_TOTAL_TOP,\n    min: STACK_FIELD_TOTAL_BOTTOM\n  }\n) {\n  const hasMinField = hasMinMax && isValid(fields.min);\n  const hasMaxField = hasMinMax && isValid(fields.max);\n\n  if (stackCache.values.length > 0) {\n    // 设置一个小数以保证 log 计算不会报错\n    let positiveStart = 0;\n    let negativeStart = 0;\n    // temp\n    let sign = 1;\n    let value = 0;\n    let minNode: any = null;\n    let maxNode: any = null;\n\n    // stack\n    const maxLength = stackCache.values.length;\n    for (let index = 0; index < maxLength; index++) {\n      const v = stackCache.values[stackInverse ? maxLength - 1 - index : index];\n      value = v[fields.end];\n      if (value >= 0) {\n        v[fields.start] = positiveStart;\n        positiveStart += v[fields.end];\n        v[fields.end] = positiveStart;\n      } else {\n        v[fields.start] = negativeStart;\n        negativeStart += v[fields.end];\n        v[fields.end] = negativeStart;\n      }\n      v[fields.key] = stackCache.key;\n\n      if (hasMaxField) {\n        delete v[fields.max];\n        if (!maxNode || v[fields.end] > maxNode[fields.end]) {\n          maxNode = v;\n        }\n      }\n      if (hasMinField) {\n        delete v[fields.min];\n        if (!minNode || v[fields.start] < minNode[fields.start]) {\n          minNode = v;\n        }\n      }\n    }\n\n    hasMaxField && maxNode && (maxNode[fields.max] = true);\n    hasMinField && minNode && (minNode[fields.min] = true);\n\n    if (hasPercent) {\n      // normalize\n      for (let index = 0; index < maxLength; index++) {\n        const v = stackCache.values[stackInverse ? maxLength - 1 - index : index];\n        value = v[fields.end];\n        const denominator = value >= 0 ? positiveStart : negativeStart;\n        sign = value >= 0 ? 1 : -1;\n        v[fields.startPercent] = denominator === 0 ? 0 : Math.min(1, v[fields.start] / denominator) * sign;\n        v[fields.endPercent] = denominator === 0 ? 0 : Math.min(1, v[fields.end] / denominator) * sign;\n      }\n    }\n  }\n\n  for (const key in stackCache.nodes) {\n    stack(stackCache.nodes[key], stackInverse, hasPercent, hasMinMax, fields);\n  }\n}\n\nexport function stackGroup(\n  s: ISeries,\n  stackData: ISeriesStackDataMeta,\n  stackCache: IStackCacheNode,\n  valueField: string,\n  setInitialValue: boolean,\n  stackSortCache: IStackSortCache,\n  stackKey?: string\n) {\n  if ('values' in stackData) {\n    setInitialValue && stackData.values.forEach(v => (v[STACK_FIELD_END] = toValidNumber(v[valueField])));\n    stackCache.series.push({ s: s, values: stackData.values });\n    // 如果有排序\n    if (stackSortCache) {\n      // 系列的 seriesField\n      const seriesField = s.getSeriesField();\n      stackData.values.forEach(d => {\n        stackCache.sortDatums.push({\n          series: s,\n          datum: d,\n          index: seriesField ? stackSortCache[seriesField].sort[d[seriesField]] : 0\n        });\n      });\n    } else {\n      // 如果没有排序，直接生成 values 数组\n      stackCache.values.push(...stackData.values);\n    }\n    return;\n  }\n  for (const key in stackData.nodes) {\n    const newStackKey = stackKey ? `${stackKey}_${key}` : key;\n\n    if (!stackCache.nodes[key]) {\n      stackCache.nodes[key] = {\n        values: [],\n        series: [],\n        nodes: {},\n        sortDatums: [],\n        key: newStackKey\n      };\n\n      if (isValid(stackData.nodes[key]?.groupField)) {\n        stackCache.nodes[key].groupField = stackData.nodes[key].groupField;\n      }\n    }\n\n    stackGroup(\n      s,\n      stackData.nodes[key],\n      stackCache.nodes[key],\n      valueField,\n      setInitialValue,\n      stackSortCache,\n      newStackKey\n    );\n  }\n}\n"]}