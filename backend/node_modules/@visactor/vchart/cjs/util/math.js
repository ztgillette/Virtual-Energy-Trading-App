"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.isValidPoint = exports.getPercentValue = exports.distance = exports.vectorAngle = exports.radiusLabelOrientAttribute = exports.regression = exports.median = exports.standardDeviation = exports.variance = exports.average = exports.sum = exports.max = exports.min = exports.outOfBounds = exports.normalizeStartEndAngle = exports.angleLabelOrientAttribute = exports.normalizeAngle = exports.isLess = exports.isGreater = exports.isClose = void 0;

const type_1 = require("./type"), vutils_1 = require("@visactor/vutils");

Object.defineProperty(exports, "isGreater", {
    enumerable: !0,
    get: function() {
        return vutils_1.isGreater;
    }
}), Object.defineProperty(exports, "isLess", {
    enumerable: !0,
    get: function() {
        return vutils_1.isLess;
    }
}), Object.defineProperty(exports, "normalizeAngle", {
    enumerable: !0,
    get: function() {
        return vutils_1.normalizeAngle;
    }
});

const vrender_components_1 = require("@visactor/vrender-components");

function normalizeStartEndAngle(start, end) {
    let startAngle = 0, endAngle = 2 * Math.PI;
    const isStartValid = (0, vutils_1.isValid)(start), isEndValid = (0, vutils_1.isValid)(end);
    for (isStartValid || isEndValid ? isEndValid ? isStartValid ? (startAngle = start, 
    endAngle = end) : (startAngle = end - 2 * Math.PI, endAngle = end) : (startAngle = start, 
    endAngle = start + 2 * Math.PI) : (startAngle = 0, endAngle = 2 * Math.PI); endAngle <= startAngle; ) endAngle += 2 * Math.PI;
    for (;startAngle > 2 * Math.PI; ) startAngle -= 2 * Math.PI, endAngle -= 2 * Math.PI;
    for (;endAngle < 0; ) startAngle += 2 * Math.PI, endAngle += 2 * Math.PI;
    return {
        startAngle: startAngle,
        endAngle: endAngle
    };
}

function outOfBounds(bounds, x, y) {
    return bounds.x1 > x || bounds.x2 < x || bounds.y1 > y || bounds.y2 < y;
}

function min(data, field) {
    const dataArray = [];
    return data.forEach((d => {
        const value = +d[field];
        (0, type_1.isValidNumber)(value) && dataArray.push(value);
    })), 0 === dataArray.length ? null : (0, vutils_1.minInArray)(dataArray);
}

function max(data, field) {
    const dataArray = [];
    return data.forEach((d => {
        const value = +d[field];
        (0, type_1.isValidNumber)(value) && dataArray.push(value);
    })), 0 === dataArray.length ? null : (0, vutils_1.maxInArray)(dataArray);
}

function sum(data, field) {
    return data.reduce(((pre, _cur) => {
        const cur = field ? +_cur[field] : +_cur;
        return (0, type_1.isValidNumber)(cur) && (pre += cur), pre;
    }), 0);
}

function average(data, field) {
    let sum = 0, count = 0;
    data.forEach((x => {
        const v = field ? +x[field] : +x;
        (0, type_1.isValidNumber)(v) && (sum += v, count++);
    }));
    return sum / count;
}

function variance(data, field) {
    const averageNumber = average(data, field);
    if (data.length <= 1) return 0;
    const total = data.reduce(((sum, cur) => sum + (field ? +cur[field] : +cur - averageNumber) ** 2), 0);
    return total / (data.length - 1);
}

function standardDeviation(data, field) {
    return Math.sqrt(variance(data, field));
}

function median(data, field) {
    return (0, vutils_1.median)(data.map((datum => datum[field])));
}

function regression(data, fieldX, fieldY) {
    const {predict: predict} = (0, vutils_1.regressionLinear)(data, (datum => datum[fieldX]), (datum => datum[fieldY])), x1 = min(data, fieldX), x2 = max(data, fieldX), predict1 = predict(x1), predict2 = predict(x2);
    return [ {
        [fieldX]: x1,
        [fieldY]: predict1
    }, {
        [fieldX]: x2,
        [fieldY]: predict2
    } ];
}

function radiusLabelOrientAttribute(angle) {
    let align = "center", baseline = "middle";
    return align = (angle = (0, vutils_1.normalizeAngle)(angle)) >= Math.PI * (7 / 6) && angle <= Math.PI * (11 / 6) ? "right" : angle >= Math.PI * (1 / 6) && angle <= Math.PI * (5 / 6) ? "left" : "center", 
    baseline = angle >= Math.PI * (5 / 3) || angle <= Math.PI * (1 / 3) ? "bottom" : angle >= Math.PI * (2 / 3) && angle <= Math.PI * (4 / 3) ? "top" : "middle", 
    {
        align: align,
        baseline: baseline
    };
}

function vectorAngle(v1, v2) {
    const v1Length = distance(v1), v2Length = distance(v2), rho = Math.asin((v1.x * v2.y - v2.x * v1.y) / v1Length / v2Length), theta = Math.acos((v1.x * v2.x + v1.y * v2.y) / v1Length / v2Length);
    return rho < 0 ? -theta : theta;
}

function distance(p1, p2 = {
    x: 0,
    y: 0
}) {
    return vutils_1.PointService.distancePP(p1, p2);
}

function getPercentValue(valueList, precision = 2) {
    const sum = valueList.reduce(((a, c) => a + (isNaN(c) ? 0 : c)), 0);
    if (0 === sum) return 0;
    const digits = Math.pow(10, precision), votesPerQuota = valueList.map((val => (isNaN(val) ? 0 : val) / sum * digits * 100)), targetSeats = 100 * digits, seats = votesPerQuota.map((votes => Math.floor(votes)));
    let currentSum = seats.reduce(((a, c) => a + c), 0);
    const remainder = votesPerQuota.map(((votes, idx) => votes - seats[idx]));
    for (;currentSum < targetSeats; ) {
        let max = Number.NEGATIVE_INFINITY, maxId = null;
        for (let i = 0; i < remainder.length; i++) remainder[i] > max && (max = remainder[i], 
        maxId = i);
        ++seats[maxId], remainder[maxId] = 0, ++currentSum;
    }
    return seats.map((entry => entry / digits));
}

function isValidPoint(p) {
    return (0, type_1.isValidNumber)(p.x) && (0, type_1.isValidNumber)(p.y);
}

Object.defineProperty(exports, "angleLabelOrientAttribute", {
    enumerable: !0,
    get: function() {
        return vrender_components_1.angleLabelOrientAttribute;
    }
}), exports.isClose = vutils_1.isNumberClose, exports.normalizeStartEndAngle = normalizeStartEndAngle, 
exports.outOfBounds = outOfBounds, exports.min = min, exports.max = max, exports.sum = sum, 
exports.average = average, exports.variance = variance, exports.standardDeviation = standardDeviation, 
exports.median = median, exports.regression = regression, exports.radiusLabelOrientAttribute = radiusLabelOrientAttribute, 
exports.vectorAngle = vectorAngle, exports.distance = distance, exports.getPercentValue = getPercentValue, 
exports.isValidPoint = isValidPoint;
//# sourceMappingURL=math.js.map
