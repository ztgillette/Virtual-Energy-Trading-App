export const epsilon = 1e-12;

export const pi = Math.PI;

export const halfPi = pi / 2;

export const tau = 2 * pi;

export const NEWTON_ITERATIONS = 4;

export const NEWTON_MIN_SLOPE = .001;

export const SUBDIVISION_PRECISION = 1e-7;

export const SUBDIVISION_MAX_ITERATIONS = 10;

export const pi2 = 2 * Math.PI;

export const abs = Math.abs;

export const atan2 = Math.atan2;

export const cos = Math.cos;

export const max = Math.max;

export const min = Math.min;

export const sin = Math.sin;

export const sqrt = Math.sqrt;

export const pow = Math.pow;

export function acos(x) {
    return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

export function asin(x) {
    return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

export function pointAt(x1, y1, x2, y2, t) {
    let x = x2, y = y2;
    return "number" == typeof x1 && "number" == typeof x2 && (x = (1 - t) * x1 + t * x2), 
    "number" == typeof y1 && "number" == typeof y2 && (y = (1 - t) * y1 + t * y2), {
        x: x,
        y: y
    };
}

export function lengthFromPointToLine(point, point1, point2) {
    const dir1X = point2.x - point1.x, dir1Y = point2.y - point1.y, dir2X = point.x - point1.x, dir2Y = point.y - point1.y;
    return Math.abs(dir1X * dir2Y - dir2X * dir1Y) / Math.sqrt(dir1X * dir1X + dir1Y * dir1Y);
}

export function crossProduct(dir1, dir2) {
    return dir1[0] * dir2[1] - dir1[1] * dir2[0];
}

export function crossProductPoint(dir1, dir2) {
    return dir1.x * dir2.y - dir1.y * dir2.x;
}

export function dotProduct(a, b) {
    let ret = 0;
    for (let i = 0; i < a.length; ++i) ret += a[i] * b[i];
    return ret;
}

export function fuzzyEqualNumber(a, b) {
    return abs(a - b) < 1e-12;
}

export function fuzzyEqualVec(a, b) {
    return abs(a[0] - b[0]) + abs(a[1] - b[1]) < 1e-12;
}

export function fixPrecision(num, precision = 10) {
    return Math.round(num * precision) / precision;
}

export function getDecimalPlaces(n) {
    const dStr = n.toString().split(/[eE]/), s = (dStr[0].split(".")[1] || "").length - (+dStr[1] || 0);
    return s > 0 ? s : 0;
}

export function precisionAdd(a, b) {
    return fixPrecision(a + b, 10 ** Math.max(getDecimalPlaces(a), getDecimalPlaces(b)));
}

export function precisionSub(a, b) {
    return fixPrecision(a - b, 10 ** Math.max(getDecimalPlaces(a), getDecimalPlaces(b)));
}
//# sourceMappingURL=math.js.map