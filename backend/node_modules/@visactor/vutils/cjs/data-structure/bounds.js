"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.OBBBounds = exports.AABBBounds = exports.Bounds = exports.transformBounds = exports.transformBoundsWithMatrix = void 0;

const common_1 = require("../common"), graphics_1 = require("../graphics"), math_1 = require("../math");

function transformBoundsWithMatrix(out, bounds, matrix) {
    const {x1: x1, y1: y1, x2: x2, y2: y2} = bounds;
    return matrix.onlyTranslate() ? (out !== bounds && out.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), 
    out.translate(matrix.e, matrix.f), bounds) : (out.clear(), out.add(matrix.a * x1 + matrix.c * y1 + matrix.e, matrix.b * x1 + matrix.d * y1 + matrix.f), 
    out.add(matrix.a * x2 + matrix.c * y1 + matrix.e, matrix.b * x2 + matrix.d * y1 + matrix.f), 
    out.add(matrix.a * x2 + matrix.c * y2 + matrix.e, matrix.b * x2 + matrix.d * y2 + matrix.f), 
    out.add(matrix.a * x1 + matrix.c * y2 + matrix.e, matrix.b * x1 + matrix.d * y2 + matrix.f), 
    bounds);
}

function transformBounds(bounds, x, y, scaleX, scaleY, angle, rotateCenter) {
    if (!((0, math_1.abs)(scaleX) <= math_1.epsilon || (0, math_1.abs)(scaleY) <= math_1.epsilon)) {
        if (1 !== scaleX && bounds.scaleX(scaleX), 1 !== scaleY && bounds.scaleY(scaleY), 
        isFinite(angle) && Math.abs(angle) > math_1.epsilon) {
            let rx = 0, ry = 0;
            void 0 !== rotateCenter && (rx = rotateCenter[0], ry = rotateCenter[1]), bounds.rotate(angle, rx, ry);
        }
        bounds.translate(x, y);
    }
}

exports.transformBoundsWithMatrix = transformBoundsWithMatrix, exports.transformBounds = transformBounds;

class Bounds {
    constructor(bounds) {
        bounds ? this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2) : this.clear();
    }
    clone() {
        return new Bounds(this);
    }
    clear() {
        return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, 
        this.y2 = -Number.MAX_VALUE, this;
    }
    empty() {
        return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
    }
    equals(b) {
        return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
    }
    setValue(x1 = 0, y1 = 0, x2 = 0, y2 = 0) {
        return this.x1 = x1, this.y1 = y1, this.x2 = x2, this.y2 = y2, this;
    }
    set(x1 = 0, y1 = 0, x2 = 0, y2 = 0) {
        return x2 < x1 ? (this.x2 = x1, this.x1 = x2) : (this.x1 = x1, this.x2 = x2), y2 < y1 ? (this.y2 = y1, 
        this.y1 = y2) : (this.y1 = y1, this.y2 = y2), this;
    }
    add(x = 0, y = 0) {
        return x < this.x1 && (this.x1 = x), y < this.y1 && (this.y1 = y), x > this.x2 && (this.x2 = x), 
        y > this.y2 && (this.y2 = y), this;
    }
    expand(d = 0) {
        return (0, common_1.isArray)(d) ? (this.y1 -= d[0], this.x2 += d[1], this.y2 += d[2], 
        this.x1 -= d[3]) : (this.x1 -= d, this.y1 -= d, this.x2 += d, this.y2 += d), this;
    }
    round() {
        return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), 
        this.y2 = Math.ceil(this.y2), this;
    }
    translate(dx = 0, dy = 0) {
        return this.x1 += dx, this.x2 += dx, this.y1 += dy, this.y2 += dy, this;
    }
    rotate(angle = 0, x = 0, y = 0) {
        const p = this.rotatedPoints(angle, x, y);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
    }
    scale(sx = 0, sy = 0, x = 0, y = 0) {
        const p = this.scalePoints(sx, sy, x, y);
        return this.clear().add(p[0], p[1]).add(p[2], p[3]);
    }
    union(b) {
        return b.x1 < this.x1 && (this.x1 = b.x1), b.y1 < this.y1 && (this.y1 = b.y1), b.x2 > this.x2 && (this.x2 = b.x2), 
        b.y2 > this.y2 && (this.y2 = b.y2), this;
    }
    intersect(b) {
        return b.x1 > this.x1 && (this.x1 = b.x1), b.y1 > this.y1 && (this.y1 = b.y1), b.x2 < this.x2 && (this.x2 = b.x2), 
        b.y2 < this.y2 && (this.y2 = b.y2), this;
    }
    encloses(b) {
        return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
    }
    alignsWith(b) {
        return b && (this.x1 === b.x1 || this.x2 === b.x2 || this.y1 === b.y1 || this.y2 === b.y2);
    }
    intersects(b) {
        return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
    }
    contains(x = 0, y = 0) {
        return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
    }
    containsPoint(p) {
        return !(p.x < this.x1 || p.x > this.x2 || p.y < this.y1 || p.y > this.y2);
    }
    width() {
        return this.empty() ? 0 : this.x2 - this.x1;
    }
    height() {
        return this.empty() ? 0 : this.y2 - this.y1;
    }
    scaleX(s = 0) {
        return this.x1 *= s, this.x2 *= s, this;
    }
    scaleY(s = 0) {
        return this.y1 *= s, this.y2 *= s, this;
    }
    transformWithMatrix(matrix) {
        return transformBoundsWithMatrix(this, this, matrix), this;
    }
    copy(b) {
        return this.x1 = b.x1, this.y1 = b.y1, this.x2 = b.x2, this.y2 = b.y2, this;
    }
    rotatedPoints(angle, x, y) {
        const {x1: x1, y1: y1, x2: x2, y2: y2} = this, cos = Math.cos(angle), sin = Math.sin(angle), cx = x - x * cos + y * sin, cy = y - x * sin - y * cos;
        return [ cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy ];
    }
    scalePoints(sx, sy, x, y) {
        const {x1: x1, y1: y1, x2: x2, y2: y2} = this;
        return [ sx * x1 + (1 - sx) * x, sy * y1 + (1 - sy) * y, sx * x2 + (1 - sx) * x, sy * y2 + (1 - sy) * y ];
    }
}

exports.Bounds = Bounds;

class AABBBounds extends Bounds {}

exports.AABBBounds = AABBBounds;

class OBBBounds extends Bounds {
    constructor(bounds, angle = 0) {
        var _a;
        super(bounds), bounds && (this.angle = null !== (_a = bounds.angle) && void 0 !== _a ? _a : angle);
    }
    intersects(b) {
        return (0, graphics_1.isRotateAABBIntersect)(this, b);
    }
    setValue(x1 = 0, y1 = 0, x2 = 0, y2 = 0, angle = 0) {
        return super.setValue(x1, y1, x2, y2), this.angle = angle, this;
    }
    clone() {
        return new OBBBounds(this);
    }
    getRotatedCorners() {
        const originPoint = {
            x: (this.x1 + this.x2) / 2,
            y: (this.y1 + this.y2) / 2
        };
        return [ (0, graphics_1.rotatePoint)({
            x: this.x1,
            y: this.y1
        }, this.angle, originPoint), (0, graphics_1.rotatePoint)({
            x: this.x2,
            y: this.y1
        }, this.angle, originPoint), (0, graphics_1.rotatePoint)({
            x: this.x1,
            y: this.y2
        }, this.angle, originPoint), (0, graphics_1.rotatePoint)({
            x: this.x2,
            y: this.y2
        }, this.angle, originPoint) ];
    }
}

exports.OBBBounds = OBBBounds;
//# sourceMappingURL=bounds.js.map
