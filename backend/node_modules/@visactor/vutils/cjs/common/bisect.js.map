{"version":3,"sources":["../src/common/bisect.ts"],"names":[],"mappings":"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","file":"bisect.js","sourcesContent":["import { ascending } from './ascending';\nimport isNil from './isNil';\nimport { Logger } from '../logger';\n\n/**\n * 通过二分法，查找数组a中大于数值x的第一个元素的序号\n * @param a\n * @param x\n * @param lo\n * @param hi\n * @returns\n */\nexport function bisect(a: number[], x: number, lo: number = 0, hi?: number) {\n  if (isNil(hi)) {\n    hi = a.length;\n  }\n  while (lo < (hi as number)) {\n    const mid: number = (lo + (hi as number)) >>> 1;\n    if (ascending(a[mid], x) > 0) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\n\n/* Adapted from fmin by Ben Frederickson\n * https://github.com/benfred/fmin\n * Licensed under the BSD-3-Clause\n\n * url: https://github.com/benfred/fmin/blob/master/src/bisect.js\n * License: https://github.com/benfred/fmin/blob/master/LICENSE\n * @license\n */\n/** finds the zeros of a function, given two starting points (which must\n * have opposite signs */\nexport function findZeroOfFunction(\n  f: (entry: number) => number,\n  a: number,\n  b: number,\n  parameters?: {\n    maxIterations?: number;\n    tolerance?: number;\n  }\n) {\n  const maxIterations = parameters?.maxIterations ?? 100;\n  const tolerance = parameters?.tolerance ?? 1e-10;\n  const fA = f(a);\n  const fB = f(b);\n  let delta = b - a;\n\n  if (fA * fB > 0) {\n    const logger = Logger.getInstance();\n    logger.error('Initial bisect points must have opposite signs');\n    return NaN;\n  }\n\n  if (fA === 0) {\n    return a;\n  }\n  if (fB === 0) {\n    return b;\n  }\n\n  for (let i = 0; i < maxIterations; ++i) {\n    delta /= 2;\n    const mid = a + delta;\n    const fMid = f(mid);\n\n    if (fMid * fA >= 0) {\n      a = mid;\n    }\n\n    if (Math.abs(delta) < tolerance || fMid === 0) {\n      return mid;\n    }\n  }\n  return a + delta;\n}\n\n/**\n * 二分靠近框架，返回数组中第一个大于等于目标值的数的索引\n * @param arr 数组\n * @param compareFn 比较函数，返回(当前值-目标值)\n */\nexport const binaryFuzzySearch = <T>(arr: T[], compareFn: (value: T) => number) => {\n  return binaryFuzzySearchInNumberRange(0, arr.length, value => compareFn(arr[value]));\n};\n\n/**\n * 二分靠近框架，返回数字区间中第一个大于等于目标值的数字\n * @param x1 区间上界\n * @param x2 区间下界（不包含）\n * @param compareFn 比较函数，返回(当前值-目标值)\n */\nexport const binaryFuzzySearchInNumberRange = (x1: number, x2: number, compareFn: (value: number) => number) => {\n  let left = x1;\n  let right = x2;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    if (compareFn(mid) >= 0) {\n      right = mid; // 第一个大于等于目标值的数\n    } else {\n      left = mid + 1;\n    }\n  }\n  return left;\n};\n"]}