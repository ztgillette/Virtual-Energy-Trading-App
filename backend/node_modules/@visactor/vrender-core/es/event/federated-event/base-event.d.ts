import type { IPickEventParams } from '../../interface';
import type { EventPoint, IEventTarget } from '../../interface/event';
import type { EventManager } from '../event-manager';
export declare class FederatedEvent<N extends Event = Event> implements Event {
    bubbles: boolean;
    cancelBubble: boolean;
    pickParams?: IPickEventParams;
    readonly cancelable = false;
    readonly composed = false;
    currentTarget: IEventTarget | null;
    defaultPrevented: boolean;
    eventPhase: number;
    isTrusted: boolean;
    returnValue: boolean;
    srcElement: IEventTarget;
    target: IEventTarget | null;
    timeStamp: number;
    type: string;
    nativeEvent: N;
    originalEvent: FederatedEvent<N> | null;
    propagationStopped: boolean;
    propagationImmediatelyStopped: boolean;
    path: IEventTarget[];
    detailPath?: Array<IEventTarget[] | IEventTarget | IEventTarget[][]>;
    readonly manager?: EventManager;
    detail: any;
    view: any;
    layer: EventPoint;
    get layerX(): number;
    get layerY(): number;
    page: EventPoint;
    get pageX(): number;
    get pageY(): number;
    canvas: EventPoint;
    get x(): number;
    get y(): number;
    get canvasX(): number;
    get canvasY(): number;
    viewport: EventPoint;
    get viewX(): number;
    get viewY(): number;
    constructor(manager?: EventManager);
    composedPath(): IEventTarget[];
    composedDetailPath(): (IEventTarget | IEventTarget[] | IEventTarget[][])[];
    _composedDetailPath(params: any): void;
    preventDefault(): void;
    stopImmediatePropagation(): void;
    stopPropagation(): void;
    initEvent(): void;
    initUIEvent(): void;
    clone(): void;
    which: number;
    readonly NONE = 0;
    readonly CAPTURING_PHASE = 1;
    readonly AT_TARGET = 2;
    readonly BUBBLING_PHASE = 3;
}
