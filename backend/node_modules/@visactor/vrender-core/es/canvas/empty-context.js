var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

import { Matrix } from "@visactor/vutils";

import { injectable } from "../common/inversify-lite";

import { contain, containStroke } from "./util";

import { CustomPath2D } from "../common/custom-path2d";

import { getScaledStroke } from "../common/canvas-utils";

import { matrixAllocate } from "../allocator/matrix-allocate";

const initMatrix = new Matrix(1, 0, 0, 1, 0, 0), globalPoint = {
    x: 0,
    y: 0
};

let EmptyContext2d = class {
    get nativeContext() {
        return this.path;
    }
    constructor(canvas, dpr) {
        this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), 
        this.path = new CustomPath2D, this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    }
    getCanvas() {
        throw new Error("不支持getCanvas");
    }
    getContext() {
        throw new Error("不支持getContext");
    }
    setTransformForCurrent(force = !1) {
        !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix = this.cloneMatrix(this.matrix));
    }
    get currentMatrix() {
        return this.matrix;
    }
    cloneMatrix(m) {
        return matrixAllocate.allocateByObj(m);
    }
    clear() {
        this.save(), this.resetTransform(), this.restore();
    }
    reset() {
        this.matrix.setValue(1, 0, 0, 1, 0, 0), this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), 
        this.stack.length = 0;
    }
    restore() {
        this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), 
        this.setTransformForCurrent());
    }
    highPerformanceRestore() {
        this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
    }
    rotate(rad, setTransform = !0) {
        this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
    }
    save() {
        const matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix);
    }
    highPerformanceSave() {
        const matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix);
    }
    scale(sx, sy, setTransform = !0) {
        this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
    }
    setScale(sx, sy, setTransform = !0) {
        this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
    }
    scalePoint(sx, sy, px, py, setTransform = !0) {
        this.translate(px, py, !1), this.scale(sx, sy, !1), this.translate(-px, -py, !1), 
        setTransform && this.setTransformForCurrent();
    }
    setTransform(a, b, c, d, e, f, setTransform = !0, dpr = this.dpr) {
        this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
    }
    setTransformFromMatrix(matrix, setTransform = !0, dpr = this.dpr) {
        this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), 
        setTransform && this.setTransformForCurrent();
    }
    resetTransform(setTransform = !0, dpr = this.dpr) {
        this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
    }
    transform(a, b, c, d, e, f, setTransform = !0) {
        this.matrix.multiply(a, b, c, d, e, f), setTransform && this.setTransformForCurrent();
    }
    transformFromMatrix(matrix, setTransform) {
        this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), 
        setTransform && this.setTransformForCurrent();
    }
    translate(x, y, setTransform = !0) {
        this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
    }
    rotateDegrees(deg, setTransform = !0) {
        const rad = deg * Math.PI / 180;
        this.rotate(rad, setTransform);
    }
    rotateAbout(rad, x, y, setTransform = !0) {
        this.translate(x, y, !1), this.rotate(rad, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
    }
    rotateDegreesAbout(deg, x, y, setTransform = !0) {
        this.translate(x, y, !1), this.rotateDegrees(deg, !1), this.translate(-x, -y, !1), 
        setTransform && this.setTransformForCurrent();
    }
    beginPath() {
        this.path.clear();
    }
    clip(path, fillRule) {}
    arc(x, y, radius, startAngle, endAngle, anticlockwise) {
        this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    arcTo(x1, y1, x2, y2, radiusX) {
        this.path.arcTo(x1, y1, x2, y2, radiusX);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    closePath() {
        this.path.closePath();
    }
    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {}
    lineTo(x, y) {
        this.path.lineTo(x, y);
    }
    moveTo(x, y) {
        this.path.moveTo(x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
        this.path.quadraticCurveTo(cpx, cpy, x, y);
    }
    rect(x, y, w, h) {
        this.path.rect(x, y, w, h);
    }
    createImageData(imageDataOrSw, sh) {
        return null;
    }
    createLinearGradient(x0, y0, x1, y1) {
        throw new Error("不支持createLinearGradient");
    }
    createPattern(image, repetition) {
        throw new Error("不支持createPattern");
    }
    createRadialGradient(x0, y0, r0, x1, y1, r1) {
        throw new Error("不支持createRadialGradient");
    }
    createConicGradient(x, y, startAngle, endAngle) {
        return null;
    }
    fill(path, fillRule) {}
    fillRect(x, y, width, height) {
        this.path.rect(x, y, width, height);
    }
    clearRect(x, y, w, h) {}
    fillText(text, x, y) {}
    getImageData(sx, sy, sw, sh) {
        return null;
    }
    getLineDash() {
        return [];
    }
    isPointInPath(x, y) {
        return this.matrix.transformPoint({
            x: x,
            y: y
        }, globalPoint), contain(this.path.commandList, globalPoint.x, globalPoint.y);
    }
    isPointInStroke(x, y) {
        if (!this.lineWidth) return !1;
        this.matrix.transformPoint({
            x: x,
            y: y
        }, globalPoint);
        const lineWidth = getScaledStroke(this, this.lineWidth, this.dpr);
        return containStroke(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);
    }
    measureText(text) {
        throw new Error("不支持measureText");
    }
    putImageData(imagedata, dx, dy) {
        throw new Error("不支持measureText");
    }
    setLineDash(segments) {}
    stroke(path) {}
    strokeRect(x, y, width, height) {
        this.path.rect(x, y, width, height);
    }
    strokeText(text, x, y) {}
    drawImage() {}
    setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {}
    _setCommonStyle(params, offsetX, offsetY, defaultParams) {}
    setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {}
    _setStrokeStyle(params, offsetX, offsetY, defaultParams) {}
    setTextStyleWithoutAlignBaseline(params, defaultParams) {}
    setTextStyle(params, defaultParams) {}
    draw() {}
    clearMatrix(setTransform = !0, dpr = this.dpr) {
        this.setTransformFromMatrix(initMatrix, setTransform, dpr);
    }
    setClearMatrix(a, b, c, d, e, f) {
        this._clearMatrix.setValue(a, b, c, d, e, f);
    }
    onlyTranslate(dpr = this.dpr) {
        return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
    }
    release(...params) {
        this.stack.forEach((m => matrixAllocate.free(m))), this.stack.length = 0;
    }
};

EmptyContext2d = __decorate([ injectable(), __metadata("design:paramtypes", [ Object, Number ]) ], EmptyContext2d);

export { EmptyContext2d };
//# sourceMappingURL=empty-context.js.map