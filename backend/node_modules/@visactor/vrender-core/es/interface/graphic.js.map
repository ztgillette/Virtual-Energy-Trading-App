{"version":3,"sources":["../src/interface/graphic.ts"],"names":[],"mappings":"","file":"graphic.js","sourcesContent":["import type { IAABBBounds, IMatrix, IPointLike, IPoint, BoundsAnchorType, IOBBBounds } from '@visactor/vutils';\nimport type { IAnimate, IStep, EasingType, IAnimateTarget, ITimeline } from './animation';\nimport type { IColor } from './color';\nimport type { IGroup } from './graphic/group';\nimport type { IShadowRoot } from './graphic/shadow-root';\nimport type { ILayer } from './layer';\nimport type { INode } from './node-tree';\nimport type { ICustomPath2D } from './path';\nimport type { IStage } from './stage';\nimport type { IGlyphGraphicAttribute } from './graphic/glyph';\nimport type { IContainPointMode } from '../common/enums';\nimport type { IFace3d } from './graphic/face3d';\nimport type { IPickerService } from './picker';\nimport type { ISymbolClass } from './graphic/symbol';\n\ntype IStrokeSeg = {\n  /**\n   * 百分比\n   */\n  start: number;\n  /**\n   * 百分比\n   * end和length二选一\n   */\n  end: number;\n  /**\n   * 像素长度\n   */\n  length: number;\n};\n\n// TODO 最后加一个any\nexport type GraphicType =\n  | 'area'\n  | 'circle'\n  | 'ellipse'\n  | 'line'\n  | 'rect'\n  | 'rect3d'\n  | 'path'\n  | 'richtext'\n  | 'text'\n  | 'arc'\n  | 'arc3d'\n  | 'image'\n  | 'symbol'\n  | 'group'\n  | 'shadowroot'\n  | 'polygon'\n  | 'pyramid3d'\n  | 'glyph'\n  | string;\n\n// Cursor style\n// See: https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\nexport type Cursor =\n  | 'auto'\n  | 'default'\n  | 'none'\n  | 'context-menu'\n  | 'help'\n  | 'pointer'\n  | 'progress'\n  | 'wait'\n  | 'cell'\n  | 'crosshair'\n  | 'text'\n  | 'vertical-text'\n  | 'alias'\n  | 'copy'\n  | 'move'\n  | 'no-drop'\n  | 'not-allowed'\n  | 'grab'\n  | 'grabbing'\n  | 'all-scroll'\n  | 'col-resize'\n  | 'row-resize'\n  | 'n-resize'\n  | 'e-resize'\n  | 's-resize'\n  | 'w-resize'\n  | 'ne-resize'\n  | 'nw-resize'\n  | 'se-resize'\n  | 'sw-resize'\n  | 'ew-resize'\n  | 'ns-resize'\n  | 'nesw-resize'\n  | 'nwse-resize'\n  | 'zoom-in'\n  | 'zoom-out';\n\nexport type ITransform = {\n  /**\n   * x坐标\n   */\n  x: number;\n  /**\n   * y坐标\n   */\n  y: number;\n  /**\n   * z坐标\n   */\n  z: number;\n  /**\n   * x方向偏移量\n   */\n  dx: number;\n  /**\n   * y方向偏移量\n   */\n  dy: number;\n  /**\n   * z方向偏移量\n   */\n  dz: number;\n  /**\n   * x方向的滚动值\n   */\n  scrollX: number;\n  /**\n   * y方向的滚动值\n   */\n  scrollY: number;\n  /**\n   * x方向的缩放值\n   */\n  scaleX: number;\n  /**\n   * y方向的缩放值\n   */\n  scaleY: number;\n  /**\n   * z方向的缩放值\n   */\n  scaleZ: number;\n  /**\n   * 绕z轴的转角，即xy平面上的旋转角度\n   */\n  angle: number;\n  /**\n   * 绕x轴的转角\n   */\n  alpha: number;\n  /**\n   * 绕y轴的转角\n   */\n  beta: number;\n  /**\n   * 应用缩放的中心\n   */\n  scaleCenter: [number | string, number | string];\n  /**\n   * 基于AABB的锚点位置，用于简单的定位某些path\n   */\n  anchor: [number | string, number | string];\n  /**\n   * 3d的锚点位置\n   */\n  anchor3d: [number | string, number | string, number] | [number | string, number | string];\n  /**\n   * 处理矩阵，在正常计算完变换矩阵之后，会将该矩阵乘到变换矩阵上得到最终的变换矩阵\n   */\n  postMatrix: IMatrix;\n};\n\nexport type IFillType = boolean | string | IColor;\nexport type IFillStyle = {\n  /**\n   * 图形的填充透明度\n   */\n  fillOpacity: number;\n  /**\n   * 图形模糊效果程度\n   */\n  shadowBlur: number;\n  /**\n   * 图形的阴影颜色\n   */\n  shadowColor: string;\n  /**\n   * 阴影水平偏移距离\n   */\n  shadowOffsetX: number;\n  /**\n   * 阴影垂直偏移距离\n   */\n  shadowOffsetY: number;\n  /**\n   * 图形的填充颜色\n   */\n  fill: IFillType;\n};\n\nexport type ILayout = {\n  /**\n   * 设置对齐方式\n   */\n  alignSelf: 'auto' | 'flex-start' | 'flex-end' | 'center';\n};\n\nexport type IBorderStyle = Omit<IStrokeStyle, 'outerBorder' | 'innerBorder'> & {\n  /**\n   * 边距离边缘的距离\n   */\n  distance: number | string;\n  /**\n   * 是否显示边框，默认是不显示的\n   */\n  visible?: boolean;\n};\n\nexport type IStrokeType = boolean | string | IColor | null;\nexport type IStrokeStyle = {\n  /**\n   * 外部边框的样式配置，默认不展示外部边框\n   */\n  outerBorder: Partial<IBorderStyle>;\n  /**\n   * 内部边框的样式配置\n   */\n  innerBorder: Partial<IBorderStyle>;\n  /**\n   * 描边的透明度\n   */\n  strokeOpacity: number;\n  /**\n   * 设置线条虚线样式的属性，它通过定义实线和空白的交替长度来创建虚线效果\n   */\n  lineDash: number[];\n\n  /**\n   * 设置虚线样式的起始偏移量\n   */\n  lineDashOffset: number;\n\n  /**\n   * 设置线条的宽度\n   */\n  lineWidth: number;\n\n  /**\n   * 设置线条末端的样式\n   */\n  lineCap: CanvasLineCap;\n\n  /**\n   * 设置线条拐角的样式\n   */\n  lineJoin: CanvasLineJoin;\n\n  /**\n   * 设置线条拐角处的斜接限制\n   */\n  miterLimit: number;\n  /**\n   * 描边的boundsBuffer，用于控制bounds的buffer\n   */\n  strokeBoundsBuffer: number;\n  /**\n   * stroke - true 全描边\n   * stroke - false 不描边\n   * stroke 为数值类型，适用于rect\\arc等图形，用于配置部分描边的场景，其中\n   *\n   * 0b00000 - 不描边\n   * 0b000001 - top\n   * 0b000010 - right\n   * 0b000100 - bottom\n   * 0b001000 - left\n   * 相应的：\n   * 0b000011 - top + right\n   * 0b000111 - top + right + bottom\n   * 0b001111 - 全描边\n   *\n   * stroke - boolean[]，适用于rect\\arc等图形，用于配置部分描边的场景\n   */\n  stroke: IStrokeType[] | IStrokeType;\n};\n\ntype TextureType = 'circle' | 'diamond' | 'rect' | 'vertical-line' | 'horizontal-line' | 'bias-lr' | 'bias-rl' | 'grid';\n\nexport type IConnectedStyle = {\n  /**\n   * 连接，取零或者断开\n   */\n  connectedType: 'connect' | 'none';\n  /**\n   * 连接线的样式配置\n   */\n  connectedStyle: {\n    stroke: IStrokeStyle['stroke'];\n    strokeOpacity: IStrokeStyle['strokeOpacity'];\n    lineDash: IStrokeStyle['lineDash'];\n    lineDashOffset: IStrokeStyle['lineDashOffset'];\n    lineCap: IStrokeStyle['lineCap'];\n    lineJoin: IStrokeStyle['lineJoin'];\n    lineWidth: IStrokeStyle['lineWidth'];\n    fill: IFillStyle['fill'];\n    fillOpacity: IFillStyle['fillOpacity'];\n  };\n  connectedX: number;\n  connectedY: number;\n};\n\nexport type IBackgroundConfig = {\n  stroke?: string | boolean;\n  fill?: string | boolean;\n  lineWidth?: number;\n  cornerRadius?: number;\n  expandX?: number;\n  expandY?: number;\n};\n\ntype IBackgroundType = string | HTMLImageElement | HTMLCanvasElement | IBackgroundConfig;\n\nexport interface SimpleDomStyleOptions {\n  /**\n   * 容器的宽度\n   */\n  width: number;\n  /**\n   * 容器的高度\n   */\n  height: number;\n  /**\n   * 容器的样式设置\n   */\n  style?:\n    | string\n    | Record<string, any>\n    | ((\n        pos: { top: number; left: number; width: number; height: number },\n        graphic: IGraphic,\n        wrapContainer: HTMLElement\n      ) => Record<string, any>); // 容器的样式\n}\n\nexport interface CommonDomOptions {\n  /**\n   * 全局唯一的id\n   */\n  id?: string;\n  /**\n   * 容器元素的id或者dom元素\n   */\n  container: string | HTMLElement | null;\n  /**\n   * 是否显示\n   */\n  visible?: boolean;\n  /**\n   * 是否支持事件冒泡\n   */\n  pointerEvents?: boolean | string;\n  /**\n   * 可穿透的事件列表\n   * @since 0.21.2\n   */\n  penetrateEventList?: string[];\n  /**\n   * 定位类型\n   * 'position' - 根据挂载图形节点的坐标也就是x,y进行定位\n   * 'boundsLeftTop' - 定位到挂载图形节点bounds的左上角\n   * 'left' - 定位到挂载图形节点bounds 的左侧\n   * 'right' - 定位到挂载图形节点bounds 的右侧\n   * 'bottom' - 定位到挂载图形节点bounds 的底部\n   * 'top' - 定位到挂载图形节点bounds 的顶部\n   * 'center' - 定位到挂载图形节点bounds 的中心\n   * 'top-left' - 定位到挂载图形节点bounds 的左上角\n   * 'top-right' - 定位到挂载图形节点bounds 的右上角\n   * 'bottom-left' - 定位到挂载图形节点bounds 的左下角\n   * 'bottom-right' - 定位到挂载图形节点bounds 的右下角\n   */\n  anchorType?: 'position' | 'boundsLeftTop' | BoundsAnchorType;\n}\n\nexport type IRoughStyle = {\n  fillStyle: 'hachure' | 'solid' | 'zigzag' | 'cross-hatch' | 'dots' | 'sunburst' | 'dashed' | 'zigzag-line';\n  roughness: number;\n  bowing: number;\n};\n\nexport type IGraphicStyle = ILayout &\n  IFillStyle &\n  IStrokeStyle &\n  IPickStyle & {\n    /**\n     * 强制设置的bounds宽度，主要用于使用html或者react展示图形的时候，设置一个固定的宽度\n     */\n    forceBoundsWidth: number | (() => number) | undefined;\n    /**\n     * 强制设置的bounds高度，主要用于使用html或者react展示图形的时候，设置一个固定的高度\n     */\n    forceBoundsHeight: number | (() => number) | undefined;\n    /**\n     * 透明度，会同时影响填充和描边\n     */\n    opacity: number;\n    /**\n     * 影子节点\n     */\n    shadowGraphic?: IGraphic | undefined;\n    /**\n     * 背景填充模式（与具体图元有关）\n     */\n    backgroundMode: 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\n    /**\n     * 是否正好填充，只在repeat-x或者repeat-y以及no-repeat的时候生效\n     */\n    backgroundFit: boolean;\n    /**\n     * 是否保持背景图的宽高比\n     */\n    backgroundKeepAspectRatio: boolean;\n    /**\n     * 背景图缩放，只在no-repeat的时候生效\n     */\n    backgroundScale: number;\n    /**\n     * 背景图偏移，只在no-repeat的时候生效\n     */\n    backgroundOffsetX: number;\n    /**\n     * 背景图偏移，只在no-repeat的时候生效\n     */\n    backgroundOffsetY: number;\n    /**\n     * 背景图是否裁切，是否调用clip避免绘制到图元外部\n     */\n    backgroundClip: boolean;\n    /**\n     * 背景圆角半径\n     */\n    backgroundCornerRadius: number | number[];\n    /**\n     * 背景透明度\n     */\n    backgroundOpacity: number;\n    /**\n     * 背景，支持颜色字符串、html image元素、html canvas元素\n     */\n    // 纹理是否自动做动画\n    autoAnimateTexture: boolean;\n    // 如果做动画的话，这里代表ratio\n    textureRatio: number;\n    textureOptions: any;\n    background:\n      | IBackgroundType\n      | {\n          /**\n           * 背景，支持颜色字符串、html image元素、html canvas元素\n           */\n          background: IBackgroundType;\n          /**\n           * 背景的x方向偏移量\n           */\n          dx?: number;\n          /**\n           * 背景的y方向偏移量\n           */\n          dy?: number;\n          /**\n           * 背景宽度\n           */\n          width?: number;\n          /**\n           * 背景高度\n           */\n          height?: number;\n          /**\n           * 背景的x坐标\n           */\n          x?: number;\n          /**\n           * 背景的y坐标\n           */\n          y?: number;\n        }\n      | null; // 背景，可以与fill同时存在\n    /**\n     * 纹理的类型\n     */\n    texture: TextureType | string;\n    /**\n     * 纹理的颜色\n     */\n    textureColor: string;\n    /**\n     * 纹理的大小\n     */\n    textureSize: number;\n    /**\n     * 纹理的间隙\n     */\n    texturePadding: number;\n\n    blur: number;\n    /**\n     * 设置图形对应的鼠标样式\n     */\n    cursor: Cursor | null;\n    // @deprecated 用处少废弃，后续考虑新设计API\n    filter: string;\n    renderStyle?: 'default' | 'rough' | any;\n    roughStyle?: IRoughStyle | null;\n    /**\n     * HTML的dom或者string\n     */\n    html:\n      | ({\n          /**\n           * dom字符串或者dom\n           */\n          dom: string | HTMLElement;\n        } & SimpleDomStyleOptions &\n          CommonDomOptions)\n      | null;\n    /**\n     * 使用react元素渲染内容\n     */\n    react:\n      | ({\n          /**\n           * react场景节点\n           */\n          element: any;\n        } & SimpleDomStyleOptions &\n          CommonDomOptions)\n      | null;\n    /**\n     * 使用vue组件渲染内容\n     */\n    vue:\n      | ({\n          /**\n           * vue 虚拟节点\n           */\n          element: any;\n        } & SimpleDomStyleOptions &\n          CommonDomOptions)\n      | null;\n  };\n\nexport type IPickStyle = {\n  /**\n   * 给stroke模式的pick额外加的buffer，用于外界控制stroke区域的pick范围\n   */\n  pickStrokeBuffer: number;\n};\n\nexport type IDebugType = {\n  _debug_bounds: boolean | ((c: any, g: any) => void);\n};\nexport type IGraphicAttribute = IDebugType &\n  IGraphicStyle &\n  ITransform & {\n    /**\n     * stroke百分比\n     */\n    strokeSeg: IStrokeSeg | null;\n    /**\n     * 包围盒的padding\n     */\n    boundsPadding: number | number[];\n    /**\n     * 选择模式，精确模式，粗糙模式（包围盒模式），自定义模式\n     */\n    pickMode: 'accurate' | 'imprecise' | 'custom';\n    boundsMode: 'accurate' | 'imprecise' | 'empty';\n    customPickShape: () => boolean | null;\n    /**\n     * 是否支持事件拾取，默认为 true。\n     * @default true\n     */\n    pickable: boolean;\n    /**\n     * 是否支持fill拾取，默认为 true。\n     * @experimental\n     * @default true\n     */\n    fillPickable: boolean;\n    /**\n     * 是否支持stroke拾取，默认为 true。\n     * @experimental\n     * @default true\n     */\n    strokePickable: boolean;\n    /**\n     * 对于 group 节点，是否支持其子元素的事件拾取，默认为 true。\n     * 如果 group `pickable` 关闭，`childrenPickable` 开启，那么 group 的子节点仍参与事件拾取\n     * @default true\n     */\n    childrenPickable: boolean;\n    /**\n     * 元素是否可见。\n     * @default true\n     */\n    visible: boolean;\n    /**\n     * 分组下的层级，层级越小越先绘制\n     */\n    zIndex: number;\n    layout: any;\n    /**\n     * 是否隐藏元素（只是绘制的时候不绘制）\n     */\n    renderable: boolean;\n    /**\n     * 是否在3d中控制方向\n     * false: 不控制方向\n     * true: 始终控制方向朝摄像机\n     */\n    keepDirIn3d?: boolean;\n    shadowRootIdx: number;\n    shadowPickMode?: 'full' | 'graphic';\n    /**\n     * 全局范围的层级，设置了这个属性的图形，会提取到交互层进行渲染\n     */\n    globalZIndex: number;\n    /**\n     * canvas 的合成方式\n     */\n    globalCompositeOperation: CanvasRenderingContext2D['globalCompositeOperation'] | '';\n    /**\n     * 完全支持滚动 | 完全不支持滚动 | 支持x方向的滚动 | 支持y方向的滚动\n     */\n    overflow: 'scroll' | 'hidden' | 'scroll-x' | 'scroll-y';\n    /**\n     * 绘制fill和stroke的顺序，为0表示fill先绘制，1表示stroke先绘制\n     */\n    fillStrokeOrder: number;\n    /**\n     * @since 0.20.15\n     * 保持stroke的scale，默认为false，为true的话stroke显示的宽度会随着scale变化\n     */\n    keepStrokeScale: boolean;\n\n    /**\n     * @since 0.22.2\n     * 裁剪路径，用于裁剪图形，用于普通图元的裁剪\n     * 由于一般情况下普通图元只需要一个形状即可，所以这里不需要配置具体的位置和大小，强制中心在图元中心，宽高和图元Bounds宽高一致\n     * 不考虑其他复杂情况，否则配置项就非常多了，比如多路径，或者配置位置大小等，如果配置大小那还得用户自己去拿图元的大小，目前没有这种需求\n     */\n    clipConfig: {\n      shape: string;\n    } | null;\n  };\n\nexport interface IGraphicJson<T extends Partial<IGraphicAttribute> = Partial<IGraphicAttribute>> {\n  attribute: Partial<T>;\n  _uid: number;\n  type: string;\n  name: string;\n  children: IGraphicJson<T>[];\n}\n\n/** the context of setAttribute */\nexport type ISetAttributeContext = {\n  /** type of setAttribute */\n  type?: number;\n  animationState?: {\n    step?: IStep;\n    isFirstFrameOfStep?: boolean;\n    /** ratio of animation */\n    ratio?: number;\n    /** is animation end? */\n    end?: boolean;\n  };\n  skipUpdateCallback?: boolean;\n};\n\nexport type IGraphicAnimateParams = {\n  slience?: boolean;\n  id?: number | string;\n  timeline?: ITimeline;\n  onStart?: () => void;\n  onFrame?: (step: IStep, ratio: number) => void;\n  onEnd?: () => void;\n  onRemove?: () => void;\n  interpolate?: (key: string, ratio: number, from: any, to: any, nextAttributes: any) => boolean;\n};\n\nexport interface IGraphic<T extends Partial<IGraphicAttribute> = Partial<IGraphicAttribute>>\n  extends INode,\n    IAnimateTarget {\n  type?: GraphicType;\n  numberType?: number;\n  stage?: IStage;\n  layer?: ILayer;\n  shadowRoot?: IShadowRoot;\n  glyphHost?: IGraphic<IGlyphGraphicAttribute>;\n  backgroundImg?: boolean;\n  attachedThemeGraphic?: IGraphic<any>;\n  /**\n   * 保存语法上下文\n   */\n  context?: Record<string, any>;\n  bindDom?: Map<\n    string | HTMLElement,\n    { container: HTMLElement | string; dom: HTMLElement | any; wrapGroup: HTMLDivElement | any; root?: any }\n  >;\n\n  valid: boolean;\n  parent: IGroup | null;\n  isContainer?: boolean;\n  // 是否是3d模式（是否应用3d视角）\n  in3dMode?: boolean;\n\n  // 不考虑transform的宽高，特殊情况下会使用到\n  widthWithoutTransform?: number;\n  heightWithoutTransform?: number;\n\n  // 上次更新的stamp\n  stamp?: number;\n  animationBackUps?: {\n    from: Record<string, any>;\n    to: Record<string, any>;\n  };\n\n  attribute: Partial<T>;\n\n  /** 用于实现morph动画场景，转换成bezier曲线渲染 */\n  pathProxy?: ICustomPath2D | ((attrs: T) => ICustomPath2D);\n  incremental?: number;\n  incrementalAt?: number;\n\n  /** 记录state对应的图形属性 */\n  states?: Record<string, Partial<T>>;\n  normalAttrs?: Partial<T>;\n  stateProxy?: (stateName: string, targetStates?: string[]) => Partial<T>;\n  findFace?: () => IFace3d;\n  toggleState: (stateName: string, hasAnimation?: boolean) => void;\n  removeState: (stateName: string | string[], hasAnimation?: boolean) => void;\n  clearStates: (hasAnimation?: boolean) => void;\n  useStates: (states: string[], hasAnimation?: boolean) => void;\n  addState: (stateName: string, keepCurrentStates?: boolean, hasAnimation?: boolean) => void;\n  hasState: (stateName?: string) => boolean;\n  getState: (stateName: string) => Partial<T>;\n  onBeforeAttributeUpdate?: (\n    val: any,\n    attributes: Partial<T>,\n    key: null | string | string[],\n    context?: ISetAttributeContext\n  ) => T | undefined;\n  applyStateAttrs: (attrs: Partial<T>, stateNames: string[], hasAnimation?: boolean, isClear?: boolean) => void;\n  updateNormalAttrs: (stateAttrs: Partial<T>) => void;\n\n  // get\n  readonly AABBBounds: IAABBBounds; // 用于获取当前节点的AABB包围盒\n  readonly OBBBounds: IOBBBounds; // 获取OBB包围盒，旋转防重叠需要用\n  readonly globalAABBBounds: IAABBBounds; // 全局AABB包围盒\n  readonly transMatrix: IMatrix; // 变换矩阵，动态计算\n  readonly globalTransMatrix: IMatrix; // 变换矩阵，动态计算\n\n  getOffsetXY: (attr?: ITransform) => IPoint;\n\n  // function\n  containsPoint: (x: number, y: number, mode?: IContainPointMode, picker?: IPickerService) => boolean;\n\n  setMode: (mode: '3d' | '2d') => void;\n  isValid: () => boolean;\n\n  getClipPath: () => ISymbolClass | null;\n\n  // TODO: transform API\n  // 基于当前transform的变换，普通用户尽量别用，拿捏不住的~\n  translate: (x: number, y: number) => this;\n  translateTo: (x: number, y: number) => this;\n  scale: (scaleX: number, scaleY: number, scaleCenter?: IPointLike) => this;\n  scaleTo: (scaleX: number, scaleY: number) => this;\n  rotate: (angle: number, rotateCenter?: IPointLike) => this;\n  rotateTo: (angle: number) => this;\n  skewTo: (b: number, c: number) => this;\n  addUpdateBoundTag: () => void;\n  addUpdateShapeAndBoundsTag: () => void;\n  addUpdateLayoutTag: () => void;\n\n  update: (d?: { bounds: boolean; trans: boolean }) => void;\n\n  // animate\n  animate?: (params?: IGraphicAnimateParams) => IAnimate;\n\n  // 语法糖，可有可无，有的为了首屏性能考虑做成get方法，有的由外界直接托管，内部不赋值\n  name?: string;\n\n  // 供render处理shape缓存tag\n  shouldUpdateShape: () => boolean;\n  clearUpdateShapeTag: () => void;\n\n  // // 供render缓存shape\n  // cacheShape?: ICustomPath2D;\n  // // 线段使用的path2D\n  // cacheLine?: ISegPath2D | ISegPath2D[];\n  // // 面积图使用的path2D\n  // cacheArea?: IAreaCacheItem | IAreaCacheItem[];\n\n  setAttributes: (params: Partial<T>, forceUpdateTag?: boolean, context?: ISetAttributeContext) => void;\n\n  initAttributes: (params: Partial<T>) => void;\n\n  setAttribute: (key: string, value: any, forceUpdateTag?: boolean, context?: ISetAttributeContext) => void;\n\n  setStage: (stage?: IStage, layer?: ILayer) => void;\n  onSetStage: (cb: (g: IGraphic, stage: IStage) => void) => void;\n\n  shouldUpdateAABBBounds: () => boolean;\n  shouldSelfChangeUpdateAABBBounds: () => boolean;\n  shouldUpdateGlobalMatrix: () => boolean;\n\n  addUpdatePositionTag: () => void;\n  addUpdateGlobalPositionTag: () => void;\n\n  attachShadow: () => IShadowRoot;\n  detachShadow: () => void;\n\n  toJson: () => IGraphicJson;\n\n  /** 创建pathProxy */\n  createPathProxy: (path?: string) => void;\n  /** 将图形转换成CustomPath2D */\n  toCustomPath?: () => ICustomPath2D;\n\n  resources?: Map<\n    string | HTMLImageElement | HTMLCanvasElement | IBackgroundConfig,\n    { state: 'init' | 'loading' | 'success' | 'fail'; data?: HTMLImageElement | HTMLCanvasElement }\n  >;\n  imageLoadSuccess: (url: string, data: HTMLImageElement) => void;\n  imageLoadFail: (url: string) => void;\n\n  clone: () => IGraphic;\n  stopAnimates: (stopChildren?: boolean) => void;\n  getNoWorkAnimateAttr: () => Record<string, number>;\n  getGraphicTheme: () => T;\n\n  getAttributes: (final?: boolean) => Partial<T>;\n\n  pauseAnimation?: (deep?: boolean) => void;\n  resumeAnimation?: (deep?: boolean) => void;\n  stopAnimation?: (deep?: boolean) => void;\n  reApplyAnimationState?: (state: string, deep?: boolean) => this;\n}\n\nexport interface IRoot extends IGraphic {\n  pick: (x: number, y: number) => IGraphic;\n}\n\n/**\n * 动画配置\n */\nexport type IAnimateConfig = {\n  duration?: number;\n  easing?: EasingType;\n};\n\nexport type GraphicReleaseStatus = 'released' | 'willRelease';\n"]}