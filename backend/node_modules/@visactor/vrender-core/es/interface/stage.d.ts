import type { INode } from './node-tree';
import type { ILayer, LayerMode } from './layer';
import type { IColor } from './color';
import type { IAABBBounds, IBounds, IBoundsLike, IMatrix } from '@visactor/vutils';
import type { ICamera } from './camera';
import type { vec3 } from './matrix';
import type { IDirectionLight } from './light';
import type { ISyncHook } from './sync-hook';
import type { IDrawContext, IRenderService, IRenderServiceDrawParams } from './render';
import type { ITicker, ITimeline } from './animation';
import type { IPickerService, PickResult } from './picker';
import type { IPlugin, IPluginService } from './plugin';
import type { IWindow } from './window';
import type { ILayerService } from './core';
import type { IFullThemeSpec } from './graphic/theme';
import type { IGraphicService } from './graphic-service';
export type IExportType = 'canvas' | 'imageData';
export type IStageCreateContext = {
    appName?: 'vchart' | 'vgrammar' | 'vtable' | string;
};
export interface IStageParams {
    viewBox: IBoundsLike;
    width: number;
    height: number;
    dpr: number;
    background: string | IColor;
    canvas: string | HTMLCanvasElement;
    container: string | HTMLElement;
    canvasControled: boolean;
    title: string;
    autoRender: boolean;
    autoRefresh: boolean;
    enableLayout: boolean;
    disableDirtyBounds: boolean;
    interactiveLayer: boolean;
    enableHtmlAttribute: string | boolean | HTMLElement;
    ReactDOM: any;
    enableScroll: boolean;
    poptip: boolean;
    beforeRender: (stage: IStage) => void;
    afterRender: (stage: IStage) => void;
    afterClearScreen: (drawParams: any) => void;
    afterClearRect: (drawParams: any) => void;
    renderStyle?: string;
    ticker?: ITicker;
    pluginList?: string[];
    optimize?: IOptimizeType;
    event?: EventConfig;
    supportsTouchEvents?: boolean;
    supportsPointerEvents?: boolean;
    context?: IStageCreateContext;
    rafId?: number;
}
export type EventConfig = {
    autoPreventDefault?: boolean;
    clickInterval?: number;
    [key: string]: any;
};
export type IOptimizeType = {
    skipRenderWithOutRange?: boolean;
    disableCheckGraphicWidthOutRange?: boolean;
    tickRenderMode?: 'effect' | 'performance';
};
export interface IOption3D {
    enableView3dTransform?: boolean;
    alpha?: number;
    beta?: number;
    gama?: number;
    center?: {
        x?: number;
        y?: number;
        z?: number;
        dx?: number;
        dy?: number;
        dz?: number;
    };
    fieldRatio?: number;
    fieldDepth?: number;
    light?: {
        dir?: vec3;
        color?: string;
        ambient?: number;
    };
    camera?: any;
}
export interface IStage extends INode {
    stage?: IStage;
    parent: IStage | null;
    x: number;
    y: number;
    params: Partial<IStageParams>;
    window: IWindow;
    width: number;
    height: number;
    viewWidth: number;
    viewHeight: number;
    defaultLayer: ILayer;
    dirtyBounds: IBounds | null;
    autoRender: boolean;
    renderCount: number;
    hooks: {
        beforeRender: ISyncHook<[IStage]>;
        afterRender: ISyncHook<[IStage]>;
        afterClearScreen: ISyncHook<[IRenderServiceDrawParams]>;
        afterClearRect: ISyncHook<[IRenderServiceDrawParams]>;
    };
    option3d?: IOption3D;
    set3dOptions: (options: IOption3D) => void;
    light?: IDirectionLight;
    camera?: ICamera;
    dpr: number;
    viewBox: IBoundsLike;
    background: string | IColor;
    ticker: ITicker;
    increaseAutoRender: boolean;
    readonly renderService: IRenderService;
    readonly graphicService: IGraphicService;
    getPickerService: () => IPickerService;
    readonly pluginService: IPluginService;
    readonly layerService: ILayerService;
    createLayer: (canvasId?: string, layerMode?: LayerMode) => ILayer;
    getLayer: (name: string) => ILayer;
    sortLayer: (cb: (layer1: ILayer, layer2: ILayer) => number) => void;
    removeLayer: (layerId: number) => ILayer | false;
    getTimeline: () => ITimeline;
    render: (layers?: ILayer[], params?: Partial<IDrawContext>) => void;
    renderNextFrame: (layers?: ILayer[], force?: boolean) => void;
    tryInitInteractiveLayer: () => void;
    resize: (w: number, h: number, rerender?: boolean) => void;
    resizeWindow: (w: number, h: number, rerender?: boolean) => void;
    resizeView: (w: number, h: number, rerender?: boolean) => void;
    setViewBox: ((viewBox: IBoundsLike, rerender: boolean) => void) | ((x: number, y: number, w: number, h: number, rerender: boolean) => void) | ((x: number | IBoundsLike, y: number | boolean, w?: number, h?: number, rerender?: boolean) => void);
    setDpr: (dpr: number, rerender?: boolean) => void;
    setOrigin: (x: number, y: number) => void;
    export: (type: IExportType) => HTMLCanvasElement | ImageData;
    pick: (x: number, y: number) => PickResult | false;
    startAnimate: (t: number) => void;
    setToFrame: (t: number) => void;
    dirty: (b: IBounds, matrix?: IMatrix) => void;
    renderTo: (window: IWindow, params: {
        x: number;
        y: number;
        width: number;
        height: number;
    }) => void;
    renderToNewWindow: (fullImage?: boolean) => IWindow;
    toCanvas: (fullImage?: boolean, viewBox?: IAABBBounds) => HTMLCanvasElement | null;
    setBeforeRender: (cb: (stage: IStage) => void) => void;
    removeBeforeRender: (cb: (stage: IStage) => void) => void;
    setAfterRender: (cb: (stage: IStage) => void) => void;
    removeAfterRender: (cb: (stage: IStage) => void) => void;
    afterNextRender: (cb: (stage: IStage) => void) => void;
    enableAutoRender: () => void;
    disableAutoRender: () => void;
    enableIncrementalAutoRender: () => void;
    disableIncrementalAutoRender: () => void;
    enableDirtyBounds: () => void;
    disableDirtyBounds: () => void;
    enableView3dTransform: () => void;
    disableView3dTranform: () => void;
    getPluginsByName: (name: string) => IPlugin[];
    clearViewBox: (color?: string) => void;
    release: () => void;
    setStage: (stage?: IStage) => void;
    pauseRender: (sk?: number) => void;
    resumeRender: () => void;
    setCursor: (mode?: string) => void;
    getTheme: () => IFullThemeSpec;
    eventPointTransform: (e: PointerEvent | WheelEvent | TouchEvent) => {
        x: number;
        y: number;
    };
    pauseTriggerEvent: () => void;
    resumeTriggerEvent: () => void;
    pauseAnimation?: (deep?: boolean) => void;
    resumeAnimation?: (deep?: boolean) => void;
    stopAnimation?: (deep?: boolean) => void;
    reApplyAnimationState?: (state: string, deep?: boolean) => this;
}
export declare function combineStage(srages: IStage[], params: {
    canvas: string | HTMLCanvasElement;
}): IStage;
