{"version":3,"sources":["../src/interface/render.ts"],"names":[],"mappings":"","file":"render.js","sourcesContent":["import type { IAABBBounds, IBounds, IMatrix, IMatrixLike } from '@visactor/vutils';\nimport type { IColor } from './color';\nimport type { IContext2d } from './context';\nimport type { IGraphic, IGraphicAttribute } from './graphic';\nimport type { IMarkAttribute, IThemeAttribute } from './graphic/creator';\nimport type { IFullThemeSpec } from './graphic/theme';\nimport type { ILayer } from './layer';\nimport type { IStage } from './stage';\nimport type { IGroup } from './graphic/group';\nimport type { MaybePromise } from './common';\nimport type { ISyncHook } from './sync-hook';\n\n// 用于绘制的参数，提供context\n// TODO: 考虑是否可以隐藏上下文类型\nexport interface IRenderServiceDrawParams {\n  context?: IContext2d;\n\n  // 绘制的区域以及是否需要清屏\n  clear?: string | IColor | boolean;\n  viewBox: IBounds;\n  transMatrix?: IMatrixLike;\n  stage: IStage;\n  layer: ILayer;\n  renderService: IRenderService;\n  updateBounds: boolean;\n  renderStyle?: string;\n}\n\nexport interface IRenderService {\n  dirtyBounds: IBounds;\n  renderTreeRoots: IGraphic[]; // 此次render的数组\n  renderLists: IGraphic[];\n  drawParams: IRenderServiceDrawParams;\n  drawContribution: IDrawContribution;\n\n  prepare: (updateBounds: boolean) => void;\n  prepareRenderList: () => void;\n  beforeDraw: (params: IRenderServiceDrawParams) => void;\n  draw: (params: IRenderServiceDrawParams) => void;\n  afterDraw: (params: IRenderServiceDrawParams) => void;\n  render: (groups: IGroup[], params: IRenderServiceDrawParams) => MaybePromise<void>;\n  reInit: () => void;\n}\n\nexport interface IDrawContext extends IRenderServiceDrawParams {\n  startAtId?: number;\n  break?: boolean;\n  restartIncremental?: boolean;\n  // multi图元开始的位置\n  multiGraphicOptions?: {\n    startAtIdx: number;\n    length: number;\n  };\n  in3dInterceptor?: boolean;\n  drawContribution?: IDrawContribution;\n  // hack内容\n  hack_pieFace?: 'inside' | 'bottom' | 'top' | 'outside';\n  // group是否有旋转，每一个renderGroup都会更新，用于在renderItem的时候给子节点使用\n  isGroupScroll?: boolean;\n}\n\nexport interface IDrawContribution {\n  hooks?: {\n    completeDraw: ISyncHook<[]>;\n  };\n  dirtyBounds?: IAABBBounds;\n  backupDirtyBounds?: IAABBBounds;\n  rendering?: boolean;\n  currentRenderMap: Map<number, IGraphicRender>;\n  defaultRenderMap: Map<number, IGraphicRender>;\n  styleRenderMap: Map<string, Map<number, IGraphicRender>>;\n  draw: (renderService: IRenderService, drawParams: IDrawContext) => MaybePromise<void>;\n  afterDraw?: (renderService: IRenderService, drawParams: IDrawContext) => MaybePromise<void>;\n  getRenderContribution: (graphic: IGraphic) => IGraphicRender | null;\n  renderGroup: (group: IGroup, drawContext: IDrawContext, matrix: IMatrixLike, skipSort?: boolean) => void;\n  renderItem: (graphic: IGraphic, drawContext: IDrawContext, params?: IGraphicRenderDrawParams) => void;\n  reInit: () => void;\n}\n\nexport interface IGraphicRenderDrawParams {\n  beforeDrawCb?: () => void;\n  afterDrawCb?: () => void;\n  drawingCb?: () => void;\n  skipDraw?: boolean;\n  theme?: IFullThemeSpec;\n  // TODO 这里是为了性能优化，之前使用匿名函数的方式闭包等逻辑会影响性能，现在直接将函数显示定义，将参数传入提升性能，就是牺牲了代码可读性\n  // 用于在group中进行递归渲染的参数\n  renderInGroupParams?: {\n    skipSort?: boolean;\n    nextM?: IMatrixLike;\n  };\n  // 用于在group中进行递归渲染的函数\n  renderInGroup?: (skipSort: boolean, group: IGroup, drawContext: IDrawContext, nextM: IMatrixLike) => void;\n}\n\nexport interface IGraphicRender {\n  type: string; // 图元类型\n  numberType: number;\n  style?: string;\n  z?: number;\n  draw: (\n    graphic: IGraphic,\n    renderService: IRenderService,\n    drawContext: IDrawContext,\n    params?: IGraphicRenderDrawParams\n  ) => void;\n  drawShape?: (\n    graphic: IGraphic,\n    ctx: IContext2d,\n    x: number,\n    y: number,\n    drawContext: IDrawContext,\n    params?: IGraphicRenderDrawParams,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) => void;\n\n  reInit: () => void;\n}\n\nexport interface IBeforeRenderConstribution {\n  apply: (renderService: IRenderService) => MaybePromise<void>;\n}\n\nexport interface IRenderSelector {\n  selector: (graphic: IGraphic) => IGraphicRender | null;\n}\n\nexport interface IDrawItemInterceptorContribution {\n  order: number;\n  beforeDrawItem?: (\n    graphic: IGraphic,\n    renderService: IRenderService,\n    drawContext: IDrawContext,\n    drawContribution: IDrawContribution,\n    params?: IGraphicRenderDrawParams\n  ) => boolean;\n  afterDrawItem?: (\n    graphic: IGraphic,\n    renderService: IRenderService,\n    drawContext: IDrawContext,\n    drawContribution: IDrawContribution,\n    params?: IGraphicRenderDrawParams\n  ) => boolean;\n}\n"]}