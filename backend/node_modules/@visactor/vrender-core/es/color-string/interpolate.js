import { ColorStore, ColorType } from "./store";

import { isArray, isNumber } from "@visactor/vutils";

function colorArrayToString(color, alphaChannel = !1) {
    return Array.isArray(color) && isNumber(color[0]) ? alphaChannel ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})` : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})` : color;
}

export function interpolateColor(from, to, ratio, alphaChannel, cb) {
    if (Array.isArray(from) && !isNumber(from[0]) || Array.isArray(to) && !isNumber(to[0])) {
        return new Array(4).fill(0).map(((_, index) => {
            var _a, _b;
            return _interpolateColor(isArray(from) ? null !== (_a = from[index]) && void 0 !== _a ? _a : from[0] : from, isArray(to) ? null !== (_b = to[index]) && void 0 !== _b ? _b : to[0] : to, ratio, alphaChannel);
        }));
    }
    return _interpolateColor(from, to, ratio, alphaChannel, cb);
}

export function _interpolateColor(from, to, ratio, alphaChannel, cb) {
    if (!from || !to) return from && colorArrayToString(from) || to && colorArrayToString(to) || !1;
    let fromArray, toArray, fromGradient = !1, toGradient = !1;
    if (Array.isArray(from) ? fromArray = from : "string" == typeof from ? fromArray = ColorStore.Get(from, ColorType.Color255) : fromGradient = !0, 
    Array.isArray(to) ? toArray = to : "string" == typeof to ? toArray = ColorStore.Get(to, ColorType.Color255) : toGradient = !0, 
    fromGradient !== toGradient) {
        const gradient = fromGradient ? from : to, pure = fromGradient ? to : from, gradientFromPure = Object.assign(Object.assign({}, gradient), {
            stops: gradient.stops.map((v => Object.assign(Object.assign({}, v), {
                color: colorArrayToString(pure)
            })))
        });
        return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
    }
    if (fromGradient) {
        if (from.gradient === to.gradient) {
            const fc = from, tc = to, fromStops = fc.stops, toStops = tc.stops;
            if (fromStops.length !== toStops.length) return !1;
            if ("linear" === fc.gradient) return interpolateGradientLinearColor(fc, tc, ratio);
            if ("radial" === fc.gradient) return interpolateGradientRadialColor(fc, tc, ratio);
            if ("conical" === fc.gradient) return interpolateGradientConicalColor(fc, tc, ratio);
        }
        return !1;
    }
    cb && cb(fromArray, toArray);
    return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);
}

export function interpolateGradientLinearColor(fc, tc, ratio) {
    const fStops = fc.stops, tStops = tc.stops;
    return {
        gradient: "linear",
        x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
        x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
        y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
        y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
        stops: new Array(fStops.length).fill(0).map(((_, i) => ({
            color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
            offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        })))
    };
}

export function interpolateGradientRadialColor(fc, tc, ratio) {
    const fStops = fc.stops, tStops = tc.stops;
    return {
        gradient: "radial",
        x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
        x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
        y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
        y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
        r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
        r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
        stops: new Array(fStops.length).fill(0).map(((_, i) => ({
            color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
            offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        })))
    };
}

export function interpolateGradientConicalColor(fc, tc, ratio) {
    const fStops = fc.stops, tStops = tc.stops;
    return {
        gradient: "conical",
        startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
        endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
        x: fc.x + (tc.x - fc.x) * ratio,
        y: fc.y + (tc.y - fc.y) * ratio,
        stops: new Array(fStops.length).fill(0).map(((_, i) => ({
            color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
            offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
        })))
    };
}

export function interpolatePureColorArray(from, to, ratio) {
    return [ from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio ];
}

export function interpolatePureColorArrayToStr(from, to, ratio) {
    return `rgba(${from[0] + (to[0] - from[0]) * ratio},${from[1] + (to[1] - from[1]) * ratio},${from[2] + (to[2] - from[2]) * ratio},${from[3] + (to[3] - from[3]) * ratio})`;
}

const _fromColorRGB = [ 0, 0, 0, 0 ], _toColorRGB = [ 0, 0, 0, 0 ];

export function colorStringInterpolationToStr(fromColor, toColor, ratio) {
    return ColorStore.Get(fromColor, ColorType.Color255, _fromColorRGB), ColorStore.Get(toColor, ColorType.Color255, _toColorRGB), 
    `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
}
//# sourceMappingURL=interpolate.js.map