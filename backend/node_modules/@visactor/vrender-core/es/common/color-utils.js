import { pi, pi2 } from "@visactor/vutils";

const parse = function() {
    const tokens = {
        linearGradient: /^(linear\-gradient)/i,
        radialGradient: /^(radial\-gradient)/i,
        conicGradient: /^(conic\-gradient)/i,
        sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
        extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
        positionKeywords: /^(left|center|right|top|bottom)/i,
        pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
        percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
        emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
        angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
        fromAngleValue: /^from\s*(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
        startCall: /^\(/,
        endCall: /^\)/,
        comma: /^,/,
        hexColor: /(^\#[0-9a-fA-F]+)/,
        literalColor: /^([a-zA-Z]+)/,
        rgbColor: /^(rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))/i,
        rgbaColor: /^(rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*((\d\.\d+)|\d{1,3})\))/i,
        number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
    };
    let input = "";
    function error(msg) {
        const err = new Error(input + ": " + msg);
        throw err.source = input, err;
    }
    function getAST() {
        const ast = matchListing(matchDefinition);
        return input.length > 0 && error("Invalid input not EOF"), ast;
    }
    function matchDefinition() {
        return matchGradient("linear", tokens.linearGradient, matchLinearOrientation) || matchGradient("radial", tokens.radialGradient, matchListRadialOrientations) || matchGradient("conic", tokens.conicGradient, matchConicalOrientation);
    }
    function matchGradient(gradientType, pattern, orientationMatcher) {
        return function(pattern, callback) {
            const captures = scan(pattern);
            if (captures) {
                scan(tokens.startCall) || error("Missing (");
                const result = callback(captures);
                return scan(tokens.endCall) || error("Missing )"), result;
            }
        }(pattern, (function(captures) {
            const orientation = orientationMatcher();
            return orientation && (scan(tokens.comma) || error("Missing comma before color stops")), 
            {
                type: gradientType,
                orientation: orientation,
                colorStops: matchListing(matchColorStop)
            };
        }));
    }
    function matchLinearOrientation() {
        return match("directional", tokens.sideOrCorner, 1) || match("angular", tokens.angleValue, 1);
    }
    function matchConicalOrientation() {
        return match("angular", tokens.fromAngleValue, 1);
    }
    function matchListRadialOrientations() {
        let radialOrientations, lookaheadCache, radialOrientation = matchRadialOrientation();
        return radialOrientation && (radialOrientations = [], radialOrientations.push(radialOrientation), 
        lookaheadCache = input, scan(tokens.comma) && (radialOrientation = matchRadialOrientation(), 
        radialOrientation ? radialOrientations.push(radialOrientation) : input = lookaheadCache)), 
        radialOrientations;
    }
    function matchRadialOrientation() {
        let radialType = function() {
            const circle = match("shape", /^(circle)/i, 0);
            circle && (circle.style = matchLength() || matchExtentKeyword());
            return circle;
        }() || function() {
            const ellipse = match("shape", /^(ellipse)/i, 0);
            ellipse && (ellipse.style = matchDistance() || matchExtentKeyword());
            return ellipse;
        }();
        if (radialType) radialType.at = matchAtPosition(); else {
            const extent = matchExtentKeyword();
            if (extent) {
                radialType = extent;
                const positionAt = matchAtPosition();
                positionAt && (radialType.at = positionAt);
            } else {
                const defaultPosition = matchPositioning();
                defaultPosition && (radialType = {
                    type: "default-radial",
                    at: defaultPosition
                });
            }
        }
        return radialType;
    }
    function matchExtentKeyword() {
        return match("extent-keyword", tokens.extentKeywords, 1);
    }
    function matchAtPosition() {
        if (match("position", /^at/, 0)) {
            const positioning = matchPositioning();
            return positioning || error("Missing positioning value"), positioning;
        }
    }
    function matchPositioning() {
        const location = {
            x: matchDistance(),
            y: matchDistance()
        };
        if (location.x || location.y) return {
            type: "position",
            value: location
        };
    }
    function matchListing(matcher) {
        let captures = matcher();
        const result = [];
        if (captures) for (result.push(captures); scan(tokens.comma); ) captures = matcher(), 
        captures ? result.push(captures) : error("One extra comma");
        return result;
    }
    function matchColorStop() {
        const color = match("hex", tokens.hexColor, 1) || match("rgba", tokens.rgbaColor, 1) || match("rgb", tokens.rgbColor, 1) || match("literal", tokens.literalColor, 0);
        return color || error("Expected color definition"), color.length = matchDistance(), 
        color;
    }
    function matchDistance() {
        return match("%", tokens.percentageValue, 1) || match("position-keyword", tokens.positionKeywords, 1) || matchLength();
    }
    function matchLength() {
        return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
    }
    function match(type, pattern, captureIndex) {
        const captures = scan(pattern);
        if (captures) return {
            type: type,
            value: captures[captureIndex]
        };
    }
    function scan(regexp) {
        const blankCaptures = /^[\n\r\t\s]+/.exec(input);
        blankCaptures && consume(blankCaptures[0].length);
        const captures = regexp.exec(input);
        return captures && consume(captures[0].length), captures;
    }
    function consume(size) {
        input = input.substr(size);
    }
    return function(code) {
        return input = code.toString(), getAST();
    };
}();

export class GradientParser {
    static IsGradient(c) {
        return !("string" == typeof c && !c.includes("gradient"));
    }
    static IsGradientStr(c) {
        return "string" == typeof c && c.includes("gradient");
    }
    static Parse(c) {
        if (GradientParser.IsGradientStr(c)) try {
            const datum = parse(c)[0];
            if (datum) {
                if ("linear" === datum.type) return GradientParser.ParseLinear(datum);
                if ("radial" === datum.type) return GradientParser.ParseRadial(datum);
                if ("conic" === datum.type) return GradientParser.ParseConic(datum);
            }
        } catch (err) {
            return c;
        }
        return c;
    }
    static processColorStops(colorStops) {
        if (!colorStops || 0 === colorStops.length) return [];
        if (colorStops.some((item => item.length))) {
            const stops = colorStops.map((item => ({
                color: item.value,
                offset: item.length ? parseFloat(item.length.value) / 100 : -1
            })));
            stops[0].offset < 0 && (stops[0].offset = 0), stops[stops.length - 1].offset < 0 && (stops[stops.length - 1].offset = 1);
            for (let i = 1; i < stops.length - 1; i++) if (stops[i].offset < 0) {
                const prevWithOffsetIdx = i - 1;
                let nextWithOffsetIdx = i + 1;
                for (;nextWithOffsetIdx < stops.length && stops[nextWithOffsetIdx].offset < 0; ) nextWithOffsetIdx++;
                const startOffset = stops[prevWithOffsetIdx].offset, endOffset = stops[nextWithOffsetIdx].offset, unspecCount = nextWithOffsetIdx - prevWithOffsetIdx;
                for (let j = 1; j < unspecCount; j++) stops[prevWithOffsetIdx + j].offset = startOffset + (endOffset - startOffset) * j / unspecCount;
                i = nextWithOffsetIdx - 1;
            }
            return stops;
        }
        return colorStops.map(((item, index) => {
            const offset = colorStops.length > 1 ? index / (colorStops.length - 1) : 0;
            return {
                color: item.value,
                offset: offset
            };
        }));
    }
    static ParseConic(datum) {
        const {orientation: orientation, colorStops: colorStops = []} = datum, halfPi = pi / 2, sa = parseFloat(orientation.value) / 180 * pi - halfPi;
        return {
            gradient: "conical",
            x: .5,
            y: .5,
            startAngle: sa,
            endAngle: sa + pi2,
            stops: GradientParser.processColorStops(colorStops)
        };
    }
    static ParseRadial(datum) {
        const {colorStops: colorStops = []} = datum;
        return {
            gradient: "radial",
            x0: .5,
            y0: .5,
            x1: .5,
            y1: .5,
            r0: 0,
            r1: 1,
            stops: GradientParser.processColorStops(colorStops)
        };
    }
    static ParseLinear(datum) {
        const {orientation: orientation, colorStops: colorStops = []} = datum, halfPi = pi / 2;
        let angle = "angular" === orientation.type ? parseFloat(orientation.value) / 180 * pi : 0;
        for (;angle < 0; ) angle += pi2;
        for (;angle >= pi2; ) angle -= pi2;
        let x0 = 0, y0 = 0, x1 = 0, y1 = 0;
        return angle < halfPi ? (x0 = 0, y0 = 1, x1 = Math.sin(angle), y1 = y0 - Math.cos(angle)) : angle < pi ? (x0 = 0, 
        y0 = 0, x1 = Math.cos(angle - halfPi), y1 = Math.sin(angle - halfPi)) : angle < pi + halfPi ? (x0 = 1, 
        y0 = 0, x1 = x0 - Math.sin(angle - pi), y1 = Math.cos(angle - pi)) : (x0 = 1, x1 = x0 - Math.cos(angle - halfPi - pi), 
        y1 -= Math.sin(angle - halfPi - pi)), {
            gradient: "linear",
            x0: x0,
            y0: y0,
            x1: x1,
            y1: y1,
            stops: GradientParser.processColorStops(colorStops)
        };
    }
}
//# sourceMappingURL=color-utils.js.map