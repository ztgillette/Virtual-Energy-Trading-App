{"version":3,"sources":["../src/common/inversify-lite/interfaces/interfaces.ts"],"names":[],"mappings":"","file":"interfaces.js","sourcesContent":["// @ts-nocheck\n/* eslint-disable */\nimport { FactoryType } from '../utils/factory_type';\n\nexport namespace interfaces {\n  export type DynamicValue<T> = (context: interfaces.Context) => T | Promise<T>;\n  export type ContainerResolution<T> = T | Promise<T> | (T | Promise<T>)[];\n\n  type AsyncCallback<TCallback> = TCallback extends (...args: infer TArgs) => infer TResult\n    ? (...args: TArgs) => Promise<TResult>\n    : never;\n\n  export type BindingScope = 'Singleton' | 'Transient' | 'Request';\n\n  export type BindingType =\n    | 'ConstantValue'\n    | 'Constructor'\n    | 'DynamicValue'\n    | 'Factory'\n    | 'Function'\n    | 'Instance'\n    | 'Invalid'\n    | 'Provider';\n\n  export type TargetType = 'ConstructorArgument' | 'ClassProperty' | 'Variable';\n\n  export interface BindingScopeEnum {\n    Request: interfaces.BindingScope;\n    Singleton: interfaces.BindingScope;\n    Transient: interfaces.BindingScope;\n  }\n\n  export interface BindingTypeEnum {\n    ConstantValue: interfaces.BindingType;\n    Constructor: interfaces.BindingType;\n    DynamicValue: interfaces.BindingType;\n    Factory: interfaces.BindingType;\n    Function: interfaces.BindingType;\n    Instance: interfaces.BindingType;\n    Invalid: interfaces.BindingType;\n    Provider: interfaces.BindingType;\n  }\n\n  export interface TargetTypeEnum {\n    ConstructorArgument: interfaces.TargetType;\n    ClassProperty: interfaces.TargetType;\n    Variable: interfaces.TargetType;\n  }\n\n  export type Newable<T> = new (...args: any[]) => T;\n\n  export type Instance<T> = T & Record<string, () => void>;\n\n  export interface Abstract<T> {\n    prototype: T;\n  }\n\n  export type ServiceIdentifier<T = unknown> = string | symbol | Newable<T> | Abstract<T>;\n\n  export interface Clonable<T> {\n    clone(): T;\n  }\n\n  export type BindingActivation<T = unknown> = (context: interfaces.Context, injectable: T) => T | Promise<T>;\n\n  export type BindingDeactivation<T = unknown> = (injectable: T) => void | Promise<void>;\n\n  export interface Binding<TActivated = unknown> extends Clonable<Binding<TActivated>> {\n    id: number;\n    moduleId: ContainerModuleBase['id'];\n    activated: boolean;\n    serviceIdentifier: ServiceIdentifier<TActivated>;\n    constraint: ConstraintFunction;\n    dynamicValue: DynamicValue<TActivated> | null;\n    scope: BindingScope;\n    type: BindingType;\n    implementationType: Newable<TActivated> | TActivated | null;\n    factory: FactoryCreator<unknown> | null;\n    provider: ProviderCreator<unknown> | null;\n    onActivation: BindingActivation<TActivated> | null;\n    onDeactivation: BindingDeactivation<TActivated> | null;\n    cache: null | TActivated | Promise<TActivated>;\n  }\n\n  export type SimpleFactory<T, U extends unknown[] = unknown[]> = (...args: U) => T;\n\n  export type MultiFactory<T, U extends unknown[] = unknown[], V extends unknown[] = unknown[]> = (\n    ...args: U\n  ) => SimpleFactory<T, V>;\n\n  export type Factory<T, U extends unknown[] = unknown[], V extends unknown[] = unknown[]> =\n    | SimpleFactory<T, U>\n    | MultiFactory<T, U, V>;\n\n  export type FactoryCreator<T, U extends unknown[] = unknown[], V extends unknown[] = unknown[]> = (\n    context: Context\n  ) => Factory<T, U, V>;\n\n  export type AutoNamedFactory<T> = SimpleFactory<T, [string]>;\n\n  export type AutoFactory<T> = SimpleFactory<T, []>;\n\n  export type FactoryTypeFunction<T = unknown> = (context: interfaces.Context) => T | Promise<T>;\n\n  export interface FactoryDetails {\n    factoryType: FactoryType;\n    factory: FactoryTypeFunction | null;\n  }\n\n  export type Provider<T> = (...args: any[]) => ((...args: any[]) => Promise<T>) | Promise<T>;\n\n  export type ProviderCreator<T> = (context: Context) => Provider<T>;\n\n  export interface NextArgs<T = unknown> {\n    avoidConstraints: boolean;\n    contextInterceptor: (contexts: Context) => Context;\n    isMultiInject: boolean;\n    targetType: TargetType;\n    serviceIdentifier: interfaces.ServiceIdentifier<T>;\n    key?: string | number | symbol | undefined;\n    value?: unknown;\n  }\n\n  export type Next = (args: NextArgs) => unknown | unknown[];\n\n  export type Middleware = (next: Next) => Next;\n\n  export type ContextInterceptor = (context: interfaces.Context) => interfaces.Context;\n\n  export interface Context {\n    id: number;\n    container: Container;\n    plan: Plan;\n    currentRequest: Request;\n    addPlan(plan: Plan): void;\n    setCurrentRequest(request: Request): void;\n  }\n\n  export type MetadataOrMetadataArray = Metadata | Metadata[];\n\n  export interface Metadata<TValue = unknown> {\n    key: string | number | symbol;\n    value: TValue;\n  }\n\n  export interface Plan {\n    parentContext: Context;\n    rootRequest: Request;\n  }\n\n  export interface QueryableString {\n    // startsWith(searchString: string): boolean;\n    // endsWith(searchString: string): boolean;\n    contains(searchString: string): boolean;\n    equals(compareString: string): boolean;\n    value(): string;\n  }\n\n  export type ResolveRequestHandler = (request: interfaces.Request) => unknown;\n\n  export type RequestScope = Map<unknown, unknown>;\n\n  export interface Request {\n    id: number;\n    serviceIdentifier: ServiceIdentifier;\n    parentContext: Context;\n    parentRequest: Request | null;\n    childRequests: Request[];\n    target: Target;\n    bindings: Binding<unknown>[];\n    requestScope: RequestScope | null;\n    addChildRequest(\n      serviceIdentifier: ServiceIdentifier,\n      bindings: Binding<unknown> | Binding<unknown>[],\n      target: Target\n    ): Request;\n  }\n\n  export interface Target {\n    id: number;\n    serviceIdentifier: ServiceIdentifier;\n    type: TargetType;\n    name: QueryableString;\n    identifier: string | symbol;\n    metadata: Metadata[];\n    getNamedTag(): interfaces.Metadata<string> | null;\n    getCustomTags(): interfaces.Metadata[] | null;\n    hasTag(key: string | number | symbol): boolean;\n    isArray(): boolean;\n    matchesArray(name: interfaces.ServiceIdentifier): boolean;\n    isNamed(): boolean;\n    isTagged(): boolean;\n    isOptional(): boolean;\n    matchesNamedTag(name: string): boolean;\n    matchesTag(key: string | number | symbol): (value: unknown) => boolean;\n  }\n\n  export interface ContainerOptions {\n    autoBindInjectable?: boolean;\n    defaultScope?: BindingScope | undefined;\n    skipBaseClassChecks?: boolean;\n  }\n\n  export interface Container {\n    id: number;\n    parent: Container | null;\n    options: ContainerOptions;\n    bind<T>(serviceIdentifier: ServiceIdentifier<T>): BindingToSyntax<T>;\n    rebind<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): interfaces.BindingToSyntax<T>;\n    // rebindAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): Promise<interfaces.BindingToSyntax<T>>;\n    unbind(serviceIdentifier: ServiceIdentifier): void;\n    // unbindAsync(serviceIdentifier: interfaces.ServiceIdentifier): Promise<void>;\n    unbindAll(): void;\n    // unbindAllAsync(): Promise<void>;\n    isBound(serviceIdentifier: ServiceIdentifier): boolean;\n    isCurrentBound<T>(serviceIdentifier: ServiceIdentifier<T>): boolean;\n    isBoundNamed(serviceIdentifier: ServiceIdentifier, named: string | number | symbol): boolean;\n    isBoundTagged(serviceIdentifier: ServiceIdentifier, key: string | number | symbol, value: unknown): boolean;\n    get<T>(serviceIdentifier: ServiceIdentifier<T>): T;\n    getNamed<T>(serviceIdentifier: ServiceIdentifier<T>, named: string | number | symbol): T;\n    getTagged<T>(serviceIdentifier: ServiceIdentifier<T>, key: string | number | symbol, value: unknown): T;\n    getAll<T>(serviceIdentifier: ServiceIdentifier<T>): T[];\n    getAllTagged<T>(serviceIdentifier: ServiceIdentifier<T>, key: string | number | symbol, value: unknown): T[];\n    getAllNamed<T>(serviceIdentifier: ServiceIdentifier<T>, named: string | number | symbol): T[];\n    getAsync<T>(serviceIdentifier: ServiceIdentifier<T>): Promise<T>;\n    // getNamedAsync<T>(serviceIdentifier: ServiceIdentifier<T>, named: string | number | symbol): Promise<T>;\n    // getTaggedAsync<T>(\n    //   serviceIdentifier: ServiceIdentifier<T>,\n    //   key: string | number | symbol,\n    //   value: unknown\n    // ): Promise<T>;\n    // getAllAsync<T>(serviceIdentifier: ServiceIdentifier<T>): Promise<T[]>;\n    // getAllTaggedAsync<T>(\n    //   serviceIdentifier: ServiceIdentifier<T>,\n    //   key: string | number | symbol,\n    //   value: unknown\n    // ): Promise<T[]>;\n    // getAllNamedAsync<T>(serviceIdentifier: ServiceIdentifier<T>, named: string | number | symbol): Promise<T[]>;\n    // onActivation<T>(serviceIdentifier: ServiceIdentifier<T>, onActivation: BindingActivation<T>): void;\n    // onDeactivation<T>(serviceIdentifier: ServiceIdentifier<T>, onDeactivation: BindingDeactivation<T>): void;\n    resolve<T>(constructorFunction: interfaces.Newable<T>): T;\n    load(...modules: ContainerModule[]): void;\n    // loadAsync(...modules: AsyncContainerModule[]): Promise<void>;\n    unload(...modules: ContainerModuleBase[]): void;\n    // unloadAsync(...modules: ContainerModuleBase[]): Promise<void>;\n    applyCustomMetadataReader(metadataReader: MetadataReader): void;\n    // applyMiddleware(...middleware: Middleware[]): void;\n    // snapshot(): void;\n    // restore(): void;\n    // createChild(): Container;\n  }\n\n  export type Bind = <T = unknown>(serviceIdentifier: ServiceIdentifier<T>) => BindingToSyntax<T>;\n\n  export type Rebind = <T = unknown>(serviceIdentifier: ServiceIdentifier<T>) => BindingToSyntax<T>;\n\n  export type Unbind = <T = unknown>(serviceIdentifier: ServiceIdentifier<T>) => void;\n\n  export type UnbindAsync = <T = unknown>(serviceIdentifier: ServiceIdentifier<T>) => Promise<void>;\n\n  export type IsBound = <T = unknown>(serviceIdentifier: ServiceIdentifier<T>) => boolean;\n\n  export interface ContainerModuleBase {\n    id: number;\n  }\n\n  export interface ContainerModule extends ContainerModuleBase {\n    registry: ContainerModuleCallBack;\n  }\n\n  export interface AsyncContainerModule extends ContainerModuleBase {\n    registry: AsyncContainerModuleCallBack;\n  }\n\n  export interface ModuleActivationHandlers {\n    onActivations: Lookup<BindingActivation<unknown>>;\n    onDeactivations: Lookup<BindingDeactivation<unknown>>;\n  }\n\n  // export interface ModuleActivationStore extends Clonable<ModuleActivationStore> {\n  //   addDeactivation(\n  //     moduleId: ContainerModuleBase['id'],\n  //     serviceIdentifier: ServiceIdentifier<unknown>,\n  //     onDeactivation: interfaces.BindingDeactivation<unknown>\n  //   ): void;\n  //   addActivation(\n  //     moduleId: ContainerModuleBase['id'],\n  //     serviceIdentifier: ServiceIdentifier<unknown>,\n  //     onActivation: interfaces.BindingActivation<unknown>\n  //   ): void;\n  //   remove(moduleId: ContainerModuleBase['id']): ModuleActivationHandlers;\n  // }\n\n  export type ContainerModuleCallBack = (\n    bind: interfaces.Bind,\n    unbind: interfaces.Unbind,\n    isBound: interfaces.IsBound,\n    rebind: interfaces.Rebind\n    // unbindAsync: interfaces.UnbindAsync,\n    // onActivation: interfaces.Container['onActivation'],\n    // onDeactivation: interfaces.Container['onDeactivation']\n  ) => void;\n\n  export type AsyncContainerModuleCallBack = AsyncCallback<ContainerModuleCallBack>;\n\n  // export interface ContainerSnapshot {\n  //   bindings: Lookup<Binding<unknown>>;\n  //   activations: Lookup<BindingActivation<unknown>>;\n  //   deactivations: Lookup<BindingDeactivation<unknown>>;\n  //   middleware: Next | null;\n  //   moduleActivationStore: interfaces.ModuleActivationStore;\n  // }\n\n  export interface Lookup<T> extends Clonable<Lookup<T>> {\n    add(serviceIdentifier: ServiceIdentifier, value: T): void;\n    getMap(): Map<interfaces.ServiceIdentifier, T[]>;\n    get(serviceIdentifier: ServiceIdentifier): T[];\n    remove(serviceIdentifier: interfaces.ServiceIdentifier): void;\n    removeByCondition(condition: (item: T) => boolean): T[];\n    removeIntersection(lookup: interfaces.Lookup<T>): void;\n    hasKey(serviceIdentifier: ServiceIdentifier): boolean;\n    clone(): Lookup<T>;\n    traverse(func: (key: interfaces.ServiceIdentifier, value: T[]) => void): void;\n  }\n\n  export interface BindingOnSyntax<T> {\n    // onActivation(fn: (context: Context, injectable: T) => T | Promise<T>): BindingWhenSyntax<T>;\n    // onDeactivation(fn: (injectable: T) => void | Promise<void>): BindingWhenSyntax<T>;\n  }\n\n  export interface BindingWhenSyntax<T> {\n    // when(constraint: (request: Request) => boolean): BindingOnSyntax<T>;\n    whenTargetNamed(name: string | number | symbol): BindingOnSyntax<T>;\n    // whenTargetIsDefault(): BindingOnSyntax<T>;\n    // whenTargetTagged(tag: string | number | symbol, value: unknown): BindingOnSyntax<T>;\n    // whenInjectedInto(parent: NewableFunction | string): BindingOnSyntax<T>;\n    // whenParentNamed(name: string | number | symbol): BindingOnSyntax<T>;\n    // whenParentTagged(tag: string | number | symbol, value: unknown): BindingOnSyntax<T>;\n    // whenAnyAncestorIs(ancestor: NewableFunction | string): BindingOnSyntax<T>;\n    // whenNoAncestorIs(ancestor: NewableFunction | string): BindingOnSyntax<T>;\n    // whenAnyAncestorNamed(name: string | number | symbol): BindingOnSyntax<T>;\n    // whenAnyAncestorTagged(tag: string | number | symbol, value: unknown): BindingOnSyntax<T>;\n    // whenNoAncestorNamed(name: string | number | symbol): BindingOnSyntax<T>;\n    // whenNoAncestorTagged(tag: string | number | symbol, value: unknown): BindingOnSyntax<T>;\n    // whenAnyAncestorMatches(constraint: (request: Request) => boolean): BindingOnSyntax<T>;\n    // whenNoAncestorMatches(constraint: (request: Request) => boolean): BindingOnSyntax<T>;\n  }\n\n  export interface BindingWhenOnSyntax<T> extends BindingWhenSyntax<T>, BindingOnSyntax<T> {}\n\n  export interface BindingInSyntax<T> {\n    inSingletonScope(): BindingWhenOnSyntax<T>;\n    inTransientScope(): BindingWhenOnSyntax<T>;\n    inRequestScope(): BindingWhenOnSyntax<T>;\n  }\n\n  export interface BindingInWhenOnSyntax<T> extends BindingInSyntax<T>, BindingWhenOnSyntax<T> {}\n\n  export interface BindingToSyntax<T> {\n    to(constructor: Newable<T>): BindingInWhenOnSyntax<T>;\n    toSelf(): BindingInWhenOnSyntax<T>;\n    toConstantValue(value: T): BindingWhenOnSyntax<T>;\n    toDynamicValue(func: DynamicValue<T>): BindingInWhenOnSyntax<T>;\n    toConstructor<T2>(constructor: Newable<T2>): BindingWhenOnSyntax<T>;\n    toFactory<T2, T3 extends unknown[] = unknown[], T4 extends unknown[] = unknown[]>(\n      factory: FactoryCreator<T2, T3, T4>\n    ): BindingWhenOnSyntax<T>;\n    toFunction(func: T): BindingWhenOnSyntax<T>;\n    toAutoFactory<T2>(serviceIdentifier: ServiceIdentifier<T2>): BindingWhenOnSyntax<T>;\n    toAutoNamedFactory<T2>(serviceIdentifier: ServiceIdentifier<T2>): BindingWhenOnSyntax<T>;\n    toProvider<T2>(provider: ProviderCreator<T2>): BindingWhenOnSyntax<T>;\n    toService(service: ServiceIdentifier<T>): void;\n  }\n\n  export interface ConstraintFunction {\n    metaData?: Metadata;\n    (request: Request | null): boolean;\n  }\n\n  export interface MetadataReader {\n    getConstructorMetadata(constructorFunc: NewableFunction): ConstructorMetadata;\n    getPropertiesMetadata(constructorFunc: NewableFunction): MetadataMap;\n  }\n\n  export interface MetadataMap {\n    [propertyNameOrArgumentIndex: string | symbol]: Metadata[];\n  }\n\n  export interface ConstructorMetadata {\n    compilerGeneratedMetadata: NewableFunction[] | undefined;\n    userGeneratedMetadata: MetadataMap;\n  }\n}\n"]}