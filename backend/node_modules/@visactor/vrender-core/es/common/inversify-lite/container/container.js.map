{"version":3,"sources":["../src/common/inversify-lite/container/container.ts"],"names":[],"mappings":";;;;;;;;;AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,qBAAqB,CAAC;AAC9C,OAAO,KAAK,UAAU,MAAM,yBAAyB,CAAC;AACtD,OAAO,EAAE,gBAAgB,EAAE,cAAc,EAAE,MAAM,4BAA4B,CAAC;AAC9E,OAAO,KAAK,YAAY,MAAM,4BAA4B,CAAC;AAE3D,OAAO,EAAE,cAAc,EAAE,MAAM,6BAA6B,CAAC;AAC7D,OAAO,EAAE,iBAAiB,EAAE,oBAAoB,EAAE,IAAI,EAAE,MAAM,qBAAqB,CAAC;AACpF,OAAO,EAAE,OAAO,EAAE,MAAM,wBAAwB,CAAC;AACjD,OAAO,EAAE,eAAe,EAAE,MAAM,6BAA6B,CAAC;AAC9D,OAAO,EAAE,SAAS,EAA8B,MAAM,gBAAgB,CAAC;AACvE,OAAO,EAAE,EAAE,EAAE,MAAM,aAAa,CAAC;AACjC,OAAO,EAAE,4BAA4B,EAAE,MAAM,wBAAwB,CAAC;AACtE,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAClC,OAAO,OAAO,MAAM,wBAAwB,CAAC;AAK7C,MAAM,SAAS;IAWb,MAAM,CAAC,KAAK,CACV,UAAgC,EAChC,UAAgC,EAChC,GAAG,UAAkC;QAErC,MAAM,SAAS,GAAG,IAAI,SAAS,EAAE,CAAC;QAClC,MAAM,gBAAgB,GAAqD;YACzE,UAAU;YACV,UAAU;YACV,GAAG,UAAU;SACd,CAAC,GAAG,CAAC,eAAe,CAAC,EAAE,CAAC,oBAAoB,CAAC,eAAe,CAAC,CAAC,CAAC;QAChE,MAAM,iBAAiB,GAAmD,oBAAoB,CAAC,SAAS,CAAC,CAAC;QAE1G,SAAS,cAAc,CACrB,MAAsD,EACtD,WAA2D;YAE3D,MAAM,CAAC,QAAQ,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;gBAC9B,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;oBACtB,WAAW,CAAC,GAAG,CAAC,OAAO,CAAC,iBAAiB,EAAE,OAAO,CAAC,KAAK,EAAE,CAAC,CAAC;gBAC9D,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC;QAED,gBAAgB,CAAC,OAAO,CAAC,uBAAuB,CAAC,EAAE;YACjD,cAAc,CAAC,uBAAuB,EAAE,iBAAiB,CAAC,CAAC;QAC7D,CAAC,CAAC,CAAC;QAEH,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,YAAY,gBAA8C;QACxD,MAAM,OAAO,GAAG,gBAAgB,IAAI,EAAE,CAAC;QACvC,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,GAAG,UAAU,CAAC,mCAAmC,EAAE,CAAC,CAAC;SACtE;QAED,IAAI,OAAO,CAAC,YAAY,KAAK,SAAS,EAAE;YACtC,OAAO,CAAC,YAAY,GAAG,gBAAgB,CAAC,SAAS,CAAC;SACnD;aAAM,IACL,OAAO,CAAC,YAAY,KAAK,gBAAgB,CAAC,SAAS;YACnD,OAAO,CAAC,YAAY,KAAK,gBAAgB,CAAC,SAAS;YACnD,OAAO,CAAC,YAAY,KAAK,gBAAgB,CAAC,OAAO,EACjD;YACA,MAAM,IAAI,KAAK,CAAC,GAAG,UAAU,CAAC,uCAAuC,EAAE,CAAC,CAAC;SAC1E;QAED,IAAI,OAAO,CAAC,kBAAkB,KAAK,SAAS,EAAE;YAC5C,OAAO,CAAC,kBAAkB,GAAG,KAAK,CAAC;SACpC;aAAM,IAAI,OAAO,OAAO,CAAC,kBAAkB,KAAK,SAAS,EAAE;YAC1D,MAAM,IAAI,KAAK,CAAC,GAAG,UAAU,CAAC,8CAA8C,EAAE,CAAC,CAAC;SACjF;QAED,IAAI,OAAO,CAAC,mBAAmB,KAAK,SAAS,EAAE;YAC7C,OAAO,CAAC,mBAAmB,GAAG,KAAK,CAAC;SACrC;aAAM,IAAI,OAAO,OAAO,CAAC,mBAAmB,KAAK,SAAS,EAAE;YAC3D,MAAM,IAAI,KAAK,CAAC,GAAG,UAAU,CAAC,yCAAyC,EAAE,CAAC,CAAC;SAC5E;QAED,IAAI,CAAC,OAAO,GAAG;YACb,kBAAkB,EAAE,OAAO,CAAC,kBAAkB;YAC9C,YAAY,EAAE,OAAO,CAAC,YAAY;YAClC,mBAAmB,EAAE,OAAO,CAAC,mBAAmB;SACjD,CAAC;QAEF,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE,CAAC;QACf,IAAI,CAAC,kBAAkB,GAAG,IAAI,MAAM,EAA+B,CAAC;QAIpE,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,eAAe,GAAG,IAAI,cAAc,EAAE,CAAC;IAE9C,CAAC;IAED,IAAI,CAAC,GAAG,OAAqC;QAC3C,MAAM,UAAU,GAAG,IAAI,CAAC,iCAAiC,EAAE,CAAC;QAE5D,KAAK,MAAM,aAAa,IAAI,OAAO,EAAE;YACnC,MAAM,sBAAsB,GAAG,UAAU,CAAC,aAAa,CAAC,EAAE,CAAC,CAAC;YAE5D,aAAa,CAAC,QAAQ,CACpB,sBAAsB,CAAC,YAA+B,EACtD,sBAAsB,CAAC,cAAc,EACrC,sBAAsB,CAAC,eAAe,EACtC,sBAAsB,CAAC,cAAmC,CAI3D,CAAC;SACH;IACH,CAAC;IAED,MAAM,CAAC,GAAG,OAAyC;QACjD,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;YACvB,MAAM,aAAa,GAAG,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YAC5D,IAAI,CAAC,qBAAqB,CAAC,aAAa,CAAC,CAAC;QAG5C,CAAC,CAAC,CAAC;IACL,CAAC;IAGD,IAAI,CAAI,iBAAkD;QACxD,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,IAAI,gBAAgB,CAAC,SAAS,CAAC;QACtE,MAAM,OAAO,GAAG,IAAI,OAAO,CAAI,iBAAiB,EAAE,KAAK,CAAC,CAAC;QACzD,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,iBAAiB,EAAE,OAA2B,CAAC,CAAC;QAC5E,OAAO,IAAI,eAAe,CAAI,OAAO,CAAC,CAAC;IACzC,CAAC;IAED,MAAM,CAAI,iBAAkD;QAC1D,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;QAC/B,OAAO,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;IACtC,CAAC;IAUD,MAAM,CAAC,iBAA+C;QACpD,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,iBAAiB,CAAC,EAAE;YACrD,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;YAEhE,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;SACtC;QAED,IAAI,CAAC,4BAA4B,CAAC,iBAAiB,CAAC,CAAC;IACvD,CAAC;IAaD,SAAS;QACP,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;YAC/C,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,kBAAkB,GAAG,IAAI,MAAM,EAAoB,CAAC;IAC3D,CAAC;IA6BD,OAAO,CAAC,iBAAwD;QAC9D,IAAI,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;QAC9D,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE;YACzB,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;SAChD;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IAGD,cAAc,CAAI,iBAAkD;QAClE,OAAO,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;IAC3D,CAAC;IAED,YAAY,CAAC,iBAA+C,EAAE,KAA+B;QAC3F,OAAO,IAAI,CAAC,aAAa,CAAC,iBAAiB,EAAE,YAAY,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;IAC9E,CAAC;IAGD,aAAa,CACX,iBAA+C,EAC/C,GAA6B,EAC7B,KAAc;QAEd,IAAI,KAAK,GAAG,KAAK,CAAC;QAGlB,IAAI,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,iBAAiB,CAAC,EAAE;YACrD,MAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;YAChE,MAAM,OAAO,GAAG,iBAAiB,CAAC,IAAI,EAAE,iBAAiB,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;YACvE,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;SACnD;QAGD,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE;YACzB,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,iBAAiB,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;SAClE;QAED,OAAO,KAAK,CAAC;IACf,CAAC;IAED,yBAAyB,CAAC,cAAyC;QACjE,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;IACxC,CAAC;IAKD,GAAG,CAAI,iBAAkD;QAKvD,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,iBAAiB,EAAE,KAAK,CAAC,CAAC;QAO9D,MAAM,IAAI,GAAG,IAAI,CAAC,mBAAmB,CAAI,OAAO,CAAM,CAAC;QAIvD,OAAO,IAAI,CAAC;IACd,CAAC;IAEK,QAAQ,CAAI,iBAAkD;;YAClE,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,iBAAiB,EAAE,KAAK,CAAC,CAAC;YAE9D,OAAO,IAAI,CAAC,IAAI,CAAI,OAAO,CAAmB,CAAC;QACjD,CAAC;KAAA;IAED,SAAS,CAAI,iBAAkD,EAAE,GAA6B,EAAE,KAAc;QAC5G,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,iBAAiB,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QAE1E,OAAO,IAAI,CAAC,mBAAmB,CAAI,OAAO,CAAM,CAAC;IACnD,CAAC;IAYD,QAAQ,CAAI,iBAAkD,EAAE,KAA+B;QAC7F,OAAO,IAAI,CAAC,SAAS,CAAI,iBAAiB,EAAE,YAAY,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;IAC7E,CAAC;IAWD,MAAM,CAAI,iBAAkD;QAC1D,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC;QAEpD,OAAO,IAAI,CAAC,mBAAmB,CAAI,OAAO,CAAQ,CAAC;IACrD,CAAC;IAQD,YAAY,CACV,iBAAkD,EAClD,GAA6B,EAC7B,KAAc;QAEd,MAAM,OAAO,GAAG,IAAI,CAAC,cAAc,CAAC,iBAAiB,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QAEzE,OAAO,IAAI,CAAC,mBAAmB,CAAI,OAAO,CAAQ,CAAC;IACrD,CAAC;IAYD,WAAW,CAAI,iBAAkD,EAAE,KAA+B;QAChG,OAAO,IAAI,CAAC,YAAY,CAAI,iBAAiB,EAAE,YAAY,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;IAChF,CAAC;IASD,OAAO,CAAI,mBAA0C;QACnD,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC;QAClD,IAAI,CAAC,OAAO,EAAE;YACZ,IAAI,CAAC,IAAI,CAAI,mBAAmB,CAAC,CAAC,MAAM,EAAE,CAAC;SAC5C;QACD,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAI,mBAAmB,CAAC,CAAC;QAClD,IAAI,CAAC,OAAO,EAAE;YACZ,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,CAAC;SAClC;QACD,OAAO,QAAQ,CAAC;IAClB,CAAC;IAEO,WAAW,CAAI,WAA4B,EAAE,QAAW;;QAC9D,IAAK,OAAe,CAAC,WAAW,CAAC,YAAY,CAAC,WAAW,EAAE,WAAW,CAAC,EAAE;YACvE,MAAM,IAAI,GAAyB,OAAe,CAAC,WAAW,CAAC,YAAY,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;YACtG,OAAO,MAAA,MAAC,QAAmC,EAAC,IAAI,CAAC,KAAe,CAAC,kDAAI,CAAC;SACvE;IACH,CAAC;IAQO,qBAAqB,CAAC,QAAgB;QAC5C,OAAO,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,QAAQ,KAAK,QAAQ,CAAC,CAAC;IAC7F,CAAC;IAEO,WAAW,CAAI,OAAmB,EAAE,QAAW;QACrD,MAAM,WAAW,GAAoB,MAAM,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,WAAW,CAAC;QACjF,IAAI;YAcF,MAAM,2BAA2B,GAAG,IAAI,CAAC,uDAAuD,CAC9F,OAAO,EACP,QAAQ,EACR,WAAW,CACZ,CAAC;YAEF,IAAI,SAAS,CAAC,2BAA2B,CAAC,EAAE;gBAC1C,OAAO,IAAI,CAAC,wBAAwB,CAAC,2BAA2B,EAAE,WAAW,CAAC,CAAC;aAChF;SACF;QAAC,OAAO,EAAE,EAAE;YACX,IAAI,EAAE,YAAY,KAAK,EAAE;gBACvB,MAAM,IAAI,KAAK,CAAC,UAAU,CAAC,qBAAqB,CAAC,WAAW,CAAC,IAAI,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;aACjF;SACF;IACH,CAAC;IAEa,wBAAwB,CAAC,WAA0B,EAAE,WAA4B;;YAC7F,IAAI;gBACF,MAAM,WAAW,CAAC;aACnB;YAAC,OAAO,EAAE,EAAE;gBACX,IAAI,EAAE,YAAY,KAAK,EAAE;oBACvB,MAAM,IAAI,KAAK,CAAC,UAAU,CAAC,qBAAqB,CAAC,WAAW,CAAC,IAAI,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;iBACjF;aACF;QACH,CAAC;KAAA;IA+BO,iCAAiC;QACvC,MAAM,WAAW,GAAG,CAClB,eAAoD,EACpD,QAA8C,EAC9C,EAAE;YAKA,eACD,CAAC,QAAQ,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACjC,CAAC,CAAC;QAEF,MAAM,eAAe,GACnB,CAAI,QAA8C,EAAE,EAAE,CACtD,CAAC,iBAA+C,EAAE,EAAE;YAClD,MAAM,eAAe,GAAG,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;YACrD,WAAW,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;YACvC,OAAO,eAAqC,CAAC;QAC/C,CAAC,CAAC;QAEJ,MAAM,iBAAiB,GAAG,GAAG,EAAE,CAAC,CAAC,iBAA+C,EAAE,EAAE;YAClF,OAAO,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;QACxC,CAAC,CAAC;QAEF,MAAM,sBAAsB,GAAG,GAAG,EAAE,CAAC,CAAC,iBAA+C,EAAE,EAAE;YACvF,OAAO,IAAW,CAAC;QAErB,CAAC,CAAC;QAEF,MAAM,kBAAkB,GAAG,GAAG,EAAE,CAAC,CAAC,iBAA+C,EAAE,EAAE;YACnF,OAAO,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;QACzC,CAAC,CAAC;QAEF,MAAM,iBAAiB,GACrB,CAAc,QAA8C,EAAE,EAAE,CAChE,CAAC,iBAA+C,EAAE,EAAE;YAClD,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;YACvD,WAAW,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC;YACvC,OAAO,eAAqC,CAAC;QAC/C,CAAC,CAAC;QAgBJ,OAAO,CAAC,GAAyC,EAAE,EAAE,CAAC,CAAC;YACrD,YAAY,EAAE,eAAe,CAAC,GAAG,CAAC;YAClC,eAAe,EAAE,kBAAkB,EAAE;YAGrC,cAAc,EAAE,iBAAiB,CAAC,GAAG,CAAC;YACtC,cAAc,EAAE,iBAAiB,EAAE;YACnC,mBAAmB,EAAE,sBAAsB,EAAE;SAC9C,CAAC,CAAC;IACL,CAAC;IAOO,IAAI,CAAI,OAAmB;QACjC,MAAM,kBAAkB,mCACnB,OAAO,KACV,kBAAkB,EAAE,OAAO,CAAC,EAAE,CAAC,OAAO,EACtC,UAAU,EAAE,cAAc,CAAC,QAAQ,GACpC,CAAC;QASF,OAAO,IAAI,CAAC,eAAe,EAAK,CAAC,kBAAkB,CAAC,CAAC;IACvD,CAAC;IAEO,mBAAmB,CAAI,OAAmB;QAEhD,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAI,OAAO,CAAC,CAAC;QAMrC,OAAO,MAAiB,CAAC;IAC3B,CAAC;IAEO,WAAW,CAAI,iBAAkD;QACvE,MAAM,UAAU,GAAe;YAC7B,gBAAgB,EAAE,IAAI;YACtB,aAAa,EAAE,IAAI;YACnB,iBAAiB;SAClB,CAAC;QAEF,OAAO,UAAU,CAAC;IACpB,CAAC;IAEO,cAAc,CACpB,iBAAkD,EAClD,aAAsB,EACtB,GAA0C,EAC1C,KAAe;QAEf,MAAM,aAAa,GAAe;YAChC,gBAAgB,EAAE,KAAK;YACvB,aAAa;YACb,iBAAiB;YACjB,GAAG;YACH,KAAK;SACN,CAAC;QAEF,OAAO,aAAa,CAAC;IACvB,CAAC;IAKO,eAAe;QACrB,OAAO,CAAC,IAA4B,EAAE,EAAE;YAOtC,IAAI,OAAO,GAAG,IAAI,CAChB,IAAI,CAAC,eAAe,EACpB,IAAI,EACJ,IAAI,CAAC,aAAa,EAClB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,iBAAiB,EACtB,IAAI,CAAC,GAAG,EACR,IAAI,CAAC,KAAK,EACV,IAAI,CAAC,gBAAgB,CACtB,CAAC;YAGF,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;YAG3C,MAAM,MAAM,GAAG,OAAO,CAAI,OAAO,CAAC,CAAC;YAEnC,OAAO,MAAM,CAAC;QAChB,CAAC,CAAC;IACJ,CAAC;IAEO,sBAAsB,CAAC,OAAyB;QACtD,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE;YACtB,OAAO;SACR;QAED,IAAI,SAAS,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YAC5B,OAAO,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC;SAC5E;QAED,OAAO,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;IAClD,CAAC;IAEO,qBAAqB,CAAC,QAA4B;QACxD,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE;YAC9B,MAAM,MAAM,GAAG,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,CAAC;YAEpD,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE;gBACrB,MAAM,IAAI,KAAK,CAAC,UAAU,CAAC,qBAAqB,CAAC,CAAC;aACnD;SACF;IACH,CAAC;IAMO,uDAAuD,CAC7D,OAAmB,EACnB,QAAW,EACX,WAA4B;QAE5B,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;SAC9D;QACD,OAAO,IAAI,CAAC,iCAAiC,CAAC,OAAO,EAAE,QAAQ,EAAE,WAAW,CAAC,CAAC;IAChF,CAAC;IAcO,4BAA4B,CAAC,iBAA+C;QAClF,IAAI;YACF,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;SACnD;QAAC,OAAO,CAAC,EAAE;YACV,MAAM,IAAI,KAAK,CAAC,GAAG,UAAU,CAAC,aAAa,IAAI,4BAA4B,CAAC,iBAAiB,CAAC,EAAE,CAAC,CAAC;SACnG;IACH,CAAC;IAEO,iCAAiC,CACvC,OAAmB,EACnB,QAAW,EACX,WAA4B;QAE5B,IAAI,OAAO,OAAO,CAAC,cAAc,KAAK,UAAU,EAAE;YAChD,MAAM,MAAM,GAAG,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;YAEhD,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE;gBACrB,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC,CAAC;aACnE;SACF;QAED,OAAO,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;IACjD,CAAC;IAEa,sCAAsC,CAClD,OAAmB,EACnB,QAAW,EACX,WAA4B;;YAE5B,IAAI,OAAO,OAAO,CAAC,cAAc,KAAK,UAAU,EAAE;gBAChD,MAAM,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;aACxC;YAED,MAAM,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;QAChD,CAAC;KAAA;CACF;AAED,OAAO,EAAE,SAAS,EAAE,CAAC","file":"container.js","sourcesContent":["import { Binding } from '../bindings/binding';\nimport * as ERROR_MSGS from '../constants/error_msgs';\nimport { BindingScopeEnum, TargetTypeEnum } from '../constants/literal_types';\nimport * as METADATA_KEY from '../constants/metadata_keys';\nimport type { interfaces } from '../interfaces/interfaces';\nimport { MetadataReader } from '../planning/metadata_reader';\nimport { createMockRequest, getBindingDictionary, plan } from '../planning/planner';\nimport { resolve } from '../resolution/resolver';\nimport { BindingToSyntax } from '../syntax/binding_to_syntax';\nimport { isPromise, isPromiseOrContainsPromise } from '../utils/async';\nimport { id } from '../utils/id';\nimport { getServiceIdentifierAsString } from '../utils/serialization';\nimport { Lookup } from './lookup';\nimport Reflect from '../../Reflect-metadata';\n// import { ModuleActivationStore } from './module_activation_store';\n\ntype GetArgs<T> = Omit<interfaces.NextArgs<T>, 'contextInterceptor' | 'targetType'>;\n\nclass Container implements interfaces.Container {\n  id: number;\n  parent: interfaces.Container | null;\n  readonly options: interfaces.ContainerOptions;\n  // private _middleware: interfaces.Next | null;\n  private _bindingDictionary: interfaces.Lookup<interfaces.Binding<unknown>>;\n  // private _activations: interfaces.Lookup<interfaces.BindingActivation<unknown>>;\n  // private _deactivations: interfaces.Lookup<interfaces.BindingDeactivation<unknown>>;\n  private _metadataReader: interfaces.MetadataReader;\n  // private _moduleActivationStore: interfaces.ModuleActivationStore;\n\n  static merge(\n    container1: interfaces.Container,\n    container2: interfaces.Container,\n    ...containers: interfaces.Container[]\n  ): interfaces.Container {\n    const container = new Container();\n    const targetContainers: interfaces.Lookup<interfaces.Binding<unknown>>[] = [\n      container1,\n      container2,\n      ...containers\n    ].map(targetContainer => getBindingDictionary(targetContainer));\n    const bindingDictionary: interfaces.Lookup<interfaces.Binding<unknown>> = getBindingDictionary(container);\n\n    function copyDictionary(\n      origin: interfaces.Lookup<interfaces.Binding<unknown>>,\n      destination: interfaces.Lookup<interfaces.Binding<unknown>>\n    ) {\n      origin.traverse((_key, value) => {\n        value.forEach(binding => {\n          destination.add(binding.serviceIdentifier, binding.clone());\n        });\n      });\n    }\n\n    targetContainers.forEach(targetBindingDictionary => {\n      copyDictionary(targetBindingDictionary, bindingDictionary);\n    });\n\n    return container;\n  }\n\n  constructor(containerOptions?: interfaces.ContainerOptions) {\n    const options = containerOptions || {};\n    if (typeof options !== 'object') {\n      throw new Error(`${ERROR_MSGS.CONTAINER_OPTIONS_MUST_BE_AN_OBJECT}`);\n    }\n\n    if (options.defaultScope === undefined) {\n      options.defaultScope = BindingScopeEnum.Transient;\n    } else if (\n      options.defaultScope !== BindingScopeEnum.Singleton &&\n      options.defaultScope !== BindingScopeEnum.Transient &&\n      options.defaultScope !== BindingScopeEnum.Request\n    ) {\n      throw new Error(`${ERROR_MSGS.CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE}`);\n    }\n\n    if (options.autoBindInjectable === undefined) {\n      options.autoBindInjectable = false;\n    } else if (typeof options.autoBindInjectable !== 'boolean') {\n      throw new Error(`${ERROR_MSGS.CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE}`);\n    }\n\n    if (options.skipBaseClassChecks === undefined) {\n      options.skipBaseClassChecks = false;\n    } else if (typeof options.skipBaseClassChecks !== 'boolean') {\n      throw new Error(`${ERROR_MSGS.CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK}`);\n    }\n\n    this.options = {\n      autoBindInjectable: options.autoBindInjectable,\n      defaultScope: options.defaultScope,\n      skipBaseClassChecks: options.skipBaseClassChecks\n    };\n\n    this.id = id();\n    this._bindingDictionary = new Lookup<interfaces.Binding<unknown>>();\n    // this._middleware = null;\n    // this._activations = new Lookup<interfaces.BindingActivation<unknown>>();\n    // this._deactivations = new Lookup<interfaces.BindingDeactivation<unknown>>();\n    this.parent = null;\n    this._metadataReader = new MetadataReader();\n    // this._moduleActivationStore = new ModuleActivationStore();\n  }\n\n  load(...modules: interfaces.ContainerModule[]) {\n    const getHelpers = this._getContainerModuleHelpersFactory();\n\n    for (const currentModule of modules) {\n      const containerModuleHelpers = getHelpers(currentModule.id);\n\n      currentModule.registry(\n        containerModuleHelpers.bindFunction as interfaces.Bind,\n        containerModuleHelpers.unbindFunction,\n        containerModuleHelpers.isboundFunction,\n        containerModuleHelpers.rebindFunction as interfaces.Rebind\n        // containerModuleHelpers.unbindAsyncFunction,\n        // containerModuleHelpers.onActivationFunction as interfaces.Container['onActivation'],\n        // containerModuleHelpers.onDeactivationFunction as interfaces.Container['onDeactivation']\n      );\n    }\n  }\n\n  unload(...modules: interfaces.ContainerModuleBase[]): void {\n    modules.forEach(module => {\n      const deactivations = this._removeModuleBindings(module.id);\n      this._deactivateSingletons(deactivations);\n\n      // this._removeModuleHandlers(module.id);\n    });\n  }\n\n  // Registers a type binding\n  bind<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): interfaces.BindingToSyntax<T> {\n    const scope = this.options.defaultScope || BindingScopeEnum.Transient;\n    const binding = new Binding<T>(serviceIdentifier, scope);\n    this._bindingDictionary.add(serviceIdentifier, binding as Binding<unknown>);\n    return new BindingToSyntax<T>(binding);\n  }\n\n  rebind<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): interfaces.BindingToSyntax<T> {\n    this.unbind(serviceIdentifier);\n    return this.bind(serviceIdentifier);\n  }\n\n  // public async rebindAsync<T>(\n  //   serviceIdentifier: interfaces.ServiceIdentifier<T>\n  // ): Promise<interfaces.BindingToSyntax<T>> {\n  //   await this.unbindAsync(serviceIdentifier);\n  //   return this.bind(serviceIdentifier);\n  // }\n\n  // Removes a type binding from the registry by its key\n  unbind(serviceIdentifier: interfaces.ServiceIdentifier): void {\n    if (this._bindingDictionary.hasKey(serviceIdentifier)) {\n      const bindings = this._bindingDictionary.get(serviceIdentifier);\n\n      this._deactivateSingletons(bindings);\n    }\n\n    this._removeServiceFromDictionary(serviceIdentifier);\n  }\n\n  // public async unbindAsync(serviceIdentifier: interfaces.ServiceIdentifier): Promise<void> {\n  //   if (this._bindingDictionary.hasKey(serviceIdentifier)) {\n  //     const bindings = this._bindingDictionary.get(serviceIdentifier);\n\n  //     await this._deactivateSingletonsAsync(bindings);\n  //   }\n\n  //   this._removeServiceFromDictionary(serviceIdentifier);\n  // }\n\n  // Removes all the type bindings from the registry\n  unbindAll(): void {\n    this._bindingDictionary.traverse((_key, value) => {\n      this._deactivateSingletons(value);\n    });\n\n    this._bindingDictionary = new Lookup<Binding<unknown>>();\n  }\n\n  // public async unbindAllAsync(): Promise<void> {\n  //   const promises: Promise<void>[] = [];\n\n  //   this._bindingDictionary.traverse((_key, value) => {\n  //     promises.push(this._deactivateSingletonsAsync(value));\n  //   });\n\n  //   await Promise.all(promises);\n\n  //   this._bindingDictionary = new Lookup<Binding<unknown>>();\n  // }\n\n  // public onActivation<T>(\n  //   serviceIdentifier: interfaces.ServiceIdentifier<T>,\n  //   onActivation: interfaces.BindingActivation<T>\n  // ) {\n  //   this._activations.add(serviceIdentifier, onActivation as interfaces.BindingActivation<unknown>);\n  // }\n\n  // public onDeactivation<T>(\n  //   serviceIdentifier: interfaces.ServiceIdentifier<T>,\n  //   onDeactivation: interfaces.BindingDeactivation<T>\n  // ) {\n  //   this._deactivations.add(serviceIdentifier, onDeactivation as interfaces.BindingDeactivation<unknown>);\n  // }\n\n  // Allows to check if there are bindings available for serviceIdentifier\n  isBound(serviceIdentifier: interfaces.ServiceIdentifier<unknown>): boolean {\n    let bound = this._bindingDictionary.hasKey(serviceIdentifier);\n    if (!bound && this.parent) {\n      bound = this.parent.isBound(serviceIdentifier);\n    }\n    return bound;\n  }\n\n  // check binding dependency only in current container\n  isCurrentBound<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): boolean {\n    return this._bindingDictionary.hasKey(serviceIdentifier);\n  }\n\n  isBoundNamed(serviceIdentifier: interfaces.ServiceIdentifier, named: string | number | symbol): boolean {\n    return this.isBoundTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);\n  }\n\n  // Check if a binding with a complex constraint is available without throwing a error. Ancestors are also verified.\n  isBoundTagged(\n    serviceIdentifier: interfaces.ServiceIdentifier,\n    key: string | number | symbol,\n    value: unknown\n  ): boolean {\n    let bound = false;\n\n    // verify if there are bindings available for serviceIdentifier on current binding dictionary\n    if (this._bindingDictionary.hasKey(serviceIdentifier)) {\n      const bindings = this._bindingDictionary.get(serviceIdentifier);\n      const request = createMockRequest(this, serviceIdentifier, key, value);\n      bound = bindings.some(b => b.constraint(request));\n    }\n\n    // verify if there is a parent container that could solve the request\n    if (!bound && this.parent) {\n      bound = this.parent.isBoundTagged(serviceIdentifier, key, value);\n    }\n\n    return bound;\n  }\n\n  applyCustomMetadataReader(metadataReader: interfaces.MetadataReader) {\n    this._metadataReader = metadataReader;\n  }\n\n  // Resolves a dependency by its runtime identifier\n  // The runtime identifier must be associated with only one binding\n  // use getAll when the runtime identifier is associated with multiple bindings\n  get<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): T {\n    // if (!window.aaa) {\n    //   window.aaa = 0;\n    // }\n    // const t = performance.now();\n    const getArgs = this._getNotAllArgs(serviceIdentifier, false);\n    // const getArgs = {\n    //   avoidConstraints: false,\n    //   isMultiInject: false,\n    //   serviceIdentifier\n    // };\n\n    const data = this._getButThrowIfAsync<T>(getArgs) as T;\n    // const delta = performance.now() - t;\n    // window.aaa += delta;\n\n    return data;\n  }\n\n  async getAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): Promise<T> {\n    const getArgs = this._getNotAllArgs(serviceIdentifier, false);\n\n    return this._get<T>(getArgs) as Promise<T> | T;\n  }\n\n  getTagged<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, key: string | number | symbol, value: unknown): T {\n    const getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);\n\n    return this._getButThrowIfAsync<T>(getArgs) as T;\n  }\n\n  // public async getTaggedAsync<T>(\n  //   serviceIdentifier: interfaces.ServiceIdentifier<T>,\n  //   key: string | number | symbol,\n  //   value: unknown\n  // ): Promise<T> {\n  //   const getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);\n\n  //   return this._get<T>(getArgs) as Promise<T> | T;\n  // }\n\n  getNamed<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T {\n    return this.getTagged<T>(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);\n  }\n\n  // public getNamedAsync<T>(\n  //   serviceIdentifier: interfaces.ServiceIdentifier<T>,\n  //   named: string | number | symbol\n  // ): Promise<T> {\n  //   return this.getTaggedAsync<T>(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);\n  // }\n\n  // Resolves a dependency by its runtime identifier\n  // The runtime identifier can be associated with one or multiple bindings\n  getAll<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): T[] {\n    const getArgs = this._getAllArgs(serviceIdentifier);\n\n    return this._getButThrowIfAsync<T>(getArgs) as T[];\n  }\n\n  // public getAllAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): Promise<T[]> {\n  //   const getArgs = this._getAllArgs(serviceIdentifier);\n\n  //   return this._getAll(getArgs);\n  // }\n\n  getAllTagged<T>(\n    serviceIdentifier: interfaces.ServiceIdentifier<T>,\n    key: string | number | symbol,\n    value: unknown\n  ): T[] {\n    const getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);\n\n    return this._getButThrowIfAsync<T>(getArgs) as T[];\n  }\n\n  // public getAllTaggedAsync<T>(\n  //   serviceIdentifier: interfaces.ServiceIdentifier<T>,\n  //   key: string | number | symbol,\n  //   value: unknown\n  // ): Promise<T[]> {\n  //   const getArgs = this._getNotAllArgs(serviceIdentifier, true, key, value);\n\n  //   return this._getAll(getArgs);\n  // }\n\n  getAllNamed<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T[] {\n    return this.getAllTagged<T>(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);\n  }\n\n  // public getAllNamedAsync<T>(\n  //   serviceIdentifier: interfaces.ServiceIdentifier<T>,\n  //   named: string | number | symbol\n  // ): Promise<T[]> {\n  //   return this.getAllTaggedAsync<T>(serviceIdentifier, METADATA_KEY.NAMED_TAG, named);\n  // }\n\n  resolve<T>(constructorFunction: interfaces.Newable<T>) {\n    const isBound = this.isBound(constructorFunction);\n    if (!isBound) {\n      this.bind<T>(constructorFunction).toSelf();\n    }\n    const resolved = this.get<T>(constructorFunction);\n    if (!isBound) {\n      this.unbind(constructorFunction);\n    }\n    return resolved;\n  }\n\n  private _preDestroy<T>(constructor: NewableFunction, instance: T): Promise<void> | void {\n    if ((Reflect as any).hasMetadata(METADATA_KEY.PRE_DESTROY, constructor)) {\n      const data: interfaces.Metadata = (Reflect as any).getMetadata(METADATA_KEY.PRE_DESTROY, constructor);\n      return (instance as interfaces.Instance<T>)[data.value as string]?.();\n    }\n  }\n  // private _removeModuleHandlers(moduleId: number): void {\n  //   const moduleActivationsHandlers = this._moduleActivationStore.remove(moduleId);\n\n  //   this._activations.removeIntersection(moduleActivationsHandlers.onActivations);\n  //   this._deactivations.removeIntersection(moduleActivationsHandlers.onDeactivations);\n  // }\n\n  private _removeModuleBindings(moduleId: number): interfaces.Binding<unknown>[] {\n    return this._bindingDictionary.removeByCondition(binding => binding.moduleId === moduleId);\n  }\n\n  private _deactivate<T>(binding: Binding<T>, instance: T): void | Promise<void> {\n    const constructor: NewableFunction = Object.getPrototypeOf(instance).constructor;\n    try {\n      // if (this._deactivations.hasKey(binding.serviceIdentifier)) {\n      //   const result = this._deactivateContainer(instance, this._deactivations.get(binding.serviceIdentifier).values());\n\n      //   if (isPromise(result)) {\n      //     return this._handleDeactivationError(\n      //       result.then(() =>\n      //         this._propagateContainerDeactivationThenBindingAndPreDestroyAsync(binding, instance, constructor)\n      //       ),\n      //       constructor\n      //     );\n      //   }\n      // }\n\n      const propagateDeactivationResult = this._propagateContainerDeactivationThenBindingAndPreDestroy(\n        binding,\n        instance,\n        constructor\n      );\n\n      if (isPromise(propagateDeactivationResult)) {\n        return this._handleDeactivationError(propagateDeactivationResult, constructor);\n      }\n    } catch (ex) {\n      if (ex instanceof Error) {\n        throw new Error(ERROR_MSGS.ON_DEACTIVATION_ERROR(constructor.name, ex.message));\n      }\n    }\n  }\n\n  private async _handleDeactivationError(asyncResult: Promise<void>, constructor: NewableFunction): Promise<void> {\n    try {\n      await asyncResult;\n    } catch (ex) {\n      if (ex instanceof Error) {\n        throw new Error(ERROR_MSGS.ON_DEACTIVATION_ERROR(constructor.name, ex.message));\n      }\n    }\n  }\n\n  // private _deactivateContainer<T>(\n  //   instance: T,\n  //   deactivationsIterator: IterableIterator<interfaces.BindingDeactivation<unknown>>\n  // ): void | Promise<void> {\n  //   let deactivation = deactivationsIterator.next();\n\n  //   while (deactivation.value) {\n  //     const result = deactivation.value(instance);\n\n  //     if (isPromise(result)) {\n  //       return result.then(() => this._deactivateContainerAsync(instance, deactivationsIterator));\n  //     }\n\n  //     deactivation = deactivationsIterator.next();\n  //   }\n  // }\n\n  // private async _deactivateContainerAsync<T>(\n  //   instance: T,\n  //   deactivationsIterator: IterableIterator<interfaces.BindingDeactivation<unknown>>\n  // ): Promise<void> {\n  //   let deactivation = deactivationsIterator.next();\n\n  //   while (deactivation.value) {\n  //     await deactivation.value(instance);\n  //     deactivation = deactivationsIterator.next();\n  //   }\n  // }\n\n  private _getContainerModuleHelpersFactory() {\n    const setModuleId = (\n      bindingToSyntax: interfaces.BindingToSyntax<unknown>,\n      moduleId: interfaces.ContainerModuleBase['id']\n    ) => {\n      // TODO: Implement an internal type `_BindingToSyntax<T>` wherein this member\n      // can be public. Let `BindingToSyntax<T>` be the presentational type that\n      // depends on it, and does not expose this member as public.\n      (\n        bindingToSyntax as unknown as { _binding: { moduleId: interfaces.ContainerModuleBase['id'] } }\n      )._binding.moduleId = moduleId;\n    };\n\n    const getBindFunction =\n      <T>(moduleId: interfaces.ContainerModuleBase['id']) =>\n      (serviceIdentifier: interfaces.ServiceIdentifier) => {\n        const bindingToSyntax = this.bind(serviceIdentifier);\n        setModuleId(bindingToSyntax, moduleId);\n        return bindingToSyntax as BindingToSyntax<T>;\n      };\n\n    const getUnbindFunction = () => (serviceIdentifier: interfaces.ServiceIdentifier) => {\n      return this.unbind(serviceIdentifier);\n    };\n\n    const getUnbindAsyncFunction = () => (serviceIdentifier: interfaces.ServiceIdentifier) => {\n      return null as any;\n      // return this.unbindAsync(serviceIdentifier);\n    };\n\n    const getIsboundFunction = () => (serviceIdentifier: interfaces.ServiceIdentifier) => {\n      return this.isBound(serviceIdentifier);\n    };\n\n    const getRebindFunction =\n      <T = unknown>(moduleId: interfaces.ContainerModuleBase['id']) =>\n      (serviceIdentifier: interfaces.ServiceIdentifier) => {\n        const bindingToSyntax = this.rebind(serviceIdentifier);\n        setModuleId(bindingToSyntax, moduleId);\n        return bindingToSyntax as BindingToSyntax<T>;\n      };\n\n    // const getOnActivationFunction =\n    //   (moduleId: interfaces.ContainerModuleBase['id']) =>\n    //   (serviceIdentifier: interfaces.ServiceIdentifier, onActivation: interfaces.BindingActivation) => {\n    //     this._moduleActivationStore.addActivation(moduleId, serviceIdentifier, onActivation);\n    //     this.onActivation(serviceIdentifier, onActivation);\n    //   };\n\n    // const getOnDeactivationFunction =\n    //   (moduleId: interfaces.ContainerModuleBase['id']) =>\n    //   (serviceIdentifier: interfaces.ServiceIdentifier, onDeactivation: interfaces.BindingDeactivation) => {\n    //     this._moduleActivationStore.addDeactivation(moduleId, serviceIdentifier, onDeactivation);\n    //     this.onDeactivation(serviceIdentifier, onDeactivation);\n    //   };\n\n    return (mId: interfaces.ContainerModuleBase['id']) => ({\n      bindFunction: getBindFunction(mId),\n      isboundFunction: getIsboundFunction(),\n      // onActivationFunction: getOnActivationFunction(mId),\n      // onDeactivationFunction: getOnDeactivationFunction(mId),\n      rebindFunction: getRebindFunction(mId),\n      unbindFunction: getUnbindFunction(),\n      unbindAsyncFunction: getUnbindAsyncFunction()\n    });\n  }\n  // private _getAll<T>(getArgs: GetArgs<T>): Promise<T[]> {\n  //   return Promise.all(this._get<T>(getArgs) as (Promise<T> | T)[]);\n  // }\n  // Prepares arguments required for resolution and\n  // delegates resolution to _middleware if available\n  // otherwise it delegates resolution to _planAndResolve\n  private _get<T>(getArgs: GetArgs<T>): interfaces.ContainerResolution<T> {\n    const planAndResolveArgs: interfaces.NextArgs<T> = {\n      ...getArgs,\n      contextInterceptor: context => context,\n      targetType: TargetTypeEnum.Variable\n    };\n    // if (this._middleware) {\n    //   const middlewareResult = this._middleware(planAndResolveArgs);\n    //   if (middlewareResult === undefined || middlewareResult === null) {\n    //     throw new Error(ERROR_MSGS.INVALID_MIDDLEWARE_RETURN);\n    //   }\n    //   return middlewareResult as interfaces.ContainerResolution<T>;\n    // }\n\n    return this._planAndResolve<T>()(planAndResolveArgs);\n  }\n\n  private _getButThrowIfAsync<T>(getArgs: GetArgs<T>): T | T[] {\n    // console.count('_getButThrowIfAsync');\n    const result = this._get<T>(getArgs);\n\n    // if (isPromiseOrContainsPromise<T>(result)) {\n    //   throw new Error(ERROR_MSGS.LAZY_IN_SYNC(getArgs.serviceIdentifier));\n    // }\n\n    return result as T | T[];\n  }\n\n  private _getAllArgs<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): GetArgs<T> {\n    const getAllArgs: GetArgs<T> = {\n      avoidConstraints: true,\n      isMultiInject: true,\n      serviceIdentifier\n    };\n\n    return getAllArgs;\n  }\n\n  private _getNotAllArgs<T>(\n    serviceIdentifier: interfaces.ServiceIdentifier<T>,\n    isMultiInject: boolean,\n    key?: string | number | symbol | undefined,\n    value?: unknown\n  ): GetArgs<T> {\n    const getNotAllArgs: GetArgs<T> = {\n      avoidConstraints: false,\n      isMultiInject,\n      serviceIdentifier,\n      key,\n      value\n    };\n\n    return getNotAllArgs;\n  }\n\n  // Planner creates a plan and Resolver resolves a plan\n  // one of the jobs of the Container is to links the Planner\n  // with the Resolver and that is what this function is about\n  private _planAndResolve<T = unknown>(): (args: interfaces.NextArgs<T>) => interfaces.ContainerResolution<T> {\n    return (args: interfaces.NextArgs<T>) => {\n      // create a plan\n      // if (!window.aaa) {\n      //   window.aaa = 0;\n      // }\n      // const t = performance.now();\n      // debugger;\n      let context = plan(\n        this._metadataReader,\n        this,\n        args.isMultiInject,\n        args.targetType,\n        args.serviceIdentifier,\n        args.key,\n        args.value,\n        args.avoidConstraints\n      );\n\n      // apply context interceptor\n      context = args.contextInterceptor(context);\n      // window.aaa += performance.now() - t;\n      // resolve plan\n      const result = resolve<T>(context);\n\n      return result;\n    };\n  }\n\n  private _deactivateIfSingleton(binding: Binding<unknown>): Promise<void> | void {\n    if (!binding.activated) {\n      return;\n    }\n\n    if (isPromise(binding.cache)) {\n      return binding.cache.then(resolved => this._deactivate(binding, resolved));\n    }\n\n    return this._deactivate(binding, binding.cache);\n  }\n\n  private _deactivateSingletons(bindings: Binding<unknown>[]): void {\n    for (const binding of bindings) {\n      const result = this._deactivateIfSingleton(binding);\n\n      if (isPromise(result)) {\n        throw new Error(ERROR_MSGS.ASYNC_UNBIND_REQUIRED);\n      }\n    }\n  }\n\n  // private async _deactivateSingletonsAsync(bindings: Binding<unknown>[]): Promise<void> {\n  //   await Promise.all(bindings.map(b => this._deactivateIfSingleton(b)));\n  // }\n\n  private _propagateContainerDeactivationThenBindingAndPreDestroy<T>(\n    binding: Binding<T>,\n    instance: T,\n    constructor: NewableFunction\n  ): void | Promise<void> {\n    if (this.parent) {\n      return this._deactivate.bind(this.parent)(binding, instance);\n    }\n    return this._bindingDeactivationAndPreDestroy(binding, instance, constructor);\n  }\n\n  // private async _propagateContainerDeactivationThenBindingAndPreDestroyAsync<T>(\n  //   binding: Binding<T>,\n  //   instance: T,\n  //   constructor: NewableFunction\n  // ): Promise<void> {\n  //   if (this.parent) {\n  //     await this._deactivate.bind(this.parent)(binding, instance);\n  //   } else {\n  //     await this._bindingDeactivationAndPreDestroyAsync(binding, instance, constructor);\n  //   }\n  // }\n\n  private _removeServiceFromDictionary(serviceIdentifier: interfaces.ServiceIdentifier): void {\n    try {\n      this._bindingDictionary.remove(serviceIdentifier);\n    } catch (e) {\n      throw new Error(`${ERROR_MSGS.CANNOT_UNBIND} ${getServiceIdentifierAsString(serviceIdentifier)}`);\n    }\n  }\n\n  private _bindingDeactivationAndPreDestroy<T>(\n    binding: Binding<T>,\n    instance: T,\n    constructor: NewableFunction\n  ): void | Promise<void> {\n    if (typeof binding.onDeactivation === 'function') {\n      const result = binding.onDeactivation(instance);\n\n      if (isPromise(result)) {\n        return result.then(() => this._preDestroy(constructor, instance));\n      }\n    }\n\n    return this._preDestroy(constructor, instance);\n  }\n\n  private async _bindingDeactivationAndPreDestroyAsync<T>(\n    binding: Binding<T>,\n    instance: T,\n    constructor: NewableFunction\n  ): Promise<void> {\n    if (typeof binding.onDeactivation === 'function') {\n      await binding.onDeactivation(instance);\n    }\n\n    await this._preDestroy(constructor, instance);\n  }\n}\n\nexport { Container };\n"]}