import type { interfaces } from '../interfaces/interfaces';
declare class Container implements interfaces.Container {
    id: number;
    parent: interfaces.Container | null;
    readonly options: interfaces.ContainerOptions;
    private _bindingDictionary;
    private _metadataReader;
    static merge(container1: interfaces.Container, container2: interfaces.Container, ...containers: interfaces.Container[]): interfaces.Container;
    constructor(containerOptions?: interfaces.ContainerOptions);
    load(...modules: interfaces.ContainerModule[]): void;
    unload(...modules: interfaces.ContainerModuleBase[]): void;
    bind<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): interfaces.BindingToSyntax<T>;
    rebind<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): interfaces.BindingToSyntax<T>;
    unbind(serviceIdentifier: interfaces.ServiceIdentifier): void;
    unbindAll(): void;
    isBound(serviceIdentifier: interfaces.ServiceIdentifier<unknown>): boolean;
    isCurrentBound<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): boolean;
    isBoundNamed(serviceIdentifier: interfaces.ServiceIdentifier, named: string | number | symbol): boolean;
    isBoundTagged(serviceIdentifier: interfaces.ServiceIdentifier, key: string | number | symbol, value: unknown): boolean;
    applyCustomMetadataReader(metadataReader: interfaces.MetadataReader): void;
    get<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): T;
    getAsync<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): Promise<T>;
    getTagged<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, key: string | number | symbol, value: unknown): T;
    getNamed<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T;
    getAll<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): T[];
    getAllTagged<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, key: string | number | symbol, value: unknown): T[];
    getAllNamed<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T[];
    resolve<T>(constructorFunction: interfaces.Newable<T>): T;
    private _preDestroy;
    private _removeModuleBindings;
    private _deactivate;
    private _handleDeactivationError;
    private _getContainerModuleHelpersFactory;
    private _get;
    private _getButThrowIfAsync;
    private _getAllArgs;
    private _getNotAllArgs;
    private _planAndResolve;
    private _deactivateIfSingleton;
    private _deactivateSingletons;
    private _propagateContainerDeactivationThenBindingAndPreDestroy;
    private _removeServiceFromDictionary;
    private _bindingDeactivationAndPreDestroy;
    private _bindingDeactivationAndPreDestroyAsync;
}
export { Container };
