{"version":3,"sources":["../src/common/render-area.ts"],"names":[],"mappings":"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","file":"render-area.js","sourcesContent":["import type { IPoint } from '@visactor/vutils';\nimport { abs } from '@visactor/vutils';\nimport type { IAreaCacheItem, ICubicBezierCurve, ICurve, IDirection, ILineCurve, IPath2D } from '../interface';\nimport { Direction } from './enums';\nimport { divideCubic } from './segment/curve/cubic-bezier';\nimport { divideLinear } from './segment/curve/line';\nimport { drawSegItem } from './render-utils';\n\n/**\n * 绘制连续的线段\n * 绘制长度为总长度percent的path，drawDirection为绘制的方向，也就是percent的方向\n * @param path\n * @param segPath\n * @param percent\n * @param drawDirection 绘制的方向，用于使用percent绘制\n * @param line 用于获取line相关属性\n */\nexport function drawAreaSegments(\n  path: IPath2D,\n  segPath: IAreaCacheItem,\n  percent: number,\n  params?: {\n    offsetX?: number;\n    offsetY?: number;\n    offsetZ?: number;\n    direction?: IDirection;\n  }\n) {\n  // let needMoveTo: boolean = true;\n  const { top, bottom } = segPath;\n  // 如果top和bottom的curves数量不同，那么就跳过\n  if (top.curves.length !== bottom.curves.length) {\n    return;\n  }\n  if (percent >= 1) {\n    const topList: ICurve<IPoint>[] = [];\n    const bottomList: ICurve<IPoint>[] = [];\n    let lastDefined: boolean = true;\n    for (let i = 0, n = top.curves.length; i < n; i++) {\n      const topCurve = top.curves[i];\n      if (lastDefined !== topCurve.defined) {\n        if (lastDefined) {\n          drawAreaBlock(path, topList, bottomList, params);\n          topList.length = 0;\n          bottomList.length = 0;\n        } else {\n          topList.push(topCurve);\n          bottomList.push(bottom.curves[n - i - 1]);\n        }\n        lastDefined = !lastDefined;\n      } else {\n        if (lastDefined) {\n          topList.push(topCurve);\n          bottomList.push(bottom.curves[n - i - 1]);\n        }\n      }\n    }\n    drawAreaBlock(path, topList, bottomList, params);\n\n    return;\n  }\n  if (percent <= 0) {\n    return;\n  }\n\n  let { direction } = params || {};\n  const { curves: topCurves } = top;\n  const endP = topCurves[topCurves.length - 1].p3 ?? topCurves[topCurves.length - 1].p1;\n  const xTotalLength = abs(endP.x - topCurves[0].p0.x);\n  const yTotalLength = abs(endP.y - topCurves[0].p0.y);\n  direction = direction ?? (xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN);\n  if (!Number.isFinite(xTotalLength)) {\n    direction = Direction.COLUMN;\n  }\n  if (!Number.isFinite(yTotalLength)) {\n    direction = Direction.ROW;\n  }\n\n  // x和y必须始终保持同方向\n  // 整个线段的总长度（基于水平、垂直方向）\n  const totalLength: number = direction === Direction.ROW ? xTotalLength : yTotalLength;\n\n  // 总需要绘制的长度\n  const totalDrawLength = percent * totalLength;\n  // 直到上次绘制的长度\n  let drawedLengthUntilLast = 0;\n  let lastDefined: boolean = true;\n  const topList: ICurve<IPoint>[] = [];\n  const bottomList: ICurve<IPoint>[] = [];\n  const defined0 = true;\n  let lastTopCurve: ICurve<IPoint>;\n  let lastBottomCurve: ICurve<IPoint>;\n  for (let i = 0, n = top.curves.length; i < n; i++) {\n    const topCurve = top.curves[i];\n    const curCurveLength = topCurve.getLength(direction);\n    const percent = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;\n    if (percent < 0) {\n      break;\n    }\n    drawedLengthUntilLast += curCurveLength;\n\n    let tc: ICurve<IPoint> | null = null;\n    let bc: ICurve<IPoint> | null = null;\n    if (lastDefined !== topCurve.defined) {\n      if (lastDefined) {\n        drawAreaBlock(path, topList, bottomList, params);\n        topList.length = 0;\n        bottomList.length = 0;\n      } else {\n        tc = topCurve;\n        bc = bottom.curves[n - i - 1];\n      }\n      lastDefined = !lastDefined;\n    } else {\n      if (lastDefined) {\n        tc = topCurve;\n        bc = bottom.curves[n - i - 1];\n      }\n    }\n\n    if (tc && bc) {\n      if (percent < 1) {\n        if (tc.p2 && tc.p3) {\n          tc = divideCubic(tc as ICubicBezierCurve, percent)[0];\n        } else {\n          tc = divideLinear(tc as ILineCurve, percent)[0];\n        }\n        if (bc.p2 && bc.p3) {\n          bc = divideCubic(bc as ICubicBezierCurve, 1 - percent)[1];\n        } else {\n          bc = divideLinear(bc as ILineCurve, 1 - percent)[1];\n        }\n      }\n      tc.defined = lastDefined;\n      bc.defined = lastDefined;\n      topList.push(tc);\n      bottomList.push(bc);\n    }\n\n    tc = null;\n    bc = null;\n  }\n\n  drawAreaBlock(path, topList, bottomList, params);\n\n  // const totalLength = segPath.tryUpdateLength();\n\n  // // 直到上次绘制的长度\n  // let drawedLengthUntilLast = 0;\n  // for (let i = 0, n = curves.length; i < n; i++) {\n  //   const curve = curves[i];\n  //   const curCurveLength = curve.getLength();\n  //   const _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;\n  //   drawedLengthUntilLast += curCurveLength;\n  //   if (_p < 0) {\n  //     break;\n  //   }\n\n  //   // 跳过这个点\n  //   if (!curve.defined()) {\n  //     needMoveTo = true;\n  //     continue;\n  //   }\n  //   if (needMoveTo) {\n  //     path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY);\n  //   }\n  //   drawSegItem(path, curve, min(_p, 1), params);\n  //   needMoveTo = false;\n  // }\n}\n\nfunction drawAreaBlock(\n  path: IPath2D,\n  topList: ICurve<IPoint>[],\n  bottomList: ICurve<IPoint>[],\n  params?: {\n    offsetX?: number;\n    offsetY?: number;\n    offsetZ?: number;\n  }\n) {\n  const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params || {};\n  let needMoveTo = true;\n  topList.forEach(curve => {\n    // 跳过这个点\n    if (!curve.defined) {\n      needMoveTo = true;\n      return;\n    }\n    if (needMoveTo) {\n      path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);\n    }\n    drawSegItem(path, curve, 1, params);\n    needMoveTo = false;\n  });\n  needMoveTo = true;\n  for (let i = bottomList.length - 1; i >= 0; i--) {\n    const curve = bottomList[i];\n    // 跳过这个点\n    if (!curve.defined) {\n      needMoveTo = true;\n      continue;\n    }\n    if (needMoveTo) {\n      // bottom需要直接line绘制\n      path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);\n    }\n    drawSegItem(path, curve, 1, params);\n    needMoveTo = false;\n  }\n  path.closePath();\n}\n"]}