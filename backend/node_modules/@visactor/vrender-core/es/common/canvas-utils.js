import { isArray } from "@visactor/vutils";

import { GradientParser } from "./color-utils";

export function getScaledStroke(context, width, dpr) {
    let strokeWidth = width;
    const {a: a, b: b, c: c, d: d} = context.currentMatrix, scaleX = Math.sign(a) * Math.sqrt(a * a + b * b), scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);
    return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, 
    strokeWidth);
}

export function createColor(context, c, params, offsetX = 0, offsetY = 0) {
    var _a, _b, _c, _d;
    if (!c || !0 === c) return "black";
    let result, color;
    if (isArray(c)) for (let i = 0; i < c.length && (color = c[i], !color); i++) ; else color = c;
    if (color = GradientParser.Parse(color), "string" == typeof color) return color;
    if (params.AABBBounds && (!params.attribute || 0 !== params.attribute.scaleX || 0 !== params.attribute.scaleY)) {
        const bounds = params.AABBBounds;
        let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;
        if (params.attribute) {
            const {scaleX: scaleX = 1, scaleY: scaleY = 1, angle: angle = 0} = params.attribute;
            w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY, (angle || 1 !== scaleX || 1 !== scaleY) && (x = null !== (_a = params.x1WithoutTransform) && void 0 !== _a ? _a : 0, 
            y = null !== (_b = params.y1WithoutTransform) && void 0 !== _b ? _b : 0, w = null !== (_c = params.widthWithoutTransform) && void 0 !== _c ? _c : w, 
            h = null !== (_d = params.heightWithoutTransform) && void 0 !== _d ? _d : h);
        }
        "linear" === color.gradient ? result = createLinearGradient(context, color, x, y, w, h) : "conical" === color.gradient ? result = createConicGradient(context, color, x, y, w, h) : "radial" === color.gradient && (result = createRadialGradient(context, color, x, y, w, h));
    }
    return result || "orange";
}

function createLinearGradient(context, color, x, y, w, h) {
    var _a, _b, _c, _d;
    const canvasGradient = context.createLinearGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h, x + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w, y + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h);
    return color.stops.forEach((stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
    })), canvasGradient;
}

function createRadialGradient(context, color, x, y, w, h) {
    var _a, _b, _c, _d, _e, _f;
    const canvasGradient = context.createRadialGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : .5) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : .5) * h, Math.max(w, h) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x + (null !== (_d = color.x1) && void 0 !== _d ? _d : .5) * w, y + (null !== (_e = color.y1) && void 0 !== _e ? _e : .5) * h, Math.max(w, h) * (null !== (_f = color.r1) && void 0 !== _f ? _f : .5));
    return color.stops.forEach((stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
    })), canvasGradient;
}

function createConicGradient(context, color, x, y, w, h) {
    var _a, _b;
    const canvasGradient = context.createConicGradient(x + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h, color.startAngle, color.endAngle);
    return color.stops.forEach((stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
    })), canvasGradient.GetPattern ? canvasGradient.GetPattern(w + x, h + y, undefined) : canvasGradient;
}
//# sourceMappingURL=canvas-utils.js.map