{"version":3,"sources":["../src/common/sort.ts"],"names":[],"mappings":"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","file":"sort.js","sourcesContent":["import type { IGraphic } from '../interface';\n\nfunction parseChildMap(graphic: IGraphic, defaultZIndex: number, reverse: boolean) {\n  const childMap: { [id: number]: IGraphic[] } = {};\n  const zIdxArray: number[] = [];\n\n  graphic.forEachChildren((item: IGraphic) => {\n    const { zIndex = defaultZIndex } = item.attribute;\n    if (childMap[zIndex]) {\n      childMap[zIndex].push(item);\n    } else {\n      childMap[zIndex] = [item];\n      zIdxArray.push(zIndex);\n    }\n  }, reverse);\n  zIdxArray.sort((a, b) => (reverse ? b - a : a - b));\n\n  return { childMap, zIdxArray };\n}\n\nexport function foreach(\n  graphic: IGraphic,\n  defaultZIndex: number,\n  cb: (...data: any) => boolean | void,\n  reverse: boolean = false,\n  sort3d: boolean = false\n) {\n  // 遍历一遍查看是否有zIndex不同的\n  let needSort = false;\n  if (sort3d) {\n    needSort = true;\n  } else {\n    let lastZIndex: number;\n    graphic.forEachChildren((item: IGraphic, i: number) => {\n      const { zIndex = defaultZIndex } = item.attribute;\n      if (i === 0) {\n        lastZIndex = zIndex;\n      } else if (lastZIndex !== zIndex) {\n        needSort = true;\n        return true;\n      }\n      return false;\n    }, reverse);\n  }\n  if (needSort) {\n    const { childMap, zIdxArray } = parseChildMap(graphic, defaultZIndex, reverse);\n    let skip = false;\n    for (let i = 0; i < zIdxArray.length; i++) {\n      if (skip) {\n        break;\n      }\n      const idx = zIdxArray[i];\n      const children = childMap[idx];\n      // 根据z进行排序\n      if (sort3d) {\n        children.sort((a, b) => {\n          return (reverse ? -1 : 1) * ((b.attribute.z ?? 0) - (a.attribute.z ?? 0));\n        });\n      }\n      for (let i = 0; i < children.length; i++) {\n        if (cb(children[i], i)) {\n          skip = true;\n          break;\n        }\n      }\n    }\n  } else {\n    graphic.forEachChildren(cb, reverse);\n  }\n}\n\nexport async function foreachAsync(\n  graphic: IGraphic,\n  defaultZIndex: number,\n  cb: (data: any, i: number) => boolean | void | Promise<boolean | void>,\n  reverse: boolean = false\n) {\n  // 不支持zIndex\n  await graphic.forEachChildrenAsync(cb, reverse);\n  // const childMap: { [id: number]: IGraphic[] } = {};\n  // const zIdxArray: number[] = [];\n  // // 遍历一遍查看是否有zIndex不同的\n  // let needSort = false;\n  // let lastZIndex: number;\n  // graphic.forEachChildren((item: IGraphic, i: number) => {\n  //   const { zIndex = defaultZIndex } = item.attribute;\n  //   if (i === 0) {\n  //     lastZIndex === zIndex;\n  //   } else if (lastZIndex !== zIndex) {\n  //     needSort = true;\n  //     return true;\n  //   }\n  //   return false;\n  // }, reverse);\n  // if (needSort) {\n  //   graphic.forEachChildren((item: IGraphic) => {\n  //     const { zIndex = defaultZIndex } = item.attribute;\n  //     if (childMap[zIndex]) {\n  //       childMap[zIndex].push(item);\n  //     } else {\n  //       childMap[zIndex] = [item];\n  //       zIdxArray.push(zIndex);\n  //     }\n  //   }, reverse);\n  //   zIdxArray.sort((a, b) => (reverse ? b - a : a - b));\n  //   let skip = false;\n  //   for (let i = 0; i < zIdxArray.length; i++) {\n  //     if (skip) {\n  //       break;\n  //     }\n  //     const idx = zIdxArray[i];\n  //     const children = childMap[idx];\n  //     for (let i = 0; i < children.length; i++) {\n  //       let d = cb(children[i], i);\n  //       if ((d as any).then) {\n  //         d = await d;\n  //       }\n  //       if (d) {\n  //         skip = true;\n  //         break;\n  //       }\n  //     }\n  //   }\n  // } else {\n  //   await graphic.forEachChildrenAsync(cb, reverse);\n  // }\n}\n\nexport function findNextGraphic(graphic: IGraphic, id: number, defaultZIndex: number, reverse: boolean = false) {\n  // 遍历一遍查看是否有zIndex不同的\n  let needSort = false;\n  let lastZIndex: number;\n  graphic.forEachChildren((item: IGraphic, i: number) => {\n    const { zIndex = defaultZIndex } = item.attribute;\n    if (i === 0) {\n      lastZIndex === zIndex;\n    } else if (lastZIndex !== zIndex) {\n      needSort = true;\n      return true;\n    }\n    return false;\n  }, reverse);\n  let result: IGraphic | null = null;\n  let next: boolean = false;\n  if (needSort) {\n    const { childMap, zIdxArray } = parseChildMap(graphic, defaultZIndex, reverse);\n    let skip = false;\n    for (let i = 0; i < zIdxArray.length; i++) {\n      if (skip) {\n        break;\n      }\n      const idx = zIdxArray[i];\n      const children = childMap[idx];\n      for (let i = 0; i < children.length; i++) {\n        if (next) {\n          skip = true;\n          result = children[i];\n          break;\n        }\n        if (children[i]._uid === id) {\n          next = true;\n          continue;\n        }\n      }\n    }\n  } else {\n    graphic.forEachChildren(item => {\n      if (next) {\n        result = item as IGraphic;\n        return true;\n      }\n      if (item._uid === id) {\n        next = true;\n      }\n      return false;\n    }, reverse);\n  }\n\n  return result;\n}\n"]}