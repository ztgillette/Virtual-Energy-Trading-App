import { abs } from "@visactor/vutils";

import { SegContext } from "../seg-context";

import { genCurveSegments } from "./common";

import { Direction } from "../enums";

export class Step {
    constructor(context, t = .5, startPoint) {
        this.context = context, this._t = t, this.startPoint = startPoint;
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
        0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, !1 !== this._lastDefined, this.lastPoint), 
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), 
        this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
    }
    point(p) {
        const x = p.x, y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p) : this.context.moveTo(x, y, p);
            break;

          case 1:
            this._point = 2;

          default:
            if (this._t <= 0) this.context.lineTo(this._x, y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), 
            this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p); else {
                const x1 = this._x * (1 - this._t) + x * this._t;
                .5 === this._t ? this.context.lineTo(x1, this._y, !1 !== this._lastDefined, this.lastPoint) : this.context.lineTo(x1, this._y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), 
                this.context.lineTo(x1, y, !1 !== this._lastDefined && !1 !== p.defined, p);
            }
        }
        this._lastDefined = p.defined, this._x = x, this._y = y, this.lastPoint = p;
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}

export class StepClosed extends Step {
    lineEnd() {
        this.context.closePath();
    }
}

export function genStepSegments(points, t, params = {}) {
    const {direction: direction, startPoint: startPoint} = params;
    if (points.length < 2 - Number(!!startPoint)) return null;
    const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN);
    return genStepTypeSegments(new Step(segContext, t, startPoint), points), segContext;
}

export function genStepTypeSegments(path, points) {
    return genCurveSegments(path, points, 1);
}

export function genStepClosedSegments(points, t, params = {}) {
    const {direction: direction, startPoint: startPoint} = params;
    if (points.length < 2 - Number(!!startPoint)) return null;
    const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN);
    return genStepTypeSegments(new StepClosed(segContext, t, startPoint), points), segContext;
}
//# sourceMappingURL=step.js.map
