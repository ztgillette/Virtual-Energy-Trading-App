import type { IPointLike } from '@visactor/vutils';
import type { IGraphic, IGroup, ILine, IPlugin, IPluginService, IRect, IRichText, IRichTextCharacter, IRichTextFrame, IRichTextIcon, IRichTextLine, IRichTextParagraph, ITicker, ITimeline } from '../../interface';
import { EditModule } from './edit-module';
type UpdateType = 'input' | 'change' | 'onfocus' | 'beforeOnfocus' | 'defocus' | 'beforeDefocus' | 'selection' | 'dispatch';
declare class Selection {
    selectionStartCursorIdx: number;
    curCursorIdx: number;
    rt: IRichText;
    constructor(selectionStartCursorIdx: number, curCursorIdx: number, rt: IRichText);
    isEmpty(): boolean;
    getSelectionPureText(): string;
    hasFormat(key: string): boolean;
    _getFormat(key: string, cursorIdx: number): any;
    getFormat(key: string, supportOutAttr?: boolean): any;
    getAllFormat(key: string, supportOutAttr?: boolean): any;
}
export declare const FORMAT_TEXT_COMMAND = "FORMAT_TEXT_COMMAND";
export declare const FORMAT_ALL_TEXT_COMMAND = "FORMAT_ALL_TEXT_COMMAND";
export declare const FORMAT_ELEMENT_COMMAND = "FORMAT_ELEMENT_COMMAND";
export declare class RichTextEditPlugin implements IPlugin {
    name: 'RichTextEditPlugin';
    activeEvent: 'onRegister';
    pluginService: IPluginService;
    _uid: number;
    key: string;
    editing: boolean;
    focusing: boolean;
    pointerDown: boolean;
    editLine: ILine;
    editBg: IGroup;
    shadowPlaceHolder: IRichText;
    shadowBounds: IRect;
    ticker?: ITicker;
    timeline?: ITimeline;
    currRt: IRichText;
    curCursorIdx: number;
    selectionStartCursorIdx: number;
    startCursorPos?: IPointLike;
    editModule: EditModule;
    protected commandCbs: Map<string, Array<(payload: any, p: RichTextEditPlugin) => void>>;
    protected updateCbs: Array<(type: UpdateType, p: RichTextEditPlugin, params?: any) => void>;
    protected deltaX: number;
    protected deltaY: number;
    static tryUpdateRichtext(richtext: IRichText): void;
    static CreateSelection(rt: IRichText): Selection;
    constructor();
    formatTextCommandCb: (payload: string, p: RichTextEditPlugin) => void;
    formatAllTextCommandCb: (payload: string, p: RichTextEditPlugin) => void;
    _formatTextCommand(payload: string, config: IRichTextCharacter[], rt: IRichText): void;
    dispatchCommand(command: string, payload: any): void;
    registerCommand(command: string, cb: (payload: any, p: RichTextEditPlugin) => void): void;
    removeCommand(command: string, cb: (payload: any, p: RichTextEditPlugin) => void): void;
    registerUpdateListener(cb: (type: UpdateType, p: RichTextEditPlugin) => void): void;
    removeUpdateListener(cb: (type: UpdateType, p: RichTextEditPlugin) => void): void;
    activate(context: IPluginService): void;
    copyToClipboard(e: KeyboardEvent): boolean;
    selectionRange(startIdx: number, endIdx: number): void;
    selectionRangeByCursorIdx(startCursorIdx: number, endCursorIdx: number, cache: IRichTextFrame): void;
    fullSelection(): void;
    protected fullSelectionKeyHandler(e: KeyboardEvent): boolean;
    directKeyHandler(e: KeyboardEvent): boolean;
    handleKeyDown: (e: KeyboardEvent) => void;
    handleInput: (text: string, isComposing: boolean, cursorIdx: number, rt: IRichText) => void;
    handleChange: (text: string, isComposing: boolean, cursorIdx: number, rt: IRichText) => void;
    tryShowShadowPlaceholder(): void;
    getRichTextAABBBounds(rt: IRichText): any;
    tryShowInputBounds(): void;
    trySyncPlaceholderToTextConfig(): void;
    handleFocusIn: () => never;
    handleFocusOut: () => never;
    deactivate(context: IPluginService): void;
    handleMove: (e: PointerEvent) => void;
    handleEnter: () => void;
    handleLeave: () => void;
    handlePointerDown: (e: PointerEvent) => void;
    handlePointerUp: (e: PointerEvent) => void;
    handleDBLClick: (e: PointerEvent) => void;
    protected stopPropagation(e: Event): void;
    addEditLineOrBgOrBounds(graphic: IGraphic, shadowRoot: IGroup): void;
    removeEditLineOrBgOrBounds(graphic: IGraphic, shadowRoot: IGroup): void;
    onFocus(e: PointerEvent, data?: any): void;
    offsetShadowRoot(rt?: IRichText): void;
    protected offsetLineBgAndShadowBounds(): void;
    protected deFocus(trulyDeFocus?: boolean): void;
    protected addAnimateToLine(line: ILine): void;
    tryShowSelection(e: PointerEvent, dblclick: boolean): void;
    _tryShowSelection(currCursorData: {
        x: any;
        y1: number;
        y2: number;
    }, cache: IRichTextFrame): void;
    hideSelection(): void;
    protected getShadow(rt: IRichText): import("../../interface").IShadowRoot;
    protected getLineByPoint(cache: IRichTextFrame, p1: IPointLike): IRichTextLine;
    protected getColumnAndIndexByLinePoint(lineInfo: IRichTextLine, p1: IPointLike): {
        columnInfo: IRichTextParagraph | IRichTextIcon;
        delta: number;
    };
    protected getColumnIndex(cache: IRichTextFrame, cInfo: IRichTextParagraph | IRichTextIcon): number;
    protected isRichtext(e: PointerEvent): boolean;
    protected isEditableRichtext(e: PointerEvent): boolean;
    protected triggerRender(): void;
    protected computeGlobalDelta(cache: IRichTextFrame): void;
    protected getEventPosition(e: PointerEvent): IPointLike;
    protected setCursorAndTextArea(x: number, y1: number, y2: number, rt: IRichText): void;
    protected computedCursorPosByEvent(e: PointerEvent, cache: IRichTextFrame): {
        x: any;
        y1: number;
        y2: number;
        cursorIndex: number;
        lineInfo: IRichTextLine;
        columnInfo: IRichTextParagraph | IRichTextIcon;
    };
    protected computedCursorPosByCursorIdx(cursorIdx: number, rt: IRichText): {
        x: number;
        y1: number;
        y2: any;
        lineInfo?: undefined;
        columnInfo?: undefined;
    } | {
        x: any;
        y1: number;
        y2: number;
        lineInfo: IRichTextLine;
        columnInfo: IRichTextParagraph | IRichTextIcon;
    };
    protected getColumnByIndex(cache: IRichTextFrame, index: number): {
        lineInfo: IRichTextLine;
        columnInfo: IRichTextParagraph | IRichTextIcon;
    } | null;
    release(): void;
    getSelection(defaultAll?: boolean): Selection;
    forceFocus(params: {
        e?: PointerEvent;
        target: IRichText | null;
        cursorIndex?: number;
    }): void;
    protected _forceFocusByEvent(e: PointerEvent): void;
    protected _forceFocusByCursorIndex(cursorIndex: number): void;
}
export {};
