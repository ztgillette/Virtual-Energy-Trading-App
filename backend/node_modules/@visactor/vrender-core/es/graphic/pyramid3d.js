import { max, PointService } from "@visactor/vutils";

import { application } from "../application";

import { Polygon } from "./polygon";

import { PYRAMID3D_NUMBER_TYPE } from "./constants";

import { NOWORK_ANIMATE_ATTR } from "./graphic";

export class Pyramid3d extends Polygon {
    constructor(params) {
        super(params), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
    }
    updateAABBBounds(attribute, polygonTheme, aabbBounds) {
        const stage = this.stage;
        if (!stage || !stage.camera) return aabbBounds;
        return this.findFace().vertices.forEach((v => {
            const x = v[0], y = v[1];
            aabbBounds.add(x, y);
        })), application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, !1, this), 
        aabbBounds;
    }
    findFace() {
        const {points: points} = this.attribute, kList = points.map(((p, i) => {
            const p1 = 3 === i ? points[0] : points[i + 1], dx = p.x - p1.x;
            return 0 === dx ? 0 : (p.y - p1.y) / dx;
        })), pointsMap = points.map((p => ({
            p: p,
            d: 0
        })));
        let find = !1, maxD = 0;
        for (let i = 0; i < kList.length - 1; i++) {
            for (let j = i + 1; j < kList.length; j++) {
                if (kList[i] === kList[j]) {
                    find = !0;
                    const d1 = PointService.distancePP(pointsMap[i].p, pointsMap[i + 1].p);
                    pointsMap[i].d = d1, pointsMap[i + 1].d = d1, maxD = max(maxD, d1);
                    const d2 = PointService.distancePP(pointsMap[j].p, pointsMap[j + 1].p);
                    pointsMap[j].d = d2, pointsMap[j + 1].d = d2, maxD = max(maxD, d2);
                }
                if (find) break;
            }
            if (find) break;
        }
        for (let i = points.length - 1; i >= 0; i--) {
            const p = points[i];
            pointsMap.unshift({
                p: p,
                d: 0
            });
        }
        for (let i = 0; i < points.length; i++) {
            const delta = (maxD - pointsMap[i + points.length].d) / 2;
            pointsMap[i].d += delta, pointsMap[i + points.length].d += delta;
        }
        const faces = {
            polygons: [],
            vertices: [],
            edges: []
        };
        return pointsMap.forEach((p => {
            faces.vertices.push([ p.p.x, p.p.y, p.d ]);
        })), faces.polygons.push({
            polygon: [ 0, 4, 5, 1 ],
            normal: [ 0, -1, 0 ]
        }), faces.polygons.push({
            polygon: [ 7, 6, 2, 3 ],
            normal: [ 0, 1, 0 ]
        }), faces.polygons.push({
            polygon: [ 0, 4, 7, 3 ],
            normal: [ -1, 0, 0 ]
        }), faces.polygons.push({
            polygon: [ 1, 5, 6, 2 ],
            normal: [ 1, 0, 0 ]
        }), faces.polygons.push({
            polygon: [ 0, 1, 2, 3 ],
            normal: [ 0, 0, -1 ]
        }), faces.polygons.push({
            polygon: [ 4, 5, 6, 7 ],
            normal: [ 0, 0, 1 ]
        }), faces.edges = [ [ 0, 1 ], [ 1, 2 ], [ 2, 3 ], [ 3, 0 ], [ 4, 5 ], [ 5, 6 ], [ 6, 7 ], [ 7, 4 ], [ 0, 4 ], [ 3, 7 ], [ 1, 5 ], [ 2, 6 ] ], 
        faces;
    }
    _isValid() {
        return super._isValid() && 4 === this.attribute.points.length;
    }
    getNoWorkAnimateAttr() {
        return Pyramid3d.NOWORK_ANIMATE_ATTR;
    }
}

Pyramid3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;

export function createPyramid3d(attributes) {
    return new Pyramid3d(attributes);
}
//# sourceMappingURL=pyramid3d.js.map
