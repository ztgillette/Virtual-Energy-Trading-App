import type { IAABBBounds } from '@visactor/vutils';
import type { IRichText, IRichTextCharacter, RichTextGlobalAlignType, RichTextGlobalBaselineType, RichTextVerticalDirection, RichTextWordBreak, IRichTextGraphicAttribute, IRichTextImageCharacter, IRichTextParagraphCharacter, IStage, ILayer, IRichTextIcon, EventPoint, IRichTextFrame } from '../interface';
import { Graphic } from './graphic';
import Frame from './richtext/frame';
export declare class RichText extends Graphic<IRichTextGraphicAttribute> implements IRichText {
    type: 'richtext';
    _frameCache: Frame;
    _currentHoverIcon: IRichTextIcon | null;
    static NOWORK_ANIMATE_ATTR: {
        strokeSeg: number;
        boundsPadding: number;
        pickMode: number;
        boundsMode: number;
        customPickShape: number;
        pickable: number;
        childrenPickable: number;
        visible: number;
        zIndex: number;
        layout: number;
        keepDirIn3d: number;
        globalZIndex: number;
        outerBorder: number;
        innerBorder: number;
        lineDash: number;
        lineCap: number;
        lineJoin: number;
        miterLimit: number;
        strokeBoundsBuffer: number;
        scaleCenter: number;
        anchor: number;
        anchor3d: number;
        postMatrix: number;
        backgroundMode: number;
        background: number;
        texture: number;
        cursor: number;
        html: number;
        ellipsis: number;
        wordBreak: number;
        verticalDirection: number;
        textAlign: number;
        textBaseline: number;
        textConfig: number;
        layoutDirection: number;
    };
    constructor(params?: IRichTextGraphicAttribute);
    get width(): number;
    set width(w: number);
    get height(): number;
    set height(h: number);
    get maxWidth(): number | undefined;
    set maxWidth(mw: number | undefined);
    get maxHeight(): number | undefined;
    set maxHeight(mh: number | undefined);
    get ellipsis(): boolean | string;
    set ellipsis(e: boolean | string);
    get wordBreak(): RichTextWordBreak;
    set wordBreak(wb: RichTextWordBreak);
    get verticalDirection(): RichTextVerticalDirection;
    set verticalDirection(vd: RichTextVerticalDirection);
    get textAlign(): RichTextGlobalAlignType;
    set textAlign(align: RichTextGlobalAlignType);
    get textBaseline(): RichTextGlobalBaselineType;
    set textBaseline(baseline: RichTextGlobalBaselineType);
    get textConfig(): IRichTextCharacter[];
    set textConfig(config: IRichTextCharacter[]);
    getGraphicTheme(): Required<IRichTextGraphicAttribute>;
    static AllSingleCharacter(cache: IRichTextFrame | IRichTextGraphicAttribute['textConfig']): boolean;
    static splitText(text: string): any[];
    static TransformTextConfig2SingleCharacter(textConfig: IRichTextGraphicAttribute['textConfig']): IRichTextCharacter[];
    protected updateAABBBounds(attribute: IRichTextGraphicAttribute, richtextTheme: Required<IRichTextGraphicAttribute>, aabbBounds: IAABBBounds): import("@visactor/vutils").IBounds;
    protected needUpdateTags(keys: string[]): boolean;
    protected needUpdateTag(key: string): boolean;
    getFrameCache(): IRichTextFrame;
    get cliped(): boolean;
    combinedStyleToCharacter(config: IRichTextImageCharacter | IRichTextParagraphCharacter): {
        lineHeight?: string | number;
        textAlign?: CanvasTextAlign;
        textBaseline?: CanvasTextBaseline;
        direction?: import("../interface").RichTextLayoutDirectionType;
        text: string | number;
        fontSize: number;
        fontFamily: string;
        fill: string | boolean | import("../interface").ILinearGradient | import("../interface").IRadialGradient | import("../interface").IConicalGradient;
        stroke: string | boolean | import("../interface").ILinearGradient | import("../interface").IRadialGradient | import("../interface").IConicalGradient | import("../interface").IStrokeType[];
        fontWeight: string | number;
        lineWidth: number;
        fontStyle: string;
        textDecoration?: import("../interface").RichTextTextDecoration;
        script?: import("../interface").RichTextScript;
        underline?: boolean;
        lineThrough?: boolean;
        opacity: number;
        fillOpacity: number;
        strokeOpacity: number;
        background?: string;
        backgroundOpacity?: number;
        space?: number;
        dx?: number;
        dy?: number;
    } | {
        lineHeight?: string | number;
        textAlign?: CanvasTextAlign;
        textBaseline?: CanvasTextBaseline;
        direction?: import("../interface").RichTextLayoutDirectionType;
        image: string | HTMLImageElement | HTMLCanvasElement;
        width: number;
        height: number;
        backgroundShowMode?: "always" | "hover";
        backgroundFill?: boolean | import("../interface").IColor;
        backgroundFillOpacity?: number;
        backgroundStroke?: boolean | import("../interface").IColor;
        backgroundStrokeOpacity?: number;
        backgroundRadius?: number;
        backgroundWidth?: number;
        backgroundHeight?: number;
        id?: string;
        margin?: number | number[];
        funcType?: string;
        hoverImage?: string | HTMLImageElement | HTMLCanvasElement;
        fill: import("../interface").IFillType;
        stroke: import("../interface").IStrokeType | import("../interface").IStrokeType[];
        fontSize: number;
        fontFamily: string;
        fontStyle: string;
        fontWeight: string | number;
        lineWidth: number;
        opacity: number;
        fillOpacity: number;
        strokeOpacity: number;
    };
    doUpdateFrameCache(tc?: IRichTextCharacter[]): void;
    clone(): RichText;
    setStage(stage?: IStage, layer?: ILayer): void;
    bindIconEvent(): void;
    updateHoverIconState(pickedIcon?: IRichTextIcon): void;
    pickIcon(point: EventPoint): IRichTextIcon | undefined;
    getNoWorkAnimateAttr(): Record<string, number>;
}
export declare function createRichText(attributes: IRichTextGraphicAttribute): IRichText;
