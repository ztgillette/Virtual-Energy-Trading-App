import { Graphic, NOWORK_ANIMATE_ATTR } from "./graphic";

import { getTheme } from "./theme";

import { GLYPH_NUMBER_TYPE } from "./constants";

export class Glyph extends Graphic {
    constructor(params) {
        super(params), this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE, this.subGraphic = [], 
        this._onInit && this._onInit(this), this.valid = this.isValid();
    }
    setSubGraphic(subGraphic) {
        this.detachSubGraphic(), this.subGraphic = subGraphic, subGraphic.forEach((g => {
            g.glyphHost = this, Object.setPrototypeOf(g.attribute, this.attribute);
        })), this.valid = this.isValid(), this.addUpdateBoundTag();
    }
    detachSubGraphic() {
        this.subGraphic.forEach((g => {
            g.glyphHost = null, Object.setPrototypeOf(g.attribute, {});
        }));
    }
    getSubGraphic() {
        return this.subGraphic;
    }
    onInit(cb) {
        this._onInit = cb;
    }
    onUpdate(cb) {
        this._onUpdate = cb;
    }
    isValid() {
        return !0;
    }
    setAttribute(key, value, forceUpdateTag, context) {
        super.setAttribute(key, value, forceUpdateTag, context), this.subGraphic.forEach((g => {
            g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
        }));
    }
    setAttributes(params, forceUpdateTag = !1, context) {
        super.setAttributes(params, forceUpdateTag, context), this.subGraphic.forEach((g => {
            g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
        }));
    }
    translate(x, y) {
        return super.translate(x, y), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    translateTo(x, y) {
        return super.translateTo(x, y), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    scale(scaleX, scaleY, scaleCenter) {
        return super.scale(scaleX, scaleY, scaleCenter), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    scaleTo(scaleX, scaleY) {
        return super.scaleTo(scaleX, scaleY), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    rotate(angle) {
        return super.rotate(angle), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    rotateTo(angle) {
        return super.rotate(angle), this.subGraphic.forEach((g => {
            g.addUpdatePositionTag(), g.addUpdateBoundTag();
        })), this;
    }
    getGraphicTheme() {
        return getTheme(this).glyph;
    }
    updateAABBBounds(attribute, theme, aabbBounds) {
        return this.getSubGraphic().forEach((node => {
            aabbBounds.union(node.AABBBounds);
        })), aabbBounds;
    }
    doUpdateAABBBounds() {
        this.updateAABBBoundsStamp++, this._AABBBounds.clear();
        const bounds = this.updateAABBBounds(this.attribute, this.getGraphicTheme(), this._AABBBounds);
        return this.clearUpdateBoundTag(), bounds;
    }
    needUpdateTags(keys) {
        return !1;
    }
    needUpdateTag(key) {
        return !1;
    }
    useStates(states, hasAnimation) {
        var _a;
        if (!states.length) return void this.clearStates(hasAnimation);
        if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some(((stateName, index) => this.currentStates[index] !== stateName)))) return;
        this.stopStateAnimates();
        const stateAttrs = {}, subAttrs = this.subGraphic.map((() => ({})));
        states.forEach((stateName => {
            var _a;
            const attrs = this.glyphStateProxy ? this.glyphStateProxy(stateName, states) : this.glyphStates[stateName];
            attrs && (Object.assign(stateAttrs, attrs.attributes), (null === (_a = attrs.subAttributes) || void 0 === _a ? void 0 : _a.length) && subAttrs.forEach(((subAttrs, index) => {
                Object.assign(subAttrs, attrs.subAttributes[index]);
            })));
        })), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
    }
    clearStates(hasAnimation) {
        this.stopStateAnimates(), this.hasState() && this.normalAttrs ? (this.currentStates = [], 
        this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0)) : this.currentStates = [], 
        this.normalAttrs = null;
    }
    clone() {
        const glyph = new Glyph(Object.assign({}, this.attribute));
        return glyph.setSubGraphic(this.subGraphic.map((g => g.clone()))), glyph;
    }
    getNoWorkAnimateAttr() {
        return Glyph.NOWORK_ANIMATE_ATTR;
    }
}

Glyph.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;

export function createGlyph(attributes) {
    return new Glyph(attributes);
}
//# sourceMappingURL=glyph.js.map
