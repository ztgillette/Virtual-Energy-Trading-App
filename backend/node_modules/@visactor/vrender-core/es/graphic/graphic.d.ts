import type { ICustomPath2D } from './../interface/path';
import type { Dict, IPointLike, IAABBBounds, IOBBBounds } from '@visactor/vutils';
import { Matrix, Point } from '@visactor/vutils';
import type { GraphicType, IAnimateConfig, IGraphicAttribute, IGraphic, IGraphicJson, ISetAttributeContext, ITransform, GraphicReleaseStatus } from '../interface/graphic';
import { Node } from './node-tree';
import type { IAnimate, IAnimateTarget, IGlyphGraphicAttribute, ILayer, IPickerService, IShadowRoot, IStage, IStep, ISymbolClass } from '../interface';
import { IContainPointMode } from '../common/enums';
import { CustomSymbolClass } from './builtin-symbol';
export declare const PURE_STYLE_KEY: string[];
export declare const GRAPHIC_UPDATE_TAG_KEY: string[];
export declare const NOWORK_ANIMATE_ATTR: {
    strokeSeg: number;
    boundsPadding: number;
    pickMode: number;
    boundsMode: number;
    customPickShape: number;
    pickable: number;
    childrenPickable: number;
    visible: number;
    zIndex: number;
    layout: number;
    keepDirIn3d: number;
    globalZIndex: number;
    outerBorder: number;
    innerBorder: number;
    lineDash: number;
    lineCap: number;
    lineJoin: number;
    miterLimit: number;
    strokeBoundsBuffer: number;
    scaleCenter: number;
    anchor: number;
    anchor3d: number;
    postMatrix: number;
    backgroundMode: number;
    background: number;
    texture: number;
    cursor: number;
    html: number;
};
export declare abstract class Graphic<T extends Partial<IGraphicAttribute> = Partial<IGraphicAttribute>> extends Node implements IGraphic<T>, IAnimateTarget {
    static mixin(source: Dict<any>): void;
    _events?: any;
    context?: Record<string, any>;
    static userSymbolMap: Record<string, ISymbolClass>;
    onBeforeAttributeUpdate?: (val: any, attributes: Partial<T>, key: null | string | string[], context?: ISetAttributeContext) => T | undefined;
    parent: any;
    resources?: Map<string | HTMLImageElement | HTMLCanvasElement, {
        state: 'init' | 'loading' | 'success' | 'fail';
        data?: HTMLImageElement | HTMLCanvasElement;
    }>;
    backgroundImg?: boolean;
    type: GraphicType;
    prefixed: string;
    numberType: number;
    isContainer?: boolean;
    valid: boolean;
    stage?: IStage;
    layer?: ILayer;
    incremental?: number;
    glyphHost?: IGraphic<IGlyphGraphicAttribute>;
    _onSetStage?: (g: IGraphic, stage: IStage, layer: ILayer) => void;
    in3dMode?: boolean;
    widthWithoutTransform?: number;
    heightWithoutTransform?: number;
    x1WithoutTransform?: number;
    y1WithoutTransform?: number;
    protected _AABBBounds: IAABBBounds;
    get AABBBounds(): IAABBBounds;
    protected _OBBBounds?: IOBBBounds;
    get OBBBounds(): IOBBBounds;
    protected _globalAABBBounds: IAABBBounds;
    get globalAABBBounds(): IAABBBounds;
    protected _transMatrix: Matrix;
    get transMatrix(): Matrix;
    protected _globalTransMatrix: Matrix;
    get globalTransMatrix(): Matrix;
    protected _updateTag: number;
    stamp?: number;
    attribute: T;
    shadowRoot?: IShadowRoot;
    releaseStatus?: GraphicReleaseStatus;
    states?: Record<string, Partial<T>>;
    currentStates?: string[];
    stateAnimateConfig?: IAnimateConfig;
    normalAttrs?: Partial<T>;
    stateProxy?: (stateName: string, targetStates?: string[]) => T;
    animates: Map<string | number, IAnimate>;
    animate?: () => IAnimate;
    pathProxy?: ICustomPath2D;
    attachedThemeGraphic?: IGraphic;
    protected updateAABBBoundsStamp: number;
    protected updateOBBBoundsStamp?: number;
    clipPathMap?: Map<string, ISymbolClass>;
    constructor(params?: T);
    getGraphicService(): import("../interface").IGraphicService;
    getAttributes(): T;
    setMode(mode: '2d' | '3d'): void;
    set3dMode(): void;
    set2dMode(): void;
    getOffsetXY(attr?: ITransform, includeScroll?: boolean): Point;
    onAnimateBind(animate: IAnimate): void;
    protected tryUpdateAABBBounds(): IAABBBounds;
    protected tryUpdateOBBBounds(): IOBBBounds;
    protected combindShadowAABBBounds(bounds: IAABBBounds): void;
    abstract getGraphicTheme(): T;
    protected doUpdateOBBBounds(): IOBBBounds;
    protected abstract updateAABBBounds(attribute: T, symbolTheme: Required<T>, aabbBounds: IAABBBounds, full?: boolean): IAABBBounds;
    getClipPath(): ISymbolClass;
    parsePath(symbolType: string): ISymbolClass | CustomSymbolClass;
    protected doUpdateAABBBounds(full?: boolean): IAABBBounds;
    updatePathProxyAABBBounds(aabbBounds: IAABBBounds): boolean;
    protected tryUpdateGlobalAABBBounds(): IAABBBounds;
    protected tryUpdateGlobalTransMatrix(clearTag?: boolean): Matrix;
    shouldUpdateGlobalMatrix(): boolean;
    protected tryUpdateLocalTransMatrix(clearTag?: boolean): Matrix;
    shouldUpdateAABBBounds(): boolean;
    shouldSelfChangeUpdateAABBBounds(): boolean;
    protected shouldUpdateLocalMatrix(): boolean;
    isValid(): boolean;
    protected _validNumber(num?: number): boolean;
    shouldUpdateShape(): boolean;
    clearUpdateShapeTag(): void;
    containsPoint(x: number, y: number, mode: IContainPointMode, picker?: IPickerService): boolean;
    protected setWidthHeightWithoutTransform(aabbBounds: IAABBBounds): void;
    setAttributesAndPreventAnimate(params: Partial<T>, forceUpdateTag?: boolean, context?: ISetAttributeContext, ignorePriority?: boolean): void;
    setAttributes(params: Partial<T>, forceUpdateTag?: boolean, context?: ISetAttributeContext): void;
    _setAttributes(params: Partial<T>, forceUpdateTag?: boolean, context?: ISetAttributeContext): void;
    setAttribute(key: string, value: any, forceUpdateTag?: boolean, context?: ISetAttributeContext): void;
    protected needUpdateTags(keys: string[], k?: string[]): boolean;
    protected needUpdateTag(key: string, k?: string[]): boolean;
    initAttributes(params: T): void;
    translate(x: number, y: number): this;
    translateTo(x: number, y: number): this;
    scale(scaleX: number, scaleY: number, scaleCenter?: IPointLike): this;
    scaleTo(scaleX: number, scaleY: number): this;
    rotate(angle: number, rotateCenter?: IPointLike): this;
    rotateTo(angle: number): this;
    skewTo(b: number, c: number): this;
    onAttributeUpdate(context?: ISetAttributeContext): void;
    update(d?: {
        bounds: boolean;
        trans: boolean;
    }): void;
    hasState(stateName?: string): boolean;
    getState(stateName: string): Partial<T>;
    applyStateAttrs(attrs: Partial<T>, stateNames: string[], hasAnimation?: boolean, isClear?: boolean): void;
    updateNormalAttrs(stateAttrs: Partial<T>): void;
    protected stopStateAnimates(type?: 'start' | 'end'): void;
    private getNormalAttribute;
    clearStates(hasAnimation?: boolean): void;
    removeState(stateName: string | string[], hasAnimation?: boolean): void;
    toggleState(stateName: string, hasAnimation?: boolean): void;
    addState(stateName: string, keepCurrentStates?: boolean, hasAnimation?: boolean): void;
    useStates(states: string[], hasAnimation?: boolean): void;
    addUpdateBoundTag(): void;
    addUpdateShapeTag(): void;
    addUpdateShapeAndBoundsTag(): void;
    protected updateShapeAndBoundsTagSetted(): boolean;
    protected clearUpdateBoundTag(): void;
    addUpdatePositionTag(): void;
    addUpdateGlobalPositionTag(): void;
    protected clearUpdateLocalPositionTag(): void;
    protected clearUpdateGlobalPositionTag(): void;
    addUpdateLayoutTag(): void;
    protected clearUpdateLayoutTag(): void;
    protected needUpdateLayout(): boolean;
    protected getAnchor(anchor: [string | number, string | number], params: {
        b?: IAABBBounds;
    }, resetScale?: boolean): [number, number];
    protected doUpdateLocalMatrix(): void;
    protected doUpdateGlobalMatrix(): void;
    setStage(stage?: IStage, layer?: ILayer): void;
    setStageToShadowRoot(stage?: IStage, layer?: ILayer): void;
    onAddStep(step: IStep): void;
    onStop(props?: Partial<T>): void;
    getDefaultAttribute(name: string): any;
    getComputedAttribute(name: string): any;
    onSetStage(cb: (g: IGraphic, stage: IStage) => void, immediate?: boolean): void;
    attachShadow(shadowRoot?: IShadowRoot): IShadowRoot;
    detachShadow(): void;
    toJson(): IGraphicJson;
    createPathProxy(path?: string): ICustomPath2D;
    loadImage(image: any, background?: boolean): void;
    setShadowGraphic(graphic: IGraphic): void;
    imageLoadSuccess(url: string, image: HTMLImageElement, cb?: () => void): void;
    imageLoadFail(url: string, cb?: () => void): void;
    private _stopAnimates;
    stopAnimates(stopChildren?: boolean): void;
    release(): void;
    protected _emitCustomEvent(type: string, context?: any): void;
    abstract getNoWorkAnimateAttr(): Record<string, number>;
    abstract clone(): IGraphic<any>;
    toCustomPath(): ICustomPath2D;
}
