import { Graphic, GRAPHIC_UPDATE_TAG_KEY, NOWORK_ANIMATE_ATTR } from "./graphic";

import { CustomPath2D } from "../common/custom-path2d";

import { pointsInterpolation } from "../common/utils";

import { getTheme } from "./theme";

import { application } from "../application";

import { AREA_NUMBER_TYPE } from "./constants";

const AREA_UPDATE_TAG_KEY = [ "segments", "points", "curveType", "curveTension", ...GRAPHIC_UPDATE_TAG_KEY ];

export class Area extends Graphic {
    constructor(params) {
        super(params), this.type = "area", this.numberType = AREA_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        if (this.pathProxy) return !0;
        const {points: points, segments: segments} = this.attribute;
        return segments ? 0 !== segments.length : !!points && 0 !== points.length;
    }
    getGraphicTheme() {
        return getTheme(this).area;
    }
    updateAABBBounds(attribute, areaTheme, aabbBounds) {
        this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds) : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds)), 
        application.graphicService.updateTempAABBBounds(aabbBounds), this.setWidthHeightWithoutTransform(aabbBounds);
        const {lineJoin: lineJoin = areaTheme.lineJoin} = attribute;
        return application.graphicService.transformAABBBounds(attribute, aabbBounds, areaTheme, "miter" === lineJoin, this), 
        aabbBounds;
    }
    updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
        const {points: points = areaTheme.points} = attribute, b = aabbBounds;
        return points.forEach((p => {
            var _a, _b;
            b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
        })), b;
    }
    updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
        const {segments: segments = areaTheme.segments} = attribute, b = aabbBounds;
        return segments.forEach((s => {
            s.points.forEach((p => {
                var _a, _b;
                b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
            }));
        })), b;
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, AREA_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, AREA_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        let path = super.toCustomPath();
        if (path) return path;
        path = new CustomPath2D;
        const attribute = this.attribute, segments = attribute.segments, parsePoints = points => {
            if (points && points.length) {
                let isFirst = !0;
                const basePoints = [];
                if (points.forEach((point => {
                    var _a, _b;
                    !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), 
                    basePoints.push({
                        x: null !== (_a = point.x1) && void 0 !== _a ? _a : point.x,
                        y: null !== (_b = point.y1) && void 0 !== _b ? _b : point.y
                    }), isFirst = !1);
                })), basePoints.length) {
                    for (let i = basePoints.length - 1; i >= 0; i--) path.lineTo(basePoints[i].x, basePoints[i].y);
                    path.closePath();
                }
            }
        };
        return attribute.points ? parsePoints(attribute.points) : segments && segments.length && segments.forEach((seg => {
            parsePoints(seg.points);
        })), path;
    }
    clone() {
        return new Area(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Area.NOWORK_ANIMATE_ATTR;
    }
}

Area.NOWORK_ANIMATE_ATTR = Object.assign({
    segments: 1,
    curveType: 1
}, NOWORK_ANIMATE_ATTR);

export function createArea(attributes) {
    return new Area(attributes);
}
//# sourceMappingURL=area.js.map
