import { Graphic, GRAPHIC_UPDATE_TAG_KEY, NOWORK_ANIMATE_ATTR } from "./graphic";

import { DefaultImageAttribute } from "./config";

import { getTheme } from "./theme";

import { application } from "../application";

import { IMAGE_NUMBER_TYPE } from "./constants";

import { updateBoundsOfCommonOuterBorder } from "./graphic-service/common-outer-boder-bounds";

const IMAGE_UPDATE_TAG_KEY = [ "width", "height", "image", ...GRAPHIC_UPDATE_TAG_KEY ];

export class Image extends Graphic {
    constructor(params) {
        super(params), this.type = "image", this.numberType = IMAGE_NUMBER_TYPE, this.loadImage(this.attribute.image);
    }
    getImageElement() {
        const {image: image} = this.attribute;
        if (!image || !this.resources) return null;
        const res = this.resources.get(image);
        return "success" !== res.state ? null : res.data;
    }
    get width() {
        return this.tryUpdateAABBBounds(), this._actualWidth;
    }
    get height() {
        return this.tryUpdateAABBBounds(), this._actualHeight;
    }
    get repeatX() {
        var _a;
        return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : "no-repeat";
    }
    set repeatX(repeatX) {
        this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);
    }
    get repeatY() {
        var _a;
        return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : "no-repeat";
    }
    set repeatY(repeatY) {
        this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);
    }
    get image() {
        return this.attribute.image;
    }
    set image(image) {
        image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));
    }
    imageLoadSuccess(url, image, cb) {
        super.imageLoadSuccess(url, image, (() => {
            this.successCallback && this.successCallback();
        })), this.addUpdateBoundTag();
    }
    imageLoadFail(url, cb) {
        super.imageLoadFail(url, (() => {
            this.failCallback && this.failCallback();
        }));
    }
    setAttributes(params, forceUpdateTag, context) {
        return params.image && this.loadImage(params.image), super.setAttributes(params, forceUpdateTag, context);
    }
    setAttribute(key, value, forceUpdateTag, context) {
        return "image" === key && this.loadImage(value), super.setAttribute(key, value, forceUpdateTag, context);
    }
    getGraphicTheme() {
        return getTheme(this).image;
    }
    updateAABBBounds(attribute, imageTheme, aabbBounds) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
            const {maxWidth: maxWidth = imageTheme.maxWidth, maxHeight: maxHeight = imageTheme.maxHeight} = attribute;
            let {width: width, height: height} = attribute;
            if (null == width || null == height) {
                const imageElement = this.getImageElement();
                if (imageElement) {
                    const imageWidth = imageElement.width, imageHeight = imageElement.height;
                    if (null != width) height = width * (imageHeight / imageWidth); else if (null != height) width = height * (imageWidth / imageHeight); else {
                        const imageRatio = imageWidth / imageHeight;
                        imageRatio > maxWidth / maxHeight ? (width = maxWidth, height = maxWidth / imageRatio) : (height = maxHeight, 
                        width = maxHeight * imageRatio);
                    }
                } else width = maxWidth, height = maxHeight;
            }
            this._actualWidth = width, this._actualHeight = height, aabbBounds.set(0, 0, width, height);
        }
        const {tb1: tb1, tb2: tb2} = application.graphicService.updateTempAABBBounds(aabbBounds);
        return updateBoundsOfCommonOuterBorder(attribute, imageTheme, tb1), aabbBounds.union(tb1), 
        tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, 
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application.graphicService.transformAABBBounds(attribute, aabbBounds, imageTheme, !1, this), 
        aabbBounds;
    }
    getDefaultAttribute(name) {
        return DefaultImageAttribute[name];
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, IMAGE_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, IMAGE_UPDATE_TAG_KEY);
    }
    clone() {
        return new Image(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Image.NOWORK_ANIMATE_ATTR;
    }
}

Image.NOWORK_ANIMATE_ATTR = Object.assign({
    image: 1,
    repeatX: 1,
    repeatY: 1
}, NOWORK_ANIMATE_ATTR);

export function createImage(attributes) {
    return new Image(attributes);
}
//# sourceMappingURL=image.js.map
