import { mat4Allocate } from "../allocator/matrix-allocate";

import { lookAt, ortho, transformMat4 } from "../common/matrix";

import { Factory } from "../factory";

import { multiplyMat4Mat4 } from "../common/matrix";

export class OrthoCamera {
    set params(params) {
        this._params = Object.assign({}, params), this._projectionMatrixCached = this.forceGetProjectionMatrix(), 
        this._viewMatrixCached = this.forceGetViewMatrix();
    }
    get params() {
        return Object.assign({}, this._params);
    }
    constructor(params) {
        this.params = params;
    }
    getViewMatrix() {
        return this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate()), 
        this._viewMatrixCached;
    }
    forceGetViewMatrix() {
        this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate());
        const {pos: pos, center: center, up: up} = this.params.viewParams;
        return lookAt(this._viewMatrixCached, pos, center, up), this._vp || (this._vp = mat4Allocate.allocate()), 
        this._vp = multiplyMat4Mat4(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), 
        this._viewMatrixCached;
    }
    getProjectionMatrix() {
        return this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate()), 
        this._projectionMatrixCached;
    }
    forceGetProjectionMatrix() {
        this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate());
        const {left: left, top: top, right: right, bottom: bottom} = this._params;
        return ortho(this._projectionMatrixCached, left, right, bottom, top, 0, -2e6), this._vp || (this._vp = mat4Allocate.allocate()), 
        this._vp = multiplyMat4Mat4(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), 
        this._projectionMatrixCached;
    }
    getField() {
        const {fieldRatio: fieldRatio = .8, fieldDepth: fieldDepth, left: left, right: right} = this._params;
        return (null != fieldDepth ? fieldDepth : right - left) * fieldRatio;
    }
    getProjectionScale(z) {
        const field = this.getField();
        return field / (field + z);
    }
    view(x, y, z) {
        const outP = [ 0, 0, 0 ];
        return transformMat4(outP, [ x, y, z ], this._viewMatrixCached), outP;
    }
    vp(x, y, z) {
        const outP = [ 0, 0, 0 ], {pos: pos} = this._params.viewParams;
        transformMat4(outP, [ x, y, z ], this._viewMatrixCached), x = outP[0], y = outP[1], 
        z = outP[2];
        const sizeProjection = this.getProjectionScale(z);
        return {
            x: x * sizeProjection + pos[0],
            y: y * sizeProjection + pos[1]
        };
    }
}

export const registerOrthoCamera = () => {
    Factory.registerPlugin("OrthoCamera", OrthoCamera);
};
//# sourceMappingURL=camera.js.map