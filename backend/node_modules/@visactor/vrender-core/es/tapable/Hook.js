export class Hook {
    constructor(args, name) {
        this._args = args, this.name = name, this.taps = [];
    }
    tap(options, fn) {
        this._tap("sync", options, fn);
    }
    unTap(options, fn) {
        const name = "string" == typeof options ? options.trim() : options.name;
        name && (this.taps = this.taps.filter((tap => !(tap.name === name && (!fn || tap.fn === fn)))));
    }
    _parseOptions(type, options, fn) {
        let _options;
        if ("string" == typeof options) _options = {
            name: options.trim()
        }; else if ("object" != typeof options || null === options) throw new Error("Invalid tap options");
        if ("string" != typeof _options.name || "" === _options.name) throw new Error("Missing name for tap");
        return _options = Object.assign({
            type: type,
            fn: fn
        }, _options), _options;
    }
    _tap(type, options, fn) {
        this._insert(this._parseOptions(type, options, fn));
    }
    _insert(item) {
        let before;
        "string" == typeof item.before ? before = new Set([ item.before ]) : Array.isArray(item.before) && (before = new Set(item.before));
        let stage = 0;
        "number" == typeof item.stage && (stage = item.stage);
        let i = this.taps.length;
        for (;i > 0; ) {
            i--;
            const x = this.taps[i];
            this.taps[i + 1] = x;
            const xStage = x.stage || 0;
            if (before) {
                if (before.has(x.name)) {
                    before.delete(x.name);
                    continue;
                }
                if (before.size > 0) continue;
            }
            if (!(xStage > stage)) {
                i++;
                break;
            }
        }
        this.taps[i] = item;
    }
}
//# sourceMappingURL=Hook.js.map
