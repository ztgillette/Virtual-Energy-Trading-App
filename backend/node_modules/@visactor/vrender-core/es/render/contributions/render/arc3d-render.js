var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

import { abs, cos, epsilon, sin, pi2 } from "@visactor/vutils";

import { injectable } from "../../../common/inversify-lite";

import { getTheme } from "../../../graphic/theme";

import { BaseRender } from "./base-render";

import { ARC3D_NUMBER_TYPE } from "../../../graphic/constants";

import { ColorStore, ColorType } from "../../../color-string";

function drawArcPath(arc, context, cx, cy, z, outerRadius, innerRadius) {
    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
    let collapsedToLine = !1;
    if (outerRadius < innerRadius) {
        const temp = outerRadius;
        outerRadius = innerRadius, innerRadius = temp;
    }
    if (outerRadius <= epsilon) context.moveTo(cx, cy, z); else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle), z), 
    context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle), z), 
    context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z)); else {
        const {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle), xors = outerRadius * cos(outerStartAngle), yors = outerRadius * sin(outerStartAngle), xire = innerRadius * cos(innerEndAngle), yire = innerRadius * sin(innerEndAngle);
        outerDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z), 
        context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z)), 
        !(innerRadius > epsilon) || innerDeltaAngle < .001 ? (context.lineTo(cx + xire, cy + yire, z), 
        collapsedToLine = !0) : (context.lineTo(cx + xire, cy + yire, z), context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z));
    }
    return context.closePath(), collapsedToLine;
}

function drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {
    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
    let collapsedToLine = !1;
    if (radius <= epsilon) context.moveTo(cx, cy, z1); else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + radius * cos(startAngle), cy + radius * sin(startAngle), z1), 
    context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1), context.lineTo(cx + radius * cos(endAngle), cy + radius * sin(endAngle), z2), 
    context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2); else {
        const {innerouterDeltaAngle: innerouterDeltaAngle, innerouterStartAngle: innerouterStartAngle, innerouterEndAngle: innerouterEndAngle} = getParsePadAngle(startAngle, endAngle), xors = radius * cos(innerouterStartAngle), yors = radius * sin(innerouterStartAngle), xore = radius * cos(innerouterEndAngle), yore = radius * sin(innerouterEndAngle);
        innerouterDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z1), 
        context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1), 
        context.lineTo(cx + xore, cy + yore, z2), context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2));
    }
    return context.closePath(), collapsedToLine;
}

let DefaultCanvasArc3DRender = class extends BaseRender {
    constructor() {
        super(...arguments), this.numberType = ARC3D_NUMBER_TYPE;
    }
    drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        const arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc, {fill: fill = arcAttribute.fill} = arc.attribute, data = this.valid(arc, arcAttribute, fillCb, strokeCb);
        if (!data) return;
        const {fVisible: fVisible, sVisible: sVisible, doFill: doFill, doStroke: doStroke} = data, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, {outerPadding: outerPadding = arcAttribute.outerPadding, innerPadding: innerPadding = arcAttribute.innerPadding, height: height = 10} = arc.attribute;
        let {outerRadius: outerRadius = arcAttribute.outerRadius, innerRadius: innerRadius = arcAttribute.innerRadius} = arc.attribute;
        outerRadius += outerPadding, innerRadius -= innerPadding;
        const rgbArray = ColorStore.Get(fill, ColorType.Color255), {light: light} = drawContext.stage || {}, face = drawContext.hack_pieFace, z_face = {
            top: z,
            bottom: z + height
        }, n_face = {
            top: [ 0, 1, 0 ],
            bottom: [ 0, -1, 0 ],
            outside: [ 1, 0, -1 ],
            inside: [ 1, 0, -1 ]
        };
        "bottom" === face || "top" === face ? (context.beginPath(), drawArcPath(arc, context, x, y, z_face[face], outerRadius, innerRadius), 
        context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), 
        doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), 
        context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), 
        doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), 
        context.stroke()))) : "outside" !== face && "inside" !== face || ("inside" === face && (context.save(), 
        context.beginPath(), context.arc(x, y, innerRadius, 0, pi2, !0, z_face.top), context.clip()), 
        context.beginPath(), drawInnerOuterArcPath(arc, context, x, y, z_face.top, z_face.bottom, "outside" === face ? outerRadius : innerRadius, ((startAngle, endAngle) => {
            const {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle);
            return "outside" === face ? {
                innerouterDeltaAngle: outerDeltaAngle,
                innerouterEndAngle: outerEndAngle,
                innerouterStartAngle: outerStartAngle
            } : {
                innerouterDeltaAngle: innerDeltaAngle,
                innerouterEndAngle: innerEndAngle,
                innerouterStartAngle: innerStartAngle
            };
        })), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), 
        doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), 
        context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), 
        doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), 
        context.stroke())), "inside" === face && context.restore());
    }
    draw(arc, renderService, drawContext, params) {
        const arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc;
        this._draw(arc, arcAttribute, !1, drawContext, params);
    }
};

DefaultCanvasArc3DRender = __decorate([ injectable() ], DefaultCanvasArc3DRender);

export { DefaultCanvasArc3DRender };
//# sourceMappingURL=arc3d-render.js.map
