{"version":3,"sources":["../src/render/contributions/render/contributions/rect-contribution-render.ts"],"names":[],"mappings":"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","file":"rect-contribution-render.js","sourcesContent":["import { isArray } from '@visactor/vutils';\nimport { injectable } from '../../../../common/inversify-lite';\nimport type {\n  IGraphicAttribute,\n  IContext2d,\n  IMarkAttribute,\n  IRect,\n  IRectGraphicAttribute,\n  IThemeAttribute,\n  IRectRenderContribution,\n  IDrawContext,\n  IBorderStyle\n} from '../../../../interface';\nimport { getScaledStroke } from '../../../../common/canvas-utils';\nimport { defaultBaseBackgroundRenderContribution } from './base-contribution-render';\nimport { createRectPath } from '../../../../common/shape/rect';\nimport { BaseRenderContributionTime } from '../../../../common/enums';\nimport { defaultBaseTextureRenderContribution } from './base-texture-contribution-render';\n\nexport class DefaultRectRenderContribution implements IRectRenderContribution {\n  time: BaseRenderContributionTime = BaseRenderContributionTime.afterFillStroke;\n  useStyle: boolean = true;\n  order: number = 0;\n  drawShape(\n    rect: IRect,\n    context: IContext2d,\n    x: number,\n    y: number,\n    doFill: boolean,\n    doStroke: boolean,\n    fVisible: boolean,\n    sVisible: boolean,\n    rectAttribute: Required<IRectGraphicAttribute>,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    const { outerBorder, innerBorder } = rect.attribute;\n    const doOuterBorder = outerBorder && outerBorder.visible !== false;\n    const doInnerBorder = innerBorder && innerBorder.visible !== false;\n    if (!(doOuterBorder || doInnerBorder)) {\n      return;\n    }\n    const {\n      cornerRadius = rectAttribute.cornerRadius,\n      cornerType = rectAttribute.cornerType,\n      opacity = rectAttribute.opacity,\n      x: originX = rectAttribute.x,\n      y: originY = rectAttribute.y,\n      scaleX = rectAttribute.scaleX,\n      scaleY = rectAttribute.scaleY,\n      x1,\n      y1,\n      keepStrokeScale = rectAttribute.keepStrokeScale\n    } = rect.attribute;\n\n    let { width, height } = rect.attribute;\n\n    width = (width ?? x1 - x) || 0;\n    height = (height ?? y1 - y) || 0;\n\n    const renderBorder = (borderStyle: Partial<IBorderStyle>, key: 'outerBorder' | 'innerBorder') => {\n      const doStroke = !!(borderStyle && borderStyle.stroke);\n\n      const sign = key === 'outerBorder' ? -1 : 1;\n      const { distance = rectAttribute[key].distance } = borderStyle;\n      const d = keepStrokeScale ? (distance as number) : getScaledStroke(context, distance as number, context.dpr);\n      const nextX = x + sign * d;\n      const nextY = y + sign * d;\n      const dw = d * 2;\n      if (cornerRadius === 0 || (isArray(cornerRadius) && (<number[]>cornerRadius).every(num => num === 0))) {\n        // 不需要处理圆角\n        context.beginPath();\n        context.rect(nextX, nextY, width - sign * dw, height - sign * dw);\n      } else {\n        context.beginPath();\n\n        // 测试后，cache对于重绘性能提升不大，但是在首屏有一定性能损耗，因此rect不再使用cache\n        createRectPath(\n          context,\n          nextX,\n          nextY,\n          width - sign * dw,\n          height - sign * dw,\n          cornerRadius,\n          cornerType !== 'bevel'\n        );\n      }\n\n      // shadow\n      context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute);\n\n      if (strokeCb) {\n        strokeCb(context, borderStyle, rectAttribute[key]);\n      } else if (doStroke) {\n        // 存在stroke\n        const lastOpacity = (rectAttribute[key] as any).opacity;\n        (rectAttribute[key] as any).opacity = opacity;\n        context.setStrokeStyle(\n          rect,\n          borderStyle,\n          (originX - x) / scaleX,\n          (originY - y) / scaleY,\n          rectAttribute[key] as any\n        );\n        (rectAttribute[key] as any).opacity = lastOpacity;\n        context.stroke();\n      }\n    };\n\n    doOuterBorder && renderBorder(outerBorder, 'outerBorder');\n    doInnerBorder && renderBorder(innerBorder, 'innerBorder');\n  }\n}\n\n@injectable()\nexport class SplitRectBeforeRenderContribution implements IRectRenderContribution {\n  time: BaseRenderContributionTime = BaseRenderContributionTime.beforeFillStroke;\n  useStyle: boolean = true;\n  order: number = 0;\n  drawShape(\n    group: IRect,\n    context: IContext2d,\n    x: number,\n    y: number,\n    doFill: boolean,\n    doStroke: boolean,\n    fVisible: boolean,\n    sVisible: boolean,\n    groupAttribute: Required<IRectGraphicAttribute>,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    doFillOrStroke?: { doFill: boolean; doStroke: boolean }\n  ) {\n    const { stroke = groupAttribute.stroke } = group.attribute as any;\n\n    // 数组且存在为false的项目，那就不绘制\n    if (Array.isArray(stroke) && stroke.some(s => s === false)) {\n      doFillOrStroke.doStroke = false;\n    }\n  }\n}\n\n@injectable()\nexport class SplitRectAfterRenderContribution implements IRectRenderContribution {\n  time: BaseRenderContributionTime = BaseRenderContributionTime.afterFillStroke;\n  useStyle: boolean = true;\n  order: number = 0;\n  drawShape(\n    rect: IRect,\n    context: IContext2d,\n    x: number,\n    y: number,\n    doFill: boolean,\n    doStroke: boolean,\n    fVisible: boolean,\n    sVisible: boolean,\n    groupAttribute: Required<IRectGraphicAttribute>,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    const {\n      x1,\n      y1,\n      x: originX = groupAttribute.x,\n      y: originY = groupAttribute.y,\n      stroke = groupAttribute.stroke,\n      cornerRadius = groupAttribute.cornerRadius,\n      cornerType = groupAttribute.cornerType\n    } = rect.attribute as any;\n\n    let { width, height } = rect.attribute;\n    width = (width ?? x1 - originX) || 0;\n    height = (height ?? y1 - originY) || 0;\n\n    // 不是数组\n    if (!(Array.isArray(stroke) && stroke.some(s => s === false))) {\n      return;\n    }\n\n    context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute);\n\n    // 带不同stroke边框\n    if (!(cornerRadius === 0 || (isArray(cornerRadius) && (<number[]>cornerRadius).every(num => num === 0)))) {\n      let lastStrokeI = 0;\n      let lastStroke: any;\n      createRectPath(\n        context,\n        x,\n        y,\n        width,\n        height,\n        cornerRadius,\n        cornerType !== 'bevel',\n        new Array(4).fill(0).map((_, i) => (x1: number, y1: number, x2: number, y2: number) => {\n          if (stroke[i]) {\n            if (!(lastStrokeI === i - 1 && stroke[i] === lastStroke)) {\n              context.setStrokeStyle(rect, { ...rect.attribute, stroke: stroke[i] }, x, y, groupAttribute);\n              context.beginPath();\n              context.moveTo(x1, y1);\n              lastStroke = stroke[i];\n            }\n            lastStrokeI = i;\n            context.lineTo(x2, y2);\n            context.stroke();\n            if (i === 3) {\n              context.beginPath();\n            }\n          }\n        })\n      );\n      context.stroke();\n      return;\n    }\n\n    // 单独处理每条边界，目前不考虑圆角\n    context.beginPath();\n    context.moveTo(x, y);\n    // top\n    if (stroke[0]) {\n      context.lineTo(x + width, y);\n    } else {\n      context.moveTo(x + width, y);\n    }\n    // right\n    if (stroke[1]) {\n      context.lineTo(x + width, y + height);\n    } else {\n      context.moveTo(x + width, y + height);\n    }\n    // bottom\n    if (stroke[2]) {\n      context.lineTo(x, y + height);\n    } else {\n      context.moveTo(x, y + height);\n    }\n    // left\n    if (stroke[3]) {\n      // 没有close path是，起点和终点不连续，需要调整y保证不出现缺口\n      const adjustY = stroke[0] ? y - context.lineWidth / 2 : y;\n      context.lineTo(x, adjustY);\n    } else {\n      context.moveTo(x, y);\n    }\n\n    context.stroke();\n  }\n}\n\nexport const defaultRectRenderContribution = new DefaultRectRenderContribution();\n// export const splitRectBeforeRenderContribution = new SplitRectBeforeRenderContribution();\n// export const splitRectAfterRenderContribution = new SplitRectAfterRenderContribution();\nexport const defaultRectTextureRenderContribution = defaultBaseTextureRenderContribution;\nexport const defaultRectBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;\n"]}