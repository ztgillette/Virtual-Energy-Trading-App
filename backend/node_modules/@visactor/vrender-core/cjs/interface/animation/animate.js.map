{"version":3,"sources":["../src/interface/animation/animate.ts"],"names":[],"mappings":";;;AAyKA,IAAY,WAGX;AAHD,WAAY,WAAW;IACrB,iDAAe,CAAA;IACf,6EAA6B,CAAA;AAC/B,CAAC,EAHW,WAAW,GAAX,mBAAW,KAAX,mBAAW,QAGtB","file":"animate.js","sourcesContent":["import type { IGraphic } from '../graphic';\nimport type { EasingType, EasingTypeFunc } from './easing';\nimport type { AnimateStatus, IAnimateStepType } from './type';\nimport type { ITimeline } from './timeline';\n\nexport interface ICustomAnimate extends IStep {\n  type: IAnimateStepType;\n}\n\nexport interface IStep {\n  type: IAnimateStepType;\n  prev?: IStep;\n  // 持续时间\n  duration: number;\n  // 链表，下一个\n  next?: IStep;\n  // 属性\n  props?: Record<string, any>;\n  // 解析后的属性（用于性能优化，避免每次tick都解析）\n  fromParsedProps?: Record<string, any>;\n  toParsedProps?: Record<string, any>;\n  fromProps?: Record<string, any>;\n  // 解析后的属性列表（用于性能优化，避免每次tick都解析）\n  propKeys?: string[];\n  // 缓动函数\n  easing?: EasingTypeFunc;\n\n  // 添加一个\n  append: (step: IStep) => void;\n  // 获取上一个props，用于完成这次的fromValue 和 toValue的插值\n  getLastProps: () => any;\n\n  animate: IAnimate;\n\n  // 设置持续时间\n  setDuration: (duration: number, updateDownstream?: boolean) => void;\n  // 获取持续时间\n  getDuration: () => number;\n  // 确定插值更新函数（在开始的时候就确定，避免每次tick都解析）\n  determineInterpolateUpdateFunction: () => void;\n\n  // 设置开始时间\n  setStartTime: (time: number, updateDownstream?: boolean) => void;\n  // 获取开始时间\n  getStartTime: () => number;\n\n  bind: (target: IGraphic, animate: IAnimate) => void;\n  // 在第一次绑定到Animate的时候触发\n  onBind: () => void;\n  // 第一次执行的时候调用\n  onFirstRun: () => void;\n  // 开始执行的时候调用（如果有循环，那每个周期都会调用）\n  onStart: () => void;\n  // 结束执行的时候调用（如果有循环，那每个周期都会调用）\n  onEnd: (cb?: (animate: IAnimate, step: IStep) => void) => void;\n  // 更新执行的时候调用（如果有循环，那每个周期都会调用）\n  update: (end: boolean, ratio: number, out: Record<string, any>) => void;\n  onUpdate: (end: boolean, ratio: number, out: Record<string, any>) => void;\n\n  getEndProps: () => Record<string, any> | void;\n  getFromProps: () => Record<string, any> | void;\n  getMergedEndProps: () => Record<string, any> | void;\n\n  // 屏蔽自身属性，会直接从props等内容里删除掉\n  deleteSelfAttr: (key: string) => void;\n\n  // 停止\n  stop: () => void;\n\n  // 释放\n  release: () => void;\n}\n\nexport interface IAnimate {\n  readonly id: string | number;\n  status: AnimateStatus;\n  target: IGraphic;\n  priority: number;\n  interpolateUpdateFunction:\n    | ((from: Record<string, any>, to: Record<string, any>, ratio: number, step: IStep, target: IGraphic) => void)\n    | null;\n\n  _onStart?: (() => void)[];\n  _onFrame?: ((step: IStep, ratio: number) => void)[];\n  _onEnd?: (() => void)[];\n  _onRemove?: (() => void)[];\n\n  getStartProps: () => Record<string, any>;\n  getEndProps: () => Record<string, any>;\n\n  // 设置timeline\n  setTimeline: (timeline: ITimeline) => void;\n  // 获取timeline\n  getTimeline: () => ITimeline;\n  readonly timeline: ITimeline;\n\n  bind: (target: IGraphic) => this;\n  to: (props: Record<string, any>, duration: number, easing: EasingType) => this;\n  from: (props: Record<string, any>, duration: number, easing: EasingType) => this;\n  pause: () => void;\n  resume: () => void;\n  onStart: (cb?: () => void) => void;\n  onEnd: (cb?: () => void) => void;\n  onFrame: (cb: (step: IStep, ratio: number) => void) => void;\n  onRemove: (cb?: () => void) => void;\n  // 屏蔽属性\n  preventAttr: (key: string) => void;\n  // 屏蔽属性\n  preventAttrs: (key: string[]) => void;\n  // 属性是否合法\n  validAttr: (key: string) => boolean;\n\n  runCb: (cb: (a: IAnimate, step: IStep) => void) => IAnimate;\n\n  // 自定义插值，返回false表示没有匹配上\n  customInterpolate: (\n    key: string,\n    ratio: number,\n    from: any,\n    to: any,\n    target: IGraphic,\n    ret: Record<string, any>\n  ) => boolean;\n  play: (customAnimate: ICustomAnimate) => this;\n\n  getFromValue: () => Record<string, any>;\n  getToValue: () => Record<string, any>;\n  // 停止，可以设置停止后设置target的属性为开始的值（fromValue），还是结束的值（toValue）\n  stop: (type?: 'start' | 'end' | Record<string, any>) => void;\n  /** 打上END标志，下一帧被删除 */\n  release: () => void;\n  // 获取持续的时长\n  getDuration: () => number;\n  getTotalDuration: () => number;\n  // 获取动画开始时间（注意并不是子动画的startAt）\n  getStartTime: () => number;\n  // 等待delay\n  wait: (delay: number) => this;\n\n  /* 动画编排 */\n  // 所有动画结束后执行\n  afterAll: (list: IAnimate[]) => this;\n  // 在某个动画结束后执行\n  after: (animate: IAnimate) => this;\n  // 并行执行\n  parallel: (animate: IAnimate) => this;\n\n  getLoop: () => number;\n\n  // 反转动画\n  // reversed: (r: boolean) => IAnimate;\n  // 循环动画\n  loop: (n: number | boolean) => IAnimate;\n  // 反弹动画\n  bounce: (b: boolean) => IAnimate;\n\n  advance: (delta: number) => void;\n\n  // 设置开始时间（startAt之前是完全不会进入动画生命周期的）\n  // 它和wait不一样，如果调用的是wait，wait过程中还算是一个动画阶段，只是空的阶段，而startAt之前是完全不会进入动画生命周期的\n  startAt: (t: number) => IAnimate;\n\n  // 重新同步和计算props，用于内部某些step发生了变更后，重新计算自身\n  reSyncProps: () => void;\n\n  // 更新duration\n  updateDuration: () => void;\n}\n\nexport enum AnimateMode {\n  NORMAL = 0b0000,\n  SET_ATTR_IMMEDIATELY = 0b0001\n}\n\nexport interface IAnimateTarget {\n  onAnimateBind?: (animte: IAnimate) => void;\n  // 获取属性\n  getComputedAttribute: (name: string) => any;\n  // 获取默认属性\n  getDefaultAttribute: (name: string) => any;\n  onStop: (props?: Record<string, any>) => void;\n  animates: Map<string | number, IAnimate>;\n  [key: string]: any;\n}\n\nexport interface BaseAnimateConfig {\n  id?: number | string;\n  interpolate?: (key: string, ratio: number, from: any, to: any, nextAttributes: any) => boolean;\n  onStart?: () => void;\n  onFrame?: (step: IStep, ratio: number) => void;\n  onEnd?: () => void;\n  onRemove?: () => void;\n}\n\nexport interface MorphingAnimateConfig extends Omit<BaseAnimateConfig, 'interpolate'> {\n  duration?: number;\n  easing?: EasingType; // 统一到easing\n  delay?: number;\n}\n\nexport interface MultiMorphingAnimateConfig extends MorphingAnimateConfig {\n  splitPath?: 'clone' | ((graphic: IGraphic, count: number, needAppend?: boolean) => IGraphic[]);\n  individualDelay?: (index: number, count: number, fromGraphic: IGraphic, toGraphic: IGraphic) => number;\n}\n"]}