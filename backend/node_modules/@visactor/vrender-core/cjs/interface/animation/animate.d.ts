import type { IGraphic } from '../graphic';
import type { EasingType, EasingTypeFunc } from './easing';
import type { AnimateStatus, IAnimateStepType } from './type';
import type { ITimeline } from './timeline';
export interface ICustomAnimate extends IStep {
    type: IAnimateStepType;
}
export interface IStep {
    type: IAnimateStepType;
    prev?: IStep;
    duration: number;
    next?: IStep;
    props?: Record<string, any>;
    fromParsedProps?: Record<string, any>;
    toParsedProps?: Record<string, any>;
    fromProps?: Record<string, any>;
    propKeys?: string[];
    easing?: EasingTypeFunc;
    append: (step: IStep) => void;
    getLastProps: () => any;
    animate: IAnimate;
    setDuration: (duration: number, updateDownstream?: boolean) => void;
    getDuration: () => number;
    determineInterpolateUpdateFunction: () => void;
    setStartTime: (time: number, updateDownstream?: boolean) => void;
    getStartTime: () => number;
    bind: (target: IGraphic, animate: IAnimate) => void;
    onBind: () => void;
    onFirstRun: () => void;
    onStart: () => void;
    onEnd: (cb?: (animate: IAnimate, step: IStep) => void) => void;
    update: (end: boolean, ratio: number, out: Record<string, any>) => void;
    onUpdate: (end: boolean, ratio: number, out: Record<string, any>) => void;
    getEndProps: () => Record<string, any> | void;
    getFromProps: () => Record<string, any> | void;
    getMergedEndProps: () => Record<string, any> | void;
    deleteSelfAttr: (key: string) => void;
    stop: () => void;
    release: () => void;
}
export interface IAnimate {
    readonly id: string | number;
    status: AnimateStatus;
    target: IGraphic;
    priority: number;
    interpolateUpdateFunction: ((from: Record<string, any>, to: Record<string, any>, ratio: number, step: IStep, target: IGraphic) => void) | null;
    _onStart?: (() => void)[];
    _onFrame?: ((step: IStep, ratio: number) => void)[];
    _onEnd?: (() => void)[];
    _onRemove?: (() => void)[];
    getStartProps: () => Record<string, any>;
    getEndProps: () => Record<string, any>;
    setTimeline: (timeline: ITimeline) => void;
    getTimeline: () => ITimeline;
    readonly timeline: ITimeline;
    bind: (target: IGraphic) => this;
    to: (props: Record<string, any>, duration: number, easing: EasingType) => this;
    from: (props: Record<string, any>, duration: number, easing: EasingType) => this;
    pause: () => void;
    resume: () => void;
    onStart: (cb?: () => void) => void;
    onEnd: (cb?: () => void) => void;
    onFrame: (cb: (step: IStep, ratio: number) => void) => void;
    onRemove: (cb?: () => void) => void;
    preventAttr: (key: string) => void;
    preventAttrs: (key: string[]) => void;
    validAttr: (key: string) => boolean;
    runCb: (cb: (a: IAnimate, step: IStep) => void) => IAnimate;
    customInterpolate: (key: string, ratio: number, from: any, to: any, target: IGraphic, ret: Record<string, any>) => boolean;
    play: (customAnimate: ICustomAnimate) => this;
    getFromValue: () => Record<string, any>;
    getToValue: () => Record<string, any>;
    stop: (type?: 'start' | 'end' | Record<string, any>) => void;
    release: () => void;
    getDuration: () => number;
    getTotalDuration: () => number;
    getStartTime: () => number;
    wait: (delay: number) => this;
    afterAll: (list: IAnimate[]) => this;
    after: (animate: IAnimate) => this;
    parallel: (animate: IAnimate) => this;
    getLoop: () => number;
    loop: (n: number | boolean) => IAnimate;
    bounce: (b: boolean) => IAnimate;
    advance: (delta: number) => void;
    startAt: (t: number) => IAnimate;
    reSyncProps: () => void;
    updateDuration: () => void;
}
export declare enum AnimateMode {
    NORMAL = 0,
    SET_ATTR_IMMEDIATELY = 1
}
export interface IAnimateTarget {
    onAnimateBind?: (animte: IAnimate) => void;
    getComputedAttribute: (name: string) => any;
    getDefaultAttribute: (name: string) => any;
    onStop: (props?: Record<string, any>) => void;
    animates: Map<string | number, IAnimate>;
    [key: string]: any;
}
export interface BaseAnimateConfig {
    id?: number | string;
    interpolate?: (key: string, ratio: number, from: any, to: any, nextAttributes: any) => boolean;
    onStart?: () => void;
    onFrame?: (step: IStep, ratio: number) => void;
    onEnd?: () => void;
    onRemove?: () => void;
}
export interface MorphingAnimateConfig extends Omit<BaseAnimateConfig, 'interpolate'> {
    duration?: number;
    easing?: EasingType;
    delay?: number;
}
export interface MultiMorphingAnimateConfig extends MorphingAnimateConfig {
    splitPath?: 'clone' | ((graphic: IGraphic, count: number, needAppend?: boolean) => IGraphic[]);
    individualDelay?: (index: number, count: number, fromGraphic: IGraphic, toGraphic: IGraphic) => number;
}
