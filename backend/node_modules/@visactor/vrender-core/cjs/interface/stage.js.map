{"version":3,"sources":["../src/interface/stage.ts"],"names":[],"mappings":"","file":"stage.js","sourcesContent":["import type { INode } from './node-tree';\nimport type { ILayer, LayerMode } from './layer';\nimport type { IColor } from './color';\nimport type { IAABBBounds, IBounds, IBoundsLike, IMatrix } from '@visactor/vutils';\nimport type { ICamera } from './camera';\nimport type { vec3 } from './matrix';\nimport type { IDirectionLight } from './light';\nimport type { ISyncHook } from './sync-hook';\nimport type { IDrawContext, IRenderService, IRenderServiceDrawParams } from './render';\nimport type { ITicker, ITimeline } from './animation';\nimport type { IPickerService, PickResult } from './picker';\nimport type { IPlugin, IPluginService } from './plugin';\nimport type { IWindow } from './window';\nimport type { ILayerService } from './core';\nimport type { IFullThemeSpec } from './graphic/theme';\nimport type { IGraphicService } from './graphic-service';\n\nexport type IExportType = 'canvas' | 'imageData';\n\nexport type IStageCreateContext = {\n  appName?: 'vchart' | 'vgrammar' | 'vtable' | string;\n};\nexport interface IStageParams {\n  // x: number;\n  // y: number;\n  // // 视口的宽高\n  // viewWidth: number;\n  // viewHeight: number;\n\n  // 视口的宽高\n  viewBox: IBoundsLike;\n  // 总的宽高\n  width: number;\n  height: number;\n  dpr: number;\n  // stage的背景\n  background: string | IColor;\n  // 外部的canvas\n  canvas: string | HTMLCanvasElement;\n  // canvas的container容器，如果不传入canvas，那就会在容器中创建canvas\n  container: string | HTMLElement;\n  // 是否是受控制的canvas，如果不是的话，不会进行resize等操作，也不会修改canvas的样式\n  canvasControled: boolean;\n  title: string;\n  // 是否开启自动渲染\n  autoRender: boolean;\n  // 是否开启自动刷新\n  autoRefresh: boolean;\n  // 是否开启布局支持\n  enableLayout: boolean;\n  // 是否关闭脏矩形检测\n  disableDirtyBounds: boolean;\n  // 是否支持interactiveLayer，默认为true\n  interactiveLayer: boolean;\n  // 是否支持HTML属性\n  enableHtmlAttribute: string | boolean | HTMLElement;\n  // 是否支持react-dom(传入ReactDOM)\n  ReactDOM: any;\n  // 是否支持滚动条\n  enableScroll: boolean;\n  poptip: boolean;\n  // 绘制之前的钩子函数\n  beforeRender: (stage: IStage) => void;\n  // 绘制之后的钩子函数\n  afterRender: (stage: IStage) => void;\n  // 清屏之后的钩子函数\n  afterClearScreen: (drawParams: any) => void;\n  // 清除矩形区域之后的钩子函数\n  afterClearRect: (drawParams: any) => void;\n\n  renderStyle?: string;\n  ticker?: ITicker;\n  pluginList?: string[];\n  // 优化配置\n  optimize?: IOptimizeType;\n  /**\n   * 事件系统相关配置\n   */\n  event?: EventConfig;\n\n  /**\n   * @since 0.17.15\n   * 是否支持touch事件，不支持就不监听touch事件\n   */\n  supportsTouchEvents?: boolean;\n\n  /**\n   * @since 0.17.15\n   * 是否支持pointer事件，不支持就监听mouse事件\n   */\n  supportsPointerEvents?: boolean;\n\n  context?: IStageCreateContext;\n\n  // 被分配的rafId，用于renderNextFrame，避免使用大量原生的RAF\n  rafId?: number;\n}\n\nexport type EventConfig = {\n  /** 是否自动阻止事件 */\n  autoPreventDefault?: boolean;\n  /**\n   * 多次点击之间的最大时间，默认为 200 ms\n   * @default 200\n   */\n  clickInterval?: number;\n  [key: string]: any;\n};\n\nexport type IOptimizeType = {\n  // 视口不在可视区，跳过渲染，默认为true\n  skipRenderWithOutRange?: boolean;\n  // 跳过图元在区间外的判断\n  // 不存在dirtyBounds的时候，根据该配置判断是否关闭图元的超出边界判定\n  // 如果有dirtyBounds那么该配置不生效\n  disableCheckGraphicWidthOutRange?: boolean;\n  // tick渲染模式，effect会在tick之后立刻执行render，保证动画效果正常。performance模式中tick和render均是RAF，属性可能会被篡改\n  // 是否开启高性能动画，默认开启\n  // 开启后不会执行某些安全校验，比如跳帧处理\n  // 开启后会自动降帧，最高60fps\n  tickRenderMode?: 'effect' | 'performance';\n};\n\nexport interface IOption3D {\n  enableView3dTransform?: boolean; // 是否开启view3d自动旋转\n  alpha?: number; // x轴的转角\n  beta?: number; // y轴的转角\n  gama?: number; // z轴的转角\n  center?: { x?: number; y?: number; z?: number; dx?: number; dy?: number; dz?: number }; // 中心位置\n  fieldRatio?: number; // 透视的视域缩放比例\n  fieldDepth?: number;\n  light?: {\n    dir?: vec3;\n    color?: string;\n    ambient?: number;\n  };\n  // 配置相机后，alpha、beta、gamma配置会失效\n  camera?: any; // 相机配置\n}\n\n// TODO 命名方式\nexport interface IStage extends INode {\n  stage?: IStage;\n  parent: IStage | null;\n  // rootNode: IStage;\n  x: number;\n  y: number;\n\n  params: Partial<IStageParams>;\n\n  window: IWindow;\n\n  width: number;\n  height: number;\n  viewWidth: number;\n  viewHeight: number;\n  defaultLayer: ILayer;\n  dirtyBounds: IBounds | null;\n\n  autoRender: boolean;\n  renderCount: number;\n\n  hooks: {\n    beforeRender: ISyncHook<[IStage]>;\n    afterRender: ISyncHook<[IStage]>;\n    afterClearScreen: ISyncHook<[IRenderServiceDrawParams]>;\n    afterClearRect: ISyncHook<[IRenderServiceDrawParams]>;\n  };\n\n  option3d?: IOption3D;\n\n  set3dOptions: (options: IOption3D) => void;\n  light?: IDirectionLight;\n  camera?: ICamera;\n\n  dpr: number;\n\n  viewBox: IBoundsLike;\n  background: string | IColor;\n  ticker: ITicker;\n  increaseAutoRender: boolean;\n  readonly renderService: IRenderService;\n  readonly graphicService: IGraphicService;\n  getPickerService: () => IPickerService;\n  readonly pluginService: IPluginService;\n  readonly layerService: ILayerService;\n  // 如果传入CanvasId，如果存在相同Id，说明这两个图层使用相同的Canvas绘制\n  // 但需要注意的是依然是两个图层（用于解决Table嵌入ChartSpace不影响Table的绘制）\n  createLayer: (canvasId?: string, layerMode?: LayerMode) => ILayer;\n  getLayer: (name: string) => ILayer;\n  sortLayer: (cb: (layer1: ILayer, layer2: ILayer) => number) => void;\n  removeLayer: (layerId: number) => ILayer | false;\n\n  getTimeline: () => ITimeline;\n\n  render: (layers?: ILayer[], params?: Partial<IDrawContext>) => void;\n  /**\n   * 下一帧渲染\n   * @param layers 渲染的图层\n   * @param force 是否强行下一帧渲染，不采取优化方案\n   * @returns\n   */\n  renderNextFrame: (layers?: ILayer[], force?: boolean) => void;\n  tryInitInteractiveLayer: () => void;\n\n  // 画布操作\n  resize: (w: number, h: number, rerender?: boolean) => void;\n  resizeWindow: (w: number, h: number, rerender?: boolean) => void;\n  resizeView: (w: number, h: number, rerender?: boolean) => void;\n  setViewBox:\n    | ((viewBox: IBoundsLike, rerender: boolean) => void)\n    | ((x: number, y: number, w: number, h: number, rerender: boolean) => void)\n    | ((x: number | IBoundsLike, y: number | boolean, w?: number, h?: number, rerender?: boolean) => void);\n  setDpr: (dpr: number, rerender?: boolean) => void;\n  setOrigin: (x: number, y: number) => void;\n  export: (type: IExportType) => HTMLCanvasElement | ImageData;\n  pick: (x: number, y: number) => PickResult | false;\n\n  // 动画相关\n  startAnimate: (t: number) => void;\n  setToFrame: (t: number) => void;\n  dirty: (b: IBounds, matrix?: IMatrix) => void;\n  // 考虑操作回放\n\n  renderTo: (window: IWindow, params: { x: number; y: number; width: number; height: number }) => void;\n\n  renderToNewWindow: (fullImage?: boolean) => IWindow;\n\n  toCanvas: (fullImage?: boolean, viewBox?: IAABBBounds) => HTMLCanvasElement | null;\n\n  setBeforeRender: (cb: (stage: IStage) => void) => void;\n  removeBeforeRender: (cb: (stage: IStage) => void) => void;\n  setAfterRender: (cb: (stage: IStage) => void) => void;\n  removeAfterRender: (cb: (stage: IStage) => void) => void;\n  afterNextRender: (cb: (stage: IStage) => void) => void;\n  enableAutoRender: () => void;\n  disableAutoRender: () => void;\n  enableIncrementalAutoRender: () => void;\n  disableIncrementalAutoRender: () => void;\n  enableDirtyBounds: () => void;\n  disableDirtyBounds: () => void;\n  enableView3dTransform: () => void;\n  disableView3dTranform: () => void;\n  getPluginsByName: (name: string) => IPlugin[];\n  clearViewBox: (color?: string) => void;\n  release: () => void;\n  setStage: (stage?: IStage) => void;\n\n  pauseRender: (sk?: number) => void;\n  resumeRender: () => void;\n\n  setCursor: (mode?: string) => void;\n\n  getTheme: () => IFullThemeSpec;\n  eventPointTransform: (e: PointerEvent | WheelEvent | TouchEvent) => { x: number; y: number };\n  pauseTriggerEvent: () => void;\n  resumeTriggerEvent: () => void;\n\n  pauseAnimation?: (deep?: boolean) => void;\n  resumeAnimation?: (deep?: boolean) => void;\n  stopAnimation?: (deep?: boolean) => void;\n  reApplyAnimationState?: (state: string, deep?: boolean) => this;\n}\n\nexport declare function combineStage(srages: IStage[], params: { canvas: string | HTMLCanvasElement }): IStage;\n"]}