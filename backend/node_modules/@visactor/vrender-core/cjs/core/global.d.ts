import type { CreateDOMParamsType, EnvType, IContributionProvider, ICreateCanvasParams, IEnvContribution, IEnvParamsMap, IGlobal, ISyncHook } from '../interface';
import type { IAABBBoundsLike } from '@visactor/vutils';
import { EventListenerManager } from '../common/event-listener-manager';
export declare class DefaultGlobal extends EventListenerManager implements IGlobal {
    protected readonly contributions: IContributionProvider<IEnvContribution>;
    readonly id: number;
    private _env;
    private _isSafari?;
    private _isChrome?;
    private _isImageAnonymous?;
    private _performanceRAFList;
    get env(): EnvType;
    private envContribution;
    get isImageAnonymous(): boolean;
    set isImageAnonymous(isImageAnonymous: boolean);
    get devicePixelRatio(): number;
    get supportEvent(): boolean;
    set supportEvent(support: boolean);
    get supportsTouchEvents(): boolean;
    set supportsTouchEvents(support: boolean);
    get supportsPointerEvents(): boolean;
    set supportsPointerEvents(support: boolean);
    get supportsMouseEvents(): boolean;
    set supportsMouseEvents(support: boolean);
    get applyStyles(): boolean;
    set applyStyles(support: boolean);
    optimizeVisible: boolean;
    envParams?: any;
    measureTextMethod: 'native' | 'simple' | 'quick';
    hooks: {
        onSetEnv: ISyncHook<[EnvType | undefined, EnvType, IGlobal]>;
    };
    eventListenerTransformer: (event: Event) => Event;
    constructor(contributions: IContributionProvider<IEnvContribution>);
    protected _nativeAddEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    protected _nativeRemoveEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    protected _nativeDispatchEvent(event: Event): boolean;
    protected bindContribution(params?: any): void | Promise<any>;
    getDynamicCanvasCount(): number;
    getStaticCanvasCount(): number;
    setEnv(env: EnvType, params?: IEnvParamsMap[EnvType]): void | Promise<any>;
    protected deactiveCurrentEnv(): void;
    protected activeEnv(env: EnvType, params?: IEnvParamsMap[EnvType]): void | Promise<any>;
    setActiveEnvContribution(contribution: IEnvContribution): void;
    createCanvas(params: ICreateCanvasParams): any;
    createOffscreenCanvas(params: ICreateCanvasParams): any;
    releaseCanvas(canvas: HTMLCanvasElement | string | any): void;
    getRequestAnimationFrame(): (callback: FrameRequestCallback) => number;
    getSpecifiedRequestAnimationFrame(id: number): (callback: FrameRequestCallback) => number;
    getSpecifiedCancelAnimationFrame(id: number): (handle: number) => boolean;
    getCancelAnimationFrame(): (h: number) => void;
    getElementById(str: string): HTMLElement | null;
    getRootElement(): HTMLElement | null;
    getDocument(): Document | null;
    mapToCanvasPoint(event: any, domElement?: any): import("@visactor/vutils").IPointLike;
    loadImage(url: string): Promise<{
        loadState: "success" | "fail";
        data: HTMLImageElement | ImageData;
    }>;
    loadSvg(str: string): Promise<{
        loadState: "success" | "fail";
        data: HTMLImageElement | ImageData;
    }>;
    loadJson(url: string): Promise<{
        loadState: "success" | "fail";
        data: Record<string, unknown>;
    }>;
    loadArrayBuffer(url: string): Promise<{
        loadState: "success" | "fail";
        data: ArrayBuffer;
    }>;
    loadBlob(url: string): Promise<{
        loadState: "success" | "fail";
        data: Blob;
    }>;
    loadFont(name: string, source: string | ArrayBuffer, descriptors?: FontFaceDescriptors): Promise<{
        loadState: "success" | "fail";
    }>;
    isChrome(): boolean;
    isSafari(): boolean;
    getNativeAABBBounds(dom: string | HTMLElement | any): IAABBBoundsLike;
    removeDom(dom: HTMLElement): boolean;
    createDom(params: CreateDOMParamsType): HTMLElement | null;
    updateDom(dom: HTMLElement, params: CreateDOMParamsType): boolean;
    getElementTop(dom: any, baseWindow?: boolean): number;
    getElementLeft(dom: any, baseWindow?: boolean): number;
    getElementTopLeft(dom: any, baseWindow?: boolean): {
        top: number;
        left: number;
    };
    isMacOS(): boolean;
    copyToClipBoard(text: string): Promise<void>;
}
