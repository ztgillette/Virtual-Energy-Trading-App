"use strict";

var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
}, __param = this && this.__param || function(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultTransformUtil = exports.DefaultGraphicUtil = void 0;

const inversify_lite_1 = require("../common/inversify-lite"), textMeasure_contribution_1 = require("./contributions/textMeasure/textMeasure-contribution"), contribution_provider_1 = require("../common/contribution-provider"), config_1 = require("../graphic/config"), vutils_1 = require("@visactor/vutils"), canvas_allocate_1 = require("../allocator/canvas-allocate"), application_1 = require("../application"), container_1 = require("../container"), window_1 = require("./window");

let DefaultGraphicUtil = class {
    get canvas() {
        return this.tryInitCanvas(), this._canvas;
    }
    get context() {
        return this.tryInitCanvas(), this._context;
    }
    constructor(contributions) {
        this.contributions = contributions, this.configured = !1, this.global = application_1.application.global, 
        this.global.hooks.onSetEnv.tap("graphic-util", ((lastEnv, env, global) => {
            this.configured = !1, this.configure(global, env);
        }));
    }
    get textMeasure() {
        return this._textMeasure || this.configure(this.global, this.global.env), this._textMeasure;
    }
    configure(global, env) {
        this.configured || (this.contributions.getContributions().forEach((contribution => {
            contribution.configure(this, env);
        })), this.configured = !0);
    }
    tryInitCanvas() {
        if (!this._canvas) {
            const canvas = canvas_allocate_1.canvasAllocate.shareCanvas();
            this._canvas = canvas, this._context = canvas.getContext("2d");
        }
    }
    bindTextMeasure(tm) {
        this._textMeasure = tm;
    }
    measureText(text, tc, method = "native") {
        var _a;
        this.configure(this.global, this.global.env);
        const m = this.global.measureTextMethod;
        this.global.measureTextMethod = method;
        const data = {
            width: this._textMeasure.measureTextWidth(text, tc),
            height: null !== (_a = tc.fontSize) && void 0 !== _a ? _a : config_1.DefaultTextStyle.fontSize
        };
        return this.global.measureTextMethod = m, data;
    }
    createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {
        return this.configure(this.global, this.global.env), new vutils_1.TextMeasure(Object.assign({
            defaultFontParams: {
                fontFamily: config_1.DefaultTextStyle.fontFamily,
                fontSize: config_1.DefaultTextStyle.fontSize
            },
            getCanvasForMeasure: getCanvasForMeasure || (() => this.canvas),
            getTextBounds: void 0,
            specialCharSet: "-/: .,@%'\"~" + vutils_1.TextMeasure.ALPHABET_CHAR_SET + vutils_1.TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
        }, null != option ? option : {}), textSpec);
    }
    drawGraphicToCanvas(graphic, stage, canvas) {
        if (!stage.defaultLayer) return null;
        const window = container_1.container.get(window_1.VWindow), bounds = graphic.AABBBounds, width = bounds.width(), height = bounds.height(), x1 = -bounds.x1, y1 = -bounds.y1;
        window.create({
            viewBox: {
                x1: x1,
                y1: y1,
                x2: bounds.x2,
                y2: bounds.y2
            },
            width: width,
            height: height,
            canvas: canvas,
            dpr: stage.window.dpr,
            canvasControled: !0,
            offscreen: !0,
            title: ""
        });
        const disableCheckGraphicWidthOutRange = stage.params.optimize.disableCheckGraphicWidthOutRange;
        stage.params.optimize.disableCheckGraphicWidthOutRange = !0, stage.defaultLayer.getNativeHandler().drawTo(window, [ graphic ], {
            transMatrix: window.getViewBoxTransform(),
            viewBox: window.getViewBox(),
            stage: stage,
            layer: stage.defaultLayer,
            renderService: stage.renderService,
            background: "transparent",
            clear: !0,
            updateBounds: !1
        }), stage.params.optimize.disableCheckGraphicWidthOutRange = disableCheckGraphicWidthOutRange;
        const c = window.getNativeHandler();
        return c.nativeCanvas ? c.nativeCanvas : null;
    }
};

var TransformMode;

DefaultGraphicUtil = __decorate([ (0, inversify_lite_1.injectable)(), __param(0, (0, 
inversify_lite_1.inject)(contribution_provider_1.ContributionProvider)), __param(0, (0, 
inversify_lite_1.named)(textMeasure_contribution_1.TextMeasureContribution)), __metadata("design:paramtypes", [ Object ]) ], DefaultGraphicUtil), 
exports.DefaultGraphicUtil = DefaultGraphicUtil, function(TransformMode) {
    TransformMode[TransformMode.transform = 0] = "transform", TransformMode[TransformMode.matrix = 1] = "matrix";
}(TransformMode || (TransformMode = {}));

const _matrix = new vutils_1.Matrix;

let DefaultTransformUtil = class {
    constructor() {
        this.matrix = new vutils_1.Matrix;
    }
    init(origin) {
        return this.mode = TransformMode.transform, this.originTransform = origin, this.matrix.reset(), 
        this;
    }
    fromMatrix(source, target) {
        return this.mode = TransformMode.matrix, this.outSourceMatrix = source, this.outTargetMatrix = target, 
        this;
    }
    scaleMatrix(sx, sy, center) {
        const sMatrix = this.outSourceMatrix;
        if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), 
        this.outTargetMatrix.reset(), center) {
            const {x: x, y: y} = center;
            this.outTargetMatrix.translate(x, y), this.outTargetMatrix.scale(sx, sy), this.outTargetMatrix.translate(-x, -y);
        } else this.outTargetMatrix.scale(sx, sy);
        return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), 
        this;
    }
    rotateMatrix(angle, center) {
        const sMatrix = this.outSourceMatrix;
        if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), 
        this.outTargetMatrix.reset(), center) {
            const {x: x, y: y} = center;
            this.outTargetMatrix.translate(x, y), this.outTargetMatrix.rotate(angle), this.outTargetMatrix.translate(-x, -y);
        } else this.outTargetMatrix.rotate(angle);
        return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), 
        this;
    }
    scale(sx, sy, center) {
        return this.mode === TransformMode.matrix ? this.scaleMatrix(sx, sy, center) : this;
    }
    rotate(angle, center) {
        return this.mode === TransformMode.matrix ? this.rotateMatrix(angle, center) : this;
    }
    translateMatrix(dx, dy) {
        const sMatrix = this.outSourceMatrix;
        return _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), 
        this.outTargetMatrix.reset(), this.outTargetMatrix.translate(dx, dy), this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), 
        this;
    }
    translate(dx, dy) {
        return this.mode === TransformMode.matrix ? this.translateMatrix(dx, dy) : this;
    }
    simplify(target) {
        return this.mode === TransformMode.matrix ? this.simplifyMatrix(target) : this;
    }
    simplifyMatrix(target) {
        return this;
    }
};

DefaultTransformUtil = __decorate([ (0, inversify_lite_1.injectable)(), __metadata("design:paramtypes", []) ], DefaultTransformUtil), 
exports.DefaultTransformUtil = DefaultTransformUtil;
//# sourceMappingURL=graphic-utils.js.map
