import type { IPointLike } from '@visactor/vutils';
import { type IBoundsLike, type IMatrix, IBounds } from '@visactor/vutils';
import type { ICanvas, IContext2d, IDomRectLike, IGlobal, IWindow, IWindowHandlerContribution, IWindowParams } from '../interface';
import { SyncHook } from '../tapable';
import { EventListenerManager } from '../common/event-listener-manager';
export declare const VWindow: unique symbol;
export declare const WindowHandlerContribution: unique symbol;
export declare class DefaultWindow extends EventListenerManager implements IWindow {
    protected _width: number;
    protected _height: number;
    protected _handler: IWindowHandlerContribution;
    hooks: {
        onChange: SyncHook<[number, number, number, number], void, import("../interface").UnsetAdditionalOptions>;
    };
    parent: Window;
    get width(): number;
    get height(): number;
    _uid: number;
    resizable: boolean;
    minHeight: number;
    minWidth: number;
    maxHeight: number;
    maxWidth: number;
    title: string;
    mainCanvas: ICanvas;
    layerCanvas: ICanvas[];
    actived: boolean;
    global: IGlobal;
    get dpr(): number;
    constructor();
    protected _nativeAddEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    protected _nativeRemoveEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    protected _nativeDispatchEvent(event: Event): boolean;
    protected postInit(): void;
    protected active: () => void;
    get style(): CSSStyleDeclaration | Record<string, any>;
    set style(style: CSSStyleDeclaration | Record<string, any>);
    create(params: IWindowParams): void;
    setWindowHandler(handler: IWindowHandlerContribution): void;
    setDpr(dpr: number): void;
    resize(w: number, h: number): void;
    configure(): void;
    release(): void;
    getContext(): IContext2d;
    getNativeHandler(): ICanvas;
    getImageBuffer(type?: string): any;
    getBoundingClientRect(): IDomRectLike;
    getContainer(): HTMLElement | any;
    clearViewBox(color?: string): void;
    setViewBox(viewBox: IBoundsLike): void;
    setViewBoxTransform(a: number, b: number, c: number, d: number, e: number, f: number): void;
    getViewBox(): IBounds;
    getViewBoxTransform(): IMatrix;
    pointTransform(x: number, y: number): IPointLike;
    hasSubView(): boolean;
    isVisible(bbox?: IBoundsLike): boolean;
    onVisibleChange(cb: (currentVisible: boolean) => void): void;
    getTopLeft(baseWindow?: boolean): {
        top: number;
        left: number;
    };
}
