"use strict";

var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}, __metadata = this && this.__metadata || function(k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.OffscreenLayerHandlerContribution = void 0;

const inversify_lite_1 = require("../../../common/inversify-lite"), util_1 = require("../../../canvas/util"), application_1 = require("../../../application");

let OffscreenLayerHandlerContribution = class {
    constructor() {
        this.offscreen = !0, this.type = "dynamic", this.global = application_1.application.global;
    }
    setDpr(dpr) {
        this.canvas.dpr = dpr;
    }
    init(layer, window, params) {
        this.layer = layer;
        const nativeCanvas = this.global.createOffscreenCanvas({
            width: params.width,
            height: params.height,
            dpr: window.dpr
        }), canvas = (0, util_1.wrapCanvas)({
            nativeCanvas: nativeCanvas,
            width: params.width,
            height: params.height,
            dpr: window.dpr,
            canvasControled: !0
        });
        this.canvas = canvas, this.context = canvas.getContext();
    }
    resize(w, h) {
        this.canvas.resize(w, h);
    }
    resizeView(w, h) {
        this.canvas.resize(w, h);
    }
    render(group, params) {
        var _a;
        params.renderService.render(group, Object.assign(Object.assign({
            context: this.context,
            viewBox: params.stage.window.getViewBox(),
            transMatrix: params.stage.window.getViewBoxTransform()
        }, params), {
            clear: null !== (_a = params.background) && void 0 !== _a ? _a : "#ffffff"
        }));
    }
    prepare(dirtyBounds, params) {}
    release() {
        this.canvas.release();
    }
    getContext() {
        return this.context;
    }
    drawTo(target, group, params) {
        const context = target.getContext(), targetDpr = target.dpr, {viewBox: viewBox} = params, x = viewBox.x1, y = viewBox.y1, width = viewBox.width(), height = viewBox.height();
        context.nativeContext.save(), context.nativeContext.setTransform(targetDpr, 0, 0, targetDpr, 0, 0), 
        params.clear && context.clearRect(x, y, width, height), context.drawImage(this.canvas.nativeCanvas, 0, 0, this.canvas.width, this.canvas.height, x, y, width, height), 
        context.nativeContext.restore();
    }
    merge(layerHandlers) {}
};

OffscreenLayerHandlerContribution = __decorate([ (0, inversify_lite_1.injectable)(), __metadata("design:paramtypes", []) ], OffscreenLayerHandlerContribution), 
exports.OffscreenLayerHandlerContribution = OffscreenLayerHandlerContribution;
//# sourceMappingURL=offscreen2d-contribution.js.map
