import type { ICanvas, IContext2d, IDomRectLike, EnvType, IGlobal, IWindowHandlerContribution, IWindow, IWindowParams } from '../../../interface';
import { type IBounds, type IBoundsLike, type IMatrix } from '@visactor/vutils';
type OnchangeCbType = (params?: {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
}) => void;
export declare abstract class BaseWindowHandlerContribution implements IWindowHandlerContribution {
    type: EnvType;
    _uid: number;
    protected viewBox: IBounds;
    protected modelMatrix: IMatrix;
    constructor();
    protected _onChangeCb?: OnchangeCbType;
    onChange(cb: OnchangeCbType): void;
    configure(window: IWindow, global: IGlobal): void;
    release(...params: any): void;
    abstract createWindow(params: IWindowParams): void;
    abstract releaseWindow(): void;
    abstract setDpr(dpr: number): void;
    abstract resizeWindow(width: number, height: number): void;
    abstract getContext(): IContext2d;
    abstract getWH(): {
        width: number;
        height: number;
    };
    abstract getTitle(): string;
    abstract getXY(): {
        x: number;
        y: number;
    };
    abstract getNativeHandler(): ICanvas | any;
    abstract getDpr(): number;
    abstract clearViewBox(color?: string): void;
    abstract addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    abstract addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
    abstract removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    abstract removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    abstract dispatchEvent(event: any): boolean;
    abstract getStyle(): CSSStyleDeclaration | Record<string, any>;
    abstract setStyle(style: CSSStyleDeclaration | Record<string, any>): void;
    abstract getBoundingClientRect(): IDomRectLike;
    isVisible(bbox?: IBoundsLike): boolean;
    onVisibleChange(cb: (currentVisible: boolean) => void): void;
    getTopLeft(baseWindow?: boolean): {
        top: number;
        left: number;
    };
    setViewBox(vb: IBoundsLike): void;
    getViewBox(): IBounds;
    setViewBoxTransform(a: number, b: number, c: number, d: number, e: number, f: number): void;
    getViewBoxTransform(): IMatrix;
}
export {};
