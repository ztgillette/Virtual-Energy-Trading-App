"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createSymbol = exports.Symbol = void 0;

const vutils_1 = require("@visactor/vutils"), graphic_1 = require("./graphic"), theme_1 = require("./theme"), application_1 = require("../application"), custom_path2d_1 = require("../common/custom-path2d"), constants_1 = require("./constants"), symbol_outer_border_bounds_1 = require("./graphic-service/symbol-outer-border-bounds"), SYMBOL_UPDATE_TAG_KEY = [ "symbolType", "size", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Symbol extends graphic_1.Graphic {
    constructor(params = {
        symbolType: "circle"
    }) {
        super(params), this.type = "symbol", this.numberType = constants_1.SYMBOL_NUMBER_TYPE;
    }
    getParsedPath() {
        return this.shouldUpdateShape() && (this._parsedPath = this.doUpdateParsedPath(), 
        this.clearUpdateShapeTag()), this._parsedPath;
    }
    getParsedPath2D(x = 0, y = 0, size = 1) {
        let path = null;
        try {
            path = new Path2D;
        } catch (err) {
            return null;
        }
        const parsedPath = this.getParsedPath();
        if (!parsedPath) return null;
        parsedPath.draw(path, size, x, y);
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {size: size} = this.attribute;
        return (0, vutils_1.isArray)(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);
    }
    doUpdateParsedPath() {
        const {symbolType: symbolType = "circle"} = this.attribute;
        return super.parsePath(symbolType);
    }
    getGraphicTheme() {
        return (0, theme_1.getTheme)(this).symbol;
    }
    updateAABBBounds(attribute, symbolTheme, aabbBounds, full) {
        this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds));
        const {tb1: tb1, tb2: tb2} = application_1.application.graphicService.updateTempAABBBounds(aabbBounds);
        (0, symbol_outer_border_bounds_1.updateBoundsOfSymbolOuterBorder)(attribute, symbolTheme, tb1), 
        aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, 
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, this.x1WithoutTransform = aabbBounds.x1, 
        this.y1WithoutTransform = aabbBounds.y1;
        const {lineJoin: lineJoin = symbolTheme.lineJoin} = attribute;
        return application_1.application.graphicService.transformAABBBounds(attribute, aabbBounds, symbolTheme, "miter" === lineJoin, this), 
        aabbBounds;
    }
    updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) {
        const {size: size = symbolTheme.size} = attribute;
        if ((0, vutils_1.isArray)(size)) aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2); else {
            const halfWH = size / 2;
            aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
        }
        return aabbBounds;
    }
    updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds) {
        const {size: size = symbolTheme.size} = attribute;
        return this.getParsedPath().bounds(size, aabbBounds), aabbBounds;
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, SYMBOL_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, SYMBOL_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        const symbolInstance = this.getParsedPath(), size = this.attribute.size, formattedSize = (0, 
        vutils_1.isArray)(size) ? size : [ size, size ];
        return symbolInstance.path ? (new custom_path2d_1.CustomPath2D).fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : (new custom_path2d_1.CustomPath2D).fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);
    }
    clone() {
        return new Symbol(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Symbol.NOWORK_ANIMATE_ATTR;
    }
}

function createSymbol(attributes) {
    return new Symbol(attributes);
}

exports.Symbol = Symbol, Symbol.NOWORK_ANIMATE_ATTR = Object.assign({
    symbolType: 1
}, graphic_1.NOWORK_ANIMATE_ATTR), exports.createSymbol = createSymbol;
//# sourceMappingURL=symbol.js.map
