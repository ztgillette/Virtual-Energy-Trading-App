"use strict";

var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))((function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            var value;
            result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                resolve(value);
            }))).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    }));
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.Node = void 0;

const vutils_1 = require("@visactor/vutils"), generator_1 = require("../common/generator");

class Node extends vutils_1.EventEmitter {
    get previousSibling() {
        return this._prev;
    }
    get nextSibling() {
        return this._next;
    }
    get children() {
        return this.getChildren();
    }
    get firstChild() {
        return this._firstChild;
    }
    get lastChild() {
        return this._lastChild;
    }
    get count() {
        return this._count;
    }
    get childrenCount() {
        return this._idMap ? this._idMap.size : 0;
    }
    constructor() {
        super(), this._uid = generator_1.Generator.GenAutoIncrementId(), this._firstChild = null, 
        this._lastChild = null, this.parent = null, this._count = 1;
    }
    forEachChildren(cb, reverse = !1) {
        if (reverse) {
            let child = this._lastChild, i = 0;
            for (;child; ) {
                if (cb(child, i++)) return;
                child = child._prev;
            }
        } else {
            let child = this._firstChild, i = 0;
            for (;child; ) {
                if (cb(child, i++)) return;
                child = child._next;
            }
        }
    }
    forEachChildrenAsync(cb, reverse = !1) {
        return __awaiter(this, void 0, void 0, (function*() {
            if (reverse) {
                let child = this._lastChild, i = 0;
                for (;child; ) {
                    let breakTag = cb(child, i++);
                    if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
                    child = child._prev;
                }
            } else {
                let child = this._firstChild, i = 0;
                for (;child; ) {
                    let breakTag = cb(child, i++);
                    if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
                    child = child._next;
                }
            }
        }));
    }
    forEach(cb) {
        return this.forEachChildren(cb);
    }
    appendChild(node, highPerformance = !0) {
        if (this._uid === node._uid) return null;
        if (!highPerformance && node.isAncestorsOf(this)) throw new Error("【Node::appendChild】不能将父辈元素append为子元素");
        return node.parent && node.parent.removeChild(node), node.parent = this, this._lastChild ? (this._lastChild._next = node, 
        node._prev = this._lastChild, this._lastChild = node) : (this._firstChild = this._lastChild = node, 
        node._prev = node._next = null), this._idMap || (this._idMap = new Map), this._idMap.set(node._uid, node), 
        this.setCount(node.count), this._structEdit = !0, node;
    }
    appendChildArrHighPerformance(nodes, replace = !1) {
        return console.error("暂不支持该函数"), nodes;
    }
    insertBefore(newNode, referenceNode) {
        if (!referenceNode) return this.appendChild(newNode);
        if (this === newNode || newNode === referenceNode) return null;
        if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
        return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), 
        newNode.parent = this, newNode._prev = referenceNode._prev, referenceNode._prev ? referenceNode._prev._next = newNode : this._firstChild = newNode, 
        referenceNode._prev = newNode, newNode._next = referenceNode, this._idMap || (this._idMap = new Map), 
        this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), 
        newNode);
    }
    insertAfter(newNode, referenceNode) {
        if (!referenceNode) return this.appendChild(newNode);
        if (this === newNode || newNode === referenceNode) return null;
        if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertAfter】不能将父辈元素insert为子元素");
        return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), 
        newNode.parent = this, referenceNode._next ? (referenceNode._next._prev = newNode, 
        newNode._next = referenceNode._next) : this._lastChild = newNode, referenceNode._next = newNode, 
        newNode._prev = referenceNode, this._idMap || (this._idMap = new Map), this._idMap.set(newNode._uid, newNode), 
        this._structEdit = !0, this.setCount(newNode.count), newNode);
    }
    insertInto(newNode, idx) {
        if (!this._ignoreWarn && this._nodeList && vutils_1.Logger.getInstance().warn("insertIntoKeepIdx和insertInto混用可能会存在错误"), 
        idx >= this.childrenCount) return this.appendChild(newNode);
        if (this === newNode) return null;
        if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
        if (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, 
        0 === idx) newNode._next = this._firstChild, this._firstChild && (this._firstChild._prev = newNode), 
        newNode._prev = null, this._firstChild = newNode; else {
            let child = this._firstChild;
            for (let i = 0; i < idx; i++) {
                if (!child) return null;
                i > 0 && (child = child._next);
            }
            if (!child) return null;
            newNode._next = child._next, newNode._prev = child, child._next = newNode, newNode._next && (newNode._next._prev = newNode);
        }
        return this._idMap || (this._idMap = new Map), this._idMap.set(newNode._uid, newNode), 
        this._structEdit = !0, this.setCount(newNode.count), newNode;
    }
    insertIntoKeepIdx(newNode, idx) {
        if (this._nodeList || (this._nodeList = this.children), this._nodeList[idx]) {
            const node = this._nodeList[idx];
            return this._nodeList.splice(idx, 0, newNode), this.insertBefore(newNode, node);
        }
        let node;
        this._nodeList[idx] = newNode;
        for (let i = idx - 1; i >= 0 && (node = this._nodeList[i], !node); i--) ;
        if (node) return node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode);
        this._ignoreWarn = !0;
        const data = this.insertInto(newNode, 0);
        return this._ignoreWarn = !1, data;
    }
    removeChild(child) {
        if (!this._idMap) return null;
        if (!this._idMap.has(child._uid)) return null;
        if (this._idMap.delete(child._uid), this._nodeList) {
            const idx = this._nodeList.findIndex((n => n === child));
            idx >= 0 && this._nodeList.splice(idx, 1);
        }
        return child._prev ? child._prev._next = child._next : this._firstChild = child._next, 
        child._next ? child._next._prev = child._prev : this._lastChild = child._prev, child.parent = null, 
        child._prev = null, child._next = null, this._structEdit = !0, this.setCount(-child.count), 
        child;
    }
    delete() {
        this.parent && this.parent.removeChild(this);
    }
    removeAllChild(deep) {
        if (!this._idMap) return;
        this._nodeList && (this._nodeList.length = 0);
        let child = this._firstChild;
        for (;child; ) {
            const next = child._next;
            child.parent = null, child._prev = null, child._next = null, child = child._next, 
            child = next;
        }
        this._firstChild = null, this._lastChild = null, this._idMap.clear(), this._structEdit = !0, 
        this.setCount(1 - this._count);
    }
    replaceChild(newChild, oldChild) {
        throw new Error("暂不支持");
    }
    find(callback, deep = !1) {
        let target = null;
        return this.forEachChildren(((node, index) => !(node === this || !callback(node, index)) && (target = node, 
        !0))), deep && this.forEachChildren((child => {
            if (child.isContainer) {
                const node = child.find(callback, !0);
                if (node) return target = node, !0;
            }
            return !1;
        })), target;
    }
    findAll(callback, deep = !1) {
        let nodes = [];
        return this.forEachChildren(((node, index) => {
            node !== this && callback(node, index) && nodes.push(node);
        })), deep && this.forEachChildren((child => {
            if (child.isContainer) {
                const targets = child.findAll(callback, !0);
                targets.length && (nodes = nodes.concat(targets));
            }
        })), nodes;
    }
    getElementById(id) {
        return this.find((node => node.id === id), !0);
    }
    findChildById(id) {
        return this.getElementById(id);
    }
    findChildByUid(uid) {
        return this._idMap && this._idMap.get(uid) || null;
    }
    getElementsByName(name) {
        return this.findAll((node => node.name === name), !0);
    }
    findChildrenByName(name) {
        return this.getElementsByName(name);
    }
    getElementsByType(type) {
        return this.findAll((node => node.type === type), !0);
    }
    getChildByName(name, deep = !1) {
        return this.find((node => node.name === name), deep);
    }
    getChildAt(idx) {
        let c = this._firstChild;
        if (!c) return null;
        for (let i = 0; i < idx; i++) {
            if (!c._next) return null;
            c = c._next;
        }
        return c;
    }
    at(idx) {
        return this.getChildAt(idx);
    }
    containNode(node) {
        if (!this._idMap) return !1;
        if (this._idMap.has(node._uid)) return !0;
        let child = this._firstChild;
        for (;child; ) {
            if (child.containNode(node)) return !0;
            child = child._next;
        }
        return !1;
    }
    getRootNode() {
        let parent = this.parent;
        for (;null == parent ? void 0 : parent.parent; ) parent = parent.parent;
        return parent || this;
    }
    hasChildNodes() {
        return null !== this._firstChild;
    }
    addChild(node) {
        return this.appendChild(node);
    }
    add(node) {
        return this.appendChild(node);
    }
    getChildren() {
        const nodes = [];
        let child = this._firstChild;
        for (;child; ) nodes.push(child), child = child._next;
        return nodes;
    }
    isChildOf(node) {
        return !!this.parent && this.parent._uid === node._uid;
    }
    isParentOf(node) {
        return node.isChildOf(this);
    }
    isDescendantsOf(node) {
        let parent = this.parent;
        if (!parent) return !1;
        do {
            if (parent._uid === node._uid) return !0;
            parent = parent.parent;
        } while (null !== parent);
        return !1;
    }
    isAncestorsOf(node) {
        return node.isDescendantsOf(this);
    }
    getAncestor(idx) {
        throw new Error("暂不支持");
    }
    setAllDescendantsProps(propsName, propsValue) {
        let child = this._firstChild;
        for (;child; ) child[propsName] = propsValue, child.setAllDescendantsProps(propsName, propsValue), 
        child = child._next;
    }
    setCount(deltaCount) {
        this._count += deltaCount;
        let parent = this.parent;
        if (parent) do {
            parent._count += deltaCount, parent = parent.parent;
        } while (null !== parent);
    }
    clone() {
        throw new Error("暂不支持");
    }
    cloneTo(node) {
        throw new Error("暂不支持");
    }
    getParent() {
        return this.parent;
    }
    del(child) {
        return this.removeChild(child);
    }
    addEventListener(type, listener, options) {
        const capture = (0, vutils_1.isBoolean)(options, !0) && options || (0, vutils_1.isObject)(options) && options.capture, once = (0, 
        vutils_1.isObject)(options) && options.once, context = (0, vutils_1.isFunction)(listener) ? void 0 : listener;
        return type = capture ? `${type}capture` : type, listener = (0, vutils_1.isFunction)(listener) ? listener : listener.handleEvent, 
        once ? super.once(type, listener, context) : super.on(type, listener, context), 
        this;
    }
    on(type, listener, options) {
        return this.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
        const capture = (0, vutils_1.isBoolean)(options, !0) && options || (0, vutils_1.isObject)(options) && options.capture, context = (0, 
        vutils_1.isFunction)(listener) ? void 0 : listener;
        type = capture ? `${type}capture` : type, listener = (0, vutils_1.isFunction)(listener) ? listener : listener.handleEvent;
        const once = (0, vutils_1.isObject)(options) && options.once;
        return super.off(type, listener, context, once), this;
    }
    off(type, listener, options) {
        return this.removeEventListener(type, listener, options);
    }
    once(type, listener, options) {
        return (0, vutils_1.isObject)(options) ? (options.once = !0, this.addEventListener(type, listener, options)) : this.addEventListener(type, listener, {
            once: !0
        });
    }
    removeAllEventListeners() {
        return super.removeAllListeners(), this;
    }
    removeAllListeners() {
        return this.removeAllEventListeners();
    }
    dispatchEvent(event, ...args) {
        return super.emit(event.type, event, ...args), !event.defaultPrevented;
    }
    emit(event, data) {
        return this.dispatchEvent(event, data);
    }
    release() {
        this.removeAllListeners();
    }
}

exports.Node = Node;
//# sourceMappingURL=node-tree.js.map
