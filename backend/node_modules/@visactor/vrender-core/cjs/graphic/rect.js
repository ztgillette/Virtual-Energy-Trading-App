"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createRect = exports.Rect = void 0;

const graphic_1 = require("./graphic"), custom_path2d_1 = require("../common/custom-path2d"), theme_1 = require("./theme"), application_1 = require("../application"), constants_1 = require("./constants"), rect_utils_1 = require("../common/rect-utils"), common_outer_boder_bounds_1 = require("./graphic-service/common-outer-boder-bounds"), RECT_UPDATE_TAG_KEY = [ "width", "x1", "y1", "height", "cornerRadius", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Rect extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "rect", this.numberType = constants_1.RECT_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        return !0;
    }
    getGraphicTheme() {
        return (0, theme_1.getTheme)(this).rect;
    }
    updateAABBBounds(attribute, rectTheme, aabbBounds) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
            let {width: width, height: height} = attribute;
            const {x1: x1, y1: y1, x: x, y: y} = attribute;
            width = null != width ? width : x1 - x, height = null != height ? height : y1 - y, 
            (isFinite(width) || isFinite(height) || isFinite(x) || isFinite(y)) && aabbBounds.set(0, 0, width || 0, height || 0);
        }
        const {tb1: tb1, tb2: tb2} = application_1.application.graphicService.updateTempAABBBounds(aabbBounds);
        return (0, common_outer_boder_bounds_1.updateBoundsOfCommonOuterBorder)(attribute, rectTheme, tb1), 
        aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, 
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application_1.application.graphicService.transformAABBBounds(attribute, aabbBounds, rectTheme, !1, this), 
        aabbBounds;
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, RECT_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, RECT_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        let path = super.toCustomPath();
        if (path) return path;
        const attribute = this.attribute, {x: x, y: y, width: width, height: height} = (0, 
        rect_utils_1.normalizeRectAttributes)(attribute);
        return path = new custom_path2d_1.CustomPath2D, path.moveTo(x, y), path.rect(x, y, width, height), 
        path;
    }
    clone() {
        return new Rect(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Rect.NOWORK_ANIMATE_ATTR;
    }
}

function createRect(attributes) {
    return new Rect(attributes);
}

exports.Rect = Rect, Rect.NOWORK_ANIMATE_ATTR = graphic_1.NOWORK_ANIMATE_ATTR, exports.createRect = createRect;
//# sourceMappingURL=rect.js.map
