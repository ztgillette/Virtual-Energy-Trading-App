"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createLine = exports.Line = void 0;

const graphic_1 = require("./graphic"), theme_1 = require("./theme"), application_1 = require("../application"), utils_1 = require("../common/utils"), custom_path2d_1 = require("../common/custom-path2d"), constants_1 = require("./constants"), LINE_UPDATE_TAG_KEY = [ "segments", "points", "curveType", "curveTension", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Line extends graphic_1.Graphic {
    constructor(params = {}) {
        super(params), this.type = "line", this.numberType = constants_1.LINE_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        if (this.pathProxy) return !0;
        const {points: points, segments: segments} = this.attribute;
        return segments ? 0 !== segments.length : !!points && !(points.length <= 1);
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "points" === key && (nextAttributes.points = (0, utils_1.pointsInterpolation)(lastStepVal, nextStepVal, ratio));
    }
    getGraphicTheme() {
        return (0, theme_1.getTheme)(this).line;
    }
    updateAABBBounds(attribute, lineTheme, aabbBounds) {
        this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds)), 
        application_1.application.graphicService.updateTempAABBBounds(aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, 
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        const {lineJoin: lineJoin = lineTheme.lineJoin} = attribute;
        return application_1.application.graphicService.transformAABBBounds(attribute, aabbBounds, lineTheme, "miter" === lineJoin, this), 
        aabbBounds;
    }
    updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
        const {points: points = lineTheme.points, connectedType: connectedType} = attribute, b = aabbBounds;
        return points.forEach((p => {
            !1 === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
        })), b;
    }
    updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
        const {segments: segments = lineTheme.segments, connectedType: connectedType} = attribute, b = aabbBounds;
        return segments.forEach((s => {
            s.points.forEach((p => {
                !1 === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
            }));
        })), b;
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, LINE_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, LINE_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        let path = super.toCustomPath();
        if (path) return path;
        const attribute = this.attribute;
        path = new custom_path2d_1.CustomPath2D;
        const segments = attribute.segments, parsePoints = points => {
            if (points && points.length) {
                let isFirst = !0;
                points.forEach((point => {
                    !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), 
                    isFirst = !1);
                }));
            }
        };
        return segments && segments.length ? segments.forEach((seg => {
            parsePoints(seg.points);
        })) : attribute.points && parsePoints(attribute.points), path;
    }
    clone() {
        return new Line(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Line.NOWORK_ANIMATE_ATTR;
    }
}

function createLine(attributes) {
    return new Line(attributes);
}

exports.Line = Line, Line.NOWORK_ANIMATE_ATTR = Object.assign({
    segments: 1,
    curveType: 1
}, graphic_1.NOWORK_ANIMATE_ATTR), exports.createLine = createLine;
//# sourceMappingURL=line.js.map
