"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

const line_1 = __importDefault(require("./line")), paragraph_1 = require("./paragraph"), utils_1 = require("./utils"), icon_1 = require("./icon");

class Wrapper {
    constructor(frame) {
        this.frame = frame, this.width = this.frame.width, this.height = this.frame.height, 
        this.lineWidth = 0, this.y = this.frame.top, this.maxAscent = 0, this.maxDescent = 0, 
        this.maxAscentForBlank = 0, this.maxDescentForBlank = 0, this.lineBuffer = [], this.direction = frame.layoutDirection, 
        this.directionKey = utils_1.DIRECTION_KEY[this.direction];
    }
    store(paragraph) {
        if (paragraph instanceof icon_1.RichTextIcon) {
            this.frame.icons.set(paragraph.richtextId, paragraph), this.lineBuffer.push(paragraph), 
            this.lineWidth += paragraph[this.directionKey.width];
            let iconAscent = 0, iconDescent = 0;
            "top" === paragraph.attribute.textBaseline ? (iconAscent = 0, iconDescent = paragraph.height) : "bottom" === paragraph.attribute.textBaseline ? (iconAscent = paragraph.height, 
            iconDescent = 0) : (iconAscent = paragraph.height / 2, iconDescent = paragraph.height / 2), 
            this.maxAscent = Math.max(this.maxAscent, iconAscent), this.maxDescent = Math.max(this.maxDescent, iconDescent);
        } else this.lineBuffer.push(paragraph), 0 !== paragraph.text.length ? (this.lineWidth += paragraph[this.directionKey.width], 
        this.maxAscent = Math.max(this.maxAscent, paragraph.ascent), this.maxDescent = Math.max(this.maxDescent, paragraph.descent)) : (this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent), 
        this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent));
    }
    send() {
        if (0 === this.lineBuffer.length) return;
        const maxAscent = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent, maxDescent = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent, line = new line_1.default(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, "horizontal" === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax);
        this.frame.lines.push(line), this.frame.actualHeight += line.height, this.y += line.height, 
        this.lineBuffer.length = 0, this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
    }
    deal(paragraph, singleLine = !1) {
        paragraph instanceof icon_1.RichTextIcon ? "horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : 0 === this.lineBuffer.length ? (this.store(paragraph), 
        this.send()) : (this.send(), this.deal(paragraph)) : "number" != typeof this.width || this.width < 0 || (paragraph.newLine && this.send(), 
        (0 !== paragraph.text.length || this.newLine) && ("horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : this.lineWidth === this[this.directionKey.width] ? (this.send(), 
        this.deal(paragraph)) : this.cut(paragraph, singleLine)));
    }
    cut(paragraph, singleLine) {
        const availableWidth = this[this.directionKey.width] - this.lineWidth || 0, guessIndex = Math.ceil(availableWidth / paragraph[this.directionKey.width] * paragraph.length) || 0, index = (0, 
        utils_1.getStrByWithCanvas)(paragraph.text, availableWidth, paragraph.character, guessIndex, "break-word" === this.frame.wordBreak);
        if (0 !== index) {
            const [p1, p2] = (0, paragraph_1.seperateParagraph)(paragraph, index);
            this.store(p1), singleLine ? this.send() : this.deal(p2);
        } else 0 !== this.lineBuffer.length && (this.send(), this.deal(paragraph));
    }
}

exports.default = Wrapper;
//# sourceMappingURL=wrapper.js.map
