"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.getThemeFromGroup = exports.getTheme = exports.globalTheme = exports.Theme = exports.newThemeObj = void 0;

const vutils_1 = require("@visactor/vutils"), config_1 = require("./config"), defaultThemeObj = {
    arc: config_1.DefaultArcAttribute,
    area: config_1.DefaultAreaAttribute,
    circle: config_1.DefaultCircleAttribute,
    line: config_1.DefaultLineAttribute,
    path: config_1.DefaultPathAttribute,
    symbol: config_1.DefaultSymbolAttribute,
    text: config_1.DefaultTextAttribute,
    rect: config_1.DefaultRectAttribute,
    polygon: config_1.DefaultPolygonAttribute,
    star: config_1.DefaultStarAttribute,
    richtext: config_1.DefaultRichTextAttribute,
    richtextIcon: config_1.DefaultRichTextIconAttribute,
    image: config_1.DefaultImageAttribute,
    group: config_1.DefaultGroupAttribute,
    glyph: config_1.DefaultGlyphAttribute
}, themeKeys = Object.keys(defaultThemeObj);

function newThemeObj() {
    return {
        arc: Object.assign({}, defaultThemeObj.arc),
        area: Object.assign({}, defaultThemeObj.area),
        circle: Object.assign({}, defaultThemeObj.circle),
        line: Object.assign({}, defaultThemeObj.line),
        path: Object.assign({}, defaultThemeObj.path),
        symbol: Object.assign({}, defaultThemeObj.symbol),
        text: Object.assign({}, defaultThemeObj.text),
        rect: Object.assign({}, defaultThemeObj.rect),
        polygon: Object.assign({}, defaultThemeObj.polygon),
        star: Object.assign({}, defaultThemeObj.star),
        richtext: Object.assign({}, defaultThemeObj.richtext),
        richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
        image: Object.assign({}, defaultThemeObj.image),
        group: Object.assign({}, defaultThemeObj.group),
        glyph: Object.assign({}, defaultThemeObj.glyph)
    };
}

function combine(out, t) {
    Object.keys(t).forEach((k => {
        out[k] = t[k];
    }));
}

exports.newThemeObj = newThemeObj;

const globalThemeObj = newThemeObj();

class Theme {
    constructor() {
        this.initTheme(), this.dirty = !1;
    }
    initTheme() {
        this._defaultTheme = {}, themeKeys.forEach((key => {
            this._defaultTheme[key] = Object.create(globalThemeObj[key]);
        })), this.combinedTheme = this._defaultTheme;
    }
    getTheme(group) {
        if (!group) return this.combinedTheme;
        if (!this.dirty) return this.combinedTheme;
        let parentTheme = {};
        const parentGroup = this.getParentWithTheme(group);
        return parentGroup && (parentTheme = parentGroup.theme), this.applyTheme(group, parentTheme), 
        this.combinedTheme;
    }
    getParentWithTheme(group) {
        for (;group.parent; ) if ((group = group.parent).theme) return group;
        return null;
    }
    applyTheme(group, pt, force = !1) {
        if (this.dirty) {
            const parentGroup = this.getParentWithTheme(group);
            if (parentGroup) {
                const parentTheme = parentGroup.theme;
                (parentTheme.dirty || force) && parentTheme.applyTheme(parentGroup, pt, !0);
            }
            this.userTheme ? this.doCombine(parentGroup && parentGroup.theme.combinedTheme) : (parentGroup ? this.combinedTheme = parentGroup.theme.combinedTheme : (this.combinedTheme = this._defaultTheme, 
            vutils_1.Logger.getInstance().warn("未知错误，走到不应该走的区域里")), this.dirty = !1);
        }
        return this.combinedTheme;
    }
    doCombine(parentCombinedTheme) {
        const userTheme = this.userTheme, combinedTheme = this.combinedTheme;
        themeKeys.forEach((k => {
            const obj = Object.create(globalThemeObj[k]);
            parentCombinedTheme && parentCombinedTheme[k] && combine(obj, parentCombinedTheme[k]), 
            combinedTheme[k] && combine(obj, combinedTheme[k]), userTheme[k] && combine(obj, userTheme[k]), 
            this.combinedTheme[k] = obj;
        })), userTheme.common && themeKeys.forEach((k => {
            combine(this.combinedTheme[k], userTheme.common);
        })), this.dirty = !1;
    }
    setTheme(t, g) {
        let userTheme = this.userTheme;
        userTheme ? Object.keys(t).forEach((k => {
            userTheme[k] ? Object.assign(userTheme[k], t[k]) : userTheme[k] = Object.assign({}, t[k]);
        })) : userTheme = t, this.userTheme = userTheme, this.dirty = !0, this.dirtyChildren(g);
    }
    resetTheme(t, g) {
        this.userTheme = t, this.dirty = !0, this.dirtyChildren(g);
    }
    dirtyChildren(g) {
        g.forEachChildren((item => {
            item.isContainer && (item.theme && (item.theme.dirty = !0), this.dirtyChildren(item));
        }));
    }
}

function getTheme(graphic, theme) {
    return graphic.glyphHost ? getTheme(graphic.glyphHost) : theme ? (graphic.isContainer, 
    theme) : getThemeFromGroup(graphic) || graphic.attachedThemeGraphic && getTheme(graphic.attachedThemeGraphic) || exports.globalTheme.getTheme();
}

function getThemeFromGroup(graphic) {
    let g;
    if (g = graphic.isContainer ? graphic : graphic.parent, g) {
        for (;g && !g.theme; ) g = g.parent;
        return g ? (g.theme || g.createTheme(), g.theme.getTheme(g)) : exports.globalTheme.getTheme();
    }
    return null;
}

exports.Theme = Theme, exports.globalTheme = new Theme, exports.getTheme = getTheme, 
exports.getThemeFromGroup = getThemeFromGroup;
//# sourceMappingURL=theme.js.map
