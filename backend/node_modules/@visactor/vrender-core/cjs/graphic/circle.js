"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createCircle = exports.Circle = void 0;

const vutils_1 = require("@visactor/vutils"), graphic_1 = require("./graphic"), custom_path2d_1 = require("../common/custom-path2d"), utils_1 = require("../common/utils"), theme_1 = require("./theme"), application_1 = require("../application"), constants_1 = require("./constants"), common_outer_boder_bounds_1 = require("./graphic-service/common-outer-boder-bounds"), CIRCLE_UPDATE_TAG_KEY = [ "radius", "startAngle", "endAngle", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Circle extends graphic_1.Graphic {
    constructor(params = {
        radius: 1
    }) {
        super(params), this.type = "circle", this.numberType = constants_1.CIRCLE_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {startAngle: startAngle, endAngle: endAngle, radius: radius} = this.attribute;
        return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);
    }
    getGraphicTheme() {
        return (0, theme_1.getTheme)(this).circle;
    }
    updateAABBBounds(attribute, circleTheme, aabbBounds, full) {
        this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds));
        const {tb1: tb1, tb2: tb2} = application_1.application.graphicService.updateTempAABBBounds(aabbBounds);
        return (0, common_outer_boder_bounds_1.updateBoundsOfCommonOuterBorder)(attribute, circleTheme, tb1), 
        aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, 
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1, application_1.application.graphicService.transformAABBBounds(attribute, aabbBounds, circleTheme, !1, this), 
        aabbBounds;
    }
    updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) {
        const {radius: radius = circleTheme.radius} = attribute;
        return aabbBounds.set(-radius, -radius, radius, radius), aabbBounds;
    }
    updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds) {
        const {startAngle: startAngle = circleTheme.startAngle, endAngle: endAngle = circleTheme.endAngle, radius: radius = circleTheme.radius} = attribute;
        return endAngle - startAngle > vutils_1.pi2 - vutils_1.epsilon ? aabbBounds.set(-radius, -radius, radius, radius) : (0, 
        utils_1.circleBounds)(startAngle, endAngle, radius, aabbBounds), aabbBounds;
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, CIRCLE_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, CIRCLE_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        var _a, _b, _c;
        let path = super.toCustomPath();
        if (path) return path;
        const attribute = this.attribute, radius = null !== (_a = attribute.radius) && void 0 !== _a ? _a : this.getDefaultAttribute("radius"), startAngle = null !== (_b = attribute.startAngle) && void 0 !== _b ? _b : this.getDefaultAttribute("startAngle"), endAngle = null !== (_c = attribute.endAngle) && void 0 !== _c ? _c : this.getDefaultAttribute("endAngle");
        return path = new custom_path2d_1.CustomPath2D, path.arc(0, 0, radius, startAngle, endAngle), 
        path;
    }
    clone() {
        return new Circle(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Circle.NOWORK_ANIMATE_ATTR;
    }
}

function createCircle(attributes) {
    return new Circle(attributes);
}

exports.Circle = Circle, Circle.NOWORK_ANIMATE_ATTR = graphic_1.NOWORK_ANIMATE_ATTR, 
exports.createCircle = createCircle;
//# sourceMappingURL=circle.js.map
