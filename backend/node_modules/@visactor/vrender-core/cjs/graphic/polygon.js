"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.createPolygon = exports.Polygon = void 0;

const graphic_1 = require("./graphic"), theme_1 = require("./theme"), utils_1 = require("../common/utils"), custom_path2d_1 = require("../common/custom-path2d"), application_1 = require("../application"), constants_1 = require("./constants"), POLYGON_UPDATE_TAG_KEY = [ "points", "cornerRadius", ...graphic_1.GRAPHIC_UPDATE_TAG_KEY ];

class Polygon extends graphic_1.Graphic {
    constructor(params) {
        super(params), this.type = "polygon", this.numberType = constants_1.POLYGON_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const {points: points} = this.attribute;
        return points && points.length >= 2;
    }
    getGraphicTheme() {
        return (0, theme_1.getTheme)(this).polygon;
    }
    updateAABBBounds(attribute, polygonTheme, aabbBounds) {
        this.updatePathProxyAABBBounds(aabbBounds) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds), 
        application_1.application.graphicService.updateTempAABBBounds(aabbBounds), this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1, 
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        const {lineJoin: lineJoin = polygonTheme.lineJoin} = attribute;
        return application_1.application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, "miter" === lineJoin, this), 
        aabbBounds;
    }
    updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds) {
        const {points: points = polygonTheme.points} = attribute;
        return points.forEach((p => {
            aabbBounds.add(p.x, p.y);
        })), aabbBounds;
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        "points" === key && (nextAttributes.points = (0, utils_1.pointsInterpolation)(lastStepVal, nextStepVal, ratio));
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, POLYGON_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, POLYGON_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        let path = super.toCustomPath();
        if (path) return path;
        const points = this.attribute.points;
        return path = new custom_path2d_1.CustomPath2D, points.forEach(((point, index) => {
            0 === index ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y);
        })), path.closePath(), path;
    }
    clone() {
        return new Polygon(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Polygon.NOWORK_ANIMATE_ATTR;
    }
}

function createPolygon(attributes) {
    return new Polygon(attributes);
}

exports.Polygon = Polygon, Polygon.NOWORK_ANIMATE_ATTR = graphic_1.NOWORK_ANIMATE_ATTR, 
exports.createPolygon = createPolygon;
//# sourceMappingURL=polygon.js.map
