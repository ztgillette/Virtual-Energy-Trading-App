"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.drawIncrementalAreaSegments = exports.drawIncrementalSegments = exports.drawSegments = void 0;

const vutils_1 = require("@visactor/vutils"), enums_1 = require("./enums"), render_utils_1 = require("./render-utils");

function drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ) {
    var _a;
    let p0 = curve.p0, newDefined0 = defined0;
    if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (p0 = lastCurve.p0), 
    curve.defined) defined0 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), 
    newDefined0 = !defined0); else {
        const {originP1: originP1, originP2: originP2} = curve;
        let validP;
        if (originP1 && !1 !== originP1.defined && !lastCurve ? validP = p0 : originP1 && !1 !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), 
        defined0) {
            newDefined0 = !defined0;
            const x = validP ? validP.x : curve.p0.x, y = validP ? validP.y : curve.p0.y;
            path.moveTo(x + offsetX, y + offsetY, offsetZ);
        } else validP && (newDefined0 = !defined0, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
    }
    return newDefined0;
}

function drawSegments(path, segPath, percent, clipRangeByDimension, params) {
    const {offsetX: offsetX = 0, offsetY: offsetY = 0, offsetZ: offsetZ = 0, mode: mode = "none", drawConnect: drawConnect = !1} = params || {};
    if (drawConnect && "none" === mode) return;
    if (!segPath) return;
    let needMoveTo = !0;
    const {curves: curves} = segPath;
    if (percent >= 1) {
        if (drawConnect) {
            let lastCurve, defined0 = !0;
            curves.forEach(((curve, i) => {
                curve.originP1 !== curve.originP2 ? (defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ), 
                lastCurve = curve) : lastCurve = curve;
            }));
        } else curves.forEach((curve => {
            curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), 
            (0, render_utils_1.drawSegItem)(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
        }));
        return;
    }
    if (percent <= 0) return;
    let direction;
    "x" === clipRangeByDimension ? direction = enums_1.Direction.ROW : "y" === clipRangeByDimension ? direction = enums_1.Direction.COLUMN : "auto" === clipRangeByDimension && (direction = segPath.direction);
    const totalDrawLength = percent * segPath.tryUpdateLength(direction);
    let drawedLengthUntilLast = 0, defined0 = !0, lastCurve = null;
    for (let i = 0, n = curves.length; i < n; i++) {
        const curve = curves[i], curCurveLength = curve.getLength(direction), _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
        if (drawedLengthUntilLast += curCurveLength, _p < 0) break;
        if (drawConnect) {
            if (curve.originP1 === curve.originP2) {
                lastCurve = curve;
                continue;
            }
            defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ), 
            lastCurve = curve;
        } else {
            if (!curve.defined) {
                needMoveTo = !0;
                continue;
            }
            needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), 
            (0, render_utils_1.drawSegItem)(path, curve, (0, vutils_1.min)(_p, 1), params), 
            needMoveTo = !1;
        }
    }
}

function drawIncrementalSegments(path, lastSeg, segments, params) {
    const {offsetX: offsetX = 0, offsetY: offsetY = 0} = params || {}, startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];
    path.moveTo(startP.x + offsetX, startP.y + offsetY), segments.points.forEach((p => {
        !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
    }));
}

function drawIncrementalAreaSegments(path, lastSeg, segments, params) {
    const {offsetX: offsetX = 0, offsetY: offsetY = 0} = params || {}, {points: points} = segments, definedPointsList = [];
    let lastIdx = 0;
    for (let i = 0; i < points.length; i++) !1 === points[i].defined && (lastIdx + 1 !== i && definedPointsList.slice(lastIdx, i), 
    lastIdx = i);
    definedPointsList.length, definedPointsList.push(points), definedPointsList.forEach(((points, i) => {
        var _a, _b, _c, _d;
        const startP = lastSeg && 0 === i ? lastSeg.points[lastSeg.points.length - 1] : points[0];
        path.moveTo(startP.x + offsetX, startP.y + offsetY), points.forEach((p => {
            !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
        }));
        for (let i = points.length - 1; i >= 0; i--) {
            const p = points[i];
            path.lineTo(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
        }
        path.lineTo(null !== (_c = startP.x1) && void 0 !== _c ? _c : startP.x, null !== (_d = startP.y1) && void 0 !== _d ? _d : startP.y), 
        path.closePath();
    }));
}

exports.drawSegments = drawSegments, exports.drawIncrementalSegments = drawIncrementalSegments, 
exports.drawIncrementalAreaSegments = drawIncrementalAreaSegments;
//# sourceMappingURL=render-curve.js.map