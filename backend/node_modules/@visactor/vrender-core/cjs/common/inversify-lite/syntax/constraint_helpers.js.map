{"version":3,"sources":["../src/common/inversify-lite/syntax/constraint_helpers.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,yEAA2D;AAE3D,mDAAgD;AAiBhD,MAAM,gBAAgB,GAAG,CAAC,GAA6B,EAAE,EAAE,CAAC,CAAC,KAAc,EAAE,EAAE;IAC7E,MAAM,UAAU,GAAkC,CAAC,OAAkC,EAAE,EAAE,CACvF,OAAO,KAAK,IAAI,IAAI,OAAO,CAAC,MAAM,KAAK,IAAI,IAAI,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC;IAEvF,UAAU,CAAC,QAAQ,GAAG,IAAI,mBAAQ,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IAE/C,OAAO,UAAU,CAAC;AACpB,CAAC,CAAC;AAEF,MAAM,eAAe,GAAG,gBAAgB,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;AAuBxD,0CAAe","file":"constraint_helpers.js","sourcesContent":["import * as METADATA_KEY from '../constants/metadata_keys';\nimport type { interfaces } from '../interfaces/interfaces';\nimport { Metadata } from '../planning/metadata';\n\n// const traverseAncerstors = (\n//   request: interfaces.Request,\n//   constraint: interfaces.ConstraintFunction\n// ): boolean => {\n\n//   const parent = request.parentRequest;\n//   if (parent !== null) {\n//     return constraint(parent) ? true : traverseAncerstors(parent, constraint);\n//   } else {\n//     return false;\n//   }\n// };\n\n// This helpers use currying to help you to generate constraints\n\nconst taggedConstraint = (key: string | number | symbol) => (value: unknown) => {\n  const constraint: interfaces.ConstraintFunction = (request: interfaces.Request | null) =>\n    request !== null && request.target !== null && request.target.matchesTag(key)(value);\n\n  constraint.metaData = new Metadata(key, value);\n\n  return constraint;\n};\n\nconst namedConstraint = taggedConstraint(METADATA_KEY.NAMED_TAG);\n\n// const typeConstraint = (type: (NewableFunction | string)) => (request: interfaces.Request | null) => {\n\n//   // Using index 0 because constraints are applied\n//   // to one binding at a time (see Planner class)\n//   let binding: interfaces.Binding<unknown> | null = null;\n\n//   if (request !== null) {\n//     binding = request.bindings[0] as interfaces.Binding<unknown>;\n//     if (typeof type === 'string') {\n//       const serviceIdentifier = binding.serviceIdentifier;\n//       return serviceIdentifier === type;\n//     } else {\n//       const constructor = (request.bindings[0] as interfaces.Binding<unknown>).implementationType;\n//       return type === constructor;\n//     }\n//   }\n\n//   return false;\n// };\n\n// export { traverseAncerstors, taggedConstraint, namedConstraint, typeConstraint };\nexport { namedConstraint };\n"]}