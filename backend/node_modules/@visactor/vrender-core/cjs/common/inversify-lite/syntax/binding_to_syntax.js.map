{"version":3,"sources":["../src/common/inversify-lite/syntax/binding_to_syntax.ts"],"names":[],"mappings":"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","file":"binding_to_syntax.js","sourcesContent":["import * as ERROR_MSGS from '../constants/error_msgs';\nimport { BindingScopeEnum, BindingTypeEnum } from '../constants/literal_types';\nimport type { interfaces } from '../interfaces/interfaces';\nimport { BindingInWhenOnSyntax } from './binding_in_when_on_syntax';\nimport { BindingWhenOnSyntax } from './binding_when_on_syntax';\n\nclass BindingToSyntax<T> implements interfaces.BindingToSyntax<T> {\n  // TODO: Implement an internal type `_BindingToSyntax<T>` wherein this member\n  // can be public. Let `BindingToSyntax<T>` be the presentational type that\n  // depends on it, and does not expose this member as public.\n  private _binding: interfaces.Binding<T>;\n\n  constructor(binding: interfaces.Binding<T>) {\n    this._binding = binding;\n  }\n\n  to(constructor: interfaces.Newable<T>): interfaces.BindingInWhenOnSyntax<T> {\n    this._binding.type = BindingTypeEnum.Instance;\n    this._binding.implementationType = constructor;\n    return new BindingInWhenOnSyntax<T>(this._binding);\n  }\n\n  toSelf(): interfaces.BindingInWhenOnSyntax<T> {\n    if (typeof this._binding.serviceIdentifier !== 'function') {\n      throw new Error(`${ERROR_MSGS.INVALID_TO_SELF_VALUE}`);\n    }\n    const self = this._binding.serviceIdentifier;\n    return this.to(self);\n  }\n\n  toConstantValue(value: T): interfaces.BindingWhenOnSyntax<T> {\n    this._binding.type = BindingTypeEnum.ConstantValue;\n    this._binding.cache = value;\n    this._binding.dynamicValue = null;\n    this._binding.implementationType = null;\n    this._binding.scope = BindingScopeEnum.Singleton;\n    return new BindingWhenOnSyntax<T>(this._binding);\n  }\n\n  toDynamicValue(func: interfaces.DynamicValue<T>): interfaces.BindingInWhenOnSyntax<T> {\n    this._binding.type = BindingTypeEnum.DynamicValue;\n    this._binding.cache = null;\n    this._binding.dynamicValue = func;\n    this._binding.implementationType = null;\n    return new BindingInWhenOnSyntax<T>(this._binding);\n  }\n\n  toConstructor<T2>(constructor: interfaces.Newable<T2>): interfaces.BindingWhenOnSyntax<T> {\n    this._binding.type = BindingTypeEnum.Constructor;\n    this._binding.implementationType = constructor as unknown as T;\n    this._binding.scope = BindingScopeEnum.Singleton;\n    return new BindingWhenOnSyntax<T>(this._binding);\n  }\n\n  toFactory<T2>(factory: interfaces.FactoryCreator<T2>): interfaces.BindingWhenOnSyntax<T> {\n    this._binding.type = BindingTypeEnum.Factory;\n    this._binding.factory = factory;\n    this._binding.scope = BindingScopeEnum.Singleton;\n    return new BindingWhenOnSyntax<T>(this._binding);\n  }\n\n  toFunction(func: T): interfaces.BindingWhenOnSyntax<T> {\n    // toFunction is an alias of toConstantValue\n    if (typeof func !== 'function') {\n      throw new Error(ERROR_MSGS.INVALID_FUNCTION_BINDING);\n    }\n    const bindingWhenOnSyntax = this.toConstantValue(func);\n    this._binding.type = BindingTypeEnum.Function;\n    this._binding.scope = BindingScopeEnum.Singleton;\n    return bindingWhenOnSyntax;\n  }\n\n  toAutoFactory<T2>(serviceIdentifier: interfaces.ServiceIdentifier<T2>): interfaces.BindingWhenOnSyntax<T> {\n    this._binding.type = BindingTypeEnum.Factory;\n    this._binding.factory = context => {\n      const autofactory = () => context.container.get<T2>(serviceIdentifier);\n      return autofactory;\n    };\n    this._binding.scope = BindingScopeEnum.Singleton;\n    return new BindingWhenOnSyntax<T>(this._binding);\n  }\n\n  toAutoNamedFactory<T2>(serviceIdentifier: interfaces.ServiceIdentifier<T2>): BindingWhenOnSyntax<T> {\n    this._binding.type = BindingTypeEnum.Factory;\n    this._binding.factory = context => {\n      return (named: unknown) => context.container.getNamed<T2>(serviceIdentifier, named as string);\n    };\n    return new BindingWhenOnSyntax<T>(this._binding);\n  }\n\n  toProvider<T2>(provider: interfaces.ProviderCreator<T2>): interfaces.BindingWhenOnSyntax<T> {\n    this._binding.type = BindingTypeEnum.Provider;\n    this._binding.provider = provider;\n    this._binding.scope = BindingScopeEnum.Singleton;\n    return new BindingWhenOnSyntax<T>(this._binding);\n  }\n\n  toService(service: string | symbol | interfaces.Newable<T> | interfaces.Abstract<T>): void {\n    this.toDynamicValue(context => context.container.get<T>(service));\n  }\n}\n\nexport { BindingToSyntax };\n"]}