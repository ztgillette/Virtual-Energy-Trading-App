{"version":3,"sources":["../src/common/inversify-lite/container/lookup.ts"],"names":[],"mappings":"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","file":"lookup.js","sourcesContent":["import * as ERROR_MSGS from '../constants/error_msgs';\nimport type { interfaces } from '../interfaces/interfaces';\nimport { isClonable } from '../utils/clonable';\n\nclass Lookup<T> implements interfaces.Lookup<T> {\n  // dictionary used store multiple values for each key <key>\n  private _map: Map<interfaces.ServiceIdentifier, T[]>;\n\n  constructor() {\n    this._map = new Map<interfaces.ServiceIdentifier, T[]>();\n  }\n\n  getMap() {\n    return this._map;\n  }\n\n  // adds a new entry to _map\n  add(serviceIdentifier: interfaces.ServiceIdentifier, value: T): void {\n    if (serviceIdentifier === null || serviceIdentifier === undefined) {\n      throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n    }\n\n    if (value === null || value === undefined) {\n      throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n    }\n\n    const entry = this._map.get(serviceIdentifier);\n    if (entry !== undefined) {\n      entry.push(value);\n    } else {\n      this._map.set(serviceIdentifier, [value]);\n    }\n  }\n\n  // gets the value of a entry by its key (serviceIdentifier)\n  get(serviceIdentifier: interfaces.ServiceIdentifier): T[] {\n    if (serviceIdentifier === null || serviceIdentifier === undefined) {\n      throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n    }\n\n    const entry = this._map.get(serviceIdentifier);\n\n    if (entry !== undefined) {\n      return entry;\n    }\n    throw new Error(ERROR_MSGS.KEY_NOT_FOUND);\n  }\n\n  // removes a entry from _map by its key (serviceIdentifier)\n  remove(serviceIdentifier: interfaces.ServiceIdentifier): void {\n    if (serviceIdentifier === null || serviceIdentifier === undefined) {\n      throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n    }\n\n    if (!this._map.delete(serviceIdentifier)) {\n      throw new Error(ERROR_MSGS.KEY_NOT_FOUND);\n    }\n  }\n\n  removeIntersection(lookup: interfaces.Lookup<T>): void {\n    this.traverse((serviceIdentifier: interfaces.ServiceIdentifier<unknown>, value: T[]) => {\n      const lookupActivations = lookup.hasKey(serviceIdentifier) ? lookup.get(serviceIdentifier) : undefined;\n      if (lookupActivations !== undefined) {\n        const filteredValues = value.filter(\n          lookupValue => !lookupActivations.some(moduleActivation => lookupValue === moduleActivation)\n        );\n\n        this._setValue(serviceIdentifier, filteredValues);\n      }\n    });\n  }\n\n  removeByCondition(condition: (item: T) => boolean): T[] {\n    const removals: T[] = [];\n    this._map.forEach((entries, key) => {\n      const updatedEntries: T[] = [];\n\n      for (const entry of entries) {\n        const remove = condition(entry);\n        if (remove) {\n          removals.push(entry);\n        } else {\n          updatedEntries.push(entry);\n        }\n      }\n\n      this._setValue(key, updatedEntries);\n    });\n\n    return removals;\n  }\n\n  // returns true if _map contains a key (serviceIdentifier)\n  hasKey(serviceIdentifier: interfaces.ServiceIdentifier): boolean {\n    if (serviceIdentifier === null || serviceIdentifier === undefined) {\n      throw new Error(ERROR_MSGS.NULL_ARGUMENT);\n    }\n\n    return this._map.has(serviceIdentifier);\n  }\n\n  // returns a new Lookup instance; note: this is not a deep clone, only Lookup related data structure (dictionary) is\n  // cloned, content remains the same\n  clone(): interfaces.Lookup<T> {\n    const copy = new Lookup<T>();\n\n    this._map.forEach((value, key) => {\n      value.forEach(b => copy.add(key, isClonable<T>(b) ? b.clone() : b));\n    });\n\n    return copy;\n  }\n\n  traverse(func: (key: interfaces.ServiceIdentifier, value: T[]) => void): void {\n    this._map.forEach((value, key) => {\n      func(key, value);\n    });\n  }\n\n  private _setValue(serviceIdentifier: interfaces.ServiceIdentifier<unknown>, value: T[]): void {\n    if (value.length > 0) {\n      this._map.set(serviceIdentifier, value);\n    } else {\n      this._map.delete(serviceIdentifier);\n    }\n  }\n}\n\nexport { Lookup };\n"]}