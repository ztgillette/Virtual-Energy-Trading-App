{"version":3,"sources":["../src/common/inversify-lite/scope/scope.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,8DAA8D;AAE9D,0CAA2C;AAEpC,MAAM,eAAe,GAAG,CAC7B,YAAqC,EACrC,OAA8B,EACP,EAAE;IACzB,IAAI,OAAO,CAAC,KAAK,KAAK,gCAAgB,CAAC,SAAS,IAAI,OAAO,CAAC,SAAS,EAAE;QACrE,OAAO,OAAO,CAAC,KAAM,CAAC;KACvB;IAED,IAAI,OAAO,CAAC,KAAK,KAAK,gCAAgB,CAAC,OAAO,IAAI,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE;QAC9E,OAAO,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAmB,CAAC;KACvD;IACD,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAZW,QAAA,eAAe,mBAY1B;AAEK,MAAM,WAAW,GAAG,CACzB,YAAqC,EACrC,OAA8B,EAC9B,MAAsB,EAChB,EAAE;IACR,IAAI,OAAO,CAAC,KAAK,KAAK,gCAAgB,CAAC,SAAS,EAAE;QAChD,qBAAqB,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;KACxC;IAED,IAAI,OAAO,CAAC,KAAK,KAAK,gCAAgB,CAAC,OAAO,EAAE;QAC9C,mBAAmB,CAAC,YAAY,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;KACpD;AACH,CAAC,CAAC;AAZW,QAAA,WAAW,eAYtB;AAEF,MAAM,mBAAmB,GAAG,CAC1B,YAAqC,EACrC,OAA8B,EAC9B,MAAsB,EAChB,EAAE;IACR,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE;QACjC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;KACtC;AACH,CAAC,CAAC;AAEF,MAAM,qBAAqB,GAAG,CAAI,OAA8B,EAAE,MAAsB,EAAQ,EAAE;IAEhG,OAAO,CAAC,KAAK,GAAG,MAAM,CAAC;IACvB,OAAO,CAAC,SAAS,GAAG,IAAI,CAAC;IAEzB,IAAI,IAAA,iBAAS,EAAC,MAAM,CAAC,EAAE;QACrB,KAAK,gCAAgC,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;KACxD;AACH,CAAC,CAAC;AAEF,MAAM,gCAAgC,GAAG,CACvC,OAA8B,EAC9B,WAAuB,EACR,EAAE;IACjB,IAAI;QACF,MAAM,MAAM,GAAG,MAAM,WAAW,CAAC;QAEjC,OAAO,CAAC,KAAK,GAAG,MAAM,CAAC;KACxB;IAAC,OAAO,EAAW,EAAE;QAEpB,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC;QACrB,OAAO,CAAC,SAAS,GAAG,KAAK,CAAC;QAE1B,MAAM,EAAE,CAAC;KACV;AACH,CAAC,CAAA,CAAC","file":"scope.js","sourcesContent":["// import { BindingScopeEnum, interfaces } from '../inversify';\nimport { BindingScopeEnum } from '../constants/literal_types';\nimport type { interfaces } from '../interfaces/interfaces';\nimport { isPromise } from '../utils/async';\n\nexport const tryGetFromScope = <T>(\n  requestScope: interfaces.RequestScope,\n  binding: interfaces.Binding<T>\n): T | Promise<T> | null => {\n  if (binding.scope === BindingScopeEnum.Singleton && binding.activated) {\n    return binding.cache!;\n  }\n\n  if (binding.scope === BindingScopeEnum.Request && requestScope.has(binding.id)) {\n    return requestScope.get(binding.id) as T | Promise<T>;\n  }\n  return null;\n};\n\nexport const saveToScope = <T>(\n  requestScope: interfaces.RequestScope,\n  binding: interfaces.Binding<T>,\n  result: T | Promise<T>\n): void => {\n  if (binding.scope === BindingScopeEnum.Singleton) {\n    _saveToSingletonScope(binding, result);\n  }\n\n  if (binding.scope === BindingScopeEnum.Request) {\n    _saveToRequestScope(requestScope, binding, result);\n  }\n};\n\nconst _saveToRequestScope = <T>(\n  requestScope: interfaces.RequestScope,\n  binding: interfaces.Binding<T>,\n  result: T | Promise<T>\n): void => {\n  if (!requestScope.has(binding.id)) {\n    requestScope.set(binding.id, result);\n  }\n};\n\nconst _saveToSingletonScope = <T>(binding: interfaces.Binding<T>, result: T | Promise<T>): void => {\n  // store in cache if scope is singleton\n  binding.cache = result;\n  binding.activated = true;\n\n  if (isPromise(result)) {\n    void _saveAsyncResultToSingletonScope(binding, result);\n  }\n};\n\nconst _saveAsyncResultToSingletonScope = async <T>(\n  binding: interfaces.Binding<T>,\n  asyncResult: Promise<T>\n): Promise<void> => {\n  try {\n    const result = await asyncResult;\n\n    binding.cache = result;\n  } catch (ex: unknown) {\n    // allow binding to retry in future\n    binding.cache = null;\n    binding.activated = false;\n\n    throw ex;\n  }\n};\n"]}