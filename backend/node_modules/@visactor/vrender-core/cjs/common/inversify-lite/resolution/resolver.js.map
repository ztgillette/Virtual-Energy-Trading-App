{"version":3,"sources":["../src/common/inversify-lite/resolution/resolver.ts"],"names":[],"mappings":"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","file":"resolver.js","sourcesContent":["import * as ERROR_MSGS from '../constants/error_msgs';\nimport { BindingTypeEnum } from '../constants/literal_types';\nimport type { interfaces } from '../interfaces/interfaces';\n// import { getBindingDictionary } from '../planning/planner';\nimport { saveToScope, tryGetFromScope } from '../scope/scope';\n// import { isPromise } from '../utils/async';\nimport { getFactoryDetails, ensureFullyBound } from '../utils/binding_utils';\nimport { tryAndThrowErrorIfStackOverflow } from '../utils/exceptions';\nimport { resolveInstance } from './instantiation';\n\nconst _resolveRequest =\n  <T>(requestScope: interfaces.RequestScope) =>\n  (request: interfaces.Request): undefined | T | Promise<T> | (T | Promise<T>)[] => {\n    request.parentContext.setCurrentRequest(request);\n\n    const bindings = request.bindings;\n    const childRequests = request.childRequests;\n\n    const targetIsAnArray = request.target && request.target.isArray();\n\n    const targetParentIsNotAnArray =\n      !request.parentRequest ||\n      !request.parentRequest.target ||\n      !request.target ||\n      !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);\n\n    if (targetIsAnArray && targetParentIsNotAnArray) {\n      // Create an array instead of creating an instance\n      return childRequests.map((childRequest: interfaces.Request) => {\n        const _f = _resolveRequest(requestScope);\n        return _f(childRequest) as T | Promise<T>;\n      });\n    }\n    if (request.target.isOptional() && bindings.length === 0) {\n      return undefined;\n    }\n\n    const binding = bindings[0];\n\n    return _resolveBinding<T>(requestScope, request, binding as unknown as interfaces.Binding<T>);\n  };\n\nconst _resolveFactoryFromBinding = <T>(binding: interfaces.Binding<T>, context: interfaces.Context): T | Promise<T> => {\n  // console.count('_resolveFactoryFromBinding');\n  const factoryDetails = getFactoryDetails(binding);\n  return tryAndThrowErrorIfStackOverflow(\n    () => (factoryDetails.factory as interfaces.FactoryTypeFunction<T>).bind(binding)(context),\n    () =>\n      new Error(\n        ERROR_MSGS.CIRCULAR_DEPENDENCY_IN_FACTORY(\n          factoryDetails.factoryType,\n          context.currentRequest.serviceIdentifier.toString()\n        )\n      )\n  );\n};\n\nconst _getResolvedFromBinding = <T = unknown>(\n  requestScope: interfaces.RequestScope,\n  request: interfaces.Request,\n  binding: interfaces.Binding<T>\n): T | Promise<T> => {\n  // console.count('_getResolvedFromBinding');\n  // console.log('_getResolvedFromBinding', binding);\n  // if (!(window as any).map) {\n  //   (window as any).map = new Map();\n  // }\n  // const d = (window as any).map.get(binding.serviceIdentifier) || [];\n  // (window as any).map.set(binding.serviceIdentifier, [...d, binding]);\n  let result: T | Promise<T> | undefined;\n  const childRequests = request.childRequests;\n\n  ensureFullyBound(binding);\n\n  switch (binding.type) {\n    case BindingTypeEnum.ConstantValue:\n    case BindingTypeEnum.Function:\n      result = binding.cache as T | Promise<T>;\n      break;\n    case BindingTypeEnum.Constructor:\n      result = binding.implementationType as T;\n      break;\n    case BindingTypeEnum.Instance:\n      result = resolveInstance<T>(\n        binding,\n        binding.implementationType as interfaces.Newable<T>,\n        childRequests,\n        _resolveRequest<T>(requestScope)\n      );\n      break;\n    default:\n      result = _resolveFactoryFromBinding(binding, request.parentContext);\n  }\n\n  return result as T | Promise<T>;\n};\n\nconst _resolveInScope = <T>(\n  requestScope: interfaces.RequestScope,\n  binding: interfaces.Binding<T>,\n  resolveFromBinding: () => T | Promise<T>\n): T | Promise<T> => {\n  let result = tryGetFromScope<T>(requestScope, binding);\n  if (result !== null) {\n    return result;\n  }\n  result = resolveFromBinding();\n  saveToScope(requestScope, binding, result);\n  return result;\n};\n\nconst _resolveBinding = <T>(\n  requestScope: interfaces.RequestScope,\n  request: interfaces.Request,\n  binding: interfaces.Binding<T>\n): T | Promise<T> => {\n  return _resolveInScope<T>(requestScope, binding, () => {\n    const result = _getResolvedFromBinding(requestScope, request, binding);\n    // if (isPromise(result)) {\n    //   result = result.then(resolved => _onActivation(request, binding, resolved));\n    // } else {\n    //   result = _onActivation<T>(request, binding, result);\n    // }\n    return result;\n  });\n};\n\n// function _onActivation<T>(request: interfaces.Request, binding: interfaces.Binding<T>, resolved: T): T | Promise<T> {\n//   let result = _bindingActivation(request.parentContext, binding, resolved);\n\n//   const containersIterator = _getContainersIterator(request.parentContext.container);\n\n//   let container: interfaces.Container;\n//   let containersIteratorResult = containersIterator.next();\n\n//   do {\n//     container = containersIteratorResult.value;\n//     // const context = request.parentContext;\n//     // const serviceIdentifier = request.serviceIdentifier;\n//     // const activationsIterator = _getContainerActivationsForService(container, serviceIdentifier);\n\n//     // if (isPromise(result)) {\n//     //   result = _activateContainerAsync<T>(\n//     //     activationsIterator as Iterator<interfaces.BindingActivation<T>>,\n//     //     context,\n//     //     result\n//     //   );\n//     // } else {\n//     //   result = _activateContainer<T>(activationsIterator as Iterator<interfaces.BindingActivation<T>>, context, result);\n//     // }\n\n//     containersIteratorResult = containersIterator.next();\n\n//     // make sure if we are currently on the container that owns the binding, not to keep looping down to child containers\n//   } while (\n//     containersIteratorResult.done !== true &&\n//     !getBindingDictionary(container).hasKey(request.serviceIdentifier)\n//   );\n\n//   return result;\n// }\n\n// const _bindingActivation = <T>(\n//   context: interfaces.Context,\n//   binding: interfaces.Binding<T>,\n//   previousResult: T\n// ): T | Promise<T> => {\n//   let result: T | Promise<T>;\n\n//   // use activation handler if available\n//   if (typeof binding.onActivation === 'function') {\n//     result = binding.onActivation(context, previousResult);\n//   } else {\n//     result = previousResult;\n//   }\n\n//   return result;\n// };\n\n// const _activateContainer = <T>(\n//   activationsIterator: Iterator<interfaces.BindingActivation<T>>,\n//   context: interfaces.Context,\n//   result: T\n// ): T | Promise<T> => {\n//   let activation = activationsIterator.next();\n\n//   while (!activation.done) {\n//     result = activation.value(context, result) as T;\n\n//     if (isPromise<T>(result)) {\n//       return _activateContainerAsync(activationsIterator, context, result);\n//     }\n\n//     activation = activationsIterator.next();\n//   }\n\n//   return result;\n// };\n\n// const _activateContainerAsync = async <T>(\n//   activationsIterator: Iterator<interfaces.BindingActivation<T>>,\n//   context: interfaces.Context,\n//   resultPromise: Promise<T>\n// ): Promise<T> => {\n//   let result = await resultPromise;\n//   let activation = activationsIterator.next();\n\n//   while (!activation.done) {\n//     result = await activation.value(context, result);\n\n//     activation = activationsIterator.next();\n//   }\n\n//   return result;\n// };\n\n// const _getContainerActivationsForService = <T>(\n//   container: interfaces.Container,\n//   serviceIdentifier: interfaces.ServiceIdentifier<T>\n// ) => {\n//   // smell accessing _activations, but similar pattern is done in planner.getBindingDictionary()\n//   const activations = (\n//     container as unknown as { _activations: interfaces.Lookup<interfaces.BindingActivation<unknown>> }\n//   )._activations;\n\n//   return activations.hasKey(serviceIdentifier) ? activations.get(serviceIdentifier).values() : [].values();\n// };\n\n// const _getContainersIterator = (container: interfaces.Container): Iterator<interfaces.Container> => {\n//   const containersStack: interfaces.Container[] = [container];\n\n//   let parent = container.parent;\n\n//   while (parent !== null) {\n//     containersStack.push(parent);\n\n//     parent = parent.parent;\n//   }\n\n//   const getNextContainer: () => IteratorResult<interfaces.Container> = () => {\n//     const nextContainer = containersStack.pop();\n\n//     if (nextContainer !== undefined) {\n//       return { done: false, value: nextContainer };\n//     } else {\n//       return { done: true, value: undefined };\n//     }\n//   };\n\n//   const containersIterator: Iterator<interfaces.Container> = {\n//     next: getNextContainer\n//   };\n\n//   return containersIterator;\n// };\n\nfunction resolve<T>(context: interfaces.Context): T | Promise<T> | (T | Promise<T>)[] {\n  const _f = _resolveRequest<T>(context.plan.rootRequest.requestScope as interfaces.RequestScope);\n  return _f(context.plan.rootRequest) as T | Promise<T> | (T | Promise<T>)[];\n}\n\nexport { resolve };\n"]}