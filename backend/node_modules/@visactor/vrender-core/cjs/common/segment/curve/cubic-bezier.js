"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.CubicBezierCurve = exports.divideCubic = void 0;

const vutils_1 = require("@visactor/vutils"), base_1 = require("./base"), enums_1 = require("../../enums"), bezier_utils_1 = require("../../bezier-utils");

function divideCubic(curve, t) {
    const {p0: p0, p1: p1, p2: p2, p3: p3} = curve, pt = (0, bezier_utils_1.cubicPointAt)(p0, p1, p2, p3, t), c1 = vutils_1.PointService.pointAtPP(p0, p1, t), c2 = vutils_1.PointService.pointAtPP(p1, p2, t), c3 = vutils_1.PointService.pointAtPP(p2, p3, t), c12 = vutils_1.PointService.pointAtPP(c1, c2, t), c23 = vutils_1.PointService.pointAtPP(c2, c3, t);
    return [ new CubicBezierCurve(p0, c1, c12, pt), new CubicBezierCurve(pt, c23, c3, p3) ];
}

exports.divideCubic = divideCubic;

class CubicBezierCurve extends base_1.Curve {
    constructor(p0, p1, p2, p3) {
        super(), this.type = enums_1.CurveTypeEnum.CubicBezierCurve, this.p0 = p0, this.p1 = p1, 
        this.p2 = p2, this.p3 = p3;
    }
    _validPoint() {
        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
    }
    getPointAt(t) {
        if (!1 !== this.defined) return (0, bezier_utils_1.cubicPointAt)(this.p0, this.p1, this.p2, this.p3, t);
        throw new Error("defined为false的点不能getPointAt");
    }
    calcLength() {
        return this._validPoint() ? (0, bezier_utils_1.cubicLength)(this.p0, this.p1, this.p2, this.p3, 0) : 60;
    }
    calcProjLength(direction) {
        return direction === enums_1.Direction.ROW ? (0, vutils_1.abs)(this.p0.x - this.p3.x) : direction === enums_1.Direction.COLUMN ? (0, 
        vutils_1.abs)(this.p0.y - this.p3.y) : 0;
    }
    getAngleAt(t) {
        const minT = (0, vutils_1.max)(t - .01, 0), maxT = (0, vutils_1.min)(t + .01, 1), minP = this.getPointAt(minT), maxP = this.getPointAt(maxT);
        return (0, vutils_1.atan2)(maxP.y - minP.y, maxP.x - minP.x);
    }
    draw(path, x, y, sx, sy, percent) {
        if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.bezierCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y, this.p3.x * sx + x, this.p3.y * sy + y); else if (percent > 0) {
            const [curve1] = divideCubic(this, percent);
            path.bezierCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y, curve1.p3.x * sx + x, curve1.p3.y * sy + y);
        }
    }
    includeX(x) {
        const minX = (0, vutils_1.min)(this.p0.x, this.p1.x, this.p2.x, this.p3.x), maxX = (0, 
        vutils_1.max)(this.p0.x, this.p1.x, this.p2.x, this.p3.x);
        return x >= minX && x <= maxX;
    }
    getYAt(x) {
        const minX = (0, vutils_1.min)(this.p0.x, this.p1.x, this.p2.x, this.p3.x), t = (x - minX) / ((0, 
        vutils_1.max)(this.p0.x, this.p1.x, this.p2.x, this.p3.x) - minX);
        return this.getPointAt(t).y;
    }
}

exports.CubicBezierCurve = CubicBezierCurve;
//# sourceMappingURL=cubic-bezier.js.map
