"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.LineCurve = exports.divideLinear = void 0;

const vutils_1 = require("@visactor/vutils"), base_1 = require("./base"), enums_1 = require("../../enums");

function divideLinear(curve, t) {
    const {p0: p0, p1: p1} = curve, c1 = vutils_1.PointService.pointAtPP(p0, p1, t);
    return [ new LineCurve(p0, c1), new LineCurve(c1, p1) ];
}

exports.divideLinear = divideLinear;

class LineCurve extends base_1.Curve {
    constructor(p0, p1) {
        super(), this.type = enums_1.CurveTypeEnum.LineCurve, this.p0 = p0, this.p1 = p1;
    }
    getPointAt(t) {
        if (!1 !== this.defined) return vutils_1.PointService.pointAtPP(this.p0, this.p1, t);
        throw new Error("defined为false的点不能getPointAt");
    }
    getAngleAt(t) {
        return null == this.angle && (this.angle = (0, vutils_1.atan2)(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), 
        this.angle;
    }
    _validPoint() {
        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
    }
    calcLength() {
        return this._validPoint() ? vutils_1.PointService.distancePP(this.p0, this.p1) : 60;
    }
    calcProjLength(direction) {
        return direction === enums_1.Direction.ROW ? (0, vutils_1.abs)(this.p0.x - this.p1.x) : direction === enums_1.Direction.COLUMN ? (0, 
        vutils_1.abs)(this.p0.y - this.p1.y) : 0;
    }
    draw(path, x, y, sx, sy, percent) {
        if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.lineTo(this.p1.x * sx + x, this.p1.y * sy + y); else if (percent > 0) {
            const p = this.getPointAt(percent);
            path.lineTo(p.x * sx + x, p.y * sy + y);
        }
    }
    includeX(x) {
        return x >= this.p0.x && x <= this.p1.x || x >= this.p1.x && x <= this.p0.x;
    }
    getYAt(x) {
        if (this.includeX(x)) {
            let minP = this.p0, maxP = this.p1;
            this.p0.x > this.p1.x && (minP = this.p1, maxP = this.p0);
            const percent = (x - minP.x) / (maxP.x - minP.x);
            return minP.y + percent * (maxP.y - minP.y);
        }
        return 1 / 0;
    }
}

exports.LineCurve = LineCurve;
//# sourceMappingURL=line.js.map
