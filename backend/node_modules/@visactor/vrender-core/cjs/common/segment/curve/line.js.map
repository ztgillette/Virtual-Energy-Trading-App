{"version":3,"sources":["../src/common/segment/curve/line.ts"],"names":[],"mappings":"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","file":"line.js","sourcesContent":["import type { IPoint, IPointLike } from '@visactor/vutils';\nimport { abs, atan2, PointService } from '@visactor/vutils';\nimport type { ILineCurve, IDirection, IPath2D } from '../../../interface';\nimport { Curve } from './base';\nimport { CurveTypeEnum, Direction } from '../../enums';\n\nexport function divideLinear(curve: ILineCurve, t: number): ILineCurve[] {\n  const { p0, p1 } = curve;\n\n  // 计算两点之间的差值点\n  const c1 = PointService.pointAtPP(p0, p1, t);\n  // const direction = p1.x1 ? p1.y > p0.y ? 0 : 1 : p1.x > p0.x ? 0 : 1;\n\n  const curve1 = new LineCurve(p0, c1);\n  const curve2 = new LineCurve(c1, p1);\n\n  return [curve1, curve2];\n}\n\nexport class LineCurve extends Curve implements ILineCurve {\n  type: number = CurveTypeEnum.LineCurve;\n  declare originP1?: IPointLike;\n  declare originP2?: IPointLike;\n  declare p0: IPoint;\n  declare p1: IPoint;\n  declare angle: number;\n  constructor(p0: IPoint, p1: IPoint) {\n    super();\n    this.p0 = p0;\n    this.p1 = p1;\n  }\n  getPointAt(t: number): IPointLike {\n    if (this.defined !== false) {\n      return PointService.pointAtPP(this.p0, this.p1, t);\n    }\n    throw new Error('defined为false的点不能getPointAt');\n  }\n\n  getAngleAt(t: number): number {\n    if (this.angle == null) {\n      this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);\n    }\n    return this.angle;\n  }\n\n  protected _validPoint() {\n    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);\n  }\n\n  protected calcLength(): number {\n    if (this._validPoint()) {\n      return PointService.distancePP(this.p0, this.p1);\n    }\n    // TODO 默认长度不好给，只能给个差不多的长度\n    return 60;\n  }\n\n  protected calcProjLength(direction: IDirection): number {\n    if (direction === Direction.ROW) {\n      return abs(this.p0.x - this.p1.x);\n    } else if (direction === Direction.COLUMN) {\n      return abs(this.p0.y - this.p1.y);\n    }\n    return 0;\n  }\n\n  draw(path: IPath2D, x: number, y: number, sx: number, sy: number, percent: number) {\n    path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y);\n    if (percent >= 1) {\n      path.lineTo(this.p1.x * sx + x, this.p1.y * sy + y);\n    } else if (percent > 0) {\n      const p = this.getPointAt(percent);\n      path.lineTo(p.x * sx + x, p.y * sy + y);\n    }\n  }\n  includeX(x: number): boolean {\n    return (x >= this.p0.x && x <= this.p1.x) || (x >= this.p1.x && x <= this.p0.x);\n  }\n\n  getYAt(x: number): number {\n    if (this.includeX(x)) {\n      let minP = this.p0;\n      let maxP = this.p1;\n      if (this.p0.x > this.p1.x) {\n        minP = this.p1;\n        maxP = this.p0;\n      }\n      const percent = (x - minP.x) / (maxP.x - minP.x);\n      return minP.y + percent * (maxP.y - minP.y);\n    }\n    return Infinity;\n  }\n}\n"]}