"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.genStepClosedSegments = exports.genStepTypeSegments = exports.genStepSegments = exports.StepClosed = exports.Step = void 0;

const vutils_1 = require("@visactor/vutils"), seg_context_1 = require("../seg-context"), common_1 = require("./common"), enums_1 = require("../enums");

class Step {
    constructor(context, t = .5, startPoint) {
        this.context = context, this._t = t, this.startPoint = startPoint;
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
        0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, !1 !== this._lastDefined, this.lastPoint), 
        (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), 
        this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
    }
    point(p) {
        const x = p.x, y = p.y;
        switch (this._point) {
          case 0:
            this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p) : this.context.moveTo(x, y, p);
            break;

          case 1:
            this._point = 2;

          default:
            if (this._t <= 0) this.context.lineTo(this._x, y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), 
            this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p); else {
                const x1 = this._x * (1 - this._t) + x * this._t;
                .5 === this._t ? this.context.lineTo(x1, this._y, !1 !== this._lastDefined, this.lastPoint) : this.context.lineTo(x1, this._y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), 
                this.context.lineTo(x1, y, !1 !== this._lastDefined && !1 !== p.defined, p);
            }
        }
        this._lastDefined = p.defined, this._x = x, this._y = y, this.lastPoint = p;
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}

exports.Step = Step;

class StepClosed extends Step {
    lineEnd() {
        this.context.closePath();
    }
}

function genStepSegments(points, t, params = {}) {
    const {direction: direction, startPoint: startPoint} = params;
    if (points.length < 2 - Number(!!startPoint)) return null;
    const segContext = new seg_context_1.SegContext("step", null != direction ? direction : (0, 
    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);
    return genStepTypeSegments(new Step(segContext, t, startPoint), points), segContext;
}

function genStepTypeSegments(path, points) {
    return (0, common_1.genCurveSegments)(path, points, 1);
}

function genStepClosedSegments(points, t, params = {}) {
    const {direction: direction, startPoint: startPoint} = params;
    if (points.length < 2 - Number(!!startPoint)) return null;
    const segContext = new seg_context_1.SegContext("step", null != direction ? direction : (0, 
    vutils_1.abs)(points[points.length - 1].x - points[0].x) > (0, vutils_1.abs)(points[points.length - 1].y - points[0].y) ? enums_1.Direction.ROW : enums_1.Direction.COLUMN);
    return genStepTypeSegments(new StepClosed(segContext, t, startPoint), points), segContext;
}

exports.StepClosed = StepClosed, exports.genStepSegments = genStepSegments, exports.genStepTypeSegments = genStepTypeSegments, 
exports.genStepClosedSegments = genStepClosedSegments;
//# sourceMappingURL=step.js.map
