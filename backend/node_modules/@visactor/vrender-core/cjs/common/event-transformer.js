"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.mapToCanvasPointForCanvas = exports.transformPointForCanvas = exports.registerGlobalEventTransformer = exports.registerWindowEventTransformer = exports.createCanvasEventTransformer = exports.createEventTransformer = void 0;

const util_1 = require("../canvas/util");

function isIdentityMatrix(matrix) {
    return 1 === matrix.a && 0 === matrix.b && 0 === matrix.c && 1 === matrix.d && 0 === matrix.e && 0 === matrix.f;
}

function createEventTransformer(containerElement, getMatrix, getRect, transformPoint) {
    return event => {
        if (!(event instanceof MouseEvent || event instanceof TouchEvent || event instanceof PointerEvent)) return event;
        const transformMatrix = getMatrix();
        if (isIdentityMatrix(transformMatrix)) return event;
        const containerRect = getRect(), transformedEvent = new event.constructor(event.type, event);
        if (Object.defineProperties(transformedEvent, {
            target: {
                value: event.target
            },
            currentTarget: {
                value: event.currentTarget
            }
        }), event instanceof MouseEvent || event instanceof PointerEvent) transformPoint(event.clientX, event.clientY, transformMatrix, containerRect, transformedEvent); else if (event instanceof TouchEvent) {
            if (event.touches.length > 0) {
                const touch = transformedEvent.touches[0];
                transformPoint(touch.clientX, touch.clientY, transformMatrix, containerRect, touch);
            }
            if (event.changedTouches.length > 0) {
                const touch = transformedEvent.changedTouches[0];
                transformPoint(touch.clientX, touch.clientY, transformMatrix, containerRect, touch);
            }
        }
        return transformedEvent;
    };
}

function createCanvasEventTransformer(canvasElement, getMatrix, getRect, transformPoint) {
    return createEventTransformer(canvasElement.parentElement || canvasElement, getMatrix, getRect, transformPoint);
}

function registerWindowEventTransformer(window, container, getMatrix, getRect, transformPoint) {
    const transformer = createEventTransformer(container, getMatrix, getRect, transformPoint);
    window.setEventListenerTransformer(transformer);
}

function registerGlobalEventTransformer(global, container, getMatrix, getRect, transformPoint) {
    const transformer = createEventTransformer(container, getMatrix, getRect, transformPoint);
    global.setEventListenerTransformer(transformer);
}

function transformPointForCanvas(clientX, clientY, matrix, rect, transformedEvent) {
    const transformedPoint = {
        x: clientX,
        y: clientY
    };
    matrix.transformPoint(transformedPoint, transformedPoint), Object.defineProperties(transformedEvent, {
        _canvasX: {
            value: transformedPoint.x
        },
        _canvasY: {
            value: transformedPoint.y
        }
    });
}

function mapToCanvasPointForCanvas(nativeEvent) {
    var _a;
    if ((0, util_1.isNumber)(nativeEvent._canvasX) && (0, util_1.isNumber)(nativeEvent._canvasY)) return {
        x: nativeEvent._canvasX,
        y: nativeEvent._canvasY
    };
    if (nativeEvent.changedTouches) {
        const data = null !== (_a = nativeEvent.changedTouches[0]) && void 0 !== _a ? _a : {};
        return {
            x: data._canvasX,
            y: data._canvasY
        };
    }
    return {
        x: nativeEvent._canvasX || 0,
        y: nativeEvent._canvasY || 0
    };
}

exports.createEventTransformer = createEventTransformer, exports.createCanvasEventTransformer = createCanvasEventTransformer, 
exports.registerWindowEventTransformer = registerWindowEventTransformer, exports.registerGlobalEventTransformer = registerGlobalEventTransformer, 
exports.transformPointForCanvas = transformPointForCanvas, exports.mapToCanvasPointForCanvas = mapToCanvasPointForCanvas;
//# sourceMappingURL=event-transformer.js.map