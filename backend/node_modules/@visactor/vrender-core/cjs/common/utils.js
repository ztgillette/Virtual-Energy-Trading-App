"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.calculateLineHeight = exports._calculateLineHeight = exports.rafBasedSto = exports.RafBasedSTO = exports.getAttributeFromDefaultAttrList = exports.pointsInterpolation = exports.pointInterpolationHighPerformance = exports.pointInterpolation = exports.pointEqual = exports.pointsEqual = exports.circleBounds = exports.parsePadding = exports.parseStroke = exports.Edge = void 0;

const vutils_1 = require("@visactor/vutils");

var Edge;

!function(Edge) {
    Edge[Edge.Top = 1] = "Top", Edge[Edge.Right = 2] = "Right", Edge[Edge.Bottom = 4] = "Bottom", 
    Edge[Edge.Left = 8] = "Left", Edge[Edge.ALL = 15] = "ALL";
}(Edge = exports.Edge || (exports.Edge = {}));

const _strokeVec4 = [ !1, !1, !1, !1 ], parseStroke = stroke => {
    var _a;
    let isFullStroke = !0;
    if ((0, vutils_1.isBoolean)(stroke, !0)) {
        for (let i = 0; i < 4; i++) _strokeVec4[i] = stroke, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i]) && void 0 !== _a && !_a));
        isFullStroke = stroke;
    } else if (Array.isArray(stroke)) for (let i = 0; i < 4; i++) _strokeVec4[i] = !!stroke[i], 
    isFullStroke && (isFullStroke = !!_strokeVec4[i]); else _strokeVec4[0] = !1, _strokeVec4[1] = !1, 
    _strokeVec4[2] = !1, _strokeVec4[3] = !1;
    return {
        isFullStroke: isFullStroke,
        stroke: _strokeVec4
    };
};

exports.parseStroke = parseStroke;

const _paddingVec4 = [ 0, 0, 0, 0 ], parsePadding = padding => padding ? (0, vutils_1.isArray)(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], 
_paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], 
_paddingVec4) : padding : padding : 0;

exports.parsePadding = parsePadding;

const _coords = [ {
    x: 0,
    y: 0
}, {
    x: 0,
    y: 0
}, {
    x: 0,
    y: 0
}, {
    x: 0,
    y: 0
} ], indexList = [ 1, 2, 3, 0, 1, 2, 3, 0 ];

function circleBounds(startAngle, endAngle, radius, bounds) {
    for (;startAngle >= vutils_1.pi2; ) startAngle -= vutils_1.pi2;
    for (;startAngle < 0; ) startAngle += vutils_1.pi2;
    for (;startAngle > endAngle; ) endAngle += vutils_1.pi2;
    _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;
    const startIdx = Math.ceil(startAngle / vutils_1.halfPi) % 4, endIdx = Math.ceil(endAngle / vutils_1.halfPi) % 4;
    if (bounds.add((0, vutils_1.cos)(startAngle) * radius, (0, vutils_1.sin)(startAngle) * radius), 
    bounds.add((0, vutils_1.cos)(endAngle) * radius, (0, vutils_1.sin)(endAngle) * radius), 
    startIdx !== endIdx || endAngle - startAngle > vutils_1.pi) {
        let match = !1;
        for (let i = 0; i < indexList.length; i++) if (match || startIdx !== indexList[i]) {
            if (match && endIdx === indexList[i]) break;
            if (match) {
                const p = _coords[indexList[i]];
                bounds.add(p.x, p.y);
            }
        } else {
            match = !0;
            const p = _coords[startIdx];
            bounds.add(p.x, p.y);
        }
    }
}

function pointsEqual(pointsA, pointsB) {
    return !(!pointsA || !pointsB) && (Array.isArray(pointsA) && Array.isArray(pointsB) ? pointsA.length === pointsB.length && pointsA.every(((point, index) => pointEqual(point, pointsB[index]))) : !Number.isNaN(pointsA.x + pointsA.y) && pointEqual(pointsA, pointsB));
}

function pointEqual(pointA, pointB) {
    return pointA.x === pointB.x && pointA.y === pointB.y && pointA.x1 === pointB.x1 && pointA.y1 === pointB.y1 && pointA.defined === pointB.defined;
}

function pointInterpolation(pointA, pointB, ratio) {
    const {x: x, y: y} = (0, vutils_1.pointAt)(pointA.x, pointA.y, pointB.x, pointB.y, ratio), {x: x1, y: y1} = (0, 
    vutils_1.pointAt)(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio), point = new vutils_1.Point(x, y, x1, y1);
    return point.defined = pointB.defined, point;
}

function pointInterpolationHighPerformance(pointA, pointB, ratio, point) {
    const {x: x, y: y} = (0, vutils_1.pointAt)(pointA.x, pointA.y, pointB.x, pointB.y, ratio), {x: x1, y: y1} = (0, 
    vutils_1.pointAt)(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio);
    return point.x = x, point.y = y, point.x1 = x1, point.y1 = y1, point.defined = pointB.defined, 
    point;
}

function pointsInterpolation(pointsA, pointsB, ratio) {
    if (!pointsA || !pointsB) return [];
    Array.isArray(pointsA) || (pointsA = [ pointsA ]), Array.isArray(pointsB) || (pointsB = [ pointsB ]);
    let points = [];
    if (pointsA.length > pointsB.length) {
        points = pointsB.map((point => {
            const p = new vutils_1.Point(point.x, point.y, point.x1, point.y1);
            return p.defined = point.defined, p;
        }));
        for (let i = 0; i < pointsB.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
    } else {
        points = pointsB.map((point => {
            const p = new vutils_1.Point(point.x, point.y, point.x1, point.y1);
            return p.defined = point.defined, p;
        }));
        for (let i = 0; i < pointsA.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
    }
    return points;
}

function getAttributeFromDefaultAttrList(attr, key) {
    if ((0, vutils_1.isArray)(attr)) {
        let val;
        for (let i = 0; i < attr.length && void 0 === val; i++) val = attr[i][key];
        return val;
    }
    return attr[key];
}

exports.circleBounds = circleBounds, exports.pointsEqual = pointsEqual, exports.pointEqual = pointEqual, 
exports.pointInterpolation = pointInterpolation, exports.pointInterpolationHighPerformance = pointInterpolationHighPerformance, 
exports.pointsInterpolation = pointsInterpolation, exports.getAttributeFromDefaultAttrList = getAttributeFromDefaultAttrList;

class RafBasedSTO {
    constructor(timeout = RafBasedSTO.TimeOut) {
        this.durations = [], this.timeout = timeout, this.lastDate = 0, this.durationsListThreshold = 30;
    }
    call(cb) {
        return this.lastDate = Date.now(), setTimeout((() => {
            this.appendDuration(Date.now() - this.lastDate), cb(0);
        }), this.timeout, !0);
    }
    clear(h) {
        clearTimeout(h);
    }
    appendDuration(d) {
        this.durations.push(d), this.durations.length > this.durationsListThreshold && this.durations.shift(), 
        this.timeout = Math.min(Math.max(this.durations.reduce(((a, b) => a + b), 0) / this.durations.length, 1e3 / 60), 1e3 / 30);
    }
}

exports.RafBasedSTO = RafBasedSTO, RafBasedSTO.TimeOut = 1e3 / 60, exports.rafBasedSto = new RafBasedSTO;

const _calculateLineHeight = (lineHeight, fontSize) => {
    if ((0, vutils_1.isString)(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
        return fontSize * (Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100);
    }
    return lineHeight;
};

exports._calculateLineHeight = _calculateLineHeight;

const calculateLineHeight = (lineHeight, fontSize) => {
    const _lh = (0, exports._calculateLineHeight)(lineHeight, fontSize);
    return isNaN(_lh) ? _lh : Math.max(fontSize, _lh);
};

exports.calculateLineHeight = calculateLineHeight;
//# sourceMappingURL=utils.js.map