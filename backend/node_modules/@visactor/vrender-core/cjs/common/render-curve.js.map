{"version":3,"sources":["../src/common/render-curve.ts"],"names":[],"mappings":"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","file":"render-curve.js","sourcesContent":["import type { IPoint, IPointLike } from '@visactor/vutils';\nimport { min } from '@visactor/vutils';\nimport type {\n  IAreaSegment,\n  IClipRangeByDimensionType,\n  ICurve,\n  IDirection,\n  IPath2D,\n  ISegment,\n  ISegPath2D\n} from '../interface';\nimport { Direction } from './enums';\nimport { drawSegItem } from './render-utils';\n\nfunction drawEachCurve(\n  path: IPath2D,\n  curve: ICurve<IPoint>,\n  lastCurve: ICurve<IPoint>,\n  defined0: boolean,\n  offsetX: number,\n  offsetY: number,\n  offsetZ: number\n) {\n  let p0 = curve.p0;\n  let newDefined0 = defined0;\n\n  if (lastCurve && lastCurve.originP1 === lastCurve.originP2) {\n    p0 = lastCurve.p0;\n  }\n  if (curve.defined) {\n    // 非法变合法需要lineTo，合法变非法需要moveTo，初始非法需要moveTo\n    if (!defined0) {\n      path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ);\n      newDefined0 = !defined0;\n    }\n  } else {\n    // 找到合法的点\n    const { originP1, originP2 } = curve;\n    let validP: IPointLike;\n    // 只能第一个curve才可以用p0作为合法点，后面的curve都不应该算p1，因为已经算在前面了\n    // lastCurve只在第一个curve不存在\n    if (originP1 && originP1.defined !== false && !lastCurve) {\n      validP = p0;\n    } else if (originP1 && originP2.defined !== false) {\n      validP = curve.p3 ?? curve.p1;\n    }\n    // 合法/（初始）变非法，moveTo\n    if (defined0) {\n      newDefined0 = !defined0;\n      const x = validP ? validP.x : curve.p0.x;\n      const y = validP ? validP.y : curve.p0.y;\n      path.moveTo(x + offsetX, y + offsetY, offsetZ);\n    } else {\n      // 非法变非法/合法，看情况要不要lineTo\n      if (validP) {\n        // 非法变合法，需要lineTo\n        newDefined0 = !defined0;\n        path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ);\n      }\n    }\n  }\n\n  return newDefined0;\n}\n\n/**\n * 绘制连续的线段\n * 绘制长度为总长度percent的path，drawDirection为绘制的方向，也就是percent的方向\n * @param path\n * @param segPath\n * @param percent\n * @param drawDirection 绘制的方向，用于使用percent绘制\n * @param line 用于获取line相关属性\n */\nexport function drawSegments(\n  path: IPath2D,\n  segPath: ISegPath2D,\n  percent: number,\n  clipRangeByDimension: IClipRangeByDimensionType,\n  params?: {\n    offsetX?: number;\n    offsetY?: number;\n    offsetZ?: number;\n    drawConnect?: boolean; // 是否是绘制connect区域的效果\n    mode?: 'none' | 'connect';\n    zeroX?: number;\n    zeroY?: number;\n  }\n) {\n  const { offsetX = 0, offsetY = 0, offsetZ = 0, mode = 'none', drawConnect = false } = params || {};\n  // none的connect不需要draw\n  if (drawConnect && mode === 'none') {\n    return;\n  }\n  if (!segPath) {\n    return;\n  }\n  let needMoveTo: boolean = true;\n  const { curves } = segPath;\n  if (percent >= 1) {\n    if (drawConnect) {\n      // return;\n      let defined0 = true;\n      let lastCurve: ICurve<IPoint>;\n      curves.forEach((curve, i) => {\n        // step的逻辑\n        if (curve.originP1 === curve.originP2) {\n          lastCurve = curve;\n          return;\n        }\n        defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ);\n\n        lastCurve = curve;\n      });\n    } else {\n      curves.forEach(curve => {\n        // 跳过这个点\n        if (!curve.defined) {\n          needMoveTo = true;\n          return;\n        }\n        if (needMoveTo) {\n          path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);\n        }\n        drawSegItem(path, curve, 1, params);\n        needMoveTo = false;\n      });\n    }\n\n    return;\n  }\n  if (percent <= 0) {\n    return;\n  }\n\n  let direction: IDirection | undefined;\n\n  if (clipRangeByDimension === 'x') {\n    direction = Direction.ROW;\n  } else if (clipRangeByDimension === 'y') {\n    direction = Direction.COLUMN;\n  } else if (clipRangeByDimension === 'auto') {\n    direction = segPath.direction;\n  }\n\n  // 整个线段的总长度\n  const totalLength = segPath.tryUpdateLength(direction);\n  // 总需要绘制的长度\n  const totalDrawLength = percent * totalLength;\n  // 直到上次绘制的长度\n  let drawedLengthUntilLast = 0;\n  let defined0 = true;\n  let lastCurve: ICurve<IPoint> = null;\n  for (let i = 0, n = curves.length; i < n; i++) {\n    const curve = curves[i];\n    const curCurveLength = curve.getLength(direction);\n    const _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;\n    drawedLengthUntilLast += curCurveLength;\n    if (_p < 0) {\n      break;\n    }\n\n    if (drawConnect) {\n      // step的逻辑\n      if (curve.originP1 === curve.originP2) {\n        lastCurve = curve;\n        continue;\n      }\n      defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ);\n\n      lastCurve = curve;\n    } else {\n      // 跳过这个点\n      if (!curve.defined) {\n        needMoveTo = true;\n        continue;\n      }\n      if (needMoveTo) {\n        path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);\n      }\n      drawSegItem(path, curve, min(_p, 1), params);\n      needMoveTo = false;\n    }\n  }\n}\n\nexport function drawIncrementalSegments(\n  path: IPath2D,\n  lastSeg: ISegment,\n  segments: ISegment,\n  params?: {\n    offsetX?: number;\n    offsetY?: number;\n  }\n) {\n  const { offsetX = 0, offsetY = 0 } = params || {};\n  const startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];\n  path.moveTo(startP.x + offsetX, startP.y + offsetY);\n  segments.points.forEach(p => {\n    if (p.defined === false) {\n      path.moveTo(p.x + offsetX, p.y + offsetY);\n      return;\n    }\n    path.lineTo(p.x + offsetX, p.y + offsetY);\n  });\n}\n\nexport function drawIncrementalAreaSegments(\n  path: IPath2D,\n  lastSeg: IAreaSegment,\n  segments: IAreaSegment,\n  params?: {\n    offsetX?: number;\n    offsetY?: number;\n  }\n) {\n  const { offsetX = 0, offsetY = 0 } = params || {};\n  const { points } = segments;\n  // 分段\n  const definedPointsList: IPointLike[][] = [];\n  let lastIdx = 0;\n  for (let i = 0; i < points.length; i++) {\n    if (points[i].defined === false) {\n      if (lastIdx + 1 !== i) {\n        definedPointsList.slice(lastIdx, i);\n      }\n      lastIdx = i;\n    }\n  }\n  definedPointsList.length === 0;\n  definedPointsList.push(points);\n  definedPointsList.forEach((points, i) => {\n    const startP = lastSeg && i === 0 ? lastSeg.points[lastSeg.points.length - 1] : points[0];\n    path.moveTo(startP.x + offsetX, startP.y + offsetY);\n    // 绘制上层\n    points.forEach(p => {\n      if (p.defined === false) {\n        path.moveTo(p.x + offsetX, p.y + offsetY);\n        return;\n      }\n      path.lineTo(p.x + offsetX, p.y + offsetY);\n    });\n    // 绘制下层\n    for (let i = points.length - 1; i >= 0; i--) {\n      const p = points[i];\n      path.lineTo(p.x1 ?? p.x, p.y1 ?? p.y);\n    }\n    path.lineTo(startP.x1 ?? startP.x, startP.y1 ?? startP.y);\n    path.closePath();\n  });\n}\n"]}