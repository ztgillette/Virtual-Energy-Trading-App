{"version":3,"sources":["../src/common/inversify/syntax/binding_to_syntax.ts"],"names":[],"mappings":";;;AACA,oDAAqE;AACrE,2DAAsD;AAEtD,MAAM,eAAe;IAMnB,YAAY,OAA8B;QACxC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAED,EAAE,CAAC,WAAkC;QACnC,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG,+BAAe,CAAC,QAAQ,CAAC;QAC9C,IAAI,CAAC,QAAQ,CAAC,kBAAkB,GAAG,WAAW,CAAC;QAC/C,OAAO,IAAI,mCAAe,CAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC/C,CAAC;IAED,MAAM;QACJ,MAAM,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC;QAC7C,OAAO,IAAI,CAAC,EAAE,CAAC,IAAW,CAAC,CAAC;IAC9B,CAAC;IAED,cAAc,CAAC,IAAgC;QAC7C,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG,+BAAe,CAAC,YAAY,CAAC;QAClD,IAAI,CAAC,QAAQ,CAAC,KAAK,GAAG,IAAI,CAAC;QAC3B,IAAI,CAAC,QAAQ,CAAC,YAAY,GAAG,IAAI,CAAC;QAClC,IAAI,CAAC,QAAQ,CAAC,kBAAkB,GAAG,IAAI,CAAC;QACxC,OAAO,IAAI,mCAAe,CAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC/C,CAAC;IAED,eAAe,CAAC,KAAQ;QACtB,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG,+BAAe,CAAC,aAAa,CAAC;QACnD,IAAI,CAAC,QAAQ,CAAC,KAAK,GAAG,KAAK,CAAC;QAC5B,IAAI,CAAC,QAAQ,CAAC,YAAY,GAAG,IAAI,CAAC;QAClC,IAAI,CAAC,QAAQ,CAAC,kBAAkB,GAAG,IAAI,CAAC;QACxC,IAAI,CAAC,QAAQ,CAAC,KAAK,GAAG,gCAAgB,CAAC,SAAS,CAAC;QACjD,OAAO,IAAI,mCAAe,CAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC/C,CAAC;IAED,SAAS,CAAK,OAAsC;QAClD,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG,+BAAe,CAAC,OAAO,CAAC;QAC7C,IAAI,CAAC,QAAQ,CAAC,OAAO,GAAG,OAAO,CAAC;QAChC,IAAI,CAAC,QAAQ,CAAC,KAAK,GAAG,gCAAgB,CAAC,SAAS,CAAC;QACjD,OAAO,IAAI,mCAAe,CAAI,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC/C,CAAC;IAED,SAAS,CAAC,OAAyE;QACjF,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,CAAI,OAAO,CAAC,CAAC,CAAC;IACpE,CAAC;CACF;AAEQ,0CAAe","file":"binding_to_syntax.js","sourcesContent":["import type { interfaces } from '../interfaces';\nimport { BindingScopeEnum, BindingTypeEnum } from '../literal_types';\nimport { BindingInSyntax } from './binding_in_syntax';\n\nclass BindingToSyntax<T> implements interfaces.BindingToSyntax<T> {\n  // TODO: Implement an internal type `_BindingToSyntax<T>` wherein this member\n  // can be public. Let `BindingToSyntax<T>` be the presentational type that\n  // depends on it, and does not expose this member as public.\n  private _binding: interfaces.Binding<T>;\n\n  constructor(binding: interfaces.Binding<T>) {\n    this._binding = binding;\n  }\n\n  to(constructor: interfaces.Newable<T>): interfaces.BindingInWhenOnSyntax<T> {\n    this._binding.type = BindingTypeEnum.Instance;\n    this._binding.implementationType = constructor;\n    return new BindingInSyntax<T>(this._binding);\n  }\n\n  toSelf(): interfaces.BindingInWhenOnSyntax<T> {\n    const self = this._binding.serviceIdentifier;\n    return this.to(self as any);\n  }\n\n  toDynamicValue(func: interfaces.DynamicValue<T>): interfaces.BindingInWhenOnSyntax<T> {\n    this._binding.type = BindingTypeEnum.DynamicValue;\n    this._binding.cache = null;\n    this._binding.dynamicValue = func;\n    this._binding.implementationType = null;\n    return new BindingInSyntax<T>(this._binding);\n  }\n\n  toConstantValue(value: T): interfaces.BindingInSyntax<T> {\n    this._binding.type = BindingTypeEnum.ConstantValue;\n    this._binding.cache = value;\n    this._binding.dynamicValue = null;\n    this._binding.implementationType = null;\n    this._binding.scope = BindingScopeEnum.Singleton;\n    return new BindingInSyntax<T>(this._binding);\n  }\n\n  toFactory<T2>(factory: interfaces.FactoryCreator<T2>): interfaces.BindingInWhenOnSyntax<T> {\n    this._binding.type = BindingTypeEnum.Factory;\n    this._binding.factory = factory;\n    this._binding.scope = BindingScopeEnum.Singleton;\n    return new BindingInSyntax<T>(this._binding);\n  }\n\n  toService(service: string | symbol | interfaces.Newable<T> | interfaces.Abstract<T>): void {\n    this.toDynamicValue(context => context.container.get<T>(service));\n  }\n}\n\nexport { BindingToSyntax };\n"]}