{"version":3,"sources":["../src/common/canvas-utils.ts"],"names":[],"mappings":"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","file":"canvas-utils.js","sourcesContent":["import type { IColor, IConicalGradient, ILinearGradient, IRadialGradient } from '../interface/color';\nimport type { IContext2d, ITransform } from '../interface';\nimport type { IBoundsLike } from '@visactor/vutils';\nimport { isArray } from '@visactor/vutils';\nimport { GradientParser } from './color-utils';\n\nexport function getScaledStroke(context: IContext2d, width: number, dpr: number) {\n  let strokeWidth = width;\n  const { a, b, c, d } = context.currentMatrix;\n  const scaleX = Math.sign(a) * Math.sqrt(a * a + b * b);\n  const scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);\n  // 如果没有scaleX和scaleY，那么认为什么都不用绘制\n  if (scaleX + scaleY === 0) {\n    return 0;\n  }\n  strokeWidth = (strokeWidth / Math.abs(scaleX + scaleY)) * 2 * dpr;\n  return strokeWidth;\n}\n\nexport function createColor(\n  context: IContext2d,\n  c: string | IColor | Array<string | IColor> | boolean,\n  params: { AABBBounds?: IBoundsLike; attribute?: Partial<ITransform> },\n  offsetX: number = 0,\n  offsetY: number = 0\n): string | CanvasGradient {\n  if (!c || c === true) {\n    return 'black';\n  }\n  let result: string | CanvasGradient | undefined;\n  let color: string | IColor;\n  if (isArray(c)) {\n    for (let i = 0; i < c.length; i++) {\n      color = c[i];\n      if (color) {\n        break;\n      }\n    }\n  } else {\n    color = c;\n  }\n  color = GradientParser.Parse(color);\n  if (typeof color === 'string') {\n    return color;\n  }\n  // 如果是渐变色的话，需要根据bounds来计算渐变色的范围\n  if (params.AABBBounds && (!params.attribute || params.attribute.scaleX !== 0 || params.attribute.scaleY !== 0)) {\n    const bounds = params.AABBBounds;\n    let w = bounds.x2 - bounds.x1;\n    let h = bounds.y2 - bounds.y1;\n    let x = bounds.x1 - offsetX;\n    let y = bounds.y1 - offsetY;\n    // 检测是否有angle、scale，如果有的话，说明context有transform。\n    // 需要获取图元原始的bounds宽高，然后设置xy为0才行\n    if (params.attribute) {\n      const { scaleX = 1, scaleY = 1, angle = 0 } = params.attribute;\n      w /= scaleX;\n      h /= scaleY;\n      x /= scaleX;\n      y /= scaleY;\n      if (angle || scaleX !== 1 || scaleY !== 1) {\n        // symbol的时候锚点是在中间的，所以bounds不能按0算\n        x = (params as any).x1WithoutTransform ?? 0;\n        y = (params as any).y1WithoutTransform ?? 0;\n        w = (params as any).widthWithoutTransform ?? w;\n        h = (params as any).heightWithoutTransform ?? h;\n      }\n    }\n    // TODO 不同scaleCenter有问题\n    if (color.gradient === 'linear') {\n      result = createLinearGradient(context, color, x, y, w, h);\n    } else if (color.gradient === 'conical') {\n      result = createConicGradient(context, color, x, y, w, h);\n    } else if (color.gradient === 'radial') {\n      result = createRadialGradient(context, color, x, y, w, h);\n    }\n  }\n  return result || 'orange';\n}\n\nfunction createLinearGradient(context: IContext2d, color: ILinearGradient, x: number, y: number, w: number, h: number) {\n  const canvasGradient = context.createLinearGradient(\n    x + (color.x0 ?? 0) * w,\n    y + (color.y0 ?? 0) * h,\n    x + (color.x1 ?? 1) * w,\n    y + (color.y1 ?? 0) * h\n  );\n  color.stops.forEach(stop => {\n    canvasGradient.addColorStop(stop.offset, stop.color);\n  });\n  return canvasGradient;\n}\n\nfunction createRadialGradient(context: IContext2d, color: IRadialGradient, x: number, y: number, w: number, h: number) {\n  const canvasGradient = context.createRadialGradient(\n    x + (color.x0 ?? 0.5) * w,\n    y + (color.y0 ?? 0.5) * h,\n    Math.max(w, h) * (color.r0 ?? 0),\n    x + (color.x1 ?? 0.5) * w,\n    y + (color.y1 ?? 0.5) * h,\n    Math.max(w, h) * (color.r1 ?? 0.5)\n  );\n  color.stops.forEach(stop => {\n    canvasGradient.addColorStop(stop.offset, stop.color);\n  });\n  return canvasGradient;\n}\n\nfunction createConicGradient(context: IContext2d, color: IConicalGradient, x: number, y: number, w: number, h: number) {\n  const canvasGradient = context.createConicGradient(\n    x + (color.x ?? 0) * w,\n    y + (color.y ?? 0) * h,\n    color.startAngle,\n    color.endAngle\n  );\n  color.stops.forEach(stop => {\n    canvasGradient.addColorStop(stop.offset, stop.color);\n  });\n\n  let deltaAngle;\n  return (canvasGradient as any).GetPattern\n    ? (canvasGradient as any).GetPattern(w + x, h + y, deltaAngle)\n    : canvasGradient;\n}\n"]}