{"version":3,"sources":["../src/common/event-transformer.ts"],"names":[],"mappings":"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","file":"event-transformer.js","sourcesContent":["import type { IAABBBounds } from '@visactor/vutils';\nimport type { Matrix } from '@visactor/vutils';\nimport type { IGlobal, IWindow } from '../interface';\nimport { isNumber } from '../canvas/util';\n\nfunction isIdentityMatrix(matrix: Matrix): boolean {\n  return matrix.a === 1 && matrix.b === 0 && matrix.c === 0 && matrix.d === 1 && matrix.e === 0 && matrix.f === 0;\n}\n\n/**\n * Create an event transformer that corrects event coordinates based on container transformations\n * @param containerElement The container element\n * @param matrix The transformation matrix to apply\n * @param rect Optional DOMRect of the container, if not provided will use getBoundingClientRect\n * @returns A function that transforms events to correct coordinates\n */\nexport function createEventTransformer(\n  containerElement: HTMLElement,\n  getMatrix: () => Matrix,\n  getRect: () => IAABBBounds,\n  transformPoint: (clientX: number, clientY: number, matrix: Matrix, rect: IAABBBounds, transformedEvent: Event) => void\n): (event: Event) => Event {\n  return (event: Event): Event => {\n    // Only transform mouse and touch events that have coordinates\n    if (!(event instanceof MouseEvent) && !(event instanceof TouchEvent) && !(event instanceof PointerEvent)) {\n      return event;\n    }\n\n    // Use provided matrix\n    const transformMatrix = getMatrix();\n\n    // If there's no transformation, return the original event\n    if (isIdentityMatrix(transformMatrix)) {\n      return event;\n    }\n\n    // Get the container's bounding rect for coordinate conversion\n    const containerRect = getRect();\n\n    // Create a copy of the event to modify\n    const transformedEvent = new (event.constructor as any)(event.type, event);\n    Object.defineProperties(transformedEvent, {\n      target: { value: event.target },\n      currentTarget: { value: event.currentTarget }\n    });\n\n    if (event instanceof MouseEvent || event instanceof PointerEvent) {\n      transformPoint(event.clientX, event.clientY, transformMatrix, containerRect, transformedEvent);\n    } else if (event instanceof TouchEvent) {\n      // For touch events, we need to transform each touch point\n      // This is a simplified version that assumes we're only using the first touch\n      if (event.touches.length > 0) {\n        const touch = transformedEvent.touches[0];\n        transformPoint(touch.clientX, touch.clientY, transformMatrix, containerRect, touch);\n      }\n      if (event.changedTouches.length > 0) {\n        const touch = transformedEvent.changedTouches[0];\n        transformPoint(touch.clientX, touch.clientY, transformMatrix, containerRect, touch);\n      }\n    }\n\n    return transformedEvent;\n  };\n}\n\n/**\n * Create an event transformer for the given canvas element\n * @param canvasElement The canvas element\n * @param getMatrix The transformation matrix to apply\n * @param getRect Optional DOMRect of the container\n * @returns A function that transforms events to correct coordinates\n */\nexport function createCanvasEventTransformer(\n  canvasElement: HTMLCanvasElement,\n  getMatrix: () => Matrix,\n  getRect: () => IAABBBounds,\n  transformPoint: (clientX: number, clientY: number, matrix: Matrix, rect: IAABBBounds, transformedEvent: Event) => void\n): (event: Event) => Event {\n  return createEventTransformer(canvasElement.parentElement || canvasElement, getMatrix, getRect, transformPoint);\n}\n\n/**\n * Register the event transformer with a DefaultWindow instance\n * @param window The window instance\n * @param container The container element\n * @param getMatrix The transformation matrix to apply\n * @param getRect Optional DOMRect of the container\n */\nexport function registerWindowEventTransformer(\n  window: IWindow,\n  container: HTMLElement,\n  getMatrix: () => Matrix,\n  getRect: () => IAABBBounds,\n  transformPoint: (clientX: number, clientY: number, matrix: Matrix, rect: IAABBBounds, transformedEvent: Event) => void\n): void {\n  const transformer = createEventTransformer(container, getMatrix, getRect, transformPoint);\n  window.setEventListenerTransformer(transformer);\n}\n\n/**\n * Register the event transformer with a DefaultGlobal instance\n * @param global The global instance\n * @param container The container element\n * @param getMatrix The transformation matrix to apply\n * @param getRect Optional DOMRect of the container\n */\nexport function registerGlobalEventTransformer(\n  global: IGlobal,\n  container: HTMLElement,\n  getMatrix: () => Matrix,\n  getRect: () => IAABBBounds,\n  transformPoint: (clientX: number, clientY: number, matrix: Matrix, rect: IAABBBounds, transformedEvent: Event) => void\n): void {\n  const transformer = createEventTransformer(container, getMatrix, getRect, transformPoint);\n  global.setEventListenerTransformer(transformer);\n}\n\nexport function transformPointForCanvas(\n  clientX: number,\n  clientY: number,\n  matrix: Matrix,\n  rect: IAABBBounds,\n  transformedEvent: Event\n) {\n  // Apply the inverse transformation\n  const transformedPoint = { x: clientX, y: clientY };\n\n  matrix.transformPoint(transformedPoint, transformedPoint);\n\n  // Update the event properties\n  Object.defineProperties(transformedEvent, {\n    _canvasX: { value: transformedPoint.x },\n    _canvasY: { value: transformedPoint.y }\n  });\n  return;\n}\n\nexport function mapToCanvasPointForCanvas(nativeEvent: any) {\n  if (isNumber(nativeEvent._canvasX) && isNumber(nativeEvent._canvasY)) {\n    return {\n      x: nativeEvent._canvasX,\n      y: nativeEvent._canvasY\n    };\n  } else if ((nativeEvent as TouchEvent).changedTouches) {\n    const data = (nativeEvent as TouchEvent).changedTouches[0] ?? ({} as any);\n    return {\n      x: data._canvasX,\n      y: data._canvasY\n    };\n  }\n  const x = (nativeEvent as any)._canvasX || 0;\n  const y = (nativeEvent as any)._canvasY || 0;\n  return {\n    x,\n    y\n  };\n}\n"]}