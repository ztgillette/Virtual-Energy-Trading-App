{"version":3,"sources":["../src/common/morphing-utils.ts"],"names":[],"mappings":"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","file":"morphing-utils.js","sourcesContent":["/* Adapted from zrender by ecomfe\n * https://github.com/ecomfe/zrender\n * Licensed under the BSD-3-Clause\n\n * url: https://github.com/ecomfe/zrender/blob/master/src/tool/morphPath.ts\n * License: https://github.com/ecomfe/zrender/blob/master/LICENSE\n * @license\n */\n\nimport type { IMatrix } from '@visactor/vutils';\nimport { getAngleByPoint, isNumberClose, PointService } from '@visactor/vutils';\nimport type { ICustomPath2D } from '../interface';\nimport { CustomPath2D } from './custom-path2d';\nimport { enumCommandMap } from './path-svg';\nimport { addArcToBezierPath } from './shape/arc';\n\nexport function cubicSubdivide(p0: number, p1: number, p2: number, p3: number, t: number, out: number[]) {\n  const p01 = (p1 - p0) * t + p0;\n  const p12 = (p2 - p1) * t + p1;\n  const p23 = (p3 - p2) * t + p2;\n\n  const p012 = (p12 - p01) * t + p01;\n  const p123 = (p23 - p12) * t + p12;\n\n  const p0123 = (p123 - p012) * t + p012;\n  // Seg0\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012;\n  out[3] = p0123;\n  // Seg1\n  out[4] = p0123;\n  out[5] = p123;\n  out[6] = p23;\n  out[7] = p3;\n}\n\nexport function alignSubpath(subpath1: number[], subpath2: number[]): [number[], number[]] {\n  const len1 = subpath1.length;\n  const len2 = subpath2.length;\n  if (len1 === len2) {\n    return [subpath1, subpath2];\n  }\n  const tmpSegX: number[] = [];\n  const tmpSegY: number[] = [];\n\n  const shorterPath = len1 < len2 ? subpath1 : subpath2;\n  const shorterLen = Math.min(len1, len2);\n  // Should divide excatly\n  const diff = Math.abs(len2 - len1) / 6;\n  const shorterBezierCount = (shorterLen - 2) / 6;\n  // Add `diff` number of beziers\n  const eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount);\n\n  const newSubpath = [shorterPath[0], shorterPath[1]];\n  let remained = diff;\n\n  for (let i = 2; i < shorterLen; i += 6) {\n    let x0 = shorterPath[i - 2];\n    let y0 = shorterPath[i - 1];\n    let x1 = shorterPath[i];\n    let y1 = shorterPath[i + 1];\n    let x2 = shorterPath[i + 2];\n    let y2 = shorterPath[i + 3];\n    const x3 = shorterPath[i + 4];\n    const y3 = shorterPath[i + 5];\n\n    if (remained <= 0) {\n      newSubpath.push(x1, y1, x2, y2, x3, y3);\n      continue;\n    }\n\n    const actualSubDivCount = Math.min(remained, eachCurveSubDivCount) + 1;\n    for (let k = 1; k <= actualSubDivCount; k++) {\n      const p = k / actualSubDivCount;\n\n      cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n      cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n\n      // tmpSegX[3] === tmpSegX[4]\n      x0 = tmpSegX[3];\n      y0 = tmpSegY[3];\n\n      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n      x1 = tmpSegX[5];\n      y1 = tmpSegY[5];\n      x2 = tmpSegX[6];\n      y2 = tmpSegY[6];\n      // The last point (x3, y3) is still the same.\n    }\n    remained -= actualSubDivCount - 1;\n  }\n\n  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\n\nfunction createSubpath(lastSubpath: number[], otherSubpath: number[]) {\n  const prevSubPath = lastSubpath || otherSubpath;\n  const len = prevSubPath.length;\n  const lastX = prevSubPath[len - 2];\n  const lastY = prevSubPath[len - 1];\n\n  const newSubpath: number[] = [];\n  for (let i = 0; i < otherSubpath.length; i += 2) {\n    newSubpath[i] = lastX;\n    newSubpath[i + 1] = lastY;\n  }\n  return newSubpath;\n}\n\nfunction reverseSubpath(array: number[]) {\n  const newArr: number[] = [];\n  const len = array.length;\n  for (let i = 0; i < len; i += 2) {\n    newArr[i] = array[len - i - 2];\n    newArr[i + 1] = array[len - i - 1];\n  }\n  return newArr;\n}\n/**\n * 用于计算内部不相交的多边形中心点\n */\nexport function centroidOfSubpath(array: number[]) {\n  // https://en.wikipedia.org/wiki/Centroid#Of_a_polygon\n  let signedArea = 0;\n  let cx = 0;\n  let cy = 0;\n  const len = array.length;\n  // Polygon should been closed.\n  for (let i = 0, j = len - 2; i < len; j = i, i += 2) {\n    const x0 = array[j];\n    const y0 = array[j + 1];\n    const x1 = array[i];\n    const y1 = array[i + 1];\n    const a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n  }\n\n  if (signedArea === 0) {\n    return [array[0] || 0, array[1] || 0, 0];\n  }\n\n  return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\n\n/**\n * 针对闭合的曲线，查找最适合的旋转offset\n */\nfunction findBestRotationOffset(fromSubBeziers: number[], toSubBeziers: number[], fromCp: number[], toCp: number[]) {\n  const bezierCount = (fromSubBeziers.length - 2) / 6;\n  let bestScore = Infinity;\n  let bestOffset = 0;\n\n  const len = fromSubBeziers.length;\n  const len2 = len - 2;\n\n  for (let offset = 0; offset < bezierCount; offset++) {\n    const cursorOffset = offset * 6;\n    let score = 0;\n\n    for (let k = 0; k < len; k += 2) {\n      const idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2) + 2;\n\n      const x0 = fromSubBeziers[idx] - fromCp[0];\n      const y0 = fromSubBeziers[idx + 1] - fromCp[1];\n      const x1 = toSubBeziers[k] - toCp[0];\n      const y1 = toSubBeziers[k + 1] - toCp[1];\n\n      const dx = x1 - x0;\n      const dy = y1 - y0;\n      score += dx * dx + dy * dy;\n    }\n    if (score < bestScore) {\n      bestScore = score;\n      bestOffset = offset;\n    }\n  }\n\n  return bestOffset;\n}\n\n/**\n * If we interpolating between two bezier curve arrays.\n * It will have many broken effects during the transition.\n * So we try to apply an extra rotation which can make each bezier curve morph as small as possible.\n */\nexport function findBestMorphingRotation(\n  fromArr: number[][],\n  toArr: number[][],\n  searchAngleIteration: number,\n  searchAngleRange: number\n) {\n  const result = [];\n\n  let fromNeedsReverse: boolean;\n\n  for (let i = 0; i < fromArr.length; i++) {\n    let fromSubpathBezier = fromArr[i];\n    const toSubpathBezier = toArr[i];\n\n    const fromCp = centroidOfSubpath(fromSubpathBezier);\n    const toCp = centroidOfSubpath(toSubpathBezier);\n\n    if (fromNeedsReverse == null) {\n      // Reverse from array if two have different directions.\n      // Determine the clockwise based on the first subpath.\n      // Reverse all subpaths or not. Avoid winding rule changed.\n      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n    }\n\n    const newFromSubpathBezier: number[] = [];\n    const newToSubpathBezier: number[] = [];\n    let bestAngle = 0;\n    let bestScore = Infinity;\n    const tmpArr: number[] = [];\n\n    const len = fromSubpathBezier.length;\n    if (fromNeedsReverse) {\n      // Make sure clockwise\n      fromSubpathBezier = reverseSubpath(fromSubpathBezier);\n    }\n    const offset = findBestRotationOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n\n    const len2 = len - 2;\n\n    for (let k = 0; k < len2; k += 2) {\n      // Not include the start point.\n      const idx = ((offset + k) % len2) + 2;\n      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n    }\n    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n\n    if (searchAngleIteration > 0) {\n      const step = searchAngleRange / searchAngleIteration;\n      for (let angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n        const sa = Math.sin(angle);\n        const ca = Math.cos(angle);\n        let score = 0;\n\n        for (let k = 0; k < fromSubpathBezier.length; k += 2) {\n          const x0 = newFromSubpathBezier[k];\n          const y0 = newFromSubpathBezier[k + 1];\n          const x1 = toSubpathBezier[k] - toCp[0];\n          const y1 = toSubpathBezier[k + 1] - toCp[1];\n\n          // Apply rotation on the target point.\n          const newX1 = x1 * ca - y1 * sa;\n          const newY1 = x1 * sa + y1 * ca;\n\n          tmpArr[k] = newX1;\n          tmpArr[k + 1] = newY1;\n\n          const dx = newX1 - x0;\n          const dy = newY1 - y0;\n\n          // Use dot product to have min direction change.\n          // const d = Math.sqrt(x0 * x0 + y0 * y0);\n          // score += x0 * dx / d + y0 * dy / d;\n          score += dx * dx + dy * dy;\n        }\n\n        if (score < bestScore) {\n          bestScore = score;\n          bestAngle = angle;\n          // Copy.\n          for (let m = 0; m < tmpArr.length; m++) {\n            newToSubpathBezier[m] = tmpArr[m];\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i < len; i += 2) {\n        newToSubpathBezier[i] = toSubpathBezier[i] - toCp[0];\n        newToSubpathBezier[i + 1] = toSubpathBezier[i + 1] - toCp[1];\n      }\n    }\n\n    result.push({\n      from: newFromSubpathBezier,\n      to: newToSubpathBezier,\n      fromCp,\n      toCp,\n      rotation: -bestAngle\n    });\n  }\n  return result;\n}\n\n/**\n * Make two bezier arrays aligns on structure. To have better animation.\n *\n * It will:\n * Make two bezier arrays have same number of subpaths.\n * Make each subpath has equal number of bezier curves.\n *\n * array is the convert result of pathToBezierCurves.\n */\nexport function alignBezierCurves(array1: number[][], array2: number[][]) {\n  let lastSubpath1;\n  let lastSubpath2;\n\n  const newArray1 = [];\n  const newArray2 = [];\n\n  for (let i = 0; i < Math.max(array1.length, array2.length); i++) {\n    const subpath1 = array1[i];\n    const subpath2 = array2[i];\n\n    let newSubpath1;\n    let newSubpath2;\n\n    if (!subpath1) {\n      newSubpath1 = createSubpath(lastSubpath1, subpath2);\n      newSubpath2 = subpath2;\n    } else if (!subpath2) {\n      newSubpath2 = createSubpath(lastSubpath2, subpath1);\n      newSubpath1 = subpath1;\n    } else {\n      [newSubpath1, newSubpath2] = alignSubpath(subpath1, subpath2);\n      lastSubpath1 = newSubpath1;\n      lastSubpath2 = newSubpath2;\n    }\n\n    newArray1.push(newSubpath1);\n    newArray2.push(newSubpath2);\n  }\n\n  return [newArray1, newArray2];\n}\n\n/**\n * 将路径转换为贝塞尔曲线数组\n * 通过复用CustomPath2D中的方法，确保处理的一致性\n * @param path 要转换的路径\n * @returns 贝塞尔曲线数组\n */\nexport function pathToBezierCurves(path: ICustomPath2D): number[][] {\n  // 创建临时路径和临时上下文\n  const tempPath = new CustomPath2D();\n\n  // 将路径转换为SVG路径字符串，这样可以利用CustomPath2D中的解析能力\n  const svgPathString = path.toString();\n\n  // 如果路径为空，直接返回空数组\n  if (!svgPathString) {\n    return [];\n  }\n\n  // 使用临时路径解析SVG字符串\n  tempPath.fromString(svgPathString);\n\n  // 确保曲线已经构建\n  const curves = tempPath.tryBuildCurves();\n\n  if (!curves || curves.length === 0) {\n    return [];\n  }\n\n  // 用于存储分离的子路径\n  const bezierSubpaths: number[][] = [];\n  let currentSubpath: number[] = null;\n\n  // 初始化当前子路径\n  currentSubpath = [];\n  let firstX = 0; // 记录子路径起点X (用于闭合路径)\n  let firstY = 0; // 记录子路径起点Y (用于闭合路径)\n  let lastX = 0; // 记录上一个点的X (用于连续线段)\n  let lastY = 0; // 记录上一个点的Y (用于连续线段)\n  let isSubpathStart = true;\n  let isPathClosed = false;\n\n  for (let i = 0; i < curves.length; i++) {\n    const curve = curves[i];\n\n    // 如果是新的子路径开始或者第一个点\n    if (isSubpathStart) {\n      firstX = curve.p0.x;\n      firstY = curve.p0.y;\n      lastX = firstX;\n      lastY = firstY;\n      currentSubpath = [firstX, firstY];\n      bezierSubpaths.push(currentSubpath);\n      isSubpathStart = false;\n    }\n\n    // 处理不同类型的曲线\n    if (curve.p1 && curve.p2 && curve.p3) {\n      // 三次贝塞尔曲线\n      currentSubpath.push(curve.p1.x, curve.p1.y, curve.p2.x, curve.p2.y, curve.p3.x, curve.p3.y);\n      lastX = curve.p3.x;\n      lastY = curve.p3.y;\n    } else if (curve.p1 && curve.p2) {\n      // 二次贝塞尔曲线，转换为三次贝塞尔曲线\n      const x1 = curve.p1.x;\n      const y1 = curve.p1.y;\n      const x2 = curve.p2.x;\n      const y2 = curve.p2.y;\n\n      currentSubpath.push(\n        lastX + (2 / 3) * (x1 - lastX),\n        lastY + (2 / 3) * (y1 - lastY),\n        x2 + (2 / 3) * (x1 - x2),\n        y2 + (2 / 3) * (y1 - y2),\n        x2,\n        y2\n      );\n\n      lastX = x2;\n      lastY = y2;\n    } else if (curve.p1) {\n      // 直线段，转换为贝塞尔曲线格式\n      // 直线的情况，p1就是终点\n      const endX = curve.p1.x;\n      const endY = curve.p1.y;\n\n      // 避免添加长度为0的线段\n      if (!(Math.abs(lastX - endX) < 1e-10 && Math.abs(lastY - endY) < 1e-10)) {\n        // 使用addLineToBezierPath的逻辑：x0,y0, x1,y1, x1,y1\n        // 第一个控制点等于起点，第二个控制点等于终点，终点等于终点\n        currentSubpath.push(\n          lastX,\n          lastY, // 第一个控制点 = 起点\n          endX,\n          endY, // 第二个控制点 = 终点\n          endX,\n          endY // 终点\n        );\n      }\n\n      lastX = endX;\n      lastY = endY;\n    }\n\n    // 检查是否是闭合路径（最后一个点回到起点）\n    if (i === curves.length - 1) {\n      if (Math.abs(lastX - firstX) < 1e-10 && Math.abs(lastY - firstY) < 1e-10) {\n        isPathClosed = true;\n      }\n    }\n\n    // 检查是否需要开始新的子路径\n    // 只有在检测到明确的路径中断（不连续的点）时才开始新子路径\n    if (i < curves.length - 1) {\n      const nextCurve = curves[i + 1];\n      if (Math.abs(lastX - nextCurve.p0.x) > 1e-10 || Math.abs(lastY - nextCurve.p0.y) > 1e-10) {\n        // 当前子路径结束，需要创建新的子路径\n        isSubpathStart = true;\n      }\n    }\n  }\n\n  // 移除空的子路径\n  const validSubpaths = bezierSubpaths.filter(subpath => subpath.length > 2);\n\n  // 为了保持与原始函数一致，如果只有一个子路径，返回它的数组\n  return validSubpaths.length === 1 ? [validSubpaths[0]] : validSubpaths;\n}\n\nexport function applyTransformOnBezierCurves(bezierCurves: number[][], martrix: IMatrix) {\n  for (let i = 0; i < bezierCurves.length; i++) {\n    const subPath = bezierCurves[i];\n    for (let k = 0; k < subPath.length; k += 2) {\n      const x = subPath[k];\n      const y = subPath[k + 1];\n      const res = { x, y };\n\n      martrix.transformPoint({ x, y }, res);\n\n      subPath[k] = res.x;\n      subPath[k + 1] = res.y;\n    }\n  }\n}\n\nexport function bezierCurversToPath(bezierCurves: number[][]) {\n  const path = new CustomPath2D();\n\n  for (let i = 0; i < bezierCurves.length; i++) {\n    const subPath = bezierCurves[i];\n\n    if (subPath.length > 2) {\n      path.moveTo(subPath[0], subPath[1]);\n      for (let k = 2; k < subPath.length; k += 6) {\n        path.bezierCurveTo(subPath[k], subPath[k + 1], subPath[k + 2], subPath[k + 3], subPath[k + 4], subPath[k + 5]);\n      }\n    }\n  }\n\n  return path;\n}\n"]}