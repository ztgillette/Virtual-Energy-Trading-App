"use strict";

var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasLineRender = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_lite_1 = require("../../../common/inversify-lite"), theme_1 = require("../../../graphic/theme"), constants_1 = require("../../../graphic/constants"), base_render_1 = require("./base-render"), render_curve_1 = require("../../../common/render-curve"), segment_1 = require("../../../common/segment");

let DefaultCanvasLineRender = class extends base_render_1.BaseRender {
    constructor() {
        super(...arguments), this.numberType = constants_1.LINE_NUMBER_TYPE;
    }
    draw(line, renderService, drawContext, params) {
        const lineAttribute = (0, theme_1.getTheme)(line, null == params ? void 0 : params.theme).line;
        this._draw(line, lineAttribute, !1, drawContext, params);
    }
    drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
        var _a;
        if (!cache) return;
        context.beginPath();
        const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
        (0, render_curve_1.drawSegments)(context, cache, clipRange, clipRangeByDimension, {
            offsetX: offsetX,
            offsetY: offsetY,
            offsetZ: z
        }), line.cache && !(0, vutils_1.isArray)(line.cache) && line.cache.curves.every((c => c.defined)) && line.attribute.curveType && line.attribute.curveType.includes("Closed") && context.closePath(), 
        context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute);
        const {x: originX = 0, x: originY = 0} = attribute;
        return !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), 
        context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), 
        context.stroke())), !1;
    }
    drawLinearLineHighPerformance(line, context, fill, stroke, fillOpacity, strokeOpacity, offsetX, offsetY, lineAttribute, drawContext, params, fillCb, strokeCb) {
        var _a;
        context.beginPath();
        const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, {points: points} = line.attribute, startP = points[0];
        context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
        for (let i = 1; i < points.length; i++) {
            const p = points[i];
            context.lineTo(p.x + offsetX, p.y + offsetY, z);
        }
        context.setShadowBlendStyle && context.setShadowBlendStyle(line, line.attribute, lineAttribute);
        const {x: originX = 0, x: originY = 0} = line.attribute;
        !1 !== fill && (fillCb ? fillCb(context, line.attribute, lineAttribute) : fillOpacity && (context.setCommonStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), 
        context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, line.attribute, lineAttribute) : strokeOpacity && (context.setStrokeStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), 
        context.stroke()));
    }
    drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
        const lineAttribute = (0, theme_1.getTheme)(line, null == params ? void 0 : params.theme).line, {fill: fill = lineAttribute.fill, stroke: stroke = lineAttribute.stroke, fillOpacity: fillOpacity = lineAttribute.fillOpacity, strokeOpacity: strokeOpacity = lineAttribute.strokeOpacity, segments: segments, points: points, closePath: closePath, curveTension: curveTension = lineAttribute.curveTension, connectedType: connectedType = lineAttribute.connectedType} = line.attribute;
        if (!this.valid(line, lineAttribute, fillCb, strokeCb)) return;
        let {curveType: curveType = lineAttribute.curveType} = line.attribute;
        closePath && "linear" === curveType && (curveType = "linearClosed");
        const {clipRange: clipRange = lineAttribute.clipRange, clipRangeByDimension: clipRangeByDimension = lineAttribute.clipRangeByDimension} = line.attribute;
        if (1 === clipRange && !segments && !points.some((p => !1 === p.defined)) && "linear" === curveType) return this.drawLinearLineHighPerformance(line, context, !!fill, !!stroke, fillOpacity, strokeOpacity, x, y, lineAttribute, drawContext, params, fillCb, strokeCb);
        function parsePoint(points, connectedType) {
            return "none" === connectedType ? points : points.filter((p => !1 !== p.defined));
        }
        if (line.shouldUpdateShape()) {
            const {points: points, segments: segments} = line.attribute, _points = points;
            if (segments && segments.length) {
                let startPoint, lastSeg;
                if (line.cache = segments.map(((seg, index) => {
                    if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastSeg = {
                        endX: seg.points[0].x,
                        endY: seg.points[0].y,
                        curves: [ {
                            defined: !1 !== seg.points[0].defined
                        } ]
                    }), null;
                    1 === index ? startPoint = {
                        x: lastSeg.endX,
                        y: lastSeg.endY,
                        defined: lastSeg.curves[lastSeg.curves.length - 1].defined
                    } : index > 1 && (startPoint.x = lastSeg.endX, startPoint.y = lastSeg.endY, startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined);
                    const data = (0, segment_1.calcLineCache)(parsePoint(seg.points, connectedType), curveType, {
                        startPoint: startPoint,
                        curveTension: curveTension
                    });
                    return lastSeg = data, data;
                })).filter((item => !!item)), "linearClosed" === curveType) {
                    let startP;
                    for (let i = 0; i < line.cache.length; i++) {
                        const cacheItem = line.cache[i];
                        for (let i = 0; i < cacheItem.curves.length; i++) if (cacheItem.curves[i].defined) {
                            startP = cacheItem.curves[i].p0;
                            break;
                        }
                        if (startP) break;
                    }
                    line.cache[line.cache.length - 1] && line.cache[line.cache.length - 1].lineTo(startP.x, startP.y, !0);
                }
            } else {
                if (!points || !points.length) return line.cache = null, void line.clearUpdateShapeTag();
                line.cache = (0, segment_1.calcLineCache)(parsePoint(_points, connectedType), curveType, {
                    curveTension: curveTension
                });
            }
            line.clearUpdateShapeTag();
        }
        if (Array.isArray(line.cache)) {
            const segments = line.attribute.segments.filter((item => item.points.length));
            if (1 === segments[0].points.length && segments.shift(), 1 === clipRange) {
                let skip = !1;
                line.cache.forEach(((cache, index) => {
                    skip || (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, segments[index], [ lineAttribute, line.attribute ], clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb));
                }));
            } else {
                const totalLength = line.cache.reduce(((l, c) => l + c.getLength()), 0), totalDrawLength = clipRange * totalLength;
                let drawedLengthUntilLast = 0, skip = !1;
                line.cache.forEach(((cache, index) => {
                    if (skip) return;
                    const curSegLength = cache.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
                    drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, segments[index], [ lineAttribute, line.attribute ], (0, 
                    vutils_1.min)(_cr, 1), clipRangeByDimension, x, y, line, fillCb, strokeCb));
                }));
            }
        } else this.drawSegmentItem(context, line.cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);
    }
};

DefaultCanvasLineRender = __decorate([ (0, inversify_lite_1.injectable)() ], DefaultCanvasLineRender), 
exports.DefaultCanvasLineRender = DefaultCanvasLineRender;
//# sourceMappingURL=line-render.js.map
