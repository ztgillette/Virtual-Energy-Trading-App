"use strict";

var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.DefaultCanvasArc3DRender = void 0;

const vutils_1 = require("@visactor/vutils"), inversify_lite_1 = require("../../../common/inversify-lite"), theme_1 = require("../../../graphic/theme"), base_render_1 = require("./base-render"), constants_1 = require("../../../graphic/constants"), color_string_1 = require("../../../color-string");

function drawArcPath(arc, context, cx, cy, z, outerRadius, innerRadius) {
    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = (0, 
    vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;
    let collapsedToLine = !1;
    if (outerRadius < innerRadius) {
        const temp = outerRadius;
        outerRadius = innerRadius, innerRadius = temp;
    }
    if (outerRadius <= vutils_1.epsilon) context.moveTo(cx, cy, z); else if (deltaAngle >= vutils_1.pi2 - vutils_1.epsilon) context.moveTo(cx + outerRadius * (0, 
    vutils_1.cos)(startAngle), cy + outerRadius * (0, vutils_1.sin)(startAngle), z), 
    context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z), innerRadius > vutils_1.epsilon && (context.moveTo(cx + innerRadius * (0, 
    vutils_1.cos)(endAngle), cy + innerRadius * (0, vutils_1.sin)(endAngle), z), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z)); else {
        const {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle), xors = outerRadius * (0, 
        vutils_1.cos)(outerStartAngle), yors = outerRadius * (0, vutils_1.sin)(outerStartAngle), xire = innerRadius * (0, 
        vutils_1.cos)(innerEndAngle), yire = innerRadius * (0, vutils_1.sin)(innerEndAngle);
        outerDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z), 
        context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z)), 
        !(innerRadius > vutils_1.epsilon) || innerDeltaAngle < .001 ? (context.lineTo(cx + xire, cy + yire, z), 
        collapsedToLine = !0) : (context.lineTo(cx + xire, cy + yire, z), context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z));
    }
    return context.closePath(), collapsedToLine;
}

function drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {
    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = (0, 
    vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;
    let collapsedToLine = !1;
    if (radius <= vutils_1.epsilon) context.moveTo(cx, cy, z1); else if (deltaAngle >= vutils_1.pi2 - vutils_1.epsilon) context.moveTo(cx + radius * (0, 
    vutils_1.cos)(startAngle), cy + radius * (0, vutils_1.sin)(startAngle), z1), context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1), 
    context.lineTo(cx + radius * (0, vutils_1.cos)(endAngle), cy + radius * (0, vutils_1.sin)(endAngle), z2), 
    context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2); else {
        const {innerouterDeltaAngle: innerouterDeltaAngle, innerouterStartAngle: innerouterStartAngle, innerouterEndAngle: innerouterEndAngle} = getParsePadAngle(startAngle, endAngle), xors = radius * (0, 
        vutils_1.cos)(innerouterStartAngle), yors = radius * (0, vutils_1.sin)(innerouterStartAngle), xore = radius * (0, 
        vutils_1.cos)(innerouterEndAngle), yore = radius * (0, vutils_1.sin)(innerouterEndAngle);
        innerouterDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z1), 
        context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1), 
        context.lineTo(cx + xore, cy + yore, z2), context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2));
    }
    return context.closePath(), collapsedToLine;
}

let DefaultCanvasArc3DRender = class extends base_render_1.BaseRender {
    constructor() {
        super(...arguments), this.numberType = constants_1.ARC3D_NUMBER_TYPE;
    }
    drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        const arcAttribute = (0, theme_1.getTheme)(arc, null == params ? void 0 : params.theme).arc, {fill: fill = arcAttribute.fill} = arc.attribute, data = this.valid(arc, arcAttribute, fillCb, strokeCb);
        if (!data) return;
        const {fVisible: fVisible, sVisible: sVisible, doFill: doFill, doStroke: doStroke} = data, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, {outerPadding: outerPadding = arcAttribute.outerPadding, innerPadding: innerPadding = arcAttribute.innerPadding, height: height = 10} = arc.attribute;
        let {outerRadius: outerRadius = arcAttribute.outerRadius, innerRadius: innerRadius = arcAttribute.innerRadius} = arc.attribute;
        outerRadius += outerPadding, innerRadius -= innerPadding;
        const rgbArray = color_string_1.ColorStore.Get(fill, color_string_1.ColorType.Color255), {light: light} = drawContext.stage || {}, face = drawContext.hack_pieFace, z_face = {
            top: z,
            bottom: z + height
        }, n_face = {
            top: [ 0, 1, 0 ],
            bottom: [ 0, -1, 0 ],
            outside: [ 1, 0, -1 ],
            inside: [ 1, 0, -1 ]
        };
        "bottom" === face || "top" === face ? (context.beginPath(), drawArcPath(arc, context, x, y, z_face[face], outerRadius, innerRadius), 
        context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), 
        doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), 
        context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), 
        doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), 
        context.stroke()))) : "outside" !== face && "inside" !== face || ("inside" === face && (context.save(), 
        context.beginPath(), context.arc(x, y, innerRadius, 0, vutils_1.pi2, !0, z_face.top), 
        context.clip()), context.beginPath(), drawInnerOuterArcPath(arc, context, x, y, z_face.top, z_face.bottom, "outside" === face ? outerRadius : innerRadius, ((startAngle, endAngle) => {
            const {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle);
            return "outside" === face ? {
                innerouterDeltaAngle: outerDeltaAngle,
                innerouterEndAngle: outerEndAngle,
                innerouterStartAngle: outerStartAngle
            } : {
                innerouterDeltaAngle: innerDeltaAngle,
                innerouterEndAngle: innerEndAngle,
                innerouterStartAngle: innerStartAngle
            };
        })), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), 
        doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), 
        context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), 
        doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), 
        context.stroke())), "inside" === face && context.restore());
    }
    draw(arc, renderService, drawContext, params) {
        const arcAttribute = (0, theme_1.getTheme)(arc, null == params ? void 0 : params.theme).arc;
        this._draw(arc, arcAttribute, !1, drawContext, params);
    }
};

DefaultCanvasArc3DRender = __decorate([ (0, inversify_lite_1.injectable)() ], DefaultCanvasArc3DRender), 
exports.DefaultCanvasArc3DRender = DefaultCanvasArc3DRender;
//# sourceMappingURL=arc3d-render.js.map
