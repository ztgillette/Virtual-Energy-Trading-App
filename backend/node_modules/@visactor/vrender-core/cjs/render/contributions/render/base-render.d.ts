import type { IPointLike } from '@visactor/vutils';
import type { IGraphicAttribute, ICamera, IContext2d, IGraphic, mat4, IDrawContext, IGraphicRenderDrawParams, IMarkAttribute, IThemeAttribute, IContributionProvider, IBaseRenderContribution } from '../../../interface';
export declare abstract class BaseRender<T extends IGraphic> {
    camera: ICamera;
    z: number;
    builtinContributions: IBaseRenderContribution<T, T['attribute']>[];
    protected graphicRenderContributions: IContributionProvider<IBaseRenderContribution<T, T['attribute']>>;
    protected _beforeRenderContribitions: IBaseRenderContribution<T, T['attribute']>[];
    protected _afterRenderContribitions: IBaseRenderContribution<T, T['attribute']>[];
    protected _renderContribitions: IBaseRenderContribution<T, T['attribute']>[];
    init(contributions?: IContributionProvider<IBaseRenderContribution<T, T['attribute']>>): void;
    reInit(): void;
    beforeRenderStep(graphic: T, context: IContext2d, x: number, y: number, doFill: boolean, doStroke: boolean, fVisible: boolean, sVisible: boolean, graphicAttribute: Required<T['attribute']>, drawContext: IDrawContext, fillCb?: (ctx: IContext2d, markAttribute: Partial<IMarkAttribute & IGraphicAttribute>, themeAttribute: IThemeAttribute) => boolean, strokeCb?: (ctx: IContext2d, markAttribute: Partial<IMarkAttribute & IGraphicAttribute>, themeAttribute: IThemeAttribute) => boolean, params?: any): void;
    afterRenderStep(graphic: T, context: IContext2d, x: number, y: number, doFill: boolean, doStroke: boolean, fVisible: boolean, sVisible: boolean, graphicAttribute: Required<T['attribute']>, drawContext: IDrawContext, fillCb?: (ctx: IContext2d, markAttribute: Partial<IMarkAttribute & IGraphicAttribute>, themeAttribute: IThemeAttribute) => boolean, strokeCb?: (ctx: IContext2d, markAttribute: Partial<IMarkAttribute & IGraphicAttribute>, themeAttribute: IThemeAttribute) => boolean, params?: any): void;
    drawPathProxy(graphic: T, context: IContext2d, x: number, y: number, drawContext: IDrawContext, params?: IGraphicRenderDrawParams, fillCb?: (ctx: IContext2d, markAttribute: Partial<IMarkAttribute & IGraphicAttribute>, themeAttribute: IThemeAttribute) => boolean, strokeCb?: (ctx: IContext2d, markAttribute: Partial<IMarkAttribute & IGraphicAttribute>, themeAttribute: IThemeAttribute) => boolean): boolean;
    valid(graphic: IGraphic, defaultAttribute: IGraphicAttribute, fillCb?: any, strokeCb?: any): false | {
        fVisible: boolean;
        sVisible: boolean;
        doFill: boolean;
        doStroke: boolean;
    };
    transform(graphic: IGraphic, graphicAttribute: Partial<IGraphicAttribute>, context: IContext2d, use3dMatrixIn3dMode?: boolean): IPointLike & {
        z: number;
        lastModelMatrix: mat4;
    };
    transformUseContext2d(graphic: IGraphic, graphicAttribute: IGraphicAttribute, z: number, context: IContext2d): void;
    restoreTransformUseContext2d(graphic: IGraphic, graphicAttribute: IGraphicAttribute, z: number, context: IContext2d): void;
    protected transformWithoutTranslate(context: IContext2d, x: number, y: number, z: number, scaleX: number, scaleY: number, angle: number): void;
    _draw(graphic: T, defaultAttr: IGraphicAttribute, computed3dMatrix: boolean, drawContext: IDrawContext, params?: IGraphicRenderDrawParams, themeAttribute?: IGraphicAttribute): void;
    drawShape?(path: T, context: IContext2d, x: number, y: number, drawContext: IDrawContext, params?: IGraphicRenderDrawParams, fillCb?: (ctx: IContext2d, markAttribute: Partial<IMarkAttribute & IGraphicAttribute>, themeAttribute: IThemeAttribute) => boolean, strokeCb?: (ctx: IContext2d, markAttribute: Partial<IMarkAttribute & IGraphicAttribute>, themeAttribute: IThemeAttribute) => boolean, themeAttribute?: IGraphicAttribute): void;
}
