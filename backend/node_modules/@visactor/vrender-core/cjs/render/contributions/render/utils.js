"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
}), exports.drawArcPath = exports.calculateArcCornerRadius = exports.cornerTangents = exports.intersect = exports.rectStrokeVisible = exports.strokeVisible = exports.rectFillVisible = exports.fillVisible = exports.runStroke = exports.runFill = void 0;

const vutils_1 = require("@visactor/vutils");

function runFill(fill, background) {
    return !(!fill && !background);
}

function runStroke(stroke, lineWidth) {
    let s;
    return s = (0, vutils_1.isArray)(stroke) ? stroke.some((item => item || void 0 === item)) : !!stroke, 
    s && lineWidth > 0;
}

function fillVisible(opacity, fillOpacity, fill) {
    return fill && opacity * fillOpacity > 0;
}

function rectFillVisible(opacity, fillOpacity, width, height, fill) {
    return fill && opacity * fillOpacity > 0 && 0 !== width && 0 !== height;
}

function strokeVisible(opacity, strokeOpacity) {
    return opacity * strokeOpacity > 0;
}

function rectStrokeVisible(opacity, strokeOpacity, width, height, drawStrokeWhenZeroWH) {
    return drawStrokeWhenZeroWH ? opacity * strokeOpacity > 0 : opacity * strokeOpacity > 0 && 0 !== width && 0 !== height;
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    const x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2;
    let t = y32 * x10 - x32 * y10;
    return t * t < vutils_1.epsilon ? [] : (t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, 
    [ x0 + t * x10, y0 + t * y10 ]);
}

function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
    const x01 = x0 - x1, y01 = y0 - y1, lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
    let cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2;
    const cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
    return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), 
    {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
    };
}

function calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius) {
    const deltaAngle = (0, vutils_1.abs)(endAngle - startAngle), cornerRadius = arc.getParsedCornerRadius(), cornerRadiusIsArray = (0, 
    vutils_1.isArray)(cornerRadius), {outerDeltaAngle: outerDeltaAngle, innerDeltaAngle: innerDeltaAngle, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle} = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[0] : cornerRadius, outerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[1] : cornerRadius, innerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[2] : cornerRadius, innerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[3] : cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
    let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;
    const xors = outerRadius * (0, vutils_1.cos)(outerStartAngle), yors = outerRadius * (0, 
    vutils_1.sin)(outerStartAngle), xire = innerRadius * (0, vutils_1.cos)(innerEndAngle), yire = innerRadius * (0, 
    vutils_1.sin)(innerEndAngle);
    let xore, yore, xirs, yirs;
    if ((maxInnerCornerRadius > vutils_1.epsilon || maxOuterCornerRadius > vutils_1.epsilon) && (xore = outerRadius * (0, 
    vutils_1.cos)(outerEndAngle), yore = outerRadius * (0, vutils_1.sin)(outerEndAngle), 
    xirs = innerRadius * (0, vutils_1.cos)(innerStartAngle), yirs = innerRadius * (0, 
    vutils_1.sin)(innerStartAngle), deltaAngle < vutils_1.pi)) {
        const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
        if (oc) {
            const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / (0, 
            vutils_1.sin)((0, vutils_1.acos)((ax * bx + ay * by) / ((0, vutils_1.sqrt)(ax * ax + ay * ay) * (0, 
            vutils_1.sqrt)(bx * bx + by * by))) / 2), lc = (0, vutils_1.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
            limitedIcr = (0, vutils_1.min)(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), 
            limitedOcr = (0, vutils_1.min)(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
        }
    }
    return {
        outerDeltaAngle: outerDeltaAngle,
        xors: xors,
        yors: yors,
        xirs: xirs,
        yirs: yirs,
        xore: xore,
        yore: yore,
        xire: xire,
        yire: yire,
        limitedOcr: limitedOcr,
        limitedIcr: limitedIcr,
        outerCornerRadiusStart: outerCornerRadiusStart,
        outerCornerRadiusEnd: outerCornerRadiusEnd,
        maxOuterCornerRadius: maxOuterCornerRadius,
        maxInnerCornerRadius: maxInnerCornerRadius,
        outerStartAngle: outerStartAngle,
        outerEndAngle: outerEndAngle,
        innerDeltaAngle: innerDeltaAngle,
        innerEndAngle: innerEndAngle,
        innerStartAngle: innerStartAngle,
        innerCornerRadiusStart: innerCornerRadiusStart,
        innerCornerRadiusEnd: innerCornerRadiusEnd
    };
}

function drawArcPath(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
    const {startAngle: startAngle, endAngle: endAngle} = arc.getParsedAngle(), deltaAngle = (0, 
    vutils_1.abs)(endAngle - startAngle), clockwise = endAngle > startAngle;
    let collapsedToLine = !1;
    if (outerRadius < innerRadius) {
        const temp = outerRadius;
        outerRadius = innerRadius, innerRadius = temp;
    }
    if (outerRadius <= vutils_1.epsilon) context.moveTo(cx, cy); else if (deltaAngle >= vutils_1.pi2 - vutils_1.epsilon) context.moveTo(cx + outerRadius * (0, 
    vutils_1.cos)(startAngle), cy + outerRadius * (0, vutils_1.sin)(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), 
    innerRadius > vutils_1.epsilon && (context.moveTo(cx + innerRadius * (0, vutils_1.cos)(endAngle), cy + innerRadius * (0, 
    vutils_1.sin)(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise)); else {
        const {outerDeltaAngle: outerDeltaAngle, xors: xors, yors: yors, xirs: xirs, yirs: yirs, limitedOcr: limitedOcr, outerCornerRadiusStart: outerCornerRadiusStart, outerCornerRadiusEnd: outerCornerRadiusEnd, maxOuterCornerRadius: maxOuterCornerRadius, xore: xore, yore: yore, xire: xire, yire: yire, outerStartAngle: outerStartAngle, outerEndAngle: outerEndAngle, limitedIcr: limitedIcr, innerDeltaAngle: innerDeltaAngle, innerEndAngle: innerEndAngle, innerStartAngle: innerStartAngle, innerCornerRadiusStart: innerCornerRadiusStart, innerCornerRadiusEnd: innerCornerRadiusEnd, maxInnerCornerRadius: maxInnerCornerRadius} = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
        if (outerDeltaAngle < .001) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), 
        collapsedToLine = !0; else if (limitedOcr > vutils_1.epsilon) {
            const cornerRadiusStart = (0, vutils_1.min)(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = (0, 
            vutils_1.min)(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
            limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, (0, vutils_1.atan2)(t0.y01, t0.x01), (0, 
            vutils_1.atan2)(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * (0, 
            vutils_1.cos)((0, vutils_1.atan2)(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * (0, 
            vutils_1.sin)((0, vutils_1.atan2)(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, (0, 
            vutils_1.atan2)(t0.y01, t0.x01), (0, vutils_1.atan2)(t0.y11, t0.x11), !clockwise), 
            context.arc(cx, cy, outerRadius, (0, vutils_1.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, 
            vutils_1.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, (0, 
            vutils_1.atan2)(t1.y11, t1.x11), (0, vutils_1.atan2)(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * (0, 
            vutils_1.cos)((0, vutils_1.atan2)(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * (0, 
            vutils_1.sin)((0, vutils_1.atan2)(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * (0, 
            vutils_1.sin)(outerEndAngle));
        } else !partStroke || partStroke[0] ? (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise)) : context.moveTo(cx + outerRadius * (0, 
        vutils_1.cos)(outerEndAngle), cy + outerRadius * (0, vutils_1.sin)(outerEndAngle));
        if (!(innerRadius > vutils_1.epsilon) || innerDeltaAngle < .001) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), 
        collapsedToLine = !0; else if (limitedIcr > vutils_1.epsilon) {
            const cornerRadiusStart = (0, vutils_1.min)(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = (0, 
            vutils_1.min)(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
            if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), 
            limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                const arcEndAngle = (0, vutils_1.atan2)(t1.y01, t1.x01);
                !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, (0, 
                vutils_1.atan2)(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + (0, 
                vutils_1.cos)(arcEndAngle), cy + t0.cy + (0, vutils_1.sin)(arcEndAngle));
            } else !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, (0, 
            vutils_1.atan2)(t0.y01, t0.x01), (0, vutils_1.atan2)(t0.y11, t0.x11), !clockwise), 
            context.arc(cx, cy, innerRadius, (0, vutils_1.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, 
            vutils_1.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, (0, 
            vutils_1.atan2)(t1.y11, t1.x11), (0, vutils_1.atan2)(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * (0, 
            vutils_1.cos)((0, vutils_1.atan2)(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * (0, 
            vutils_1.sin)((0, vutils_1.atan2)(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);
        } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), 
        !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * (0, 
        vutils_1.cos)(innerStartAngle), cy + innerRadius * (0, vutils_1.sin)(innerStartAngle));
    }
    return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * (0, vutils_1.cos)(startAngle), cy + outerRadius * (0, 
    vutils_1.sin)(startAngle)) : context.closePath(), collapsedToLine;
}

exports.runFill = runFill, exports.runStroke = runStroke, exports.fillVisible = fillVisible, 
exports.rectFillVisible = rectFillVisible, exports.strokeVisible = strokeVisible, 
exports.rectStrokeVisible = rectStrokeVisible, exports.intersect = intersect, exports.cornerTangents = cornerTangents, 
exports.calculateArcCornerRadius = calculateArcCornerRadius, exports.drawArcPath = drawArcPath;
//# sourceMappingURL=utils.js.map
