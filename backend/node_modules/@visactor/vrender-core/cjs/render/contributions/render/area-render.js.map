{"version":3,"sources":["../src/render/contributions/render/area-render.ts"],"names":[],"mappings":"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","file":"area-render.js","sourcesContent":["import type { IPointLike } from '@visactor/vutils';\nimport { abs, isArray, min } from '@visactor/vutils';\nimport { inject, injectable, named } from '../../../common/inversify-lite';\nimport type {\n  IArea,\n  IAreaCacheItem,\n  IAreaGraphicAttribute,\n  IGraphicAttribute,\n  IContext2d,\n  IMarkAttribute,\n  IThemeAttribute,\n  ISegPath2D,\n  IAreaRenderContribution,\n  IDrawContext,\n  IRenderService,\n  IGraphicRender,\n  IGraphicRenderDrawParams,\n  IContributionProvider\n} from '../../../interface';\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\nimport { ContributionProvider } from '../../../common/contribution-provider';\nimport { calcLineCache } from '../../../common/segment';\n\nimport { getTheme } from '../../../graphic/theme';\nimport { AreaRenderContribution } from './contributions/constants';\nimport { Direction } from '../../../common/enums';\nimport { drawAreaSegments } from '../../../common/render-area';\nimport { AREA_NUMBER_TYPE } from '../../../graphic/constants';\nimport { drawSegments } from '../../../common/render-curve';\nimport { BaseRender } from './base-render';\nimport {\n  defaultAreaBackgroundRenderContribution,\n  defaultAreaTextureRenderContribution\n} from './contributions/area-contribution-render';\n\n@injectable()\nexport class DefaultCanvasAreaRender extends BaseRender<IArea> implements IGraphicRender {\n  type: 'area';\n  numberType: number = AREA_NUMBER_TYPE;\n\n  constructor(\n    @inject(ContributionProvider)\n    @named(AreaRenderContribution)\n    protected readonly graphicRenderContributions: IContributionProvider<IAreaRenderContribution>\n  ) {\n    super();\n    this.builtinContributions = [defaultAreaTextureRenderContribution, defaultAreaBackgroundRenderContribution];\n    this.init(graphicRenderContributions);\n  }\n\n  drawLinearAreaHighPerformance(\n    area: IArea,\n    context: IContext2d,\n    fill: boolean,\n    stroke: boolean,\n    fillOpacity: number,\n    strokeOpacity: number,\n    offsetX: number,\n    offsetY: number,\n    areaAttribute: Required<IAreaGraphicAttribute>,\n    drawContext: IDrawContext,\n    params?: IGraphicRenderDrawParams,\n    fillCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    const { points } = area.attribute;\n    if (points.length < 2) {\n      return;\n    }\n    context.beginPath();\n\n    const z = this.z ?? 0;\n    const startP = points[0];\n\n    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);\n    for (let i = 1; i < points.length; i++) {\n      const p = points[i];\n      context.lineTo(p.x + offsetX, p.y + offsetY, z);\n    }\n    for (let i = points.length - 1; i >= 0; i--) {\n      const p = points[i];\n      context.lineTo((p.x1 ?? p.x) + offsetX, (p.y1 ?? p.y) + offsetY, z);\n    }\n    context.closePath();\n\n    // shadow\n    context.setShadowBlendStyle && context.setShadowBlendStyle(area, area.attribute, areaAttribute);\n\n    this.beforeRenderStep(\n      area,\n      context,\n      offsetX,\n      offsetY,\n      !!fillOpacity,\n      false,\n      fill,\n      false,\n      areaAttribute as any,\n      drawContext,\n      fillCb,\n      null,\n      { attribute: area.attribute }\n    );\n\n    const { x: originX = 0, x: originY = 0 } = area.attribute;\n    const _runFill = () => {\n      if (fill !== false) {\n        if (fillCb) {\n          fillCb(context, area.attribute, areaAttribute);\n        } else if (fillOpacity) {\n          context.setCommonStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute);\n          context.fill();\n        }\n      }\n    };\n\n    const _runStroke = () => {\n      if (stroke) {\n        const { stroke = areaAttribute && areaAttribute.stroke } = area.attribute;\n        if (isArray(stroke) && (stroke[0] || stroke[2]) && stroke[1] === false) {\n          context.beginPath();\n          if (stroke[0]) {\n            context.moveTo(startP.x + offsetX, startP.y + offsetY, z);\n            for (let i = 1; i < points.length; i++) {\n              const p = points[i];\n              context.lineTo(p.x + offsetX, p.y + offsetY, z);\n            }\n          } else if (stroke[2]) {\n            const endP = points[points.length - 1];\n            context.moveTo(endP.x + offsetX, endP.y + offsetY, z);\n            for (let i = points.length - 2; i >= 0; i--) {\n              const p = points[i];\n              context.lineTo((p.x1 ?? p.x) + offsetX, (p.y1 ?? p.y) + offsetY, z);\n            }\n          }\n        }\n        if (strokeCb) {\n          strokeCb(context, area.attribute, areaAttribute);\n        } else {\n          context.setStrokeStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute);\n          context.stroke();\n        }\n      }\n    };\n\n    _runFill();\n    this.afterRenderStep(\n      area,\n      context,\n      offsetX,\n      offsetY,\n      !!fillOpacity,\n      false,\n      fill,\n      false,\n      areaAttribute as any,\n      drawContext,\n      fillCb,\n      null,\n      { attribute: area.attribute }\n    );\n    _runStroke();\n  }\n\n  drawShape(\n    area: IArea,\n    context: IContext2d,\n    x: number,\n    y: number,\n    drawContext: IDrawContext,\n    params?: IGraphicRenderDrawParams,\n    fillCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    const areaAttribute = getTheme(area, params?.theme).area;\n    const {\n      fill = areaAttribute.fill,\n      stroke = areaAttribute.stroke,\n      fillOpacity = areaAttribute.fillOpacity,\n      z = areaAttribute.z,\n      strokeOpacity = areaAttribute.strokeOpacity,\n      curveTension = areaAttribute.curveTension,\n      connectedType = areaAttribute.connectedType\n    } = area.attribute;\n\n    const data = this.valid(area, areaAttribute, fillCb, strokeCb);\n    if (!data) {\n      return;\n    }\n    const { doFill } = data;\n    const doStroke = data.doStroke && data.sVisible;\n\n    const { clipRange = areaAttribute.clipRange, closePath, points, segments } = area.attribute;\n    let { curveType = areaAttribute.curveType } = area.attribute;\n    if (closePath && curveType === 'linear') {\n      curveType = 'linearClosed';\n    }\n\n    function parsePoint(points: IPointLike[], connectedType: 'none' | 'connect') {\n      if (connectedType !== 'connect') {\n        return points;\n      }\n      return points.filter(p => p.defined !== false);\n    }\n\n    if (clipRange === 1 && !segments && !points.some(p => p.defined === false) && curveType === 'linear') {\n      return this.drawLinearAreaHighPerformance(\n        area,\n        context,\n        !!fill,\n        doStroke,\n        fillOpacity,\n        strokeOpacity,\n        x,\n        y,\n        areaAttribute,\n        drawContext,\n        params,\n        fillCb,\n        strokeCb\n      );\n    }\n\n    // 更新cache\n    if (area.shouldUpdateShape()) {\n      if (segments && segments.length) {\n        let startPoint: IPointLike;\n        let lastTopSeg: { endX: number; endY: number };\n        const topCaches = segments\n          .map((seg, index) => {\n            if (seg.points.length <= 1) {\n              // 第一个点的话，直接设置lastTopSeg\n              if (index === 0) {\n                seg.points[0] && (lastTopSeg = { endX: seg.points[0].x, endY: seg.points[0].y });\n                return null;\n              }\n            }\n            // 添加上一个segment结束的点作为这个segment的起始点\n            if (index === 1) {\n              startPoint = { x: lastTopSeg.endX, y: lastTopSeg.endY };\n            } else if (index > 1) {\n              startPoint.x = lastTopSeg.endX;\n              startPoint.y = lastTopSeg.endY;\n            }\n            const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {\n              startPoint,\n              curveTension\n            });\n            lastTopSeg = data;\n            return data;\n          })\n          .filter(item => !!item);\n        let lastBottomSeg: ISegPath2D;\n        const bottomCaches = [];\n        for (let i = segments.length - 1; i >= 0; i--) {\n          const points = segments[i].points;\n          const bottomPoints: IPointLike[] = [];\n          for (let i = points.length - 1; i >= 0; i--) {\n            bottomPoints.push({\n              x: points[i].x1 ?? points[i].x,\n              y: points[i].y1 ?? points[i].y\n            });\n          }\n          // 处理一下bottom的segments，bottom的segments需要手动添加endPoints\n          if (i !== 0) {\n            const lastSegmentPoints = segments[i - 1].points;\n            const endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];\n            endPoint &&\n              bottomPoints.push({\n                x: endPoint.x1 ?? endPoint.x,\n                y: endPoint.y1 ?? endPoint.y\n              });\n          }\n          if (bottomPoints.length > 1) {\n            lastBottomSeg = calcLineCache(\n              parsePoint(bottomPoints, connectedType),\n              curveType === 'stepBefore' ? 'stepAfter' : curveType === 'stepAfter' ? 'stepBefore' : curveType,\n              { curveTension }\n            );\n            bottomCaches.unshift(lastBottomSeg);\n          }\n        }\n        area.cacheArea = bottomCaches.map((item, index) => ({\n          top: topCaches[index],\n          bottom: item\n        }));\n      } else if (points && points.length) {\n        // 转换points\n        const topPoints = parsePoint(points, connectedType);\n        const bottomPoints: IPointLike[] = [];\n        for (let i = topPoints.length - 1; i >= 0; i--) {\n          bottomPoints.push({\n            x: topPoints[i].x1 ?? topPoints[i].x,\n            y: topPoints[i].y1 ?? topPoints[i].y\n          });\n        }\n        const topCache = calcLineCache(topPoints, curveType, { curveTension });\n        const bottomCache = calcLineCache(\n          bottomPoints,\n          curveType === 'stepBefore' ? 'stepAfter' : curveType === 'stepAfter' ? 'stepBefore' : curveType,\n          { curveTension }\n        );\n\n        area.cacheArea = { top: topCache, bottom: bottomCache };\n      } else {\n        area.cacheArea = null;\n        area.clearUpdateShapeTag();\n        return;\n      }\n      area.clearUpdateShapeTag();\n    }\n\n    if (Array.isArray(area.cacheArea)) {\n      const segments = area.attribute.segments.filter(item => item.points.length);\n      // 如果第一个seg只有一个点，那么shift出去\n      if (segments[0].points.length === 1) {\n        segments.shift();\n      }\n      if (clipRange === 1) {\n        let skip = false;\n        // 性能优化，不需要clip的线段不需要计算长度\n        area.cacheArea.forEach((cache, index) => {\n          if (skip) {\n            return;\n          }\n          skip = this.drawSegmentItem(\n            context,\n            cache,\n            doFill,\n            fillOpacity,\n            doStroke,\n            strokeOpacity,\n            segments[index],\n            [areaAttribute, area.attribute],\n            clipRange,\n            x,\n            y,\n            z,\n            area,\n            drawContext,\n            fillCb,\n            strokeCb\n          );\n        });\n      } else {\n        // 如果是segments的话，每个clipRange需要重新计算\n        // 整个线段的总长度\n        const totalLength = area.cacheArea.reduce((l, c) => l + c.top.getLength(), 0);\n        // 总需要绘制的长度\n        const totalDrawLength = clipRange * totalLength;\n        // 直到上次绘制的长度\n        let drawedLengthUntilLast = 0;\n        let skip = false;\n        area.cacheArea.forEach((cache, index) => {\n          if (skip) {\n            return;\n          }\n          const curSegLength = cache.top.getLength();\n          const _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;\n          drawedLengthUntilLast += curSegLength;\n          if (_cr > 0) {\n            skip = this.drawSegmentItem(\n              context,\n              cache,\n              doFill,\n              fillOpacity,\n              doStroke,\n              strokeOpacity,\n              segments[index],\n              [areaAttribute, area.attribute],\n              min(_cr, 1),\n              x,\n              y,\n              z,\n              area,\n              drawContext,\n              fillCb,\n              strokeCb\n            );\n          }\n        });\n      }\n    } else {\n      this.drawSegmentItem(\n        context,\n        area.cacheArea as IAreaCacheItem,\n        doFill,\n        fillOpacity,\n        doStroke,\n        strokeOpacity,\n        area.attribute,\n        areaAttribute,\n        clipRange,\n        x,\n        y,\n        z,\n        area,\n        drawContext,\n        fillCb,\n        strokeCb\n      );\n    }\n  }\n\n  draw(area: IArea, renderService: IRenderService, drawContext: IDrawContext, params?: IGraphicRenderDrawParams) {\n    const areaAttribute = getTheme(area, params?.theme).area;\n    this._draw(area, areaAttribute, false, drawContext, params);\n  }\n\n  /**\n   * 绘制segment\n   * @param context\n   * @param cache\n   * @param fill\n   * @param stroke\n   * @param attribute\n   * @param defaultAttribute\n   * @param clipRange\n   * @param offsetX\n   * @param offsetY\n   * @param fillCb\n   * @param strokeCb\n   * @returns 返回true代表跳过后续绘制\n   */\n  protected drawSegmentItem(\n    context: IContext2d,\n    cache: IAreaCacheItem,\n    fill: boolean,\n    fillOpacity: number,\n    stroke: boolean,\n    strokeOpacity: number,\n    attribute: Partial<IAreaGraphicAttribute>,\n    defaultAttribute: Required<IAreaGraphicAttribute> | Partial<IAreaGraphicAttribute>[],\n    clipRange: number,\n    offsetX: number,\n    offsetY: number,\n    offsetZ: number,\n    area: IArea,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute | IThemeAttribute[]\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute | IThemeAttribute[]\n    ) => boolean\n  ): boolean {\n    return this._drawSegmentItem(\n      context,\n      cache,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeOpacity,\n      attribute,\n      defaultAttribute,\n      clipRange,\n      offsetX,\n      offsetY,\n      offsetZ,\n      area,\n      drawContext,\n      fillCb,\n      strokeCb\n    );\n  }\n\n  protected _drawSegmentItem(\n    context: IContext2d,\n    cache: IAreaCacheItem,\n    fill: boolean,\n    fillOpacity: number,\n    stroke: boolean,\n    strokeOpacity: number,\n    attribute: Partial<IAreaGraphicAttribute>,\n    defaultAttribute: Required<IAreaGraphicAttribute> | Partial<IAreaGraphicAttribute>[],\n    clipRange: number,\n    offsetX: number,\n    offsetY: number,\n    offsetZ: number,\n    area: IArea,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute | IThemeAttribute[]\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute | IThemeAttribute[]\n    ) => boolean\n  ) {\n    if (\n      !(\n        cache &&\n        cache.top &&\n        cache.bottom &&\n        cache.top.curves &&\n        cache.top.curves.length &&\n        cache.bottom.curves &&\n        cache.bottom.curves.length\n      )\n    ) {\n      return;\n    }\n\n    context.beginPath();\n\n    const ret: boolean = false;\n    const { points, segments } = area.attribute;\n    let direction = Direction.ROW;\n    let endP: IPointLike;\n    let startP: IPointLike;\n    if (segments) {\n      const endSeg = segments[segments.length - 1];\n      const startSeg = segments[0];\n      startP = startSeg.points[0];\n      endP = endSeg.points[endSeg.points.length - 1];\n    } else {\n      startP = points[0];\n      endP = points[points.length - 1];\n    }\n    const xTotalLength = abs(endP.x - startP.x);\n    const yTotalLength = abs(endP.y - startP.y);\n    if (endP.x1 == null) {\n      direction = Direction.ROW;\n    } else if (endP.y1 == null) {\n      direction = Direction.COLUMN;\n    } else if (!Number.isFinite(xTotalLength + yTotalLength)) {\n      direction = Direction.ROW;\n    } else {\n      direction = xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN;\n    }\n    drawAreaSegments(context, cache, clipRange, {\n      offsetX,\n      offsetY,\n      offsetZ,\n      direction\n    });\n\n    this.beforeRenderStep(\n      area,\n      context,\n      offsetX,\n      offsetY,\n      !!fillOpacity,\n      false,\n      fill,\n      false,\n      defaultAttribute as any,\n      drawContext,\n      fillCb,\n      null,\n      { attribute }\n    );\n\n    // shadow\n    context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute);\n\n    const { x: originX = 0, x: originY = 0 } = attribute;\n    const _runFill = () => {\n      if (fill !== false) {\n        if (fillCb) {\n          fillCb(context, attribute, defaultAttribute);\n        } else if (fillOpacity) {\n          context.setCommonStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute);\n          context.fill();\n        }\n      }\n    };\n\n    const _runStroke = () => {\n      if (stroke !== false) {\n        if (strokeCb) {\n          strokeCb(context, attribute, defaultAttribute);\n        } else {\n          const { stroke = defaultAttribute && (defaultAttribute as any)[1] && (defaultAttribute as any)[1].stroke } =\n            attribute;\n          if (isArray(stroke) && (stroke[0] || stroke[2]) && stroke[1] === false) {\n            context.beginPath();\n            drawSegments(\n              context,\n              stroke[0] ? cache.top : cache.bottom,\n              clipRange,\n              direction === Direction.ROW ? 'x' : 'y',\n              {\n                offsetX,\n                offsetY,\n                offsetZ\n              }\n            );\n          }\n          context.setStrokeStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute);\n          context.stroke();\n        }\n      }\n    };\n\n    _runFill();\n    this.afterRenderStep(\n      area,\n      context,\n      offsetX,\n      offsetY,\n      !!fillOpacity,\n      false,\n      fill,\n      false,\n      defaultAttribute as any,\n      drawContext,\n      fillCb,\n      null,\n      { attribute }\n    );\n    _runStroke();\n\n    return ret;\n  }\n}\n"]}