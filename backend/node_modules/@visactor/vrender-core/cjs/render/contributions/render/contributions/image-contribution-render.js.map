{"version":3,"sources":["../src/render/contributions/render/contributions/image-contribution-render.ts"],"names":[],"mappings":";;;AAYA,yEAGoC;AACpC,oDAAsE;AAItE,yEAA2E;AA+H3E,MAAa,8BAA+B,SAAQ,wDAA6B;IAAjF;;QACE,SAAI,GAA+B,kCAA0B,CAAC,eAAe,CAAC;QAC9E,aAAQ,GAAY,IAAI,CAAC;QACzB,UAAK,GAAW,CAAC,CAAC;IAsCpB,CAAC;IArCC,SAAS,CACP,KAAU,EACV,OAAmB,EACnB,CAAS,EACT,CAAS,EACT,MAAe,EACf,QAAiB,EACjB,QAAiB,EACjB,QAAiB,EACjB,aAAkB,EAClB,WAAyB,EACzB,MAIY,EACZ,QAIY;QAEZ,OAAO,KAAK,CAAC,SAAS,CACpB,KAAK,EACL,OAAO,EACP,CAAC,EACD,CAAC,EACD,MAAM,EACN,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,aAAa,EACb,WAAW,EACX,MAAM,EACN,QAAQ,CACT,CAAC;IACJ,CAAC;CACF;AAzCD,wEAyCC;AAEY,QAAA,8BAA8B,GAAG,IAAI,8BAA8B,EAAE,CAAC;AACtE,QAAA,wCAAwC,GAAG,kEAAuC,CAAC","file":"image-contribution-render.js","sourcesContent":["import type {\n  IGraphicAttribute,\n  IContext2d,\n  IImage,\n  IThemeAttribute,\n  IImageRenderContribution,\n  IDrawContext,\n  IBackgroundConfig,\n  IGraphic,\n  IMarkAttribute\n} from '../../../../interface';\nimport { getTheme } from '../../../../graphic/theme';\nimport {\n  defaultBaseBackgroundRenderContribution,\n  DefaultBaseBackgroundRenderContribution\n} from './base-contribution-render';\nimport { BaseRenderContributionTime } from '../../../../common/enums';\nimport { isNumber, isObject } from '@visactor/vutils';\nimport { parsePadding } from '../../../../common/utils';\nimport { createRectPath } from '../../../../common/shape/rect';\nimport { DefaultRectRenderContribution } from './rect-contribution-render';\n\n// export class DefaultImageBackgroundRenderContribution\n//   extends DefaultBaseBackgroundRenderContribution\n//   implements IImageRenderContribution\n// {\n//   time: BaseRenderContributionTime = BaseRenderContributionTime.beforeFillStroke;\n\n//   drawShape(\n//     graphic: IImage,\n//     context: IContext2d,\n//     x: number,\n//     y: number,\n//     doFill: boolean,\n//     doStroke: boolean,\n//     fVisible: boolean,\n//     sVisible: boolean,\n//     graphicAttribute: Required<IGraphicAttribute>,\n//     drawContext: IDrawContext,\n//     fillCb?: (ctx: IContext2d, markAttribute: Partial<IGraphicAttribute>, themeAttribute: IThemeAttribute) => boolean,\n//     strokeCb?: (ctx: IContext2d, markAttribute: Partial<IGraphicAttribute>, themeAttribute: IThemeAttribute) => boolean\n//   ) {\n//     const {\n//       background,\n//       backgroundMode = graphicAttribute.backgroundMode,\n//       backgroundFit = graphicAttribute.backgroundFit,\n//       width,\n//       height\n//     } = graphic.attribute;\n//     if (!background) {\n//       return;\n//     }\n\n//     if (!graphic.backgroundImg) {\n//       if (isObject(background)) {\n//         const {\n//           stroke,\n//           fill,\n//           lineWidth = 1,\n//           cornerRadius = 0,\n//           expandX = 0,\n//           expandY = 0\n//         } = background as IBackgroundConfig;\n\n//         if (!stroke && !fill) {\n//           return;\n//         }\n\n//         context.beginPath();\n//         const { x, y, width, height } = getActualPosition(graphic);\n//         if (cornerRadius) {\n//           createRectPath(context, x - expandX, y - expandY, width + expandX * 2, height + expandY * 2, cornerRadius);\n//         } else {\n//           context.rect(x - expandX, y - expandY, width + expandX * 2, height + expandY * 2);\n//         }\n\n//         context.globalAlpha = 1;\n//         if (fill) {\n//           context.fillStyle = fill as string;\n//           context.fill();\n//         }\n\n//         if (stroke && lineWidth > 0) {\n//           context.lineWidth = lineWidth;\n//           context.strokeStyle = stroke as string;\n//           context.stroke();\n//         }\n//       } else {\n//         context.beginPath();\n//         // const b = graphic.AABBBounds;\n//         // image的背景不包括Bounds了\n//         context.rect(x, y, width || 0, height || 0);\n//         context.fillStyle = background as string;\n//         context.globalAlpha = 1;\n//         context.fill();\n//       }\n//     } else {\n//       const res = graphic.resources.get(background as any);\n//       if (res.state !== 'success' || !res.data) {\n//         return;\n//       }\n//       context.save();\n//       if (graphic.parent && !graphic.transMatrix.onlyTranslate()) {\n//         const groupAttribute = getTheme(graphic.parent).group;\n//         const { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = graphic.parent.attribute;\n//         context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);\n//         context.translate(scrollX, scrollY);\n//       }\n//       // context.clip();\n//       const b = graphic.AABBBounds;\n//       this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit);\n//       context.restore();\n//       if (!graphic.transMatrix.onlyTranslate()) {\n//         context.setTransformForCurrent();\n//       }\n//     }\n//   }\n// }\n\n// function getActualPosition(graphic: IGraphic) {\n//   const boundsPadding = parsePadding(graphic.attribute.boundsPadding);\n//   const bounds = graphic.AABBBounds;\n//   let x = bounds.x1;\n//   let y = bounds.y1;\n//   let width = bounds.width();\n//   let height = bounds.height();\n\n//   if (isNumber(boundsPadding)) {\n//     x += boundsPadding;\n//     y += boundsPadding;\n//     width -= boundsPadding * 2;\n//     height -= boundsPadding * 2;\n//   } else {\n//     x += boundsPadding[3];\n//     y += boundsPadding[0];\n//     width -= boundsPadding[1] + boundsPadding[3];\n//     height -= boundsPadding[0] + boundsPadding[2];\n//   }\n\n//   return {\n//     x,\n//     y,\n//     width,\n//     height\n//   };\n// }\n\nexport class DefaultImageRenderContribution extends DefaultRectRenderContribution implements IImageRenderContribution {\n  time: BaseRenderContributionTime = BaseRenderContributionTime.afterFillStroke;\n  useStyle: boolean = true;\n  order: number = 0;\n  drawShape(\n    image: any,\n    context: IContext2d,\n    x: number,\n    y: number,\n    doFill: boolean,\n    doStroke: boolean,\n    fVisible: boolean,\n    sVisible: boolean,\n    rectAttribute: any,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    return super.drawShape(\n      image,\n      context,\n      x,\n      y,\n      doFill,\n      doStroke,\n      fVisible,\n      sVisible,\n      rectAttribute,\n      drawContext,\n      fillCb,\n      strokeCb\n    );\n  }\n}\n\nexport const defaultImageRenderContribution = new DefaultImageRenderContribution();\nexport const defaultImageBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;\n"]}