{"version":3,"sources":["../src/render/contributions/render/contributions/symbol-contribution-render.ts"],"names":[],"mappings":"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","file":"symbol-contribution-render.js","sourcesContent":["import type {\n  IGraphicAttribute,\n  IContext2d,\n  IMarkAttribute,\n  ISymbol,\n  ISymbolGraphicAttribute,\n  IThemeAttribute,\n  ISymbolRenderContribution,\n  IDrawContext,\n  IBorderStyle,\n  IBaseRenderContribution,\n  ICustomPath2D\n} from '../../../../interface';\nimport { getScaledStroke } from '../../../../common/canvas-utils';\nimport { defaultBaseBackgroundRenderContribution } from './base-contribution-render';\nimport { BaseRenderContributionTime } from '../../../../common/enums';\nimport { defaultBaseTextureRenderContribution } from './base-texture-contribution-render';\n\nexport class DefaultSymbolRenderContribution implements ISymbolRenderContribution {\n  time: BaseRenderContributionTime = BaseRenderContributionTime.afterFillStroke;\n  useStyle: boolean = true;\n  order: number = 0;\n  drawShape(\n    symbol: ISymbol,\n    context: IContext2d,\n    x: number,\n    y: number,\n    doFill: boolean,\n    doStroke: boolean,\n    fVisible: boolean,\n    sVisible: boolean,\n    symbolAttribute: Required<ISymbolGraphicAttribute>,\n    drawContext: IDrawContext,\n    fillCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      markAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    const parsedPath = symbol.getParsedPath();\n    // todo: 考虑使用path\n    if (!parsedPath) {\n      return;\n    }\n\n    const { outerBorder, innerBorder } = symbol.attribute;\n    const doOuterBorder = outerBorder && outerBorder.visible !== false;\n    const doInnerBorder = innerBorder && innerBorder.visible !== false;\n    if (!(doOuterBorder || doInnerBorder)) {\n      return;\n    }\n\n    const {\n      size = symbolAttribute.size,\n      opacity = symbolAttribute.opacity,\n      x: originX = symbolAttribute.x,\n      y: originY = symbolAttribute.y,\n      scaleX = symbolAttribute.scaleX,\n      scaleY = symbolAttribute.scaleY,\n      keepStrokeScale = symbolAttribute.keepStrokeScale\n    } = symbol.attribute;\n\n    const renderBorder = (borderStyle: Partial<IBorderStyle>, key: 'outerBorder' | 'innerBorder') => {\n      const doStroke = !!(borderStyle && borderStyle.stroke);\n\n      const { distance = symbolAttribute[key].distance } = borderStyle;\n      const d = keepStrokeScale ? (distance as number) : getScaledStroke(context, distance as number, context.dpr);\n      const sign = key === 'outerBorder' ? 1 : -1;\n\n      context.beginPath();\n      if (parsedPath.drawOffset(context, size, x, y, sign * d) === false) {\n        context.closePath();\n      }\n\n      // shadow\n      context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute);\n\n      if (strokeCb) {\n        strokeCb(context, borderStyle, symbolAttribute[key]);\n      } else if (doStroke) {\n        // 存在stroke\n        const lastOpacity = (symbolAttribute[key] as any).opacity;\n        (symbolAttribute[key] as any).opacity = opacity;\n        context.setStrokeStyle(\n          symbol,\n          borderStyle,\n          (originX - x) / scaleX,\n          (originY - y) / scaleY,\n          symbolAttribute[key] as any\n        );\n        (symbolAttribute[key] as any).opacity = lastOpacity;\n        context.stroke();\n      }\n    };\n\n    doOuterBorder && renderBorder(outerBorder, 'outerBorder');\n    doInnerBorder && renderBorder(innerBorder, 'innerBorder');\n  }\n}\n\nexport class DefaultSymbolClipRangeStrokeRenderContribution\n  implements IBaseRenderContribution<ISymbol, ISymbolGraphicAttribute>\n{\n  time: BaseRenderContributionTime = BaseRenderContributionTime.afterFillStroke;\n  useStyle: boolean = true;\n  order: number = 0;\n\n  drawShape(\n    graphic: ISymbol,\n    context: IContext2d,\n    x: number,\n    y: number,\n    doFill: boolean,\n    doStroke: boolean,\n    fVisible: boolean,\n    sVisible: boolean,\n    graphicAttribute: Required<ISymbolGraphicAttribute>,\n    drawContext: IDrawContext,\n    fillCb?: (ctx: IContext2d, markAttribute: Partial<IGraphicAttribute>, themeAttribute: IThemeAttribute) => boolean,\n    strokeCb?: (ctx: IContext2d, markAttribute: Partial<IGraphicAttribute>, themeAttribute: IThemeAttribute) => boolean,\n    options?: any\n  ) {\n    const {\n      clipRange = graphicAttribute.clipRange,\n      x: originX = graphicAttribute.x,\n      y: originY = graphicAttribute.y,\n      z = graphicAttribute.z,\n      size = graphicAttribute.size,\n      scaleX = graphicAttribute.scaleX,\n      scaleY = graphicAttribute.scaleY\n    } = graphic.attribute;\n    const parsedPath = graphic.getParsedPath();\n    // todo: 考虑使用path\n    if (!(parsedPath && clipRange < 1 && clipRange > 0)) {\n      return;\n    }\n\n    const callback = (p: ICustomPath2D, a: any) => {\n      // 如果是svg的话，合并一下fill和stroke\n      if (graphic._parsedPath.svgCache) {\n        const obj = Object.assign({}, a);\n        obj.fill = a.fill ?? graphic.attribute.fill;\n        obj.opacity = a.opacity ?? graphic.attribute.opacity;\n        obj.fillOpacity = graphic.attribute.fillOpacity;\n        obj.stroke = a.stroke ?? graphic.attribute.stroke;\n        obj.lineWidth = a.lineWidth ?? graphic.attribute.lineWidth;\n        a = obj;\n      }\n\n      if (a.stroke) {\n        if (strokeCb) {\n          strokeCb(context, graphic.attribute, graphicAttribute);\n        } else if (sVisible) {\n          context.setStrokeStyle(graphic, a, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute);\n          context.stroke();\n        }\n      }\n    };\n\n    context.beginPath();\n    parsedPath.drawWithClipRange && parsedPath.drawWithClipRange(context, size, x, y, clipRange, z, callback);\n\n    if (doStroke && !parsedPath.isSvg) {\n      if (strokeCb) {\n        strokeCb(context, graphic.attribute, graphicAttribute);\n      } else if (sVisible) {\n        context.setStrokeStyle(\n          graphic,\n          graphic.attribute,\n          (originX - x) / scaleX,\n          (originY - y) / scaleY,\n          graphicAttribute\n        );\n        context.stroke();\n      }\n    }\n  }\n}\n\nexport const defaultSymbolRenderContribution = new DefaultSymbolRenderContribution();\nexport const defaultSymbolClipRangeStrokeRenderContribution = new DefaultSymbolClipRangeStrokeRenderContribution();\nexport const defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution;\nexport const defaultSymbolBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;\n"]}