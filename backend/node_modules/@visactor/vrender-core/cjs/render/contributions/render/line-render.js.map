{"version":3,"sources":["../src/render/contributions/render/line-render.ts"],"names":[],"mappings":"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","file":"line-render.js","sourcesContent":["import type { IPointLike } from '@visactor/vutils';\nimport { min, isArray } from '@visactor/vutils';\nimport { injectable } from '../../../common/inversify-lite';\nimport type {\n  IContext2d,\n  ILine,\n  ILineGraphicAttribute,\n  IMarkAttribute,\n  IGraphicAttribute,\n  IThemeAttribute,\n  IClipRangeByDimensionType,\n  ISegPath2D,\n  IDrawContext,\n  IRenderService,\n  IGraphicRender,\n  IGraphicRenderDrawParams\n} from '../../../interface';\nimport { getTheme } from '../../../graphic/theme';\nimport { LINE_NUMBER_TYPE } from '../../../graphic/constants';\nimport { BaseRender } from './base-render';\nimport { drawSegments } from '../../../common/render-curve';\nimport { calcLineCache } from '../../../common/segment';\n\n/**\n * 默认的基于canvas的line渲染器\n * 单例\n */\n@injectable()\nexport class DefaultCanvasLineRender extends BaseRender<ILine> implements IGraphicRender {\n  type: 'line';\n  numberType: number = LINE_NUMBER_TYPE;\n  declare z: number;\n\n  draw(line: ILine, renderService: IRenderService, drawContext: IDrawContext, params?: IGraphicRenderDrawParams) {\n    const lineAttribute = getTheme(line, params?.theme).line;\n    this._draw(line, lineAttribute, false, drawContext, params);\n  }\n\n  /**\n   * 绘制segment\n   * @param context\n   * @param cache\n   * @param fill\n   * @param stroke\n   * @param attribute\n   * @param defaultAttribute\n   * @param clipRange\n   * @param offsetX\n   * @param offsetY\n   * @param fillCb\n   * @param strokeCb\n   * @returns 返回true代表跳过后续绘制\n   */\n  protected drawSegmentItem(\n    context: IContext2d,\n    cache: ISegPath2D,\n    fill: boolean,\n    stroke: boolean,\n    fillOpacity: number,\n    strokeOpacity: number,\n    attribute: Partial<ILineGraphicAttribute>,\n    defaultAttribute: Required<ILineGraphicAttribute> | Partial<ILineGraphicAttribute>[],\n    clipRange: number,\n    clipRangeByDimension: IClipRangeByDimensionType,\n    offsetX: number,\n    offsetY: number,\n    line: ILine,\n    fillCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute | IThemeAttribute[]\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute | IThemeAttribute[]\n    ) => boolean\n  ): boolean {\n    if (!cache) {\n      return;\n    }\n    context.beginPath();\n\n    const z = this.z ?? 0;\n\n    drawSegments(context, cache, clipRange, clipRangeByDimension, {\n      offsetX,\n      offsetY,\n      offsetZ: z\n    });\n\n    // 如果是一根线，且是Closed，并且没有defined为false的点，需要close\n    if (\n      line.cache &&\n      !isArray(line.cache) &&\n      line.cache.curves.every(c => c.defined) &&\n      line.attribute.curveType &&\n      line.attribute.curveType.includes('Closed')\n    ) {\n      context.closePath();\n    }\n\n    // shadow\n    context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute);\n\n    const { x: originX = 0, x: originY = 0 } = attribute;\n    const ret: boolean = false;\n    if (fill !== false) {\n      if (fillCb) {\n        fillCb(context, attribute, defaultAttribute);\n      } else if (fillOpacity) {\n        context.setCommonStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute);\n        context.fill();\n      }\n    }\n    if (stroke !== false) {\n      if (strokeCb) {\n        strokeCb(context, attribute, defaultAttribute);\n      } else if (strokeOpacity) {\n        context.setStrokeStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute);\n        context.stroke();\n      }\n    }\n    return !!ret;\n  }\n\n  // 高性能绘制linear line，不用拆分\n  drawLinearLineHighPerformance(\n    line: ILine,\n    context: IContext2d,\n    fill: boolean,\n    stroke: boolean,\n    fillOpacity: number,\n    strokeOpacity: number,\n    offsetX: number,\n    offsetY: number,\n    lineAttribute: Required<ILineGraphicAttribute>,\n    drawContext: IDrawContext,\n    params?: IGraphicRenderDrawParams,\n    fillCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    context.beginPath();\n\n    const z = this.z ?? 0;\n    const { points } = line.attribute;\n    const startP = points[0];\n\n    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);\n    for (let i = 1; i < points.length; i++) {\n      const p = points[i];\n      context.lineTo(p.x + offsetX, p.y + offsetY, z);\n    }\n\n    // shadow\n    context.setShadowBlendStyle && context.setShadowBlendStyle(line, line.attribute, lineAttribute);\n\n    const { x: originX = 0, x: originY = 0 } = line.attribute;\n    if (fill !== false) {\n      if (fillCb) {\n        fillCb(context, line.attribute, lineAttribute);\n      } else if (fillOpacity) {\n        context.setCommonStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute);\n        context.fill();\n      }\n    }\n    if (stroke !== false) {\n      if (strokeCb) {\n        strokeCb(context, line.attribute, lineAttribute);\n      } else if (strokeOpacity) {\n        context.setStrokeStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute);\n        context.stroke();\n      }\n    }\n  }\n\n  drawShape(\n    line: ILine,\n    context: IContext2d,\n    x: number,\n    y: number,\n    drawContext: IDrawContext,\n    params?: IGraphicRenderDrawParams,\n    fillCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean,\n    strokeCb?: (\n      ctx: IContext2d,\n      lineAttribute: Partial<IMarkAttribute & IGraphicAttribute>,\n      themeAttribute: IThemeAttribute\n    ) => boolean\n  ) {\n    // const lineAttribute = graphicService.themeService.getCurrentTheme().lineAttribute;\n    const lineAttribute = getTheme(line, params?.theme).line;\n\n    const {\n      fill = lineAttribute.fill,\n      stroke = lineAttribute.stroke,\n      fillOpacity = lineAttribute.fillOpacity,\n      strokeOpacity = lineAttribute.strokeOpacity,\n      segments,\n      points,\n      closePath,\n      curveTension = lineAttribute.curveTension,\n      connectedType = lineAttribute.connectedType\n    } = line.attribute;\n\n    const data = this.valid(line, lineAttribute, fillCb, strokeCb);\n    if (!data) {\n      return;\n    }\n\n    let { curveType = lineAttribute.curveType } = line.attribute;\n    if (closePath && curveType === 'linear') {\n      curveType = 'linearClosed';\n    }\n\n    const { clipRange = lineAttribute.clipRange, clipRangeByDimension = lineAttribute.clipRangeByDimension } =\n      line.attribute;\n\n    if (clipRange === 1 && !segments && !points.some(p => p.defined === false) && curveType === 'linear') {\n      return this.drawLinearLineHighPerformance(\n        line,\n        context,\n        !!fill,\n        !!stroke,\n        fillOpacity,\n        strokeOpacity,\n        x,\n        y,\n        lineAttribute,\n        drawContext,\n        params,\n        fillCb,\n        strokeCb\n      );\n    }\n    // const { fVisible, sVisible, doFill, doStroke } = data;\n\n    function parsePoint(points: IPointLike[], connectedType: 'none' | 'connect') {\n      if (connectedType === 'none') {\n        return points;\n      }\n      return points.filter(p => p.defined !== false);\n    }\n\n    // 更新cache\n    if (line.shouldUpdateShape()) {\n      const { points, segments } = line.attribute;\n\n      const _points = points;\n      if (segments && segments.length) {\n        let startPoint: IPointLike;\n        let lastSeg: { endX: number; endY: number; curves: Array<{ defined: boolean }> };\n        line.cache = segments\n          .map((seg, index) => {\n            if (seg.points.length <= 1) {\n              // 第一个点的话，直接设置lastTopSeg\n              if (index === 0) {\n                seg.points[0] &&\n                  (lastSeg = {\n                    endX: seg.points[0].x,\n                    endY: seg.points[0].y,\n                    curves: [{ defined: seg.points[0].defined !== false }]\n                  });\n                return null;\n              }\n            }\n            // 添加上一个segment结束的点作为这个segment的起始点\n            if (index === 1) {\n              startPoint = {\n                x: lastSeg.endX,\n                y: lastSeg.endY,\n                defined: lastSeg.curves[lastSeg.curves.length - 1].defined\n              };\n            } else if (index > 1) {\n              startPoint.x = lastSeg.endX;\n              startPoint.y = lastSeg.endY;\n              startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined;\n            }\n            const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {\n              startPoint,\n              curveTension\n            });\n            lastSeg = data;\n            return data;\n          })\n          .filter(item => !!item);\n\n        // 如果lineClosed，那就绘制到第一个点\n        if (curveType === 'linearClosed') {\n          let startP: IPointLike;\n          for (let i = 0; i < line.cache.length; i++) {\n            const cacheItem = line.cache[i];\n            for (let i = 0; i < cacheItem.curves.length; i++) {\n              if (cacheItem.curves[i].defined) {\n                startP = cacheItem.curves[i].p0;\n                break;\n              }\n            }\n            if (startP) {\n              break;\n            }\n          }\n          line.cache[line.cache.length - 1] && line.cache[line.cache.length - 1].lineTo(startP.x, startP.y, true);\n        }\n      } else if (points && points.length) {\n        line.cache = calcLineCache(parsePoint(_points, connectedType), curveType, { curveTension });\n      } else {\n        line.cache = null;\n        line.clearUpdateShapeTag();\n        return;\n      }\n      line.clearUpdateShapeTag();\n    }\n\n    if (Array.isArray(line.cache)) {\n      const segments = line.attribute.segments.filter(item => item.points.length);\n      // 如果第一个seg只有一个点，那么shift出去\n      if (segments[0].points.length === 1) {\n        segments.shift();\n      }\n      if (clipRange === 1) {\n        let skip = false;\n        // 性能优化，不需要clip的线段不需要计算长度\n        line.cache.forEach((cache, index) => {\n          if (skip) {\n            return;\n          }\n          skip = this.drawSegmentItem(\n            context,\n            cache,\n            !!fill,\n            !!stroke,\n            fillOpacity,\n            strokeOpacity,\n            segments[index],\n            [lineAttribute, line.attribute],\n            clipRange,\n            clipRangeByDimension,\n            x,\n            y,\n            line,\n            fillCb,\n            strokeCb\n          );\n        });\n      } else {\n        // 如果是segments的话，每个clipRange需要重新计算\n        // 整个线段的总长度\n        const totalLength = line.cache.reduce((l, c) => l + c.getLength(), 0);\n        // 总需要绘制的长度\n        const totalDrawLength = clipRange * totalLength;\n        // 直到上次绘制的长度\n        let drawedLengthUntilLast = 0;\n        let skip = false;\n        line.cache.forEach((cache, index) => {\n          if (skip) {\n            return;\n          }\n          const curSegLength = cache.getLength();\n          const _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;\n          drawedLengthUntilLast += curSegLength;\n          if (_cr > 0) {\n            skip = this.drawSegmentItem(\n              context,\n              cache,\n              !!fill,\n              !!stroke,\n              fillOpacity,\n              strokeOpacity,\n              segments[index],\n              [lineAttribute, line.attribute],\n              min(_cr, 1),\n              clipRangeByDimension,\n              x,\n              y,\n              line,\n              fillCb,\n              strokeCb\n            );\n          }\n        });\n      }\n    } else {\n      this.drawSegmentItem(\n        context,\n        line.cache as ISegPath2D,\n        !!fill,\n        !!stroke,\n        fillOpacity,\n        strokeOpacity,\n        line.attribute,\n        lineAttribute,\n        clipRange,\n        clipRangeByDimension,\n        x,\n        y,\n        line,\n        fillCb,\n        strokeCb\n      );\n    }\n  }\n}\n"]}