import { tau, halfPi as halfPi$1, AABBBounds, degreeToRadian, PointService, Point, abs, max, min, atan2, epsilon, Matrix, pi2, Logger, pi, isArray, isPointInLine, isNumberClose, TextMeasure, EventEmitter, isBoolean, isObject, isFunction, isString, has, isUndefined, cos, sin, pointAt, isNumber as isNumber$1, sqrt, Color, DEFAULT_COLORS, LRU, OBBBounds, isNil, normalTransform, isValidUrl, isBase64, acos, lowerCamelCaseToMiddle, isValid, transformBoundsWithMatrix, getContextFont, rotatePoint, clampAngleByRadian, asin, arrayEqual, Bounds, getRectIntersect, isRectIntersect, isEqual, getIntersectPoint, merge, calculateAnchorOfBounds, styleStringToObject } from '@visactor/vutils';

class Generator {
    static GenAutoIncrementId() {
        return Generator.auto_increment_id++;
    }
}
Generator.auto_increment_id = 0;

class ContainerModule {
    constructor(registry) {
        this.id = Generator.GenAutoIncrementId();
        this.registry = registry;
    }
}

const NAMED_TAG = 'named';
const INJECT_TAG = 'inject';
const MULTI_INJECT_TAG = 'multi_inject';
const TAGGED = 'inversify:tagged';
const PARAM_TYPES = 'inversify:paramtypes';

class Metadata {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
    toString() {
        if (this.key === NAMED_TAG) {
            return `named: ${String(this.value).toString()} `;
        }
        return `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
    }
}

var Reflect$1 = (function (Reflect) {
    (function (factory) {
        const exporter = makeExporter(Reflect);
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== 'function') {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous) {
                    previous(key, value);
                }
            };
        }
    })(function (exporter) {
        const supportsSymbol = typeof Symbol === 'function';
        const toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== 'undefined' ? Symbol.toPrimitive : '@@toPrimitive';
        const functionPrototype = Object.getPrototypeOf(Function);
        typeof process === 'object' && process.env && process.env.REFLECT_METADATA_USE_MAP_POLYFILL === 'true';
        const _Map = Map;
        const _WeakMap = WeakMap;
        const Metadata = new _WeakMap();
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target)) {
                throw new TypeError();
            }
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter('defineMetadata', defineMetadata);
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target)) {
                throw new TypeError();
            }
            if (!IsUndefined(propertyKey)) {
                propertyKey = ToPropertyKey(propertyKey);
            }
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter('hasMetadata', hasMetadata);
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target)) {
                throw new TypeError();
            }
            if (!IsUndefined(propertyKey)) {
                propertyKey = ToPropertyKey(propertyKey);
            }
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter('hasOwnMetadata', hasOwnMetadata);
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target)) {
                throw new TypeError();
            }
            if (!IsUndefined(propertyKey)) {
                propertyKey = ToPropertyKey(propertyKey);
            }
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter('getMetadata', getMetadata);
        function GetOrCreateMetadataMap(O, P, Create) {
            let targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create) {
                    return undefined;
                }
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            let metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create) {
                    return undefined;
                }
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            const hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn) {
                return true;
            }
            const parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent)) {
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            }
            return false;
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            const metadataMap = GetOrCreateMetadataMap(O, P, false);
            if (IsUndefined(metadataMap)) {
                return false;
            }
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            const hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn) {
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            }
            const parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent)) {
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            }
            return undefined;
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            const metadataMap = GetOrCreateMetadataMap(O, P, false);
            if (IsUndefined(metadataMap)) {
                return undefined;
            }
            return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            const metadataMap = GetOrCreateMetadataMap(O, P, true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        function Type(x) {
            if (x === null) {
                return 1;
            }
            switch (typeof x) {
                case 'undefined':
                    return 0;
                case 'boolean':
                    return 2;
                case 'string':
                    return 3;
                case 'symbol':
                    return 4;
                case 'number':
                    return 5;
                case 'object':
                    return x === null ? 1 : 6;
                default:
                    return 6;
            }
        }
        function IsUndefined(x) {
            return x === undefined;
        }
        function IsNull(x) {
            return x === null;
        }
        function IsSymbol(x) {
            return typeof x === 'symbol';
        }
        function IsObject(x) {
            return typeof x === 'object' ? x !== null : typeof x === 'function';
        }
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0:
                    return input;
                case 1:
                    return input;
                case 2:
                    return input;
                case 3:
                    return input;
                case 4:
                    return input;
                case 5:
                    return input;
            }
            const hint = PreferredType === 3 ? 'string' : PreferredType === 5 ? 'number' : 'default';
            const exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                const result = exoticToPrim.call(input, hint);
                if (IsObject(result)) {
                    throw new TypeError();
                }
                return result;
            }
            return OrdinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
        }
        function OrdinaryToPrimitive(O, hint) {
            if (hint === 'string') {
                const toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    const result = toString_1.call(O);
                    if (!IsObject(result)) {
                        return result;
                    }
                }
                const valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    const result = valueOf.call(O);
                    if (!IsObject(result)) {
                        return result;
                    }
                }
            }
            else {
                const valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    const result = valueOf.call(O);
                    if (!IsObject(result)) {
                        return result;
                    }
                }
                const toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    const result = toString_2.call(O);
                    if (!IsObject(result)) {
                        return result;
                    }
                }
            }
            throw new TypeError();
        }
        function ToBoolean(argument) {
            return !!argument;
        }
        function ToString(argument) {
            return '' + argument;
        }
        function ToPropertyKey(argument) {
            const key = ToPrimitive(argument, 3);
            if (IsSymbol(key)) {
                return key;
            }
            return ToString(key);
        }
        function IsCallable(argument) {
            return typeof argument === 'function';
        }
        function GetMethod(V, P) {
            const func = V[P];
            if (func === undefined || func === null) {
                return undefined;
            }
            if (!IsCallable(func)) {
                throw new TypeError();
            }
            return func;
        }
        function OrdinaryGetPrototypeOf(O) {
            const proto = Object.getPrototypeOf(O);
            if (typeof O !== 'function' || O === functionPrototype) {
                return proto;
            }
            if (proto !== functionPrototype) {
                return proto;
            }
            const prototype = O.prototype;
            const prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype) {
                return proto;
            }
            const constructor = prototypeProto.constructor;
            if (typeof constructor !== 'function') {
                return proto;
            }
            if (constructor === O) {
                return proto;
            }
            return constructor;
        }
    });
    return Reflect;
})({});

function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
    const metadatas = [metadata];
    let paramsOrPropertiesMetadata = {};
    if (Reflect$1.hasOwnMetadata(metadataKey, annotationTarget)) {
        paramsOrPropertiesMetadata = Reflect$1.getMetadata(metadataKey, annotationTarget);
    }
    let paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
    if (paramOrPropertyMetadata === undefined) {
        paramOrPropertyMetadata = [];
    }
    paramOrPropertyMetadata.push(...metadatas);
    paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
    Reflect$1.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
    _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
}
function createTaggedDecorator(metadata) {
    return (target, targetKey, indexOrPropertyDescriptor) => {
        tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
    };
}
function injectBase(metadataKey) {
    return (serviceIdentifier) => {
        return (target, targetKey, indexOrPropertyDescriptor) => {
            return createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
        };
    };
}

const inject = injectBase(INJECT_TAG);

const multiInject = injectBase(MULTI_INJECT_TAG);

function injectable() {
    return function (target) {
        Reflect$1.defineMetadata(PARAM_TYPES, null, target);
        return target;
    };
}

function named(name) {
    return createTaggedDecorator(new Metadata(NAMED_TAG, name));
}

const BindingScopeEnum = {
    Singleton: 'Singleton',
    Transient: 'Transient'
};
const BindingTypeEnum = {
    ConstantValue: 'ConstantValue',
    Constructor: 'Constructor',
    DynamicValue: 'DynamicValue',
    Factory: 'Factory',
    Function: 'Function',
    Instance: 'Instance',
    Invalid: 'Invalid',
    Provider: 'Provider'
};

class Binding {
    constructor(serviceIdentifier, scope) {
        this.id = Generator.GenAutoIncrementId();
        this.activated = false;
        this.serviceIdentifier = serviceIdentifier;
        this.scope = scope;
        this.type = BindingTypeEnum.Invalid;
        this.constraint = (request) => true;
        this.implementationType = null;
        this.cache = null;
        this.factory = null;
        this.provider = null;
        this.dynamicValue = null;
    }
    clone() {
        const clone = new Binding(this.serviceIdentifier, this.scope);
        clone.activated = clone.scope === BindingScopeEnum.Singleton ? this.activated : false;
        clone.implementationType = this.implementationType;
        clone.dynamicValue = this.dynamicValue;
        clone.scope = this.scope;
        clone.type = this.type;
        clone.provider = this.provider;
        clone.constraint = this.constraint;
        clone.cache = this.cache;
        return clone;
    }
}

class MetadataReader {
    getConstructorMetadata(constructorFunc) {
        const compilerGeneratedMetadata = Reflect$1.getMetadata(PARAM_TYPES, constructorFunc);
        const userGeneratedMetadata = Reflect$1.getMetadata(TAGGED, constructorFunc);
        return {
            compilerGeneratedMetadata,
            userGeneratedMetadata: userGeneratedMetadata || {}
        };
    }
    getPropertiesMetadata(constructorFunc) {
        throw new Error('暂未实现');
    }
}

const taggedConstraint = (key) => (value) => {
    const constraint = (request) => {
        if (request == null) {
            return false;
        }
        if (request.key === key && request.value === value) {
            return true;
        }
        if (request.constructorArgsMetadata == null) {
            return false;
        }
        const constructorArgsMetadata = request.constructorArgsMetadata;
        for (let i = 0; i < constructorArgsMetadata.length; i++) {
            if (constructorArgsMetadata[i].key === key && constructorArgsMetadata[i].value === value) {
                return true;
            }
        }
        return false;
    };
    constraint.metaData = new Metadata(key, value);
    return constraint;
};
const namedConstraint = taggedConstraint(NAMED_TAG);

class BindingInSyntax {
    constructor(binding) {
        this._binding = binding;
    }
    inRequestScope() {
        throw new Error('暂未实现');
    }
    inSingletonScope() {
        this._binding.scope = BindingScopeEnum.Singleton;
        return this;
    }
    inTransientScope() {
        this._binding.scope = BindingScopeEnum.Transient;
        return this;
    }
    whenTargetNamed(name) {
        this._binding.constraint = namedConstraint(name);
        return this;
    }
}

class BindingToSyntax {
    constructor(binding) {
        this._binding = binding;
    }
    to(constructor) {
        this._binding.type = BindingTypeEnum.Instance;
        this._binding.implementationType = constructor;
        return new BindingInSyntax(this._binding);
    }
    toSelf() {
        const self = this._binding.serviceIdentifier;
        return this.to(self);
    }
    toDynamicValue(func) {
        this._binding.type = BindingTypeEnum.DynamicValue;
        this._binding.cache = null;
        this._binding.dynamicValue = func;
        this._binding.implementationType = null;
        return new BindingInSyntax(this._binding);
    }
    toConstantValue(value) {
        this._binding.type = BindingTypeEnum.ConstantValue;
        this._binding.cache = value;
        this._binding.dynamicValue = null;
        this._binding.implementationType = null;
        this._binding.scope = BindingScopeEnum.Singleton;
        return new BindingInSyntax(this._binding);
    }
    toFactory(factory) {
        this._binding.type = BindingTypeEnum.Factory;
        this._binding.factory = factory;
        this._binding.scope = BindingScopeEnum.Singleton;
        return new BindingInSyntax(this._binding);
    }
    toService(service) {
        this.toDynamicValue(context => context.container.get(service));
    }
}

class Container {
    constructor(containerOptions) {
        const options = containerOptions || {};
        options.defaultScope = options.defaultScope || BindingScopeEnum.Transient;
        this.options = options;
        this.id = Generator.GenAutoIncrementId();
        this._bindingDictionary = new Map();
        this._metadataReader = new MetadataReader();
    }
    load(module) {
        const getHelpers = this._getContainerModuleHelpersFactory();
        const containerModuleHelpers = getHelpers(module.id);
        module.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
    }
    get(serviceIdentifier) {
        const getArgs = this._getNotAllArgs(serviceIdentifier, false);
        return this._get(getArgs);
    }
    getAll(serviceIdentifier) {
        const getArgs = this._getAllArgs(serviceIdentifier);
        return this._get(getArgs);
    }
    getTagged(serviceIdentifier, key, value) {
        const getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
        return this._get(getArgs);
    }
    getNamed(serviceIdentifier, named) {
        return this.getTagged(serviceIdentifier, NAMED_TAG, named);
    }
    isBound(serviceIdentifier) {
        return this._bindingDictionary.has(serviceIdentifier);
    }
    bind(serviceIdentifier) {
        const scope = this.options.defaultScope;
        const binding = new Binding(serviceIdentifier, scope);
        const list = this._bindingDictionary.get(serviceIdentifier) || [];
        list.push(binding);
        this._bindingDictionary.set(serviceIdentifier, list);
        return new BindingToSyntax(binding);
    }
    unbind(serviceIdentifier) {
        this._bindingDictionary.delete(serviceIdentifier);
    }
    rebind(serviceIdentifier) {
        this.unbind(serviceIdentifier);
        return this.bind(serviceIdentifier);
    }
    _getContainerModuleHelpersFactory() {
        const setModuleId = (bindingToSyntax, moduleId) => {
            bindingToSyntax._binding.moduleId = moduleId;
        };
        const getBindFunction = (moduleId) => (serviceIdentifier) => {
            const bindingToSyntax = this.bind(serviceIdentifier);
            setModuleId(bindingToSyntax, moduleId);
            return bindingToSyntax;
        };
        const getUnbindFunction = () => (serviceIdentifier) => {
            return this.unbind(serviceIdentifier);
        };
        const getUnbindAsyncFunction = () => (serviceIdentifier) => {
            return null;
        };
        const getIsboundFunction = () => (serviceIdentifier) => {
            return this.isBound(serviceIdentifier);
        };
        const getRebindFunction = (moduleId) => (serviceIdentifier) => {
            const bindingToSyntax = this.rebind(serviceIdentifier);
            setModuleId(bindingToSyntax, moduleId);
            return bindingToSyntax;
        };
        return (mId) => ({
            bindFunction: getBindFunction(mId),
            isboundFunction: getIsboundFunction(),
            rebindFunction: getRebindFunction(mId),
            unbindFunction: getUnbindFunction(),
            unbindAsyncFunction: getUnbindAsyncFunction()
        });
    }
    _getNotAllArgs(serviceIdentifier, isMultiInject, key, value) {
        return {
            avoidConstraints: false,
            isMultiInject,
            serviceIdentifier,
            key,
            value
        };
    }
    _getAllArgs(serviceIdentifier) {
        return {
            avoidConstraints: true,
            isMultiInject: true,
            serviceIdentifier
        };
    }
    _get(getArgs) {
        const result = [];
        const bindings = this._bindingDictionary.get(getArgs.serviceIdentifier).filter(b => {
            return b.constraint(getArgs);
        });
        bindings.forEach(binding => {
            result.push(this._resolveFromBinding(binding));
        });
        return !getArgs.isMultiInject && result.length === 1 ? result[0] : result;
    }
    _getChildRequest(binding) {
        const constr = binding.implementationType;
        const { userGeneratedMetadata } = this._metadataReader.getConstructorMetadata(constr);
        const keys = Object.keys(userGeneratedMetadata);
        const arr = [];
        for (let i = 0; i < keys.length; i++) {
            const constructorArgsMetadata = userGeneratedMetadata[i];
            const targetMetadataMap = {};
            constructorArgsMetadata.forEach(md => {
                targetMetadataMap[md.key] = md.value;
            });
            const metadata = {
                inject: targetMetadataMap[INJECT_TAG],
                multiInject: targetMetadataMap[MULTI_INJECT_TAG]
            };
            const injectIdentifier = metadata.inject || metadata.multiInject;
            const target = {
                serviceIdentifier: injectIdentifier,
                constructorArgsMetadata
            };
            const bindings = (this._bindingDictionary.get(injectIdentifier) || []).filter(b => {
                return b.constraint(target);
            });
            if (bindings.length) {
                const request = {
                    injectIdentifier,
                    metadata: constructorArgsMetadata,
                    bindings: bindings
                };
                arr.push(request);
            }
        }
        return arr;
    }
    _resolveFromBinding(binding) {
        const result = this._getResolvedFromBinding(binding);
        this._saveToScope(binding, result);
        return result;
    }
    _getResolvedFromBinding(binding) {
        let result;
        switch (binding.type) {
            case BindingTypeEnum.ConstantValue:
            case BindingTypeEnum.Function:
                result = binding.cache;
                break;
            case BindingTypeEnum.Instance:
                result = this._resolveInstance(binding, binding.implementationType);
                break;
            default:
                result = binding.dynamicValue({ container: this });
        }
        return result;
    }
    _resolveInstance(binding, constr) {
        if (binding.activated) {
            return binding.cache;
        }
        const childRequests = this._getChildRequest(binding);
        return this._createInstance(constr, childRequests);
    }
    _createInstance(constr, childRequests) {
        if (childRequests.length) {
            const resolved = this._resolveRequests(childRequests);
            const obj = new constr(...resolved);
            return obj;
        }
        const obj = new constr();
        return obj;
    }
    _resolveRequests(childRequests) {
        return childRequests.map(request => {
            return request.bindings.length > 1
                ? request.bindings.map(binding => this._resolveFromBinding(binding))
                : this._resolveFromBinding(request.bindings[0]);
        });
    }
    _saveToScope(binding, result) {
        if (binding.scope === BindingScopeEnum.Singleton) {
            binding.cache = result;
            binding.activated = true;
        }
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
    d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const ContributionProvider = Symbol('ContributionProvider');
class ContributionProviderCache {
    constructor(serviceIdentifier, container) {
        this.serviceIdentifier = serviceIdentifier;
        this.container = container;
        ContributionStore.setStore(this.serviceIdentifier, this);
    }
    getContributions() {
        if (!this.caches) {
            this.caches = [];
            this.container &&
                this.container.isBound(this.serviceIdentifier) &&
                this.caches.push(...this.container.getAll(this.serviceIdentifier));
        }
        return this.caches;
    }
    refresh() {
        if (!this.caches) {
            return;
        }
        this.caches.length = 0;
        this.container &&
            this.container.isBound(this.serviceIdentifier) &&
            this.caches.push(...this.container.getAll(this.serviceIdentifier));
    }
}
function bindContributionProvider(bind, id) {
    bind(ContributionProvider)
        .toDynamicValue(({ container }) => new ContributionProviderCache(id, container))
        .inSingletonScope()
        .whenTargetNamed(id);
}
function bindContributionProviderNoSingletonScope(bind, id) {
    bind(ContributionProvider)
        .toDynamicValue(({ container }) => new ContributionProviderCache(id, container))
        .whenTargetNamed(id);
}
class ContributionStore {
    static getStore(id) {
        return this.store.get(id);
    }
    static setStore(id, cache) {
        this.store.set(id, cache);
    }
    static refreshAllContributions() {
        this.store.forEach(cache => {
            cache.refresh();
        });
    }
}
ContributionStore.store = new Map();

class Hook {
    constructor(args, name) {
        this._args = args;
        this.name = name;
        this.taps = [];
    }
    tap(options, fn) {
        this._tap('sync', options, fn);
    }
    unTap(options, fn) {
        const name = typeof options === 'string' ? options.trim() : options.name;
        if (name) {
            this.taps = this.taps.filter(tap => !(tap.name === name && (!fn || tap.fn === fn)));
        }
    }
    _parseOptions(type, options, fn) {
        let _options;
        if (typeof options === 'string') {
            _options = {
                name: options.trim()
            };
        }
        else if (typeof options !== 'object' || options === null) {
            throw new Error('Invalid tap options');
        }
        if (typeof _options.name !== 'string' || _options.name === '') {
            throw new Error('Missing name for tap');
        }
        _options = Object.assign({ type, fn }, _options);
        return _options;
    }
    _tap(type, options, fn) {
        this._insert(this._parseOptions(type, options, fn));
    }
    _insert(item) {
        let before;
        if (typeof item.before === 'string') {
            before = new Set([item.before]);
        }
        else if (Array.isArray(item.before)) {
            before = new Set(item.before);
        }
        let stage = 0;
        if (typeof item.stage === 'number') {
            stage = item.stage;
        }
        let i = this.taps.length;
        while (i > 0) {
            i--;
            const x = this.taps[i];
            this.taps[i + 1] = x;
            const xStage = x.stage || 0;
            if (before) {
                if (before.has(x.name)) {
                    before.delete(x.name);
                    continue;
                }
                if (before.size > 0) {
                    continue;
                }
            }
            if (xStage > stage) {
                continue;
            }
            i++;
            break;
        }
        this.taps[i] = item;
    }
}

class SyncHook extends Hook {
    call(...args) {
        const cbs = this.taps.map(t => t.fn);
        cbs.forEach(cb => cb(...args));
        return undefined;
    }
}

const EnvContribution = Symbol.for('EnvContribution');
const VGlobal = Symbol.for('VGlobal');
const DEFAULT_TEXT_FONT_FAMILY = 'PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol';

class Application {
}
const application = new Application();

let idx = 0;
class PerformanceRAF {
    constructor() {
        this.nextAnimationFrameCbs = new Map();
        this._rafHandle = null;
        this.runAnimationFrame = (time) => {
            this._rafHandle = null;
            const cbs = this.nextAnimationFrameCbs;
            this.nextAnimationFrameCbs = new Map();
            cbs.forEach(cb => cb(time));
        };
        this.tryRunAnimationFrameNextFrame = () => {
            if (this._rafHandle !== null || this.nextAnimationFrameCbs.size === 0) {
                return;
            }
            this._rafHandle = application.global.getRequestAnimationFrame()(this.runAnimationFrame);
        };
    }
    addAnimationFrameCb(callback) {
        this.nextAnimationFrameCbs.set(++idx, callback);
        this.tryRunAnimationFrameNextFrame();
        return idx;
    }
    removeAnimationFrameCb(index) {
        if (this.nextAnimationFrameCbs.has(index)) {
            this.nextAnimationFrameCbs.delete(index);
            return true;
        }
        return false;
    }
}

class EventListenerManager {
    constructor() {
        this._listenerMap = new Map();
        this._eventListenerTransformer = event => event;
    }
    setEventListenerTransformer(transformer) {
        this._eventListenerTransformer = transformer || (event => event);
    }
    addEventListener(type, listener, options) {
        if (!listener) {
            return;
        }
        const wrappedListener = (event) => {
            const transformedEvent = this._eventListenerTransformer(event);
            if (typeof listener === 'function') {
                listener(transformedEvent);
            }
            else if (listener.handleEvent) {
                listener.handleEvent(transformedEvent);
            }
        };
        if (!this._listenerMap.has(type)) {
            this._listenerMap.set(type, new Map());
        }
        this._listenerMap.get(type).set(listener, wrappedListener);
        this._nativeAddEventListener(type, wrappedListener, options);
    }
    removeEventListener(type, listener, options) {
        var _a;
        if (!listener) {
            return;
        }
        const wrappedListener = (_a = this._listenerMap.get(type)) === null || _a === void 0 ? void 0 : _a.get(listener);
        if (wrappedListener) {
            this._nativeRemoveEventListener(type, wrappedListener, options);
            this._listenerMap.get(type).delete(listener);
            if (this._listenerMap.get(type).size === 0) {
                this._listenerMap.delete(type);
            }
        }
    }
    dispatchEvent(event) {
        return this._nativeDispatchEvent(event);
    }
    clearAllEventListeners() {
        this._listenerMap.forEach((listenersMap, type) => {
            listenersMap.forEach((wrappedListener, originalListener) => {
                this._nativeRemoveEventListener(type, wrappedListener, undefined);
            });
        });
        this._listenerMap.clear();
    }
    _nativeAddEventListener(type, listener, options) {
        throw new Error('_nativeAddEventListener must be implemented by derived classes');
    }
    _nativeRemoveEventListener(type, listener, options) {
        throw new Error('_nativeRemoveEventListener must be implemented by derived classes');
    }
    _nativeDispatchEvent(event) {
        throw new Error('_nativeDispatchEvent must be implemented by derived classes');
    }
}

const defaultEnv = 'browser';
let DefaultGlobal = class DefaultGlobal extends EventListenerManager {
    get env() {
        return this._env;
    }
    get isImageAnonymous() {
        return this._isImageAnonymous;
    }
    set isImageAnonymous(isImageAnonymous) {
        this._isImageAnonymous = isImageAnonymous;
    }
    get devicePixelRatio() {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.getDevicePixelRatio();
    }
    get supportEvent() {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.supportEvent;
    }
    set supportEvent(support) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        this.envContribution.supportEvent = support;
    }
    get supportsTouchEvents() {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.supportsTouchEvents;
    }
    set supportsTouchEvents(support) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        this.envContribution.supportsTouchEvents = support;
    }
    get supportsPointerEvents() {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.supportsPointerEvents;
    }
    set supportsPointerEvents(support) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        this.envContribution.supportsPointerEvents = support;
    }
    get supportsMouseEvents() {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.supportsMouseEvents;
    }
    set supportsMouseEvents(support) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        this.envContribution.supportsMouseEvents = support;
    }
    get applyStyles() {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.applyStyles;
    }
    set applyStyles(support) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        this.envContribution.applyStyles = support;
    }
    constructor(contributions) {
        super();
        this.contributions = contributions;
        this._isImageAnonymous = true;
        this._performanceRAFList = [];
        this.eventListenerTransformer = event => event;
        this.id = Generator.GenAutoIncrementId();
        this.hooks = {
            onSetEnv: new SyncHook(['lastEnv', 'env', 'global'])
        };
        this.measureTextMethod = 'native';
        this.optimizeVisible = false;
    }
    _nativeAddEventListener(type, listener, options) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.addEventListener(type, listener, options);
    }
    _nativeRemoveEventListener(type, listener, options) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.removeEventListener(type, listener, options);
    }
    _nativeDispatchEvent(event) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.dispatchEvent(event);
    }
    bindContribution(params) {
        const promiseArr = [];
        this.contributions.getContributions().forEach(contribution => {
            const data = contribution.configure(this, params);
            if (data && data.then) {
                promiseArr.push(data);
            }
        });
        if (promiseArr.length) {
            return Promise.all(promiseArr);
        }
    }
    getDynamicCanvasCount() {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.getDynamicCanvasCount();
    }
    getStaticCanvasCount() {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.getStaticCanvasCount();
    }
    setEnv(env, params) {
        if (!(params && params.force === true) && this._env === env) {
            return;
        }
        this.deactiveCurrentEnv();
        return this.activeEnv(env, params);
    }
    deactiveCurrentEnv() {
        this.envContribution && this.envContribution.release();
    }
    activeEnv(env, params) {
        const lastEnv = this._env;
        this._env = env;
        const data = this.bindContribution(params);
        if (data && data.then) {
            return data.then(() => {
                this.envParams = params;
                this.hooks.onSetEnv.call(lastEnv, env, this);
            });
        }
        this.envParams = params;
        this.hooks.onSetEnv.call(lastEnv, env, this);
    }
    setActiveEnvContribution(contribution) {
        this.envContribution = contribution;
    }
    createCanvas(params) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.createCanvas(params);
    }
    createOffscreenCanvas(params) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.createOffscreenCanvas(params);
    }
    releaseCanvas(canvas) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.releaseCanvas(canvas);
    }
    getRequestAnimationFrame() {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.getRequestAnimationFrame();
    }
    getSpecifiedRequestAnimationFrame(id) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        if (!this._performanceRAFList[id]) {
            this._performanceRAFList[id] = new PerformanceRAF();
        }
        const performanceRAF = this._performanceRAFList[id];
        return (callback) => {
            return performanceRAF.addAnimationFrameCb(callback);
        };
    }
    getSpecifiedCancelAnimationFrame(id) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        if (!this._performanceRAFList[id]) {
            return () => false;
        }
        const performanceRAF = this._performanceRAFList[id];
        return (handle) => {
            return performanceRAF.removeAnimationFrameCb(handle);
        };
    }
    getCancelAnimationFrame() {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        return this.envContribution.getCancelAnimationFrame();
    }
    getElementById(str) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        if (!this.envContribution.getElementById) {
            return null;
        }
        return this.envContribution.getElementById(str);
    }
    getRootElement() {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        if (!this.envContribution.getRootElement) {
            return null;
        }
        return this.envContribution.getRootElement();
    }
    getDocument() {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        if (!this.envContribution.getDocument) {
            return null;
        }
        return this.envContribution.getDocument();
    }
    mapToCanvasPoint(event, domElement) {
        if (!this._env) {
            this.setEnv(defaultEnv);
        }
        if (!this.envContribution.mapToCanvasPoint) {
            return null;
        }
        return this.envContribution.mapToCanvasPoint(event, domElement);
    }
    loadImage(url) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.loadImage(url);
    }
    loadSvg(str) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.loadSvg(str);
    }
    loadJson(url) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.loadJson(url);
    }
    loadArrayBuffer(url) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.loadArrayBuffer(url);
    }
    loadBlob(url) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.loadBlob(url);
    }
    loadFont(name, source, descriptors) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._env) {
                this.setEnv('browser');
            }
            return this.envContribution.loadFont(name, source, descriptors);
        });
    }
    isChrome() {
        if (this._isChrome != null) {
            return this._isChrome;
        }
        if (!this._env) {
            this.setEnv('browser');
        }
        this._isChrome = this._env === 'browser' && navigator.userAgent.indexOf('Chrome') > -1;
        return this._isChrome;
    }
    isSafari() {
        if (this._isSafari != null) {
            return this._isSafari;
        }
        if (!this._env) {
            this.setEnv('browser');
        }
        this._isSafari =
            this._env === 'browser' && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
        return this._isSafari;
    }
    getNativeAABBBounds(dom) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.getNativeAABBBounds(dom);
    }
    removeDom(dom) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.removeDom(dom);
    }
    createDom(params) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.createDom(params);
    }
    updateDom(dom, params) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.updateDom(dom, params);
    }
    getElementTop(dom, baseWindow = false) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.getElementTop(dom, baseWindow);
    }
    getElementLeft(dom, baseWindow = false) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.getElementLeft(dom, baseWindow);
    }
    getElementTopLeft(dom, baseWindow = false) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.getElementTopLeft(dom, baseWindow);
    }
    isMacOS() {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.isMacOS();
    }
    copyToClipBoard(text) {
        if (!this._env) {
            this.setEnv('browser');
        }
        return this.envContribution.copyToClipBoard(text);
    }
};
DefaultGlobal = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(EnvContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultGlobal);

var params;
(function (params) {
    params[params["W"] = 1] = "W";
    params[params["H"] = 2] = "H";
    params[params["WH"] = 3] = "WH";
})(params || (params = {}));

var MeasureModeEnum;
(function (MeasureModeEnum) {
    MeasureModeEnum[MeasureModeEnum["estimate"] = 0] = "estimate";
    MeasureModeEnum[MeasureModeEnum["actualBounding"] = 1] = "actualBounding";
    MeasureModeEnum[MeasureModeEnum["fontBounding"] = 2] = "fontBounding";
})(MeasureModeEnum || (MeasureModeEnum = {}));

const strCommandMap = [
    'arc',
    'arcTo',
    'bezierCurveTo',
    'closePath',
    'ellipse',
    'lineTo',
    'moveTo',
    'quadraticCurveTo',
    'rect'
];

var AnimateMode;
(function (AnimateMode) {
    AnimateMode[AnimateMode["NORMAL"] = 0] = "NORMAL";
    AnimateMode[AnimateMode["SET_ATTR_IMMEDIATELY"] = 1] = "SET_ATTR_IMMEDIATELY";
})(AnimateMode || (AnimateMode = {}));

var STATUS$1;
(function (STATUS) {
    STATUS[STATUS["INITIAL"] = 0] = "INITIAL";
    STATUS[STATUS["RUNNING"] = 1] = "RUNNING";
    STATUS[STATUS["PAUSE"] = 2] = "PAUSE";
})(STATUS$1 || (STATUS$1 = {}));

var AnimateStepType;
(function (AnimateStepType) {
    AnimateStepType["wait"] = "wait";
    AnimateStepType["from"] = "from";
    AnimateStepType["to"] = "to";
    AnimateStepType["customAnimate"] = "customAnimate";
})(AnimateStepType || (AnimateStepType = {}));
var AnimateStatus;
(function (AnimateStatus) {
    AnimateStatus[AnimateStatus["INITIAL"] = 0] = "INITIAL";
    AnimateStatus[AnimateStatus["RUNNING"] = 1] = "RUNNING";
    AnimateStatus[AnimateStatus["PAUSED"] = 2] = "PAUSED";
    AnimateStatus[AnimateStatus["END"] = 3] = "END";
})(AnimateStatus || (AnimateStatus = {}));

const circleThreshold = tau - 1e-8;
class BoundsContext {
    constructor(bounds) {
        this.init(bounds);
    }
    init(bounds) {
        this.bounds = bounds;
    }
    arc(cx, cy, r, sa, ea, ccw) {
        if (Math.abs(ea - sa) > circleThreshold) {
            this.bounds.add(cx - r, cy - r);
            this.bounds.add(cx + r, cy + r);
            return;
        }
        let xmin = Infinity;
        let xmax = -Infinity;
        let ymin = Infinity;
        let ymax = -Infinity;
        let s;
        let i;
        let x;
        let y;
        function update(a) {
            x = r * Math.cos(a);
            y = r * Math.sin(a);
            if (x < xmin) {
                xmin = x;
            }
            if (x > xmax) {
                xmax = x;
            }
            if (y < ymin) {
                ymin = y;
            }
            if (y > ymax) {
                ymax = y;
            }
        }
        update(sa);
        update(ea);
        if (ea !== sa) {
            sa = sa % tau;
            if (sa < 0) {
                sa += tau;
            }
            ea = ea % tau;
            if (ea < 0) {
                ea += tau;
            }
            if (ea < sa) {
                ccw = !ccw;
                s = sa;
                sa = ea;
                ea = s;
            }
            if (ccw) {
                ea -= tau;
                s = sa - (sa % halfPi$1);
                for (i = 0; i < 4 && s > ea; ++i, s -= halfPi$1) {
                    update(s);
                }
            }
            else {
                s = sa - (sa % halfPi$1) + halfPi$1;
                for (i = 0; i < 4 && s < ea; ++i, s = s + halfPi$1) {
                    update(s);
                }
            }
        }
        this.bounds.add(cx + xmin, cy + ymin);
        this.bounds.add(cx + xmax, cy + ymax);
    }
    arcTo(x1, y1, x2, y2, radius) {
        this.bounds.add(x1, y1);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.bounds.add(cp1x, cp1y);
        this.bounds.add(cp2x, cp2y);
        this.bounds.add(x, y);
    }
    closePath() {
    }
    ellipse() {
        throw new Error('不支持ellipse');
    }
    lineTo(x, y) {
        this.bounds.add(x, y);
    }
    moveTo(x, y) {
        this.bounds.add(x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
        this.bounds.add(cpx, cpy);
        this.bounds.add(x, y);
    }
    rect(x, y, w, h) {
        this.bounds.add(x, y);
        this.bounds.add(x + w, y + h);
    }
    clear() {
        this.bounds.clear();
    }
    release(...params) {
        return;
    }
}

class CurvePath {
    constructor() {
        this._curves = [];
        this.bounds = new AABBBounds();
    }
    get curves() {
        return this._curves;
    }
    getCurveLengths() {
        return this._curves.map(curve => curve.getLength());
    }
    getPointAt(t) {
        return { x: 0, y: 0 };
    }
    getLength() {
        return 0;
    }
    getBounds() {
        return this.bounds;
    }
}

const rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi;
const commandLengths = {
    m: 2,
    l: 2,
    h: 1,
    v: 1,
    c: 6,
    s: 4,
    q: 4,
    t: 2,
    a: 7,
    M: 2,
    L: 2,
    H: 1,
    V: 1,
    C: 6,
    S: 4,
    Q: 4,
    T: 2,
    A: 7
};
const enumCommandMap = {
    A: 0,
    AT: 1,
    C: 2,
    Z: 3,
    E: 4,
    L: 5,
    M: 6,
    Q: 7,
    R: 8
};
let currPath;
let coordsStr;
let commandChar;
let coordStr;
let coordNumber;
let standardCommandLen;
function parseSvgPath(str) {
    if (!str) {
        return [];
    }
    const paths = str.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
    if (paths === null) {
        return [];
    }
    let currCommandData;
    let coordsStrArr;
    const result = [];
    for (let i = 0, len = paths.length; i < len; i++) {
        currPath = paths[i];
        coordsStr = currPath.slice(1);
        commandChar = currPath[0];
        currCommandData = [commandChar];
        coordsStrArr = coordsStr.match(rePathCommand);
        if (coordsStrArr === null) {
            result.push(currCommandData);
            continue;
        }
        for (let i = 0, len = coordsStrArr.length; i < len; i++) {
            coordStr = coordsStrArr[i];
            coordNumber = parseFloat(coordStr);
            if (!Number.isNaN(coordNumber)) {
                currCommandData.push(coordNumber);
            }
        }
        standardCommandLen = commandLengths[commandChar];
        if (currCommandData.length - 1 > standardCommandLen) {
            let subCommand;
            let bestCommandChar = commandChar;
            for (let i = 1, len = currCommandData.length; i < len; i += standardCommandLen) {
                subCommand = [bestCommandChar];
                for (let j = i, subLen = i + standardCommandLen; j < subLen; j++) {
                    subCommand.push(currCommandData[j]);
                }
                result.push(subCommand);
                if (bestCommandChar === 'm') {
                    bestCommandChar = 'l';
                }
                else if (bestCommandChar === 'M') {
                    bestCommandChar = 'L';
                }
            }
        }
        else {
            result.push(currCommandData);
        }
    }
    return result;
}

var UpdateTag;
(function (UpdateTag) {
    UpdateTag[UpdateTag["NONE"] = 0] = "NONE";
    UpdateTag[UpdateTag["UPDATE_BOUNDS"] = 1] = "UPDATE_BOUNDS";
    UpdateTag[UpdateTag["UPDATE_SHAPE"] = 2] = "UPDATE_SHAPE";
    UpdateTag[UpdateTag["CLEAR_SHAPE"] = 253] = "CLEAR_SHAPE";
    UpdateTag[UpdateTag["UPDATE_SHAPE_AND_BOUNDS"] = 3] = "UPDATE_SHAPE_AND_BOUNDS";
    UpdateTag[UpdateTag["INIT"] = 179] = "INIT";
    UpdateTag[UpdateTag["CLEAR_BOUNDS"] = 254] = "CLEAR_BOUNDS";
    UpdateTag[UpdateTag["UPDATE_GLOBAL_MATRIX"] = 32] = "UPDATE_GLOBAL_MATRIX";
    UpdateTag[UpdateTag["CLEAR_GLOBAL_MATRIX"] = 223] = "CLEAR_GLOBAL_MATRIX";
    UpdateTag[UpdateTag["UPDATE_LOCAL_MATRIX"] = 16] = "UPDATE_LOCAL_MATRIX";
    UpdateTag[UpdateTag["CLEAR_LOCAL_MATRIX"] = 239] = "CLEAR_LOCAL_MATRIX";
    UpdateTag[UpdateTag["UPDATE_GLOBAL_LOCAL_MATRIX"] = 48] = "UPDATE_GLOBAL_LOCAL_MATRIX";
    UpdateTag[UpdateTag["UPDATE_LAYOUT"] = 128] = "UPDATE_LAYOUT";
    UpdateTag[UpdateTag["CLEAR_LAYOUT"] = 127] = "CLEAR_LAYOUT";
})(UpdateTag || (UpdateTag = {}));
var IContainPointMode;
(function (IContainPointMode) {
    IContainPointMode[IContainPointMode["GLOBAL"] = 1] = "GLOBAL";
    IContainPointMode[IContainPointMode["LOCAL"] = 16] = "LOCAL";
    IContainPointMode[IContainPointMode["GLOBAL_ACCURATE"] = 3] = "GLOBAL_ACCURATE";
    IContainPointMode[IContainPointMode["LOCAL_ACCURATE"] = 48] = "LOCAL_ACCURATE";
})(IContainPointMode || (IContainPointMode = {}));
var AttributeUpdateType;
(function (AttributeUpdateType) {
    AttributeUpdateType[AttributeUpdateType["INIT"] = 0] = "INIT";
    AttributeUpdateType[AttributeUpdateType["DEFAULT"] = 1] = "DEFAULT";
    AttributeUpdateType[AttributeUpdateType["STATE"] = 2] = "STATE";
    AttributeUpdateType[AttributeUpdateType["ANIMATE_BIND"] = 10] = "ANIMATE_BIND";
    AttributeUpdateType[AttributeUpdateType["ANIMATE_PLAY"] = 11] = "ANIMATE_PLAY";
    AttributeUpdateType[AttributeUpdateType["ANIMATE_START"] = 12] = "ANIMATE_START";
    AttributeUpdateType[AttributeUpdateType["ANIMATE_UPDATE"] = 13] = "ANIMATE_UPDATE";
    AttributeUpdateType[AttributeUpdateType["ANIMATE_END"] = 14] = "ANIMATE_END";
    AttributeUpdateType[AttributeUpdateType["TRANSLATE"] = 20] = "TRANSLATE";
    AttributeUpdateType[AttributeUpdateType["TRANSLATE_TO"] = 21] = "TRANSLATE_TO";
    AttributeUpdateType[AttributeUpdateType["SCALE"] = 22] = "SCALE";
    AttributeUpdateType[AttributeUpdateType["SCALE_TO"] = 23] = "SCALE_TO";
    AttributeUpdateType[AttributeUpdateType["ROTATE"] = 24] = "ROTATE";
    AttributeUpdateType[AttributeUpdateType["ROTATE_TO"] = 25] = "ROTATE_TO";
})(AttributeUpdateType || (AttributeUpdateType = {}));
var Direction;
(function (Direction) {
    Direction[Direction["ROW"] = 1] = "ROW";
    Direction[Direction["COLUMN"] = 2] = "COLUMN";
})(Direction || (Direction = {}));
var CurveTypeEnum;
(function (CurveTypeEnum) {
    CurveTypeEnum[CurveTypeEnum["CubicBezierCurve"] = 0] = "CubicBezierCurve";
    CurveTypeEnum[CurveTypeEnum["QuadraticBezierCurve"] = 1] = "QuadraticBezierCurve";
    CurveTypeEnum[CurveTypeEnum["ArcCurve"] = 2] = "ArcCurve";
    CurveTypeEnum[CurveTypeEnum["LineCurve"] = 3] = "LineCurve";
    CurveTypeEnum[CurveTypeEnum["EllipseCurve"] = 4] = "EllipseCurve";
    CurveTypeEnum[CurveTypeEnum["MoveCurve"] = 5] = "MoveCurve";
})(CurveTypeEnum || (CurveTypeEnum = {}));
var BaseRenderContributionTime;
(function (BaseRenderContributionTime) {
    BaseRenderContributionTime[BaseRenderContributionTime["beforeFillStroke"] = 0] = "beforeFillStroke";
    BaseRenderContributionTime[BaseRenderContributionTime["afterFillStroke"] = 1] = "afterFillStroke";
})(BaseRenderContributionTime || (BaseRenderContributionTime = {}));

function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
    const th = degreeToRadian(rotateX);
    const sin_th = Math.sin(th);
    const cos_th = Math.cos(th);
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
    const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
    let pl = (px * px) / (rx * rx) + (py * py) / (ry * ry);
    if (pl > 1) {
        pl = Math.sqrt(pl);
        rx *= pl;
        ry *= pl;
    }
    const a00 = cos_th / rx;
    const a01 = sin_th / rx;
    const a10 = -sin_th / ry;
    const a11 = cos_th / ry;
    const x0 = a00 * ox + a01 * oy;
    const y0 = a10 * ox + a11 * oy;
    const x1 = a00 * x + a01 * y;
    const y1 = a10 * x + a11 * y;
    const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
    let sfactor_sq = 1 / d - 0.25;
    if (sfactor_sq < 0) {
        sfactor_sq = 0;
    }
    let sfactor = Math.sqrt(sfactor_sq);
    if (sweep === large) {
        sfactor = -sfactor;
    }
    const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
    const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
    const th0 = Math.atan2(y0 - yc, x0 - xc);
    const th1 = Math.atan2(y1 - yc, x1 - xc);
    let th_arc = th1 - th0;
    if (th_arc < 0 && sweep === 1) {
        th_arc += tau;
    }
    else if (th_arc > 0 && sweep === 0) {
        th_arc -= tau;
    }
    const segs = Math.ceil(Math.abs(th_arc / (halfPi$1 + 0.001)));
    const result = [];
    for (let i = 0; i < segs; ++i) {
        const th2 = th0 + (i * th_arc) / segs;
        const th3 = th0 + ((i + 1) * th_arc) / segs;
        result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
    }
    return result;
}
function bezier(params) {
    const cx = params[0];
    const cy = params[1];
    const th0 = params[2];
    const th1 = params[3];
    const rx = params[4];
    const ry = params[5];
    const sin_th = params[6];
    const cos_th = params[7];
    const a00 = cos_th * rx;
    const a01 = -sin_th * ry;
    const a10 = sin_th * rx;
    const a11 = cos_th * ry;
    const cos_th0 = Math.cos(th0);
    const sin_th0 = Math.sin(th0);
    const cos_th1 = Math.cos(th1);
    const sin_th1 = Math.sin(th1);
    const th_half = 0.5 * (th1 - th0);
    const sin_th_h2 = Math.sin(th_half * 0.5);
    const t = ((8 / 3) * sin_th_h2 * sin_th_h2) / Math.sin(th_half);
    const x1 = cx + cos_th0 - t * sin_th0;
    const y1 = cy + sin_th0 + t * cos_th0;
    const x3 = cx + cos_th1;
    const y3 = cy + sin_th1;
    const x2 = x3 + t * sin_th1;
    const y2 = y3 - t * cos_th1;
    return [
        a00 * x1 + a01 * y1,
        a10 * x1 + a11 * y1,
        a00 * x2 + a01 * y2,
        a10 * x2 + a11 * y2,
        a00 * x3 + a01 * y3,
        a10 * x3 + a11 * y3
    ];
}
function drawArc(context, x, y, coords) {
    const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x, y);
    for (let i = 0; i < seg.length; ++i) {
        const bez = bezier(seg[i]);
        context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
    }
}
const addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry, counterclockwise = false) => {
    const PI2 = Math.PI * 2;
    const sAngle = ((startAngle % PI2) + PI2) % PI2;
    let eAngle = ((endAngle % PI2) + PI2) % PI2;
    let deltaAngle;
    if (counterclockwise) {
        if (eAngle >= sAngle) {
            eAngle -= PI2;
        }
        deltaAngle = eAngle - sAngle;
    }
    else {
        if (eAngle <= sAngle) {
            eAngle += PI2;
        }
        deltaAngle = eAngle - sAngle;
    }
    const count = Math.ceil(Math.abs(deltaAngle) / (Math.PI * 0.5));
    const stepAngle = deltaAngle / count;
    for (let i = 0; i < count; i++) {
        const sa = sAngle + stepAngle * i;
        const ea = sAngle + stepAngle * (i + 1);
        const len = (4 / 3) * Math.tan(Math.abs(stepAngle) / 4);
        const c1 = Math.cos(sa);
        const s1 = Math.sin(sa);
        const c2 = Math.cos(ea);
        const s2 = Math.sin(ea);
        const x1 = c1 * rx + cx;
        const y1 = s1 * ry + cy;
        const x4 = c2 * rx + cx;
        const y4 = s2 * ry + cy;
        const sign = counterclockwise ? -1 : 1;
        const hx = rx * len * sign;
        const hy = ry * len * sign;
        bezierPath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
    }
};

const commandFuncs = [
    (command, context, x, y, sx, sy, z) => context.arc(command[1] * sx + x, command[2] * sy + y, (command[3] * (sx + sy)) / 2, command[4], command[5], command[6], z),
    (command, context, x, y, sx, sy, z) => context.arcTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, (command[5] * (sx + sy)) / 2, z),
    (command, context, x, y, sx, sy, z) => context.bezierCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * sx + x, command[6] * sy + y, z),
    (command, context, x, y) => context.closePath(),
    (command, context, x, y, sx, sy) => context.ellipse(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]),
    (command, context, x, y, sx, sy, z) => context.lineTo(command[1] * sx + x, command[2] * sy + y, z),
    (command, context, x, y, sx, sy, z) => context.moveTo(command[1] * sx + x, command[2] * sy + y, z),
    (command, context, x, y, sx, sy, z) => context.quadraticCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, z),
    (command, context, x, y, sx, sy, z) => context.rect(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, z)
];
function renderCommandList(commandList, context, x = 0, y = 0, sx = 1, sy = 1, z) {
    for (let i = 0; i < commandList.length; i++) {
        const command = commandList[i];
        commandFuncs[command[0]](command, context, x, y, sx, sy, z);
    }
}

class Curve {
    getLength(direction) {
        if (direction != null) {
            return this.calcProjLength(direction);
        }
        if (Number.isFinite(this.length)) {
            return this.length;
        }
        this.length = this.calcLength();
        return this.length;
    }
}

function snapLength(xArr, yArr) {
    let totalLength = 0;
    const count = xArr.length;
    for (let i = 0; i < count; i++) {
        const x = xArr[i];
        const y = yArr[i];
        const nextX = xArr[(i + 1) % count];
        const nextY = yArr[(i + 1) % count];
        totalLength += PointService.distanceNN(x, y, nextX, nextY);
    }
    return totalLength / 2;
}
function cubicLength(p0, p1, p2, p3, iterationCount) {
    return snapLength([p0.x, p1.x, p2.x, p3.x], [p0.y, p1.y, p2.y, p3.y]);
}
function cubicCalc(p0, p1, p2, p3, t) {
    const one = 1 - t;
    return one * one * one * p0 + 3 * p1 * t * one * one + 3 * p2 * t * t * one + p3 * t * t * t;
}
function cubicPointAt(p0, p1, p2, p3, t) {
    const x = cubicCalc(p0.x, p1.x, p2.x, p3.x, t);
    const y = cubicCalc(p0.y, p1.y, p2.y, p3.y, t);
    return new Point(x, y);
}
function quadCalc(p0, p1, p2, t) {
    const one = 1 - t;
    return one * one * p0 + 2 * one * t * p1 + t * t * p2;
}
function quadPointAt(p0, p1, p2, t) {
    const x = quadCalc(p0.x, p1.x, p2.x, t);
    const y = quadCalc(p0.y, p1.y, p2.y, t);
    return new Point(x, y);
}
function quadLength(p0, p1, p2, iterationCount) {
    return snapLength([p0.x, p1.x, p2.x], [p0.y, p1.y, p2.y]);
}

function divideCubic(curve, t) {
    const { p0, p1, p2, p3 } = curve;
    const pt = cubicPointAt(p0, p1, p2, p3, t);
    const c1 = PointService.pointAtPP(p0, p1, t);
    const c2 = PointService.pointAtPP(p1, p2, t);
    const c3 = PointService.pointAtPP(p2, p3, t);
    const c12 = PointService.pointAtPP(c1, c2, t);
    const c23 = PointService.pointAtPP(c2, c3, t);
    const curve1 = new CubicBezierCurve(p0, c1, c12, pt);
    const curve2 = new CubicBezierCurve(pt, c23, c3, p3);
    return [curve1, curve2];
}
class CubicBezierCurve extends Curve {
    constructor(p0, p1, p2, p3) {
        super();
        this.type = CurveTypeEnum.CubicBezierCurve;
        this.p0 = p0;
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
    }
    _validPoint() {
        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
    }
    getPointAt(t) {
        if (this.defined !== false) {
            return cubicPointAt(this.p0, this.p1, this.p2, this.p3, t);
        }
        throw new Error('defined为false的点不能getPointAt');
    }
    calcLength() {
        if (this._validPoint()) {
            return cubicLength(this.p0, this.p1, this.p2, this.p3);
        }
        return 60;
    }
    calcProjLength(direction) {
        if (direction === Direction.ROW) {
            return abs(this.p0.x - this.p3.x);
        }
        else if (direction === Direction.COLUMN) {
            return abs(this.p0.y - this.p3.y);
        }
        return 0;
    }
    getAngleAt(t) {
        const minT = max(t - 0.01, 0);
        const maxT = min(t + 0.01, 1);
        const minP = this.getPointAt(minT);
        const maxP = this.getPointAt(maxT);
        return atan2(maxP.y - minP.y, maxP.x - minP.x);
    }
    draw(path, x, y, sx, sy, percent) {
        path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y);
        if (percent >= 1) {
            path.bezierCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y, this.p3.x * sx + x, this.p3.y * sy + y);
        }
        else if (percent > 0) {
            const [curve1] = divideCubic(this, percent);
            path.bezierCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y, curve1.p3.x * sx + x, curve1.p3.y * sy + y);
        }
    }
    includeX(x) {
        const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x);
        const maxX = max(this.p0.x, this.p1.x, this.p2.x, this.p3.x);
        return x >= minX && x <= maxX;
    }
    getYAt(x) {
        const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x);
        const maxX = max(this.p0.x, this.p1.x, this.p2.x, this.p3.x);
        const t = (x - minX) / (maxX - minX);
        return this.getPointAt(t).y;
    }
}

function divideLinear(curve, t) {
    const { p0, p1 } = curve;
    const c1 = PointService.pointAtPP(p0, p1, t);
    const curve1 = new LineCurve(p0, c1);
    const curve2 = new LineCurve(c1, p1);
    return [curve1, curve2];
}
class LineCurve extends Curve {
    constructor(p0, p1) {
        super();
        this.type = CurveTypeEnum.LineCurve;
        this.p0 = p0;
        this.p1 = p1;
    }
    getPointAt(t) {
        if (this.defined !== false) {
            return PointService.pointAtPP(this.p0, this.p1, t);
        }
        throw new Error('defined为false的点不能getPointAt');
    }
    getAngleAt(t) {
        if (this.angle == null) {
            this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
        }
        return this.angle;
    }
    _validPoint() {
        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
    }
    calcLength() {
        if (this._validPoint()) {
            return PointService.distancePP(this.p0, this.p1);
        }
        return 60;
    }
    calcProjLength(direction) {
        if (direction === Direction.ROW) {
            return abs(this.p0.x - this.p1.x);
        }
        else if (direction === Direction.COLUMN) {
            return abs(this.p0.y - this.p1.y);
        }
        return 0;
    }
    draw(path, x, y, sx, sy, percent) {
        path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y);
        if (percent >= 1) {
            path.lineTo(this.p1.x * sx + x, this.p1.y * sy + y);
        }
        else if (percent > 0) {
            const p = this.getPointAt(percent);
            path.lineTo(p.x * sx + x, p.y * sy + y);
        }
    }
    includeX(x) {
        return (x >= this.p0.x && x <= this.p1.x) || (x >= this.p1.x && x <= this.p0.x);
    }
    getYAt(x) {
        if (this.includeX(x)) {
            let minP = this.p0;
            let maxP = this.p1;
            if (this.p0.x > this.p1.x) {
                minP = this.p1;
                maxP = this.p0;
            }
            const percent = (x - minP.x) / (maxP.x - minP.x);
            return minP.y + percent * (maxP.y - minP.y);
        }
        return Infinity;
    }
}

class SegContext {
    get endX() {
        return this._lastX;
    }
    get endY() {
        return this._lastY;
    }
    constructor(curveType, direction) {
        this.init(curveType, direction);
    }
    init(curveType, direction) {
        this._lastX = this._lastY = this._startX = this._startY = 0;
        this.curveType = curveType;
        this.direction = direction;
        this.curves = [];
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
        const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
        curve.originP1 = this._lastOriginP;
        curve.originP2 = p;
        curve.defined = defined;
        this.curves.push(curve);
        this._lastX = x;
        this._lastY = y;
        this._lastOriginP = p;
    }
    closePath() {
        if (this.curves.length < 2) {
            return;
        }
        const lastCurve = this.curves[this.curves.length - 1];
        this.lineTo(this._startX, this._startY, lastCurve.defined, this._startOriginP);
    }
    ellipse() {
        throw new Error('SegContext不支持调用ellipse');
    }
    lineTo(x, y, defined, p) {
        const curve = this.addLinearCurve(x, y, defined, this._lastOriginP, p);
        this.curves.push(curve);
        this._lastX = x;
        this._lastY = y;
        this._lastOriginP = p;
    }
    moveTo(x, y, p) {
        this._lastX = this._startX = x;
        this._lastY = this._startY = y;
        this._lastOriginP = p;
        this._startOriginP = p;
        return this;
    }
    quadraticCurveTo(cpx, cpy, x, y) {
        throw new Error('SegContext不支持调用quadraticCurveTo');
    }
    clear() {
        this.curves = [];
        this.length = NaN;
    }
    tryUpdateLength(direction) {
        return this.getLength(direction);
    }
    addLinearCurve(x, y, defined, p1, p2) {
        const curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
        curve.originP1 = p1;
        curve.originP2 = p2;
        curve.defined = defined;
        return curve;
    }
    getPointAt(t) {
        throw new Error('暂未实现');
    }
    getCurveLengths() {
        return [];
    }
    getLength(direction) {
        var _a, _b;
        if (direction === Direction.COLUMN) {
            if (!this.curves.length) {
                return 0;
            }
            const sc = this.curves[0];
            const ec = this.curves[this.curves.length - 1];
            const endP = (_a = ec.p3) !== null && _a !== void 0 ? _a : ec.p1;
            return abs(sc.p0.y - endP.y);
        }
        else if (direction === Direction.ROW) {
            if (!this.curves.length) {
                return 0;
            }
            const sc = this.curves[0];
            const ec = this.curves[this.curves.length - 1];
            const endP = (_b = ec.p3) !== null && _b !== void 0 ? _b : ec.p1;
            return abs(sc.p0.x - endP.x);
        }
        if (Number.isFinite(this.length)) {
            return this.length;
        }
        this.length = this.curves.reduce((l, c) => l + c.getLength(), 0);
        return this.length;
    }
}
class ReflectSegContext extends SegContext {
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
        return super.bezierCurveTo(cp1y, cp1x, cp2y, cp2x, y, x, defined, p);
    }
    lineTo(x, y, defined, p) {
        return super.lineTo(y, x, defined, p);
    }
    moveTo(x, y, p) {
        return super.moveTo(y, x, p);
    }
    clear() {
        return super.clear();
    }
}

function genCurveSegments(path, points, step = 1) {
    let defined0 = false;
    for (let i = 0, n = points.length; i <= n; i++) {
        if (i >= n === defined0) {
            if ((defined0 = !defined0)) {
                path.lineStart();
            }
            else {
                path.lineEnd();
            }
        }
        if (defined0) {
            path.point(points[i]);
        }
    }
}
function genSegContext(curveType, direction, points) {
    const curveDirection = direction !== null && direction !== void 0 ? direction : (abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y)
        ? Direction.ROW
        : Direction.COLUMN);
    if (curveType === 'monotoneY') {
        return new ReflectSegContext(curveType, curveDirection);
    }
    return new SegContext(curveType, curveDirection);
}

class Linear {
    constructor(context, startPoint) {
        this.context = context;
        startPoint && (this.startPoint = startPoint);
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._point = 0;
        this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
        if (this._line || (this._line !== 0 && this._point === 1)) {
            this.context.closePath();
        }
        this._line = 1 - this._line;
    }
    point(p) {
        const x = p.x;
        const y = p.y;
        switch (this._point) {
            case 0:
                this._point = 1;
                this._line
                    ? this.context.lineTo(x, y, this._lastDefined !== false && p.defined !== false, p)
                    : this.context.moveTo(x, y, p);
                break;
            case 1:
                this._point = 2;
            default:
                this.context.lineTo(x, y, this._lastDefined !== false && p.defined !== false, p);
                break;
        }
        this._lastDefined = p.defined;
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}
function genLinearSegments(points, params = {}) {
    const { direction, startPoint } = params;
    if (points.length < 2 - Number(!!startPoint)) {
        return null;
    }
    const segContext = genSegContext('linear', direction, points);
    const linear = new Linear(segContext, startPoint);
    genLinearTypeSegments(linear, points);
    return segContext;
}
function genLinearTypeSegments(path, points) {
    return genCurveSegments(path, points, 1);
}

function point$3(curveClass, x, y, defined, p) {
    curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x) / 6, (curveClass._y0 + 4 * curveClass._y1 + y) / 6, defined, curveClass.lastPoint1);
}
class Basis {
    constructor(context, startPoint) {
        this.context = context;
        this.startPoint = startPoint;
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
        this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
        switch (this._point) {
            case 2:
                point$3(this, this._x1 * 6 - (this._x0 + 4 * this._x1), this._y1 * 6 - (this._y0 + 4 * this._y1), this._lastDefined1 !== false && this._lastDefined2 !== false, this.lastPoint1);
        }
        if (this._line || (this._line !== 0 && this._point === 1)) {
            this.context.closePath();
        }
        this._line = 1 - this._line;
    }
    point(p) {
        const x = p.x;
        const y = p.y;
        switch (this._point) {
            case 0:
                this._point = 1;
                this._line
                    ? this.context.lineTo(x, y, this._lastDefined1 !== false && this._lastDefined2 !== false, p)
                    : this.context.moveTo(x, y, p);
                break;
            case 1:
                this._point = 2;
                break;
            default:
                point$3(this, x, y, this._lastDefined1 !== false && this._lastDefined2 !== false);
                break;
        }
        (this._x0 = this._x1), (this._x1 = x);
        (this._y0 = this._y1), (this._y1 = y);
        this._lastDefined1 = this._lastDefined2;
        this._lastDefined2 = p.defined;
        this.lastPoint0 = this.lastPoint1;
        this.lastPoint1 = p;
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}
function genBasisTypeSegments(path, points) {
    return genCurveSegments(path, points, 2);
}
function genBasisSegments(points, params = {}) {
    const { direction, startPoint } = params;
    if (points.length < 2 - Number(!!startPoint)) {
        return null;
    }
    if (points.length < 3 - Number(!!startPoint)) {
        return genLinearSegments(points, params);
    }
    const segContext = genSegContext('basis', direction, points);
    const basis = new Basis(segContext, startPoint);
    genBasisTypeSegments(basis, points);
    return segContext;
}

function sign(x) {
    return x < 0 ? -1 : 1;
}
function slope3(curveClass, x2, y2) {
    const h0 = curveClass._x1 - curveClass._x0;
    const h1 = x2 - curveClass._x1;
    const s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0));
    const s1 = (y2 - curveClass._y1) / (h1 || Number(h0 < 0 && -0));
    const p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(curveClass, t) {
    const h = curveClass._x1 - curveClass._x0;
    return h ? ((3 * (curveClass._y1 - curveClass._y0)) / h - t) / 2 : t;
}
function point$2(curveClass, t0, t1, defined, p) {
    const x0 = curveClass._x0;
    const y0 = curveClass._y0;
    const x1 = curveClass._x1;
    const y1 = curveClass._y1;
    const dx = (x1 - x0) / 3;
    curveClass.context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1, defined, curveClass.lastPoint1);
}
class MonotoneX {
    constructor(context, startPoint) {
        this.context = context;
        this.startPoint = startPoint;
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
        this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
        switch (this._point) {
            case 2:
                this.context.lineTo(this._x1, this._y1, this._lastDefined1 !== false && this._lastDefined2 !== false, this.lastPoint1);
                break;
            case 3:
                point$2(this, this._t0, slope2(this, this._t0), this._lastDefined1 !== false && this._lastDefined2 !== false, this.lastPoint1);
                break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) {
            this.context.closePath();
        }
        this._line = 1 - this._line;
    }
    point(p) {
        let t1 = NaN;
        const x = p.x;
        const y = p.y;
        switch (this._point) {
            case 0:
                this._point = 1;
                this._line
                    ? this.context.lineTo(x, y, this._lastDefined1 !== false && this._lastDefined2 !== false, p)
                    : this.context.moveTo(x, y, p);
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
                point$2(this, slope2(this, (t1 = slope3(this, x, y))), t1, this._lastDefined1 !== false && this._lastDefined2 !== false);
                break;
            default:
                point$2(this, this._t0, (t1 = slope3(this, x, y)), this._lastDefined1 !== false && this._lastDefined2 !== false);
                break;
        }
        (this._x0 = this._x1), (this._x1 = x);
        (this._y0 = this._y1), (this._y1 = y);
        this._t0 = t1;
        this._lastDefined1 = this._lastDefined2;
        this._lastDefined2 = p.defined !== false;
        this.lastPoint0 = this.lastPoint1;
        this.lastPoint1 = p;
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}
class MonotoneY extends MonotoneX {
    constructor(context, startPoint) {
        super(context, startPoint);
    }
    point(p) {
        return super.point({ y: p.x, x: p.y, defined: p.defined });
    }
}
function genMonotoneXTypeSegments(path, points) {
    return genCurveSegments(path, points, 2);
}
function genMonotoneXSegments(points, params = {}) {
    const { direction, startPoint } = params;
    if (points.length < 2 - Number(!!startPoint)) {
        return null;
    }
    if (points.length < 3 - Number(!!startPoint)) {
        return genLinearSegments(points, params);
    }
    const segContext = genSegContext('monotoneX', direction, points);
    const monotoneX = new MonotoneX(segContext, startPoint);
    genMonotoneXTypeSegments(monotoneX, points);
    return segContext;
}
function genMonotoneYTypeSegments(path, points) {
    return genCurveSegments(path, points, 2);
}
function genMonotoneYSegments(points, params = {}) {
    const { direction, startPoint } = params;
    if (points.length < 2 - Number(!!startPoint)) {
        return null;
    }
    if (points.length < 3 - Number(!!startPoint)) {
        return genLinearSegments(points, params);
    }
    const segContext = genSegContext('monotoneY', direction, points);
    const monotoneY = new MonotoneY(segContext, startPoint);
    genMonotoneYTypeSegments(monotoneY, points);
    return segContext;
}

class Step {
    constructor(context, t = 0.5, startPoint) {
        this.context = context;
        this._t = t;
        this.startPoint = startPoint;
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._x = this._y = NaN;
        this._point = 0;
        this.startPoint && this.point(this.startPoint);
    }
    lineEnd() {
        if (0 < this._t && this._t < 1 && this._point === 2) {
            this.context.lineTo(this._x, this._y, this._lastDefined !== false, this.lastPoint);
        }
        if (this._line || (this._line !== 0 && this._point === 1)) {
            this.context.closePath();
        }
        if (this._line >= 0) {
            (this._t = 1 - this._t), (this._line = 1 - this._line);
        }
    }
    point(p) {
        const x = p.x;
        const y = p.y;
        switch (this._point) {
            case 0:
                this._point = 1;
                this._line
                    ? this.context.lineTo(x, y, this._lastDefined !== false && p.defined !== false, p)
                    : this.context.moveTo(x, y, p);
                break;
            case 1:
                this._point = 2;
            default: {
                if (this._t <= 0) {
                    this.context.lineTo(this._x, y, this._lastDefined !== false && p.defined !== false, this.lastPoint);
                    this.context.lineTo(x, y, this._lastDefined !== false && p.defined !== false, p);
                }
                else {
                    const x1 = this._x * (1 - this._t) + x * this._t;
                    if (this._t === 0.5) {
                        this.context.lineTo(x1, this._y, this._lastDefined !== false, this.lastPoint);
                    }
                    else {
                        this.context.lineTo(x1, this._y, this._lastDefined !== false && p.defined !== false, this.lastPoint);
                    }
                    this.context.lineTo(x1, y, this._lastDefined !== false && p.defined !== false, p);
                }
                break;
            }
        }
        this._lastDefined = p.defined;
        (this._x = x), (this._y = y);
        this.lastPoint = p;
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}
class StepClosed extends Step {
    lineEnd() {
        this.context.closePath();
    }
}
function genStepSegments(points, t, params = {}) {
    const { direction, startPoint } = params;
    if (points.length < 2 - Number(!!startPoint)) {
        return null;
    }
    const segContext = new SegContext('step', direction !== null && direction !== void 0 ? direction : (abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y)
        ? Direction.ROW
        : Direction.COLUMN));
    const step = new Step(segContext, t, startPoint);
    genStepTypeSegments(step, points);
    return segContext;
}
function genStepTypeSegments(path, points) {
    return genCurveSegments(path, points, 1);
}
function genStepClosedSegments(points, t, params = {}) {
    const { direction, startPoint } = params;
    if (points.length < 2 - Number(!!startPoint)) {
        return null;
    }
    const segContext = new SegContext('step', direction !== null && direction !== void 0 ? direction : (abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y)
        ? Direction.ROW
        : Direction.COLUMN));
    const step = new StepClosed(segContext, t, startPoint);
    genStepTypeSegments(step, points);
    return segContext;
}

class LinearClosed extends Linear {
    lineEnd() {
        this.context.closePath();
    }
}
function genLinearClosedSegments(points, params = {}) {
    const { direction, startPoint } = params;
    if (points.length < 2 - Number(!!startPoint)) {
        return null;
    }
    const segContext = genSegContext('linear', direction, points);
    const linear = new LinearClosed(segContext, startPoint);
    genLinearClosedTypeSegments(linear, points);
    return segContext;
}
function genLinearClosedTypeSegments(path, points) {
    return genCurveSegments(path, points, 1);
}

function point$1(curveClass, x, y, defined, p) {
    let x1 = curveClass._x1;
    let y1 = curveClass._y1;
    let x2 = curveClass._x2;
    let y2 = curveClass._y2;
    if (curveClass._l01_a > epsilon) {
        const a = 2 * curveClass._l01_2a + 3 * curveClass._l01_a * curveClass._l12_a + curveClass._l12_2a;
        const n = 3 * curveClass._l01_a * (curveClass._l01_a + curveClass._l12_a);
        x1 = (x1 * a - curveClass._x0 * curveClass._l12_2a + curveClass._x2 * curveClass._l01_2a) / n;
        y1 = (y1 * a - curveClass._y0 * curveClass._l12_2a + curveClass._y2 * curveClass._l01_2a) / n;
    }
    if (curveClass._l23_a > epsilon) {
        const b = 2 * curveClass._l23_2a + 3 * curveClass._l23_a * curveClass._l12_a + curveClass._l12_2a;
        const m = 3 * curveClass._l23_a * (curveClass._l23_a + curveClass._l12_a);
        x2 = (x2 * b + curveClass._x1 * curveClass._l23_2a - x * curveClass._l12_2a) / m;
        y2 = (y2 * b + curveClass._y1 * curveClass._l23_2a - y * curveClass._l12_2a) / m;
    }
    curveClass.context.bezierCurveTo(x1, y1, x2, y2, curveClass._x2, curveClass._y2, defined, curveClass.lastPoint1);
}
class CatmullRom {
    constructor(context, alpha = 0.5, startPoint) {
        this.context = context;
        this.startPoint = startPoint;
        this._alpha = alpha;
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    }
    lineEnd() {
        switch (this._point) {
            case 2:
                this.context.lineTo(this._x2, this._y2, this._lastDefined1 !== false && this._lastDefined2 !== false, this.lastPoint1);
                break;
            case 3:
                this.point({ x: this._x2, y: this._y2 });
                break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) {
            this.context.closePath();
        }
        this._line = 1 - this._line;
    }
    point(p) {
        const { x, y } = p;
        if (this._point) {
            const x23 = this._x2 - x;
            const y23 = this._y2 - y;
            this._l23_a = Math.sqrt((this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha)));
        }
        switch (this._point) {
            case 0:
                this._point = 1;
                this._line
                    ? this.context.lineTo(x, y, this._lastDefined1 !== false && this._lastDefined2 !== false)
                    : this.context.moveTo(x, y);
                break;
            case 1:
                this._point = 2;
                break;
            case 2:
                this._point = 3;
            default:
                point$1(this, x, y, this._lastDefined1 !== false && this._lastDefined2 !== false);
                break;
        }
        (this._l01_a = this._l12_a), (this._l12_a = this._l23_a);
        (this._l01_2a = this._l12_2a), (this._l12_2a = this._l23_2a);
        (this._x0 = this._x1), (this._x1 = this._x2), (this._x2 = x);
        (this._y0 = this._y1), (this._y1 = this._y2), (this._y2 = y);
        this._lastDefined1 = this._lastDefined2;
        this._lastDefined2 = p.defined;
        this.lastPoint0 = this.lastPoint1;
        this.lastPoint1 = p;
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}
function commonGenCatmullRomSegments(type, cons) {
    return function genCatmullRomSegments(points, alpha, params = {}) {
        const { direction, startPoint } = params;
        if (points.length < 2 - Number(!!startPoint)) {
            return null;
        }
        if (points.length < 3 - Number(!!startPoint)) {
            return genLinearSegments(points, params);
        }
        const segContext = genSegContext(type, direction, points);
        const gatmullRom = new cons(segContext, alpha, startPoint);
        genCurveSegments(gatmullRom, points, 2);
        return segContext;
    };
}
const genCatmullRomSegments = commonGenCatmullRomSegments('catmullRom', CatmullRom);

class CatmullRomClosed {
    constructor(context, alpha = 0.5, startPoint) {
        this.context = context;
        this.startPoint = startPoint;
        this._alpha = alpha;
    }
    areaStart() {
        this._line = 0;
    }
    areaEnd() {
        this._line = NaN;
    }
    lineStart() {
        this._x0 =
            this._x1 =
                this._x2 =
                    this._x3 =
                        this._x4 =
                            this._x5 =
                                this._y0 =
                                    this._y1 =
                                        this._y2 =
                                            this._y3 =
                                                this._y4 =
                                                    this._y5 =
                                                        NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    }
    lineEnd() {
        switch (this._point) {
            case 1: {
                this.context.moveTo(this._x3, this._y3, this.lastPoint1);
                this.context.closePath();
                break;
            }
            case 2: {
                this.context.lineTo(this._x3, this._y3, this._lastDefined1 !== false && this._lastDefined2 !== false, this.lastPoint1);
                this.context.closePath();
                break;
            }
            case 3: {
                this.point({ x: this._x3, y: this._y3 });
                this.point({ x: this._x4, y: this._y4 });
                this.point({ x: this._x5, y: this._y5 });
                break;
            }
        }
    }
    point(p) {
        const { x, y } = p;
        if (this._point) {
            const x23 = this._x2 - x;
            const y23 = this._y2 - y;
            this._l23_a = Math.sqrt((this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha)));
        }
        switch (this._point) {
            case 0:
                this._point = 1;
                (this._x3 = x), (this._y3 = y);
                break;
            case 1:
                this._point = 2;
                this.context.moveTo((this._x4 = x), (this._y4 = y), p);
                break;
            case 2:
                this._point = 3;
                (this._x5 = x), (this._y5 = y);
                break;
            default:
                point$1(this, x, y, this._lastDefined1 !== false && this._lastDefined2 !== false);
                break;
        }
        (this._l01_a = this._l12_a), (this._l12_a = this._l23_a);
        (this._l01_2a = this._l12_2a), (this._l12_2a = this._l23_2a);
        (this._x0 = this._x1), (this._x1 = this._x2), (this._x2 = x);
        (this._y0 = this._y1), (this._y1 = this._y2), (this._y2 = y);
        this._lastDefined1 = this._lastDefined2;
        this._lastDefined2 = p.defined;
        this.lastPoint0 = this.lastPoint1;
        this.lastPoint1 = p;
    }
    tryUpdateLength() {
        return this.context.tryUpdateLength();
    }
}
const genCatmullRomClosedSegments = commonGenCatmullRomSegments('catmullRomClosed', CatmullRomClosed);

function divideQuad(curve, t) {
    const { p0, p1, p2 } = curve;
    const pt = quadPointAt(p0, p1, p2, t);
    const c1 = PointService.pointAtPP(p0, p1, t);
    const c2 = PointService.pointAtPP(p1, p2, t);
    const curve1 = new QuadraticBezierCurve(p0, c1, pt);
    const curve2 = new QuadraticBezierCurve(pt, c2, p2);
    return [curve1, curve2];
}
class QuadraticBezierCurve extends Curve {
    constructor(p0, p1, p2) {
        super();
        this.type = CurveTypeEnum.QuadraticBezierCurve;
        this.p0 = p0;
        this.p1 = p1;
        this.p2 = p2;
    }
    _validPoint() {
        return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y);
    }
    getPointAt(t) {
        if (this.defined !== false) {
            return quadPointAt(this.p0, this.p1, this.p2, t);
        }
        throw new Error('defined为false的点不能getPointAt');
    }
    calcLength() {
        if (this._validPoint()) {
            return quadLength(this.p0, this.p1, this.p2);
        }
        return 60;
    }
    calcProjLength(direction) {
        if (direction === Direction.ROW) {
            return abs(this.p0.x - this.p2.x);
        }
        else if (direction === Direction.COLUMN) {
            return abs(this.p0.y - this.p2.y);
        }
        return 0;
    }
    getAngleAt(t) {
        const minT = max(t - 0.01, 0);
        const maxT = min(t + 0.01, 1);
        const minP = this.getPointAt(minT);
        const maxP = this.getPointAt(maxT);
        return atan2(maxP.y - minP.y, maxP.x - minP.x);
    }
    draw(path, x, y, sx, sy, percent) {
        path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y);
        if (percent >= 1) {
            path.quadraticCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y);
        }
        else if (percent > 0) {
            const [curve1] = divideQuad(this, percent);
            path.quadraticCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y);
        }
    }
    getYAt(x) {
        throw new Error('QuadraticBezierCurve暂不支持getYAt');
    }
    includeX(x) {
        throw new Error('QuadraticBezierCurve暂不支持includeX');
    }
}

class CurveContext {
    constructor(path) {
        this.path = path;
        this._lastX = this._lastY = this._startX = this._startY = 0;
    }
    moveTo(x, y) {
        this._lastX = this._startX = x;
        this._lastY = this._startY = y;
        return this;
    }
    lineTo(x, y) {
        const curve = this.addLinearCurve(x, y);
        this.path.addCurve(curve);
        this._lastX = x;
        this._lastY = y;
    }
    addLinearCurve(x, y) {
        const curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
        return curve;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        const curve = new QuadraticBezierCurve(new Point(this._lastX, this._lastY), new Point(aCPx, aCPy), new Point(aX, aY));
        this.path.addCurve(curve);
        this._lastX = aX;
        this._lastY = aY;
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
        this.path.addCurve(curve);
        this._lastX = x;
        this._lastY = y;
    }
    arcTo(aX1, aY1, aX2, aY2, aRadius) {
        throw new Error('CurveContext不支持调用arcTo');
    }
    ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
        throw new Error('CurveContext不支持调用ellipse');
    }
    rect(x, y, w, h) {
        throw new Error('CurveContext不支持调用rect');
    }
    arc(x, y, radius, startAngle, endAngle, counterclockwise) {
        throw new Error('CurveContext不支持调用arc');
    }
    closePath() {
        if (this.path.curves.length < 2) {
            return;
        }
        this.lineTo(this._startX, this._startY);
    }
}

function calcLineCache(points, curveType, params) {
    var _a, _b;
    switch (curveType) {
        case 'linear':
            return genLinearSegments(points, params);
        case 'basis':
            return genBasisSegments(points, params);
        case 'monotoneX':
            return genMonotoneXSegments(points, params);
        case 'monotoneY':
            return genMonotoneYSegments(points, params);
        case 'step':
            return genStepSegments(points, 0.5, params);
        case 'stepClosed':
            return genStepClosedSegments(points, 0.5, params);
        case 'stepBefore':
            return genStepSegments(points, 0, params);
        case 'stepAfter':
            return genStepSegments(points, 1, params);
        case 'catmullRom':
            return genCatmullRomSegments(points, (_a = params === null || params === void 0 ? void 0 : params.curveTension) !== null && _a !== void 0 ? _a : 0.5, params);
        case 'catmullRomClosed':
            return genCatmullRomClosedSegments(points, (_b = params === null || params === void 0 ? void 0 : params.curveTension) !== null && _b !== void 0 ? _b : 0.5, params);
        case 'linearClosed':
            return genLinearClosedSegments(points, params);
        default:
            return genLinearSegments(points, params);
    }
}

class CustomPath2D extends CurvePath {
    constructor(ctx) {
        super();
        this.commandList = [];
        if (ctx) {
            this._ctx = ctx;
        }
        this._boundsContext = new BoundsContext(this.bounds);
    }
    get curves() {
        return this.tryBuildCurves();
    }
    setCtx(ctx) {
        this._ctx = ctx;
    }
    moveTo(x, y) {
        this.commandList.push([enumCommandMap.M, x, y]);
        this._ctx && this._ctx.moveTo(x, y);
        return this;
    }
    lineTo(x, y) {
        this.commandList.push([enumCommandMap.L, x, y]);
        this._ctx && this._ctx.lineTo(x, y);
        return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.commandList.push([enumCommandMap.Q, aCPx, aCPy, aX, aY]);
        this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.commandList.push([enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]);
        this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
    }
    arcTo(aX1, aY1, aX2, aY2, aRadius) {
        this.commandList.push([enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius]);
        this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius);
        return this;
    }
    ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
        this.commandList.push([enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise]);
        this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise);
        return this;
    }
    rect(x, y, w, h) {
        this.commandList.push([enumCommandMap.R, x, y, w, h]);
        this._ctx && this._ctx.rect(x, y, w, h);
        return this;
    }
    arc(x, y, radius, startAngle, endAngle, counterclockwise) {
        this.commandList.push([enumCommandMap.A, x, y, radius, startAngle, endAngle, counterclockwise]);
        this._ctx && this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise);
        return this;
    }
    closePath() {
        this.commandList.push([enumCommandMap.Z]);
        this._ctx && this._ctx.closePath();
        return this;
    }
    addCurve(curve) {
        this._curves.push(curve);
    }
    clear() {
        this.transformCbList = null;
        this.commandList.length = 0;
        this._curves.length = 0;
    }
    beginPath() {
        this.clear();
    }
    tryBuildCurves() {
        if (!(this._curves && this._curves.length)) {
            const curveContext = new CurveContext(this);
            renderCommandList(this.commandList, curveContext, 0, 0, 1, 1);
        }
        return this._curves;
    }
    toString() {
        if (!this.toStringCbList) {
            const list = [];
            list[enumCommandMap.M] = (cmd) => `M${cmd[1]} ${cmd[2]}`;
            list[enumCommandMap.L] = (cmd) => `L${cmd[1]} ${cmd[2]}`;
            list[enumCommandMap.Q] = (cmd) => `Q${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`;
            list[enumCommandMap.C] = (cmd) => `C${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]} ${cmd[5]} ${cmd[6]}`;
            list[enumCommandMap.A] = (cmd) => {
                const bezierPathList = [];
                const x = cmd[1];
                const y = cmd[2];
                const radius = cmd[3];
                const startAngle = cmd[4];
                const endAngle = cmd[5];
                const counterclockwise = cmd[6];
                addArcToBezierPath(bezierPathList, startAngle, endAngle, x, y, radius, radius, counterclockwise);
                let path = '';
                for (let i = 0; i < bezierPathList.length; i += 6) {
                    path += `C${bezierPathList[i]} ${bezierPathList[i + 1]} ${bezierPathList[i + 2]} ${bezierPathList[i + 3]} ${bezierPathList[i + 4]} ${bezierPathList[i + 5]}`;
                }
                return path;
            };
            list[enumCommandMap.R] = (cmd) => `M${cmd[1]} ${cmd[2]} h${cmd[3]} v${cmd[4]} H${cmd[1]}Z`;
            list[enumCommandMap.Z] = (cmd) => `Z`;
            this.toStringCbList = list;
        }
        const list = this.toStringCbList;
        let path = '';
        this.commandList.forEach(c => {
            path += list[c[0]](c);
        });
        return path;
    }
    fromString(str, x, y, sX, sY) {
        this.clear();
        const commandStrList = parseSvgPath(str);
        this._runCommandStrList(commandStrList, x, y, sX, sY);
        this._updateBounds();
        return this;
    }
    fromLine(line) {
        const { points, curveType, clipRangeByDimension } = line.attribute;
        if (!points) {
            return;
        }
        const cache = calcLineCache(points, curveType);
        if (clipRangeByDimension === 'x') {
            this.direction = Direction.ROW;
        }
        else if (clipRangeByDimension === 'y') {
            this.direction = Direction.COLUMN;
        }
        else if (clipRangeByDimension === 'auto') {
            this.direction = cache.direction;
        }
        this._curves = cache.curves;
    }
    fromCustomPath2D(path, x, y, sX, sY) {
        this.clear();
        this._runCommandList(path.commandList, x, y, sX, sY);
        this._updateBounds();
        return this;
    }
    transform(x, y, sx, sy) {
        const commandList = this.commandList;
        if (!this.transformCbList) {
            const list = [];
            list[enumCommandMap.M] = this.moveToTransform;
            list[enumCommandMap.L] = this.lineToTransform;
            list[enumCommandMap.Q] = this.quadraticCurveToTransform;
            list[enumCommandMap.C] = this.bezierCurveToTransform;
            list[enumCommandMap.AT] = this.arcToTransform;
            list[enumCommandMap.E] = this.ellipseTransform;
            list[enumCommandMap.R] = this.rectTransform;
            list[enumCommandMap.A] = this.arcTransform;
            list[enumCommandMap.Z] = this.closePathTransform;
            this.transformCbList = list;
        }
        commandList.forEach(cmd => {
            this.transformCbList[cmd[0]](cmd, x, y, sx, sy);
        });
        this._updateBounds();
    }
    moveToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x;
        cmd[2] = cmd[2] * sy + y;
    }
    lineToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x;
        cmd[2] = cmd[2] * sy + y;
    }
    quadraticCurveToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x;
        cmd[2] = cmd[2] * sy + y;
        cmd[3] = cmd[3] * sx + x;
        cmd[4] = cmd[4] * sy + y;
    }
    bezierCurveToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x;
        cmd[2] = cmd[2] * sy + y;
        cmd[3] = cmd[3] * sx + x;
        cmd[4] = cmd[4] * sy + y;
        cmd[5] = cmd[5] * sx + x;
        cmd[6] = cmd[6] * sy + y;
    }
    arcToTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x;
        cmd[2] = cmd[2] * sy + y;
        cmd[3] = cmd[3] * sx + x;
        cmd[4] = cmd[4] * sy + y;
        cmd[5] = (cmd[5] * (sx + sy)) / 2;
    }
    ellipseTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x;
        cmd[2] = cmd[2] * sy + y;
        cmd[3] = cmd[3] * sx;
        cmd[4] = cmd[4] * sy;
    }
    rectTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x;
        cmd[2] = cmd[2] * sy + y;
        cmd[3] = cmd[3] * sx;
        cmd[4] = cmd[4] * sy;
    }
    arcTransform(cmd, x, y, sx, sy) {
        cmd[1] = cmd[1] * sx + x;
        cmd[2] = cmd[2] * sy + y;
        cmd[3] = (cmd[3] * (sx + sy)) / 2;
    }
    closePathTransform() {
        return;
    }
    _runCommandStrList(commandStrList, l = 0, t = 0, sX = 1, sY = 1) {
        let current;
        let previous = null;
        let x = 0;
        let y = 0;
        let controlX = 0;
        let controlY = 0;
        let tempX;
        let tempY;
        let tempControlX;
        let tempControlY;
        for (let i = 0, len = commandStrList.length; i < len; ++i) {
            current = commandStrList[i];
            if (sX !== 1 || sY !== 1) {
                current = scale(current, sX, sY);
            }
            switch (current[0]) {
                case 'l':
                    x += current[1];
                    y += current[2];
                    this.lineTo(x + l, y + t);
                    break;
                case 'L':
                    x = current[1];
                    y = current[2];
                    this.lineTo(x + l, y + t);
                    break;
                case 'h':
                    x += current[1];
                    this.lineTo(x + l, y + t);
                    break;
                case 'H':
                    x = current[1];
                    this.lineTo(x + l, y + t);
                    break;
                case 'v':
                    y += current[1];
                    this.lineTo(x + l, y + t);
                    break;
                case 'V':
                    y = current[1];
                    this.lineTo(x + l, y + t);
                    break;
                case 'm':
                    x += current[1];
                    y += current[2];
                    this.moveTo(x + l, y + t);
                    break;
                case 'M':
                    x = current[1];
                    y = current[2];
                    this.moveTo(x + l, y + t);
                    break;
                case 'c':
                    tempX = x + current[5];
                    tempY = y + current[6];
                    controlX = x + current[3];
                    controlY = y + current[4];
                    this.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t);
                    x = tempX;
                    y = tempY;
                    break;
                case 'C':
                    x = current[5];
                    y = current[6];
                    controlX = current[3];
                    controlY = current[4];
                    this.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
                    break;
                case 's':
                    tempX = x + current[3];
                    tempY = y + current[4];
                    if (previous[0].match(/[CcSs]/) === null) {
                        controlX = x;
                        controlY = y;
                    }
                    else {
                        controlX = 2 * x - controlX;
                        controlY = 2 * y - controlY;
                    }
                    tempControlX = x + current[1];
                    tempControlY = y + current[2];
                    this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t);
                    controlX = tempControlX;
                    controlY = tempControlY;
                    x = tempX;
                    y = tempY;
                    break;
                case 'S':
                    tempX = current[3];
                    tempY = current[4];
                    if (previous[0].match(/[CcSs]/) === null) {
                        controlX = x;
                        controlY = y;
                    }
                    else {
                        controlX = 2 * x - controlX;
                        controlY = 2 * y - controlY;
                    }
                    tempControlX = current[1];
                    tempControlY = current[2];
                    this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t);
                    controlX = tempControlX;
                    controlY = tempControlY;
                    x = tempX;
                    y = tempY;
                    break;
                case 'q':
                    tempX = x + current[3];
                    tempY = y + current[4];
                    controlX = x + current[1];
                    controlY = y + current[2];
                    this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
                    x = tempX;
                    y = tempY;
                    break;
                case 'Q':
                    tempX = current[3];
                    tempY = current[4];
                    this.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);
                    x = tempX;
                    y = tempY;
                    controlX = current[1];
                    controlY = current[2];
                    break;
                case 't':
                    tempX = x + current[1];
                    tempY = y + current[2];
                    if (previous[0].match(/[QqTt]/) === null) {
                        controlX = x;
                        controlY = y;
                    }
                    else if (previous[0] === 't') {
                        controlX = 2 * x - tempControlX;
                        controlY = 2 * y - tempControlY;
                    }
                    else if (previous[0] === 'q') {
                        controlX = 2 * x - controlX;
                        controlY = 2 * y - controlY;
                    }
                    tempControlX = controlX;
                    tempControlY = controlY;
                    this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
                    x = tempX;
                    y = tempY;
                    controlX = x + current[1];
                    controlY = y + current[2];
                    break;
                case 'T':
                    tempX = current[1];
                    tempY = current[2];
                    controlX = 2 * x - controlX;
                    controlY = 2 * y - controlY;
                    this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
                    x = tempX;
                    y = tempY;
                    break;
                case 'a':
                    drawArc(this, x + l, y + t, [
                        current[1],
                        current[2],
                        current[3],
                        current[4],
                        current[5],
                        current[6] + x + l,
                        current[7] + y + t
                    ]);
                    x += current[6];
                    y += current[7];
                    break;
                case 'A':
                    drawArc(this, x + l, y + t, [
                        current[1],
                        current[2],
                        current[3],
                        current[4],
                        current[5],
                        current[6] + l,
                        current[7] + t
                    ]);
                    x = current[6];
                    y = current[7];
                    break;
                case 'z':
                case 'Z':
                    this.closePath();
                    break;
            }
            previous = current;
        }
    }
    _runCommandList(commandList, l = 0, t = 0, sX = 1, sY = 1) {
        if (l === 0 && t === 0 && sX === 1 && sY === 1) {
            this.commandList = commandList.map(entry => entry.slice());
            return;
        }
        for (let i = 0, len = commandList.length; i < len; ++i) {
            const current = commandList[i].slice();
            switch (current[0]) {
                case enumCommandMap.L:
                    this.lineToTransform(current, l, t, sX, sY);
                    break;
                case enumCommandMap.M:
                    this.moveToTransform(current, l, t, sX, sY);
                    break;
                case enumCommandMap.C:
                    this.bezierCurveToTransform(current, l, t, sX, sY);
                    break;
                case enumCommandMap.Q:
                    this.quadraticCurveToTransform(current, l, t, sX, sY);
                    break;
                case enumCommandMap.A:
                    this.arcToTransform(current, l, t, sX, sY);
                    break;
                case enumCommandMap.E:
                    this.ellipseTransform(current, l, t, sX, sY);
                    break;
                case enumCommandMap.R:
                    this.rectTransform(current, l, t, sX, sY);
                    break;
                case enumCommandMap.AT:
                    this.arcToTransform(current, l, t, sX, sY);
                    break;
                case enumCommandMap.Z:
                    this.closePath();
                    break;
            }
        }
    }
    _updateBounds() {
        this.bounds.clear();
        renderCommandList(this.commandList, this._boundsContext);
    }
    release() {
        this.commandList = [];
        this._boundsContext = null;
        this._ctx = null;
    }
    getLength() {
        if (this.direction === Direction.COLUMN) {
            if (!this._curves.length) {
                return 0;
            }
            const sc = this._curves[0];
            const ec = this._curves[this._curves.length - 1];
            return abs(sc.p0.y - ec.p1.y);
        }
        else if (this.direction === Direction.ROW) {
            if (!this._curves.length) {
                return 0;
            }
            const sc = this._curves[0];
            const ec = this._curves[this._curves.length - 1];
            return abs(sc.p0.x - ec.p1.x);
        }
        return this._curves.reduce((l, c) => l + c.getLength(), 0);
    }
    getYAt(x) {
        if (!this.curves) {
            return Infinity;
        }
        for (let i = 0; i < this.curves.length; i++) {
            const curve = this.curves[i];
            if (curve.includeX(x)) {
                return curve.getYAt(x);
            }
        }
        return Infinity;
    }
    getAttrAt(distance) {
        if (!this._curves) {
            return { pos: { x: 0, y: 0 }, angle: 0 };
        }
        let _dis = 0;
        let curve;
        for (let i = 0; i < this._curves.length; i++) {
            curve = this._curves[i];
            const cl = curve.getLength(this.direction);
            if (_dis + cl >= distance) {
                break;
            }
            else {
                _dis += cl;
            }
        }
        const t = (distance - _dis) / curve.getLength(this.direction);
        const pos = curve.getPointAt(t);
        const angle = curve.getAngleAt(t);
        return { pos, angle };
    }
    drawWithClipRange(ctx, size, x, y, clipRange) {
        this.tryBuildCurves();
        const totalLen = this.getLength() * clipRange;
        let currLen = 0;
        for (let i = 0; i < this._curves.length; i++) {
            const curve = this._curves[i];
            const cl = curve.getLength(this.direction);
            if (currLen + cl <= totalLen) {
                curve.draw(ctx, x, y, size, size, 1);
            }
            else {
                const percent = 1 - (currLen + cl - totalLen) / cl;
                curve.draw(ctx, x, y, size, size, percent);
                break;
            }
            currLen += cl;
        }
    }
}
const temp = ['l', 0, 0, 0, 0, 0, 0, 0];
function scale(current, sX, sY) {
    const c = (temp[0] = current[0]);
    if (c === 'a' || c === 'A') {
        temp[1] = sX * current[1];
        temp[2] = sY * current[2];
        temp[3] = current[3];
        temp[4] = current[4];
        temp[5] = current[5];
        temp[6] = sX * current[6];
        temp[7] = sY * current[7];
    }
    else if (c === 'h' || c === 'H') {
        temp[1] = sX * current[1];
    }
    else if (c === 'v' || c === 'V') {
        temp[1] = sY * current[1];
    }
    else {
        for (let i = 1, n = current.length; i < n; ++i) {
            temp[i] = (i % 2 === 1 ? sX : sY) * current[i];
        }
    }
    return temp;
}

const DefaultLayout = {
    alignSelf: 'auto'
};
const DefaultTransform = {
    x: 0,
    y: 0,
    z: 0,
    dx: 0,
    dy: 0,
    dz: 0,
    scrollX: 0,
    scrollY: 0,
    scaleX: 1,
    scaleY: 1,
    scaleZ: 1,
    angle: 0,
    alpha: 0,
    beta: 0,
    scaleCenter: [0, 0],
    anchor: [0, 0],
    anchor3d: [0, 0],
    postMatrix: new Matrix()
};
const DefaultFillStyle = {
    fillOpacity: 1,
    fill: false,
    shadowBlur: 0,
    shadowColor: 'black',
    shadowOffsetX: 0,
    shadowOffsetY: 0
};
const commonStroke = {
    strokeOpacity: 1,
    lineDash: [],
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: 'butt',
    lineJoin: 'miter',
    miterLimit: 10,
    strokeBoundsBuffer: 2,
    stroke: false
};
const DefaultStrokeStyle = Object.assign({ outerBorder: Object.assign(Object.assign({}, commonStroke), { distance: 0 }), innerBorder: Object.assign(Object.assign({}, commonStroke), { distance: 0 }) }, commonStroke);
const DefaultTextStyle = {
    text: '',
    maxLineWidth: Infinity,
    maxWidth: Infinity,
    textAlign: 'left',
    textBaseline: 'alphabetic',
    fontSize: 16,
    fontFamily: `PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,
    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol`,
    fontWeight: '',
    ellipsis: '…',
    fontVariant: '',
    fontStyle: '',
    lineHeight: undefined,
    underline: 0,
    lineThrough: 0,
    scaleIn3d: false,
    direction: 'horizontal',
    wordBreak: 'break-all',
    ignoreBuf: false,
    verticalMode: 0,
    wrap: false,
    whiteSpace: 'no-wrap',
    heightLimit: Infinity,
    lineClamp: Infinity,
    suffixPosition: 'end',
    underlineDash: [],
    underlineOffset: 0,
    disableAutoClipedPoptip: undefined,
    measureMode: MeasureModeEnum.fontBounding,
    keepCenterInLine: false
};
const DefaultPickStyle = {
    pickStrokeBuffer: 0
};
const DefaultStyle = Object.assign(Object.assign(Object.assign(Object.assign({ forceBoundsWidth: undefined, forceBoundsHeight: undefined, opacity: 1, background: null, autoAnimateTexture: false, textureRatio: 1, textureOptions: null, backgroundOpacity: 1, backgroundCornerRadius: 0, texture: null, textureColor: 'black', textureSize: 10, texturePadding: 2, backgroundMode: 'no-repeat', backgroundFit: true, backgroundKeepAspectRatio: false, backgroundClip: true, backgroundScale: 1, backgroundOffsetX: 0, backgroundOffsetY: 0, blur: 0, filter: '', cursor: null, html: null, react: null, vue: null }, DefaultFillStyle), DefaultStrokeStyle), DefaultLayout), DefaultPickStyle);
const DefaultConnectAttribute = {
    connectedType: 'none',
    connectedStyle: {},
    connectedX: NaN,
    connectedY: NaN
};
const DefaultDebugAttribute = {
    _debug_bounds: false
};
const DefaultAttribute = Object.assign(Object.assign(Object.assign({ strokeSeg: null, renderable: true, pickable: true, shadowGraphic: undefined, childrenPickable: true, fillPickable: true, strokePickable: true, visible: true, zIndex: 0, layout: null, boundsPadding: 0, fillStrokeOrder: 0, renderStyle: 'default', pickMode: 'accurate', customPickShape: null, boundsMode: 'accurate', keepDirIn3d: true, shadowRootIdx: 1, globalZIndex: 1, globalCompositeOperation: '', overflow: 'hidden', shadowPickMode: 'graphic', keepStrokeScale: false, clipConfig: null, roughStyle: null }, DefaultDebugAttribute), DefaultStyle), DefaultTransform);
function addAttributeToPrototype(obj, c, keys) {
    keys.forEach(key => {
        c.prototype[key] = obj[key];
    });
}
function rewriteProto(obj, c) {
    Object.setPrototypeOf(obj, c);
}
const DefaultArcAttribute = Object.assign(Object.assign({}, DefaultAttribute), { startAngle: 0, endAngle: pi2, innerRadius: 0, outerRadius: 1, innerPadding: 0, outerPadding: 0, cornerRadius: 0, padRadius: 0, padAngle: 0, cap: false, forceShowCap: false });
const DefaultAreaAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), { points: [], segments: [], curveType: 'linear', clipRange: 1, closePath: false, curveTension: 1 });
const DefaultCircleAttribute = Object.assign(Object.assign({}, DefaultAttribute), { radius: 1, startAngle: 0, endAngle: pi2 });
const DefaultGroupAttribute = Object.assign(Object.assign({}, DefaultAttribute), { width: 0, height: 0, cornerRadius: 0, path: [], clip: false, visibleAll: true, display: 'relative', flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'flex-start', alignItems: 'flex-start', alignContent: 'flex-start', baseOpacity: 1, cornerType: 'round' });
const DefaultGlyphAttribute = Object.assign(Object.assign({}, DefaultAttribute), { path: '', width: 0, height: 0, cornerRadius: 0, clip: false });
const DefaultLineAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), { points: [], segments: [], curveType: 'linear', clipRange: 1, clipRangeByDimension: 'default', closePath: false, curveTension: 1 });
const DefaultPathAttribute = Object.assign(Object.assign({}, DefaultAttribute), { path: new CustomPath2D(), fillStrokeOrder: 1, clipRange: 1, customPath: () => {
        Logger.getInstance().warn('空函数');
    } });
const DefaultPolygonAttribute = Object.assign(Object.assign({}, DefaultAttribute), { points: [], cornerRadius: 0, closePath: true });
const DefaultStarAttribute = Object.assign(Object.assign({}, DefaultAttribute), { width: 100, height: 100, spikes: 5, thickness: 0.5 });
const DefaultRectAttribute = Object.assign(Object.assign({}, DefaultAttribute), { width: 0, height: 0, x1: 0, y1: 0, strokeBoundsBuffer: 0, cornerRadius: 0, cornerType: 'round', drawStrokeWhenZeroWH: false });
const DefaultRect3dAttribute = Object.assign(Object.assign({}, DefaultAttribute), { width: 0, height: 0, x1: 0, y1: 0, cornerRadius: 0, length: 0, cornerType: 'round', drawStrokeWhenZeroWH: false });
const DefaultSymbolAttribute = Object.assign(Object.assign({}, DefaultAttribute), { symbolType: 'circle', size: 10, keepDirIn3d: true, clipRange: 1 });
const DefaultTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), { strokeBoundsBuffer: 0, keepDirIn3d: true });
const DefaultRichTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), { upgradeAttrs: null, editable: false, editOptions: null, ascentDescentMode: 'actual', width: 300, height: 300, ellipsis: true, wordBreak: 'break-word', verticalDirection: 'top', textAlign: 'left', textBaseline: 'top', layoutDirection: 'horizontal', textConfig: [], disableAutoWrapLine: false, maxHeight: undefined, maxWidth: undefined, singleLine: false });
const DefaultImageAttribute = Object.assign(Object.assign({ repeatX: 'no-repeat', repeatY: 'no-repeat', image: '', width: 0, height: 0, maxWidth: 500, maxHeight: 500 }, DefaultAttribute), { fill: true, cornerRadius: 0, cornerType: 'round' });
const DefaultRichTextIconAttribute = Object.assign(Object.assign({}, DefaultImageAttribute), { backgroundShowMode: 'never', backgroundWidth: 0, backgroundHeight: 0, textAlign: 'left', textBaseline: 'middle', direction: 'horizontal', margin: 0, id: '', width: 20, height: 20, backgroundFill: 'rgba(101, 117, 168, 0.1)', backgroundFillOpacity: 1, backgroundStroke: false, backgroundStrokeOpacity: 1, backgroundRadius: 4, opacity: 1 });

const parse = (function () {
    const tokens = {
        linearGradient: /^(linear\-gradient)/i,
        radialGradient: /^(radial\-gradient)/i,
        conicGradient: /^(conic\-gradient)/i,
        sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
        extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
        positionKeywords: /^(left|center|right|top|bottom)/i,
        pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
        percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
        emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
        angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
        fromAngleValue: /^from\s*(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
        startCall: /^\(/,
        endCall: /^\)/,
        comma: /^,/,
        hexColor: /(^\#[0-9a-fA-F]+)/,
        literalColor: /^([a-zA-Z]+)/,
        rgbColor: /^(rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))/i,
        rgbaColor: /^(rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*((\d\.\d+)|\d{1,3})\))/i,
        number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
    };
    let input = '';
    function error(msg) {
        const err = new Error(input + ': ' + msg);
        err.source = input;
        throw err;
    }
    function getAST() {
        const ast = matchListDefinitions();
        if (input.length > 0) {
            error('Invalid input not EOF');
        }
        return ast;
    }
    function matchListDefinitions() {
        return matchListing(matchDefinition);
    }
    function matchDefinition() {
        return (matchGradient('linear', tokens.linearGradient, matchLinearOrientation) ||
            matchGradient('radial', tokens.radialGradient, matchListRadialOrientations) ||
            matchGradient('conic', tokens.conicGradient, matchConicalOrientation));
    }
    function matchGradient(gradientType, pattern, orientationMatcher) {
        return matchCall(pattern, function (captures) {
            const orientation = orientationMatcher();
            if (orientation) {
                if (!scan(tokens.comma)) {
                    error('Missing comma before color stops');
                }
            }
            return {
                type: gradientType,
                orientation: orientation,
                colorStops: matchListing(matchColorStop)
            };
        });
    }
    function matchCall(pattern, callback) {
        const captures = scan(pattern);
        if (captures) {
            if (!scan(tokens.startCall)) {
                error('Missing (');
            }
            const result = callback(captures);
            if (!scan(tokens.endCall)) {
                error('Missing )');
            }
            return result;
        }
    }
    function matchLinearOrientation() {
        return matchSideOrCorner() || matchAngle();
    }
    function matchConicalOrientation() {
        return matchFromAngle();
    }
    function matchSideOrCorner() {
        return match('directional', tokens.sideOrCorner, 1);
    }
    function matchAngle() {
        return match('angular', tokens.angleValue, 1);
    }
    function matchFromAngle() {
        return match('angular', tokens.fromAngleValue, 1);
    }
    function matchListRadialOrientations() {
        let radialOrientations;
        let radialOrientation = matchRadialOrientation();
        let lookaheadCache;
        if (radialOrientation) {
            radialOrientations = [];
            radialOrientations.push(radialOrientation);
            lookaheadCache = input;
            if (scan(tokens.comma)) {
                radialOrientation = matchRadialOrientation();
                if (radialOrientation) {
                    radialOrientations.push(radialOrientation);
                }
                else {
                    input = lookaheadCache;
                }
            }
        }
        return radialOrientations;
    }
    function matchRadialOrientation() {
        let radialType = matchCircle() || matchEllipse();
        if (radialType) {
            radialType.at = matchAtPosition();
        }
        else {
            const extent = matchExtentKeyword();
            if (extent) {
                radialType = extent;
                const positionAt = matchAtPosition();
                if (positionAt) {
                    radialType.at = positionAt;
                }
            }
            else {
                const defaultPosition = matchPositioning();
                if (defaultPosition) {
                    radialType = {
                        type: 'default-radial',
                        at: defaultPosition
                    };
                }
            }
        }
        return radialType;
    }
    function matchCircle() {
        const circle = match('shape', /^(circle)/i, 0);
        if (circle) {
            circle.style = matchLength() || matchExtentKeyword();
        }
        return circle;
    }
    function matchEllipse() {
        const ellipse = match('shape', /^(ellipse)/i, 0);
        if (ellipse) {
            ellipse.style = matchDistance() || matchExtentKeyword();
        }
        return ellipse;
    }
    function matchExtentKeyword() {
        return match('extent-keyword', tokens.extentKeywords, 1);
    }
    function matchAtPosition() {
        if (match('position', /^at/, 0)) {
            const positioning = matchPositioning();
            if (!positioning) {
                error('Missing positioning value');
            }
            return positioning;
        }
    }
    function matchPositioning() {
        const location = matchCoordinates();
        if (location.x || location.y) {
            return {
                type: 'position',
                value: location
            };
        }
    }
    function matchCoordinates() {
        return {
            x: matchDistance(),
            y: matchDistance()
        };
    }
    function matchListing(matcher) {
        let captures = matcher();
        const result = [];
        if (captures) {
            result.push(captures);
            while (scan(tokens.comma)) {
                captures = matcher();
                if (captures) {
                    result.push(captures);
                }
                else {
                    error('One extra comma');
                }
            }
        }
        return result;
    }
    function matchColorStop() {
        const color = matchColor();
        if (!color) {
            error('Expected color definition');
        }
        color.length = matchDistance();
        return color;
    }
    function matchColor() {
        return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
    }
    function matchLiteralColor() {
        return match('literal', tokens.literalColor, 0);
    }
    function matchHexColor() {
        return match('hex', tokens.hexColor, 1);
    }
    function matchRGBColor() {
        return match('rgb', tokens.rgbColor, 1);
    }
    function matchRGBAColor() {
        return match('rgba', tokens.rgbaColor, 1);
    }
    function matchDistance() {
        return match('%', tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
    }
    function matchPositionKeyword() {
        return match('position-keyword', tokens.positionKeywords, 1);
    }
    function matchLength() {
        return match('px', tokens.pixelValue, 1) || match('em', tokens.emValue, 1);
    }
    function match(type, pattern, captureIndex) {
        const captures = scan(pattern);
        if (captures) {
            return {
                type: type,
                value: captures[captureIndex]
            };
        }
    }
    function scan(regexp) {
        const blankCaptures = /^[\n\r\t\s]+/.exec(input);
        if (blankCaptures) {
            consume(blankCaptures[0].length);
        }
        const captures = regexp.exec(input);
        if (captures) {
            consume(captures[0].length);
        }
        return captures;
    }
    function consume(size) {
        input = input.substr(size);
    }
    return function (code) {
        input = code.toString();
        return getAST();
    };
})();
class GradientParser {
    static IsGradient(c) {
        return !(typeof c === 'string' && !c.includes('gradient'));
    }
    static IsGradientStr(c) {
        return typeof c === 'string' && c.includes('gradient');
    }
    static Parse(c) {
        if (GradientParser.IsGradientStr(c)) {
            try {
                const data = parse(c);
                const datum = data[0];
                if (datum) {
                    if (datum.type === 'linear') {
                        return GradientParser.ParseLinear(datum);
                    }
                    else if (datum.type === 'radial') {
                        return GradientParser.ParseRadial(datum);
                    }
                    else if (datum.type === 'conic') {
                        return GradientParser.ParseConic(datum);
                    }
                }
            }
            catch (err) {
                return c;
            }
        }
        return c;
    }
    static processColorStops(colorStops) {
        if (!colorStops || colorStops.length === 0) {
            return [];
        }
        const anyStopHasLength = colorStops.some((item) => item.length);
        if (anyStopHasLength) {
            const stops = colorStops.map((item) => ({
                color: item.value,
                offset: item.length ? parseFloat(item.length.value) / 100 : -1
            }));
            if (stops[0].offset < 0) {
                stops[0].offset = 0;
            }
            if (stops[stops.length - 1].offset < 0) {
                stops[stops.length - 1].offset = 1;
            }
            for (let i = 1; i < stops.length - 1; i++) {
                if (stops[i].offset < 0) {
                    const prevWithOffsetIdx = i - 1;
                    let nextWithOffsetIdx = i + 1;
                    while (nextWithOffsetIdx < stops.length && stops[nextWithOffsetIdx].offset < 0) {
                        nextWithOffsetIdx++;
                    }
                    const startOffset = stops[prevWithOffsetIdx].offset;
                    const endOffset = stops[nextWithOffsetIdx].offset;
                    const unspecCount = nextWithOffsetIdx - prevWithOffsetIdx;
                    for (let j = 1; j < unspecCount; j++) {
                        stops[prevWithOffsetIdx + j].offset = startOffset + ((endOffset - startOffset) * j) / unspecCount;
                    }
                    i = nextWithOffsetIdx - 1;
                }
            }
            return stops;
        }
        return colorStops.map((item, index) => {
            const offset = colorStops.length > 1 ? index / (colorStops.length - 1) : 0;
            return {
                color: item.value,
                offset
            };
        });
    }
    static ParseConic(datum) {
        const { orientation, colorStops = [] } = datum;
        const halfPi = pi / 2;
        const sa = (parseFloat(orientation.value) / 180) * pi - halfPi;
        return {
            gradient: 'conical',
            x: 0.5,
            y: 0.5,
            startAngle: sa,
            endAngle: sa + pi2,
            stops: GradientParser.processColorStops(colorStops)
        };
    }
    static ParseRadial(datum) {
        const { colorStops = [] } = datum;
        return {
            gradient: 'radial',
            x0: 0.5,
            y0: 0.5,
            x1: 0.5,
            y1: 0.5,
            r0: 0,
            r1: 1,
            stops: GradientParser.processColorStops(colorStops)
        };
    }
    static ParseLinear(datum) {
        const { orientation, colorStops = [] } = datum;
        const halfPi = pi / 2;
        let angle = orientation.type === 'angular' ? (parseFloat(orientation.value) / 180) * pi : 0;
        while (angle < 0) {
            angle += pi2;
        }
        while (angle >= pi2) {
            angle -= pi2;
        }
        let x0 = 0;
        let y0 = 0;
        let x1 = 0;
        let y1 = 0;
        if (angle < halfPi) {
            x0 = 0;
            y0 = 1;
            x1 = Math.sin(angle);
            y1 = y0 - Math.cos(angle);
        }
        else if (angle < pi) {
            x0 = 0;
            y0 = 0;
            x1 = Math.cos(angle - halfPi);
            y1 = Math.sin(angle - halfPi);
        }
        else if (angle < pi + halfPi) {
            x0 = 1;
            y0 = 0;
            x1 = x0 - Math.sin(angle - pi);
            y1 = Math.cos(angle - pi);
        }
        else {
            x0 = 1;
            x1 = x0 - Math.cos(angle - halfPi - pi);
            y1 = y1 - Math.sin(angle - halfPi - pi);
        }
        return {
            gradient: 'linear',
            x0,
            y0,
            x1,
            y1,
            stops: GradientParser.processColorStops(colorStops)
        };
    }
}

function getScaledStroke(context, width, dpr) {
    let strokeWidth = width;
    const { a, b, c, d } = context.currentMatrix;
    const scaleX = Math.sign(a) * Math.sqrt(a * a + b * b);
    const scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);
    if (scaleX + scaleY === 0) {
        return 0;
    }
    strokeWidth = (strokeWidth / Math.abs(scaleX + scaleY)) * 2 * dpr;
    return strokeWidth;
}
function createColor(context, c, params, offsetX = 0, offsetY = 0) {
    var _a, _b, _c, _d;
    if (!c || c === true) {
        return 'black';
    }
    let result;
    let color;
    if (isArray(c)) {
        for (let i = 0; i < c.length; i++) {
            color = c[i];
            if (color) {
                break;
            }
        }
    }
    else {
        color = c;
    }
    color = GradientParser.Parse(color);
    if (typeof color === 'string') {
        return color;
    }
    if (params.AABBBounds && (!params.attribute || params.attribute.scaleX !== 0 || params.attribute.scaleY !== 0)) {
        const bounds = params.AABBBounds;
        let w = bounds.x2 - bounds.x1;
        let h = bounds.y2 - bounds.y1;
        let x = bounds.x1 - offsetX;
        let y = bounds.y1 - offsetY;
        if (params.attribute) {
            const { scaleX = 1, scaleY = 1, angle = 0 } = params.attribute;
            w /= scaleX;
            h /= scaleY;
            x /= scaleX;
            y /= scaleY;
            if (angle || scaleX !== 1 || scaleY !== 1) {
                x = (_a = params.x1WithoutTransform) !== null && _a !== void 0 ? _a : 0;
                y = (_b = params.y1WithoutTransform) !== null && _b !== void 0 ? _b : 0;
                w = (_c = params.widthWithoutTransform) !== null && _c !== void 0 ? _c : w;
                h = (_d = params.heightWithoutTransform) !== null && _d !== void 0 ? _d : h;
            }
        }
        if (color.gradient === 'linear') {
            result = createLinearGradient(context, color, x, y, w, h);
        }
        else if (color.gradient === 'conical') {
            result = createConicGradient(context, color, x, y, w, h);
        }
        else if (color.gradient === 'radial') {
            result = createRadialGradient(context, color, x, y, w, h);
        }
    }
    return result || 'orange';
}
function createLinearGradient(context, color, x, y, w, h) {
    var _a, _b, _c, _d;
    const canvasGradient = context.createLinearGradient(x + ((_a = color.x0) !== null && _a !== void 0 ? _a : 0) * w, y + ((_b = color.y0) !== null && _b !== void 0 ? _b : 0) * h, x + ((_c = color.x1) !== null && _c !== void 0 ? _c : 1) * w, y + ((_d = color.y1) !== null && _d !== void 0 ? _d : 0) * h);
    color.stops.forEach(stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
    });
    return canvasGradient;
}
function createRadialGradient(context, color, x, y, w, h) {
    var _a, _b, _c, _d, _e, _f;
    const canvasGradient = context.createRadialGradient(x + ((_a = color.x0) !== null && _a !== void 0 ? _a : 0.5) * w, y + ((_b = color.y0) !== null && _b !== void 0 ? _b : 0.5) * h, Math.max(w, h) * ((_c = color.r0) !== null && _c !== void 0 ? _c : 0), x + ((_d = color.x1) !== null && _d !== void 0 ? _d : 0.5) * w, y + ((_e = color.y1) !== null && _e !== void 0 ? _e : 0.5) * h, Math.max(w, h) * ((_f = color.r1) !== null && _f !== void 0 ? _f : 0.5));
    color.stops.forEach(stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
    });
    return canvasGradient;
}
function createConicGradient(context, color, x, y, w, h) {
    var _a, _b;
    const canvasGradient = context.createConicGradient(x + ((_a = color.x) !== null && _a !== void 0 ? _a : 0) * w, y + ((_b = color.y) !== null && _b !== void 0 ? _b : 0) * h, color.startAngle, color.endAngle);
    color.stops.forEach(stop => {
        canvasGradient.addColorStop(stop.offset, stop.color);
    });
    let deltaAngle;
    return canvasGradient.GetPattern
        ? canvasGradient.GetPattern(w + x, h + y, deltaAngle)
        : canvasGradient;
}

const DIRECTION_KEY = {
    horizontal: {
        width: 'width',
        height: 'height',
        left: 'left',
        top: 'top',
        x: 'x',
        y: 'y',
        bottom: 'bottom'
    },
    vertical: {
        width: 'height',
        height: 'width',
        left: 'top',
        top: 'left',
        x: 'y',
        y: 'x',
        bottom: 'right'
    }
};
const defaultFormatting = {
    fontSize: 16,
    fontFamily: DEFAULT_TEXT_FONT_FAMILY,
    fill: true,
    stroke: false,
    fontWeight: 'normal',
    lineHeight: 'normal',
    fontStyle: 'normal',
    textDecoration: 'none',
    textAlign: 'left',
    script: 'normal'
};
const regLetter = /\w|\(|\)|-/;
const regPunctuation = /[.?!,;:/，。？！、；：]/;
const regFirstSpace = /\S/;
const setTextStyle = (ctx, character) => {
    let fontSize = character.fontSize || 16;
    switch (character.script) {
        case 'super':
        case 'sub':
            fontSize *= 0.8;
            break;
    }
    ctx.setTextStyle({
        textAlign: 'left',
        textBaseline: character.textBaseline || 'alphabetic',
        fontStyle: character.fontStyle || '',
        fontWeight: character.fontWeight || '',
        fontSize,
        fontFamily: character.fontFamily
    });
};
function applyFillStyle(ctx, character, b) {
    const fillStyle = (character && character.fill) || defaultFormatting.fill;
    if (!fillStyle) {
        ctx.globalAlpha = 0;
        return;
    }
    const { fillOpacity = 1, opacity = 1 } = character;
    ctx.globalAlpha = fillOpacity * opacity;
    ctx.fillStyle = b ? createColor(ctx, fillStyle, { AABBBounds: b }) : fillStyle;
    setTextStyle(ctx, character);
}
function applyStrokeStyle(ctx, character) {
    const strokeStyle = (character && character.stroke) || defaultFormatting.stroke;
    if (!strokeStyle) {
        ctx.globalAlpha = 0;
        return;
    }
    const { strokeOpacity = 1, opacity = 1 } = character;
    ctx.globalAlpha = strokeOpacity * opacity;
    ctx.lineWidth = character && typeof character.lineWidth === 'number' ? character.lineWidth : 1;
    ctx.strokeStyle = strokeStyle;
    setTextStyle(ctx, character);
}
function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
    if (desc.length <= 1) {
        return 0;
    }
    if (!width || width <= 0) {
        return 0;
    }
    const textMeasure = application.graphicUtil.textMeasure;
    let index = guessIndex;
    let temp = desc.slice(0, index);
    let tempWidth = Math.floor(textMeasure.measureText(temp, character).width);
    let tempNext = desc.slice(0, index + 1);
    let tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
    while (tempWidth > width || tempWidthNext <= width) {
        if (tempWidth > width) {
            index--;
        }
        else {
            index++;
        }
        if (index > desc.length) {
            index = desc.length;
            break;
        }
        else if (index < 0) {
            index = 0;
            break;
        }
        temp = desc.slice(0, index);
        tempWidth = Math.floor(textMeasure.measureText(temp, character).width);
        tempNext = desc.slice(0, index + 1);
        tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
    }
    if (needTestLetter) {
        index = testLetter(desc, index);
    }
    return index;
}
function getWordStartEndIdx(string, index) {
    let startIdx = index;
    while ((regLetter.test(string[startIdx - 1]) && regLetter.test(string[startIdx])) ||
        regPunctuation.test(string[startIdx])) {
        startIdx--;
        if (startIdx <= 0) {
            break;
        }
    }
    let endIdx = index;
    while ((regLetter.test(string[endIdx + 1]) && regLetter.test(string[endIdx])) ||
        regPunctuation.test(string[endIdx])) {
        endIdx++;
        if (endIdx >= string.length) {
            break;
        }
    }
    endIdx = Math.min(endIdx + 1, string.length);
    return {
        startIdx,
        endIdx
    };
}
function testLetter(string, index, negativeWrongMatch = false) {
    let i = index;
    while ((regLetter.test(string[i - 1]) && regLetter.test(string[i])) ||
        regPunctuation.test(string[i])) {
        i--;
        if (i <= 0) {
            return negativeWrongMatch ? testLetter2(string, index) : index;
        }
    }
    return i;
}
function testLetter2(string, index) {
    let i = index;
    while ((regLetter.test(string[i + 1]) && regLetter.test(string[i])) ||
        regPunctuation.test(string[i])) {
        i++;
        if (i >= string.length) {
            return i;
        }
    }
    return i + 1;
}
function measureTextCanvas(text, character, mode = 'actual') {
    var _a;
    if (text === '') {
        return {
            ascent: 0,
            height: 0,
            descent: 0,
            width: 0
        };
    }
    const textMeasure = application.graphicUtil.textMeasure;
    const measurement = textMeasure.measureText(text, character);
    const result = {
        ascent: 0,
        height: 0,
        descent: 0,
        width: 0
    };
    const ascent = mode === 'actual' ? measurement.actualBoundingBoxAscent : measurement.fontBoundingBoxAscent;
    const descent = mode === 'actual' ? measurement.actualBoundingBoxDescent : measurement.fontBoundingBoxDescent;
    if (typeof ascent !== 'number' || typeof descent !== 'number') {
        result.width = Math.floor(measurement.width);
        result.height = character.fontSize || 0;
        result.ascent = result.height;
        result.descent = 0;
    }
    else {
        result.width = Math.floor(measurement.width);
        result.height = Math.floor(ascent + descent);
        result.ascent = Math.floor(ascent);
        result.descent = result.height - result.ascent;
    }
    const space = (_a = character.space) !== null && _a !== void 0 ? _a : 0;
    result.width += space;
    return result;
}

let ATextMeasure = class ATextMeasure {
    configure(service, env) {
        this.canvas = service.canvas;
        this.context = service.context;
        service.bindTextMeasure(this);
    }
    _measureTextWithoutAlignBaseline(text, options, compatible) {
        this.context.setTextStyleWithoutAlignBaseline(options);
        const metrics = this.context.measureText(text);
        return compatible ? this.compatibleMetrics(metrics, options) : metrics;
    }
    _measureTextWithAlignBaseline(text, options, compatible) {
        this.context.setTextStyle(options);
        const metrics = this.context.measureText(text);
        return compatible ? this.compatibleMetrics(metrics, options) : metrics;
    }
    compatibleMetrics(metrics, options) {
        if (metrics.actualBoundingBoxAscent == null ||
            metrics.actualBoundingBoxDescent == null ||
            metrics.fontBoundingBoxAscent == null ||
            metrics.fontBoundingBoxDescent == null) {
            metrics = {
                width: metrics.width
            };
            const { ascent, descent } = this.measureTextBoundADscentEstimate(options);
            metrics.actualBoundingBoxAscent = ascent;
            metrics.actualBoundingBoxDescent = descent;
            metrics.fontBoundingBoxAscent = ascent;
            metrics.fontBoundingBoxDescent = descent;
        }
        if (metrics.actualBoundingBoxLeft == null || metrics.actualBoundingBoxRight == null) {
            metrics = {
                width: metrics.width,
                actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
                actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
                fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
                fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
            };
            const { left, right } = this.measureTextBoundLeftRightEstimate(options);
            metrics.actualBoundingBoxLeft = left;
            metrics.actualBoundingBoxRight = right;
        }
        return metrics;
    }
    estimate(text, { fontSize = DefaultTextAttribute.fontSize }) {
        let eCharLen = 0;
        let cCharLen = 0;
        for (let i = 0; i < text.length; i++) {
            text.charCodeAt(i) < 128 ? eCharLen++ : cCharLen++;
        }
        return {
            width: ~~(0.8 * eCharLen * fontSize + cCharLen * fontSize),
            height: fontSize
        };
    }
    measureTextWidth(text, options, textMeasure) {
        if (!this.context) {
            return this.estimate(text, options).width;
        }
        textMeasure = textMeasure !== null && textMeasure !== void 0 ? textMeasure : this._measureTextWithoutAlignBaseline(text, options);
        return textMeasure.width;
    }
    measureTextBoundsWidth(text, options, textMeasure) {
        if (!this.context) {
            return this.estimate(text, options).width;
        }
        textMeasure = textMeasure !== null && textMeasure !== void 0 ? textMeasure : this._measureTextWithoutAlignBaseline(text, options);
        return textMeasure.width;
    }
    measureTextBoundsLeftRight(text, options, textMeasure) {
        if (!this.context) {
            return this.measureTextBoundLeftRightEstimate(options);
        }
        textMeasure = textMeasure !== null && textMeasure !== void 0 ? textMeasure : this._measureTextWithAlignBaseline(text, options, true);
        return {
            left: textMeasure.actualBoundingBoxLeft,
            right: textMeasure.actualBoundingBoxRight
        };
    }
    measureTextPixelHeight(text, options, textMeasure) {
        var _a;
        if (!this.context) {
            return (_a = options.fontSize) !== null && _a !== void 0 ? _a : DefaultTextStyle.fontSize;
        }
        textMeasure = textMeasure !== null && textMeasure !== void 0 ? textMeasure : this._measureTextWithoutAlignBaseline(text, options, true);
        return Math.abs(textMeasure.actualBoundingBoxAscent - textMeasure.actualBoundingBoxDescent);
    }
    measureTextPixelADscent(text, options, textMeasure) {
        if (!this.context) {
            return this.measureTextBoundADscentEstimate(options);
        }
        textMeasure = textMeasure !== null && textMeasure !== void 0 ? textMeasure : this._measureTextWithAlignBaseline(text, options, true);
        return {
            ascent: textMeasure.actualBoundingBoxAscent,
            descent: textMeasure.actualBoundingBoxDescent
        };
    }
    measureTextBoundHieght(text, options, textMeasure) {
        var _a;
        if (!this.context) {
            return (_a = options.fontSize) !== null && _a !== void 0 ? _a : DefaultTextStyle.fontSize;
        }
        textMeasure = textMeasure !== null && textMeasure !== void 0 ? textMeasure : this._measureTextWithoutAlignBaseline(text, options, true);
        return Math.abs(textMeasure.fontBoundingBoxAscent - textMeasure.fontBoundingBoxDescent);
    }
    measureTextBoundADscent(text, options, textMeasure) {
        if (!this.context) {
            return this.measureTextBoundADscentEstimate(options);
        }
        textMeasure = textMeasure !== null && textMeasure !== void 0 ? textMeasure : this._measureTextWithAlignBaseline(text, options, true);
        return {
            ascent: textMeasure.fontBoundingBoxAscent,
            descent: textMeasure.fontBoundingBoxDescent
        };
    }
    measureTextBoundADscentEstimate(options) {
        var _a;
        const fontSize = (_a = options.fontSize) !== null && _a !== void 0 ? _a : DefaultTextStyle.fontSize;
        return {
            ascent: 0.79 * fontSize,
            descent: 0.21 * fontSize
        };
    }
    measureTextBoundLeftRightEstimate(options) {
        var _a;
        const fontSize = (_a = options.fontSize) !== null && _a !== void 0 ? _a : DefaultTextStyle.fontSize;
        const { textAlign } = options;
        if (textAlign === 'center') {
            return {
                left: fontSize / 2,
                right: fontSize / 2
            };
        }
        else if (textAlign === 'right' || textAlign === 'end') {
            return {
                left: fontSize,
                right: 0
            };
        }
        return {
            left: 0,
            right: fontSize
        };
    }
    measureTextPixelADscentAndWidth(text, options, mode) {
        if (!this.context) {
            return Object.assign(Object.assign({}, this.measureTextBoundADscentEstimate(options)), { width: this.estimate(text, options).width });
        }
        const out = this._measureTextWithoutAlignBaseline(text, options, true);
        if (mode === MeasureModeEnum.actualBounding) {
            return {
                ascent: out.actualBoundingBoxAscent,
                descent: out.actualBoundingBoxDescent,
                width: out.width
            };
        }
        else if (mode === MeasureModeEnum.estimate) {
            return Object.assign(Object.assign({}, this.measureTextBoundADscentEstimate(options)), { width: out.width });
        }
        else if (mode === MeasureModeEnum.fontBounding) {
            let ascent = out.fontBoundingBoxAscent;
            let descent = out.fontBoundingBoxDescent;
            if (out.actualBoundingBoxDescent && descent < out.actualBoundingBoxDescent) {
                const delta = out.actualBoundingBoxDescent - descent;
                descent += delta;
                ascent -= delta;
            }
            else if (out.actualBoundingBoxAscent && ascent < out.actualBoundingBoxAscent) {
                const delta = out.actualBoundingBoxAscent - ascent;
                ascent += delta;
                descent -= delta;
            }
            return {
                ascent,
                descent,
                width: out.width
            };
        }
        return {
            ascent: out.actualBoundingBoxAscent,
            descent: out.actualBoundingBoxDescent,
            width: out.width
        };
    }
    measureText(text, options) {
        if (!this.context) {
            return this.estimate(text, options);
        }
        this.context.setTextStyleWithoutAlignBaseline(options);
        return this.context.measureText(text);
    }
    clipTextVertical(verticalList, options, width, wordBreak) {
        if (verticalList.length === 0) {
            return { verticalList, width: 0 };
        }
        const { fontSize = 12 } = options;
        verticalList.forEach(item => {
            item.width = item.direction === 0 ? fontSize : this.measureTextWidth(item.text, options);
        });
        const out = [];
        let length = 0;
        let i = 0;
        for (; i < verticalList.length; i++) {
            if (length + verticalList[i].width < width) {
                length += verticalList[i].width;
                out.push(verticalList[i]);
            }
            else {
                break;
            }
        }
        if (verticalList[i] && verticalList[i].text.length > 1) {
            const clipedData = this._clipText(verticalList[i].text, options, width - length, 0, verticalList[i].text.length - 1, 'end', false);
            if (wordBreak && clipedData.str !== verticalList[i].text) {
                let text = '';
                let length = 0;
                for (let j = 0; j < i; j++) {
                    const item = verticalList[j];
                    text += item.text;
                    length += item.text.length;
                }
                text += verticalList[i].text;
                const totalLength = length + clipedData.str.length;
                let index = testLetter(text, totalLength);
                index = index - length;
                if (index !== clipedData.str.length - 1) {
                    clipedData.str = clipedData.str.substring(0, index);
                    clipedData.width = this.measureTextWidth(clipedData.str, options);
                }
            }
            out.push(Object.assign(Object.assign({}, verticalList[i]), { text: clipedData.str, width: clipedData.width }));
            length += clipedData.width;
        }
        return {
            verticalList: out,
            width: length
        };
    }
    clipText(text, options, width, wordBreak, keepAllBreak) {
        if (text.length === 0) {
            return { str: '', width: 0 };
        }
        let length = this.measureTextWidth(text, options);
        if (length <= width) {
            return { str: text, width: length };
        }
        length = this.measureTextWidth(text[0], options);
        if (length > width) {
            return { str: '', width: 0 };
        }
        const data = this._clipText(text, options, width, 0, text.length - 1, 'end', false);
        if (wordBreak && data.str !== text) {
            let index = testLetter(text, data.str.length, keepAllBreak);
            if (index !== data.str.length) {
                if (index > data.str.length) {
                    data.wordBreaked = index;
                    index = data.str.length;
                }
                data.str = text.substring(0, index);
                data.width = this.measureTextWidth(data.str, options);
            }
        }
        return data;
    }
    _clipText(text, options, width, leftIdx, rightIdx, position, suffix) {
        let data;
        if (position === 'start') {
            data = this._clipTextStart(text, options, width, leftIdx, rightIdx);
            suffix && (data.result = suffix + data.str);
        }
        else if (position === 'middle') {
            const d = this._clipTextMiddle(text, options, width, '', '', 0, 0, 1);
            data = { str: 'none', width: d.width, result: d.left + suffix + d.right };
        }
        else {
            data = this._clipTextEnd(text, options, width, leftIdx, rightIdx);
            suffix && (data.result = data.str + suffix);
        }
        return data;
    }
    _clipTextEnd(text, options, width, leftIdx, rightIdx) {
        if (leftIdx === rightIdx) {
            Logger.getInstance().warn(`【_clipTextEnd】不应该走到这里${text}, ${leftIdx}, ${rightIdx}`);
            const subText = text.substring(0, rightIdx + 1);
            return { str: subText, width: this.measureTextWidth(subText, options) };
        }
        const middleIdx = Math.floor((leftIdx + rightIdx) / 2);
        const subText = text.substring(0, middleIdx + 1);
        const strWidth = this.measureTextWidth(subText, options);
        let length;
        if (strWidth > width) {
            if (subText.length <= 1) {
                return { str: '', width: 0 };
            }
            const str = text.substring(0, middleIdx);
            length = this.measureTextWidth(str, options);
            if (length <= width) {
                return { str, width: length };
            }
            return this._clipTextEnd(text, options, width, leftIdx, middleIdx);
        }
        else if (strWidth < width) {
            if (middleIdx >= text.length - 1) {
                return { str: text, width: this.measureTextWidth(text, options) };
            }
            const str = text.substring(0, middleIdx + 2);
            length = this.measureTextWidth(str, options);
            if (length >= width) {
                return { str: subText, width: strWidth };
            }
            return this._clipTextEnd(text, options, width, middleIdx, rightIdx);
        }
        return { str: subText, width: strWidth };
    }
    _clipTextStart(text, options, width, leftIdx, rightIdx) {
        const middleIdx = Math.ceil((leftIdx + rightIdx) / 2);
        const subText = text.substring(middleIdx - 1, text.length);
        const strWidth = this.measureTextWidth(subText, options);
        let length;
        if (strWidth > width) {
            if (subText.length <= 1) {
                return { str: '', width: 0 };
            }
            const str = text.substring(middleIdx, text.length);
            length = this.measureTextWidth(str, options);
            if (length <= width) {
                return { str, width: length };
            }
            return this._clipTextStart(text, options, width, middleIdx, text.length);
        }
        else if (strWidth < width) {
            if (middleIdx <= 0) {
                return { str: text, width: this.measureTextWidth(text, options) };
            }
            const str = text.substring(middleIdx - 2, text.length);
            length = this.measureTextWidth(str, options);
            if (length >= width) {
                return { str: subText, width: strWidth };
            }
            return this._clipTextStart(text, options, width, leftIdx, middleIdx);
        }
        return { str: subText, width: strWidth };
    }
    _clipTextMiddle(text, options, width, left, right, leftW, rightW, buffer) {
        const subLeftText = text.substring(0, buffer);
        const strLeftWidth = this.measureTextWidth(subLeftText, options);
        if (strLeftWidth + rightW > width) {
            return { left, right, width: leftW + rightW };
        }
        const subRightText = text.substring(text.length - buffer, text.length);
        const strRightWidth = this.measureTextWidth(subRightText, options);
        if (strLeftWidth + strRightWidth > width) {
            return { left: subLeftText, right, width: strLeftWidth + rightW };
        }
        return this._clipTextMiddle(text, options, width, subLeftText, subRightText, strLeftWidth, strRightWidth, buffer + 1);
    }
    clipTextWithSuffixVertical(verticalList, options, width, suffix, wordBreak, suffixPosition) {
        if (suffix === '') {
            return this.clipTextVertical(verticalList, options, width, wordBreak);
        }
        if (verticalList.length === 0) {
            return { verticalList, width: 0 };
        }
        const output = this.clipTextVertical(verticalList, options, width, wordBreak);
        if (output.verticalList.length === verticalList.length &&
            output.verticalList[output.verticalList.length - 1].width === verticalList[verticalList.length - 1].width) {
            return output;
        }
        const suffixWidth = this.measureTextWidth(suffix, options);
        if (suffixWidth > width) {
            return output;
        }
        width -= suffixWidth;
        let out;
        if (suffixPosition === 'start') {
            const nextVerticalList = this.revertVerticalList(verticalList);
            out = this.clipTextVertical(nextVerticalList, options, width, wordBreak);
            const v = this.revertVerticalList(out.verticalList);
            v.unshift({
                text: suffix,
                direction: 1,
                width: suffixWidth
            });
            out.verticalList = v;
        }
        else if (suffixPosition === 'middle') {
            const leftOut = this.clipTextVertical(verticalList, options, width / 2, wordBreak);
            const nextVerticalList = this.revertVerticalList(verticalList);
            const rightOut = this.clipTextVertical(nextVerticalList, options, width / 2, wordBreak);
            leftOut.verticalList.push({
                text: suffix,
                direction: 1,
                width: suffixWidth
            });
            this.revertVerticalList(rightOut.verticalList).forEach(v => leftOut.verticalList.push(v));
            out = {
                verticalList: leftOut.verticalList,
                width: leftOut.width + rightOut.width
            };
        }
        else {
            out = this.clipTextVertical(verticalList, options, width, wordBreak);
            out.verticalList.push({
                text: suffix,
                direction: 1,
                width: suffixWidth
            });
        }
        out.width += suffixWidth;
        return out;
    }
    revertVerticalList(verticalList) {
        return verticalList.reverse().map(l => {
            const t = l.text.split('').reverse().join('');
            return Object.assign(Object.assign({}, l), { text: t });
        });
    }
    clipTextWithSuffix(text, options, width, suffix, wordBreak, position, forceSuffix = false) {
        if (suffix === '') {
            return this.clipText(text, options, width, wordBreak);
        }
        if (text.length === 0) {
            return { str: '', width: 0 };
        }
        const length = this.measureTextWidth(text, options);
        if (!forceSuffix && length <= width) {
            return { str: text, width: length };
        }
        const suffixWidth = this.measureTextWidth(suffix, options);
        if (suffixWidth > width) {
            return { str: '', width: 0 };
        }
        if (forceSuffix && length + suffixWidth <= width) {
            return { str: text + suffix, width: length + suffixWidth };
        }
        width -= suffixWidth;
        const data = this._clipText(text, options, width, 0, text.length - 1, position, suffix);
        if (wordBreak && data.str !== text) {
            const index = testLetter(text, data.str.length);
            if (index !== data.str.length) {
                data.result = text.substring(0, index);
                data.width = this.measureTextWidth(data.str, options);
            }
        }
        else if (forceSuffix && data.str === text) {
            data.result = text + suffix;
        }
        data.str = data.result;
        data.width += suffixWidth;
        return data;
    }
};
ATextMeasure = __decorate([
    injectable()
], ATextMeasure);

const TextMeasureContribution = Symbol.for('TextMeasureContribution');
let DefaultTextMeasureContribution = class DefaultTextMeasureContribution extends ATextMeasure {
};
DefaultTextMeasureContribution = __decorate([
    injectable()
], DefaultTextMeasureContribution);

const container = new Container();

const CanvasFactory = Symbol.for('CanvasFactory');
const Context2dFactory = Symbol.for('Context2dFactory');

function wrapCanvas(params) {
    return container.getNamed(CanvasFactory, application.global.env)(params);
}
function wrapContext(canvas, dpr) {
    return container.getNamed(Context2dFactory, application.global.env)(canvas, dpr);
}
const EPSILON_NUMERIC = 1e-4;
const THREE_SQRT = Math.sqrt(3);
const ONE_THIRD = 1 / 3;
function isAroundZero(val) {
    return val > -EPSILON && val < EPSILON;
}
function isNotAroundZero(val) {
    return val > EPSILON || val < -EPSILON;
}
function isNumber(data) {
    return typeof data === 'number' && Number.isFinite(data);
}
const _v0 = [0, 0];
const _v1 = [0, 0];
const _v2 = [0, 0];
function distanceSquare(v1, v2) {
    return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
function quadraticAt(p0, p1, p2, t) {
    const onet = 1 - t;
    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
function cubicAt(p0, p1, p2, p3, t) {
    const onet = 1 - t;
    return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
function quadraticRootAt(p0, p1, p2, val, roots) {
    const a = p0 - 2 * p1 + p2;
    const b = 2 * (p1 - p0);
    const c = p0 - val;
    let n = 0;
    if (isAroundZero(a)) {
        if (isNotAroundZero(b)) {
            const t1 = -c / b;
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
    }
    else {
        const disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
            const t1 = -b / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
        else if (disc > 0) {
            const discSqrt = Math.sqrt(disc);
            const t1 = (-b + discSqrt) / (2 * a);
            const t2 = (-b - discSqrt) / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                roots[n++] = t2;
            }
        }
    }
    return n;
}
function quadraticExtremum(p0, p1, p2) {
    const divider = p0 + p2 - 2 * p1;
    if (divider === 0) {
        return 0.5;
    }
    return (p0 - p1) / divider;
}
function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
    let t = 0;
    let interval = 0.005;
    let d = Infinity;
    _v0[0] = x;
    _v0[1] = y;
    for (let _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = quadraticAt(x0, x1, x2, _t);
        _v1[1] = quadraticAt(y0, y1, y2, _t);
        const d1 = distanceSquare(_v0, _v1);
        if (d1 < d) {
            t = _t;
            d = d1;
        }
    }
    d = Infinity;
    for (let i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
            break;
        }
        const prev = t - interval;
        const next = t + interval;
        _v1[0] = quadraticAt(x0, x1, x2, prev);
        _v1[1] = quadraticAt(y0, y1, y2, prev);
        const d1 = distanceSquare(_v1, _v0);
        if (prev >= 0 && d1 < d) {
            t = prev;
            d = d1;
        }
        else {
            _v2[0] = quadraticAt(x0, x1, x2, next);
            _v2[1] = quadraticAt(y0, y1, y2, next);
            const d2 = distanceSquare(_v2, _v0);
            if (next <= 1 && d2 < d) {
                t = next;
                d = d2;
            }
            else {
                interval *= 0.5;
            }
        }
    }
    if (out) {
        out[0] = quadraticAt(x0, x1, x2, t);
        out[1] = quadraticAt(y0, y1, y2, t);
    }
    return Math.sqrt(d);
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
    let t = 0;
    let interval = 0.005;
    let d = Infinity;
    let prev;
    let next;
    let d1;
    let d2;
    _v0[0] = x;
    _v0[1] = y;
    for (let _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = cubicAt(x0, x1, x2, x3, _t);
        _v1[1] = cubicAt(y0, y1, y2, y3, _t);
        d1 = distanceSquare(_v0, _v1);
        if (d1 < d) {
            t = _t;
            d = d1;
        }
    }
    d = Infinity;
    for (let i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
            break;
        }
        prev = t - interval;
        next = t + interval;
        _v1[0] = cubicAt(x0, x1, x2, x3, prev);
        _v1[1] = cubicAt(y0, y1, y2, y3, prev);
        d1 = distanceSquare(_v1, _v0);
        if (prev >= 0 && d1 < d) {
            t = prev;
            d = d1;
        }
        else {
            _v2[0] = cubicAt(x0, x1, x2, x3, next);
            _v2[1] = cubicAt(y0, y1, y2, y3, next);
            d2 = distanceSquare(_v2, _v0);
            if (next <= 1 && d2 < d) {
                t = next;
                d = d2;
            }
            else {
                interval *= 0.5;
            }
        }
    }
    if (out) {
        out[0] = cubicAt(x0, x1, x2, x3, t);
        out[1] = cubicAt(y0, y1, y2, y3, t);
    }
    return Math.sqrt(d);
}
function normalizeRadian(angle) {
    angle %= pi2;
    if (angle < 0) {
        angle += pi2;
    }
    return angle;
}
function containQuadStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    const _l = lineWidth;
    if ((y > y0 + _l && y > y1 + _l && y > y2 + _l) ||
        (y < y0 - _l && y < y1 - _l && y < y2 - _l) ||
        (x > x0 + _l && x > x1 + _l && x > x2 + _l) ||
        (x < x0 - _l && x < x1 - _l && x < x2 - _l)) {
        return false;
    }
    const d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
    return d <= _l / 2;
}
function containCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    const _l = lineWidth;
    if ((y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l) ||
        (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l) ||
        (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l) ||
        (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)) {
        return false;
    }
    const d = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
    return d <= _l / 2;
}
function containArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    const _l = lineWidth;
    x -= cx;
    y -= cy;
    const d = Math.sqrt(x * x + y * y);
    if (d - _l > r || d + _l < r) {
        return false;
    }
    if (Math.abs(startAngle - endAngle) % pi2 < 1e-4) {
        return true;
    }
    if (anticlockwise) {
        const tmp = startAngle;
        startAngle = normalizeRadian(endAngle);
        endAngle = normalizeRadian(tmp);
    }
    else {
        startAngle = normalizeRadian(startAngle);
        endAngle = normalizeRadian(endAngle);
    }
    if (startAngle > endAngle) {
        endAngle += pi2;
    }
    let angle = Math.atan2(y, x);
    if (angle < 0) {
        angle += pi2;
    }
    return (angle >= startAngle && angle <= endAngle) || (angle + pi2 >= startAngle && angle + pi2 <= endAngle);
}
function containLineStroke(x0, y0, x1, y1, lineWidth, x, y) {
    if (lineWidth === 0) {
        return false;
    }
    const _l = lineWidth;
    const _halfL = lineWidth / 2;
    let _a = 0;
    let _b = x0;
    if ((y > y0 + _halfL && y > y1 + _halfL) ||
        (y < y0 - _halfL && y < y1 - _halfL) ||
        (x > x0 + _halfL && x > x1 + _halfL) ||
        (x < x0 - _halfL && x < x1 - _halfL)) {
        return false;
    }
    if (x0 !== x1) {
        _a = (y0 - y1) / (x0 - x1);
        _b = (x0 * y1 - x1 * y0) / (x0 - x1);
    }
    else {
        return Math.abs(x - x0) <= _l / 2;
    }
    const tmp = _a * x - y + _b;
    const _s = (tmp * tmp) / (_a * _a + 1);
    return _s <= ((_l / 2) * _l) / 2;
}
const EPSILON = 1e-4;
function cubicRootAt(p0, p1, p2, p3, val, roots) {
    const a = p3 + 3 * (p1 - p2) - p0;
    const b = 3 * (p2 - p1 * 2 + p0);
    const c = 3 * (p1 - p0);
    const d = p0 - val;
    const A = b * b - 3 * a * c;
    const B = b * c - 9 * a * d;
    const C = c * c - 3 * b * d;
    let n = 0;
    if (isAroundZero(A) && isAroundZero(B)) {
        if (isAroundZero(b)) {
            roots[0] = 0;
        }
        else {
            const t1 = -c / b;
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
    }
    else {
        const disc = B * B - 4 * A * C;
        if (isAroundZero(disc)) {
            const K = B / A;
            const t1 = -b / a + K;
            const t2 = -K / 2;
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                roots[n++] = t2;
            }
        }
        else if (disc > 0) {
            const discSqrt = Math.sqrt(disc);
            let Y1 = A * b + 1.5 * a * (-B + discSqrt);
            let Y2 = A * b + 1.5 * a * (-B - discSqrt);
            if (Y1 < 0) {
                Y1 = -Math.pow(-Y1, ONE_THIRD);
            }
            else {
                Y1 = Math.pow(Y1, ONE_THIRD);
            }
            if (Y2 < 0) {
                Y2 = -Math.pow(-Y2, ONE_THIRD);
            }
            else {
                Y2 = Math.pow(Y2, ONE_THIRD);
            }
            const t1 = (-b - (Y1 + Y2)) / (3 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
        }
        else {
            const T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A));
            const theta = Math.acos(T) / 3;
            const ASqrt = Math.sqrt(A);
            const tmp = Math.cos(theta);
            const t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
            const t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
            const t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
            if (t1 >= 0 && t1 <= 1) {
                roots[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                roots[n++] = t2;
            }
            if (t3 >= 0 && t3 <= 1) {
                roots[n++] = t3;
            }
        }
    }
    return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema) {
    const b = 6 * p2 - 12 * p1 + 6 * p0;
    const a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
    const c = 3 * p1 - 3 * p0;
    let n = 0;
    if (isAroundZero(a)) {
        if (isNotAroundZero(b)) {
            const t1 = -c / b;
            if (t1 >= 0 && t1 <= 1) {
                extrema[n++] = t1;
            }
        }
    }
    else {
        const disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
            extrema[0] = -b / (2 * a);
        }
        else if (disc > 0) {
            const discSqrt = Math.sqrt(disc);
            const t1 = (-b + discSqrt) / (2 * a);
            const t2 = (-b - discSqrt) / (2 * a);
            if (t1 >= 0 && t1 <= 1) {
                extrema[n++] = t1;
            }
            if (t2 >= 0 && t2 <= 1) {
                extrema[n++] = t2;
            }
        }
    }
    return n;
}
function isAroundEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
}
const roots = [-1, -1, -1];
const extrema = [-1, -1];
function swapExtrema() {
    const tmp = extrema[0];
    extrema[0] = extrema[1];
    extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
    if ((y > y0 && y > y1 && y > y2 && y > y3) || (y < y0 && y < y1 && y < y2 && y < y3)) {
        return 0;
    }
    const nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
    if (nRoots === 0) {
        return 0;
    }
    let w = 0;
    let nExtrema = -1;
    let y0_ = 0;
    let y1_ = 0;
    for (let i = 0; i < nRoots; i++) {
        const t = roots[i];
        const unit = t === 0 || t === 1 ? 0.5 : 1;
        const x_ = cubicAt(x0, x1, x2, x3, t);
        if (x_ < x) {
            continue;
        }
        if (nExtrema < 0) {
            nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);
            if (extrema[1] < extrema[0] && nExtrema > 1) {
                swapExtrema();
            }
            y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);
            if (nExtrema > 1) {
                y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
            }
        }
        if (nExtrema === 2) {
            if (t < extrema[0]) {
                w += y0_ < y0 ? unit : -unit;
            }
            else if (t < extrema[1]) {
                w += y1_ < y0_ ? unit : -unit;
            }
            else {
                w += y3 < y1_ ? unit : -unit;
            }
        }
        else {
            if (t < extrema[0]) {
                w += y0_ < y0 ? unit : -unit;
            }
            else {
                w += y3 < y0_ ? unit : -unit;
            }
        }
    }
    return w;
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
    if ((y > y0 && y > y1 && y > y2) || (y < y0 && y < y1 && y < y2)) {
        return 0;
    }
    const nRoots = quadraticRootAt(y0, y1, y2, y, roots);
    if (nRoots === 0) {
        return 0;
    }
    const t = quadraticExtremum(y0, y1, y2);
    if (t >= 0 && t <= 1) {
        let w = 0;
        const y_ = quadraticAt(y0, y1, y2, t);
        for (let i = 0; i < nRoots; i++) {
            const unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
            const x_ = quadraticAt(x0, x1, x2, roots[i]);
            if (x_ < x) {
                continue;
            }
            if (roots[i] < t) {
                w += y_ < y0 ? unit : -unit;
            }
            else {
                w += y2 < y_ ? unit : -unit;
            }
        }
        return w;
    }
    const unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
    const x_ = quadraticAt(x0, x1, x2, roots[0]);
    if (x_ < x) {
        return 0;
    }
    return y2 < y0 ? unit : -unit;
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
    y -= cy;
    if (y > r || y < -r) {
        return 0;
    }
    const tmp = Math.sqrt(r * r - y * y);
    roots[0] = -tmp;
    roots[1] = tmp;
    const dTheta = Math.abs(startAngle - endAngle);
    if (dTheta < 1e-4) {
        return 0;
    }
    if (dTheta >= pi2 - 1e-4) {
        startAngle = 0;
        endAngle = pi2;
        const dir = anticlockwise ? 1 : -1;
        if (x >= roots[0] + cx && x <= roots[1] + cx) {
            return dir;
        }
        return 0;
    }
    if (startAngle > endAngle) {
        const tmp = startAngle;
        startAngle = endAngle;
        endAngle = tmp;
    }
    if (startAngle < 0) {
        startAngle += pi2;
        endAngle += pi2;
    }
    let w = 0;
    for (let i = 0; i < 2; i++) {
        const x_ = roots[i];
        if (x_ + cx > x) {
            let angle = Math.atan2(y, x_);
            let dir = anticlockwise ? 1 : -1;
            if (angle < 0) {
                angle = pi2 + angle;
            }
            if ((angle >= startAngle && angle <= endAngle) || (angle + pi2 >= startAngle && angle + pi2 <= endAngle)) {
                if (angle > pi / 2 && angle < pi * 1.5) {
                    dir = -dir;
                }
                w += dir;
            }
        }
    }
    return w;
}
function modpi2(radian) {
    const n = Math.round((radian / pi) * 1e8) / 1e8;
    return (n % 2) * pi;
}
function normalizeArcAngles(angles, anticlockwise) {
    let newStartAngle = modpi2(angles[0]);
    if (newStartAngle < 0) {
        newStartAngle += pi2;
    }
    const delta = newStartAngle - angles[0];
    let newEndAngle = angles[1];
    newEndAngle += delta;
    if (!anticlockwise && newEndAngle - newStartAngle >= pi2) {
        newEndAngle = newStartAngle + pi2;
    }
    else if (anticlockwise && newStartAngle - newEndAngle >= pi2) {
        newEndAngle = newStartAngle - pi2;
    }
    else if (!anticlockwise && newStartAngle > newEndAngle) {
        newEndAngle = newStartAngle + (pi2 - modpi2(newStartAngle - newEndAngle));
    }
    else if (anticlockwise && newStartAngle < newEndAngle) {
        newEndAngle = newStartAngle - (pi2 - modpi2(newEndAngle - newStartAngle));
    }
    angles[0] = newStartAngle;
    angles[1] = newEndAngle;
}
const tmpAngles = [0, 0];
function containPath(commands, lineWidth, isStroke, x, y) {
    const data = commands;
    const len = commands.length;
    let w = 0;
    let xi = 0;
    let yi = 0;
    let x0 = 0;
    let y0 = 0;
    let x1;
    let y1;
    for (let i = 0; i < len; i++) {
        const command = data[i];
        const isFirst = i === 0;
        if (command[0] === enumCommandMap.M && i > 1) {
            if (!isStroke) {
                w += isPointInLine(xi, yi, x0, y0, x, y);
            }
        }
        if (isFirst) {
            xi = command[1];
            yi = command[2];
            x0 = xi;
            y0 = yi;
        }
        const c0 = command[0];
        const c1 = command[1];
        const c2 = command[2];
        const c3 = command[3];
        const c4 = command[4];
        const c5 = command[5];
        const c6 = command[6];
        let startAngle = c4;
        let endAngle = c5;
        tmpAngles[0] = startAngle;
        tmpAngles[1] = endAngle;
        normalizeArcAngles(tmpAngles, Boolean(command[6]));
        startAngle = tmpAngles[0];
        endAngle = tmpAngles[1];
        const theta = startAngle;
        const dTheta = endAngle - startAngle;
        const anticlockwise = !!(1 - (command[6] ? 0 : 1));
        const _x = ((x - c1) * c3) / c3 + c1;
        switch (c0) {
            case enumCommandMap.M:
                x0 = c1;
                y0 = c2;
                xi = x0;
                yi = y0;
                break;
            case enumCommandMap.L:
                if (isStroke) {
                    if (containLineStroke(xi, yi, c1, c2, lineWidth, x, y)) {
                        return true;
                    }
                }
                else {
                    w += isPointInLine(xi, yi, c1, c2, x, y) || 0;
                }
                xi = c1;
                yi = c2;
                break;
            case enumCommandMap.C:
                if (isStroke) {
                    if (containCubicStroke(xi, yi, c1, c2, c3, c4, c5, c6, lineWidth, x, y)) {
                        return true;
                    }
                }
                else {
                    w += windingCubic(xi, yi, c1, c2, c3, c4, c5, c6, x, y) || 0;
                }
                xi = c5;
                yi = c6;
                break;
            case enumCommandMap.Q:
                if (isStroke) {
                    if (containQuadStroke(xi, yi, c1, c2, c3, c4, lineWidth, x, y)) {
                        return true;
                    }
                }
                else {
                    w += windingQuadratic(xi, yi, c1, c2, c3, c4, x, y) || 0;
                }
                xi = c3;
                yi = c4;
                break;
            case enumCommandMap.A:
                x1 = Math.cos(theta) * c3 + c1;
                y1 = Math.sin(theta) * c3 + c2;
                if (!isFirst) {
                    w += isPointInLine(xi, yi, x1, y1, x, y);
                }
                else {
                    x0 = x1;
                    y0 = y1;
                }
                if (isStroke) {
                    if (containArcStroke(c1, c2, c3, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
                        return true;
                    }
                }
                else {
                    w += windingArc(c1, c2, c3, theta, theta + dTheta, anticlockwise, _x, y);
                }
                xi = Math.cos(theta + dTheta) * c3 + c1;
                yi = Math.sin(theta + dTheta) * c3 + c2;
                break;
            case enumCommandMap.R:
                x0 = xi = c1;
                y0 = yi = c2;
                x1 = x0 + c3;
                y1 = y0 + c4;
                if (isStroke) {
                    if (containLineStroke(x0, y0, x1, y0, lineWidth, x, y) ||
                        containLineStroke(x1, y0, x1, y1, lineWidth, x, y) ||
                        containLineStroke(x1, y1, x0, y1, lineWidth, x, y) ||
                        containLineStroke(x0, y1, x0, y0, lineWidth, x, y)) {
                        return true;
                    }
                }
                else {
                    w += isPointInLine(x1, y0, x1, y1, x, y);
                    w += isPointInLine(x0, y1, x0, y0, x, y);
                }
                break;
            case enumCommandMap.Z:
                if (isStroke) {
                    if (containLineStroke(xi, yi, x0, y0, lineWidth, x, y)) {
                        return true;
                    }
                }
                else {
                    w += isPointInLine(xi, yi, x0, y0, x, y);
                }
                xi = x0;
                yi = y0;
                break;
        }
    }
    if (!isStroke && !isAroundEqual(yi, y0)) {
        w += isPointInLine(xi, yi, x0, y0, x, y) || 0;
    }
    return w !== 0;
}
function contain(commands, x, y) {
    return containPath(commands, 0, false, x, y);
}
function containStroke(commands, lineWidth, x, y) {
    return containPath(commands, lineWidth, true, x, y);
}

class DefaultCanvasAllocate {
    constructor() {
        this.pools = [];
        this.allocatedCanvas = [];
    }
    shareCanvas() {
        if (this.allocatedCanvas.length) {
            return this.allocatedCanvas[0];
        }
        return this.getCommonCanvas();
    }
    getCommonCanvas() {
        if (!this._commonCanvas) {
            this._commonCanvas = this.allocate({ width: 100, height: 100, dpr: 2 });
        }
        return this._commonCanvas;
    }
    allocate(data) {
        if (!this.pools.length) {
            const c = wrapCanvas(Object.assign({ nativeCanvas: application.global.createCanvas(data) }, data));
            this.allocatedCanvas.push(c);
            return c;
        }
        const m = this.pools.pop();
        m.resize(data.width, data.height);
        m.dpr = data.dpr;
        return m;
    }
    allocateByObj(canvas) {
        if (!this.pools.length) {
            const data = {
                width: canvas.width / canvas.dpr,
                height: canvas.height / canvas.dpr,
                dpr: canvas.dpr
            };
            const c = wrapCanvas(Object.assign({ nativeCanvas: application.global.createCanvas(data) }, data));
            this.allocatedCanvas.push(c);
            return c;
        }
        const m = this.pools.pop();
        m.width = canvas.width;
        m.height = canvas.height;
        return m;
    }
    free(d) {
        this.pools.push(d);
    }
    get length() {
        return this.pools.length;
    }
    release(...params) {
        this.pools = [];
    }
}
const canvasAllocate = new DefaultCanvasAllocate();

const VWindow = Symbol.for('VWindow');
const WindowHandlerContribution = Symbol.for('WindowHandlerContribution');
let DefaultWindow = class DefaultWindow extends EventListenerManager {
    get width() {
        if (this._handler) {
            const wh = this._handler.getWH();
            return (this._width = wh.width);
        }
        return this._width;
    }
    get height() {
        if (this._handler) {
            const wh = this._handler.getWH();
            return (this._height = wh.height);
        }
        return this._height;
    }
    get dpr() {
        return this._handler.getDpr();
    }
    constructor() {
        super();
        this.hooks = {
            onChange: new SyncHook(['x', 'y', 'width', 'height'])
        };
        this.active = () => {
            const global = this.global;
            if (!global.env || this.actived) {
                return;
            }
            const handler = container.getNamed(WindowHandlerContribution, global.env);
            handler.configure(this, global);
            this.actived = true;
        };
        this._uid = Generator.GenAutoIncrementId();
        this.global = application.global;
        this.postInit();
    }
    _nativeAddEventListener(type, listener, options) {
        return this._handler.addEventListener(type, listener, options);
    }
    _nativeRemoveEventListener(type, listener, options) {
        return this._handler.removeEventListener(type, listener, options);
    }
    _nativeDispatchEvent(event) {
        return this._handler.dispatchEvent(event);
    }
    postInit() {
        this.global.hooks.onSetEnv.tap('window', this.active);
        this.active();
    }
    get style() {
        var _a;
        return (_a = this._handler.getStyle()) !== null && _a !== void 0 ? _a : {};
    }
    set style(style) {
        this._handler.setStyle(style);
    }
    create(params) {
        var _a, _b;
        this._handler.createWindow(params);
        const windowWH = this._handler.getWH();
        this._width = windowWH.width;
        this._height = windowWH.height;
        if (params.viewBox) {
            this.setViewBox(params.viewBox);
        }
        else {
            if (params.canvasControled !== false) {
                this.setViewBox({ x1: 0, y1: 0, x2: this._width, y2: this._height });
            }
            else {
                this.setViewBox({ x1: 0, y1: 0, x2: (_a = params.width) !== null && _a !== void 0 ? _a : this._width, y2: (_b = params.height) !== null && _b !== void 0 ? _b : this._height });
            }
        }
        this.title = this._handler.getTitle();
        this.resizable = true;
    }
    setWindowHandler(handler) {
        this._handler = handler;
    }
    setDpr(dpr) {
        return this._handler.setDpr(dpr);
    }
    resize(w, h) {
        return this._handler.resizeWindow(w, h);
    }
    configure() {
        throw new Error('暂不支持');
    }
    release() {
        this.global.hooks.onSetEnv.unTap('window', this.active);
        this.clearAllEventListeners();
        return this._handler.releaseWindow();
    }
    getContext() {
        return this._handler.getContext();
    }
    getNativeHandler() {
        return this._handler.getNativeHandler();
    }
    getImageBuffer(type) {
        if (!this._handler.getImageBuffer) {
            return null;
        }
        return this._handler.getImageBuffer(type);
    }
    getBoundingClientRect() {
        return this._handler.getBoundingClientRect();
    }
    getContainer() {
        return this._handler.container;
    }
    clearViewBox(color) {
        this._handler.clearViewBox(color);
    }
    setViewBox(viewBox) {
        this._handler.setViewBox(viewBox);
    }
    setViewBoxTransform(a, b, c, d, e, f) {
        this._handler.setViewBoxTransform(a, b, c, d, e, f);
    }
    getViewBox() {
        return this._handler.getViewBox();
    }
    getViewBoxTransform() {
        return this._handler.getViewBoxTransform();
    }
    pointTransform(x, y) {
        const vb = this._handler.getViewBox();
        const m = this._handler.getViewBoxTransform();
        const nextP = { x, y };
        m.transformPoint({ x, y }, nextP);
        nextP.x -= vb.x1;
        nextP.y -= vb.y1;
        return nextP;
    }
    hasSubView() {
        const viewBox = this._handler.getViewBox();
        return !(viewBox.x1 === 0 &&
            viewBox.y1 === 0 &&
            isNumberClose(this.width, viewBox.width()) &&
            isNumberClose(this.height, viewBox.height()));
    }
    isVisible(bbox) {
        return this._handler.isVisible(bbox);
    }
    onVisibleChange(cb) {
        return this._handler.onVisibleChange(cb);
    }
    getTopLeft(baseWindow) {
        return this._handler.getTopLeft(baseWindow);
    }
};
DefaultWindow = __decorate([
    injectable(),
    __metadata("design:paramtypes", [])
], DefaultWindow);

let DefaultGraphicUtil = class DefaultGraphicUtil {
    get canvas() {
        this.tryInitCanvas();
        return this._canvas;
    }
    get context() {
        this.tryInitCanvas();
        return this._context;
    }
    constructor(contributions) {
        this.contributions = contributions;
        this.configured = false;
        this.global = application.global;
        this.global.hooks.onSetEnv.tap('graphic-util', (lastEnv, env, global) => {
            this.configured = false;
            this.configure(global, env);
        });
    }
    get textMeasure() {
        if (!this._textMeasure) {
            this.configure(this.global, this.global.env);
        }
        return this._textMeasure;
    }
    configure(global, env) {
        if (this.configured) {
            return;
        }
        this.contributions.getContributions().forEach(contribution => {
            contribution.configure(this, env);
        });
        this.configured = true;
    }
    tryInitCanvas() {
        if (!this._canvas) {
            const canvas = canvasAllocate.shareCanvas();
            this._canvas = canvas;
            this._context = canvas.getContext('2d');
        }
    }
    bindTextMeasure(tm) {
        this._textMeasure = tm;
    }
    measureText(text, tc, method = 'native') {
        var _a;
        this.configure(this.global, this.global.env);
        const m = this.global.measureTextMethod;
        this.global.measureTextMethod = method;
        const data = {
            width: this._textMeasure.measureTextWidth(text, tc),
            height: (_a = tc.fontSize) !== null && _a !== void 0 ? _a : DefaultTextStyle.fontSize
        };
        this.global.measureTextMethod = m;
        return data;
    }
    createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {
        this.configure(this.global, this.global.env);
        return new TextMeasure(Object.assign({ defaultFontParams: {
                fontFamily: DefaultTextStyle.fontFamily,
                fontSize: DefaultTextStyle.fontSize
            }, getCanvasForMeasure: getCanvasForMeasure || (() => this.canvas), getTextBounds: undefined, specialCharSet: '-/: .,@%\'"~' + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase() }, (option !== null && option !== void 0 ? option : {})), textSpec);
    }
    drawGraphicToCanvas(graphic, stage, canvas) {
        if (!stage.defaultLayer) {
            return null;
        }
        const window = container.get(VWindow);
        const bounds = graphic.AABBBounds;
        const width = bounds.width();
        const height = bounds.height();
        const x1 = -bounds.x1;
        const y1 = -bounds.y1;
        window.create({
            viewBox: { x1, y1, x2: bounds.x2, y2: bounds.y2 },
            width,
            height,
            canvas,
            dpr: stage.window.dpr,
            canvasControled: true,
            offscreen: true,
            title: ''
        });
        const disableCheckGraphicWidthOutRange = stage.params.optimize.disableCheckGraphicWidthOutRange;
        stage.params.optimize.disableCheckGraphicWidthOutRange = true;
        stage.defaultLayer.getNativeHandler().drawTo(window, [graphic], {
            transMatrix: window.getViewBoxTransform(),
            viewBox: window.getViewBox(),
            stage,
            layer: stage.defaultLayer,
            renderService: stage.renderService,
            background: 'transparent',
            clear: true,
            updateBounds: false
        });
        stage.params.optimize.disableCheckGraphicWidthOutRange = disableCheckGraphicWidthOutRange;
        const c = window.getNativeHandler();
        if (c.nativeCanvas) {
            return c.nativeCanvas;
        }
        return null;
    }
};
DefaultGraphicUtil = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(TextMeasureContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultGraphicUtil);
var TransformMode;
(function (TransformMode) {
    TransformMode[TransformMode["transform"] = 0] = "transform";
    TransformMode[TransformMode["matrix"] = 1] = "matrix";
})(TransformMode || (TransformMode = {}));
const _matrix = new Matrix();
let DefaultTransformUtil = class DefaultTransformUtil {
    constructor() {
        this.matrix = new Matrix();
    }
    init(origin) {
        this.mode = TransformMode.transform;
        this.originTransform = origin;
        this.matrix.reset();
        return this;
    }
    fromMatrix(source, target) {
        this.mode = TransformMode.matrix;
        this.outSourceMatrix = source;
        this.outTargetMatrix = target;
        return this;
    }
    scaleMatrix(sx, sy, center) {
        const sMatrix = this.outSourceMatrix;
        _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f);
        this.outTargetMatrix.reset();
        if (center) {
            const { x, y } = center;
            this.outTargetMatrix.translate(x, y);
            this.outTargetMatrix.scale(sx, sy);
            this.outTargetMatrix.translate(-x, -y);
        }
        else {
            this.outTargetMatrix.scale(sx, sy);
        }
        this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f);
        return this;
    }
    rotateMatrix(angle, center) {
        const sMatrix = this.outSourceMatrix;
        _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f);
        this.outTargetMatrix.reset();
        if (center) {
            const { x, y } = center;
            this.outTargetMatrix.translate(x, y);
            this.outTargetMatrix.rotate(angle);
            this.outTargetMatrix.translate(-x, -y);
        }
        else {
            this.outTargetMatrix.rotate(angle);
        }
        this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f);
        return this;
    }
    scale(sx, sy, center) {
        if (this.mode === TransformMode.matrix) {
            return this.scaleMatrix(sx, sy, center);
        }
        return this;
    }
    rotate(angle, center) {
        if (this.mode === TransformMode.matrix) {
            return this.rotateMatrix(angle, center);
        }
        return this;
    }
    translateMatrix(dx, dy) {
        const sMatrix = this.outSourceMatrix;
        _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f);
        this.outTargetMatrix.reset();
        this.outTargetMatrix.translate(dx, dy);
        this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f);
        return this;
    }
    translate(dx, dy) {
        if (this.mode === TransformMode.matrix) {
            return this.translateMatrix(dx, dy);
        }
        return this;
    }
    simplify(target) {
        if (this.mode === TransformMode.matrix) {
            return this.simplifyMatrix(target);
        }
        return this;
    }
    simplifyMatrix(target) {
        return this;
    }
};
DefaultTransformUtil = __decorate([
    injectable(),
    __metadata("design:paramtypes", [])
], DefaultTransformUtil);

const defaultThemeObj = {
    arc: DefaultArcAttribute,
    area: DefaultAreaAttribute,
    circle: DefaultCircleAttribute,
    line: DefaultLineAttribute,
    path: DefaultPathAttribute,
    symbol: DefaultSymbolAttribute,
    text: DefaultTextAttribute,
    rect: DefaultRectAttribute,
    polygon: DefaultPolygonAttribute,
    star: DefaultStarAttribute,
    richtext: DefaultRichTextAttribute,
    richtextIcon: DefaultRichTextIconAttribute,
    image: DefaultImageAttribute,
    group: DefaultGroupAttribute,
    glyph: DefaultGlyphAttribute
};
const themeKeys = Object.keys(defaultThemeObj);
function newThemeObj() {
    return {
        arc: Object.assign({}, defaultThemeObj.arc),
        area: Object.assign({}, defaultThemeObj.area),
        circle: Object.assign({}, defaultThemeObj.circle),
        line: Object.assign({}, defaultThemeObj.line),
        path: Object.assign({}, defaultThemeObj.path),
        symbol: Object.assign({}, defaultThemeObj.symbol),
        text: Object.assign({}, defaultThemeObj.text),
        rect: Object.assign({}, defaultThemeObj.rect),
        polygon: Object.assign({}, defaultThemeObj.polygon),
        star: Object.assign({}, defaultThemeObj.star),
        richtext: Object.assign({}, defaultThemeObj.richtext),
        richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
        image: Object.assign({}, defaultThemeObj.image),
        group: Object.assign({}, defaultThemeObj.group),
        glyph: Object.assign({}, defaultThemeObj.glyph)
    };
}
function combine(out, t) {
    Object.keys(t).forEach(k => {
        out[k] = t[k];
    });
}
const globalThemeObj = newThemeObj();
class Theme {
    constructor() {
        this.initTheme();
        this.dirty = false;
    }
    initTheme() {
        this._defaultTheme = {};
        themeKeys.forEach(key => {
            this._defaultTheme[key] = Object.create(globalThemeObj[key]);
        });
        this.combinedTheme = this._defaultTheme;
    }
    getTheme(group) {
        if (!group) {
            return this.combinedTheme;
        }
        if (!this.dirty) {
            return this.combinedTheme;
        }
        let parentTheme = {};
        const parentGroup = this.getParentWithTheme(group);
        if (parentGroup) {
            parentTheme = parentGroup.theme;
        }
        this.applyTheme(group, parentTheme);
        return this.combinedTheme;
    }
    getParentWithTheme(group) {
        while (group.parent) {
            group = group.parent;
            if (group.theme) {
                return group;
            }
        }
        return null;
    }
    applyTheme(group, pt, force = false) {
        if (this.dirty) {
            const parentGroup = this.getParentWithTheme(group);
            if (parentGroup) {
                const parentTheme = parentGroup.theme;
                if (parentTheme.dirty || force) {
                    parentTheme.applyTheme(parentGroup, pt, true);
                }
            }
            if (!this.userTheme) {
                if (parentGroup) {
                    this.combinedTheme = parentGroup.theme.combinedTheme;
                }
                else {
                    this.combinedTheme = this._defaultTheme;
                    Logger.getInstance().warn('未知错误，走到不应该走的区域里');
                }
                this.dirty = false;
            }
            else {
                this.doCombine(parentGroup && parentGroup.theme.combinedTheme);
            }
        }
        return this.combinedTheme;
    }
    doCombine(parentCombinedTheme) {
        const userTheme = this.userTheme;
        const combinedTheme = this.combinedTheme;
        themeKeys.forEach(k => {
            const obj = Object.create(globalThemeObj[k]);
            if (parentCombinedTheme && parentCombinedTheme[k]) {
                combine(obj, parentCombinedTheme[k]);
            }
            if (combinedTheme[k]) {
                combine(obj, combinedTheme[k]);
            }
            if (userTheme[k]) {
                combine(obj, userTheme[k]);
            }
            this.combinedTheme[k] = obj;
        });
        if (userTheme.common) {
            themeKeys.forEach(k => {
                combine(this.combinedTheme[k], userTheme.common);
            });
        }
        this.dirty = false;
    }
    setTheme(t, g) {
        let userTheme = this.userTheme;
        if (userTheme) {
            Object.keys(t).forEach(k => {
                if (userTheme[k]) {
                    Object.assign(userTheme[k], t[k]);
                }
                else {
                    userTheme[k] = Object.assign({}, t[k]);
                }
            });
        }
        else {
            userTheme = t;
        }
        this.userTheme = userTheme;
        this.dirty = true;
        this.dirtyChildren(g);
    }
    resetTheme(t, g) {
        this.userTheme = t;
        this.dirty = true;
        this.dirtyChildren(g);
    }
    dirtyChildren(g) {
        g.forEachChildren(item => {
            if (item.isContainer) {
                if (item.theme) {
                    item.theme.dirty = true;
                }
                this.dirtyChildren(item);
            }
        });
    }
}
const globalTheme = new Theme();
function getTheme(graphic, theme) {
    if (graphic.glyphHost) {
        return getTheme(graphic.glyphHost);
    }
    if (theme) {
        if (graphic.isContainer) {
            return theme;
        }
        return theme;
    }
    return (getThemeFromGroup(graphic) ||
        (graphic.attachedThemeGraphic && getTheme(graphic.attachedThemeGraphic)) ||
        globalTheme.getTheme());
}
function getThemeFromGroup(graphic) {
    let g;
    if (graphic.isContainer) {
        g = graphic;
    }
    else {
        g = graphic.parent;
    }
    if (g) {
        while (g) {
            if (g.theme) {
                break;
            }
            g = g.parent;
        }
        if (!g) {
            return globalTheme.getTheme();
        }
        if (!g.theme) {
            g.createTheme();
        }
        return g.theme.getTheme(g);
    }
    return null;
}

class Node extends EventEmitter {
    get previousSibling() {
        return this._prev;
    }
    get nextSibling() {
        return this._next;
    }
    get children() {
        return this.getChildren();
    }
    get firstChild() {
        return this._firstChild;
    }
    get lastChild() {
        return this._lastChild;
    }
    get count() {
        return this._count;
    }
    get childrenCount() {
        if (!this._idMap) {
            return 0;
        }
        return this._idMap.size;
    }
    constructor() {
        super();
        this._uid = Generator.GenAutoIncrementId();
        this._firstChild = null;
        this._lastChild = null;
        this.parent = null;
        this._count = 1;
    }
    forEachChildren(cb, reverse = false) {
        if (reverse) {
            let child = this._lastChild;
            let i = 0;
            while (child) {
                const breakTag = cb(child, i++);
                if (breakTag) {
                    return;
                }
                child = child._prev;
            }
        }
        else {
            let child = this._firstChild;
            let i = 0;
            while (child) {
                const breakTag = cb(child, i++);
                if (breakTag) {
                    return;
                }
                child = child._next;
            }
        }
    }
    forEachChildrenAsync(cb, reverse = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (reverse) {
                let child = this._lastChild;
                let i = 0;
                while (child) {
                    let breakTag = cb(child, i++);
                    if (breakTag.then) {
                        breakTag = yield breakTag;
                    }
                    if (breakTag) {
                        return;
                    }
                    child = child._prev;
                }
            }
            else {
                let child = this._firstChild;
                let i = 0;
                while (child) {
                    let breakTag = cb(child, i++);
                    if (breakTag.then) {
                        breakTag = yield breakTag;
                    }
                    if (breakTag) {
                        return;
                    }
                    child = child._next;
                }
            }
        });
    }
    forEach(cb) {
        return this.forEachChildren(cb);
    }
    appendChild(node, highPerformance = true) {
        if (this._uid === node._uid) {
            return null;
        }
        if (!highPerformance && node.isAncestorsOf(this)) {
            throw new Error('【Node::appendChild】不能将父辈元素append为子元素');
        }
        node.parent && node.parent.removeChild(node);
        node.parent = this;
        if (!this._lastChild) {
            this._firstChild = this._lastChild = node;
            node._prev = node._next = null;
        }
        else {
            this._lastChild._next = node;
            node._prev = this._lastChild;
            this._lastChild = node;
        }
        if (!this._idMap) {
            this._idMap = new Map();
        }
        this._idMap.set(node._uid, node);
        this.setCount(node.count);
        this._structEdit = true;
        return node;
    }
    appendChildArrHighPerformance(nodes, replace = false) {
        console.error('暂不支持该函数');
        return nodes;
    }
    insertBefore(newNode, referenceNode) {
        if (!referenceNode) {
            return this.appendChild(newNode);
        }
        if (this === newNode || newNode === referenceNode) {
            return null;
        }
        if (newNode.isAncestorsOf(this)) {
            throw new Error('【Node::insertBefore】不能将父辈元素insert为子元素');
        }
        if (referenceNode.parent !== this) {
            return null;
        }
        newNode.parent && newNode.parent.removeChild(newNode);
        newNode.parent = this;
        newNode._prev = referenceNode._prev;
        if (!referenceNode._prev) {
            this._firstChild = newNode;
        }
        else {
            referenceNode._prev._next = newNode;
        }
        referenceNode._prev = newNode;
        newNode._next = referenceNode;
        if (!this._idMap) {
            this._idMap = new Map();
        }
        this._idMap.set(newNode._uid, newNode);
        this._structEdit = true;
        this.setCount(newNode.count);
        return newNode;
    }
    insertAfter(newNode, referenceNode) {
        if (!referenceNode) {
            return this.appendChild(newNode);
        }
        if (this === newNode || newNode === referenceNode) {
            return null;
        }
        if (newNode.isAncestorsOf(this)) {
            throw new Error('【Node::insertAfter】不能将父辈元素insert为子元素');
        }
        if (referenceNode.parent !== this) {
            return null;
        }
        newNode.parent && newNode.parent.removeChild(newNode);
        newNode.parent = this;
        if (!referenceNode._next) {
            this._lastChild = newNode;
        }
        else {
            referenceNode._next._prev = newNode;
            newNode._next = referenceNode._next;
        }
        referenceNode._next = newNode;
        newNode._prev = referenceNode;
        if (!this._idMap) {
            this._idMap = new Map();
        }
        this._idMap.set(newNode._uid, newNode);
        this._structEdit = true;
        this.setCount(newNode.count);
        return newNode;
    }
    insertInto(newNode, idx) {
        if (!this._ignoreWarn && this._nodeList) {
            Logger.getInstance().warn('insertIntoKeepIdx和insertInto混用可能会存在错误');
        }
        if (idx >= this.childrenCount) {
            return this.appendChild(newNode);
        }
        if (this === newNode) {
            return null;
        }
        if (newNode.isAncestorsOf(this)) {
            throw new Error('【Node::insertBefore】不能将父辈元素insert为子元素');
        }
        newNode.parent && newNode.parent.removeChild(newNode);
        newNode.parent = this;
        if (idx === 0) {
            newNode._next = this._firstChild;
            this._firstChild && (this._firstChild._prev = newNode);
            newNode._prev = null;
            this._firstChild = newNode;
        }
        else {
            let child = this._firstChild;
            for (let i = 0; i < idx; i++) {
                if (!child) {
                    return null;
                }
                if (i > 0) {
                    child = child._next;
                }
            }
            if (!child) {
                return null;
            }
            newNode._next = child._next;
            newNode._prev = child;
            child._next = newNode;
            if (newNode._next) {
                newNode._next._prev = newNode;
            }
        }
        if (!this._idMap) {
            this._idMap = new Map();
        }
        this._idMap.set(newNode._uid, newNode);
        this._structEdit = true;
        this.setCount(newNode.count);
        return newNode;
    }
    insertIntoKeepIdx(newNode, idx) {
        if (!this._nodeList) {
            this._nodeList = this.children;
        }
        if (this._nodeList[idx]) {
            const node = this._nodeList[idx];
            this._nodeList.splice(idx, 0, newNode);
            return this.insertBefore(newNode, node);
        }
        this._nodeList[idx] = newNode;
        let node;
        for (let i = idx - 1; i >= 0; i--) {
            node = this._nodeList[i];
            if (node) {
                break;
            }
        }
        if (node) {
            return node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode);
        }
        this._ignoreWarn = true;
        const data = this.insertInto(newNode, 0);
        this._ignoreWarn = false;
        return data;
    }
    removeChild(child) {
        if (!this._idMap) {
            return null;
        }
        if (!this._idMap.has(child._uid)) {
            return null;
        }
        this._idMap.delete(child._uid);
        if (this._nodeList) {
            const idx = this._nodeList.findIndex(n => n === child);
            if (idx >= 0) {
                this._nodeList.splice(idx, 1);
            }
        }
        if (!child._prev) {
            this._firstChild = child._next;
        }
        else {
            child._prev._next = child._next;
        }
        if (child._next) {
            child._next._prev = child._prev;
        }
        else {
            this._lastChild = child._prev;
        }
        child.parent = null;
        child._prev = null;
        child._next = null;
        this._structEdit = true;
        this.setCount(-child.count);
        return child;
    }
    delete() {
        if (this.parent) {
            this.parent.removeChild(this);
        }
    }
    removeAllChild(deep) {
        if (!this._idMap) {
            return;
        }
        if (this._nodeList) {
            this._nodeList.length = 0;
        }
        let child = this._firstChild;
        while (child) {
            const next = child._next;
            child.parent = null;
            child._prev = null;
            child._next = null;
            child = child._next;
            child = next;
        }
        this._firstChild = null;
        this._lastChild = null;
        this._idMap.clear();
        this._structEdit = true;
        this.setCount(-this._count + 1);
    }
    replaceChild(newChild, oldChild) {
        throw new Error('暂不支持');
    }
    find(callback, deep = false) {
        let target = null;
        this.forEachChildren((node, index) => {
            if (node !== this && callback(node, index)) {
                target = node;
                return true;
            }
            return false;
        });
        if (deep) {
            this.forEachChildren(child => {
                if (child.isContainer) {
                    const node = child.find(callback, true);
                    if (node) {
                        target = node;
                        return true;
                    }
                }
                return false;
            });
        }
        return target;
    }
    findAll(callback, deep = false) {
        let nodes = [];
        this.forEachChildren((node, index) => {
            if (node !== this && callback(node, index)) {
                nodes.push(node);
            }
        });
        if (deep) {
            this.forEachChildren(child => {
                if (child.isContainer) {
                    const targets = child.findAll(callback, true);
                    if (targets.length) {
                        nodes = nodes.concat(targets);
                    }
                }
            });
        }
        return nodes;
    }
    getElementById(id) {
        return this.find(node => node.id === id, true);
    }
    findChildById(id) {
        return this.getElementById(id);
    }
    findChildByUid(uid) {
        if (!this._idMap) {
            return null;
        }
        return this._idMap.get(uid) || null;
    }
    getElementsByName(name) {
        return this.findAll(node => node.name === name, true);
    }
    findChildrenByName(name) {
        return this.getElementsByName(name);
    }
    getElementsByType(type) {
        return this.findAll(node => node.type === type, true);
    }
    getChildByName(name, deep = false) {
        return this.find(node => node.name === name, deep);
    }
    getChildAt(idx) {
        let c = this._firstChild;
        if (!c) {
            return null;
        }
        for (let i = 0; i < idx; i++) {
            if (!c._next) {
                return null;
            }
            c = c._next;
        }
        return c;
    }
    at(idx) {
        return this.getChildAt(idx);
    }
    containNode(node) {
        if (!this._idMap) {
            return false;
        }
        if (this._idMap.has(node._uid)) {
            return true;
        }
        let child = this._firstChild;
        while (child) {
            if (child.containNode(node)) {
                return true;
            }
            child = child._next;
        }
        return false;
    }
    getRootNode() {
        let parent = this.parent;
        while (parent === null || parent === void 0 ? void 0 : parent.parent) {
            parent = parent.parent;
        }
        return parent || this;
    }
    hasChildNodes() {
        return this._firstChild !== null;
    }
    addChild(node) {
        return this.appendChild(node);
    }
    add(node) {
        return this.appendChild(node);
    }
    getChildren() {
        const nodes = [];
        let child = this._firstChild;
        while (child) {
            nodes.push(child);
            child = child._next;
        }
        return nodes;
    }
    isChildOf(node) {
        if (!this.parent) {
            return false;
        }
        return this.parent._uid === node._uid;
    }
    isParentOf(node) {
        return node.isChildOf(this);
    }
    isDescendantsOf(node) {
        let parent = this.parent;
        if (!parent) {
            return false;
        }
        do {
            if (parent._uid === node._uid) {
                return true;
            }
            parent = parent.parent;
        } while (parent !== null);
        return false;
    }
    isAncestorsOf(node) {
        return node.isDescendantsOf(this);
    }
    getAncestor(idx) {
        throw new Error('暂不支持');
    }
    setAllDescendantsProps(propsName, propsValue) {
        let child = this._firstChild;
        while (child) {
            child[propsName] = propsValue;
            child.setAllDescendantsProps(propsName, propsValue);
            child = child._next;
        }
    }
    setCount(deltaCount) {
        this._count += deltaCount;
        let parent = this.parent;
        if (!parent) {
            return;
        }
        do {
            parent._count += deltaCount;
            parent = parent.parent;
        } while (parent !== null);
    }
    clone() {
        throw new Error('暂不支持');
    }
    cloneTo(node) {
        throw new Error('暂不支持');
    }
    getParent() {
        return this.parent;
    }
    del(child) {
        return this.removeChild(child);
    }
    addEventListener(type, listener, options) {
        const capture = (isBoolean(options, true) && options) || (isObject(options) && options.capture);
        const once = isObject(options) && options.once;
        const context = isFunction(listener) ? undefined : listener;
        type = capture ? `${type}capture` : type;
        listener = isFunction(listener) ? listener : listener.handleEvent;
        if (once) {
            super.once(type, listener, context);
        }
        else {
            super.on(type, listener, context);
        }
        return this;
    }
    on(type, listener, options) {
        return this.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
        const capture = (isBoolean(options, true) && options) || (isObject(options) && options.capture);
        const context = isFunction(listener) ? undefined : listener;
        type = capture ? `${type}capture` : type;
        listener = isFunction(listener) ? listener : listener.handleEvent;
        const once = isObject(options) && options.once;
        super.off(type, listener, context, once);
        return this;
    }
    off(type, listener, options) {
        return this.removeEventListener(type, listener, options);
    }
    once(type, listener, options) {
        if (isObject(options)) {
            options.once = true;
            return this.addEventListener(type, listener, options);
        }
        return this.addEventListener(type, listener, { once: true });
    }
    removeAllEventListeners() {
        super.removeAllListeners();
        return this;
    }
    removeAllListeners() {
        return this.removeAllEventListeners();
    }
    dispatchEvent(event, ...args) {
        super.emit(event.type, event, ...args);
        return !event.defaultPrevented;
    }
    emit(event, data) {
        return this.dispatchEvent(event, data);
    }
    release() {
        this.removeAllListeners();
    }
}

class FederatedEvent {
    get layerX() {
        return this.layer.x;
    }
    get layerY() {
        return this.layer.y;
    }
    get pageX() {
        return this.page.x;
    }
    get pageY() {
        return this.page.y;
    }
    get x() {
        return this.canvas.x;
    }
    get y() {
        return this.canvas.y;
    }
    get canvasX() {
        return this.canvas.x;
    }
    get canvasY() {
        return this.canvas.y;
    }
    get viewX() {
        return this.viewport.x;
    }
    get viewY() {
        return this.viewport.y;
    }
    constructor(manager) {
        this.bubbles = true;
        this.cancelBubble = true;
        this.cancelable = false;
        this.composed = false;
        this.defaultPrevented = false;
        this.eventPhase = FederatedEvent.prototype.NONE;
        this.propagationStopped = false;
        this.propagationImmediatelyStopped = false;
        this.layer = {
            x: 0,
            y: 0
        };
        this.page = {
            x: 0,
            y: 0
        };
        this.canvas = {
            x: 0,
            y: 0
        };
        this.viewport = {
            x: 0,
            y: 0
        };
        this.NONE = 0;
        this.CAPTURING_PHASE = 1;
        this.AT_TARGET = 2;
        this.BUBBLING_PHASE = 3;
        this.manager = manager;
    }
    composedPath() {
        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
            this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        this.composedDetailPath();
        return this.path;
    }
    composedDetailPath() {
        if (this.pickParams && this.pickParams.graphic) {
            this.detailPath = this.path.slice();
            this._composedDetailPath(this.pickParams);
        }
        else {
            this.detailPath = this.path.slice();
        }
        return this.detailPath;
    }
    _composedDetailPath(params) {
        if (params && params.graphic) {
            const g = params.graphic;
            if (g.stage) {
                const path = g.stage.eventSystem.manager.propagationPath(g);
                this.detailPath.push(path);
                this._composedDetailPath(params.params);
            }
        }
    }
    preventDefault() {
        try {
            if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
                this.nativeEvent.preventDefault();
            }
        }
        catch (err) {
            this.nativeEvent.preventDefault &&
                isFunction(this.nativeEvent.preventDefault) &&
                this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
    }
    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
    }
    stopPropagation() {
        try {
            if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
                this.nativeEvent.stopPropagation();
            }
        }
        catch (err) {
            this.nativeEvent.stopPropagation &&
                isFunction(this.nativeEvent.stopPropagation) &&
                this.nativeEvent.stopPropagation();
        }
        this.propagationStopped = true;
    }
    initEvent() {
        return;
    }
    initUIEvent() {
        return;
    }
    clone() {
        throw new Error('Method not implemented.');
    }
}

class FederatedMouseEvent extends FederatedEvent {
    constructor() {
        super(...arguments);
        this.client = {
            x: 0,
            y: 0
        };
        this.movement = {
            x: 0,
            y: 0
        };
        this.offset = {
            x: 0,
            y: 0
        };
        this.global = {
            x: 0,
            y: 0
        };
        this.screen = {
            x: 0,
            y: 0
        };
    }
    get clientX() {
        return this.client.x;
    }
    get clientY() {
        return this.client.y;
    }
    get movementX() {
        return this.movement.x;
    }
    get movementY() {
        return this.movement.y;
    }
    get offsetX() {
        return this.offset.x;
    }
    get offsetY() {
        return this.offset.y;
    }
    get globalX() {
        return this.global.x;
    }
    get globalY() {
        return this.global.y;
    }
    get screenX() {
        return this.screen.x;
    }
    get screenY() {
        return this.screen.y;
    }
    getModifierState(key) {
        return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);
    }
    initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error('Method not implemented.');
    }
}

class FederatedPointerEvent extends FederatedMouseEvent {
    constructor() {
        super(...arguments);
        this.width = 0;
        this.height = 0;
        this.isPrimary = false;
    }
    getCoalescedEvents() {
        if (this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove') {
            return [this];
        }
        return [];
    }
    getPredictedEvents() {
        throw new Error('getPredictedEvents is not supported!');
    }
    clone() {
        var _a, _b, _c;
        const event = new FederatedPointerEvent(this.manager);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.path = [];
        event.detailPath = [];
        event.target = null;
        event.nativeEvent = this.nativeEvent;
        event.originalEvent = this.originalEvent;
        (_a = this.manager) === null || _a === void 0 ? void 0 : _a.copyPointerData(this, event);
        (_b = this.manager) === null || _b === void 0 ? void 0 : _b.copyMouseData(this, event);
        (_c = this.manager) === null || _c === void 0 ? void 0 : _c.copyData(this, event);
        event.target = this.target;
        event.path = this.composedPath().slice();
        const p = this.composedDetailPath();
        event.detailPath = p && p.slice();
        event.type = this.type;
        return event;
    }
}

class FederatedWheelEvent extends FederatedMouseEvent {
    constructor() {
        super(...arguments);
        this.DOM_DELTA_PIXEL = 0;
        this.DOM_DELTA_LINE = 1;
        this.DOM_DELTA_PAGE = 2;
    }
    clone() {
        var _a, _b, _c;
        const event = new FederatedWheelEvent(this.manager);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.path = [];
        event.detailPath = [];
        event.target = null;
        event.nativeEvent = this.nativeEvent;
        event.originalEvent = this.originalEvent;
        (_a = this.manager) === null || _a === void 0 ? void 0 : _a.copyWheelData(this, event);
        (_b = this.manager) === null || _b === void 0 ? void 0 : _b.copyMouseData(this, event);
        (_c = this.manager) === null || _c === void 0 ? void 0 : _c.copyData(this, event);
        event.target = this.target;
        event.path = this.composedPath().slice();
        const p = this.composedDetailPath();
        event.detailPath = p && p.slice();
        event.type = this.type;
        return event;
    }
}
FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
FederatedWheelEvent.DOM_DELTA_LINE = 1;
FederatedWheelEvent.DOM_DELTA_PAGE = 2;

class CustomEvent extends FederatedEvent {
    constructor(eventName, object) {
        super();
        this.type = eventName;
        this.detail = object;
    }
}

const WILDCARD = '*';

const clock = typeof performance === 'object' && performance.now ? performance : Date;

const PROPAGATION_LIMIT = 2048;
function isMouseLike(pointerType) {
    return pointerType === 'mouse' || pointerType === 'pen';
}
const DEFAULT_CLICK_INTERVAL = 200;
class EventManager {
    constructor(root, config) {
        this.dispatch = new EventEmitter();
        this.cursorTarget = null;
        this.pauseNotify = false;
        this.mappingState = {
            trackingData: {}
        };
        this.eventPool = new Map();
        this.onPointerDown = (from, target) => {
            if (!(from instanceof FederatedPointerEvent)) {
                Logger.getInstance().warn('EventManager cannot map a non-pointer event as a pointer event');
                return;
            }
            const e = this.createPointerEvent(from, from.type, target);
            this.dispatchEvent(e, 'pointerdown');
            if (e.pointerType === 'touch') {
                this.dispatchEvent(e, 'touchstart');
            }
            else if (isMouseLike(e.pointerType)) {
                const isRightButton = e.button === 2;
                this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');
            }
            const trackingData = this.trackingData(from.pointerId);
            trackingData.pressTargetsByButton[from.button] = e.composedPath();
            this.freeEvent(e);
        };
        this.onPointerMove = (from, target) => {
            var _a, _b;
            if (!(from instanceof FederatedPointerEvent)) {
                Logger.getInstance().warn('EventManager cannot map a non-pointer event as a pointer event');
                return;
            }
            const e = this.createPointerEvent(from, from.type, target);
            const isMouse = isMouseLike(e.pointerType);
            const trackingData = this.trackingData(from.pointerId);
            const outTarget = this.findMountedTarget(trackingData.overTargets);
            if (trackingData.overTargets && outTarget && outTarget !== this.rootTarget && outTarget !== e.target) {
                const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';
                const outEvent = this.createPointerEvent(from, outType, outTarget || undefined);
                this.dispatchEvent(outEvent, 'pointerout');
                if (isMouse) {
                    this.dispatchEvent(outEvent, 'mouseout');
                }
                if (!e.composedPath().includes(outTarget)) {
                    const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget || undefined);
                    leaveEvent.eventPhase = leaveEvent.AT_TARGET;
                    while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {
                        leaveEvent.currentTarget = leaveEvent.target;
                        this.notifyTarget(leaveEvent);
                        if (isMouse) {
                            this.notifyTarget(leaveEvent, 'mouseleave');
                        }
                        leaveEvent.target = leaveEvent.target.parent;
                    }
                    this.freeEvent(leaveEvent);
                }
                this.freeEvent(outEvent);
            }
            if (outTarget !== e.target) {
                const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';
                const overEvent = this.clonePointerEvent(e, overType);
                this.dispatchEvent(overEvent, 'pointerover');
                if (isMouse) {
                    this.dispatchEvent(overEvent, 'mouseover');
                }
                let overTargetAncestor = outTarget === null || outTarget === void 0 ? void 0 : outTarget.parent;
                while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
                    if (overTargetAncestor === e.target) {
                        break;
                    }
                    overTargetAncestor = overTargetAncestor.parent;
                }
                const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
                if (didPointerEnter) {
                    const enterEvent = this.clonePointerEvent(e, 'pointerenter');
                    enterEvent.eventPhase = enterEvent.AT_TARGET;
                    let currentTarget = enterEvent.target;
                    const outTargetAncestors = new Set();
                    let ancestor = outTarget;
                    while (ancestor && ancestor !== this.rootTarget) {
                        outTargetAncestors.add(ancestor);
                        ancestor = ancestor.parent;
                    }
                    while (currentTarget && currentTarget !== outTarget && currentTarget !== this.rootTarget.parent) {
                        if (!outTargetAncestors.has(currentTarget)) {
                            enterEvent.currentTarget = currentTarget;
                            this.notifyTarget(enterEvent);
                            if (isMouse) {
                                this.notifyTarget(enterEvent, 'mouseenter');
                            }
                        }
                        currentTarget = currentTarget.parent;
                    }
                    this.freeEvent(enterEvent);
                }
                this.freeEvent(overEvent);
            }
            const propagationMethod = 'dispatchEvent';
            this[propagationMethod](e, 'pointermove');
            if (e.pointerType === 'touch') {
                this[propagationMethod](e, 'touchmove');
            }
            if (isMouse) {
                this[propagationMethod](e, 'mousemove');
                this.cursorTarget = e.target;
                this.cursor = ((_b = (_a = e.target) === null || _a === void 0 ? void 0 : _a.attribute) === null || _b === void 0 ? void 0 : _b.cursor) || this.rootTarget.getCursor();
            }
            trackingData.overTargets = e.composedPath();
            this.freeEvent(e);
        };
        this.onPointerOver = (from, target) => {
            var _a, _b;
            if (!(from instanceof FederatedPointerEvent)) {
                Logger.getInstance().warn('EventManager cannot map a non-pointer event as a pointer event');
                return;
            }
            const trackingData = this.trackingData(from.pointerId);
            const e = this.createPointerEvent(from, from.type, target);
            const isMouse = isMouseLike(e.pointerType);
            this.dispatchEvent(e, 'pointerover');
            if (isMouse) {
                this.dispatchEvent(e, 'mouseover');
            }
            if (e.pointerType === 'mouse') {
                this.cursorTarget = e.target;
                this.cursor = ((_b = (_a = e.target) === null || _a === void 0 ? void 0 : _a.attribute) === null || _b === void 0 ? void 0 : _b.cursor) || this.rootTarget.getCursor();
            }
            const enterEvent = this.clonePointerEvent(e, 'pointerenter');
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
                enterEvent.currentTarget = enterEvent.target;
                this.notifyTarget(enterEvent);
                if (isMouse) {
                    this.notifyTarget(enterEvent, 'mouseenter');
                }
                enterEvent.target = enterEvent.target.parent;
            }
            trackingData.overTargets = e.composedPath();
            this.freeEvent(e);
            this.freeEvent(enterEvent);
        };
        this.onPointerOut = (from, target) => {
            if (!(from instanceof FederatedPointerEvent)) {
                Logger.getInstance().warn('EventManager cannot map a non-pointer event as a pointer event');
                return;
            }
            const trackingData = this.trackingData(from.pointerId);
            if (trackingData.overTargets) {
                const isMouse = isMouseLike(from.pointerType);
                const outTarget = this.findMountedTarget(trackingData.overTargets);
                const outEvent = this.createPointerEvent(from, 'pointerout', outTarget || undefined);
                this.dispatchEvent(outEvent);
                if (isMouse) {
                    this.dispatchEvent(outEvent, 'mouseout');
                }
                const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget || undefined);
                leaveEvent.eventPhase = leaveEvent.AT_TARGET;
                while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
                    leaveEvent.currentTarget = leaveEvent.target;
                    this.notifyTarget(leaveEvent);
                    if (isMouse) {
                        this.notifyTarget(leaveEvent, 'mouseleave');
                    }
                    leaveEvent.target = leaveEvent.target.parent;
                }
                trackingData.overTargets = [];
                this.freeEvent(outEvent);
                this.freeEvent(leaveEvent);
            }
            this.cursorTarget = null;
            this.cursor = '';
        };
        this.onPointerUp = (from, target) => {
            var _a;
            if (!(from instanceof FederatedPointerEvent)) {
                Logger.getInstance().warn('EventManager cannot map a non-pointer event as a pointer event');
                return;
            }
            const now = clock.now();
            const e = this.createPointerEvent(from, from.type, target);
            this.dispatchEvent(e, 'pointerup');
            if (e.pointerType === 'touch') {
                this.dispatchEvent(e, 'touchend');
            }
            else if (isMouseLike(e.pointerType)) {
                const isRightButton = e.button === 2;
                this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');
            }
            const trackingData = this.trackingData(from.pointerId);
            const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
            let clickTarget = pressTarget;
            if (pressTarget && !e.composedPath().includes(pressTarget)) {
                let currentTarget = pressTarget;
                while (currentTarget && !e.composedPath().includes(currentTarget)) {
                    e.currentTarget = currentTarget;
                    this.notifyTarget(e, 'pointerupoutside');
                    if (e.pointerType === 'touch') {
                        this.notifyTarget(e, 'touchendoutside');
                    }
                    else if (isMouseLike(e.pointerType)) {
                        const isRightButton = e.button === 2;
                        this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');
                    }
                    currentTarget = currentTarget.parent;
                }
                delete trackingData.pressTargetsByButton[from.button];
                clickTarget = currentTarget;
            }
            if (clickTarget) {
                const clickEvent = this.clonePointerEvent(e, 'click');
                clickEvent.target = clickTarget;
                clickEvent.path = [];
                clickEvent.detailPath = [];
                if (!trackingData.clicksByButton[from.button]) {
                    trackingData.clicksByButton[from.button] = {
                        clickCount: 0,
                        target: clickEvent.target,
                        timeStamp: now
                    };
                }
                const clickHistory = trackingData.clicksByButton[from.button];
                if (clickHistory.target === clickEvent.target &&
                    now - clickHistory.timeStamp < ((_a = this._config.clickInterval) !== null && _a !== void 0 ? _a : DEFAULT_CLICK_INTERVAL)) {
                    ++clickHistory.clickCount;
                }
                else {
                    clickHistory.clickCount = 1;
                }
                clickHistory.target = clickEvent.target;
                clickHistory.timeStamp = now;
                clickEvent.detail = clickHistory.clickCount;
                if (isMouseLike(clickEvent.pointerType)) {
                    this.dispatchEvent(clickEvent, 'click');
                    if (clickHistory.clickCount === 2) {
                        this.dispatchEvent(clickEvent, 'dblclick');
                    }
                }
                else if (clickEvent.pointerType === 'touch' && this._config.supportsTouchEvents) {
                    this.dispatchEvent(clickEvent, 'tap');
                    if (clickHistory.clickCount === 2) {
                        this.dispatchEvent(clickEvent, 'dbltap');
                    }
                }
                this.dispatchEvent(clickEvent, 'pointertap');
                this.freeEvent(clickEvent);
            }
            this.freeEvent(e);
        };
        this.onPointerUpOutside = (from, target) => {
            if (!(from instanceof FederatedPointerEvent)) {
                Logger.getInstance().warn('EventManager cannot map a non-pointer event as a pointer event');
                return;
            }
            const trackingData = this.trackingData(from.pointerId);
            const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
            const e = this.createPointerEvent(from, from.type, target);
            if (pressTarget) {
                let currentTarget = pressTarget;
                while (currentTarget) {
                    e.currentTarget = currentTarget;
                    this.notifyTarget(e, 'pointerupoutside');
                    if (e.pointerType === 'touch') {
                        this.notifyTarget(e, 'touchendoutside');
                    }
                    else if (isMouseLike(e.pointerType)) {
                        this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');
                    }
                    currentTarget = currentTarget.parent;
                }
                delete trackingData.pressTargetsByButton[from.button];
            }
            this.freeEvent(e);
        };
        this.onWheel = (from, target) => {
            if (!(from instanceof FederatedWheelEvent)) {
                Logger.getInstance().warn('EventManager cannot map a non-wheel event as a wheel event');
                return;
            }
            const wheelEvent = this.createWheelEvent(from, target);
            this.dispatchEvent(wheelEvent);
            this.freeEvent(wheelEvent);
        };
        this.rootTarget = root;
        this.mappingTable = {};
        this._config = Object.assign({ clickInterval: DEFAULT_CLICK_INTERVAL }, config);
        this.addEventMapping('pointerdown', this.onPointerDown);
        this.addEventMapping('pointermove', this.onPointerMove);
        this.addEventMapping('pointerout', this.onPointerOut);
        this.addEventMapping('pointerleave', this.onPointerOut);
        this.addEventMapping('pointerover', this.onPointerOver);
        this.addEventMapping('pointerup', this.onPointerUp);
        this.addEventMapping('pointerupoutside', this.onPointerUpOutside);
        this.addEventMapping('wheel', this.onWheel);
    }
    addEventMapping(type, fn) {
        if (!this.mappingTable[type]) {
            this.mappingTable[type] = [];
        }
        this.mappingTable[type].push({
            fn,
            priority: 0
        });
        this.mappingTable[type].sort((a, b) => a.priority - b.priority);
    }
    dispatchEvent(e, type) {
        e.propagationStopped = false;
        e.propagationImmediatelyStopped = false;
        this.propagate(e, type);
        this.dispatch.emit(type || e.type, e);
    }
    mapEvent(e) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.rootTarget) {
            return;
        }
        const mappers = this.mappingTable[e.type];
        let target;
        const cacheKey = `${e.canvasX}-${e.canvasY}`;
        if (((_a = this._prePointTargetCache) === null || _a === void 0 ? void 0 : _a[cacheKey]) &&
            ((_c = (_b = this._prePointTargetCache) === null || _b === void 0 ? void 0 : _b[cacheKey]) === null || _c === void 0 ? void 0 : _c.stage) &&
            ((_e = (_d = this._prePointTargetCache) === null || _d === void 0 ? void 0 : _d[cacheKey]) === null || _e === void 0 ? void 0 : _e.stage.renderCount) ===
                ((_f = this._prePointTargetCache) === null || _f === void 0 ? void 0 : _f.stageRenderCount)) {
            target = this._prePointTargetCache[cacheKey];
        }
        else {
            target = this.pickTarget(e.viewX, e.viewY, e);
            if (!e.pickParams) {
                this._prePointTargetCache = {
                    [cacheKey]: target,
                    stageRenderCount: (_g = target === null || target === void 0 ? void 0 : target.stage.renderCount) !== null && _g !== void 0 ? _g : -1
                };
            }
        }
        if (mappers) {
            for (let i = 0, j = mappers.length; i < j; i++) {
                mappers[i].fn(e, target);
            }
        }
        else {
            Logger.getInstance().warn(`[EventManager]: Event mapping not defined for ${e.type}`);
        }
    }
    propagate(e, type) {
        if (!e.target) {
            return;
        }
        const composedPath = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for (let i = 0, j = composedPath.length - 1; i < j; i++) {
            e.currentTarget = composedPath[i];
            this.notifyTarget(e, type);
            if (e.propagationStopped || e.propagationImmediatelyStopped) {
                return;
            }
        }
        e.eventPhase = e.AT_TARGET;
        e.currentTarget = e.target;
        this.notifyTarget(e, type);
        if (e.propagationStopped || e.propagationImmediatelyStopped) {
            return;
        }
        e.eventPhase = e.BUBBLING_PHASE;
        for (let i = composedPath.length - 2; i >= 0; i--) {
            e.currentTarget = composedPath[i];
            this.notifyTarget(e, type);
            if (e.propagationStopped || e.propagationImmediatelyStopped) {
                return;
            }
        }
    }
    propagationPath(target) {
        const propagationPath = [target];
        for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget && target.parent; i++) {
            if (!target.parent) {
                throw new Error('Cannot find propagation path to disconnected target');
            }
            propagationPath.push(target.parent);
            target = target.parent;
        }
        propagationPath.reverse();
        return propagationPath;
    }
    notifyTarget(e, type) {
        if (this.pauseNotify) {
            return;
        }
        type = type !== null && type !== void 0 ? type : e.type;
        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
        this.notifyListeners(e, key);
        if (e.eventPhase === e.AT_TARGET) {
            this.notifyListeners(e, type);
        }
    }
    findMountedTarget(propagationPath) {
        if (!propagationPath) {
            return null;
        }
        let currentTarget = propagationPath[0];
        for (let i = 1; i < propagationPath.length; i++) {
            if (propagationPath[i].parent === currentTarget) {
                currentTarget = propagationPath[i];
            }
            else {
                break;
            }
        }
        return currentTarget;
    }
    createPointerEvent(from, type, target) {
        var _a, _b;
        const event = this.allocateEvent(FederatedPointerEvent);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        if (target) {
            event.target = target;
        }
        else {
            event.target = this.pickTarget((_a = event.viewX) !== null && _a !== void 0 ? _a : event.global.x, (_b = event.viewY) !== null && _b !== void 0 ? _b : event.global.y, event);
        }
        if (typeof type === 'string') {
            event.type = type;
        }
        return event;
    }
    createWheelEvent(from, target) {
        var _a, _b;
        const event = this.allocateEvent(FederatedWheelEvent);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = target || this.pickTarget((_a = event.viewX) !== null && _a !== void 0 ? _a : event.global.x, (_b = event.viewY) !== null && _b !== void 0 ? _b : event.global.y, event);
        return event;
    }
    clonePointerEvent(from, type) {
        const event = this.allocateEvent(FederatedPointerEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        const p = from.composedDetailPath();
        event.detailPath = p && p.slice();
        event.type = type !== null && type !== void 0 ? type : event.type;
        return event;
    }
    copyWheelData(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
    }
    copyPointerData(from, to) {
        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) {
            return;
        }
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
    }
    copyMouseData(from, to) {
        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) {
            return;
        }
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.ctrlKey = from.ctrlKey;
        to.shiftKey = from.shiftKey;
        to.metaKey = from.metaKey;
        ['client', 'movement', 'canvas', 'screen', 'global', 'offset', 'viewport'].forEach(key => {
            to[key].x = from[key].x;
            to[key].y = from[key].y;
        });
    }
    copyData(from, to) {
        to.isTrusted = from.isTrusted;
        to.srcElement = from.srcElement;
        to.timeStamp = clock.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.which = from.which;
        to.layer.x = from.layer.x;
        to.layer.y = from.layer.y;
        to.page.x = from.page.x;
        to.page.y = from.page.y;
        to.pickParams = from.pickParams;
    }
    trackingData(id) {
        if (!this.mappingState.trackingData[id]) {
            this.mappingState.trackingData[id] = {
                pressTargetsByButton: {},
                clicksByButton: {},
                overTarget: null
            };
        }
        return this.mappingState.trackingData[id];
    }
    allocateEvent(constructor) {
        var _a;
        if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
        }
        const event = ((_a = this.eventPool.get(constructor)) === null || _a === void 0 ? void 0 : _a.pop()) || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.path = [];
        event.detailPath = [];
        event.target = null;
        return event;
    }
    freeEvent(event) {
        var _a;
        if (event.manager !== this) {
            throw new Error('It is illegal to free an event not managed by this EventManager!');
        }
        const constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
            this.eventPool.set(constructor, []);
        }
        (_a = this.eventPool.get(constructor)) === null || _a === void 0 ? void 0 : _a.push(event);
    }
    notifyListeners(e, type) {
        const events = e.currentTarget._events;
        const listeners = events[type];
        if (listeners) {
            if ('fn' in listeners) {
                if (listeners.once) {
                    e.currentTarget.removeEventListener(type, listeners.fn, { once: true });
                }
                listeners.fn.call(listeners.context, e);
            }
            else {
                for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
                    if (listeners[i].once) {
                        e.currentTarget.removeEventListener(type, listeners[i].fn, { once: true });
                    }
                    listeners[i].fn.call(listeners[i].context, e);
                }
            }
        }
        this.emitDelegation(e, type);
    }
    emitDelegation(e, type) {
        const events = e.currentTarget._events;
        const listeners = events[WILDCARD];
        if (listeners) {
            if ('fn' in listeners) {
                listeners.fn.call(listeners.context, e, type);
            }
            else {
                for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
                    listeners[i].fn.call(listeners[i].context, e, type);
                }
            }
        }
    }
    pickTarget(x, y, e) {
        let target;
        const pickResult = this.rootTarget.pick(x, y);
        if (pickResult && pickResult.graphic) {
            target = pickResult.graphic;
        }
        else if (pickResult && pickResult.group) {
            target = pickResult.group;
        }
        else if (this.rootTarget.AABBBounds.contains(x, y)) {
            target = this.rootTarget;
        }
        else {
            target = null;
        }
        if (e) {
            e.pickParams = pickResult.params;
        }
        return target;
    }
    release() {
        this.dispatch.removeAllListeners();
        this.eventPool.clear();
        this.rootTarget = null;
        this.mappingTable = null;
        this.mappingState = null;
        this.cursorTarget = null;
    }
}

const EventTarget = {
    dispatchEvent(e) {
        var _a;
        if (!(e instanceof FederatedEvent)) {
            throw new Error('DisplayObject cannot propagate events outside of the Federated Events API');
        }
        e.defaultPrevented = false;
        e.path = [];
        e.detailPath && (e.detailPath = []);
        e.target = this;
        (_a = e === null || e === void 0 ? void 0 : e.manager) === null || _a === void 0 ? void 0 : _a.dispatchEvent(e);
        return !e.defaultPrevented;
    },
    emit(eventName, object) {
        return this.dispatchEvent(new CustomEvent(eventName, object));
    }
};

const MOUSE_POINTER_ID = 1;
const TOUCH_TO_POINTER = {
    touchstart: 'pointerdown',
    touchend: 'pointerup',
    touchendoutside: 'pointerupoutside',
    touchmove: 'pointermove',
    touchcancel: 'pointercancel'
};
class EventSystem {
    constructor(params) {
        this.resolution = 1;
        this.onPointerDown = (nativeEvent) => {
            if (this.supportsTouchEvents && nativeEvent.pointerType === 'touch') {
                return;
            }
            const events = this.normalizeToPointerData(nativeEvent);
            if (this.autoPreventDefault && events[0].isNormalized) {
                const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);
                if (cancelable) {
                    nativeEvent.preventDefault();
                }
            }
            for (let i = 0, j = events.length; i < j; i++) {
                const nativeEvent = events[i];
                const federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent);
                this.manager.mapEvent(federatedEvent);
            }
            this.setCursor(this.manager.cursor, this.manager.cursorTarget);
            this.rootPointerEvent.nativeEvent = null;
        };
        this.onPointerMove = (nativeEvent) => {
            if (this.supportsTouchEvents && nativeEvent.pointerType === 'touch') {
                return;
            }
            if (this.isEventOutsideOfTargetElement(nativeEvent)) {
                return;
            }
            const normalizedEvents = this.normalizeToPointerData(nativeEvent);
            for (let i = 0, j = normalizedEvents.length; i < j; i++) {
                const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
                this.manager.mapEvent(event);
            }
            this.setCursor(this.manager.cursor, this.manager.cursorTarget);
            this.rootPointerEvent.nativeEvent = null;
        };
        this.onPointerUp = (nativeEvent) => {
            if (this.supportsTouchEvents && nativeEvent.pointerType === 'touch') {
                return;
            }
            const outside = this.isEventOutsideOfTargetViewPort(nativeEvent) ? 'outside' : '';
            const normalizedEvents = this.normalizeToPointerData(nativeEvent);
            for (let i = 0, j = normalizedEvents.length; i < j; i++) {
                const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
                event.type += outside;
                this.manager.mapEvent(event);
            }
            this.setCursor(this.manager.cursor, this.manager.cursorTarget);
            this.rootPointerEvent.nativeEvent = null;
        };
        this.onPointerOverOut = (nativeEvent) => {
            if (this.supportsTouchEvents && nativeEvent.pointerType === 'touch') {
                return;
            }
            const normalizedEvents = this.normalizeToPointerData(nativeEvent);
            for (let i = 0, j = normalizedEvents.length; i < j; i++) {
                const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
                this.manager.mapEvent(event);
            }
            this.setCursor(this.manager.cursor, this.manager.cursorTarget);
            this.rootPointerEvent.nativeEvent = null;
        };
        this.onWheel = (nativeEvent) => {
            const wheelEvent = this.normalizeWheelEvent(nativeEvent);
            this.manager.mapEvent(wheelEvent);
        };
        const { targetElement, resolution, rootNode, global, autoPreventDefault = false, clickInterval, supportsTouchEvents = global.supportsTouchEvents, supportsPointerEvents = global.supportsPointerEvents } = params;
        this.manager = new EventManager(rootNode, {
            clickInterval,
            supportsTouchEvents: supportsTouchEvents
        });
        this.globalObj = global;
        this.supportsPointerEvents = supportsPointerEvents;
        this.supportsTouchEvents = supportsTouchEvents;
        this.supportsMouseEvents = global.supportsMouseEvents;
        this.applyStyles = global.applyStyles;
        this.autoPreventDefault = autoPreventDefault;
        this.eventsAdded = false;
        this.rootPointerEvent = new FederatedPointerEvent();
        this.rootWheelEvent = new FederatedWheelEvent();
        this.cursorStyles = {
            default: 'inherit',
            pointer: 'pointer'
        };
        this.resolution = resolution;
        this.setTargetElement(targetElement);
    }
    release() {
        this.removeEvents();
        this.manager && this.manager.release();
        this.domElement = null;
        this.manager = null;
        this.globalObj = null;
    }
    setCursor(mode, target) {
        if (!target && !this.manager.rootTarget.window._handler.canvas.controled) {
            return;
        }
        if (!mode) {
            mode = 'default';
        }
        const { applyStyles, domElement } = this;
        if (this.currentCursor === mode) {
            return;
        }
        this.currentCursor = mode;
        const style = this.cursorStyles[mode];
        if (style) {
            if (typeof style === 'string' && applyStyles) {
                domElement.style.cursor = style;
            }
            else if (typeof style === 'function') {
                style(mode);
            }
            else if (typeof style === 'object' && applyStyles) {
                Object.assign(domElement.style, style);
            }
        }
        else if (applyStyles && isString(mode) && !has(this.cursorStyles, mode)) {
            domElement.style.cursor = mode;
        }
    }
    setTargetElement(element) {
        this.removeEvents();
        this.domElement = element;
        this.addEvents();
    }
    addEvents() {
        if (this.eventsAdded || !this.domElement) {
            return;
        }
        const { globalObj, domElement } = this;
        if (this.supportsPointerEvents) {
            if (globalObj.getDocument()) {
                globalObj.addEventListener('pointermove', this.onPointerMove, true);
                globalObj.addEventListener('pointerup', this.onPointerUp, true);
            }
            else {
                domElement.addEventListener('pointermove', this.onPointerMove, true);
                domElement.addEventListener('pointerup', this.onPointerUp, true);
            }
            domElement.addEventListener('pointerdown', this.onPointerDown, true);
            domElement.addEventListener('pointerleave', this.onPointerOverOut, true);
            domElement.addEventListener('pointerover', this.onPointerOverOut, true);
        }
        else {
            if (globalObj.getDocument()) {
                globalObj.addEventListener('mousemove', this.onPointerMove, true);
                globalObj.addEventListener('mouseup', this.onPointerUp, true);
            }
            else {
                domElement.addEventListener('mousemove', this.onPointerMove, true);
                domElement.addEventListener('mouseup', this.onPointerUp, true);
            }
            domElement.addEventListener('mousedown', this.onPointerDown, true);
            domElement.addEventListener('mouseout', this.onPointerOverOut, true);
            domElement.addEventListener('mouseover', this.onPointerOverOut, true);
        }
        if (this.supportsTouchEvents) {
            domElement.addEventListener('touchstart', this.onPointerDown, true);
            domElement.addEventListener('touchend', this.onPointerUp, true);
            domElement.addEventListener('touchmove', this.onPointerMove, true);
        }
        domElement.addEventListener('wheel', this.onWheel, {
            capture: true
        });
        this.eventsAdded = true;
    }
    removeEvents() {
        if (!this.eventsAdded || !this.domElement) {
            return;
        }
        const { globalObj, domElement } = this;
        if (this.supportsPointerEvents) {
            if (globalObj.getDocument()) {
                globalObj.removeEventListener('pointermove', this.onPointerMove, true);
                globalObj.removeEventListener('pointerup', this.onPointerUp, true);
            }
            else {
                domElement.removeEventListener('pointermove', this.onPointerMove, true);
                domElement.removeEventListener('pointerup', this.onPointerUp, true);
            }
            domElement.removeEventListener('pointerdown', this.onPointerDown, true);
            domElement.removeEventListener('pointerleave', this.onPointerOverOut, true);
            domElement.removeEventListener('pointerover', this.onPointerOverOut, true);
        }
        else {
            if (globalObj.getDocument()) {
                globalObj.removeEventListener('mousemove', this.onPointerMove, true);
                globalObj.removeEventListener('mouseup', this.onPointerUp, true);
            }
            else {
                domElement.removeEventListener('mousemove', this.onPointerMove, true);
                domElement.removeEventListener('mouseup', this.onPointerUp, true);
            }
            domElement.removeEventListener('mousedown', this.onPointerDown, true);
            domElement.removeEventListener('mouseout', this.onPointerOverOut, true);
            domElement.removeEventListener('mouseover', this.onPointerOverOut, true);
        }
        if (this.supportsTouchEvents) {
            domElement.removeEventListener('touchstart', this.onPointerDown, true);
            domElement.removeEventListener('touchend', this.onPointerUp, true);
            domElement.removeEventListener('touchmove', this.onPointerMove, true);
        }
        domElement.removeEventListener('wheel', this.onWheel, true);
        this.domElement = null;
        this.eventsAdded = false;
    }
    mapToViewportPoint(event) {
        if (this.domElement.pointTransform) {
            return this.domElement.pointTransform(event.x, event.y);
        }
        return event;
    }
    mapToCanvasPoint(nativeEvent) {
        var _a, _b;
        const point = (_a = this.globalObj) === null || _a === void 0 ? void 0 : _a.mapToCanvasPoint(nativeEvent, this.domElement);
        if (point) {
            return point;
        }
        let x = 0;
        let y = 0;
        if (nativeEvent.changedTouches) {
            const data = (_b = nativeEvent.changedTouches[0]) !== null && _b !== void 0 ? _b : {};
            x = data.clientX || 0;
            y = data.clientY || 0;
        }
        else {
            x = nativeEvent.clientX || 0;
            y = nativeEvent.clientY || 0;
        }
        const rect = this.domElement.getBoundingClientRect();
        return {
            x: x - rect.left,
            y: y - rect.top
        };
    }
    normalizeToPointerData(event) {
        const normalizedEvents = [];
        if (this.supportsTouchEvents &&
            event.changedTouches &&
            event.changedTouches.length) {
            for (let i = 0, li = event.changedTouches.length; i < li; i++) {
                const touch = event.changedTouches[i];
                if (isUndefined(touch.button)) {
                    touch.button = 0;
                }
                if (isUndefined(touch.buttons)) {
                    touch.buttons = 1;
                }
                if (isUndefined(touch.isPrimary)) {
                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
                }
                if (isUndefined(touch.width)) {
                    touch.width = touch.radiusX || 1;
                }
                if (isUndefined(touch.height)) {
                    touch.height = touch.radiusY || 1;
                }
                if (isUndefined(touch.tiltX)) {
                    touch.tiltX = 0;
                }
                if (isUndefined(touch.tiltY)) {
                    touch.tiltY = 0;
                }
                if (isUndefined(touch.pointerType)) {
                    touch.pointerType = 'touch';
                }
                if (isUndefined(touch.pointerId)) {
                    touch.pointerId = touch.identifier || 0;
                }
                if (isUndefined(touch.pressure)) {
                    touch.pressure = touch.force || 0.5;
                }
                if (isUndefined(touch.twist)) {
                    touch.twist = 0;
                }
                if (isUndefined(touch.tangentialPressure)) {
                    touch.tangentialPressure = 0;
                }
                if (isUndefined(touch.layerX)) {
                    touch.layerX = touch.offsetX = touch.clientX;
                }
                if (isUndefined(touch.layerY)) {
                    touch.layerY = touch.offsetY = touch.clientY;
                }
                touch.isNormalized = true;
                touch.type = event.type;
                normalizedEvents.push(touch);
            }
        }
        else if (!this.globalObj.supportsMouseEvents ||
            (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof PointerEvent)))) {
            const tempEvent = event;
            if (isUndefined(tempEvent.isPrimary)) {
                tempEvent.isPrimary = true;
            }
            if (isUndefined(tempEvent.width)) {
                tempEvent.width = 1;
            }
            if (isUndefined(tempEvent.height)) {
                tempEvent.height = 1;
            }
            if (isUndefined(tempEvent.tiltX)) {
                tempEvent.tiltX = 0;
            }
            if (isUndefined(tempEvent.tiltY)) {
                tempEvent.tiltY = 0;
            }
            if (isUndefined(tempEvent.pointerType)) {
                tempEvent.pointerType = 'mouse';
            }
            if (isUndefined(tempEvent.pointerId)) {
                tempEvent.pointerId = MOUSE_POINTER_ID;
            }
            if (isUndefined(tempEvent.pressure)) {
                tempEvent.pressure = 0.5;
            }
            if (isUndefined(tempEvent.twist)) {
                tempEvent.twist = 0;
            }
            if (isUndefined(tempEvent.tangentialPressure)) {
                tempEvent.tangentialPressure = 0;
            }
            tempEvent.isNormalized = true;
            normalizedEvents.push(tempEvent);
        }
        else {
            normalizedEvents.push(event);
        }
        return normalizedEvents;
    }
    normalizeWheelEvent(nativeEvent) {
        const event = this.rootWheelEvent;
        this.transferMouseData(event, nativeEvent);
        event.deltaMode = nativeEvent.deltaMode;
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        const { x: canvasX, y: canvasY } = this.mapToCanvasPoint(nativeEvent);
        event.canvas.x = canvasX;
        event.canvas.y = canvasY;
        event.global.x = canvasX;
        event.global.y = canvasY;
        event.offset.x = canvasX;
        event.offset.y = canvasY;
        const { x: viewX, y: viewY } = this.mapToViewportPoint(event);
        event.viewport.x = viewX;
        event.viewport.y = viewY;
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
    }
    bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = nativeEvent.pointerId;
        event.width = nativeEvent.width;
        event.height = nativeEvent.height;
        event.isPrimary = nativeEvent.isPrimary;
        event.pointerType = nativeEvent.pointerType;
        event.pressure = nativeEvent.pressure;
        event.tangentialPressure = nativeEvent.tangentialPressure;
        event.tiltX = nativeEvent.tiltX;
        event.tiltY = nativeEvent.tiltY;
        event.twist = nativeEvent.twist;
        this.transferMouseData(event, nativeEvent);
        const { x: canvasX, y: canvasY } = this.mapToCanvasPoint(nativeEvent);
        event.canvas.x = canvasX;
        event.canvas.y = canvasY;
        event.global.x = canvasX;
        event.global.y = canvasY;
        event.offset.x = canvasX;
        event.offset.y = canvasY;
        const { x: viewX, y: viewY } = this.mapToViewportPoint(event);
        event.viewport.x = viewX;
        event.viewport.y = viewY;
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === 'pointerleave') {
            event.type = 'pointerout';
        }
        if (event.type.startsWith('mouse')) {
            event.type = event.type.replace('mouse', 'pointer');
        }
        if (event.type.startsWith('touch')) {
            event.type = TOUCH_TO_POINTER[event.type] || event.type;
        }
        return event;
    }
    transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = clock.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.shiftKey = nativeEvent.shiftKey;
        event.metaKey = nativeEvent.metaKey;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.relatedTarget = null;
    }
    isEventOutsideOfTargetViewPort(nativeEvent) {
        if (this.isEventOutsideOfTargetElement(nativeEvent)) {
            return true;
        }
        if (this.domElement.getViewBox) {
            const p = this.mapToViewportPoint(this.mapToCanvasPoint(nativeEvent));
            const b = this.domElement.getViewBox();
            const w = b.width();
            const h = b.height();
            const contain = p.x < w && p.y < h && p.x > 0 && p.y > 0;
            return !contain;
        }
        return false;
    }
    isEventOutsideOfTargetElement(nativeEvent) {
        let target = nativeEvent.target;
        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
            target = nativeEvent.composedPath()[0];
        }
        const nativeElement = this.domElement.getNativeHandler
            ? this.domElement.getNativeHandler().nativeCanvas
            : this.domElement;
        return target !== nativeElement;
    }
    pauseTriggerEvent() {
        this.manager.pauseNotify = true;
    }
    resumeTriggerEvent() {
        this.manager.pauseNotify = false;
    }
}

const PARALLEL_NUMBER = 10;
class ResourceLoader {
    static GetImage(url, mark) {
        var _a;
        const data = ResourceLoader.cache.get(url);
        if (data) {
            if (data.loadState === 'fail') {
                application.global.getRequestAnimationFrame()(() => {
                    mark.imageLoadFail(url);
                });
            }
            else if (data.loadState === 'init' || data.loadState === 'loading') {
                (_a = data.waitingMark) === null || _a === void 0 ? void 0 : _a.push(mark);
            }
            else if (mark) {
                mark.imageLoadSuccess(url, data.data);
            }
        }
        else {
            ResourceLoader.loadImage(url, mark);
        }
    }
    static GetSvg(svgStr, mark) {
        var _a;
        let data = ResourceLoader.cache.get(svgStr);
        if (data) {
            if (data.loadState === 'fail') {
                application.global.getRequestAnimationFrame()(() => {
                    mark.imageLoadFail(svgStr);
                });
            }
            else if (data.loadState === 'init' || data.loadState === 'loading') {
                (_a = data.waitingMark) === null || _a === void 0 ? void 0 : _a.push(mark);
            }
            else if (mark) {
                mark.imageLoadSuccess(svgStr, data.data);
            }
        }
        else {
            data = { type: 'image', loadState: 'init' };
            ResourceLoader.cache.set(svgStr, data);
            data.dataPromise = application.global.loadSvg(svgStr);
            if (!data.dataPromise) {
                data.loadState = 'fail';
                mark.imageLoadFail(svgStr);
            }
            else {
                data.waitingMark = [mark];
                data.dataPromise.then(res => {
                    var _a;
                    data.loadState = (res === null || res === void 0 ? void 0 : res.data) ? 'success' : 'fail';
                    data.data = res === null || res === void 0 ? void 0 : res.data;
                    (_a = data.waitingMark) === null || _a === void 0 ? void 0 : _a.map((mark, index) => {
                        if (res === null || res === void 0 ? void 0 : res.data) {
                            data.loadState = 'success';
                            data.data = res.data;
                            mark.imageLoadSuccess(svgStr, res.data);
                        }
                        else {
                            data.loadState = 'fail';
                            mark.imageLoadFail(svgStr);
                        }
                    });
                    data.waitingMark && (data.waitingMark = []);
                });
            }
        }
    }
    static GetFile(url, type) {
        let data = ResourceLoader.cache.get(url);
        if (data) {
            if (data.loadState === 'fail') {
                return Promise.reject();
            }
            else if (data.loadState === 'init' || data.loadState === 'loading') {
                return data.dataPromise.then(data => data.data);
            }
            return Promise.resolve(data.data);
        }
        data = { type, loadState: 'init' };
        ResourceLoader.cache.set(url, data);
        if (type === 'arrayBuffer') {
            data.dataPromise = application.global.loadArrayBuffer(url);
        }
        else if (type === 'blob') {
            data.dataPromise = application.global.loadBlob(url);
        }
        else if (type === 'json') {
            data.dataPromise = application.global.loadJson(url);
        }
        return data.dataPromise.then(data => data.data);
    }
    static loading() {
        setTimeout(() => {
            if (!ResourceLoader.isLoading && ResourceLoader.toLoadAueue.length) {
                ResourceLoader.isLoading = true;
                const tasks = ResourceLoader.toLoadAueue.splice(0, PARALLEL_NUMBER);
                const promises = [];
                tasks.forEach(task => {
                    const { url, marks } = task;
                    const data = { type: 'image', loadState: 'init' };
                    ResourceLoader.cache.set(url, data);
                    data.dataPromise = application.global.loadImage(url);
                    if (!data.dataPromise) {
                        data.loadState = 'fail';
                        marks.forEach(mark => mark.imageLoadFail(url));
                    }
                    else {
                        data.waitingMark = marks;
                        const end = data.dataPromise.then(res => {
                            var _a;
                            data.loadState = (res === null || res === void 0 ? void 0 : res.data) ? 'success' : 'fail';
                            data.data = res === null || res === void 0 ? void 0 : res.data;
                            (_a = data.waitingMark) === null || _a === void 0 ? void 0 : _a.map((mark, index) => {
                                if (res === null || res === void 0 ? void 0 : res.data) {
                                    data.loadState = 'success';
                                    data.data = res.data;
                                    mark.imageLoadSuccess(url, res.data);
                                }
                                else {
                                    data.loadState = 'fail';
                                    mark.imageLoadFail(url);
                                }
                            });
                            data.waitingMark && (data.waitingMark = []);
                        });
                        promises.push(end);
                    }
                });
                Promise.all(promises)
                    .then(() => {
                    ResourceLoader.isLoading = false;
                    this.onLoadSuccessCb.forEach(cb => cb());
                    ResourceLoader.loading();
                })
                    .catch(error => {
                    console.error(error);
                    ResourceLoader.isLoading = false;
                    this.onLoadSuccessCb.forEach(cb => cb());
                    ResourceLoader.loading();
                });
            }
        }, 0);
    }
    static loadImage(url, mark) {
        const index = getIndex(url, ResourceLoader.toLoadAueue);
        if (index !== -1) {
            ResourceLoader.toLoadAueue[index].marks.push(mark);
            ResourceLoader.loading();
            return;
        }
        ResourceLoader.toLoadAueue.push({ url, marks: [mark] });
        ResourceLoader.loading();
    }
    static improveImageLoading(url) {
        const index = getIndex(url, ResourceLoader.toLoadAueue);
        if (index !== -1) {
            const elememt = ResourceLoader.toLoadAueue.splice(index, 1);
            ResourceLoader.toLoadAueue.unshift(elememt[0]);
        }
    }
    static onLoadSuccess(cb) {
        this.onLoadSuccessCb.push(cb);
    }
}
ResourceLoader.cache = new Map();
ResourceLoader.isLoading = false;
ResourceLoader.toLoadAueue = [];
ResourceLoader.onLoadSuccessCb = [];
function getIndex(url, arr) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i].url === url) {
            return i;
        }
    }
    return -1;
}

var Edge;
(function (Edge) {
    Edge[Edge["Top"] = 1] = "Top";
    Edge[Edge["Right"] = 2] = "Right";
    Edge[Edge["Bottom"] = 4] = "Bottom";
    Edge[Edge["Left"] = 8] = "Left";
    Edge[Edge["ALL"] = 15] = "ALL";
})(Edge || (Edge = {}));
const _strokeVec4 = [
    false,
    false,
    false,
    false
];
const parseStroke = (stroke) => {
    var _a;
    let isFullStroke = true;
    if (isBoolean(stroke, true)) {
        for (let i = 0; i < 4; i++) {
            _strokeVec4[i] = stroke;
            isFullStroke && (isFullStroke = !!((_a = _strokeVec4[i]) !== null && _a !== void 0 ? _a : true));
        }
        isFullStroke = stroke;
    }
    else if (Array.isArray(stroke)) {
        for (let i = 0; i < 4; i++) {
            _strokeVec4[i] = !!stroke[i];
            isFullStroke && (isFullStroke = !!_strokeVec4[i]);
        }
    }
    else {
        _strokeVec4[0] = false;
        _strokeVec4[1] = false;
        _strokeVec4[2] = false;
        _strokeVec4[3] = false;
    }
    return {
        isFullStroke,
        stroke: _strokeVec4
    };
};
const _paddingVec4 = [0, 0, 0, 0];
const parsePadding = (padding) => {
    if (!padding) {
        return 0;
    }
    if (isArray(padding)) {
        if (padding.length === 0) {
            return 0;
        }
        else if (padding.length === 1) {
            return padding[0];
        }
        else if (padding.length === 2) {
            _paddingVec4[0] = padding[0];
            _paddingVec4[2] = padding[0];
            _paddingVec4[1] = padding[1];
            _paddingVec4[3] = padding[1];
            return _paddingVec4;
        }
        return padding;
    }
    return padding;
};
const _coords = [
    { x: 0, y: 0 },
    { x: 0, y: 0 },
    { x: 0, y: 0 },
    { x: 0, y: 0 }
];
const indexList = [1, 2, 3, 0, 1, 2, 3, 0];
function circleBounds(startAngle, endAngle, radius, bounds) {
    while (startAngle >= pi2) {
        startAngle -= pi2;
    }
    while (startAngle < 0) {
        startAngle += pi2;
    }
    while (startAngle > endAngle) {
        endAngle += pi2;
    }
    _coords[0].x = radius;
    _coords[1].y = radius;
    _coords[2].x = -radius;
    _coords[3].y = -radius;
    const startIdx = Math.ceil(startAngle / halfPi$1) % 4;
    const endIdx = Math.ceil(endAngle / halfPi$1) % 4;
    bounds.add(cos(startAngle) * radius, sin(startAngle) * radius);
    bounds.add(cos(endAngle) * radius, sin(endAngle) * radius);
    if (startIdx !== endIdx || endAngle - startAngle > pi) {
        let match = false;
        for (let i = 0; i < indexList.length; i++) {
            if (!match && startIdx === indexList[i]) {
                match = true;
                const p = _coords[startIdx];
                bounds.add(p.x, p.y);
                continue;
            }
            else if (match && endIdx === indexList[i]) {
                break;
            }
            if (match) {
                const p = _coords[indexList[i]];
                bounds.add(p.x, p.y);
            }
        }
    }
}
function pointsEqual(pointsA, pointsB) {
    if (!pointsA || !pointsB) {
        return false;
    }
    if (Array.isArray(pointsA) && Array.isArray(pointsB)) {
        if (pointsA.length !== pointsB.length) {
            return false;
        }
        return pointsA.every((point, index) => pointEqual(point, pointsB[index]));
    }
    if (!Number.isNaN(pointsA.x + pointsA.y)) {
        return pointEqual(pointsA, pointsB);
    }
    return false;
}
function pointEqual(pointA, pointB) {
    return (pointA.x === pointB.x &&
        pointA.y === pointB.y &&
        pointA.x1 === pointB.x1 &&
        pointA.y1 === pointB.y1 &&
        pointA.defined === pointB.defined);
}
function pointInterpolation(pointA, pointB, ratio) {
    const { x, y } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio);
    const { x: x1, y: y1 } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio);
    const point = new Point(x, y, x1, y1);
    point.defined = pointB.defined;
    return point;
}
function pointInterpolationHighPerformance(pointA, pointB, ratio, point) {
    const { x, y } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio);
    const { x: x1, y: y1 } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio);
    point.x = x;
    point.y = y;
    point.x1 = x1;
    point.y1 = y1;
    point.defined = pointB.defined;
    return point;
}
function pointsInterpolation(pointsA, pointsB, ratio) {
    if (!pointsA || !pointsB) {
        return [];
    }
    if (!Array.isArray(pointsA)) {
        pointsA = [pointsA];
    }
    if (!Array.isArray(pointsB)) {
        pointsB = [pointsB];
    }
    let points = [];
    if (pointsA.length > pointsB.length) {
        points = pointsB.map(point => {
            const p = new Point(point.x, point.y, point.x1, point.y1);
            p.defined = point.defined;
            return p;
        });
        for (let i = 0; i < pointsB.length; i++) {
            points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
        }
    }
    else {
        points = pointsB.map(point => {
            const p = new Point(point.x, point.y, point.x1, point.y1);
            p.defined = point.defined;
            return p;
        });
        for (let i = 0; i < pointsA.length; i++) {
            points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
        }
    }
    return points;
}
function getAttributeFromDefaultAttrList(attr, key) {
    if (isArray(attr)) {
        let val;
        for (let i = 0; i < attr.length && val === undefined; i++) {
            val = attr[i][key];
        }
        return val;
    }
    return attr[key];
}
class RafBasedSTO {
    constructor(timeout = RafBasedSTO.TimeOut) {
        this.durations = [];
        this.timeout = timeout;
        this.lastDate = 0;
        this.durationsListThreshold = 30;
    }
    call(cb) {
        this.lastDate = Date.now();
        return setTimeout(() => {
            this.appendDuration(Date.now() - this.lastDate);
            cb(0);
        }, this.timeout, true);
    }
    clear(h) {
        clearTimeout(h);
    }
    appendDuration(d) {
        this.durations.push(d);
        if (this.durations.length > this.durationsListThreshold) {
            this.durations.shift();
        }
        this.timeout = Math.min(Math.max(this.durations.reduce((a, b) => a + b, 0) / this.durations.length, 1000 / 60), 1000 / 30);
    }
}
RafBasedSTO.TimeOut = 1000 / 60;
const rafBasedSto = new RafBasedSTO();
const _calculateLineHeight = (lineHeight, fontSize) => {
    if (isString(lineHeight) && lineHeight[lineHeight.length - 1] === '%') {
        const scale = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
        return fontSize * scale;
    }
    return lineHeight;
};
const calculateLineHeight = (lineHeight, fontSize) => {
    const _lh = _calculateLineHeight(lineHeight, fontSize);
    return isNaN(_lh) ? _lh : Math.max(fontSize, _lh);
};

class BaseSymbol {
    bounds(size, bounds) {
        if (isNumber$1(size)) {
            const halfS = size / 2;
            bounds.x1 = -halfS;
            bounds.x2 = halfS;
            bounds.y1 = -halfS;
            bounds.y2 = halfS;
        }
        else {
            bounds.x1 = -size[0] / 2;
            bounds.x2 = size[0] / 2;
            bounds.y1 = -size[1] / 2;
            bounds.y2 = size[1] / 2;
        }
    }
    parseSize(size) {
        return isNumber$1(size) ? size : Math.min(size[0], size[1]);
    }
}

function circle(ctx, r, x, y, z) {
    if (z) {
        ctx.arc(x, y, r, 0, tau, false, z);
    }
    else {
        ctx.arc(x, y, r, 0, tau);
    }
    return false;
}
class CircleSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'circle';
        this.pathStr = 'M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0';
    }
    draw(ctx, size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return circle(ctx, r, x, y, z);
    }
    drawOffset(ctx, size, x, y, offset, z) {
        const r = this.parseSize(size) / 2 + offset;
        return circle(ctx, r, x, y, z);
    }
    drawToSvgPath(size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return `M ${x - r}, ${y} a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${r * 2},0`;
    }
}
var circle$1 = new CircleSymbol();

function cross(ctx, r, x, y, z) {
    ctx.moveTo(-3 * r + x, -r + y, z);
    ctx.lineTo(-r + x, -r + y, z);
    ctx.lineTo(-r + x, -3 * r + y, z);
    ctx.lineTo(r + x, -3 * r + y, z);
    ctx.lineTo(r + x, -r + y, z);
    ctx.lineTo(3 * r + x, -r + y, z);
    ctx.lineTo(3 * r + x, r + y, z);
    ctx.lineTo(r + x, r + y, z);
    ctx.lineTo(r + x, 3 * r + y, z);
    ctx.lineTo(-r + x, 3 * r + y, z);
    ctx.lineTo(-r + x, r + y, z);
    ctx.lineTo(-3 * r + x, r + y, z);
    ctx.closePath();
    return true;
}
function crossOffset(ctx, r, x, y, offset, z) {
    ctx.moveTo(-3 * r + x - offset, -r + y - offset, z);
    ctx.lineTo(-r + x - offset, -r + y - offset, z);
    ctx.lineTo(-r + x - offset, -3 * r + y - offset, z);
    ctx.lineTo(r + x + offset, -3 * r + y - offset, z);
    ctx.lineTo(r + x + offset, -r + y - offset, z);
    ctx.lineTo(3 * r + x + offset, -r + y - offset, z);
    ctx.lineTo(3 * r + x + offset, r + y + offset, z);
    ctx.lineTo(r + x + offset, r + y + offset, z);
    ctx.lineTo(r + x + offset, 3 * r + y + offset, z);
    ctx.lineTo(-r + x - offset, 3 * r + y + offset, z);
    ctx.lineTo(-r + x - offset, r + y + offset, z);
    ctx.lineTo(-3 * r + x - offset, r + y + offset, z);
    ctx.closePath();
    return true;
}
class CrossSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'cross';
        this.pathStr = 'M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z';
    }
    draw(ctx, size, x, y, z) {
        const r = this.parseSize(size) / 6;
        return cross(ctx, r, x, y, z);
    }
    drawOffset(ctx, size, x, y, offset, z) {
        const r = this.parseSize(size) / 6;
        return crossOffset(ctx, r, x, y, offset, z);
    }
}
var cross$1 = new CrossSymbol();

function diamond(ctx, r, x, y, z) {
    ctx.moveTo(x, y - r, z);
    ctx.lineTo(r + x, y, z);
    ctx.lineTo(x, y + r, z);
    ctx.lineTo(x - r, y, z);
    ctx.closePath();
    return true;
}
class DiamondSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'diamond';
        this.pathStr = 'M-0.5,0L0,-0.5L0.5,0L0,0.5Z';
    }
    draw(ctx, size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return diamond(ctx, r, x, y, z);
    }
    drawFitDir(ctx, size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return diamond(ctx, r, x, y, z);
    }
    drawOffset(ctx, size, x, y, offset, z) {
        const r = this.parseSize(size) / 2 + offset;
        return diamond(ctx, r, x, y, z);
    }
}
var diamond$1 = new DiamondSymbol();

function square(ctx, r, x, y) {
    const wh = r * 2;
    ctx.rect(x - r, y - r, wh, wh);
    return false;
}
class SquareSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'square';
        this.pathStr = 'M-0.5,-0.5h1v1h-1Z';
    }
    draw(ctx, size, x, y) {
        const r = this.parseSize(size) / 2;
        return square(ctx, r, x, y);
    }
    drawOffset(ctx, size, x, y, offset) {
        const r = this.parseSize(size) / 2 + offset;
        return square(ctx, r, x, y);
    }
}
var square$1 = new SquareSymbol();

function trianglUpOffset(ctx, r, x, y, offset = 0) {
    ctx.moveTo(x + r + offset * 2, r + y + offset);
    ctx.lineTo(x - r - offset * 2, r + y + offset);
    ctx.lineTo(x, y - r - offset * 2);
    ctx.closePath();
    return true;
}
class TriangleUpSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'triangleUp';
        this.pathStr = 'M0.5,0.5 L-0.5,0.5 L0,-0.5 Z';
    }
    draw(ctx, size, x, y) {
        const r = this.parseSize(size) / 2;
        return trianglUpOffset(ctx, r, x, y);
    }
    drawOffset(ctx, size, x, y, offset) {
        const r = this.parseSize(size) / 2;
        return trianglUpOffset(ctx, r, x, y, offset);
    }
}
var triangleUp = new TriangleUpSymbol();

class TriangleSymbol extends TriangleUpSymbol {
    constructor() {
        super(...arguments);
        this.type = 'triangle';
    }
}
var triangle = new TriangleSymbol();

const kr = Math.sin(Math.PI / 10) / Math.sin((7 * Math.PI) / 10);
const kx = Math.sin(tau / 10) * kr;
const ky = -Math.cos(tau / 10) * kr;
function star(ctx, r, transX, transY) {
    const x = kx * r;
    const y = ky * r;
    ctx.moveTo(transX, -r + transY);
    ctx.lineTo(x + transX, y + transY);
    for (let i = 1; i < 5; ++i) {
        const a = (tau * i) / 5;
        const c = Math.cos(a);
        const s = Math.sin(a);
        ctx.lineTo(s * r + transX, -c * r + transY);
        ctx.lineTo(c * x - s * y + transX, s * x + c * y + transY);
    }
    ctx.closePath();
    return true;
}
class StarSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'star';
        this.pathStr = 'M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z';
    }
    draw(ctx, size, transX, transY) {
        const r = this.parseSize(size) / 2;
        return star(ctx, r, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        const r = this.parseSize(size) / 2 + offset;
        return star(ctx, r, transX, transY);
    }
}
var star$1 = new StarSymbol();

const sqrt3$1 = sqrt(3);
function arrow(ctx, r, transX, transY) {
    const triangleH = r;
    const trangleBottomSide = triangleH / sqrt3$1;
    const rectW = trangleBottomSide / 5;
    const rectH = r;
    ctx.moveTo(0 + transX, -triangleH + transY);
    ctx.lineTo(trangleBottomSide / 2 + transX, transY);
    ctx.lineTo(rectW / 2 + transX, transY);
    ctx.lineTo(rectW / 2 + transX, rectH + transY);
    ctx.lineTo(-rectW / 2 + transX, rectH + transY);
    ctx.lineTo(-rectW / 2 + transX, transY);
    ctx.lineTo(-trangleBottomSide / 2 + transX, transY);
    ctx.closePath();
    return true;
}
class ArrowSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'arrow';
        this.pathStr = 'M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z';
    }
    draw(ctx, size, transX, transY) {
        const r = this.parseSize(size) / 2;
        return arrow(ctx, r, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        const r = this.parseSize(size) / 2 + offset;
        return arrow(ctx, r, transX, transY);
    }
}
var arrow$1 = new ArrowSymbol();

function wedge(ctx, r, transX, transY) {
    const h = r * 2;
    ctx.moveTo(transX, -r + transY);
    ctx.lineTo(h / 3 / 2 + transX, r + transY);
    ctx.lineTo(-h / 3 / 2 + transX, r + transY);
    ctx.closePath();
    return true;
}
class WedgeSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'wedge';
        this.pathStr = 'M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z';
    }
    draw(ctx, size, transX, transY) {
        const r = this.parseSize(size) / 2;
        return wedge(ctx, r, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        const r = this.parseSize(size) / 2 + offset;
        return wedge(ctx, r, transX, transY);
    }
}
var wedge$1 = new WedgeSymbol();

function stroke(ctx, r, transX, transY) {
    ctx.moveTo(-r + transX, transY);
    ctx.lineTo(transX, r + transY);
    return false;
}
class StrokeSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'stroke';
        this.pathStr = '';
    }
    draw(ctx, size, transX, transY) {
        const r = this.parseSize(size) / 2;
        return stroke(ctx, r, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        const r = this.parseSize(size) / 2 + offset;
        return stroke(ctx, r, transX, transY);
    }
}
var stroke$1 = new StrokeSymbol();

const c = -0.5;
const s = sqrt(3) / 2;
const k = 1 / sqrt(12);
function wye(ctx, r, transX, transY) {
    const x0 = r / 2;
    const y0 = r * k;
    const x1 = x0;
    const y1 = r * k + r;
    const x2 = -x1;
    const y2 = y1;
    ctx.moveTo(x0 + transX, y0 + transY);
    ctx.lineTo(x1 + transX, y1 + transY);
    ctx.lineTo(x2 + transX, y2 + transY);
    ctx.lineTo(c * x0 - s * y0 + transX, s * x0 + c * y0 + transY);
    ctx.lineTo(c * x1 - s * y1 + transX, s * x1 + c * y1 + transY);
    ctx.lineTo(c * x2 - s * y2 + transX, s * x2 + c * y2 + transY);
    ctx.lineTo(c * x0 + s * y0 + transX, c * y0 - s * x0 + transY);
    ctx.lineTo(c * x1 + s * y1 + transX, c * y1 - s * x1 + transY);
    ctx.lineTo(c * x2 + s * y2 + transX, c * y2 - s * x2 + transY);
    ctx.closePath();
    return false;
}
class WyeSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'wye';
        this.pathStr = 'M0.25 0.14433756729740646L0.25 0.6443375672974064L-0.25 0.6443375672974064L-0.25 0.14433756729740643L-0.6830127018922193 -0.10566243270259357L-0.4330127018922193 -0.5386751345948129L0 -0.28867513459481287L0.4330127018922193 -0.5386751345948129L0.6830127018922193 -0.10566243270259357Z';
    }
    draw(ctx, size, transX, transY) {
        const r = this.parseSize(size) / 2;
        return wye(ctx, r, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        const r = this.parseSize(size) / 2 + offset;
        return wye(ctx, r, transX, transY);
    }
}
var wye$1 = new WyeSymbol();

function trianglLeftOffset(ctx, r, x, y, offset) {
    ctx.moveTo(-r + x - 2 * offset, y);
    ctx.lineTo(r + x + offset, r + y + 2 * offset);
    ctx.lineTo(r + x + offset, y - r - 2 * offset);
    ctx.closePath();
    return true;
}
class TriangleLeftSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'triangleLeft';
        this.pathStr = 'M-0.5,0 L0.5,0.5 L0.5,-0.5 Z';
    }
    draw(ctx, size, x, y) {
        const r = this.parseSize(size) / 2;
        return trianglLeftOffset(ctx, r, x, y, 0);
    }
    drawOffset(ctx, size, x, y, offset) {
        const r = this.parseSize(size) / 2;
        return trianglLeftOffset(ctx, r, x, y, offset);
    }
}
var triangleLeft = new TriangleLeftSymbol();

function trianglRightOffset(ctx, r, x, y, offset = 0) {
    ctx.moveTo(x - r - offset, r + y + 2 * offset);
    ctx.lineTo(r + x + 2 * offset, y);
    ctx.lineTo(x - r - offset, y - r - 2 * offset);
    ctx.closePath();
    return true;
}
class TriangleRightSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'triangleRight';
        this.pathStr = 'M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z';
    }
    draw(ctx, size, x, y) {
        const r = this.parseSize(size) / 2;
        return trianglRightOffset(ctx, r, x, y);
    }
    drawOffset(ctx, size, x, y, offset) {
        const r = this.parseSize(size) / 2;
        return trianglRightOffset(ctx, r, x, y, offset);
    }
}
var triangleRight = new TriangleRightSymbol();

function trianglDownOffset(ctx, r, x, y, offset = 0) {
    ctx.moveTo(x - r - offset * 2, y - r - offset);
    ctx.lineTo(x + r + offset * 2, y - r - offset);
    ctx.lineTo(x, y + r + offset * 2);
    ctx.closePath();
    return true;
}
class TriangleDownSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'triangleDown';
        this.pathStr = 'M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z';
    }
    draw(ctx, size, x, y) {
        const r = this.parseSize(size) / 2;
        return trianglDownOffset(ctx, r, x, y);
    }
    drawOffset(ctx, size, x, y, offset) {
        const r = this.parseSize(size) / 2;
        return trianglDownOffset(ctx, r, x, y, offset);
    }
}
var triangleDown = new TriangleDownSymbol();

const sqrt3 = sqrt(3);
function thinTriangle(ctx, r, x, y) {
    const h = r * sqrt3;
    ctx.moveTo(x, y + (-h / 3) * 2);
    ctx.lineTo(r + x, y + h);
    ctx.lineTo(x - r, y + h);
    ctx.closePath();
    return true;
}
class ThinTriangleSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'thinTriangle';
        this.pathStr = 'M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z';
    }
    draw(ctx, size, x, y) {
        const r = this.parseSize(size) / 2 / sqrt3;
        return thinTriangle(ctx, r, x, y);
    }
    drawOffset(ctx, size, x, y, offset) {
        const r = this.parseSize(size) / 2 / sqrt3 + offset;
        return thinTriangle(ctx, r, x, y);
    }
}
var thinTriangle$1 = new ThinTriangleSymbol();

function arrow2Left(ctx, r, transX, transY) {
    const r2 = r * 2;
    ctx.moveTo(r + transX, transY - r2);
    ctx.lineTo(transX - r, transY);
    ctx.lineTo(r + transX, r2 + transY);
    return true;
}
class Arrow2LeftSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'arrow2Left';
        this.pathStr = 'M 0.25 -0.5 L -0.25 0 l 0.25 0.5';
    }
    draw(ctx, size, transX, transY) {
        const r = this.parseSize(size) / 4;
        return arrow2Left(ctx, r, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        const r = this.parseSize(size) / 4 + offset;
        return arrow2Left(ctx, r, transX, transY);
    }
}
var arrow2Left$1 = new Arrow2LeftSymbol();

function arrow2Right(ctx, r, transX, transY) {
    const r2 = r * 2;
    ctx.moveTo(transX - r, transY - r2);
    ctx.lineTo(transX + r, transY);
    ctx.lineTo(transX - r, r2 + transY);
    return true;
}
class Arrow2RightSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'arrow2Right';
        this.pathStr = 'M -0.25 -0.5 l 0.25 0 l -0.25 0.5';
    }
    draw(ctx, size, transX, transY) {
        const r = this.parseSize(size) / 4;
        return arrow2Right(ctx, r, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        const r = this.parseSize(size) / 4 + offset;
        return arrow2Right(ctx, r, transX, transY);
    }
}
var arrow2Right$1 = new Arrow2RightSymbol();

function arrow2Up(ctx, r, transX, transY) {
    const r2 = r * 2;
    ctx.moveTo(transX - r2, transY + r);
    ctx.lineTo(transX, transY - r);
    ctx.lineTo(transX + r2, transY + r);
    return true;
}
class Arrow2UpSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'arrow2Up';
        this.pathStr = 'M -0.5 0.25 L 0 -0.25 l 0.5 0.25';
    }
    draw(ctx, size, transX, transY) {
        const r = this.parseSize(size) / 4;
        return arrow2Up(ctx, r, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        const r = this.parseSize(size) / 4 + offset;
        return arrow2Up(ctx, r, transX, transY);
    }
}
var arrow2Up$1 = new Arrow2UpSymbol();

function arrow2Down(ctx, r, transX, transY) {
    const r2 = r * 2;
    ctx.moveTo(transX - r2, transY - r);
    ctx.lineTo(transX, transY + r);
    ctx.lineTo(transX + r2, transY - r);
    return true;
}
class Arrow2DownSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'arrow2Down';
        this.pathStr = 'M -0.5 -0.25 L 0 0.25 l 0.5 -0.25';
    }
    draw(ctx, size, transX, transY) {
        const r = this.parseSize(size) / 4;
        return arrow2Down(ctx, r, transX, transY);
    }
    drawOffset(ctx, size, transX, transY, offset) {
        const r = this.parseSize(size) / 4 + offset;
        return arrow2Down(ctx, r, transX, transY);
    }
}
var arrow2Down$1 = new Arrow2DownSymbol();

function lineV(ctx, r, x, y, z) {
    ctx.moveTo(x, y - r);
    ctx.lineTo(x, y + r);
    return true;
}
class LineVSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'lineV';
        this.pathStr = 'M0,-0.5L0,0.5';
    }
    draw(ctx, size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return lineV(ctx, r, x, y);
    }
    drawOffset(ctx, size, x, y, offset, z) {
        const r = this.parseSize(size) / 2 + offset;
        return lineV(ctx, r, x, y);
    }
    drawToSvgPath(size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return `M ${x}, ${y - r} L ${x},${y + r}`;
    }
}
var lineV$1 = new LineVSymbol();

function lineH(ctx, r, x, y, z) {
    ctx.moveTo(x - r, y);
    ctx.lineTo(x + r, y);
    return true;
}
class LineHSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'lineH';
        this.pathStr = 'M-0.5,0L0.5,0';
    }
    draw(ctx, size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return lineH(ctx, r, x, y);
    }
    drawOffset(ctx, size, x, y, offset, z) {
        const r = this.parseSize(size) / 2 + offset;
        return lineH(ctx, r, x, y);
    }
    drawToSvgPath(size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return `M ${x - r}, ${y} L ${x + r},${y}`;
    }
}
var lineH$1 = new LineHSymbol();

function close(ctx, r, x, y, z) {
    ctx.moveTo(x - r, y - r);
    ctx.lineTo(x + r, y + r);
    ctx.moveTo(x + r, y - r);
    ctx.lineTo(x - r, y + r);
    return true;
}
class CloseSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'close';
        this.pathStr = 'M-0.5,-0.5L0.5,0.5,M0.5,-0.5L-0.5,0.5';
    }
    draw(ctx, size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return close(ctx, r, x, y);
    }
    drawOffset(ctx, size, x, y, offset, z) {
        const r = this.parseSize(size) / 2 + offset;
        return close(ctx, r, x, y);
    }
    drawToSvgPath(size, x, y, z) {
        const r = this.parseSize(size) / 2;
        return `M ${x - r}, ${y - r} L ${x + r},${y + r} M ${x + r}, ${y - r} L ${x - r},${y + r}`;
    }
}
var close$1 = new CloseSymbol();

function rectSizeArray(ctx, size, x, y) {
    ctx.rect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
    return false;
}
function rectSize(ctx, size, x, y) {
    const w = size;
    const h = size / 2;
    ctx.rect(x - w / 2, y - h / 2, w, h);
    return false;
}
class RectSymbol extends BaseSymbol {
    constructor() {
        super(...arguments);
        this.type = 'rect';
        this.pathStr = 'M -0.5,0.25 L 0.5,0.25 L 0.5,-0.25,L -0.5,-0.25 Z';
    }
    draw(ctx, size, x, y) {
        if (isNumber$1(size)) {
            return rectSize(ctx, size, x, y);
        }
        return rectSizeArray(ctx, size, x, y);
    }
    drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
        if (isNumber$1(size)) {
            size = [size, size / 2];
        }
        const totalLength = (size[0] + size[1]) * 2;
        const drawLength = totalLength * clipRange;
        const points = [
            { x: x + size[0] / 2, y: y - size[1] / 2 },
            { x: x + size[0] / 2, y: y + size[1] / 2 },
            { x: x - size[0] / 2, y: y + size[1] / 2 },
            { x: x - size[0] / 2, y: y - size[1] / 2 }
        ];
        let currLength = 0;
        let lastP = points[3];
        ctx.moveTo(lastP.x, lastP.y);
        for (let i = 0; i < points.length; i++) {
            const p = points[i];
            const len = Math.sqrt((p.x - lastP.x) * (p.x - lastP.x) + (p.y - lastP.y) * (p.y - lastP.y));
            if (currLength + len > drawLength) {
                const dx = ((p.x - lastP.x) * (drawLength - currLength)) / len;
                const dy = ((p.y - lastP.y) * (drawLength - currLength)) / len;
                ctx.lineTo(lastP.x + dx, lastP.y + dy);
                break;
            }
            else {
                ctx.lineTo(p.x, p.y);
            }
            lastP = p;
            currLength += len;
        }
        return false;
    }
    drawOffset(ctx, size, x, y, offset) {
        if (isNumber$1(size)) {
            return rectSize(ctx, size + 2 * offset, x, y);
        }
        return rectSizeArray(ctx, [size[0] + 2 * offset, size[1] + 2 * offset], x, y);
    }
}
var rect = new RectSymbol();

const tempBounds = new AABBBounds();
class CustomSymbolClass {
    constructor(type, path, isSvg = false) {
        this.pathStr = '';
        this.type = type;
        if (isArray(path)) {
            this.svgCache = path;
        }
        else {
            this.path = path;
        }
        this.isSvg = isSvg;
    }
    drawOffset(ctx, size, x, y, offset, z, cb) {
        size = this.parseSize(size);
        if (this.isSvg) {
            if (!this.svgCache) {
                return false;
            }
            this.svgCache.forEach(item => {
                ctx.beginPath();
                renderCommandList(item.path.commandList, ctx, x, y, size, size);
                cb && cb(item.path, item.attribute);
            });
            return false;
        }
        renderCommandList(this.path.commandList, ctx, x, y, size + offset, size + offset);
        return false;
    }
    draw(ctx, size, x, y, z, cb) {
        size = this.parseSize(size);
        return this.drawOffset(ctx, size, x, y, 0, z, cb);
    }
    parseSize(size) {
        return isNumber$1(size) ? size : Math.min(size[0], size[1]);
    }
    drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
        size = this.parseSize(size);
        if (this.isSvg) {
            if (!this.svgCache) {
                return false;
            }
            this.svgCache.forEach(item => {
                item.path.drawWithClipRange(ctx, size, x, y, clipRange);
                cb && cb(item.path, item.attribute);
            });
            return false;
        }
        this.path.drawWithClipRange(ctx, size, x, y, clipRange);
        return false;
    }
    bounds(size, bounds) {
        size = this.parseSize(size);
        if (this.isSvg) {
            if (!this.svgCache) {
                return;
            }
            bounds.clear();
            this.svgCache.forEach(({ path }) => {
                tempBounds.x1 = path.bounds.x1 * size;
                tempBounds.y1 = path.bounds.y1 * size;
                tempBounds.x2 = path.bounds.x2 * size;
                tempBounds.y2 = path.bounds.y2 * size;
                bounds.union(tempBounds);
            });
            return;
        }
        if (!this.path.bounds) {
            return;
        }
        bounds.x1 = this.path.bounds.x1 * size;
        bounds.y1 = this.path.bounds.y1 * size;
        bounds.x2 = this.path.bounds.x2 * size;
        bounds.y2 = this.path.bounds.y2 * size;
    }
}

const builtinSymbols = [
    circle$1,
    cross$1,
    diamond$1,
    square$1,
    thinTriangle$1,
    triangle,
    star$1,
    arrow$1,
    wedge$1,
    stroke$1,
    wye$1,
    triangleLeft,
    triangleRight,
    triangleUp,
    triangleDown,
    arrow2Left$1,
    arrow2Right$1,
    arrow2Up$1,
    arrow2Down$1,
    rect,
    lineV$1,
    lineH$1,
    close$1
];
const builtinSymbolsMap = {};
builtinSymbols.forEach(symbol => {
    builtinSymbolsMap[symbol.type] = symbol;
});
const builtInSymbolStrMap = {
    arrowLeft: 'M 0.25 -0.5 L -0.25 0 l 0.5 0.5',
    arrowRight: 'M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5',
    rectRound: 'M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z',
    roundLine: 'M 1.2392 -0.258 L -1.3432 -0.258 C -1.4784 -0.258 -1.588 -0.1436 -1.588 -0.002 c 0 0.1416 0.1096 0.256 0.2448 0.256 l 2.5824 0 c 0.1352 0 0.2448 -0.1144 0.2448 -0.256 C 1.484 -0.1436 1.3744 -0.258 1.2392 -0.258 z'
};

function getAllMatches(string, regex) {
    const matches = [];
    let match = regex.exec(string);
    while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len = match.length;
        for (let index = 0; index < len; index++) {
            allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
    }
    return matches;
}

class XmlNode {
    constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[':@'] = {};
    }
    add(key, val) {
        if (key === '__proto__') {
            key = '#__proto__';
        }
        this.child.push({ [key]: val });
    }
    addChild(node) {
        if (node.tagname === '__proto__') {
            node.tagname = '#__proto__';
        }
        if (node[':@'] && Object.keys(node[':@']).length > 0) {
            this.child.push({ [node.tagname]: node.child, [':@']: node[':@'] });
        }
        else {
            this.child.push({ [node.tagname]: node.child });
        }
    }
}
function findClosingIndex(xmlData, str, i, errMsg) {
    const closingIndex = xmlData.indexOf(str, i);
    if (closingIndex === -1) {
        throw new Error(errMsg);
    }
    else {
        return closingIndex + str.length - 1;
    }
}
function tagExpWithClosingIndex(xmlData, i, closingChar = '>') {
    let attrBoundary;
    let tagExp = '';
    for (let index = i; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
            if (ch === attrBoundary) {
                attrBoundary = '';
            }
        }
        else if (ch === '"' || ch === "'") {
            attrBoundary = ch;
        }
        else if (ch === closingChar[0]) {
            if (closingChar[1]) {
                if (xmlData[index + 1] === closingChar[1]) {
                    return {
                        data: tagExp,
                        index: index
                    };
                }
            }
            else {
                return {
                    data: tagExp,
                    index: index
                };
            }
        }
        else if (ch === '\t') {
            ch = ' ';
        }
        tagExp += ch;
    }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = '>') {
    const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
    if (!result) {
        return;
    }
    let tagExp = result.data;
    const closeIndex = result.index;
    const separatorIndex = tagExp.search(/\s/);
    let tagName = tagExp;
    let attrExpPresent = true;
    if (separatorIndex !== -1) {
        tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, '');
        tagExp = tagExp.substr(separatorIndex + 1);
    }
    const rawTagName = tagName;
    if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(':');
        if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
    }
    return {
        tagName: tagName,
        tagExp: tagExp,
        closeIndex: closeIndex,
        attrExpPresent: attrExpPresent,
        rawTagName: rawTagName
    };
}
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');
class OrderedObjParser {
    constructor(options) {
        this.currentNode = null;
        this.options = options;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
    }
    addChild(currentNode, childNode, jPath) {
        const result = childNode.tagname;
        if (typeof result === 'string') {
            childNode.tagname = result;
            currentNode.addChild(childNode);
        }
        else {
            currentNode.addChild(childNode);
        }
    }
    buildAttributesMap(attrStr, jPath, tagName) {
        const attrs = {};
        if (!attrStr) {
            return;
        }
        const matches = getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        for (let i = 0; i < len; i++) {
            const attrName = matches[i][1];
            const oldVal = matches[i][4];
            const aName = attrName;
            if (attrName) {
                if (oldVal !== undefined) {
                    attrs[aName] = isNaN(oldVal) ? oldVal : Number(oldVal);
                }
                else {
                    attrs[aName] = true;
                }
            }
        }
        return attrs;
    }
    parseXml(xmlData) {
        xmlData = xmlData.replace(/\r\n?/g, '\n');
        const xmlObj = new XmlNode('!xml');
        let currentNode = xmlObj;
        let textData = '';
        let jPath = '';
        for (let i = 0; i < xmlData.length; i++) {
            const ch = xmlData[i];
            if (ch === '<') {
                if (xmlData[i + 1] === '/') {
                    const closeIndex = findClosingIndex(xmlData, '>', i, 'Closing Tag is not closed.');
                    const propIndex = jPath.lastIndexOf('.');
                    jPath = jPath.substring(0, propIndex);
                    currentNode = this.tagsNodeStack.pop();
                    if (currentNode && currentNode.child && textData) {
                        currentNode.child[currentNode.child.length - 1][':@'] &&
                            (currentNode.child[currentNode.child.length - 1][':@'].text = textData);
                    }
                    textData = '';
                    i = closeIndex;
                }
                else if (xmlData[i + 1] === '?') {
                    const tagData = readTagExp(xmlData, i, false, '?>');
                    i = tagData.closeIndex + 1;
                }
                else if (xmlData.substr(i + 1, 3) === '!--') {
                    const endIndex = findClosingIndex(xmlData, '-->', i + 4, 'Comment is not closed.');
                    i = endIndex;
                }
                else {
                    const result = readTagExp(xmlData, i, false);
                    let tagName = result.tagName;
                    let tagExp = result.tagExp;
                    const attrExpPresent = result.attrExpPresent;
                    const closeIndex = result.closeIndex;
                    if (tagName !== xmlObj.tagname) {
                        jPath += jPath ? '.' + tagName : tagName;
                    }
                    if (tagExp.length > 0 && tagExp.lastIndexOf('/') === tagExp.length - 1) {
                        if (tagName[tagName.length - 1] === '/') {
                            tagName = tagName.substr(0, tagName.length - 1);
                            jPath = jPath.substr(0, jPath.length - 1);
                            tagExp = tagName;
                        }
                        else {
                            tagExp = tagExp.substr(0, tagExp.length - 1);
                        }
                        const childNode = new XmlNode(tagName);
                        if (tagName !== tagExp && attrExpPresent) {
                            childNode[':@'] = this.buildAttributesMap(tagExp, jPath, tagName);
                        }
                        this.addChild(currentNode, childNode, jPath);
                        jPath = jPath.substr(0, jPath.lastIndexOf('.'));
                    }
                    else {
                        const childNode = new XmlNode(tagName);
                        this.tagsNodeStack.push(currentNode);
                        if (tagName !== tagExp && attrExpPresent) {
                            childNode[':@'] = this.buildAttributesMap(tagExp, jPath, tagName);
                        }
                        this.addChild(currentNode, childNode, jPath);
                        currentNode = childNode;
                    }
                    textData = '';
                    i = closeIndex;
                }
            }
            else {
                textData += xmlData[i];
            }
        }
        return xmlObj.child;
    }
}

function prettify(node, options) {
    return compress(node);
}
function compress(arr, jPath) {
    const compressedObj = {};
    for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const property = propName(tagObj);
        if (property === undefined) {
            continue;
        }
        else if (tagObj[property]) {
            const val = compress(tagObj[property]);
            isLeafTag(val);
            if (tagObj[':@']) {
                assignAttributes(val, tagObj[':@']);
            }
            if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
                if (!Array.isArray(compressedObj[property])) {
                    compressedObj[property] = [compressedObj[property]];
                }
                compressedObj[property].push(val);
            }
            else {
                compressedObj[property] = val;
            }
        }
    }
    return compressedObj;
}
function propName(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key !== ':@') {
            return key;
        }
    }
}
function assignAttributes(obj, attrMap, jpath) {
    if (attrMap) {
        const keys = Object.keys(attrMap);
        const len = keys.length;
        for (let i = 0; i < len; i++) {
            const atrrName = keys[i];
            obj[atrrName] = attrMap[atrrName];
        }
    }
}
function isLeafTag(obj) {
    const propCount = Object.keys(obj).length;
    if (propCount === 0) {
        return true;
    }
    return false;
}

class XMLParser {
    constructor(options) {
        this.options = Object.assign({}, XMLParser.defaultOptions, options);
    }
    valid(xml) {
        return xml.startsWith('<');
    }
    parse(xmlData) {
        if (!this.valid) {
            return false;
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        return prettify(orderedResult, this.options);
    }
}
XMLParser.defaultOptions = {};
function isSvg(str) {
    return str.startsWith('<svg') || str.startsWith('<?xml');
}
function isXML(str) {
    return str.startsWith('<');
}

function incrementalAddTo(group, graphic) {
    group.incrementalAppendChild(graphic);
}
function waitForAllSubLayers(stage) {
    return __awaiter(this, void 0, void 0, function* () {
        const promiseList = [];
        const layers = stage.getChildren();
        yield new Promise(resolve => {
            application.global.getRequestAnimationFrame()(() => {
                resolve(null);
            });
        });
        layers.forEach(l => {
            if (l.subLayers.size) {
                l.subLayers.forEach(sl => {
                    if (sl.drawContribution && sl.drawContribution.hooks && sl.drawContribution.rendering) {
                        promiseList.push(new Promise(resolve => {
                            sl.drawContribution.hooks.completeDraw.tap('outWait', () => {
                                sl.drawContribution.hooks.completeDraw.taps = sl.drawContribution.hooks.completeDraw.taps.filter(i => {
                                    return i.name !== 'outWait';
                                });
                                resolve(null);
                            });
                        }));
                    }
                });
            }
        });
        yield Promise.all(promiseList);
    });
}
function boundStroke(bounds, halfW, miter, pad = 0) {
    bounds.expand(halfW + (pad / 2 + (miter ? miterAdjustment(miter, halfW) : 0)));
    return bounds;
}
function miterAdjustment(miter, strokeWidth) {
    return miter ? strokeWidth : 0;
}
let NUMBER_TYPE = 0;
function genNumberType() {
    return NUMBER_TYPE++;
}
var TextDirection;
(function (TextDirection) {
    TextDirection[TextDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
    TextDirection[TextDirection["VERTICAL"] = 1] = "VERTICAL";
})(TextDirection || (TextDirection = {}));
function verticalLayout(text) {
    const nextCharacter = [];
    let flag = 0;
    let currStr = '';
    for (let i = 0; i < text.length; i++) {
        if (rotateText(text[i])) {
            if (flag) {
                currStr += text[i];
            }
            else {
                flag = 1;
                currStr = text[i];
            }
        }
        else {
            if (flag) {
                nextCharacter.push({
                    text: currStr,
                    direction: TextDirection.VERTICAL
                });
                currStr = '';
                flag = 0;
            }
            nextCharacter.push({
                text: text[i],
                direction: TextDirection.HORIZONTAL
            });
        }
    }
    if (currStr) {
        nextCharacter.push({
            text: currStr,
            direction: TextDirection.VERTICAL
        });
    }
    return nextCharacter;
}
const rotateCharList = ['…', '（', '）', '—', '【', '】', '「', '」', '《', '》'];
const rotateCharMap = new Map();
rotateCharList.forEach(c => rotateCharMap.set(c, true));
const noRotateCharList = [''];
const noRotateCharMap = new Map();
noRotateCharList.forEach(c => noRotateCharMap.set(c, true));
function rotateText(c) {
    if (rotateCharMap.has(c)) {
        return true;
    }
    if (noRotateCharMap.has(c)) {
        return false;
    }
    const cp = c.codePointAt(0);
    let rotate = false;
    if (cp < 256) {
        rotate = true;
    }
    return rotate;
}
function xul(str) {
    const xmlStr = isArray(str) ? str[0] : str;
    const config = [];
    if (!xmlStr) {
        return config;
    }
    const valid = isXML(xmlStr);
    if (valid === true) {
        const parser = new XMLParser();
        const data = parser.parse(xmlStr);
        data.tc &&
            Object.keys(data.tc).forEach(k => {
                if (k === 'text') {
                    config.push(parseRTTextXML(data.tc[k]));
                }
                else {
                    config.push(parseRTImageXML(data.tc[k]));
                }
            });
    }
    return config;
}
function parseRTTextXML(str) {
    const output = { text: '' };
    parseCommonXML(str, output);
    const inlineText = str['#text'];
    if (inlineText) {
        output.text = inlineText;
    }
    return output;
}
function parseCommonXML(str, output) {
    const attr = str.attribute;
    if (attr) {
        const attrList = attr.split(';');
        attrList.forEach((attrItem) => {
            if (!attrItem) {
                return;
            }
            const kv = attrItem.split(':');
            if (kv.length === 2) {
                const val = parseFloat(kv[1]);
                output[kv[0].trim()] = isFinite(val) ? val : kv[1].trim();
            }
            else {
                let val = '';
                for (let i = 1; i < kv.length; i++) {
                    if (i > 1) {
                        val += ':';
                    }
                    val += kv[i].trim();
                }
                output[kv[0].trim()] = val;
            }
        });
    }
}
function parseRTImageXML(str) {
    const output = { image: '', width: 0, height: 0 };
    parseCommonXML(str, output);
    const image = output.image;
    if (image) {
        output.image = image.replaceAll('&quot', '"').replaceAll('&lt', '<').replaceAll('&gt', '>');
    }
    return output;
}

const ARC_NUMBER_TYPE = genNumberType();
const ARC3D_NUMBER_TYPE = genNumberType();
const AREA_NUMBER_TYPE = genNumberType();
const CIRCLE_NUMBER_TYPE = genNumberType();
const GLYPH_NUMBER_TYPE = genNumberType();
const GROUP_NUMBER_TYPE = genNumberType();
const IMAGE_NUMBER_TYPE = genNumberType();
const LINE_NUMBER_TYPE = genNumberType();
const PATH_NUMBER_TYPE = genNumberType();
const POLYGON_NUMBER_TYPE = genNumberType();
const PYRAMID3D_NUMBER_TYPE = genNumberType();
const RECT_NUMBER_TYPE = genNumberType();
const RECT3D_NUMBER_TYPE = genNumberType();
const RICHTEXT_NUMBER_TYPE = genNumberType();
const STAR_NUMBER_TYPE = genNumberType();
const SYMBOL_NUMBER_TYPE = genNumberType();
const TEXT_NUMBER_TYPE = genNumberType();
const GraphicService = Symbol.for('GraphicService');
const GraphicCreator$1 = Symbol.for('GraphicCreator');
const SVG_ATTRIBUTE_MAP = {
    'stroke-linecap': 'lineCap',
    'stroke-linejoin': 'lineJoin',
    'stroke-dasharray': 'lineDash',
    'stroke-dashoffset': 'lineDashOffset',
    'stroke-width': 'lineWidth',
    'fill-opacity': 'fillOpacity',
    'stroke-opacity': 'strokeOpacity'
};
const SVG_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_ATTRIBUTE_MAP);
const SVG_PARSE_ATTRIBUTE_MAP = {
    'stroke-linecap': 'lineCap',
    'stroke-linejoin': 'lineJoin',
    'stroke-dasharray': 'lineDash',
    'stroke-dashoffset': 'lineDashOffset',
    'stroke-width': 'lineWidth',
    'fill-opacity': 'fillOpacity',
    'stroke-opacity': 'strokeOpacity',
    stroke: 'stroke',
    fill: 'fill'
};
const SVG_PARSE_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_PARSE_ATTRIBUTE_MAP);

const DefaultStateAnimateConfig = {
    duration: 200,
    easing: 'cubicOut'
};

function identityMat4(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}
function rotateX(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    if (a !== out) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
}
function rotateY(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    if (a !== out) {
        out[4] = a[4];
        out[5] = a[5];
        out[6] = a[6];
        out[7] = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
}
function rotateZ(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    if (a !== out) {
        out[8] = a[8];
        out[9] = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
}
function translate(out, a, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    }
    else {
        a00 = a[0];
        a01 = a[1];
        a02 = a[2];
        a03 = a[3];
        a10 = a[4];
        a11 = a[5];
        a12 = a[6];
        a13 = a[7];
        a20 = a[8];
        a21 = a[9];
        a22 = a[10];
        a23 = a[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
}
function mat3Tomat4(out, b) {
    out[0] = b.a;
    out[1] = b.b;
    out[2] = 0;
    out[3] = 0;
    out[4] = b.c;
    out[5] = b.d;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = b.e;
    out[13] = b.f;
    out[14] = 0;
    out[15] = 1;
}
function multiplyMat4Mat3(out, a, b) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    let b0 = b.a;
    let b1 = b.b;
    let b2 = 0;
    let b3 = 0;
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b.c;
    b1 = b.d;
    b2 = 0;
    b3 = 0;
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = 0;
    b1 = 0;
    b2 = 1;
    b3 = 0;
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b.e;
    b1 = b.f;
    b2 = 0;
    b3 = 1;
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}
function scaleMat4(out, a, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
}
function multiplyMat4Mat4(out, a, b) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    let b0 = b[0];
    let b1 = b[1];
    let b2 = b[2];
    let b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
}
function lookAt(out, eye, center, up) {
    let x0;
    let x1;
    let x2;
    let y0;
    let y1;
    let y2;
    let z0;
    let z1;
    let z2;
    let len;
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];
    if (Math.abs(eyex - centerx) < epsilon && Math.abs(eyey - centery) < epsilon && Math.abs(eyez - centerz) < epsilon) {
        return identityMat4(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    }
    else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    }
    else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
}
function ortho(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
}
function transformMat4(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    let w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
}

const MatrixAllocate = Symbol.for('MatrixAllocate');
const Mat4Allocate = Symbol.for('Mat4Allocate');
function createMat4() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
class DefaultMatrixAllocate {
    constructor() {
        this.pools = [];
    }
    allocate(a, b, c, d, e, f) {
        if (!this.pools.length) {
            return new Matrix(a, b, c, d, e, f);
        }
        const m = this.pools.pop();
        m.a = a;
        m.b = b;
        m.c = c;
        m.d = d;
        m.e = e;
        m.f = f;
        return m;
    }
    allocateByObj(matrix) {
        if (!this.pools.length) {
            return new Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
        }
        const m = this.pools.pop();
        m.a = matrix.a;
        m.b = matrix.b;
        m.c = matrix.c;
        m.d = matrix.d;
        m.e = matrix.e;
        m.f = matrix.f;
        return m;
    }
    free(d) {
        this.pools.push(d);
    }
    get length() {
        return this.pools.length;
    }
    release(...params) {
        this.pools = [];
    }
}
class DefaultMat4Allocate {
    constructor() {
        this.pools = [];
    }
    static identity(out) {
        return identityMat4(out);
    }
    allocate() {
        if (!this.pools.length) {
            return createMat4();
        }
        const m = this.pools.pop();
        DefaultMat4Allocate.identity(m);
        return m;
    }
    allocateByObj(d) {
        let m;
        if (!this.pools.length) {
            m = createMat4();
        }
        else {
            m = this.pools.pop();
        }
        for (let i = 0; i < m.length; i++) {
            m[i] = d[i];
        }
        return m;
    }
    free(m) {
        m && this.pools.push(m);
    }
    get length() {
        return this.pools.length;
    }
    release(...params) {
        this.pools = [];
    }
}
const matrixAllocate = new DefaultMatrixAllocate();
const mat4Allocate = new DefaultMat4Allocate();

const initMatrix = new Matrix(1, 0, 0, 1, 0, 0);
const globalPoint = { x: 0, y: 0 };
let EmptyContext2d = class EmptyContext2d {
    get nativeContext() {
        return this.path;
    }
    constructor(canvas, dpr) {
        this.matrix = new Matrix(1, 0, 0, 1, 0, 0);
        this.stack = [];
        this.dpr = dpr;
        this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0);
        this.path = new CustomPath2D();
        this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    }
    getCanvas() {
        throw new Error('不支持getCanvas');
    }
    getContext() {
        throw new Error('不支持getContext');
    }
    setTransformForCurrent(force = false) {
        if (!force && this.applyedMatrix.equalToMatrix(this.matrix)) {
            return;
        }
        this.applyedMatrix = this.cloneMatrix(this.matrix);
        return;
    }
    get currentMatrix() {
        return this.matrix;
    }
    cloneMatrix(m) {
        return matrixAllocate.allocateByObj(m);
    }
    clear() {
        this.save();
        this.resetTransform();
        this.restore();
    }
    reset() {
        this.matrix.setValue(1, 0, 0, 1, 0, 0);
        this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0);
        this.stack.length = 0;
    }
    restore() {
        if (this.stack.length > 0) {
            matrixAllocate.free(this.matrix);
            this.matrix = this.stack.pop();
            this.setTransformForCurrent();
        }
    }
    highPerformanceRestore() {
        if (this.stack.length > 0) {
            matrixAllocate.free(this.matrix);
            this.matrix = this.stack.pop();
        }
    }
    rotate(rad, setTransform = true) {
        this.matrix.rotate(rad);
        setTransform && this.setTransformForCurrent();
    }
    save() {
        const matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix);
    }
    highPerformanceSave() {
        const matrix = this.cloneMatrix(this.matrix);
        this.stack.push(matrix);
    }
    scale(sx, sy, setTransform = true) {
        this.matrix.scale(sx, sy);
        setTransform && this.setTransformForCurrent();
    }
    setScale(sx, sy, setTransform = true) {
        this.matrix.setScale(sx, sy);
        setTransform && this.setTransformForCurrent();
    }
    scalePoint(sx, sy, px, py, setTransform = true) {
        this.translate(px, py, false);
        this.scale(sx, sy, false);
        this.translate(-px, -py, false);
        setTransform && this.setTransformForCurrent();
    }
    setTransform(a, b, c, d, e, f, setTransform = true, dpr = this.dpr) {
        this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f);
        setTransform && this.setTransformForCurrent();
    }
    setTransformFromMatrix(matrix, setTransform = true, dpr = this.dpr) {
        this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr);
        setTransform && this.setTransformForCurrent();
    }
    resetTransform(setTransform = true, dpr = this.dpr) {
        this.setTransform(dpr, 0, 0, dpr, 0, 0);
        setTransform && this.setTransformForCurrent();
    }
    transform(a, b, c, d, e, f, setTransform = true) {
        this.matrix.multiply(a, b, c, d, e, f);
        setTransform && this.setTransformForCurrent();
    }
    transformFromMatrix(matrix, setTransform) {
        this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
        setTransform && this.setTransformForCurrent();
    }
    translate(x, y, setTransform = true) {
        this.matrix.translate(x, y);
        setTransform && this.setTransformForCurrent();
    }
    rotateDegrees(deg, setTransform = true) {
        const rad = (deg * Math.PI) / 180;
        this.rotate(rad, setTransform);
    }
    rotateAbout(rad, x, y, setTransform = true) {
        this.translate(x, y, false);
        this.rotate(rad, false);
        this.translate(-x, -y, false);
        setTransform && this.setTransformForCurrent();
    }
    rotateDegreesAbout(deg, x, y, setTransform = true) {
        this.translate(x, y, false);
        this.rotateDegrees(deg, false);
        this.translate(-x, -y, false);
        setTransform && this.setTransformForCurrent();
    }
    beginPath() {
        this.path.clear();
    }
    clip(path, fillRule) {
        return;
    }
    arc(x, y, radius, startAngle, endAngle, anticlockwise) {
        this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    arcTo(x1, y1, x2, y2, radiusX) {
        this.path.arcTo(x1, y1, x2, y2, radiusX);
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    closePath() {
        this.path.closePath();
    }
    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
        return;
    }
    lineTo(x, y) {
        this.path.lineTo(x, y);
    }
    moveTo(x, y) {
        this.path.moveTo(x, y);
    }
    quadraticCurveTo(cpx, cpy, x, y) {
        this.path.quadraticCurveTo(cpx, cpy, x, y);
    }
    rect(x, y, w, h) {
        this.path.rect(x, y, w, h);
    }
    createImageData(imageDataOrSw, sh) {
        return null;
    }
    createLinearGradient(x0, y0, x1, y1) {
        throw new Error('不支持createLinearGradient');
    }
    createPattern(image, repetition) {
        throw new Error('不支持createPattern');
    }
    createRadialGradient(x0, y0, r0, x1, y1, r1) {
        throw new Error('不支持createRadialGradient');
    }
    createConicGradient(x, y, startAngle, endAngle) {
        return null;
    }
    fill(path, fillRule) {
        return;
    }
    fillRect(x, y, width, height) {
        this.path.rect(x, y, width, height);
    }
    clearRect(x, y, w, h) {
        return;
    }
    fillText(text, x, y) {
        return;
    }
    getImageData(sx, sy, sw, sh) {
        return null;
    }
    getLineDash() {
        return [];
    }
    isPointInPath(x, y) {
        this.matrix.transformPoint({ x, y }, globalPoint);
        return contain(this.path.commandList, globalPoint.x, globalPoint.y);
    }
    isPointInStroke(x, y) {
        if (!this.lineWidth) {
            return false;
        }
        this.matrix.transformPoint({ x, y }, globalPoint);
        const lineWidth = getScaledStroke(this, this.lineWidth, this.dpr);
        return containStroke(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);
    }
    measureText(text) {
        throw new Error('不支持measureText');
    }
    putImageData(imagedata, dx, dy) {
        throw new Error('不支持measureText');
    }
    setLineDash(segments) {
        return;
    }
    stroke(path) {
        return;
    }
    strokeRect(x, y, width, height) {
        this.path.rect(x, y, width, height);
    }
    strokeText(text, x, y) {
        return;
    }
    drawImage() {
        return;
    }
    setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
        return;
    }
    _setCommonStyle(params, offsetX, offsetY, defaultParams) {
        return;
    }
    setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
        return;
    }
    _setStrokeStyle(params, offsetX, offsetY, defaultParams) {
        return;
    }
    setTextStyleWithoutAlignBaseline(params, defaultParams) {
        return;
    }
    setTextStyle(params, defaultParams) {
        return;
    }
    draw() {
        return;
    }
    clearMatrix(setTransform = true, dpr = this.dpr) {
        this.setTransformFromMatrix(initMatrix, setTransform, dpr);
    }
    setClearMatrix(a, b, c, d, e, f) {
        this._clearMatrix.setValue(a, b, c, d, e, f);
    }
    onlyTranslate(dpr = this.dpr) {
        return this.matrix.a === dpr && this.matrix.b === 0 && this.matrix.c === 0 && this.matrix.d === dpr;
    }
    release(...params) {
        this.stack.forEach(m => matrixAllocate.free(m));
        this.stack.length = 0;
        return;
    }
};
EmptyContext2d = __decorate([
    injectable(),
    __metadata("design:paramtypes", [Object, Number])
], EmptyContext2d);

const DefaultConfig$1 = {
    WIDTH: 500,
    HEIGHT: 500,
    DPR: 1
};
class BaseCanvas {
    get displayWidth() {
        return this._pixelWidth / this._dpr;
    }
    get displayHeight() {
        return this._pixelHeight / this._dpr;
    }
    get id() {
        return this._id;
    }
    get x() {
        return this._x;
    }
    set x(_x) {
        this._x = _x;
    }
    get y() {
        return this._y;
    }
    set y(_y) {
        this._y = _y;
    }
    get nativeCanvas() {
        return this._nativeCanvas;
    }
    set nativeCanvas(nativeCanvas) {
        this._nativeCanvas = nativeCanvas;
    }
    get width() {
        return this._pixelWidth;
    }
    set width(width) {
        this._pixelWidth = width;
        this._displayWidth = width / (this._dpr || 1);
    }
    get height() {
        return this._pixelHeight;
    }
    set height(height) {
        this._pixelHeight = height;
        this._displayHeight = height / (this._dpr || 1);
    }
    getContext(str) {
        return this._context;
    }
    get visiable() {
        return this._visiable;
    }
    set visiable(visiable) {
        this._visiable = visiable;
        visiable ? this.show() : this.hide();
    }
    get dpr() {
        return this._dpr;
    }
    set dpr(dpr) {
        this._dpr = dpr;
        this.resize(this._displayWidth, this._displayHeight);
    }
    constructor(params) {
        var _a;
        const { nativeCanvas, width = DefaultConfig$1.WIDTH, height = DefaultConfig$1.HEIGHT, dpr = DefaultConfig$1.DPR, x, y, id, canvasControled = true } = params;
        const offsetX = 0;
        const offsetY = 0;
        this._x = x !== null && x !== void 0 ? x : offsetX;
        this._y = y !== null && y !== void 0 ? y : offsetY;
        this._pixelWidth = width * dpr;
        this._pixelHeight = height * dpr;
        this._visiable = params.visiable !== false;
        this.controled = canvasControled;
        this._displayWidth = width;
        this._displayHeight = height;
        this._dpr = dpr;
        this._nativeCanvas = nativeCanvas;
        this._id = (_a = nativeCanvas.id) !== null && _a !== void 0 ? _a : id;
        if (id) {
            nativeCanvas.id = id;
        }
        this.init(params);
    }
    getNativeCanvas() {
        return this._nativeCanvas;
    }
    hide() {
        return;
    }
    show() {
        return;
    }
    applyPosition() {
        return;
    }
    resetStyle(params) {
        return;
    }
    resize(width, height) {
        return;
    }
    toDataURL(mimeType, quality) {
        return '';
    }
    readPixels(x, y, w, h) {
        return this._context.getImageData(x, y, w, h);
    }
    convertToBlob(options) {
        throw new Error('暂未实现');
    }
    transferToImageBitmap() {
        throw new Error('暂未实现');
    }
    release(...params) {
        if (this.controled) {
            this._nativeCanvas.parentElement && this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);
        }
    }
}
BaseCanvas.env = 'browser';

function colorEqual(color1, color2) {
    const c1 = Color.parseColorString(color1);
    const c2 = Color.parseColorString(color2);
    return c1 && c2 ? c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.opacity === c2.opacity : false;
}
var ColorType;
(function (ColorType) {
    ColorType[ColorType["Color255"] = 0] = "Color255";
    ColorType[ColorType["Color1"] = 1] = "Color1";
})(ColorType || (ColorType = {}));
class ColorStore {
    static Get(str, size = ColorType.Color1, arr = [0, 0, 0, 1]) {
        if (size === ColorType.Color1) {
            const color = ColorStore.store1[str];
            if (color) {
                arr[0] = color[0];
                arr[1] = color[1];
                arr[2] = color[2];
                arr[3] = color[3];
                return arr;
            }
            const c = Color.parseColorString(str);
            if (c) {
                const data = [c.r / 255, c.g / 255, c.b / 255, c.opacity];
                ColorStore.store1[str] = data;
                ColorStore.store255[str] = [c.r, c.g, c.b, c.opacity];
                arr[0] = data[0];
                arr[1] = data[1];
                arr[2] = data[2];
                arr[3] = data[3];
            }
            return arr;
        }
        const color = ColorStore.store255[str];
        if (color) {
            arr[0] = color[0];
            arr[1] = color[1];
            arr[2] = color[2];
            arr[3] = color[3];
            return arr;
        }
        const c = Color.parseColorString(str);
        if (c) {
            ColorStore.store1[str] = [c.r / 255, c.g / 255, c.b / 255, c.opacity];
            ColorStore.store255[str] = [c.r, c.g, c.b, c.opacity];
            arr[0] = c.r;
            arr[1] = c.g;
            arr[2] = c.b;
            arr[3] = c.opacity;
        }
        return arr;
    }
    static Set(str, size, arr) {
        if (size === ColorType.Color1) {
            if (ColorStore.store1[str]) {
                return;
            }
            ColorStore.store1[str] = arr;
            ColorStore.store255[str] = [
                Math.floor(arr[0] * 255),
                Math.floor(arr[1] * 255),
                Math.floor(arr[2] * 255),
                Math.floor(arr[3] * 255)
            ];
        }
        else {
            if (ColorStore.store255[str]) {
                return;
            }
            ColorStore.store255[str] = arr;
            ColorStore.store1[str] = [arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3]];
        }
    }
}
ColorStore.store255 = {};
ColorStore.store1 = {};

function colorArrayToString(color, alphaChannel = false) {
    if (Array.isArray(color) && isNumber$1(color[0])) {
        return alphaChannel
            ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})`
            : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})`;
    }
    return color;
}
function interpolateColor(from, to, ratio, alphaChannel, cb) {
    if ((Array.isArray(from) && !isNumber$1(from[0])) || (Array.isArray(to) && !isNumber$1(to[0]))) {
        const out = new Array(4).fill(0).map((_, index) => {
            var _a, _b;
            return _interpolateColor(isArray(from) ? ((_a = from[index]) !== null && _a !== void 0 ? _a : from[0]) : from, isArray(to) ? ((_b = to[index]) !== null && _b !== void 0 ? _b : to[0]) : to, ratio, alphaChannel);
        });
        return out;
    }
    return _interpolateColor(from, to, ratio, alphaChannel, cb);
}
function _interpolateColor(from, to, ratio, alphaChannel, cb) {
    if (!(from && to)) {
        return (from && colorArrayToString(from)) || (to && colorArrayToString(to)) || false;
    }
    let fromArray;
    let toArray;
    let fromGradient = false;
    let toGradient = false;
    if (Array.isArray(from)) {
        fromArray = from;
    }
    else if (typeof from === 'string') {
        fromArray = ColorStore.Get(from, ColorType.Color255);
    }
    else {
        fromGradient = true;
    }
    if (Array.isArray(to)) {
        toArray = to;
    }
    else if (typeof to === 'string') {
        toArray = ColorStore.Get(to, ColorType.Color255);
    }
    else {
        toGradient = true;
    }
    if (fromGradient !== toGradient) {
        const gradient = (fromGradient ? from : to);
        const pure = (fromGradient ? to : from);
        const gradientFromPure = Object.assign(Object.assign({}, gradient), { stops: gradient.stops.map(v => (Object.assign(Object.assign({}, v), { color: colorArrayToString(pure) }))) });
        return fromGradient
            ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb)
            : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
    }
    if (fromGradient) {
        if (from.gradient === to.gradient) {
            const fc = from;
            const tc = to;
            const fromStops = fc.stops;
            const toStops = tc.stops;
            if (fromStops.length !== toStops.length) {
                return false;
            }
            if (fc.gradient === 'linear') {
                return interpolateGradientLinearColor(fc, tc, ratio);
            }
            else if (fc.gradient === 'radial') {
                return interpolateGradientRadialColor(fc, tc, ratio);
            }
            else if (fc.gradient === 'conical') {
                return interpolateGradientConicalColor(fc, tc, ratio);
            }
        }
        return false;
    }
    cb && cb(fromArray, toArray);
    const result = interpolatePureColorArray(fromArray, toArray, ratio);
    return colorArrayToString(result, alphaChannel);
}
function interpolateGradientLinearColor(fc, tc, ratio) {
    const fStops = fc.stops;
    const tStops = tc.stops;
    const color = {
        gradient: 'linear',
        x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
        x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
        y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
        y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
        stops: new Array(fStops.length).fill(0).map((_, i) => {
            return {
                color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
                offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
            };
        })
    };
    return color;
}
function interpolateGradientRadialColor(fc, tc, ratio) {
    const fStops = fc.stops;
    const tStops = tc.stops;
    const color = {
        gradient: 'radial',
        x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
        x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
        y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
        y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
        r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
        r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
        stops: new Array(fStops.length).fill(0).map((_, i) => {
            return {
                color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
                offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
            };
        })
    };
    return color;
}
function interpolateGradientConicalColor(fc, tc, ratio) {
    const fStops = fc.stops;
    const tStops = tc.stops;
    const color = {
        gradient: 'conical',
        startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
        endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
        x: fc.x + (tc.x - fc.x) * ratio,
        y: fc.y + (tc.y - fc.y) * ratio,
        stops: new Array(fStops.length).fill(0).map((_, i) => {
            return {
                color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
                offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
            };
        })
    };
    return color;
}
function interpolatePureColorArray(from, to, ratio) {
    return [
        from[0] + (to[0] - from[0]) * ratio,
        from[1] + (to[1] - from[1]) * ratio,
        from[2] + (to[2] - from[2]) * ratio,
        from[3] + (to[3] - from[3]) * ratio
    ];
}
function interpolatePureColorArrayToStr(from, to, ratio) {
    return `rgba(${from[0] + (to[0] - from[0]) * ratio},${from[1] + (to[1] - from[1]) * ratio},${from[2] + (to[2] - from[2]) * ratio},${from[3] + (to[3] - from[3]) * ratio})`;
}
const _fromColorRGB = [0, 0, 0, 0];
const _toColorRGB = [0, 0, 0, 0];
function colorStringInterpolationToStr(fromColor, toColor, ratio) {
    ColorStore.Get(fromColor, ColorType.Color255, _fromColorRGB);
    ColorStore.Get(toColor, ColorType.Color255, _toColorRGB);
    return `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
}

Object.keys(DEFAULT_COLORS).forEach(k => {
    DEFAULT_COLORS[k];
});

class ConicalCanvas {
    static GetCanvas() {
        try {
            if (!ConicalCanvas.canvas) {
                ConicalCanvas.canvas = application.global.createCanvas({});
            }
            return ConicalCanvas.canvas;
        }
        catch (err) {
            return null;
        }
    }
    static GetCtx() {
        if (!ConicalCanvas.ctx) {
            const conicalCanvas = ConicalCanvas.GetCanvas();
            ConicalCanvas.ctx = conicalCanvas.getContext('2d');
        }
        return ConicalCanvas.ctx;
    }
}
class ColorInterpolate extends LRU {
    static getInstance() {
        if (!ColorInterpolate._instance) {
            ColorInterpolate._instance = new ColorInterpolate();
        }
        return ColorInterpolate._instance;
    }
    constructor(stops = [], precision = 100) {
        super();
        this.cacheParams = { CLEAN_THRESHOLD: 100, L_TIME: 1e3 };
        this.dataMap = new Map();
        const canvas = ConicalCanvas.GetCanvas();
        const conicalCtx = ConicalCanvas.GetCtx();
        canvas.width = precision;
        canvas.height = 1;
        if (!conicalCtx) {
            return;
        }
        conicalCtx.translate(0, 0);
        if (!conicalCtx) {
            throw new Error('获取ctx发生错误');
        }
        const gradient = conicalCtx.createLinearGradient(0, 0, precision, 0);
        stops.forEach(stop => {
            gradient.addColorStop(stop[0], stop[1]);
        });
        conicalCtx.fillStyle = gradient;
        conicalCtx.fillRect(0, 0, precision, 1);
        this.rgbaSet = conicalCtx.getImageData(0, 0, precision, 1).data;
    }
    getColor(offset) {
        const rgba = this.rgbaSet.slice(4 * offset, 4 * offset + 4);
        return `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3] / 255})`;
    }
    GetOrCreate(x, y, w, h, stops = [], precision = 100) {
        let str = `${x}${y}${w}${h}`;
        stops.forEach(item => (str += item.join()));
        str += precision;
        let colorInter = this.dataMap.get(str);
        if (!colorInter) {
            const data = new ColorInterpolate(stops, precision);
            colorInter = { data, timestamp: [] };
            this.addLimitedTimestamp(colorInter, Date.now(), {});
            this.dataMap.set(str, colorInter);
        }
        this.clearCache(this.dataMap, this.cacheParams);
        return colorInter.data;
    }
}
class ConicalPatternStore {
    static GetSize(minSize) {
        for (let i = 0; i < ConicalPatternStore.ImageSize.length; i++) {
            if (ConicalPatternStore.ImageSize[i] >= minSize) {
                return ConicalPatternStore.ImageSize[i];
            }
        }
        return minSize;
    }
    static Get(stops, x, y, startAngle, endAngle, w, h) {
        const key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle);
        const data = ConicalPatternStore.cache[key];
        if (!data || data.length === 0) {
            return null;
        }
        for (let i = 0; i < data.length; i++) {
            if (data[i].width >= w && data[i].height >= h) {
                return data[i].pattern;
            }
        }
        return null;
    }
    static Set(stops, x, y, startAngle, endAngle, pattern, w, h) {
        const key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle);
        if (!ConicalPatternStore.cache[key]) {
            ConicalPatternStore.cache[key] = [
                {
                    width: w,
                    height: h,
                    pattern
                }
            ];
        }
        else {
            ConicalPatternStore.cache[key].push({
                width: w,
                height: h,
                pattern
            });
        }
    }
    static GenKey(stops, x, y, startAngle, endAngle) {
        return `${x},${y},${startAngle},${endAngle},${stops.join()}`;
    }
}
ConicalPatternStore.cache = {};
ConicalPatternStore.ImageSize = [20, 40, 80, 160, 320, 640, 1280, 2560];
function getConicGradientAt(x, y, angle, color) {
    const { stops, startAngle, endAngle } = color;
    while (angle < 0) {
        angle += pi2;
    }
    while (angle > pi2) {
        angle -= pi2;
    }
    if (angle < startAngle) {
        return stops[0].color;
    }
    if (angle > endAngle) {
        return stops[0].color;
    }
    let percent = (angle - startAngle) / (endAngle - startAngle);
    let startStop;
    let endStop;
    for (let i = 0; i < stops.length; i++) {
        if (stops[i].offset >= percent) {
            startStop = stops[i - 1];
            endStop = stops[i];
            break;
        }
    }
    percent = (percent - startStop.offset) / (endStop.offset - startStop.offset);
    return interpolateColor(startStop.color, endStop.color, percent, false);
}
function createConicalGradient(context, stops, x, y, deltaAngle, startAngle, endAngle, minW, minH) {
    const deltaDeg = Math.floor((deltaAngle * 180) / Math.PI);
    const conicalCanvas = ConicalCanvas.GetCanvas();
    const conicalCtx = ConicalCanvas.GetCtx();
    if (!conicalCtx) {
        return null;
    }
    const width = ConicalPatternStore.GetSize(minW);
    const height = ConicalPatternStore.GetSize(minH);
    let pattern = ConicalPatternStore.Get(stops, x, y, startAngle, endAngle, width, height);
    if (pattern) {
        return pattern;
    }
    const r = Math.sqrt(Math.max(Math.max(Math.pow(x, 2) + Math.pow(y, 2), Math.pow(width - x, 2) + Math.pow(y, 2)), Math.max(Math.pow(width - x, 2) + Math.pow(height - y, 2), Math.pow(x, 2) + Math.pow(height - y, 2))));
    const stepNum = deltaDeg + 1;
    const step = deltaAngle / Math.max(1, stepNum - 1);
    const colorInter = ColorInterpolate.getInstance().GetOrCreate(x, y, width, height, stops, stepNum);
    const lineWidth = (2 * Math.PI * r) / 360;
    conicalCanvas.width = width;
    conicalCanvas.height = height;
    conicalCtx.setTransform(1, 0, 0, 1, 0, 0);
    conicalCtx.clearRect(0, 0, width, height);
    conicalCtx.translate(x, y);
    conicalCtx.rotate(startAngle);
    for (let i = 0, len = stepNum - 1; i < len; i++) {
        if (startAngle + i * step > endAngle) {
            break;
        }
        const color = colorInter.getColor(i);
        conicalCtx.beginPath();
        conicalCtx.rotate(step);
        conicalCtx.moveTo(0, 0);
        conicalCtx.lineTo(r, -2 * lineWidth);
        conicalCtx.lineTo(r, 0);
        conicalCtx.fillStyle = color;
        conicalCtx.closePath();
        conicalCtx.fill();
    }
    const imageData = conicalCtx.getImageData(0, 0, width, height);
    conicalCanvas.width = imageData.width;
    conicalCanvas.height = imageData.height;
    conicalCtx.putImageData(imageData, 0, 0);
    pattern = context.createPattern(conicalCanvas, 'no-repeat');
    pattern && ConicalPatternStore.Set(stops, x, y, startAngle, endAngle, pattern, width, height);
    return pattern;
}

const _tempBounds$1 = new AABBBounds();
const tempMatrix = new Matrix();
new AABBBounds();
const PURE_STYLE_KEY = [
    'stroke',
    'opacity',
    'strokeOpacity',
    'lineDash',
    'lineDashOffset',
    'lineCap',
    'lineJoin',
    'miterLimit',
    'fill',
    'fillOpacity'
];
const GRAPHIC_UPDATE_TAG_KEY = [
    'lineWidth',
    'scaleX',
    'scaleY',
    'angle',
    'anchor',
    'visible'
];
const tempConstantXYKey = ['x', 'y'];
const tempConstantScaleXYKey = ['scaleX', 'scaleY'];
const tempConstantAngleKey = ['angle'];
const point = new Point();
const NOWORK_ANIMATE_ATTR = {
    strokeSeg: 1,
    boundsPadding: 2,
    pickMode: 1,
    boundsMode: 1,
    customPickShape: 1,
    pickable: 1,
    childrenPickable: 1,
    visible: 1,
    zIndex: 1,
    layout: 1,
    keepDirIn3d: 1,
    globalZIndex: 1,
    outerBorder: 1,
    innerBorder: 1,
    lineDash: 1,
    lineCap: 1,
    lineJoin: 1,
    miterLimit: 2,
    strokeBoundsBuffer: 2,
    scaleCenter: 1,
    anchor: 1,
    anchor3d: 1,
    postMatrix: 1,
    backgroundMode: 2,
    background: 1,
    texture: 1,
    cursor: 1,
    html: 1
};
class Graphic extends Node {
    static mixin(source) {
        const keys = Object.keys(source);
        for (let i = 0; i < keys.length; ++i) {
            const propertyName = keys[i];
            Object.defineProperty(Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
    }
    get AABBBounds() {
        return this.tryUpdateAABBBounds();
    }
    get OBBBounds() {
        return this.tryUpdateOBBBounds();
    }
    get globalAABBBounds() {
        return this.tryUpdateGlobalAABBBounds();
    }
    get transMatrix() {
        return this.tryUpdateLocalTransMatrix(true);
    }
    get globalTransMatrix() {
        return this.tryUpdateGlobalTransMatrix(true);
    }
    constructor(params = {}) {
        var _a;
        super();
        this._AABBBounds = new AABBBounds();
        this._updateTag = UpdateTag.INIT;
        this.attribute = params;
        this.valid = this.isValid();
        this.updateAABBBoundsStamp = 0;
        if (params.background) {
            this.loadImage((_a = params.background.background) !== null && _a !== void 0 ? _a : params.background, true);
        }
        else if (params.shadowGraphic) {
            this.setShadowGraphic(params.shadowGraphic);
        }
    }
    getGraphicService() {
        var _a, _b;
        return (_b = (_a = this.stage) === null || _a === void 0 ? void 0 : _a.graphicService) !== null && _b !== void 0 ? _b : application.graphicService;
    }
    getAttributes() {
        return this.attribute;
    }
    setMode(mode) {
        mode === '3d' ? this.set3dMode() : this.set2dMode();
    }
    set3dMode() {
        this.in3dMode = true;
    }
    set2dMode() {
        this.in3dMode = false;
    }
    getOffsetXY(attr, includeScroll = false) {
        var _a, _b;
        const { dx = attr.dx, dy = attr.dy } = this.attribute;
        if (includeScroll && this.parent) {
            const attribute = this.parent.attribute;
            point.x = dx + ((_a = attribute.scrollX) !== null && _a !== void 0 ? _a : 0);
            point.y = dy + ((_b = attribute.scrollY) !== null && _b !== void 0 ? _b : 0);
        }
        else {
            point.x = dx;
            point.y = dy;
        }
        return point;
    }
    onAnimateBind(animate) {
        this._emitCustomEvent('animate-bind', animate);
    }
    tryUpdateAABBBounds() {
        const full = this.attribute.boundsMode === 'imprecise';
        if (!this.shouldUpdateAABBBounds()) {
            return this._AABBBounds;
        }
        if (!this.valid) {
            this._AABBBounds.clear();
            return this._AABBBounds;
        }
        this.getGraphicService().beforeUpdateAABBBounds(this, this.stage, true, this._AABBBounds);
        const bounds = this.doUpdateAABBBounds(full);
        this.getGraphicService().afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, true);
        if (this.attribute.boundsMode === 'empty') {
            bounds.clear();
        }
        return bounds;
    }
    tryUpdateOBBBounds() {
        if (!this._OBBBounds) {
            this._OBBBounds = new OBBBounds();
        }
        this.tryUpdateAABBBounds();
        if (this.updateOBBBoundsStamp === this.updateAABBBoundsStamp) {
            return this._OBBBounds;
        }
        this.updateOBBBoundsStamp = this.updateAABBBoundsStamp;
        if (!this.valid) {
            this._OBBBounds.clear();
            return this._OBBBounds;
        }
        const bounds = this.doUpdateOBBBounds();
        return bounds;
    }
    combindShadowAABBBounds(bounds) {
        if (this.shadowRoot) {
            const b = this.shadowRoot.AABBBounds.clone();
            bounds.union(b);
        }
    }
    doUpdateOBBBounds() {
        return this._OBBBounds;
    }
    getClipPath() {
        const { clipConfig } = this.attribute;
        if (!clipConfig) {
            return null;
        }
        if (!this.clipPathMap) {
            this.clipPathMap = new Map();
        }
        const { shape } = clipConfig;
        let path = this.clipPathMap.get(shape) || null;
        if (!path) {
            if (this.clipPathMap.size > 10) {
                this.clipPathMap.clear();
            }
            path = this.parsePath(shape);
            path && this.clipPathMap.set(shape, path);
        }
        return path;
    }
    parsePath(symbolType) {
        if (!symbolType) {
            return null;
        }
        let path = builtinSymbolsMap[symbolType];
        if (path) {
            return path;
        }
        path = Graphic.userSymbolMap[symbolType];
        if (path) {
            return path;
        }
        const _symbolType = builtInSymbolStrMap[symbolType];
        symbolType = _symbolType || symbolType;
        const valid = isSvg(symbolType);
        if (valid === true) {
            const parser = new XMLParser();
            const { svg } = parser.parse(symbolType);
            if (!svg) {
                return null;
            }
            const path = isArray(svg.path) ? svg.path : [svg.path];
            _tempBounds$1.clear();
            const cacheList = [];
            path.forEach((item) => {
                const cache = new CustomPath2D().fromString(item.d);
                const attribute = {};
                SVG_PARSE_ATTRIBUTE_MAP_KEYS.forEach(k => {
                    if (item[k]) {
                        attribute[SVG_PARSE_ATTRIBUTE_MAP[k]] = item[k];
                    }
                });
                cacheList.push({
                    path: cache,
                    attribute
                });
                _tempBounds$1.union(cache.bounds);
            });
            const width = _tempBounds$1.width();
            const height = _tempBounds$1.height();
            const maxWH = max(width, height);
            const scale = 1 / maxWH;
            cacheList.forEach(cache => cache.path.transform(0, 0, scale, scale));
            const _parsedPath = new CustomSymbolClass(symbolType, cacheList, true);
            Graphic.userSymbolMap[symbolType] = _parsedPath;
            return _parsedPath;
        }
        const cache = new CustomPath2D().fromString(symbolType);
        const width = cache.bounds.width();
        const height = cache.bounds.height();
        const maxWH = max(width, height);
        const scale = 1 / maxWH;
        cache.transform(0, 0, scale, scale);
        const _parsedPath = new CustomSymbolClass(symbolType, cache);
        Graphic.userSymbolMap[symbolType] = _parsedPath;
        return _parsedPath;
    }
    doUpdateAABBBounds(full) {
        this.updateAABBBoundsStamp++;
        const graphicTheme = this.getGraphicTheme();
        this._AABBBounds.clear();
        const attribute = this.attribute;
        const bounds = this.updateAABBBounds(attribute, graphicTheme, this._AABBBounds, full);
        const { boundsPadding = graphicTheme.boundsPadding } = attribute;
        const paddingArray = parsePadding(boundsPadding);
        if (paddingArray) {
            bounds.expand(paddingArray);
        }
        this.clearUpdateBoundTag();
        return bounds;
    }
    updatePathProxyAABBBounds(aabbBounds) {
        const path = typeof this.pathProxy === 'function' ? this.pathProxy(this.attribute) : this.pathProxy;
        if (!path) {
            return false;
        }
        const boundsContext = new BoundsContext(aabbBounds);
        renderCommandList(path.commandList, boundsContext, 0, 0);
        return true;
    }
    tryUpdateGlobalAABBBounds() {
        const b = this.AABBBounds;
        if (!this._globalAABBBounds) {
            this._globalAABBBounds = b.clone();
        }
        else {
            this._globalAABBBounds.setValue(b.x1, b.y1, b.x2, b.y2);
        }
        if (this._globalAABBBounds.empty()) {
            return this._globalAABBBounds;
        }
        if (this.parent) {
            this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix);
        }
        return this._globalAABBBounds;
    }
    tryUpdateGlobalTransMatrix(clearTag = true) {
        if (!this._globalTransMatrix) {
            this._globalTransMatrix = this.parent
                ? this.parent.globalTransMatrix.clone()
                : this.transMatrix.clone();
        }
        else if (this.parent) {
            const m = this.parent.globalTransMatrix;
            this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
        }
        if (this.shouldUpdateGlobalMatrix()) {
            this.doUpdateGlobalMatrix();
        }
        return this._globalTransMatrix;
    }
    shouldUpdateGlobalMatrix() {
        return true;
    }
    tryUpdateLocalTransMatrix(clearTag = true) {
        if (!this._transMatrix) {
            this._transMatrix = new Matrix();
        }
        if (this.shouldUpdateLocalMatrix()) {
            this.doUpdateLocalMatrix();
            clearTag && this.clearUpdateLocalPositionTag();
        }
        return this._transMatrix;
    }
    shouldUpdateAABBBounds() {
        if (this.shadowRoot) {
            return ((!!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds()) &&
                this.getGraphicService().validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this));
        }
        return (!!(this._updateTag & UpdateTag.UPDATE_BOUNDS) &&
            this.getGraphicService().validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this));
    }
    shouldSelfChangeUpdateAABBBounds() {
        if (this.shadowRoot) {
            return !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds();
        }
        return !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
    }
    shouldUpdateLocalMatrix() {
        return !!(this._updateTag & UpdateTag.UPDATE_LOCAL_MATRIX);
    }
    isValid() {
        var _a, _b;
        const attribute = this.attribute;
        return Number.isFinite(((_a = attribute.x) !== null && _a !== void 0 ? _a : 0) + ((_b = attribute.y) !== null && _b !== void 0 ? _b : 0));
    }
    _validNumber(num) {
        return num == null || Number.isFinite(num);
    }
    shouldUpdateShape() {
        return !!(this._updateTag & UpdateTag.UPDATE_SHAPE);
    }
    clearUpdateShapeTag() {
        this._updateTag &= UpdateTag.CLEAR_SHAPE;
    }
    containsPoint(x, y, mode, picker) {
        if (!picker) {
            return false;
        }
        if (mode === IContainPointMode.GLOBAL) {
            const point = new Point(x, y);
            if (this.parent) {
                this.parent.globalTransMatrix.transformPoint(point, point);
            }
            x = point.x;
            y = point.y;
        }
        return picker.containsPoint(this, { x, y });
    }
    setWidthHeightWithoutTransform(aabbBounds) {
        this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1;
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
    }
    setAttributesAndPreventAnimate(params, forceUpdateTag = false, context, ignorePriority) {
        this.setAttributes(params, forceUpdateTag, context);
        this.animates &&
            this.animates.forEach(animate => {
                if (animate.priority === Infinity && !ignorePriority) {
                    return;
                }
                Object.keys(params).forEach(key => {
                    animate.preventAttr(key);
                });
            });
    }
    setAttributes(params, forceUpdateTag = false, context) {
        if (!params) {
            return;
        }
        params =
            (this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context)) || params;
        if (params.background) {
            this.loadImage(params.background, true);
        }
        else if (params.shadowGraphic) {
            this.setShadowGraphic(params.shadowGraphic);
        }
        this._setAttributes(params, forceUpdateTag, context);
    }
    _setAttributes(params, forceUpdateTag = false, context) {
        const keys = Object.keys(params);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            this.attribute[key] = params[key];
        }
        this.valid = this.isValid();
        if (!this.updateShapeAndBoundsTagSetted() && (forceUpdateTag || this.needUpdateTags(keys))) {
            this.addUpdateShapeAndBoundsTag();
        }
        else {
            this.addUpdateBoundTag();
        }
        this.addUpdatePositionTag();
        this.addUpdateLayoutTag();
        this.onAttributeUpdate(context);
    }
    setAttribute(key, value, forceUpdateTag, context) {
        var _a;
        const params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({ [key]: value }, this.attribute, key, context);
        if (!params) {
            if (!isNil((_a = this.normalAttrs) === null || _a === void 0 ? void 0 : _a[key])) {
                this.normalAttrs[key] = value;
            }
            else {
                this.attribute[key] = value;
                this.valid = this.isValid();
                if (!this.updateShapeAndBoundsTagSetted() && (forceUpdateTag || this.needUpdateTag(key))) {
                    this.addUpdateShapeAndBoundsTag();
                }
                else {
                    this.addUpdateBoundTag();
                }
                this.addUpdatePositionTag();
                this.addUpdateLayoutTag();
                this.onAttributeUpdate(context);
            }
        }
        else {
            this._setAttributes(params, forceUpdateTag, context);
        }
        if (key === 'background') {
            this.loadImage(value, true);
        }
        else if (key === 'shadowGraphic') {
            this.setShadowGraphic(value);
        }
    }
    needUpdateTags(keys, k = GRAPHIC_UPDATE_TAG_KEY) {
        for (let i = 0; i < k.length; i++) {
            const attrKey = k[i];
            if (keys.indexOf(attrKey) !== -1) {
                return true;
            }
        }
        return false;
    }
    needUpdateTag(key, k = GRAPHIC_UPDATE_TAG_KEY) {
        for (let i = 0; i < k.length; i++) {
            const attrKey = k[i];
            if (key === attrKey) {
                return true;
            }
        }
        return false;
    }
    initAttributes(params) {
        const context = { type: AttributeUpdateType.INIT };
        params =
            (this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context)) || params;
        this.attribute = params;
        if (params.background) {
            this.loadImage(params.background, true);
        }
        else if (params.shadowGraphic) {
            this.setShadowGraphic(params.shadowGraphic);
        }
        this._updateTag = UpdateTag.INIT;
        this.valid = this.isValid();
        this.onAttributeUpdate(context);
    }
    translate(x, y) {
        var _a, _b;
        if (x === 0 && y === 0) {
            return this;
        }
        const context = {
            type: AttributeUpdateType.TRANSLATE
        };
        const params = this.onBeforeAttributeUpdate &&
            this.onBeforeAttributeUpdate({ x, y }, this.attribute, tempConstantXYKey, context);
        if (params) {
            x = params.x;
            y = params.y;
            delete params.x;
            delete params.y;
            this._setAttributes(params);
        }
        const attribute = this.attribute;
        const postMatrix = attribute.postMatrix;
        if (!postMatrix) {
            attribute.x = ((_a = attribute.x) !== null && _a !== void 0 ? _a : DefaultTransform.x) + x;
            attribute.y = ((_b = attribute.y) !== null && _b !== void 0 ? _b : DefaultTransform.y) + y;
        }
        else {
            application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x, y);
        }
        this.addUpdatePositionTag();
        this.addUpdateBoundTag();
        this.addUpdateLayoutTag();
        this.onAttributeUpdate(context);
        return this;
    }
    translateTo(x, y) {
        const attribute = this.attribute;
        if (attribute.x === x && attribute.y === y) {
            return this;
        }
        const context = {
            type: AttributeUpdateType.TRANSLATE_TO
        };
        const params = this.onBeforeAttributeUpdate &&
            this.onBeforeAttributeUpdate({ x, y }, this.attribute, tempConstantXYKey, context);
        if (params) {
            this._setAttributes(params, false, context);
            return this;
        }
        attribute.x = x;
        attribute.y = y;
        this.addUpdatePositionTag();
        this.addUpdateBoundTag();
        this.addUpdateLayoutTag();
        this.onAttributeUpdate(context);
        return this;
    }
    scale(scaleX, scaleY, scaleCenter) {
        var _a, _b;
        if (scaleX === 1 && scaleY === 1) {
            return this;
        }
        const context = {
            type: AttributeUpdateType.SCALE
        };
        const params = this.onBeforeAttributeUpdate &&
            this.onBeforeAttributeUpdate({ scaleX, scaleY, scaleCenter }, this.attribute, tempConstantScaleXYKey, context);
        if (params) {
            scaleX = params.scaleX;
            scaleY = params.scaleY;
            delete params.scaleX;
            delete params.scaleY;
            this._setAttributes(params);
        }
        const attribute = this.attribute;
        if (!scaleCenter) {
            attribute.scaleX = ((_a = attribute.scaleX) !== null && _a !== void 0 ? _a : DefaultTransform.scaleX) * scaleX;
            attribute.scaleY = ((_b = attribute.scaleY) !== null && _b !== void 0 ? _b : DefaultTransform.scaleY) * scaleY;
        }
        else {
            let { postMatrix } = this.attribute;
            if (!postMatrix) {
                postMatrix = new Matrix();
                attribute.postMatrix = postMatrix;
            }
            application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);
        }
        this.addUpdatePositionTag();
        this.addUpdateBoundTag();
        this.addUpdateLayoutTag();
        this.onAttributeUpdate(context);
        return this;
    }
    scaleTo(scaleX, scaleY) {
        const attribute = this.attribute;
        if (attribute.scaleX === scaleX && attribute.scaleY === scaleY) {
            return this;
        }
        const context = {
            type: AttributeUpdateType.SCALE_TO
        };
        const params = this.onBeforeAttributeUpdate &&
            this.onBeforeAttributeUpdate({ scaleX, scaleY }, this.attribute, tempConstantScaleXYKey, context);
        if (params) {
            this._setAttributes(params, false, context);
            return this;
        }
        attribute.scaleX = scaleX;
        attribute.scaleY = scaleY;
        this.addUpdatePositionTag();
        this.addUpdateBoundTag();
        this.addUpdateLayoutTag();
        this.onAttributeUpdate(context);
        return this;
    }
    rotate(angle, rotateCenter) {
        var _a;
        if (angle === 0) {
            return this;
        }
        const context = { type: AttributeUpdateType.ROTATE };
        const params = this.onBeforeAttributeUpdate &&
            this.onBeforeAttributeUpdate({ angle, rotateCenter }, this.attribute, tempConstantAngleKey, context);
        if (params) {
            delete params.angle;
            this._setAttributes(params, false, context);
        }
        const attribute = this.attribute;
        if (!rotateCenter) {
            attribute.angle = ((_a = attribute.angle) !== null && _a !== void 0 ? _a : DefaultTransform.angle) + angle;
        }
        else {
            let { postMatrix } = this.attribute;
            if (!postMatrix) {
                postMatrix = new Matrix();
                attribute.postMatrix = postMatrix;
            }
            application.transformUtil.fromMatrix(postMatrix, postMatrix).rotate(angle, rotateCenter);
        }
        this.addUpdatePositionTag();
        this.addUpdateBoundTag();
        this.addUpdateLayoutTag();
        this.onAttributeUpdate(context);
        return this;
    }
    rotateTo(angle) {
        const attribute = this.attribute;
        if (attribute.angle === angle) {
            return this;
        }
        const context = {
            type: AttributeUpdateType.ROTATE_TO
        };
        const params = this.onBeforeAttributeUpdate &&
            this.onBeforeAttributeUpdate(angle, this.attribute, tempConstantAngleKey, context);
        if (params) {
            this._setAttributes(params, false, context);
            return this;
        }
        attribute.angle = angle;
        this.addUpdatePositionTag();
        this.addUpdateBoundTag();
        this.addUpdateLayoutTag();
        this.onAttributeUpdate(context);
        return this;
    }
    skewTo(b, c) {
        return this;
    }
    onAttributeUpdate(context) {
        if (context && context.skipUpdateCallback) {
            return;
        }
        this.getGraphicService().onAttributeUpdate(this);
        this._emitCustomEvent('afterAttributeUpdate', context);
    }
    update(d) {
        if (d) {
            d.bounds && this.tryUpdateAABBBounds();
            d.trans && this.tryUpdateLocalTransMatrix();
        }
        else {
            this.tryUpdateAABBBounds();
            this.tryUpdateLocalTransMatrix();
        }
    }
    hasState(stateName) {
        if (!this.currentStates || !this.currentStates.length) {
            return false;
        }
        if (!isNil(stateName)) {
            return this.currentStates.includes(stateName);
        }
        return true;
    }
    getState(stateName) {
        var _a;
        return (_a = this.states) === null || _a === void 0 ? void 0 : _a[stateName];
    }
    applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {
        var _a, _b;
        if (hasAnimation) {
            const keys = Object.keys(attrs);
            const noWorkAttrs = this.getNoWorkAnimateAttr();
            const animateAttrs = {};
            let noAnimateAttrs;
            keys.forEach(key => {
                if (!noWorkAttrs[key]) {
                    animateAttrs[key] =
                        isClear && attrs[key] === undefined ? this.getDefaultAttribute(key) : attrs[key];
                }
                else {
                    if (!noAnimateAttrs) {
                        noAnimateAttrs = {};
                    }
                    noAnimateAttrs[key] = attrs[key];
                }
            });
            const stateAnimateConfig = (_b = (_a = (this.context && this.context.stateAnimateConfig)) !== null && _a !== void 0 ? _a : this.stateAnimateConfig) !== null && _b !== void 0 ? _b : DefaultStateAnimateConfig;
            this.applyAnimationState(['state'], [
                {
                    name: 'state',
                    animation: {
                        type: 'state',
                        to: animateAttrs,
                        duration: stateAnimateConfig.duration,
                        easing: stateAnimateConfig.easing
                    }
                }
            ]);
            noAnimateAttrs && this.setAttributesAndPreventAnimate(noAnimateAttrs, false, { type: AttributeUpdateType.STATE });
        }
        else {
            this.stopStateAnimates();
            this.setAttributesAndPreventAnimate(attrs, false, { type: AttributeUpdateType.STATE });
            if (this.finalAttribute) {
                Object.assign(this.finalAttribute, attrs);
            }
        }
        this._emitCustomEvent('afterStateUpdate', { type: AttributeUpdateType.STATE });
    }
    updateNormalAttrs(stateAttrs) {
        const newNormalAttrs = {};
        if (this.normalAttrs) {
            Object.keys(stateAttrs).forEach(key => {
                if (key in this.normalAttrs) {
                    newNormalAttrs[key] = this.normalAttrs[key];
                    delete this.normalAttrs[key];
                }
                else {
                    newNormalAttrs[key] = this.getNormalAttribute(key);
                }
            });
            Object.keys(this.normalAttrs).forEach(key => {
                stateAttrs[key] = this.normalAttrs[key];
            });
        }
        else {
            Object.keys(stateAttrs).forEach(key => {
                newNormalAttrs[key] = this.getNormalAttribute(key);
            });
        }
        this.normalAttrs = newNormalAttrs;
    }
    stopStateAnimates(type = 'end') {
        if (this.animates) {
            this.animates.forEach(animate => {
                if (animate.stateNames) {
                    animate.stop(type);
                    this.animates.delete(animate.id);
                }
            });
        }
    }
    getNormalAttribute(key) {
        var _a, _b;
        const value = this.attribute[key];
        if (this.animates) {
            return (_a = this.finalAttribute) === null || _a === void 0 ? void 0 : _a[key];
        }
        return value !== null && value !== void 0 ? value : (_b = this.finalAttribute) === null || _b === void 0 ? void 0 : _b[key];
    }
    clearStates(hasAnimation) {
        if (this.hasState() && this.normalAttrs) {
            this.currentStates = [];
            this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, true);
        }
        else {
            this.currentStates = [];
        }
        this.normalAttrs = null;
    }
    removeState(stateName, hasAnimation) {
        if (this.currentStates) {
            const filter = isArray(stateName) ? (s) => !stateName.includes(s) : (s) => s !== stateName;
            const newStates = this.currentStates.filter(filter);
            if (newStates.length !== this.currentStates.length) {
                this.useStates(newStates, hasAnimation);
            }
        }
    }
    toggleState(stateName, hasAnimation) {
        if (this.hasState(stateName)) {
            this.removeState(stateName, hasAnimation);
        }
        else {
            const index = this.currentStates ? this.currentStates.indexOf(stateName) : -1;
            if (index < 0) {
                const nextStates = this.currentStates ? this.currentStates.slice() : [];
                nextStates.push(stateName);
                this.useStates(nextStates, hasAnimation);
            }
        }
    }
    addState(stateName, keepCurrentStates, hasAnimation) {
        var _a;
        if (this.currentStates &&
            this.currentStates.includes(stateName) &&
            (keepCurrentStates || this.currentStates.length === 1)) {
            return;
        }
        const newStates = keepCurrentStates && ((_a = this.currentStates) === null || _a === void 0 ? void 0 : _a.length) ? this.currentStates.concat([stateName]) : [stateName];
        this.useStates(newStates, hasAnimation);
    }
    useStates(states, hasAnimation) {
        var _a;
        if (!states.length) {
            this.clearStates(hasAnimation);
            return;
        }
        const isChange = ((_a = this.currentStates) === null || _a === void 0 ? void 0 : _a.length) !== states.length ||
            states.some((stateName, index) => this.currentStates[index] !== stateName);
        if (!isChange) {
            return;
        }
        const stateAttrs = {};
        states.forEach(stateName => {
            var _a;
            const attrs = this.stateProxy ? this.stateProxy(stateName, states) : (_a = this.states) === null || _a === void 0 ? void 0 : _a[stateName];
            if (attrs) {
                Object.assign(stateAttrs, attrs);
            }
        });
        this.updateNormalAttrs(stateAttrs);
        this.currentStates = states;
        this.applyStateAttrs(stateAttrs, states, hasAnimation);
    }
    addUpdateBoundTag() {
        this._updateTag |= UpdateTag.UPDATE_BOUNDS;
        if (this.parent) {
            this.parent.addChildUpdateBoundTag();
        }
        if (this.glyphHost) {
            this.glyphHost.addUpdateBoundTag();
        }
    }
    addUpdateShapeTag() {
        this._updateTag |= UpdateTag.UPDATE_SHAPE;
    }
    addUpdateShapeAndBoundsTag() {
        this._updateTag |= UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
        if (this.parent) {
            this.parent.addChildUpdateBoundTag();
        }
        if (this.glyphHost) {
            this.glyphHost.addUpdateBoundTag();
        }
    }
    updateShapeAndBoundsTagSetted() {
        return (this._updateTag & UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
    }
    clearUpdateBoundTag() {
        this._updateTag &= UpdateTag.CLEAR_BOUNDS;
    }
    addUpdatePositionTag() {
        this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag();
        this._updateTag |= UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;
    }
    addUpdateGlobalPositionTag() {
        this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag();
        this._updateTag |= UpdateTag.UPDATE_GLOBAL_MATRIX;
    }
    clearUpdateLocalPositionTag() {
        this._updateTag &= UpdateTag.CLEAR_LOCAL_MATRIX;
    }
    clearUpdateGlobalPositionTag() {
        this._updateTag &= UpdateTag.CLEAR_GLOBAL_MATRIX;
    }
    addUpdateLayoutTag() {
        this._updateTag |= UpdateTag.UPDATE_LAYOUT;
    }
    clearUpdateLayoutTag() {
        this._updateTag &= UpdateTag.CLEAR_LAYOUT;
    }
    needUpdateLayout() {
        return !!(this._updateTag & UpdateTag.UPDATE_LAYOUT);
    }
    getAnchor(anchor, params, resetScale) {
        const _anchor = [0, 0];
        const getBounds = () => {
            if (params.b) {
                return params.b;
            }
            const graphic = this.clone();
            graphic.attribute.angle = 0;
            graphic.attribute.scaleCenter = null;
            if (resetScale) {
                graphic.attribute.scaleX = 1;
                graphic.attribute.scaleY = 1;
            }
            params.b = graphic.AABBBounds;
            return params.b;
        };
        if (typeof anchor[0] === 'string') {
            const ratio = parseFloat(anchor[0]) / 100;
            const bounds = getBounds();
            _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        }
        else {
            _anchor[0] = anchor[0];
        }
        if (typeof anchor[1] === 'string') {
            const ratio = parseFloat(anchor[1]) / 100;
            const bounds = getBounds();
            _anchor[1] = bounds.y1 + (bounds.y2 - bounds.y1) * ratio;
        }
        else {
            _anchor[1] = anchor[1];
        }
        return _anchor;
    }
    doUpdateLocalMatrix() {
        const { x = DefaultTransform.x, y = DefaultTransform.y, scaleX = DefaultTransform.scaleX, scaleY = DefaultTransform.scaleY, angle = DefaultTransform.angle, scaleCenter, anchor, postMatrix } = this.attribute;
        let _anchor = [0, 0];
        const params = {};
        if (anchor && angle) {
            _anchor = this.getAnchor(anchor, params);
        }
        if (scaleCenter && (scaleX !== 1 || scaleY !== 1)) {
            const m = this._transMatrix;
            m.reset();
            m.translate(_anchor[0], _anchor[1]);
            m.rotate(angle);
            m.translate(-_anchor[0], -_anchor[1]);
            m.translate(x, y);
            _anchor = this.getAnchor(scaleCenter, params, true);
            application.transformUtil.fromMatrix(m, m).scale(scaleX, scaleY, { x: _anchor[0], y: _anchor[1] });
        }
        else {
            normalTransform(this._transMatrix, this._transMatrix.reset(), x, y, scaleX, scaleY, angle, anchor && _anchor);
        }
        const p = this.getOffsetXY(DefaultTransform);
        this._transMatrix.e += p.x;
        this._transMatrix.f += p.y;
        if (postMatrix) {
            const m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f);
            const m2 = this._transMatrix;
            m1.multiply(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
            m2.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);
        }
    }
    doUpdateGlobalMatrix() {
        if (this.parent) {
            this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);
            const { scrollX = 0, scrollY = 0 } = this.parent.attribute;
            this._globalTransMatrix.translate(scrollX, scrollY);
        }
    }
    setStage(stage, layer) {
        if (this.stage !== stage) {
            this.stage = stage;
            this.layer = layer;
            this.setStageToShadowRoot(stage, layer);
            if (this.animates && this.animates.size) {
                const timeline = stage.getTimeline();
                this.animates.forEach(a => {
                    if (a.timeline.isGlobal) {
                        a.setTimeline(timeline);
                        timeline.addAnimate(a);
                    }
                });
            }
            this._onSetStage && this._onSetStage(this, stage, layer);
            this.getGraphicService().onSetStage(this, stage);
        }
    }
    setStageToShadowRoot(stage, layer) {
        if (this.shadowRoot) {
            this.shadowRoot.setStage(stage, layer);
        }
    }
    onAddStep(step) {
        return;
    }
    onStop(props) {
        if (props) {
            this.setAttributes(props, false, { type: AttributeUpdateType.ANIMATE_END });
        }
    }
    getDefaultAttribute(name) {
        return this.getGraphicTheme()[name];
    }
    getComputedAttribute(name) {
        var _a;
        return (_a = this.attribute[name]) !== null && _a !== void 0 ? _a : this.getDefaultAttribute(name);
    }
    onSetStage(cb, immediate = false) {
        this._onSetStage = cb;
        if (immediate && this.stage) {
            cb(this, this.stage);
        }
    }
    attachShadow(shadowRoot) {
        if (shadowRoot) {
            shadowRoot.shadowHost = this;
        }
        this.shadowRoot = shadowRoot !== null && shadowRoot !== void 0 ? shadowRoot : application.graphicService.creator.shadowRoot(this);
        this.addUpdateBoundTag();
        this.shadowRoot.setStage(this.stage, this.layer);
        return this.shadowRoot;
    }
    detachShadow() {
        if (this.shadowRoot) {
            this.addUpdateBoundTag();
            this.shadowRoot.release(true);
            this.shadowRoot = null;
        }
    }
    toJson() {
        return {
            attribute: this.attribute,
            _uid: this._uid,
            type: this.type,
            name: this.name,
            children: this.children.map((item) => item.toJson())
        };
    }
    createPathProxy(path) {
        if (isString(path, true)) {
            this.pathProxy = new CustomPath2D().fromString(path);
        }
        else {
            this.pathProxy = new CustomPath2D();
        }
        return this.pathProxy;
    }
    loadImage(image, background = false) {
        if (!image || (background && backgroundNotImage(image))) {
            return;
        }
        const url = image;
        if (!this.resources) {
            this.resources = new Map();
        }
        const cache = {
            data: 'init',
            state: null
        };
        this.resources.set(url, cache);
        if (typeof image === 'string') {
            cache.state = 'loading';
            if (image.startsWith('<svg')) {
                ResourceLoader.GetSvg(image, this);
                this.backgroundImg = this.backgroundImg || background;
            }
            else if (isValidUrl(image) || image.includes('/') || isBase64(image)) {
                ResourceLoader.GetImage(image, this);
                this.backgroundImg = this.backgroundImg || background;
            }
        }
        else if (isObject(image)) {
            (cache.state = 'success'), (cache.data = image);
            this.backgroundImg = this.backgroundImg || background;
        }
        else {
            cache.state = 'fail';
        }
    }
    setShadowGraphic(graphic) {
        if (!graphic) {
            this.detachShadow();
        }
        else {
            const root = this.attachShadow();
            root.add(graphic);
        }
    }
    imageLoadSuccess(url, image, cb) {
        if (!this.resources) {
            return;
        }
        const res = this.resources.get(url);
        if (!res) {
            return;
        }
        res.state = 'success';
        res.data = image;
        cb && cb();
        this.addUpdateBoundTag();
        this.stage && this.stage.renderNextFrame();
    }
    imageLoadFail(url, cb) {
        if (!this.resources) {
            return;
        }
        const res = this.resources.get(url);
        if (!res) {
            return;
        }
        res.state = 'fail';
        cb && cb();
    }
    _stopAnimates(animates) {
        if (animates) {
            animates.forEach(animate => {
                animate.stop();
            });
        }
    }
    stopAnimates(stopChildren = false) {
        this._stopAnimates(this.animates);
        if (this.shadowRoot) {
            this.shadowRoot.stopAnimates(true);
        }
        if (this.isContainer && stopChildren) {
            this.forEachChildren((c) => {
                c.stopAnimates(stopChildren);
            });
        }
    }
    release() {
        this.releaseStatus = 'released';
        this.stopAnimates();
        application.graphicService.onRelease(this);
    }
    _emitCustomEvent(type, context) {
        var _a, _b;
        if (this._events && type in this._events) {
            const changeEvent = new CustomEvent(type, context);
            changeEvent.bubbles = false;
            changeEvent.manager = (_b = (_a = this.stage) === null || _a === void 0 ? void 0 : _a.eventSystem) === null || _b === void 0 ? void 0 : _b.manager;
            this.dispatchEvent(changeEvent);
        }
    }
    toCustomPath() {
        var _a, _b, _c;
        const renderer = (_c = (_b = (((_a = this.stage) === null || _a === void 0 ? void 0 : _a.renderService) || application.renderService)) === null || _b === void 0 ? void 0 : _b.drawContribution) === null || _c === void 0 ? void 0 : _c.getRenderContribution(this);
        if (renderer) {
            const context = new EmptyContext2d(null, 1);
            renderer.drawShape(this, context, 0, 0, {}, {});
            return context.path;
        }
        return null;
    }
}
Graphic.userSymbolMap = {};
Graphic.mixin(EventTarget);
function backgroundNotImage(image) {
    if (image.fill || image.stroke) {
        return true;
    }
    return false;
}

var GroupUpdateAABBBoundsMode;
(function (GroupUpdateAABBBoundsMode) {
    GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode["LESS_GROUP"] = 0] = "LESS_GROUP";
    GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode["MORE_GROUP"] = 1] = "MORE_GROUP";
})(GroupUpdateAABBBoundsMode || (GroupUpdateAABBBoundsMode = {}));
class Group extends Graphic {
    constructor(params) {
        super(params);
        this.type = 'group';
        this.parent = null;
        this.isContainer = true;
        this.numberType = GROUP_NUMBER_TYPE;
        this._childUpdateTag = UpdateTag.UPDATE_BOUNDS;
    }
    setMode(mode) {
        mode === '3d' ? this.set3dMode() : this.set2dMode();
    }
    set3dMode() {
        this.in3dMode = true;
    }
    set2dMode() {
        this.in3dMode = false;
    }
    setTheme(t) {
        if (!this.theme) {
            this.theme = new Theme();
        }
        return this.theme.setTheme(t, this);
    }
    createTheme() {
        if (!this.theme) {
            this.theme = new Theme();
        }
    }
    visibleAll(visible) {
        this.setAttribute('visible', visible);
        this.forEachChildren((item) => {
            if (item.isContainer && item.visibleAll) {
                item.visibleAll(visible);
            }
            else {
                item.setAttribute('visible', visible);
            }
        });
    }
    hideAll() {
        this.visibleAll(false);
    }
    showAll() {
        this.visibleAll(true);
    }
    containsPoint(x, y, mode) {
        if (mode === IContainPointMode.GLOBAL) {
            const point = new Point(x, y);
            if (this.parent) {
                this.parent.globalTransMatrix.transformPoint(point, point);
            }
            return this.AABBBounds.contains(point.x, point.y);
        }
        return this.AABBBounds.contains(x, y);
    }
    shouldUpdateAABBBounds() {
        if (super.shouldUpdateAABBBounds()) {
            return true;
        }
        if (this._childUpdateTag & UpdateTag.UPDATE_BOUNDS) {
            return true;
        }
        return false;
    }
    tryUpdateAABBBounds() {
        if (!this.shouldUpdateAABBBounds()) {
            return this._AABBBounds;
        }
        this.getGraphicService().beforeUpdateAABBBounds(this, this.stage, true, this._AABBBounds);
        const selfChange = this.shouldSelfChangeUpdateAABBBounds();
        const bounds = this.doUpdateAABBBounds();
        this.addUpdateLayoutTag();
        this.getGraphicService().afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange);
        if (this.attribute.boundsMode === 'empty') {
            bounds.clear();
        }
        return bounds;
    }
    doUpdateLocalMatrix() {
        const { x = DefaultTransform.x, y = DefaultTransform.y, dx = DefaultTransform.dx, dy = DefaultTransform.dy, scaleX = DefaultTransform.scaleX, scaleY = DefaultTransform.scaleY, angle = DefaultTransform.angle, postMatrix } = this.attribute;
        if (x === 0 && y === 0 && dx === 0 && dy === 0 && scaleX === 1 && scaleY === 1 && angle === 0 && !postMatrix) {
            this._transMatrix.reset();
            return;
        }
        return super.doUpdateLocalMatrix();
    }
    getGraphicTheme() {
        return getTheme(this).group;
    }
    updateAABBBounds(attribute, groupTheme, aabbBounds) {
        const originalAABBBounds = aabbBounds;
        aabbBounds = aabbBounds.clone();
        const { width, height, path, clip = groupTheme.clip } = attribute;
        if (path && path.length) {
            path.forEach(g => {
                aabbBounds.union(g.AABBBounds);
            });
        }
        else if (width != null && height != null) {
            aabbBounds.set(0, 0, Math.max(0, width), Math.max(0, height));
        }
        if (!clip) {
            this.forEachChildren((node) => {
                aabbBounds.union(node.AABBBounds);
            });
            const { scrollX = 0, scrollY = 0 } = attribute;
            aabbBounds.translate(scrollX, scrollY);
        }
        application.graphicService.updateTempAABBBounds(aabbBounds);
        application.graphicService.transformAABBBounds(attribute, aabbBounds, groupTheme, false, this);
        originalAABBBounds.copy(aabbBounds);
        return originalAABBBounds;
    }
    doUpdateAABBBounds() {
        this.updateAABBBoundsStamp++;
        const bounds = super.doUpdateAABBBounds();
        this.parent && this.parent.addChildUpdateBoundTag();
        this._emitCustomEvent('AAABBBoundsChange');
        return bounds;
    }
    clearUpdateBoundTag() {
        this._updateTag &= UpdateTag.CLEAR_BOUNDS;
        this._childUpdateTag &= UpdateTag.CLEAR_BOUNDS;
    }
    addUpdateBoundTag() {
        this._updateTag |= UpdateTag.UPDATE_BOUNDS;
        if (this.parent) {
            this.parent.addChildUpdateBoundTag();
        }
    }
    addChildUpdateBoundTag() {
        if (this._childUpdateTag & UpdateTag.UPDATE_BOUNDS) {
            return;
        }
        this._childUpdateTag |= UpdateTag.UPDATE_BOUNDS;
        this.parent && this.parent.addChildUpdateBoundTag();
    }
    getTheme() {
        return this.theme.getTheme(this);
    }
    incrementalAppendChild(node) {
        const data = super.appendChild(node);
        if (this.stage && data) {
            data.stage = this.stage;
            data.layer = this.layer;
        }
        this.addUpdateBoundTag();
        this.getGraphicService().onAddIncremental(node, this, this.stage);
        return data;
    }
    incrementalClearChild() {
        super.removeAllChild();
        this.addUpdateBoundTag();
        this.getGraphicService().onClearIncremental(this, this.stage);
        return;
    }
    _updateChildToStage(child) {
        if (this.stage && child) {
            child.setStage(this.stage, this.layer);
        }
        this.addUpdateBoundTag();
        return child;
    }
    appendChild(node, addStage = true) {
        const data = super.appendChild(node);
        if (addStage && this.stage && data) {
            data.setStage(this.stage, this.layer);
        }
        this.addUpdateBoundTag();
        return data;
    }
    insertBefore(newNode, referenceNode) {
        return this._updateChildToStage(super.insertBefore(newNode, referenceNode));
    }
    insertAfter(newNode, referenceNode) {
        return this._updateChildToStage(super.insertAfter(newNode, referenceNode));
    }
    insertInto(newNode, idx) {
        return this._updateChildToStage(super.insertInto(newNode, idx));
    }
    removeChild(child) {
        const data = super.removeChild(child);
        this.getGraphicService().onRemove(child);
        child.stage = null;
        this.addUpdateBoundTag();
        return data;
    }
    removeAllChild(deep = false) {
        this.forEachChildren((child) => {
            this.getGraphicService().onRemove(child);
            if (deep && child.isContainer) {
                child.removeAllChild(deep);
            }
        });
        super.removeAllChild();
        this.addUpdateBoundTag();
    }
    setStage(stage, layer) {
        if (this.stage !== stage) {
            this.stage = stage;
            this.layer = layer;
            this.setStageToShadowRoot(stage, layer);
            this._onSetStage && this._onSetStage(this, stage, layer);
            this.getGraphicService().onSetStage(this, stage);
            this.forEachChildren(item => {
                item.setStage(stage, this.layer);
            });
        }
    }
    addUpdatePositionTag() {
        super.addUpdatePositionTag();
        this.forEachChildren((g) => {
            if (g.isContainer) {
                g.addUpdateGlobalPositionTag();
            }
        });
    }
    addUpdateGlobalPositionTag() {
        super.addUpdateGlobalPositionTag();
        this.forEachChildren((g) => {
            if (g.isContainer) {
                g.addUpdateGlobalPositionTag();
            }
        });
    }
    tryUpdateGlobalTransMatrix(clearTag = true) {
        if (this.shouldUpdateGlobalMatrix()) {
            if (!this._globalTransMatrix) {
                this._globalTransMatrix = this.parent
                    ? this.parent.globalTransMatrix.clone()
                    : this.transMatrix.clone();
            }
            else if (this.parent) {
                const m = this.parent.globalTransMatrix;
                this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
            }
            this.doUpdateGlobalMatrix();
            clearTag && this.clearUpdateGlobalPositionTag();
        }
        return this._globalTransMatrix;
    }
    shouldUpdateGlobalMatrix() {
        const shouldUpdate = !!(this._updateTag & UpdateTag.UPDATE_GLOBAL_MATRIX);
        return shouldUpdate;
    }
    _getChildByName(name, deep) {
        return this.find(node => node.name === name, deep);
    }
    createOrUpdateChild(graphicName, attributes, graphicType) {
        let graphic = this._getChildByName(graphicName);
        if (graphic) {
            graphic.setAttributes(attributes);
        }
        else {
            graphic = application.graphicService.creator[graphicType](attributes);
            graphic.name = graphicName;
            this.add(graphic);
        }
        return graphic;
    }
    clone() {
        return new Group(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Group.NOWORK_ANIMATE_ATTR;
    }
    release(all) {
        if (all) {
            this.forEachChildren((g) => {
                g.release(all);
            });
        }
        super.release();
    }
}
Group.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createGroup(attributes) {
    return new Group(attributes);
}

class Layer extends Group {
    get offscreen() {
        return this.layerHandler.offscreen;
    }
    get layerMode() {
        return this.layerHandler.type;
    }
    get width() {
        if (!this.stage) {
            return 0;
        }
        return this.stage.width;
    }
    get height() {
        if (!this.stage) {
            return 0;
        }
        return this.stage.height;
    }
    get viewWidth() {
        if (!this.stage) {
            return 0;
        }
        return this.stage.viewWidth;
    }
    get viewHeight() {
        if (!this.stage) {
            return 0;
        }
        return this.stage.viewHeight;
    }
    get dirtyBound() {
        throw new Error('暂不支持');
    }
    get dpr() {
        return this._dpr;
    }
    constructor(stage, global, window, params) {
        var _a;
        super({});
        this.stage = stage;
        this.global = global;
        this.window = window;
        this.main = params.main;
        this.layerHandler = params.layerHandler;
        this.layerHandler.init(this, window, {
            main: params.main,
            canvasId: params.canvasId,
            width: this.viewWidth,
            height: this.viewHeight,
            zIndex: (_a = params.zIndex) !== null && _a !== void 0 ? _a : 0
        });
        this.layer = this;
        this.subLayers = new Map();
        this.theme = new Theme();
        this.background = 'rgba(0, 0, 0, 0)';
        this.afterDrawCbs = [];
    }
    combineSubLayer(removeIncrementalKey = true) {
        const subLayers = Array.from(this.subLayers.values()).sort((a, b) => {
            return a.zIndex - b.zIndex;
        });
        this.layerHandler.merge(subLayers.map(l => {
            if (l.layer.subLayers.size) {
                l.layer.combineSubLayer(removeIncrementalKey);
            }
            return l.layer.getNativeHandler();
        }));
        if (removeIncrementalKey) {
            subLayers.forEach(l => {
                l.group && (l.group.incremental = 0);
            });
        }
        subLayers.forEach(l => {
            application.layerService.releaseLayer(this.stage, l.layer);
        });
        this.subLayers.clear();
    }
    getNativeHandler() {
        return this.layerHandler;
    }
    setStage(stage, layer) {
        super.setStage(stage, this);
    }
    pick(x, y) {
        throw new Error('暂不支持');
    }
    tryRenderSecondaryLayer(params, userParams) {
        if (this.layerHandler.secondaryHandlers && this.layerHandler.secondaryHandlers.length) {
            this.layerHandler.secondaryHandlers.forEach(h => {
                h.layer.renderCount = this.renderCount;
                h.layer.render(params, userParams);
            });
        }
    }
    render(params, userParams) {
        var _a;
        this.layerHandler.render([this], {
            renderService: params.renderService,
            stage: this.stage,
            layer: this,
            viewBox: params.viewBox,
            transMatrix: params.transMatrix,
            background: (_a = params.background) !== null && _a !== void 0 ? _a : this.background,
            updateBounds: params.updateBounds
        }, userParams);
        this.afterDrawCbs.forEach(c => c(this));
        this.tryRenderSecondaryLayer(params, userParams);
    }
    resize(w, h) {
        this.layerHandler.resize(w, h);
    }
    resizeView(w, h) {
        this.layerHandler.resizeView(w, h);
    }
    setDpr(dpr) {
        this.layerHandler.setDpr(dpr);
    }
    afterDraw(cb) {
        this.afterDrawCbs.push(cb);
    }
    startAnimate(t) {
        throw new Error('暂不支持');
    }
    setToFrame(t) {
        throw new Error('暂不支持');
    }
    prepare(dirtyBounds, params) {
        return;
    }
    release() {
        super.release();
        this.layerHandler.release();
        if (this.subLayers) {
            this.subLayers.forEach(l => {
                application.layerService.releaseLayer(this.stage, l.layer);
            });
        }
    }
    drawTo(target, params) {
        var _a;
        this.layerHandler.drawTo(target, [this], Object.assign({ background: (_a = params.background) !== null && _a !== void 0 ? _a : this.background, renderService: params.renderService, viewBox: params.viewBox, transMatrix: params.transMatrix, stage: this.stage, layer: this }, params));
        this.afterDrawCbs.forEach(c => c(this));
    }
}

const TransformUtil = Symbol.for('TransformUtil');
const GraphicUtil = Symbol.for('GraphicUtil');
const LayerService = Symbol.for('LayerService');
const StaticLayerHandlerContribution = Symbol.for('StaticLayerHandlerContribution');
const DynamicLayerHandlerContribution = Symbol.for('DynamicLayerHandlerContribution');
const VirtualLayerHandlerContribution = Symbol.for('VirtualLayerHandlerContribution');

var DefaultLayerService_1;
let DefaultLayerService = DefaultLayerService_1 = class DefaultLayerService {
    static GenerateLayerId() {
        return `${DefaultLayerService_1.idprefix}_${DefaultLayerService_1.prefix_count++}`;
    }
    constructor() {
        this.layerMap = new Map();
        this.global = application.global;
    }
    tryInit() {
        if (!this.inited) {
            this.staticLayerCountInEnv = this.global.getStaticCanvasCount();
            this.dynamicLayerCountInEnv = this.global.getDynamicCanvasCount();
            this.inited = true;
        }
    }
    getStageLayer(stage) {
        return this.layerMap.get(stage);
    }
    getRecommendedLayerType(layerMode) {
        if (layerMode) {
            return layerMode;
        }
        if (this.staticLayerCountInEnv !== 0) {
            return 'static';
        }
        else if (this.dynamicLayerCountInEnv !== 0) {
            return 'dynamic';
        }
        return 'virtual';
    }
    getLayerHandler(layerMode) {
        let layerHandler;
        if (layerMode === 'static') {
            layerHandler = container.get(StaticLayerHandlerContribution);
        }
        else if (layerMode === 'dynamic') {
            layerHandler = container.get(DynamicLayerHandlerContribution);
        }
        else {
            layerHandler = container.get(VirtualLayerHandlerContribution);
        }
        return layerHandler;
    }
    createLayer(stage, options = { main: false }) {
        var _a;
        this.tryInit();
        let layerMode = this.getRecommendedLayerType(options.layerMode);
        layerMode = options.main ? 'static' : options.canvasId ? 'static' : layerMode;
        const layerHandler = this.getLayerHandler(layerMode);
        const layer = new Layer(stage, this.global, stage.window, Object.assign(Object.assign({ main: false }, options), { layerMode, canvasId: (_a = options.canvasId) !== null && _a !== void 0 ? _a : DefaultLayerService_1.GenerateLayerId(), layerHandler }));
        const stageLayers = this.layerMap.get(stage) || [];
        stageLayers.push(layer);
        this.layerMap.set(stage, stageLayers);
        this.staticLayerCountInEnv--;
        return layer;
    }
    prepareStageLayer(stage) {
        let mainHandler;
        stage.forEachChildren((l) => {
            const handler = l.getNativeHandler();
            if (handler.type === 'virtual') {
                handler.mainHandler = mainHandler;
                mainHandler.secondaryHandlers.push(handler);
            }
            else {
                mainHandler = handler;
                mainHandler.secondaryHandlers = [];
            }
        });
    }
    releaseLayer(stage, layer) {
        layer.release();
        const stageLayers = this.layerMap.get(stage) || [];
        this.layerMap.set(stage, stageLayers.filter(l => l !== layer));
    }
    layerCount(stage) {
        return (this.layerMap.get(stage) || []).length;
    }
    restLayerCount(stage) {
        if (this.global.env === 'browser') {
            return 10;
        }
        return 0;
    }
    releaseStage(stage) {
        this.layerMap.delete(stage);
    }
};
DefaultLayerService.idprefix = 'visactor_layer';
DefaultLayerService.prefix_count = 0;
DefaultLayerService = DefaultLayerService_1 = __decorate([
    injectable(),
    __metadata("design:paramtypes", [])
], DefaultLayerService);

var coreModule = new ContainerModule(bind => {
    bind(VGlobal).to(DefaultGlobal).inSingletonScope();
    bind(VWindow).to(DefaultWindow);
    bind(GraphicUtil).to(DefaultGraphicUtil).inSingletonScope();
    bind(TransformUtil).to(DefaultTransformUtil).inSingletonScope();
    bind(LayerService).to(DefaultLayerService).inSingletonScope();
});

function runFill(fill, background) {
    return !!(fill || background);
}
function runStroke(stroke, lineWidth) {
    let s;
    if (isArray(stroke)) {
        s = stroke.some(item => item || item === undefined);
    }
    else {
        s = !!stroke;
    }
    return s && lineWidth > 0;
}
function fillVisible(opacity, fillOpacity, fill) {
    return fill && opacity * fillOpacity > 0;
}
function rectFillVisible(opacity, fillOpacity, width, height, fill) {
    return fill && opacity * fillOpacity > 0 && width !== 0 && height !== 0;
}
function strokeVisible(opacity, strokeOpacity) {
    return opacity * strokeOpacity > 0;
}
function rectStrokeVisible(opacity, strokeOpacity, width, height, drawStrokeWhenZeroWH) {
    if (drawStrokeWhenZeroWH) {
        return opacity * strokeOpacity > 0;
    }
    return opacity * strokeOpacity > 0 && width !== 0 && height !== 0;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
    const x10 = x1 - x0;
    const y10 = y1 - y0;
    const x32 = x3 - x2;
    const y32 = y3 - y2;
    let t = y32 * x10 - x32 * y10;
    if (t * t < epsilon) {
        return [];
    }
    t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
    return [x0 + t * x10, y0 + t * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
    const x01 = x0 - x1;
    const y01 = y0 - y1;
    const lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01);
    const ox = lo * y01;
    const oy = -lo * x01;
    const x11 = x0 + ox;
    const y11 = y0 + oy;
    const x10 = x1 + ox;
    const y10 = y1 + oy;
    const x00 = (x11 + x10) / 2;
    const y00 = (y11 + y10) / 2;
    const dx = x10 - x11;
    const dy = y10 - y11;
    const d2 = dx * dx + dy * dy;
    const r = r1 - rc;
    const D = x11 * y10 - x10 * y11;
    const d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
    let cx0 = (D * dy - dx * d) / d2;
    let cy0 = (-D * dx - dy * d) / d2;
    const cx1 = (D * dy + dx * d) / d2;
    const cy1 = (-D * dx + dy * d) / d2;
    const dx0 = cx0 - x00;
    const dy0 = cy0 - y00;
    const dx1 = cx1 - x00;
    const dy1 = cy1 - y00;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
        (cx0 = cx1), (cy0 = cy1);
    }
    return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
    };
}
function calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius) {
    const deltaAngle = abs(endAngle - startAngle);
    const cornerRadius = arc.getParsedCornerRadius();
    const cornerRadiusIsArray = isArray(cornerRadius);
    const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle);
    const outerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[0] : cornerRadius;
    const outerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[1] : cornerRadius;
    const innerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[2] : cornerRadius;
    const innerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[3] : cornerRadius;
    const maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart);
    const maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
    let limitedOcr = maxOuterCornerRadius;
    let limitedIcr = maxInnerCornerRadius;
    const xors = outerRadius * cos(outerStartAngle);
    const yors = outerRadius * sin(outerStartAngle);
    const xire = innerRadius * cos(innerEndAngle);
    const yire = innerRadius * sin(innerEndAngle);
    let xore;
    let yore;
    let xirs;
    let yirs;
    if (maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) {
        xore = outerRadius * cos(outerEndAngle);
        yore = outerRadius * sin(outerEndAngle);
        xirs = innerRadius * cos(innerStartAngle);
        yirs = innerRadius * sin(innerStartAngle);
        if (deltaAngle < pi) {
            const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
            if (oc) {
                const ax = xors - oc[0];
                const ay = yors - oc[1];
                const bx = xore - oc[0];
                const by = yore - oc[1];
                const kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2);
                const lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1));
                limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
            }
        }
    }
    return {
        outerDeltaAngle,
        xors,
        yors,
        xirs,
        yirs,
        xore,
        yore,
        xire,
        yire,
        limitedOcr,
        limitedIcr,
        outerCornerRadiusStart,
        outerCornerRadiusEnd,
        maxOuterCornerRadius,
        maxInnerCornerRadius,
        outerStartAngle,
        outerEndAngle,
        innerDeltaAngle,
        innerEndAngle,
        innerStartAngle,
        innerCornerRadiusStart,
        innerCornerRadiusEnd
    };
}
function drawArcPath$1(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
    const { startAngle, endAngle } = arc.getParsedAngle();
    const deltaAngle = abs(endAngle - startAngle);
    const clockwise = endAngle > startAngle;
    let collapsedToLine = false;
    if (outerRadius < innerRadius) {
        const temp = outerRadius;
        outerRadius = innerRadius;
        innerRadius = temp;
    }
    if (outerRadius <= epsilon) {
        context.moveTo(cx, cy);
    }
    else if (deltaAngle >= pi2 - epsilon) {
        context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle));
        context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise);
        if (innerRadius > epsilon) {
            context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle));
            context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
        }
    }
    else {
        const { outerDeltaAngle, xors, yors, xirs, yirs, limitedOcr, outerCornerRadiusStart, outerCornerRadiusEnd, maxOuterCornerRadius, xore, yore, xire, yire, outerStartAngle, outerEndAngle, limitedIcr, innerDeltaAngle, innerEndAngle, innerStartAngle, innerCornerRadiusStart, innerCornerRadiusEnd, maxInnerCornerRadius } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
        if (outerDeltaAngle < 0.001) {
            if (partStroke && (partStroke[3] || partStroke[1])) {
                context.moveTo(cx + xors, cy + yors);
            }
            collapsedToLine = true;
        }
        else if (limitedOcr > epsilon) {
            const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr);
            const cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr);
            const t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise));
            const t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
            if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                if (!partStroke || partStroke[0]) {
                    context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
                    context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);
                }
                else {
                    context.moveTo(cx + t0.cx + limitedOcr * cos(atan2(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * sin(atan2(t1.y01, t1.x01)));
                }
            }
            else {
                if (!partStroke || partStroke[0]) {
                    context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
                    cornerRadiusStart > 0 &&
                        context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
                    context.arc(cx, cy, outerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise);
                    cornerRadiusEnd > 0 &&
                        context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
                }
                else {
                    if (cornerRadiusEnd > 0) {
                        context.moveTo(cx + t1.cx + cornerRadiusEnd * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * sin(atan2(t1.y01, t1.x01)));
                    }
                    else {
                        context.moveTo(cx + xore, cy + outerRadius * sin(outerEndAngle));
                    }
                }
            }
        }
        else {
            if (!partStroke || partStroke[0]) {
                context.moveTo(cx + xors, cy + yors);
                context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise);
            }
            else {
                context.moveTo(cx + outerRadius * cos(outerEndAngle), cy + outerRadius * sin(outerEndAngle));
            }
        }
        if (!(innerRadius > epsilon) || innerDeltaAngle < 0.001) {
            if (!partStroke || partStroke[1]) {
                context.lineTo(cx + xire, cy + yire);
            }
            else {
                context.moveTo(cx + xire, cy + yire);
            }
            collapsedToLine = true;
        }
        else if (limitedIcr > epsilon) {
            const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr);
            const cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr);
            const t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise));
            const t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
            if (!partStroke || partStroke[1]) {
                context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
            }
            else {
                context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
            }
            if (limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                const arcEndAngle = atan2(t1.y01, t1.x01);
                if (!partStroke || partStroke[2]) {
                    context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);
                }
                else {
                    context.moveTo(cx + t0.cx + cos(arcEndAngle), cy + t0.cy + sin(arcEndAngle));
                }
            }
            else {
                if (!partStroke || partStroke[2]) {
                    cornerRadiusEnd > 0 &&
                        context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
                    context.arc(cx, cy, innerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), clockwise);
                    cornerRadiusStart > 0 &&
                        context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
                }
                else {
                    if (cornerRadiusStart > 0) {
                        context.moveTo(cx + t1.cx + cornerRadiusStart * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * sin(atan2(t1.y01, t1.x01)));
                    }
                    else {
                        context.moveTo(cx + xirs, cy + yirs);
                    }
                }
            }
        }
        else {
            if (!partStroke || partStroke[1]) {
                context.lineTo(cx + xire, cy + yire);
            }
            else {
                context.moveTo(cx + xire, cy + yire);
            }
            if (!partStroke || partStroke[2]) {
                context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise);
            }
            else {
                context.moveTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
            }
        }
    }
    if (!partStroke) {
        context.closePath();
    }
    else if (partStroke[3]) {
        context.lineTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle));
    }
    return collapsedToLine;
}

const ArcRenderContribution = Symbol.for('ArcRenderContribution');
const AreaRenderContribution = Symbol.for('AreaRenderContribution');
const CircleRenderContribution = Symbol.for('CircleRenderContribution');
const GroupRenderContribution = Symbol.for('GroupRenderContribution');
const ImageRenderContribution = Symbol.for('ImageRenderContribution');
const PathRenderContribution = Symbol.for('PathRenderContribution');
const PolygonRenderContribution = Symbol.for('PolygonRenderContribution');
const RectRenderContribution = Symbol.for('RectRenderContribution');
const SymbolRenderContribution = Symbol.for('SymbolRenderContribution');
const TextRenderContribution = Symbol.for('TextRenderContribution');
const StarRenderContribution = Symbol.for('StarRenderContribution');
const CommonRenderContribution = Symbol.for('CommonRenderContribution');
const InteractiveSubRenderContribution = Symbol.for('InteractiveSubRenderContribution');

function textDrawOffsetY(baseline, h) {
    const offset = baseline === 'top'
        ? Math.ceil(0.79 * h)
        : baseline === 'middle'
            ? Math.round(0.3 * h)
            : baseline === 'bottom'
                ? Math.round(-0.21 * h)
                : 0;
    return offset;
}
function textDrawOffsetX(textAlign, width) {
    if (textAlign === 'end' || textAlign === 'right') {
        return -width;
    }
    else if (textAlign === 'center') {
        return -width / 2;
    }
    return 0;
}
function textLayoutOffsetY(baseline, lineHeight, fontSize, buf = 0) {
    if (baseline === 'middle') {
        return -lineHeight / 2;
    }
    if (baseline === 'top') {
        return 0;
    }
    if (baseline === 'bottom') {
        return buf - lineHeight;
    }
    if (!baseline || baseline === 'alphabetic') {
        if (!fontSize) {
            fontSize = lineHeight;
        }
        return -(lineHeight - fontSize) / 2 - 0.79 * fontSize;
    }
    return 0;
}
function textAttributesToStyle(attrs) {
    const stringTypes = ['textAlign', 'fontFamily', 'fontVariant', 'fontStyle', 'fontWeight'];
    const pxKeys = ['fontSize', 'lineHeight'];
    const style = {};
    const parsePxValue = (value) => {
        return /^\d+(\.\d+)?$/.test(`${value}`) ? `${value}px` : `${value}`;
    };
    stringTypes.forEach(key => {
        if (attrs[key]) {
            style[lowerCamelCaseToMiddle(key)] = attrs[key];
        }
    });
    pxKeys.forEach(key => {
        const styleKey = lowerCamelCaseToMiddle(key);
        if (!isNil(attrs[key])) {
            style[styleKey] = parsePxValue(attrs[key]);
        }
    });
    if (isValid(attrs.maxLineWidth)) {
        style['max-width'] = parsePxValue(attrs.maxLineWidth);
    }
    if (attrs.underline) {
        style['text-decoration'] = 'underline';
    }
    else if (attrs.lineThrough) {
        style['text-decoration'] = 'line-through';
    }
    if (attrs.fill) {
        if (isString(attrs.fill)) {
            style.color = attrs.fill;
        }
    }
    return style;
}

function getExtraModelMatrix(dx, dy, graphic) {
    const { alpha, beta } = graphic.attribute;
    if (!alpha && !beta) {
        return null;
    }
    const { anchor3d = graphic.attribute.anchor } = graphic.attribute;
    const _anchor = [0, 0];
    if (anchor3d) {
        if (typeof anchor3d[0] === 'string') {
            const ratio = parseFloat(anchor3d[0]) / 100;
            const bounds = graphic.AABBBounds;
            _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        }
        else {
            _anchor[0] = anchor3d[0];
        }
        if (typeof anchor3d[1] === 'string') {
            const ratio = parseFloat(anchor3d[1]) / 100;
            const bounds = graphic.AABBBounds;
            _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        }
        else {
            _anchor[1] = anchor3d[1];
        }
    }
    if (graphic.type === 'text') {
        const { textAlign } = graphic.attribute;
        _anchor[0] += textDrawOffsetX(textAlign, graphic.clipedWidth);
    }
    _anchor[0] += dx;
    _anchor[1] += dy;
    const modelMatrix = mat4Allocate.allocate();
    translate(modelMatrix, modelMatrix, [_anchor[0], _anchor[1], 0]);
    if (beta) {
        rotateX(modelMatrix, modelMatrix, beta);
    }
    if (alpha) {
        rotateY(modelMatrix, modelMatrix, alpha);
    }
    translate(modelMatrix, modelMatrix, [-_anchor[0], -_anchor[1], 0]);
    return modelMatrix;
}
function getModelMatrix(out, graphic, theme) {
    var _a;
    const { x = theme.x, y = theme.y, z = theme.z, dx = theme.dx, dy = theme.dy, dz = theme.dz, scaleX = theme.scaleX, scaleY = theme.scaleY, scaleZ = theme.scaleZ, alpha = theme.alpha, beta = theme.beta, angle = theme.angle, anchor3d = graphic.attribute.anchor, anchor } = graphic.attribute;
    const _anchor = [0, 0, 0];
    if (anchor3d) {
        if (typeof anchor3d[0] === 'string') {
            const ratio = parseFloat(anchor3d[0]) / 100;
            const bounds = graphic.AABBBounds;
            _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        }
        else {
            _anchor[0] = anchor3d[0];
        }
        if (typeof anchor3d[1] === 'string') {
            const ratio = parseFloat(anchor3d[1]) / 100;
            const bounds = graphic.AABBBounds;
            _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
        }
        else {
            _anchor[1] = anchor3d[1];
        }
        _anchor[2] = (_a = anchor3d[2]) !== null && _a !== void 0 ? _a : 0;
    }
    identityMat4(out);
    translate(out, out, [x + dx, y + dy, z + dz]);
    translate(out, out, [_anchor[0], _anchor[1], _anchor[2]]);
    rotateX(out, out, beta);
    rotateY(out, out, alpha);
    translate(out, out, [-_anchor[0], -_anchor[1], _anchor[2]]);
    scaleMat4(out, out, [scaleX, scaleY, scaleZ]);
    if (angle) {
        const m = mat4Allocate.allocate();
        const _anchor = [0, 0];
        if (anchor) {
            if (typeof anchor3d[0] === 'string') {
                const ratio = parseFloat(anchor3d[0]) / 100;
                const bounds = graphic.AABBBounds;
                _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
            }
            else {
                _anchor[0] = anchor3d[0];
            }
            if (typeof anchor3d[1] === 'string') {
                const ratio = parseFloat(anchor3d[1]) / 100;
                const bounds = graphic.AABBBounds;
                _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
            }
            else {
                _anchor[1] = anchor3d[1];
            }
        }
        translate(m, m, [_anchor[0], _anchor[1], 0]);
        rotateZ(m, m, angle);
        translate(m, m, [-_anchor[0], -_anchor[1], 0]);
        multiplyMat4Mat4(out, out, m);
    }
}
function shouldUseMat4(graphic) {
    const { alpha, beta } = graphic.attribute;
    return alpha || beta;
}
let DefaultGraphicService = class DefaultGraphicService {
    constructor(creator) {
        this.creator = creator;
        this.hooks = {
            onAttributeUpdate: new SyncHook(['graphic']),
            onSetStage: new SyncHook(['graphic', 'stage']),
            onRemove: new SyncHook(['graphic']),
            onRelease: new SyncHook(['graphic']),
            onAddIncremental: new SyncHook(['graphic', 'group', 'stage']),
            onClearIncremental: new SyncHook(['graphic', 'group', 'stage']),
            beforeUpdateAABBBounds: new SyncHook([
                'graphic',
                'stage',
                'willUpdate',
                'aabbBounds'
            ]),
            afterUpdateAABBBounds: new SyncHook([
                'graphic',
                'stage',
                'aabbBounds',
                'globalAABBBounds',
                'selfChange'
            ]),
            clearAABBBounds: new SyncHook(['graphic', 'stage', 'aabbBounds'])
        };
        this.tempAABBBounds1 = new AABBBounds();
        this.tempAABBBounds2 = new AABBBounds();
    }
    onAttributeUpdate(graphic) {
        if (this.hooks.onAttributeUpdate.taps.length) {
            this.hooks.onAttributeUpdate.call(graphic);
        }
    }
    onSetStage(graphic, stage) {
        if (this.hooks.onSetStage.taps.length) {
            this.hooks.onSetStage.call(graphic, stage);
        }
    }
    onRemove(graphic) {
        if (this.hooks.onRemove.taps.length) {
            this.hooks.onRemove.call(graphic);
        }
    }
    onRelease(graphic) {
        if (this.hooks.onRelease.taps.length) {
            this.hooks.onRelease.call(graphic);
        }
    }
    onAddIncremental(graphic, group, stage) {
        if (this.hooks.onAddIncremental.taps.length) {
            this.hooks.onAddIncremental.call(graphic, group, stage);
        }
    }
    onClearIncremental(group, stage) {
        if (this.hooks.onClearIncremental.taps.length) {
            this.hooks.onClearIncremental.call(group, stage);
        }
    }
    beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
        if (this.hooks.beforeUpdateAABBBounds.taps.length) {
            this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
        }
    }
    afterUpdateAABBBounds(graphic, stage, bounds, params, selfChange) {
        if (this.hooks.afterUpdateAABBBounds.taps.length) {
            this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params, selfChange);
        }
    }
    clearAABBBounds(graphic, stage, b) {
        if (this.hooks.clearAABBBounds.taps.length) {
            this.hooks.clearAABBBounds.call(graphic, stage, b);
        }
    }
    updatePathProxyAABBBounds(aabbBounds, graphic) {
        const path = typeof graphic.pathProxy === 'function' ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
        if (!path) {
            return false;
        }
        const boundsContext = new BoundsContext(aabbBounds);
        renderCommandList(path.commandList, boundsContext, 0, 0);
        return true;
    }
    updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
        const { textAlign, textBaseline } = attribute;
        if (attribute.forceBoundsHeight != null) {
            const h = isNumber$1(attribute.forceBoundsHeight) ? attribute.forceBoundsHeight : attribute.forceBoundsHeight();
            const dy = textLayoutOffsetY(textBaseline, h, h);
            aabbBounds.set(aabbBounds.x1, dy, aabbBounds.x2, dy + h);
        }
        if (attribute.forceBoundsWidth != null) {
            const w = isNumber$1(attribute.forceBoundsWidth) ? attribute.forceBoundsWidth : attribute.forceBoundsWidth();
            const dx = textDrawOffsetX(textAlign, w);
            aabbBounds.set(dx, aabbBounds.y1, dx + w, aabbBounds.y2);
        }
    }
    combindShadowAABBBounds(bounds, graphic) {
        if (graphic && graphic.shadowRoot) {
            const b = graphic.shadowRoot.AABBBounds;
            bounds.union(b);
        }
    }
    transformAABBBounds(attribute, aabbBounds, theme, miter, graphic) {
        if (!aabbBounds.empty()) {
            const { scaleX = theme.scaleX, scaleY = theme.scaleY, stroke = theme.stroke, shadowBlur = theme.shadowBlur, lineWidth = theme.lineWidth, pickStrokeBuffer = theme.pickStrokeBuffer, strokeBoundsBuffer = theme.strokeBoundsBuffer } = attribute;
            const tb1 = this.tempAABBBounds1;
            const tb2 = this.tempAABBBounds2;
            if (stroke && lineWidth) {
                const scaledHalfLineWidth = (lineWidth + pickStrokeBuffer) / Math.abs(scaleX + scaleY);
                boundStroke(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer);
                aabbBounds.union(tb1);
                tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
            }
            if (shadowBlur) {
                const { shadowOffsetX = theme.shadowOffsetX, shadowOffsetY = theme.shadowOffsetY } = attribute;
                const shadowBlurWidth = (shadowBlur / Math.abs(scaleX + scaleY)) * 2;
                boundStroke(tb1, shadowBlurWidth, false, strokeBoundsBuffer + 1);
                tb1.translate(shadowOffsetX, shadowOffsetY);
                aabbBounds.union(tb1);
            }
        }
        this.combindShadowAABBBounds(aabbBounds, graphic);
        if (aabbBounds.empty()) {
            return;
        }
        let updateMatrix = true;
        const m = graphic.transMatrix;
        if (graphic && graphic.isContainer) {
            updateMatrix = !(m.a === 1 && m.b === 0 && m.c === 0 && m.d === 1 && m.e === 0 && m.f === 0);
        }
        updateMatrix && transformBoundsWithMatrix(aabbBounds, aabbBounds, m);
    }
    validCheck(attribute, theme, aabbBounds, graphic) {
        if (!graphic) {
            return true;
        }
        if (attribute.forceBoundsHeight != null || attribute.forceBoundsWidth != null) {
            return true;
        }
        if (graphic.shadowRoot || graphic.isContainer) {
            return true;
        }
        const { visible = theme.visible } = attribute;
        if (!(graphic.valid && visible)) {
            if (!aabbBounds.empty()) {
                graphic.parent && aabbBounds.transformWithMatrix(graphic.parent.globalTransMatrix);
                this.clearAABBBounds(graphic, graphic.stage, aabbBounds);
                aabbBounds.clear();
            }
            return false;
        }
        return true;
    }
    updateTempAABBBounds(aabbBounds) {
        const tb1 = this.tempAABBBounds1;
        const tb2 = this.tempAABBBounds2;
        tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
        return { tb1, tb2 };
    }
};
DefaultGraphicService = __decorate([
    injectable(),
    __param(0, inject(GraphicCreator$1)),
    __metadata("design:paramtypes", [Object])
], DefaultGraphicService);

const updateBoundsOfCommonOuterBorder = (attribute, theme, aabbBounds) => {
    const { outerBorder, shadowBlur = theme.shadowBlur } = attribute;
    if (outerBorder) {
        const defaultOuterBorder = theme.outerBorder;
        const { distance = defaultOuterBorder.distance, lineWidth = defaultOuterBorder.lineWidth } = outerBorder;
        aabbBounds.expand(distance + (shadowBlur + lineWidth) / 2);
    }
    return aabbBounds;
};

const CIRCLE_UPDATE_TAG_KEY = ['radius', 'startAngle', 'endAngle', ...GRAPHIC_UPDATE_TAG_KEY];
class Circle extends Graphic {
    constructor(params = { radius: 1 }) {
        super(params);
        this.type = 'circle';
        this.numberType = CIRCLE_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const { startAngle, endAngle, radius } = this.attribute;
        return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);
    }
    getGraphicTheme() {
        return getTheme(this).circle;
    }
    updateAABBBounds(attribute, circleTheme, aabbBounds, full) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
            full
                ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds)
                : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds);
        }
        const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
        updateBoundsOfCommonOuterBorder(attribute, circleTheme, tb1);
        aabbBounds.union(tb1);
        tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1;
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        application.graphicService.transformAABBBounds(attribute, aabbBounds, circleTheme, false, this);
        return aabbBounds;
    }
    updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) {
        const { radius = circleTheme.radius } = attribute;
        aabbBounds.set(-radius, -radius, radius, radius);
        return aabbBounds;
    }
    updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds) {
        const { startAngle = circleTheme.startAngle, endAngle = circleTheme.endAngle, radius = circleTheme.radius } = attribute;
        if (endAngle - startAngle > pi2 - epsilon) {
            aabbBounds.set(-radius, -radius, radius, radius);
        }
        else {
            circleBounds(startAngle, endAngle, radius, aabbBounds);
        }
        return aabbBounds;
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, CIRCLE_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, CIRCLE_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        var _a, _b, _c;
        let path = super.toCustomPath();
        if (path) {
            return path;
        }
        const x = 0;
        const y = 0;
        const attribute = this.attribute;
        const radius = (_a = attribute.radius) !== null && _a !== void 0 ? _a : this.getDefaultAttribute('radius');
        const startAngle = (_b = attribute.startAngle) !== null && _b !== void 0 ? _b : this.getDefaultAttribute('startAngle');
        const endAngle = (_c = attribute.endAngle) !== null && _c !== void 0 ? _c : this.getDefaultAttribute('endAngle');
        path = new CustomPath2D();
        path.arc(x, y, radius, startAngle, endAngle);
        return path;
    }
    clone() {
        return new Circle(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Circle.NOWORK_ANIMATE_ATTR;
    }
}
Circle.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createCircle(attributes) {
    return new Circle(attributes);
}

class CanvasTextLayout {
    constructor(fontFamily, options, textMeasure) {
        this.fontFamily = fontFamily;
        this.textOptions = options;
        this.textMeasure = textMeasure;
    }
    LayoutBBox(bbox, textAlign, textBaseline, linesLayout) {
        if (textAlign === 'left' || textAlign === 'start') {
            bbox.xOffset = 0;
        }
        else if (textAlign === 'center') {
            bbox.xOffset = bbox.width / -2;
        }
        else if (textAlign === 'right' || textAlign === 'end') {
            bbox.xOffset = -bbox.width;
        }
        else {
            bbox.xOffset = 0;
        }
        if (textBaseline === 'top') {
            bbox.yOffset = 0;
        }
        else if (textBaseline === 'middle') {
            bbox.yOffset = bbox.height / -2;
        }
        else if (textBaseline === 'alphabetic') {
            let percent = 0.79;
            if (linesLayout.length === 1) {
                const lineInfo = linesLayout[0];
                percent = lineInfo.ascent / (lineInfo.ascent + lineInfo.descent);
            }
            bbox.yOffset = bbox.height * -percent;
        }
        else {
            bbox.yOffset = -bbox.height;
        }
        return bbox;
    }
    GetLayoutByLines(lines, textAlign, textBaseline, lineHeight, suffix = '', wordBreak, params) {
        const { lineWidth, suffixPosition = 'end', measureMode = MeasureModeEnum.actualBounding, keepCenterInLine = false } = params !== null && params !== void 0 ? params : {};
        lines = lines.map(l => l.toString());
        const linesLayout = [];
        const bboxWH = [0, 0];
        if (typeof lineWidth === 'number' && lineWidth !== Infinity) {
            let width;
            for (let i = 0, len = lines.length; i < len; i++) {
                const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
                let str = lines[i].toString();
                if (metrics.width > lineWidth) {
                    const data = this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, lineWidth, suffix, wordBreak, suffixPosition);
                    str = data.str;
                    width = data.width;
                }
                else {
                    width = metrics.width;
                }
                linesLayout.push({
                    str,
                    width,
                    ascent: metrics.ascent,
                    descent: metrics.descent,
                    keepCenterInLine
                });
            }
            bboxWH[0] = lineWidth;
        }
        else {
            let _lineWidth = 0;
            let width;
            let text;
            for (let i = 0, len = lines.length; i < len; i++) {
                text = lines[i];
                const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
                width = metrics.width;
                _lineWidth = Math.max(_lineWidth, width);
                linesLayout.push({ str: text, width, ascent: metrics.ascent, descent: metrics.descent, keepCenterInLine });
            }
            bboxWH[0] = _lineWidth;
        }
        bboxWH[1] = linesLayout.length * lineHeight;
        bboxWH[0] = linesLayout.reduce((a, b) => Math.max(a, b.width), 0);
        const bbox = {
            xOffset: 0,
            yOffset: 0,
            width: bboxWH[0],
            height: bboxWH[1]
        };
        this.LayoutBBox(bbox, textAlign, textBaseline, linesLayout);
        return this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    }
    layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
        const origin = [0, 0];
        const totalLineHeight = lines.length * lineHeight;
        if (textBaseline === 'top') ;
        else if (textBaseline === 'middle') {
            origin[1] = (bbox.height - totalLineHeight) / 2;
        }
        else if (textBaseline === 'bottom') {
            origin[1] = bbox.height - totalLineHeight;
        }
        for (let i = 0; i < lines.length; i++) {
            this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);
        }
        return {
            bbox,
            lines,
            fontFamily: this.fontFamily,
            fontSize: this.textOptions.fontSize,
            fontWeight: this.textOptions.fontWeight,
            lineHeight,
            textAlign,
            textBaseline
        };
    }
    lineOffset(bbox, line, textAlign, textBaseline, lineHeight, origin) {
        if (textAlign === 'left' || textAlign === 'start') {
            line.leftOffset = 0;
        }
        else if (textAlign === 'center') {
            line.leftOffset = (bbox.width - line.width) / 2;
        }
        else if (textAlign === 'right' || textAlign === 'end') {
            line.leftOffset = bbox.width - line.width;
        }
        line.topOffset = lineHeight / 2 + (line.ascent - line.descent) / 2 + origin[1];
        if (!line.keepCenterInLine) {
            const actualHeight = line.ascent + line.descent;
            const buf = 0;
            const actualHeightWithBuf = actualHeight + buf;
            if (actualHeightWithBuf < lineHeight - buf) {
                if (textBaseline === 'bottom') {
                    line.topOffset += (lineHeight - actualHeightWithBuf) / 2;
                }
                else if (textBaseline === 'top') {
                    line.topOffset -= (lineHeight - actualHeightWithBuf) / 2;
                }
            }
            if (textBaseline === 'alphabetic') {
                const fontBoundingHeight = line.ascent + line.descent;
                const ratio = lineHeight / fontBoundingHeight;
                line.topOffset = lineHeight / 2 + ((line.ascent - line.descent) / 2) * ratio + origin[1];
            }
        }
        origin[1] += lineHeight;
        return line;
    }
}

const TEXT_UPDATE_TAG_KEY = [
    'text',
    'maxLineWidth',
    'maxWidth',
    'textAlign',
    'textBaseline',
    'heightLimit',
    'lineClamp',
    'fontSize',
    'fontFamily',
    'fontWeight',
    'ellipsis',
    'lineHeight',
    'direction',
    'wordBreak',
    'heightLimit',
    'lineClamp',
    ...GRAPHIC_UPDATE_TAG_KEY
];
class Text extends Graphic {
    get font() {
        const textTheme = this.getGraphicTheme();
        if (!this._font) {
            this._font = getContextFont(this.attribute, textTheme);
        }
        return this._font;
    }
    get clipedText() {
        var _a;
        const attribute = this.attribute;
        const textTheme = this.getGraphicTheme();
        const maxWidth = this.getMaxWidth(textTheme);
        if (!Number.isFinite(maxWidth)) {
            return ((_a = attribute.text) !== null && _a !== void 0 ? _a : textTheme.text).toString();
        }
        this.tryUpdateAABBBounds();
        return this.cache.clipedText;
    }
    get clipedWidth() {
        this.tryUpdateAABBBounds();
        return this.cache.clipedWidth;
    }
    get cliped() {
        var _a, _b;
        const textTheme = this.getGraphicTheme();
        const attribute = this.attribute;
        const maxWidth = this.getMaxWidth(textTheme);
        if (!Number.isFinite(maxWidth)) {
            return false;
        }
        const { text } = this.attribute;
        this.tryUpdateAABBBounds();
        if ((_b = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.layoutData) === null || _b === void 0 ? void 0 : _b.lines) {
            let mergedText = '';
            this.cache.layoutData.lines.forEach(item => {
                mergedText += item.str;
            });
            const originText = Array.isArray(text) ? text.join('') : text;
            return originText !== mergedText;
        }
        if (attribute.direction === 'vertical' && this.cache.verticalList && this.cache.verticalList[0]) {
            return this.cache.verticalList[0].map(item => item.text).join('') !== attribute.text.toString();
        }
        if (this.clipedText == null) {
            return false;
        }
        return this.clipedText !== attribute.text.toString();
    }
    get multilineLayout() {
        this.tryUpdateAABBBounds();
        return this.cache.layoutData;
    }
    get isMultiLine() {
        return Array.isArray(this.attribute.text) || this.attribute.whiteSpace === 'normal';
    }
    constructor(params = { text: '', fontSize: 16 }) {
        super(params);
        this.type = 'text';
        this.numberType = TEXT_NUMBER_TYPE;
        this.cache = {};
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const { text } = this.attribute;
        if (isArray(text)) {
            return !text.every((t) => t == null || t === '');
        }
        return text != null && text !== '';
    }
    getGraphicTheme() {
        return getTheme(this).text;
    }
    doUpdateOBBBounds() {
        const graphicTheme = this.getGraphicTheme();
        this._OBBBounds.clear();
        const attribute = this.attribute;
        const { angle = graphicTheme.angle } = attribute;
        if (!angle) {
            const b = this.AABBBounds;
            this._OBBBounds.setValue(b.x1, b.y1, b.x2, b.y2);
            return this._OBBBounds;
        }
        if (!this.obbText) {
            this.obbText = new Text({});
        }
        this.obbText.setAttributes(Object.assign(Object.assign({}, attribute), { angle: 0 }));
        const bounds1 = this.obbText.AABBBounds;
        const { x, y } = attribute;
        const boundsCenter = { x: (bounds1.x1 + bounds1.x2) / 2, y: (bounds1.y1 + bounds1.y2) / 2 };
        const center = rotatePoint(boundsCenter, angle, { x, y });
        this._OBBBounds.copy(bounds1);
        this._OBBBounds.translate(center.x - boundsCenter.x, center.y - boundsCenter.y);
        this._OBBBounds.angle = angle;
        return this._OBBBounds;
    }
    updateAABBBounds(attribute, textTheme, aabbBounds) {
        const { text = textTheme.text } = this.attribute;
        if (Array.isArray(text)) {
            this.updateMultilineAABBBounds(text);
        }
        else {
            this.updateSingallineAABBBounds(text);
        }
        const { tb1 } = application.graphicService.updateTempAABBBounds(aabbBounds);
        const { scaleX = textTheme.scaleX, scaleY = textTheme.scaleY, shadowBlur = textTheme.shadowBlur, strokeBoundsBuffer = textTheme.strokeBoundsBuffer } = attribute;
        if (shadowBlur) {
            const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
            boundStroke(tb1, shadowBlurHalfWidth, true, strokeBoundsBuffer);
            aabbBounds.union(tb1);
        }
        application.graphicService.combindShadowAABBBounds(aabbBounds, this);
        if (attribute.forceBoundsHeight != null || attribute.forceBoundsWidth != null) {
            application.graphicService.updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds);
        }
        this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1;
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        transformBoundsWithMatrix(aabbBounds, aabbBounds, this.transMatrix);
        return aabbBounds;
    }
    updateSingallineAABBBounds(text) {
        this.updateMultilineAABBBounds([text]);
        const layoutData = this.cache.layoutData;
        if (layoutData && layoutData.lines && layoutData.lines.length) {
            const line = layoutData.lines[0];
            this.cache.clipedText = line.str;
            this.cache.clipedWidth = line.width;
        }
        return this._AABBBounds;
    }
    updateMultilineAABBBounds(text) {
        const textTheme = this.getGraphicTheme();
        const { direction = textTheme.direction, underlineOffset = textTheme.underlineOffset } = this.attribute;
        const b = direction === 'horizontal'
            ? this.updateHorizontalMultilineAABBBounds(text)
            : this.updateVerticalMultilineAABBBounds(text);
        if (direction === 'horizontal') {
            if (underlineOffset) {
                this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + underlineOffset);
            }
        }
        return b;
    }
    guessLineHeightBuf(fontSize) {
        return fontSize ? fontSize * 0.1 : 0;
    }
    updateHorizontalMultilineAABBBounds(text) {
        var _a;
        const textTheme = this.getGraphicTheme();
        const attribute = this.attribute;
        const { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, ellipsis = textTheme.ellipsis, maxLineWidth, stroke = textTheme.stroke, wrap = textTheme.wrap, measureMode = textTheme.measureMode, lineWidth = textTheme.lineWidth, whiteSpace = textTheme.whiteSpace, suffixPosition = textTheme.suffixPosition, ignoreBuf = textTheme.ignoreBuf, keepCenterInLine = textTheme.keepCenterInLine } = attribute;
        const buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize);
        const lineHeight = this.getLineHeight(attribute, textTheme, buf);
        if (whiteSpace === 'normal' || wrap) {
            return this.updateWrapAABBBounds(text);
        }
        if (!this.shouldUpdateShape() && ((_a = this.cache) === null || _a === void 0 ? void 0 : _a.layoutData)) {
            const bbox = this.cache.layoutData.bbox;
            this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);
            if (stroke) {
                this._AABBBounds.expand(lineWidth / 2);
            }
            return this._AABBBounds;
        }
        const textMeasure = application.graphicUtil.textMeasure;
        const layoutObj = new CanvasTextLayout(fontFamily, { fontSize, fontWeight, fontFamily, lineHeight }, textMeasure);
        const layoutData = layoutObj.GetLayoutByLines(text, textAlign, textBaseline, lineHeight, ellipsis === true ? textTheme.ellipsis : ellipsis || undefined, false, {
            lineWidth: maxLineWidth,
            suffixPosition,
            measureMode,
            keepCenterInLine
        });
        const { bbox } = layoutData;
        this.cache.layoutData = layoutData;
        this.clearUpdateShapeTag();
        this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);
        if (stroke) {
            this._AABBBounds.expand(lineWidth / 2);
        }
        return this._AABBBounds;
    }
    updateWrapAABBBounds(text) {
        var _a, _b, _c;
        const textTheme = this.getGraphicTheme();
        const { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, ellipsis = textTheme.ellipsis, maxLineWidth, stroke = textTheme.stroke, lineWidth = textTheme.lineWidth, wordBreak = textTheme.wordBreak, fontWeight = textTheme.fontWeight, ignoreBuf = textTheme.ignoreBuf, measureMode = textTheme.measureMode, suffixPosition = textTheme.suffixPosition, heightLimit = 0, lineClamp, keepCenterInLine = textTheme.keepCenterInLine } = this.attribute;
        const buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize);
        const lineHeight = this.getLineHeight(this.attribute, textTheme, buf);
        if (!this.shouldUpdateShape() && ((_a = this.cache) === null || _a === void 0 ? void 0 : _a.layoutData)) {
            const bbox = this.cache.layoutData.bbox;
            this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);
            if (stroke) {
                this._AABBBounds.expand(lineWidth / 2);
            }
            return this._AABBBounds;
        }
        const textMeasure = application.graphicUtil.textMeasure;
        const textOptions = { fontSize, fontWeight, fontFamily, lineHeight };
        const layoutObj = new CanvasTextLayout(fontFamily, textOptions, textMeasure);
        const lines = isArray(text) ? text.map(l => l.toString()) : [text.toString()];
        const linesLayout = [];
        const bboxWH = [0, 0];
        let lineCountLimit = Infinity;
        if (heightLimit > 0) {
            lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1);
        }
        if (lineClamp) {
            lineCountLimit = Math.min(lineCountLimit, lineClamp);
        }
        if (typeof maxLineWidth === 'number' && maxLineWidth !== Infinity) {
            if (maxLineWidth > 0) {
                for (let i = 0; i < lines.length; i++) {
                    const str = lines[i];
                    let needCut = true;
                    if (i === lineCountLimit - 1) {
                        const clip = textMeasure.clipTextWithSuffix(str, textOptions, maxLineWidth, ellipsis, false, suffixPosition, i !== lines.length - 1);
                        const matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
                        linesLayout.push({
                            str: clip.str,
                            width: clip.width,
                            ascent: matrics.ascent,
                            descent: matrics.descent,
                            keepCenterInLine
                        });
                        break;
                    }
                    const clip = textMeasure.clipText(str, textOptions, maxLineWidth, wordBreak !== 'break-all', wordBreak === 'keep-all');
                    if ((str !== '' && clip.str === '') || clip.wordBreaked) {
                        if (ellipsis) {
                            const clipEllipsis = textMeasure.clipTextWithSuffix(str, textOptions, maxLineWidth, ellipsis, false, suffixPosition);
                            clip.str = (_b = clipEllipsis.str) !== null && _b !== void 0 ? _b : '';
                            clip.width = (_c = clipEllipsis.width) !== null && _c !== void 0 ? _c : 0;
                        }
                        else {
                            clip.str = '';
                            clip.width = 0;
                        }
                        needCut = false;
                    }
                    const matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
                    linesLayout.push({
                        str: clip.str,
                        width: clip.width,
                        ascent: matrics.ascent,
                        descent: matrics.descent,
                        keepCenterInLine
                    });
                    let cutLength = clip.str.length;
                    if (clip.wordBreaked && !(str !== '' && clip.str === '')) {
                        needCut = true;
                        cutLength = clip.wordBreaked;
                    }
                    if (clip.str.length === str.length) ;
                    else if (needCut) {
                        let newStr = str.substring(cutLength);
                        if (wordBreak === 'keep-all') {
                            newStr = newStr.replace(/^\s+/g, '');
                        }
                        lines.splice(i + 1, 0, newStr);
                    }
                }
            }
            let maxWidth = 0;
            linesLayout.forEach(layout => {
                maxWidth = Math.max(maxWidth, layout.width);
            });
            bboxWH[0] = maxWidth;
        }
        else {
            let lineWidth = 0;
            let width;
            let text;
            for (let i = 0, len = lines.length; i < len; i++) {
                if (i === lineCountLimit - 1) {
                    const clip = textMeasure.clipTextWithSuffix(lines[i], textOptions, maxLineWidth, ellipsis, false, suffixPosition);
                    const matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
                    linesLayout.push({
                        str: clip.str,
                        width: clip.width,
                        ascent: matrics.ascent,
                        descent: matrics.descent,
                        keepCenterInLine
                    });
                    lineWidth = Math.max(lineWidth, clip.width);
                    break;
                }
                text = lines[i];
                width = textMeasure.measureTextWidth(text, textOptions);
                lineWidth = Math.max(lineWidth, width);
                const matrics = textMeasure.measureTextPixelADscentAndWidth(text, textOptions, measureMode);
                linesLayout.push({ str: text, width, ascent: matrics.ascent, descent: matrics.descent, keepCenterInLine });
            }
            bboxWH[0] = lineWidth;
        }
        bboxWH[1] = linesLayout.length * lineHeight;
        const bbox = {
            xOffset: 0,
            yOffset: 0,
            width: bboxWH[0],
            height: bboxWH[1]
        };
        layoutObj.LayoutBBox(bbox, textAlign, textBaseline, linesLayout);
        const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
        this.cache.layoutData = layoutData;
        this.clearUpdateShapeTag();
        this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);
        if (stroke) {
            this._AABBBounds.expand(lineWidth / 2);
        }
        return this._AABBBounds;
    }
    updateVerticalMultilineAABBBounds(text) {
        var _a, _b;
        const textTheme = this.getGraphicTheme();
        const textMeasure = application.graphicUtil.textMeasure;
        let width;
        const attribute = this.attribute;
        const { maxLineWidth = textTheme.maxLineWidth, ellipsis = textTheme.ellipsis, fontFamily = textTheme.fontFamily, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, stroke = textTheme.stroke, lineWidth = textTheme.lineWidth, verticalMode = textTheme.verticalMode, suffixPosition = textTheme.suffixPosition } = attribute;
        const lineHeight = this.getLineHeight(attribute, textTheme, 0);
        let { textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline } = attribute;
        if (!verticalMode) {
            const t = textAlign;
            textAlign = (_a = Text.baselineMapAlign[textBaseline]) !== null && _a !== void 0 ? _a : 'left';
            textBaseline = (_b = Text.alignMapBaseline[t]) !== null && _b !== void 0 ? _b : 'top';
        }
        width = 0;
        if (!this.shouldUpdateShape() && this.cache) {
            this.cache.verticalList.forEach(item => {
                const w = item.reduce((a, b) => a + b.width, 0);
                width = max(w, width);
            });
            const dx = textDrawOffsetX(textAlign, width);
            const height = this.cache.verticalList.length * lineHeight;
            const dy = textLayoutOffsetY(textBaseline, height, fontSize);
            this._AABBBounds.set(dy, dx, dy + height, dx + width);
            if (stroke) {
                this._AABBBounds.expand(lineWidth / 2);
            }
            return this._AABBBounds;
        }
        const verticalLists = text.map(str => {
            return verticalLayout(str.toString());
        });
        verticalLists.forEach((verticalData, i) => {
            if (Number.isFinite(maxLineWidth)) {
                if (ellipsis) {
                    const strEllipsis = (ellipsis === true ? textTheme.ellipsis : ellipsis);
                    const data = textMeasure.clipTextWithSuffixVertical(verticalData, { fontSize, fontWeight, fontFamily }, maxLineWidth, strEllipsis, false, suffixPosition);
                    verticalLists[i] = data.verticalList;
                    width = data.width;
                }
                else {
                    const data = textMeasure.clipTextVertical(verticalData, { fontSize, fontWeight, fontFamily }, maxLineWidth, false);
                    verticalLists[i] = data.verticalList;
                    width = data.width;
                }
            }
            else {
                width = 0;
                verticalData.forEach(t => {
                    const w = t.direction === TextDirection.HORIZONTAL
                        ? fontSize
                        : textMeasure.measureTextWidth(t.text, { fontSize, fontWeight, fontFamily });
                    width += w;
                    t.width = w;
                });
            }
        });
        this.cache.verticalList = verticalLists;
        this.clearUpdateShapeTag();
        this.cache.verticalList.forEach(item => {
            const w = item.reduce((a, b) => a + b.width, 0);
            width = max(w, width);
        });
        const dx = textDrawOffsetX(textAlign, width);
        const height = this.cache.verticalList.length * lineHeight;
        const dy = textLayoutOffsetY(textBaseline, height, fontSize);
        this._AABBBounds.set(dy, dx, dy + height, dx + width);
        if (stroke) {
            this._AABBBounds.expand(lineWidth / 2);
        }
        return this._AABBBounds;
    }
    getMaxWidth(theme) {
        var _a, _b;
        const attribute = this.attribute;
        return (_b = (_a = attribute.maxLineWidth) !== null && _a !== void 0 ? _a : attribute.maxWidth) !== null && _b !== void 0 ? _b : theme.maxWidth;
    }
    getLineHeight(attribute, textTheme, buf) {
        var _a;
        return ((_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) !== null && _a !== void 0 ? _a : (attribute.fontSize || textTheme.fontSize) + buf);
    }
    needUpdateTags(keys, k = TEXT_UPDATE_TAG_KEY) {
        return super.needUpdateTags(keys, k);
    }
    needUpdateTag(key, k = TEXT_UPDATE_TAG_KEY) {
        return super.needUpdateTag(key, k);
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        if (key === 'text') {
            nextAttributes.text = nextStepVal;
        }
    }
    clone() {
        return new Text(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Text.NOWORK_ANIMATE_ATTR;
    }
    getBaselineMapAlign() {
        return Text.baselineMapAlign;
    }
    getAlignMapBaseline() {
        return Text.alignMapBaseline;
    }
}
Text.NOWORK_ANIMATE_ATTR = Object.assign({ ellipsis: 1, wordBreak: 1, direction: 1, textAlign: 1, textBaseline: 1, fontFamily: 1, fontWeight: 1 }, NOWORK_ANIMATE_ATTR);
Text.baselineMapAlign = {
    top: 'left',
    bottom: 'right',
    middle: 'center'
};
Text.alignMapBaseline = {
    left: 'top',
    right: 'bottom',
    center: 'middle'
};
function createText(attributes) {
    return new Text(attributes);
}

const WRAP_TEXT_UPDATE_TAG_KEY = ['heightLimit', 'lineClamp'];
class WrapText extends Text {
    constructor(params) {
        super(Object.assign(Object.assign({}, params), { wrap: true }));
    }
    _isValid() {
        const { text } = this.attribute;
        if (isArray(text)) {
            return !text.every((t) => t == null || t === '');
        }
        return text != null && text !== '';
    }
    updateMultilineAABBBounds(text) {
        var _a, _b, _c, _d;
        const textTheme = this.getGraphicTheme();
        const { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, ellipsis = textTheme.ellipsis, maxLineWidth, stroke = textTheme.stroke, lineWidth = textTheme.lineWidth, wordBreak = textTheme.wordBreak, fontWeight = textTheme.fontWeight, ignoreBuf = textTheme.ignoreBuf, heightLimit = 0, suffixPosition = textTheme.suffixPosition, lineClamp } = this.attribute;
        const lineHeight = (_a = calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize)) !== null && _a !== void 0 ? _a : (this.attribute.fontSize || textTheme.fontSize);
        const buf = ignoreBuf ? 0 : 2;
        if (!this.shouldUpdateShape() && ((_b = this.cache) === null || _b === void 0 ? void 0 : _b.layoutData)) {
            const bbox = this.cache.layoutData.bbox;
            this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);
            if (stroke) {
                this._AABBBounds.expand(lineWidth / 2);
            }
            return this._AABBBounds;
        }
        const textMeasure = application.graphicUtil.textMeasure;
        const layoutObj = new CanvasTextLayout(fontFamily, { fontSize, fontWeight, fontFamily }, textMeasure);
        const lines = text.map(l => l.toString());
        const linesLayout = [];
        const bboxWH = [0, 0];
        let lineCountLimit = Infinity;
        if (heightLimit > 0) {
            lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1);
        }
        if (lineClamp) {
            lineCountLimit = Math.min(lineCountLimit, lineClamp);
        }
        if (typeof maxLineWidth === 'number' && maxLineWidth !== Infinity) {
            if (maxLineWidth > 0) {
                for (let i = 0; i < lines.length; i++) {
                    const str = lines[i];
                    let needCut = true;
                    if (i === lineCountLimit - 1) {
                        const clip = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
                        linesLayout.push({
                            str: clip.str,
                            width: clip.width,
                            ascent: 0,
                            descent: 0,
                            keepCenterInLine: false
                        });
                        break;
                    }
                    const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth, wordBreak === 'break-word');
                    if (str !== '' && clip.str === '') {
                        if (ellipsis) {
                            const clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
                            clip.str = (_c = clipEllipsis.str) !== null && _c !== void 0 ? _c : '';
                            clip.width = (_d = clipEllipsis.width) !== null && _d !== void 0 ? _d : 0;
                        }
                        else {
                            clip.str = '';
                            clip.width = 0;
                        }
                        needCut = false;
                    }
                    linesLayout.push({
                        str: clip.str,
                        width: clip.width,
                        ascent: 0,
                        descent: 0,
                        keepCenterInLine: false
                    });
                    if (clip.str.length === str.length) ;
                    else if (needCut) {
                        const newStr = str.substring(clip.str.length);
                        lines.splice(i + 1, 0, newStr);
                    }
                }
            }
            let maxWidth = 0;
            linesLayout.forEach(layout => {
                maxWidth = Math.max(maxWidth, layout.width);
            });
            bboxWH[0] = maxWidth;
        }
        else {
            let lineWidth = 0;
            let width;
            let text;
            for (let i = 0, len = lines.length; i < len; i++) {
                if (i === lineCountLimit - 1) {
                    const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i], layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
                    linesLayout.push({
                        str: clip.str,
                        width: clip.width,
                        ascent: 0,
                        descent: 0,
                        keepCenterInLine: false
                    });
                    lineWidth = Math.max(lineWidth, clip.width);
                    break;
                }
                text = lines[i];
                width = layoutObj.textMeasure.measureTextWidth(text, layoutObj.textOptions, wordBreak === 'break-word');
                lineWidth = Math.max(lineWidth, width);
                linesLayout.push({ str: text, width, ascent: 0, descent: 0, keepCenterInLine: false });
            }
            bboxWH[0] = lineWidth;
        }
        bboxWH[1] = linesLayout.length * (lineHeight + buf);
        const bbox = {
            xOffset: 0,
            yOffset: 0,
            width: bboxWH[0],
            height: bboxWH[1]
        };
        layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
        const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
        this.cache.layoutData = layoutData;
        this.clearUpdateShapeTag();
        this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height);
        if (stroke) {
            this._AABBBounds.expand(lineWidth / 2);
        }
        return this._AABBBounds;
    }
    needUpdateTags(keys) {
        for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
            const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];
            if (keys.indexOf(attrKey) !== -1) {
                return true;
            }
        }
        return super.needUpdateTags(keys);
    }
    needUpdateTag(key) {
        for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
            const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];
            if (key === attrKey) {
                return true;
            }
        }
        return super.needUpdateTag(key);
    }
    getNoWorkAnimateAttr() {
        return WrapText.NOWORK_ANIMATE_ATTR;
    }
}
function createWrapText(attributes) {
    return new WrapText(attributes);
}

const updateBoundsOfSymbolOuterBorder = (attribute, symbolTheme, aabbBounds) => {
    const { outerBorder, shadowBlur = symbolTheme.shadowBlur, strokeBoundsBuffer = symbolTheme.strokeBoundsBuffer } = attribute;
    if (outerBorder) {
        const defaultOuterBorder = symbolTheme.outerBorder;
        const { distance = defaultOuterBorder.distance, lineWidth = defaultOuterBorder.lineWidth } = outerBorder;
        boundStroke(aabbBounds, distance + (shadowBlur + lineWidth) / 2, true, strokeBoundsBuffer);
    }
    return aabbBounds;
};

const SYMBOL_UPDATE_TAG_KEY = ['symbolType', 'size', ...GRAPHIC_UPDATE_TAG_KEY];
let Symbol$1 = class Symbol extends Graphic {
    constructor(params = { symbolType: 'circle' }) {
        super(params);
        this.type = 'symbol';
        this.numberType = SYMBOL_NUMBER_TYPE;
    }
    getParsedPath() {
        if (this.shouldUpdateShape()) {
            this._parsedPath = this.doUpdateParsedPath();
            this.clearUpdateShapeTag();
        }
        return this._parsedPath;
    }
    getParsedPath2D(x = 0, y = 0, size = 1) {
        let path = null;
        try {
            path = new Path2D();
        }
        catch (err) {
            return null;
        }
        const parsedPath = this.getParsedPath();
        if (!parsedPath) {
            return null;
        }
        parsedPath.draw(path, size, x, y);
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const { size } = this.attribute;
        return isArray(size) ? size.length === 2 && size.every(this._validNumber) : this._validNumber(size);
    }
    doUpdateParsedPath() {
        const { symbolType = 'circle' } = this.attribute;
        return super.parsePath(symbolType);
    }
    getGraphicTheme() {
        return getTheme(this).symbol;
    }
    updateAABBBounds(attribute, symbolTheme, aabbBounds, full) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
            full
                ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds)
                : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds);
        }
        const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
        updateBoundsOfSymbolOuterBorder(attribute, symbolTheme, tb1);
        aabbBounds.union(tb1);
        tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1;
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        this.x1WithoutTransform = aabbBounds.x1;
        this.y1WithoutTransform = aabbBounds.y1;
        const { lineJoin = symbolTheme.lineJoin } = attribute;
        application.graphicService.transformAABBBounds(attribute, aabbBounds, symbolTheme, lineJoin === 'miter', this);
        return aabbBounds;
    }
    updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) {
        const { size = symbolTheme.size } = attribute;
        if (isArray(size)) {
            aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2);
        }
        else {
            const halfWH = size / 2;
            aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
        }
        return aabbBounds;
    }
    updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds) {
        const { size = symbolTheme.size } = attribute;
        const symbolClass = this.getParsedPath();
        symbolClass.bounds(size, aabbBounds);
        return aabbBounds;
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, SYMBOL_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, SYMBOL_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        const symbolInstance = this.getParsedPath();
        const size = this.attribute.size;
        const x = 0;
        const y = 0;
        const formattedSize = isArray(size) ? size : [size, size];
        return symbolInstance.path
            ? new CustomPath2D().fromCustomPath2D(symbolInstance.path, x, y, formattedSize[0], formattedSize[1])
            : new CustomPath2D().fromString(symbolInstance.pathStr, x, y, formattedSize[0], formattedSize[1]);
    }
    clone() {
        return new Symbol(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Symbol.NOWORK_ANIMATE_ATTR;
    }
};
Symbol$1.NOWORK_ANIMATE_ATTR = Object.assign({ symbolType: 1 }, NOWORK_ANIMATE_ATTR);
function createSymbol(attributes) {
    return new Symbol$1(attributes);
}

const LINE_UPDATE_TAG_KEY = ['segments', 'points', 'curveType', 'curveTension', ...GRAPHIC_UPDATE_TAG_KEY];
let Line$1 = class Line extends Graphic {
    constructor(params = {}) {
        super(params);
        this.type = 'line';
        this.numberType = LINE_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        if (this.pathProxy) {
            return true;
        }
        const { points, segments } = this.attribute;
        if (segments) {
            if (segments.length === 0) {
                return false;
            }
            return true;
        }
        else if (points) {
            if (points.length <= 1) {
                return false;
            }
            return true;
        }
        return false;
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        if (key === 'points') {
            nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio);
        }
    }
    getGraphicTheme() {
        return getTheme(this).line;
    }
    updateAABBBounds(attribute, lineTheme, aabbBounds) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
            attribute.segments
                ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds)
                : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds);
        }
        application.graphicService.updateTempAABBBounds(aabbBounds);
        this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1;
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        const { lineJoin = lineTheme.lineJoin } = attribute;
        application.graphicService.transformAABBBounds(attribute, aabbBounds, lineTheme, lineJoin === 'miter', this);
        return aabbBounds;
    }
    updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
        const { points = lineTheme.points, connectedType } = attribute;
        const b = aabbBounds;
        points.forEach(p => {
            if (p.defined !== false || connectedType === 'connect') {
                b.add(p.x, p.y);
            }
        });
        return b;
    }
    updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
        const { segments = lineTheme.segments, connectedType } = attribute;
        const b = aabbBounds;
        segments.forEach(s => {
            s.points.forEach(p => {
                if (p.defined !== false || connectedType === 'connect') {
                    b.add(p.x, p.y);
                }
            });
        });
        return b;
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, LINE_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, LINE_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        let path = super.toCustomPath();
        if (path) {
            return path;
        }
        const attribute = this.attribute;
        path = new CustomPath2D();
        const segments = attribute.segments;
        const parsePoints = (points) => {
            if (points && points.length) {
                let isFirst = true;
                points.forEach(point => {
                    if (point.defined === false) {
                        return;
                    }
                    if (isFirst) {
                        path.moveTo(point.x, point.y);
                    }
                    else {
                        path.lineTo(point.x, point.y);
                    }
                    isFirst = false;
                });
            }
        };
        if (segments && segments.length) {
            segments.forEach(seg => {
                parsePoints(seg.points);
            });
        }
        else if (attribute.points) {
            parsePoints(attribute.points);
        }
        return path;
    }
    clone() {
        return new Line(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Line.NOWORK_ANIMATE_ATTR;
    }
};
Line$1.NOWORK_ANIMATE_ATTR = Object.assign({ segments: 1, curveType: 1 }, NOWORK_ANIMATE_ATTR);
function createLine(attributes) {
    return new Line$1(attributes);
}

const normalizeRectAttributes = (attribute) => {
    if (!attribute) {
        return { x: 0, y: 0, width: 0, height: 0 };
    }
    let width = isNil(attribute.width) ? attribute.x1 - attribute.x : attribute.width;
    let height = isNil(attribute.height) ? attribute.y1 - attribute.y : attribute.height;
    let x = 0;
    let y = 0;
    if (width < 0) {
        x = width;
        width = -width;
    }
    else if (Number.isNaN(width)) {
        width = 0;
    }
    if (height < 0) {
        y = height;
        height = -height;
    }
    else if (Number.isNaN(height)) {
        height = 0;
    }
    return { x, y, width, height };
};

const RECT_UPDATE_TAG_KEY = ['width', 'x1', 'y1', 'height', 'cornerRadius', ...GRAPHIC_UPDATE_TAG_KEY];
class Rect extends Graphic {
    constructor(params) {
        super(params);
        this.type = 'rect';
        this.numberType = RECT_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        return true;
    }
    getGraphicTheme() {
        return getTheme(this).rect;
    }
    updateAABBBounds(attribute, rectTheme, aabbBounds) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
            let { width, height } = attribute;
            const { x1, y1, x, y } = attribute;
            width = width !== null && width !== void 0 ? width : x1 - x;
            height = height !== null && height !== void 0 ? height : y1 - y;
            if (isFinite(width) || isFinite(height) || isFinite(x) || isFinite(y)) {
                aabbBounds.set(0, 0, width || 0, height || 0);
            }
        }
        const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
        updateBoundsOfCommonOuterBorder(attribute, rectTheme, tb1);
        aabbBounds.union(tb1);
        tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1;
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        application.graphicService.transformAABBBounds(attribute, aabbBounds, rectTheme, false, this);
        return aabbBounds;
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, RECT_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, RECT_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        let path = super.toCustomPath();
        if (path) {
            return path;
        }
        const attribute = this.attribute;
        const { x, y, width, height } = normalizeRectAttributes(attribute);
        path = new CustomPath2D();
        path.moveTo(x, y);
        path.rect(x, y, width, height);
        return path;
    }
    clone() {
        return new Rect(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Rect.NOWORK_ANIMATE_ATTR;
    }
}
Rect.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createRect(attributes) {
    return new Rect(attributes);
}

const CUBE_VERTICES = [
    [0, 0, 0],
    [1, 0, 0],
    [1, 1, 0],
    [0, 1, 0],
    [0, 0, 1],
    [1, 0, 1],
    [1, 1, 1],
    [0, 1, 1]
];
class Rect3d extends Rect {
    constructor(params) {
        super(params);
        this.type = 'rect3d';
        this.numberType = RECT3D_NUMBER_TYPE;
    }
    findFace() {
        const faces = { polygons: [], vertices: [], edges: [] };
        const rectTheme = this.getGraphicTheme();
        const { x1, y1, x, y, length = min(rectTheme.width, rectTheme.height) } = this.attribute;
        let { width, height } = this.attribute;
        width = width !== null && width !== void 0 ? width : x1 - x;
        height = height !== null && height !== void 0 ? height : y1 - y;
        for (let i = 0; i < CUBE_VERTICES.length; i++) {
            const v = CUBE_VERTICES[i];
            faces.vertices.push([v[0] * width, v[1] * height, v[2] * length]);
        }
        faces.polygons.push({ polygon: [0, 1, 5, 4], normal: [0, -1, 0] });
        faces.polygons.push({ polygon: [2, 3, 7, 6], normal: [0, 1, 0] });
        faces.polygons.push({ polygon: [4, 7, 3, 0], normal: [-1, 0, 0] });
        faces.polygons.push({ polygon: [1, 2, 6, 5], normal: [1, 0, 0] });
        faces.polygons.push({ polygon: [0, 1, 2, 3], normal: [0, 0, -1] });
        faces.polygons.push({ polygon: [4, 5, 6, 7], normal: [0, 0, 1] });
        faces.edges = [
            [0, 1],
            [1, 2],
            [2, 3],
            [3, 0],
            [4, 5],
            [5, 6],
            [6, 7],
            [7, 4],
            [0, 4],
            [3, 7],
            [1, 5],
            [2, 6]
        ];
        return faces;
    }
    getNoWorkAnimateAttr() {
        return Rect3d.NOWORK_ANIMATE_ATTR;
    }
}
Rect3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createRect3d(attributes) {
    return new Rect3d(attributes);
}

class Glyph extends Graphic {
    constructor(params) {
        super(params);
        this.type = 'glyph';
        this.numberType = GLYPH_NUMBER_TYPE;
        this.subGraphic = [];
        this._onInit && this._onInit(this);
        this.valid = this.isValid();
    }
    setSubGraphic(subGraphic) {
        this.detachSubGraphic();
        this.subGraphic = subGraphic;
        subGraphic.forEach(g => {
            g.glyphHost = this;
            Object.setPrototypeOf(g.attribute, this.attribute);
        });
        this.valid = this.isValid();
        this.addUpdateBoundTag();
    }
    detachSubGraphic() {
        this.subGraphic.forEach(g => {
            g.glyphHost = null;
            Object.setPrototypeOf(g.attribute, {});
        });
    }
    getSubGraphic() {
        return this.subGraphic;
    }
    onInit(cb) {
        this._onInit = cb;
    }
    onUpdate(cb) {
        this._onUpdate = cb;
    }
    isValid() {
        return true;
    }
    setAttribute(key, value, forceUpdateTag, context) {
        super.setAttribute(key, value, forceUpdateTag, context);
        this.subGraphic.forEach(g => {
            g.addUpdateShapeAndBoundsTag();
            g.addUpdatePositionTag();
        });
    }
    setAttributes(params, forceUpdateTag = false, context) {
        super.setAttributes(params, forceUpdateTag, context);
        this.subGraphic.forEach(g => {
            g.addUpdateShapeAndBoundsTag();
            g.addUpdatePositionTag();
        });
    }
    translate(x, y) {
        super.translate(x, y);
        this.subGraphic.forEach(g => {
            g.addUpdatePositionTag();
            g.addUpdateBoundTag();
        });
        return this;
    }
    translateTo(x, y) {
        super.translateTo(x, y);
        this.subGraphic.forEach(g => {
            g.addUpdatePositionTag();
            g.addUpdateBoundTag();
        });
        return this;
    }
    scale(scaleX, scaleY, scaleCenter) {
        super.scale(scaleX, scaleY, scaleCenter);
        this.subGraphic.forEach(g => {
            g.addUpdatePositionTag();
            g.addUpdateBoundTag();
        });
        return this;
    }
    scaleTo(scaleX, scaleY) {
        super.scaleTo(scaleX, scaleY);
        this.subGraphic.forEach(g => {
            g.addUpdatePositionTag();
            g.addUpdateBoundTag();
        });
        return this;
    }
    rotate(angle) {
        super.rotate(angle);
        this.subGraphic.forEach(g => {
            g.addUpdatePositionTag();
            g.addUpdateBoundTag();
        });
        return this;
    }
    rotateTo(angle) {
        super.rotate(angle);
        this.subGraphic.forEach(g => {
            g.addUpdatePositionTag();
            g.addUpdateBoundTag();
        });
        return this;
    }
    getGraphicTheme() {
        return getTheme(this).glyph;
    }
    updateAABBBounds(attribute, theme, aabbBounds) {
        this.getSubGraphic().forEach((node) => {
            aabbBounds.union(node.AABBBounds);
        });
        return aabbBounds;
    }
    doUpdateAABBBounds() {
        this.updateAABBBoundsStamp++;
        this._AABBBounds.clear();
        const bounds = this.updateAABBBounds(this.attribute, this.getGraphicTheme(), this._AABBBounds);
        this.clearUpdateBoundTag();
        return bounds;
    }
    needUpdateTags(keys) {
        return false;
    }
    needUpdateTag(key) {
        return false;
    }
    useStates(states, hasAnimation) {
        var _a;
        if (!states.length) {
            this.clearStates(hasAnimation);
            return;
        }
        const isChange = ((_a = this.currentStates) === null || _a === void 0 ? void 0 : _a.length) !== states.length ||
            states.some((stateName, index) => this.currentStates[index] !== stateName);
        if (!isChange) {
            return;
        }
        this.stopStateAnimates();
        const stateAttrs = {};
        const subAttrs = this.subGraphic.map(() => ({}));
        states.forEach(stateName => {
            var _a;
            const attrs = this.glyphStateProxy ? this.glyphStateProxy(stateName, states) : this.glyphStates[stateName];
            if (attrs) {
                Object.assign(stateAttrs, attrs.attributes);
                if ((_a = attrs.subAttributes) === null || _a === void 0 ? void 0 : _a.length) {
                    subAttrs.forEach((subAttrs, index) => {
                        Object.assign(subAttrs, attrs.subAttributes[index]);
                    });
                }
            }
        });
        this.updateNormalAttrs(stateAttrs);
        this.currentStates = states;
        this.applyStateAttrs(stateAttrs, states, hasAnimation);
    }
    clearStates(hasAnimation) {
        this.stopStateAnimates();
        if (this.hasState() && this.normalAttrs) {
            this.currentStates = [];
            this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, true);
        }
        else {
            this.currentStates = [];
        }
        this.normalAttrs = null;
    }
    clone() {
        const glyph = new Glyph(Object.assign({}, this.attribute));
        glyph.setSubGraphic(this.subGraphic.map(g => g.clone()));
        return glyph;
    }
    getNoWorkAnimateAttr() {
        return Glyph.NOWORK_ANIMATE_ATTR;
    }
}
Glyph.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createGlyph(attributes) {
    return new Glyph(attributes);
}

class Frame {
    constructor(left, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons) {
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
        this.actualHeight = 0;
        this.bottom = top + height;
        this.right = left + width;
        this.ellipsis = ellipsis;
        this.wordBreak = wordBreak;
        this.verticalDirection = verticalDirection;
        this.lines = [];
        this.globalAlign = globalAlign;
        this.globalBaseline = globalBaseline;
        this.layoutDirection = layoutDirection;
        this.directionKey = DIRECTION_KEY[this.layoutDirection];
        this.isWidthMax = isWidthMax;
        this.isHeightMax = isHeightMax;
        this.singleLine = singleLine;
        if (icons) {
            icons.clear();
            this.icons = icons;
        }
        else {
            this.icons = new Map();
        }
    }
    draw(ctx, drawIcon) {
        const { width: actualWidth, height: actualHeight } = this.getActualSize();
        const width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;
        let height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;
        height = Math.min(height, actualHeight);
        let deltaY = 0;
        switch (this.globalBaseline) {
            case 'top':
                deltaY = 0;
                break;
            case 'middle':
                deltaY = -height / 2;
                break;
            case 'bottom':
                deltaY = -height;
                break;
        }
        let deltaX = 0;
        if (this.globalAlign === 'right' || this.globalAlign === 'end') {
            deltaX = -width;
        }
        else if (this.globalAlign === 'center') {
            deltaX = -width / 2;
        }
        let frameHeight = this[this.directionKey.height];
        if (this.singleLine) {
            frameHeight = this.lines[0].height + 1;
        }
        let lastLineTag = false;
        if (this.verticalDirection === 'middle') {
            if (this.actualHeight >= frameHeight && frameHeight !== 0) {
                for (let i = 0; i < this.lines.length; i++) {
                    const { top, height } = this.lines[i];
                    if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) {
                        return lastLineTag;
                    }
                    let lastLine = false;
                    if (this.ellipsis &&
                        this.lines[i + 1] &&
                        this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
                        lastLine = true;
                        lastLineTag = true;
                    }
                    this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
                }
            }
            else {
                const detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);
                if (this.layoutDirection === 'vertical') {
                    deltaX += detalHeight;
                }
                else {
                    deltaY += detalHeight;
                }
                for (let i = 0; i < this.lines.length; i++) {
                    this.lines[i].draw(ctx, false, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
                }
            }
        }
        else if (this.verticalDirection === 'bottom' && this.layoutDirection !== 'vertical') {
            for (let i = 0; i < this.lines.length; i++) {
                const { top, height } = this.lines[i];
                const y = frameHeight - this.lines[i].top - this.lines[i].height;
                if (frameHeight === 0) {
                    this.lines[i].draw(ctx, false, deltaX, y + deltaY, this.ellipsis, drawIcon);
                }
                else if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) {
                    return lastLineTag;
                }
                else {
                    let lastLine = false;
                    if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {
                        lastLine = true;
                        lastLineTag = true;
                    }
                    this.lines[i].draw(ctx, lastLine, deltaX, y + deltaY, this.ellipsis, drawIcon);
                }
            }
        }
        else {
            if (this.verticalDirection === 'bottom' &&
                this.layoutDirection === 'vertical' &&
                this.singleLine &&
                this.isWidthMax) {
                deltaX += this.lines[0].height + 1;
            }
            for (let i = 0; i < this.lines.length; i++) {
                if (this.verticalDirection === 'bottom' && this.layoutDirection === 'vertical') {
                    deltaX -= this.lines[i].height + this.lines[i].top;
                }
                const { top, height } = this.lines[i];
                if (frameHeight === 0) {
                    this.lines[i].draw(ctx, false, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
                }
                else if (top + height < this[this.directionKey.top] ||
                    top + height > this[this.directionKey.top] + frameHeight) {
                    return lastLineTag;
                }
                else {
                    let lastLine = false;
                    if (this.ellipsis &&
                        this.lines[i + 1] &&
                        this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
                        lastLine = true;
                        lastLineTag = true;
                    }
                    this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
                }
            }
        }
        return lastLineTag;
    }
    getActualSize() {
        if (this.ellipsis) {
            return this.getActualSizeWidthEllipsis();
        }
        return this.getRawActualSize();
    }
    getRawActualSize() {
        let width = 0;
        let height = 0;
        for (let i = 0; i < this.lines.length; i++) {
            const line = this.lines[i];
            if (line.actualWidth > width) {
                width = line.actualWidth;
            }
            height += line.height;
        }
        return {
            width: this.layoutDirection === 'vertical' ? height : width,
            height: this.layoutDirection === 'vertical' ? width : height
        };
    }
    getActualSizeWidthEllipsis() {
        let widthBound = 0;
        let heightBound = 0;
        const { width: actualWidth, height: actualHeight } = this.getRawActualSize();
        this.width || actualWidth || 0;
        this.height || actualHeight || 0;
        let frameHeight = this[this.directionKey.height];
        if (this.singleLine) {
            frameHeight = this.lines[0].height + 1;
        }
        if (this.verticalDirection === 'middle') {
            if (this.actualHeight >= frameHeight && frameHeight !== 0) {
                for (let i = 0; i < this.lines.length; i++) {
                    const { top, height } = this.lines[i];
                    if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ;
                    else {
                        if (this.ellipsis &&
                            this.lines[i + 1] &&
                            this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
                            const ellipsis = this.ellipsis === true ? '...' : this.ellipsis || '';
                            const lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
                            if (lineWidth > widthBound) {
                                widthBound = lineWidth;
                            }
                            heightBound += this.lines[i].height;
                        }
                        else {
                            if (this.lines[i].actualWidth > widthBound) {
                                widthBound = this.lines[i].actualWidth;
                            }
                            heightBound += this.lines[i].height;
                        }
                    }
                }
            }
            else {
                Math.floor((frameHeight - this.actualHeight) / 2);
                for (let i = 0; i < this.lines.length; i++) {
                    if (this.lines[i].actualWidth > widthBound) {
                        widthBound = this.lines[i].actualWidth;
                    }
                    heightBound += this.lines[i].height;
                }
            }
        }
        else if (this.verticalDirection === 'bottom') {
            for (let i = 0; i < this.lines.length; i++) {
                const { top, height } = this.lines[i];
                const y = frameHeight - this.lines[i].top - this.lines[i].height;
                if (frameHeight === 0) {
                    if (this.lines[i].actualWidth > widthBound) {
                        widthBound = this.lines[i].actualWidth;
                    }
                    heightBound += this.lines[i].height;
                }
                else if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) ;
                else {
                    if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {
                        const ellipsis = this.ellipsis === true ? '...' : this.ellipsis || '';
                        const lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
                        if (lineWidth > widthBound) {
                            widthBound = lineWidth;
                        }
                        heightBound += this.lines[i].height;
                    }
                    else {
                        if (this.lines[i].actualWidth > widthBound) {
                            widthBound = this.lines[i].actualWidth;
                        }
                        heightBound += this.lines[i].height;
                    }
                }
            }
        }
        else {
            for (let i = 0; i < this.lines.length; i++) {
                const { top, height } = this.lines[i];
                if (frameHeight === 0) {
                    if (this.lines[i].actualWidth > widthBound) {
                        widthBound = this.lines[i].actualWidth;
                    }
                    heightBound += this.lines[i].height;
                }
                else if (top + height < this[this.directionKey.top] ||
                    top + height > this[this.directionKey.top] + frameHeight) ;
                else {
                    if (this.ellipsis &&
                        this.lines[i + 1] &&
                        this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
                        const ellipsis = this.ellipsis === true ? '...' : this.ellipsis || '';
                        const lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
                        if (lineWidth > widthBound) {
                            widthBound = lineWidth;
                        }
                        heightBound += this.lines[i].height;
                    }
                    else {
                        if (this.lines[i].actualWidth > widthBound) {
                            widthBound = this.lines[i].actualWidth;
                        }
                        heightBound += this.lines[i].height;
                    }
                }
            }
        }
        return {
            width: this.layoutDirection === 'vertical' ? heightBound : widthBound,
            height: this.layoutDirection === 'vertical' ? widthBound : heightBound
        };
    }
}

function getFixedLRTB(left, right, top, bottom) {
    const leftInt = Math.round(left);
    const topInt = Math.round(top);
    const rightInt = Math.round(right);
    const bottomInt = Math.round(bottom);
    const _left = left > leftInt ? leftInt : leftInt - 0.5;
    const _top = top > topInt ? topInt : topInt - 0.5;
    const _right = rightInt > right ? rightInt : rightInt + 0.5;
    const _bottom = bottomInt > bottom ? bottomInt : bottomInt + 0.5;
    return {
        left: _left,
        top: _top,
        right: _right,
        bottom: _bottom
    };
}
class Paragraph {
    constructor(text, newLine, character, ascentDescentMode) {
        var _a, _b;
        this.fontSize = character.fontSize || 16;
        this.textBaseline = character.textBaseline || 'alphabetic';
        this.ascentDescentMode = ascentDescentMode;
        const lineHeight = calculateLineHeight(character.lineHeight, this.fontSize);
        if (typeof lineHeight === 'number') {
            this.lineHeight = lineHeight > this.fontSize ? lineHeight : this.fontSize;
        }
        else {
            this.lineHeight = Math.floor(1.2 * this.fontSize);
        }
        this.height = this.lineHeight;
        const { ascent, height, descent, width } = measureTextCanvas(text, character, this.ascentDescentMode);
        let halfDetaHeight = 0;
        let deltaAscent = 0;
        let deltaDescent = 0;
        if (this.height > height) {
            halfDetaHeight = (this.height - height) / 2;
            deltaAscent = Math.ceil(halfDetaHeight);
            deltaDescent = Math.floor(halfDetaHeight);
        }
        if (this.textBaseline === 'top') {
            this.ascent = halfDetaHeight;
            this.descent = height - halfDetaHeight;
        }
        else if (this.textBaseline === 'bottom') {
            this.ascent = height - halfDetaHeight;
            this.descent = halfDetaHeight;
        }
        else if (this.textBaseline === 'middle') {
            this.ascent = this.height / 2;
            this.descent = this.height / 2;
        }
        else {
            this.ascent = ascent + deltaAscent;
            this.descent = descent + deltaDescent;
        }
        this.length = text.length;
        this.width = width || 0;
        this.text = text || '';
        this.newLine = newLine || false;
        this.character = character;
        this.left = 0;
        this.top = 0;
        this.ellipsis = 'normal';
        this.ellipsisWidth = 0;
        this.ellipsisOtherParagraphWidth = 0;
        this.space = character.space;
        this.dx = (_a = character.dx) !== null && _a !== void 0 ? _a : 0;
        this.dy = (_b = character.dy) !== null && _b !== void 0 ? _b : 0;
        if (character.direction === 'vertical') {
            this.direction = character.direction;
            this.widthOrigin = this.width;
            this.heightOrigin = this.height;
            this.width = this.heightOrigin;
            this.height = this.widthOrigin;
            this.lineHeight = this.height;
        }
        this.ellipsisStr = '...';
    }
    updateWidth() {
        const { width } = measureTextCanvas(this.text, this.character, this.ascentDescentMode);
        this.width = width;
        if (this.direction === 'vertical') {
            this.widthOrigin = this.width;
            this.width = this.heightOrigin;
            this.height = this.widthOrigin;
        }
    }
    drawBackground(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
        if (!(this.text !== '' &&
            this.text !== '\n' &&
            this.character.background &&
            (!this.character.backgroundOpacity || this.character.backgroundOpacity > 0))) {
            return;
        }
        let baseline = top + ascent;
        let text = this.text;
        let left = this.left + deltaLeft;
        baseline += this.top;
        let direction = this.direction;
        if (this.verticalEllipsis) {
            text = this.ellipsisStr;
            direction = 'vertical';
            baseline -= this.ellipsisWidth / 2;
        }
        else if (this.ellipsis === 'hide') {
            return;
        }
        else if (this.ellipsis === 'add') {
            text += this.ellipsisStr;
            if (textAlign === 'right' || textAlign === 'end') {
                left -= this.ellipsisWidth;
            }
        }
        else if (this.ellipsis === 'replace') {
            const index = getStrByWithCanvas(text, (direction === 'vertical' ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
            text = text.slice(0, index);
            text += this.ellipsisStr;
            if (textAlign === 'right' || textAlign === 'end') {
                if (direction === 'vertical') ;
                else {
                    const { width } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
                    left -= this.ellipsisWidth - width;
                }
            }
        }
        const right = left + (this.widthOrigin || this.width);
        const bottom = top + lineHeight;
        const lrtb = getFixedLRTB(left, right, top, bottom);
        return Object.assign(Object.assign({}, lrtb), { fillStyle: this.character.background, globalAlpha: this.character.backgroundOpacity });
    }
    draw(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
        var _a;
        let baseline = top + ascent;
        let text = this.text;
        let left = this.left + deltaLeft + ((_a = this.space) !== null && _a !== void 0 ? _a : 0) / 2;
        baseline += this.top;
        let direction = this.direction;
        if (this.verticalEllipsis) {
            text = this.ellipsisStr;
            direction = 'vertical';
            baseline -= this.ellipsisWidth / 2;
        }
        else if (this.ellipsis === 'hide') {
            return;
        }
        else if (this.ellipsis === 'add') {
            text += this.ellipsisStr;
            if (textAlign === 'right' || textAlign === 'end') {
                left -= this.ellipsisWidth;
            }
        }
        else if (this.ellipsis === 'replace') {
            const index = getStrByWithCanvas(text, (direction === 'vertical' ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
            text = text.slice(0, index);
            text += this.ellipsisStr;
            if (textAlign === 'right' || textAlign === 'end') {
                if (direction === 'vertical') ;
                else {
                    const { width } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
                    left -= this.ellipsisWidth - width;
                }
            }
        }
        switch (this.character.script) {
            case 'super':
                baseline -= this.ascent * (1 / 3);
                break;
            case 'sub':
                baseline += this.descent / 2;
                break;
        }
        if (direction === 'vertical') {
            ctx.save();
            ctx.rotateAbout(Math.PI / 2, left, baseline);
            ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2);
            ctx.translate(left, baseline);
            left = 0;
            baseline = 0;
        }
        const { lineWidth = 1 } = this.character;
        if (this.character.stroke && lineWidth) {
            ctx.strokeText(text, left + this.dx, baseline + this.dy);
        }
        if (this.character.fill) {
            ctx.fillText(text, left + this.dx, baseline + this.dy);
        }
        if (this.character.fill) {
            if (this.character.lineThrough || this.character.underline) {
                if (this.character.underline) {
                    const top = 1 + baseline;
                    const right = left + (this.widthOrigin || this.width);
                    const bottom = top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
                    const lrtb = getFixedLRTB(left, right, top, bottom);
                    ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
                }
                if (this.character.lineThrough) {
                    const top = 1 + baseline - this.ascent / 2;
                    const right = left + (this.widthOrigin || this.width);
                    const bottom = top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
                    const lrtb = getFixedLRTB(left, right, top, bottom);
                    ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
                }
            }
            else if (this.character.textDecoration === 'underline') {
                const top = 1 + baseline;
                const right = left + (this.widthOrigin || this.width);
                const bottom = top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
                const lrtb = getFixedLRTB(left, right, top, bottom);
                ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
            }
            else if (this.character.textDecoration === 'line-through') {
                const top = 1 + baseline - this.ascent / 2;
                const right = left + (this.widthOrigin || this.width);
                const bottom = top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
                const lrtb = getFixedLRTB(left, right, top, bottom);
                ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
            }
        }
        if (direction === 'vertical') {
            ctx.restore();
        }
    }
    getWidthWithEllips(direction) {
        let text = this.text;
        const width = direction === 'vertical' ? this.height : this.width;
        if (this.ellipsis === 'hide') {
            return width;
        }
        else if (this.ellipsis === 'add') {
            return width + this.ellipsisWidth;
        }
        else if (this.ellipsis === 'replace') {
            const index = getStrByWithCanvas(text, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
            text = text.slice(0, index);
            text += this.ellipsisStr;
            const { width: measureWidth } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
            return width + this.ellipsisWidth - measureWidth;
        }
        return width;
    }
}
function seperateParagraph(paragraph, index) {
    const text1 = paragraph.text.slice(0, index);
    const text2 = paragraph.text.slice(index);
    const p1 = new Paragraph(text1, paragraph.newLine, paragraph.character, paragraph.ascentDescentMode);
    const p2 = new Paragraph(text2, true, paragraph.character, paragraph.ascentDescentMode);
    return [p1, p2];
}

const IMAGE_UPDATE_TAG_KEY = ['width', 'height', 'image', ...GRAPHIC_UPDATE_TAG_KEY];
class Image extends Graphic {
    constructor(params) {
        super(params);
        this.type = 'image';
        this.numberType = IMAGE_NUMBER_TYPE;
        this.loadImage(this.attribute.image);
    }
    getImageElement() {
        const { image } = this.attribute;
        if (!image || !this.resources) {
            return null;
        }
        const res = this.resources.get(image);
        if (res.state !== 'success') {
            return null;
        }
        return res.data;
    }
    get width() {
        this.tryUpdateAABBBounds();
        return this._actualWidth;
    }
    get height() {
        this.tryUpdateAABBBounds();
        return this._actualHeight;
    }
    get repeatX() {
        var _a;
        return (_a = this.attribute.repeatX) !== null && _a !== void 0 ? _a : 'no-repeat';
    }
    set repeatX(repeatX) {
        if (this.attribute.repeatX === repeatX) {
            this.attribute.repeatX = repeatX;
        }
    }
    get repeatY() {
        var _a;
        return (_a = this.attribute.repeatY) !== null && _a !== void 0 ? _a : 'no-repeat';
    }
    set repeatY(repeatY) {
        if (this.attribute.repeatY === repeatY) {
            this.attribute.repeatY = repeatY;
        }
    }
    get image() {
        return this.attribute.image;
    }
    set image(image) {
        if (image !== this.attribute.image) {
            this.attribute.image = image;
            this.loadImage(this.attribute.image);
        }
    }
    imageLoadSuccess(url, image, cb) {
        super.imageLoadSuccess(url, image, () => {
            if (this.successCallback) {
                this.successCallback();
            }
        });
        this.addUpdateBoundTag();
    }
    imageLoadFail(url, cb) {
        super.imageLoadFail(url, () => {
            if (this.failCallback) {
                this.failCallback();
            }
        });
    }
    setAttributes(params, forceUpdateTag, context) {
        if (params.image) {
            this.loadImage(params.image);
        }
        return super.setAttributes(params, forceUpdateTag, context);
    }
    setAttribute(key, value, forceUpdateTag, context) {
        if (key === 'image') {
            this.loadImage(value);
        }
        return super.setAttribute(key, value, forceUpdateTag, context);
    }
    getGraphicTheme() {
        return getTheme(this).image;
    }
    updateAABBBounds(attribute, imageTheme, aabbBounds) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
            const { maxWidth = imageTheme.maxWidth, maxHeight = imageTheme.maxHeight } = attribute;
            let { width, height } = attribute;
            if (width == null || height == null) {
                const imageElement = this.getImageElement();
                if (imageElement) {
                    const imageWidth = imageElement.width;
                    const imageHeight = imageElement.height;
                    if (width != null) {
                        height = width * (imageHeight / imageWidth);
                    }
                    else if (height != null) {
                        width = height * (imageWidth / imageHeight);
                    }
                    else {
                        const imageRatio = imageWidth / imageHeight;
                        const maxWHRatio = maxWidth / maxHeight;
                        if (imageRatio > maxWHRatio) {
                            width = maxWidth;
                            height = maxWidth / imageRatio;
                        }
                        else {
                            height = maxHeight;
                            width = maxHeight * imageRatio;
                        }
                    }
                }
                else {
                    width = maxWidth;
                    height = maxHeight;
                }
            }
            this._actualWidth = width;
            this._actualHeight = height;
            aabbBounds.set(0, 0, width, height);
        }
        const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
        updateBoundsOfCommonOuterBorder(attribute, imageTheme, tb1);
        aabbBounds.union(tb1);
        tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1;
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        application.graphicService.transformAABBBounds(attribute, aabbBounds, imageTheme, false, this);
        return aabbBounds;
    }
    getDefaultAttribute(name) {
        return DefaultImageAttribute[name];
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, IMAGE_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, IMAGE_UPDATE_TAG_KEY);
    }
    clone() {
        return new Image(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Image.NOWORK_ANIMATE_ATTR;
    }
}
Image.NOWORK_ANIMATE_ATTR = Object.assign({ image: 1, repeatX: 1, repeatY: 1 }, NOWORK_ANIMATE_ATTR);
function createImage(attributes) {
    return new Image(attributes);
}

class RichTextIcon extends Image {
    constructor(params) {
        super(params);
        this._x = 0;
        this._y = 0;
        this._hovered = false;
        this._marginArray = [0, 0, 0, 0];
        if (params.backgroundShowMode === 'always') {
            this._hovered = true;
        }
        if (params.margin) {
            const marginArray = parsePadding(params.margin);
            if (typeof marginArray === 'number') {
                this._marginArray = [marginArray, marginArray, marginArray, marginArray];
            }
            else {
                this._marginArray = marginArray;
            }
        }
        this.onBeforeAttributeUpdate = (val, attributes, key) => {
            if ((isArray(key) && key.indexOf('margin') !== -1) || key === 'margin') {
                if (attributes.margin) {
                    const marginArray = parsePadding(attributes.margin);
                    if (typeof marginArray === 'number') {
                        this._marginArray = [marginArray, marginArray, marginArray, marginArray];
                    }
                    else {
                        this._marginArray = marginArray;
                    }
                }
                else {
                    this._marginArray = [0, 0, 0, 0];
                }
            }
            return undefined;
        };
    }
    get width() {
        var _a;
        return ((_a = this.attribute.width) !== null && _a !== void 0 ? _a : 0) + this._marginArray[1] + this._marginArray[3];
    }
    get height() {
        var _a;
        return ((_a = this.attribute.height) !== null && _a !== void 0 ? _a : 0) + this._marginArray[0] + this._marginArray[2];
    }
    tryUpdateAABBBounds() {
        if (!this.shouldUpdateAABBBounds()) {
            return this._AABBBounds;
        }
        this.doUpdateAABBBounds();
        const { width = DefaultImageAttribute.width, height = DefaultImageAttribute.height } = this.attribute;
        const { backgroundWidth = width, backgroundHeight = height } = this.attribute;
        const expandX = (backgroundWidth - width) / 2;
        const expandY = (backgroundHeight - height) / 2;
        this._AABBBounds.expand([0, expandX * 2, expandY * 2, 0]);
        return this._AABBBounds;
    }
    setHoverState(hovered) {
        if (this.attribute.backgroundShowMode === 'hover' && this._hovered !== hovered) {
            this._hovered = hovered;
        }
    }
}

class Line {
    constructor(left, width, baseline, ascent, descent, lineBuffer, direction, isWidthMax) {
        this.left = left;
        this.width = width;
        this.baseline = baseline;
        this.ascent = ascent;
        this.descent = descent;
        this.top = baseline - ascent;
        this.paragraphs = lineBuffer.map(p => p);
        this.textAlign =
            (this.paragraphs[0] instanceof RichTextIcon
                ? this.paragraphs[0].attribute.textAlign
                : this.paragraphs[0].character.textAlign) || 'left';
        this.direction = direction;
        this.directionKey = DIRECTION_KEY[this.direction];
        this.actualWidth = 0;
        let maxHeight = 0;
        this.paragraphs.forEach((word, index) => {
            if (index === 0 && word instanceof Paragraph) {
                const result = regFirstSpace.exec(word.text);
                if ((result === null || result === void 0 ? void 0 : result.index) !== 0) {
                    word.text = word.text.slice(result === null || result === void 0 ? void 0 : result.index);
                    word.updateWidth();
                }
            }
            this.actualWidth += word[this.directionKey.width];
            maxHeight = Math.max(word[this.directionKey.height], maxHeight);
        });
        this.height = maxHeight;
        this.blankWidth = !isWidthMax ? this.width - this.actualWidth : 0;
        this.calcOffset(width, isWidthMax);
    }
    calcOffset(width, isWidthMax) {
        const directionKey = this.directionKey;
        const maxHeight = this.height;
        let x = this.left;
        let spacing = 0;
        if (this.actualWidth < width && !isWidthMax) {
            if (this.textAlign === 'right' || this.textAlign === 'end') {
                x = width - this.actualWidth;
            }
            else if (this.textAlign === 'center') {
                x = (width - this.actualWidth) / 2;
            }
            else if (this.textAlign === 'justify') {
                if (this.paragraphs.length < 2) {
                    x = (width - this.actualWidth) / 2;
                }
                else {
                    spacing = (width - this.actualWidth) / (this.paragraphs.length - 1);
                }
            }
        }
        this.paragraphs.map(function (paragraph) {
            if (paragraph instanceof RichTextIcon) {
                paragraph['_' + directionKey.x] = x;
                x += paragraph[directionKey.width] + spacing;
                paragraph['_' + directionKey.y] =
                    paragraph.attribute.textBaseline === 'top'
                        ? 0
                        : paragraph.attribute.textBaseline === 'bottom'
                            ? maxHeight - paragraph.height
                            : (maxHeight - paragraph.height) / 2;
            }
            else {
                paragraph[directionKey.left] = x;
                x += paragraph[directionKey.width] + spacing;
            }
        });
    }
    draw(ctx, lastLine, x, y, drawEllipsis, drawIcon) {
        if (drawEllipsis && (lastLine || this.paragraphs.some(p => p.overflow))) {
            let emptyOverflow = true;
            let skipEllipsis = false;
            for (let i = this.paragraphs.length - 1; i >= 0; i--) {
                const paragraph = this.paragraphs[i];
                if (paragraph.overflow) {
                    emptyOverflow = emptyOverflow && paragraph.text === '';
                }
                else {
                    if (emptyOverflow) {
                        skipEllipsis = true;
                        break;
                    }
                }
            }
            let otherParagraphWidth = 0;
            if (!skipEllipsis) {
                for (let i = this.paragraphs.length - 1; i >= 0; i--) {
                    const paragraph = this.paragraphs[i];
                    if (paragraph.overflow) {
                        if (paragraph.text === '') {
                            break;
                        }
                        continue;
                    }
                    if (paragraph instanceof RichTextIcon) {
                        break;
                    }
                    if (this.direction === 'vertical' && paragraph.direction !== 'vertical') {
                        paragraph.verticalEllipsis = true;
                        break;
                    }
                    const ellipsis = drawEllipsis === true ? '...' : drawEllipsis || '';
                    paragraph.ellipsisStr = ellipsis;
                    const { width } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode);
                    const ellipsisWidth = width || 0;
                    if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
                        lastLine && (paragraph.ellipsis = 'add');
                        break;
                    }
                    else if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
                        paragraph.ellipsis = 'replace';
                        paragraph.ellipsisWidth = ellipsisWidth;
                        paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
                        break;
                    }
                    else {
                        paragraph.ellipsis = 'hide';
                        otherParagraphWidth += paragraph.width;
                    }
                }
            }
        }
        let fillStyle = '';
        let globalAlpha = -1;
        let currBgList = [];
        const bgList = [currBgList];
        this.paragraphs.forEach((paragraph, index) => {
            if (paragraph instanceof RichTextIcon) {
                return;
            }
            const data = paragraph.drawBackground(ctx, y, this.ascent, x, index === 0, this.textAlign, this.height);
            if (!data) {
                return;
            }
            if (!(fillStyle === data.fillStyle && globalAlpha === data.globalAlpha)) {
                currBgList = [];
                bgList.push(currBgList);
                fillStyle = data.fillStyle;
                globalAlpha = data.globalAlpha;
            }
            currBgList.push(data);
        });
        bgList.forEach(bg => {
            if (bg.length === 0) {
                return;
            }
            const data = bg[0];
            const end = bg[bg.length - 1];
            ctx.fillStyle = data.fillStyle;
            ctx.globalAlpha = data.globalAlpha;
            ctx.fillRect(data.left, data.top, end.right - data.left, end.bottom - data.top);
        });
        this.paragraphs.forEach((paragraph, index) => {
            if (paragraph instanceof RichTextIcon) {
                paragraph.setAttributes({
                    x: x + paragraph._x,
                    y: y + paragraph._y
                });
                drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, this.ascent);
                return;
            }
            const b = {
                x1: this.left,
                y1: this.top,
                x2: this.left + this.actualWidth,
                y2: this.top + this.height
            };
            applyStrokeStyle(ctx, paragraph.character);
            applyFillStyle(ctx, paragraph.character, b);
            paragraph.draw(ctx, y, this.ascent, x, index === 0, this.textAlign, this.height);
        });
    }
    getWidthWithEllips(ellipsis) {
        let otherParagraphWidth = 0;
        for (let i = this.paragraphs.length - 1; i >= 0; i--) {
            const paragraph = this.paragraphs[i];
            if (paragraph instanceof RichTextIcon) {
                break;
            }
            const { width } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode);
            const ellipsisWidth = width || 0;
            if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
                paragraph.ellipsis = 'add';
                paragraph.ellipsisWidth = ellipsisWidth;
                break;
            }
            else if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
                paragraph.ellipsis = 'replace';
                paragraph.ellipsisWidth = ellipsisWidth;
                paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
                break;
            }
            else {
                paragraph.ellipsis = 'hide';
                otherParagraphWidth += paragraph.width;
            }
        }
        let width = 0;
        this.paragraphs.forEach((paragraph, index) => {
            if (paragraph instanceof RichTextIcon) {
                width += paragraph.width;
            }
            else {
                width += paragraph.getWidthWithEllips(this.direction);
            }
        });
        return width;
    }
}

class Wrapper {
    constructor(frame) {
        this.frame = frame;
        this.width = this.frame.width;
        this.height = this.frame.height;
        this.lineWidth = 0;
        this.y = this.frame.top;
        this.maxAscent = 0;
        this.maxDescent = 0;
        this.maxAscentForBlank = 0;
        this.maxDescentForBlank = 0;
        this.lineBuffer = [];
        this.direction = frame.layoutDirection;
        this.directionKey = DIRECTION_KEY[this.direction];
    }
    store(paragraph) {
        if (paragraph instanceof RichTextIcon) {
            this.frame.icons.set(paragraph.richtextId, paragraph);
            this.lineBuffer.push(paragraph);
            this.lineWidth += paragraph[this.directionKey.width];
            let iconAscent = 0;
            let iconDescent = 0;
            if (paragraph.attribute.textBaseline === 'top') {
                iconAscent = 0;
                iconDescent = paragraph.height;
            }
            else if (paragraph.attribute.textBaseline === 'bottom') {
                iconAscent = paragraph.height;
                iconDescent = 0;
            }
            else {
                iconAscent = paragraph.height / 2;
                iconDescent = paragraph.height / 2;
            }
            this.maxAscent = Math.max(this.maxAscent, iconAscent);
            this.maxDescent = Math.max(this.maxDescent, iconDescent);
        }
        else {
            this.lineBuffer.push(paragraph);
            if (paragraph.text.length !== 0) {
                this.lineWidth += paragraph[this.directionKey.width];
                this.maxAscent = Math.max(this.maxAscent, paragraph.ascent);
                this.maxDescent = Math.max(this.maxDescent, paragraph.descent);
            }
            else {
                this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent);
                this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent);
            }
        }
    }
    send() {
        if (this.lineBuffer.length === 0) {
            return;
        }
        const maxAscent = this.maxAscent === 0 ? this.maxAscentForBlank : this.maxAscent;
        const maxDescent = this.maxDescent === 0 ? this.maxDescentForBlank : this.maxDescent;
        const line = new Line(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, this.direction === 'horizontal' ? this.frame.isWidthMax : this.frame.isHeightMax);
        this.frame.lines.push(line);
        this.frame.actualHeight += line.height;
        this.y += line.height;
        this.lineBuffer.length = 0;
        this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
    }
    deal(paragraph, singleLine = false) {
        if (paragraph instanceof RichTextIcon) {
            if ((this.direction === 'horizontal' && this.width === 0) ||
                (this.direction === 'vertical' && this.height === 0)) {
                this.store(paragraph);
            }
            else {
                if (this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width]) {
                    this.store(paragraph);
                }
                else if (this.lineBuffer.length === 0) {
                    this.store(paragraph);
                    this.send();
                }
                else {
                    this.send();
                    this.deal(paragraph);
                }
            }
            return;
        }
        if (typeof this.width !== 'number' || this.width < 0) {
            return;
        }
        if (paragraph.newLine) {
            this.send();
        }
        if (paragraph.text.length === 0 && !this.newLine) {
            return;
        }
        if ((this.direction === 'horizontal' && this.width === 0) || (this.direction === 'vertical' && this.height === 0)) {
            this.store(paragraph);
        }
        else {
            if (this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width]) {
                this.store(paragraph);
            }
            else if (this.lineWidth === this[this.directionKey.width]) {
                this.send();
                this.deal(paragraph);
            }
            else {
                this.cut(paragraph, singleLine);
            }
        }
    }
    cut(paragraph, singleLine) {
        const availableWidth = this[this.directionKey.width] - this.lineWidth || 0;
        const guessIndex = Math.ceil((availableWidth / paragraph[this.directionKey.width]) * paragraph.length) || 0;
        const index = getStrByWithCanvas(paragraph.text, availableWidth, paragraph.character, guessIndex, this.frame.wordBreak === 'break-word');
        if (index !== 0) {
            const [p1, p2] = seperateParagraph(paragraph, index);
            this.store(p1);
            if (singleLine) {
                this.send();
            }
            else {
                this.deal(p2);
            }
        }
        else if (this.lineBuffer.length !== 0) {
            this.send();
            this.deal(paragraph);
        }
    }
}

let supportIntl = false;
try {
    supportIntl = Intl && typeof Intl.Segmenter === 'function';
}
catch (e) {
    supportIntl = false;
}
const RICHTEXT_UPDATE_TAG_KEY = [
    'width',
    'height',
    'ellipsis',
    'wordBreak',
    'verticalDirection',
    'maxHeight',
    'maxWidth',
    'textAlign',
    'textBaseline',
    'textConfig',
    'layoutDirection',
    'fill',
    'stroke',
    'fontSize',
    'fontFamily',
    'fontStyle',
    'fontWeight',
    'lineWidth',
    'opacity',
    'fillOpacity',
    'strokeOpacity',
    ...GRAPHIC_UPDATE_TAG_KEY
];
class RichText extends Graphic {
    constructor(params) {
        super(params);
        this.type = 'richtext';
        this._currentHoverIcon = null;
        this.numberType = RICHTEXT_NUMBER_TYPE;
        this.onBeforeAttributeUpdate = ((val, attributes, key) => {
            for (const key in val) {
                if (key === 'hoverIconId') {
                    if (val[key] === attributes[key]) {
                        continue;
                    }
                    const icon = this._frameCache.icons.get(val[key]);
                    this.updateHoverIconState(icon);
                }
            }
        });
    }
    get width() {
        var _a;
        return (_a = this.attribute.width) !== null && _a !== void 0 ? _a : DefaultRichTextAttribute.width;
    }
    set width(w) {
        if (this.attribute.width === w) {
            return;
        }
        this.attribute.width = w;
        this.addUpdateShapeAndBoundsTag();
    }
    get height() {
        var _a;
        return (_a = this.attribute.height) !== null && _a !== void 0 ? _a : DefaultRichTextAttribute.height;
    }
    set height(h) {
        if (this.attribute.height === h) {
            return;
        }
        this.attribute.height = h;
        this.addUpdateShapeAndBoundsTag();
    }
    get maxWidth() {
        return this.attribute.maxWidth;
    }
    set maxWidth(mw) {
        if (this.attribute.maxWidth === mw) {
            return;
        }
        this.attribute.maxWidth = mw;
        this.addUpdateShapeAndBoundsTag();
    }
    get maxHeight() {
        return this.attribute.maxHeight;
    }
    set maxHeight(mh) {
        if (this.attribute.maxHeight === mh) {
            return;
        }
        this.attribute.maxHeight = mh;
        this.addUpdateShapeAndBoundsTag();
    }
    get ellipsis() {
        var _a;
        return (_a = this.attribute.ellipsis) !== null && _a !== void 0 ? _a : DefaultRichTextAttribute.ellipsis;
    }
    set ellipsis(e) {
        if (this.attribute.ellipsis === e) {
            return;
        }
        this.attribute.ellipsis = e;
        this.addUpdateShapeAndBoundsTag();
    }
    get wordBreak() {
        var _a;
        return (_a = this.attribute.wordBreak) !== null && _a !== void 0 ? _a : DefaultRichTextAttribute.wordBreak;
    }
    set wordBreak(wb) {
        if (this.attribute.wordBreak === wb) {
            return;
        }
        this.attribute.wordBreak = wb;
        this.addUpdateShapeAndBoundsTag();
    }
    get verticalDirection() {
        var _a;
        return (_a = this.attribute.verticalDirection) !== null && _a !== void 0 ? _a : DefaultRichTextAttribute.verticalDirection;
    }
    set verticalDirection(vd) {
        if (this.attribute.verticalDirection === vd) {
            return;
        }
        this.attribute.verticalDirection = vd;
        this.addUpdateShapeAndBoundsTag();
    }
    get textAlign() {
        var _a;
        return (_a = this.attribute.textAlign) !== null && _a !== void 0 ? _a : DefaultRichTextAttribute.textAlign;
    }
    set textAlign(align) {
        if (this.attribute.textAlign === align) {
            return;
        }
        this.attribute.textAlign = align;
        this.addUpdateShapeAndBoundsTag();
    }
    get textBaseline() {
        var _a;
        return (_a = this.attribute.textBaseline) !== null && _a !== void 0 ? _a : DefaultRichTextAttribute.textBaseline;
    }
    set textBaseline(baseline) {
        if (this.attribute.textBaseline === baseline) {
            return;
        }
        this.attribute.textBaseline = baseline;
        this.addUpdateShapeAndBoundsTag();
    }
    get textConfig() {
        var _a;
        return (_a = this.attribute.textConfig) !== null && _a !== void 0 ? _a : DefaultRichTextAttribute.textConfig;
    }
    set textConfig(config) {
        this.attribute.textConfig = config;
        this.addUpdateShapeAndBoundsTag();
    }
    getGraphicTheme() {
        return getTheme(this).richtext;
    }
    static AllSingleCharacter(cache) {
        if (cache.lines) {
            const frame = cache;
            return frame.lines.every(line => line.paragraphs.every(item => !(item.text && isString(item.text) && RichText.splitText(item.text).length > 1)));
        }
        const tc = cache;
        return tc.every(item => item.isComposing ||
            !(item.text && isString(item.text) && RichText.splitText(item.text).length > 1));
    }
    static splitText(text) {
        if (supportIntl) {
            const segmenter = new Intl.Segmenter(undefined, { granularity: 'grapheme' });
            const segments = [];
            for (const { segment } of segmenter.segment(text)) {
                segments.push(segment);
            }
            return segments;
        }
        return Array.from(text);
    }
    static TransformTextConfig2SingleCharacter(textConfig) {
        const tc = [];
        textConfig.forEach((item) => {
            const textList = RichText.splitText(item.text.toString());
            if (isString(item.text) && textList.length > 1) {
                for (let i = 0; i < textList.length; i++) {
                    const t = textList[i];
                    tc.push(Object.assign(Object.assign({}, item), { text: t }));
                }
            }
            else {
                tc.push(item);
            }
        });
        return tc;
    }
    updateAABBBounds(attribute, richtextTheme, aabbBounds) {
        var _a, _b, _c, _d;
        const { width = richtextTheme.width, height = richtextTheme.height, maxWidth = richtextTheme.maxWidth, maxHeight = richtextTheme.maxHeight, textAlign = richtextTheme.textAlign, textBaseline = (_b = (_a = attribute.textBaseline) !== null && _a !== void 0 ? _a : richtextTheme.textBaseline) !== null && _b !== void 0 ? _b : 'top', editOptions } = attribute;
        if (width > 0 && height > 0) {
            aabbBounds.set(0, 0, width, height);
        }
        else {
            const frameCache = this.getFrameCache();
            const { width: actualWidth, height: actualHeight } = frameCache.getActualSize();
            let contentWidth = width || actualWidth || 0;
            let contentHeight = height || actualHeight || 0;
            contentHeight = typeof maxHeight === 'number' && contentHeight > maxHeight ? maxHeight : contentHeight || 0;
            contentWidth = typeof maxWidth === 'number' && contentWidth > maxWidth ? maxWidth : contentWidth || 0;
            aabbBounds.set(0, 0, contentWidth, contentHeight);
        }
        if (editOptions && editOptions.keepHeightWhileEmpty && !aabbBounds.height() && !((_c = attribute.textConfig) === null || _c === void 0 ? void 0 : _c.length)) {
            aabbBounds.y2 = aabbBounds.y1 + ((_d = attribute.fontSize) !== null && _d !== void 0 ? _d : 12);
            aabbBounds.x2 = aabbBounds.x1 + 2;
        }
        let deltaY = 0;
        switch (textBaseline) {
            case 'top':
                deltaY = 0;
                break;
            case 'middle':
                deltaY = -aabbBounds.height() / 2;
                break;
            case 'bottom':
                deltaY = -aabbBounds.height();
                break;
        }
        let deltaX = 0;
        switch (textAlign) {
            case 'left':
                deltaX = 0;
                break;
            case 'center':
                deltaX = -aabbBounds.width() / 2;
                break;
            case 'right':
                deltaX = -aabbBounds.width();
                break;
        }
        if (!height) {
            if (this.verticalDirection === 'middle') {
                deltaY -= aabbBounds.height() / 2;
            }
            else if (this.verticalDirection === 'bottom') {
                deltaY -= aabbBounds.height();
            }
        }
        aabbBounds.translate(deltaX, deltaY);
        application.graphicService.updateTempAABBBounds(aabbBounds);
        if (attribute.forceBoundsHeight != null || attribute.forceBoundsWidth != null) {
            application.graphicService.updateHTMLTextAABBBounds(attribute, richtextTheme, aabbBounds);
        }
        this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1;
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        application.graphicService.transformAABBBounds(attribute, aabbBounds, richtextTheme, false, this);
        if (aabbBounds.width() === 0 && aabbBounds.height() === 0) {
            aabbBounds.clear();
        }
        return aabbBounds;
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, RICHTEXT_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, RICHTEXT_UPDATE_TAG_KEY);
    }
    getFrameCache() {
        if (this.shouldUpdateShape()) {
            this.doUpdateFrameCache();
            this.clearUpdateShapeTag();
        }
        return this._frameCache;
    }
    get cliped() {
        const frameCache = this.getFrameCache();
        if (frameCache.actualHeight > frameCache.height) {
            return true;
        }
        const { disableAutoWrapLine } = this.attribute;
        if (disableAutoWrapLine) {
            for (let i = 0; i < frameCache.lines.length; i++) {
                const l = frameCache.lines[i];
                for (let j = 0; j < l.paragraphs.length; j++) {
                    const p = l.paragraphs[j];
                    if (p.overflow && p.text !== '') {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    combinedStyleToCharacter(config) {
        const { fill, stroke, fontSize, fontFamily, fontStyle, fontWeight, lineWidth, opacity, fillOpacity, lineHeight, strokeOpacity, upgradeAttrs } = this.attribute;
        const out = Object.assign({ fill,
            stroke,
            fontSize,
            fontFamily,
            fontStyle,
            fontWeight,
            lineWidth,
            opacity,
            fillOpacity,
            strokeOpacity }, config);
        if (upgradeAttrs === null || upgradeAttrs === void 0 ? void 0 : upgradeAttrs.lineHeight) {
            out.lineHeight = lineHeight;
        }
        return out;
    }
    doUpdateFrameCache(tc) {
        var _a;
        const { maxWidth, maxHeight, width, height, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection, singleLine, disableAutoWrapLine, editable, ascentDescentMode, upgradeAttrs } = this.attribute;
        const enableMultiBreakLine = upgradeAttrs && upgradeAttrs.multiBreakLine;
        let { textConfig: _tc = [] } = this.attribute;
        if (editable && _tc.length > 0 && !RichText.AllSingleCharacter(_tc)) {
            _tc = RichText.TransformTextConfig2SingleCharacter(_tc);
            this.attribute.textConfig = _tc;
        }
        const paragraphs = [];
        const textConfig = tc !== null && tc !== void 0 ? tc : _tc;
        for (let i = 0; i < textConfig.length; i++) {
            if ('image' in textConfig[i]) {
                const config = this.combinedStyleToCharacter(textConfig[i]);
                config.lineWidth = undefined;
                const iconCache = config.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config.id);
                if (iconCache) {
                    paragraphs.push(iconCache);
                }
                else {
                    const icon = new RichTextIcon(config);
                    icon.successCallback = () => {
                        var _a;
                        this.addUpdateBoundTag();
                        (_a = this.stage) === null || _a === void 0 ? void 0 : _a.renderNextFrame();
                    };
                    icon.richtextId = config.id;
                    paragraphs.push(icon);
                }
            }
            else {
                const richTextConfig = this.combinedStyleToCharacter(textConfig[i]);
                if (isNumber$1(richTextConfig.text)) {
                    richTextConfig.text = `${richTextConfig.text}`;
                }
                if (richTextConfig.text && richTextConfig.text.includes('\n')) {
                    const textParts = richTextConfig.text.split('\n');
                    for (let j = 0; j < textParts.length; j++) {
                        if (j === 0) {
                            paragraphs.push(new Paragraph(textParts[j], false, richTextConfig, ascentDescentMode));
                        }
                        else if (textParts[j] || i === textConfig.length - 1) {
                            paragraphs.push(new Paragraph(textParts[j], true, richTextConfig, ascentDescentMode));
                        }
                        else {
                            const nextRichTextConfig = this.combinedStyleToCharacter(textConfig[i + 1]);
                            paragraphs.push(new Paragraph(textParts[j], true, nextRichTextConfig, ascentDescentMode));
                        }
                    }
                }
                else if (richTextConfig.text) {
                    paragraphs.push(new Paragraph(richTextConfig.text, false, richTextConfig, ascentDescentMode));
                }
            }
        }
        const maxWidthFinite = typeof maxWidth === 'number' && Number.isFinite(maxWidth) && maxWidth > 0;
        const maxHeightFinite = typeof maxHeight === 'number' && Number.isFinite(maxHeight) && maxHeight > 0;
        const richTextWidthEnable = typeof width === 'number' &&
            Number.isFinite(width) &&
            width > 0 &&
            (!maxWidthFinite || width <= maxWidth);
        const richTextHeightEnable = typeof height === 'number' &&
            Number.isFinite(height) &&
            height > 0 &&
            (!maxHeightFinite || height <= maxHeight);
        const frameWidth = richTextWidthEnable ? width : maxWidthFinite ? maxWidth : 0;
        const frameHeight = richTextHeightEnable ? height : maxHeightFinite ? maxHeight : 0;
        const frame = new Frame(0, 0, frameWidth || 0, frameHeight || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || 'horizontal', !richTextWidthEnable && maxWidthFinite, !richTextHeightEnable && maxHeightFinite, singleLine || false, (_a = this._frameCache) === null || _a === void 0 ? void 0 : _a.icons);
        const wrapper = new Wrapper(frame);
        wrapper.newLine = enableMultiBreakLine;
        if (disableAutoWrapLine) {
            let lineCount = 0;
            let skip = false;
            for (let i = 0; i < paragraphs.length; i++) {
                const p = paragraphs[i];
                if (skip) {
                    p.overflow = true;
                    p.left = Infinity;
                    p.top = Infinity;
                    !p.newLine && frame.lines[frame.lines.length - 1].paragraphs.push(p);
                }
                else {
                    wrapper.deal(p, true);
                }
                if (frame.lines.length !== lineCount) {
                    lineCount = frame.lines.length;
                    wrapper.lineBuffer.length = 0;
                    p.overflow = true;
                    p.left = 1000;
                    p.top = 1000;
                    frame.lines[frame.lines.length - 1].paragraphs.push(p);
                    skip = true;
                }
                if (p.newLine) {
                    skip = false;
                    wrapper.lineWidth = 0;
                }
                wrapper.send();
            }
        }
        else {
            for (let i = 0; i < paragraphs.length; i++) {
                wrapper.deal(paragraphs[i]);
            }
        }
        wrapper.send();
        const directionEnable = frame.layoutDirection === 'horizontal' ? richTextWidthEnable : richTextHeightEnable;
        if (!directionEnable) {
            const frameSize = frame.getActualSizeWidthEllipsis();
            let offsetSize = frame.layoutDirection === 'horizontal' ? frameSize.width : frameSize.height;
            if (frame.layoutDirection === 'horizontal' ? maxWidthFinite : maxHeightFinite) {
                offsetSize = Math.min(offsetSize, frame.layoutDirection === 'horizontal' ? maxWidth : maxHeight);
            }
            frame.lines.forEach(function (l) {
                l.calcOffset(offsetSize, false);
            });
        }
        if (enableMultiBreakLine) {
            frame.lines.forEach(item => {
                const lastParagraphs = item.paragraphs;
                item.paragraphs = item.paragraphs.filter(p => p.text !== '');
                if (item.paragraphs.length === 0 && lastParagraphs.length) {
                    lastParagraphs[0].text = '\n';
                    item.paragraphs.push(lastParagraphs[0]);
                }
            });
        }
        this._frameCache = frame;
    }
    clone() {
        return new RichText(Object.assign({}, this.attribute));
    }
    setStage(stage, layer) {
        super.setStage(stage, layer);
        const frameCache = this.getFrameCache();
        frameCache.icons.forEach(icon => {
            icon.setStage(stage, layer);
        });
    }
    bindIconEvent() {
        this.addEventListener('pointermove', (e) => {
            const pickedIcon = this.pickIcon(e.global);
            if (pickedIcon && pickedIcon === this._currentHoverIcon) ;
            else if (pickedIcon) {
                this.setAttribute('hoverIconId', pickedIcon.richtextId);
            }
            else if (!pickedIcon && this._currentHoverIcon) {
                this.setAttribute('hoverIconId', undefined);
            }
        });
        this.addEventListener('pointerleave', (e) => {
            if (this._currentHoverIcon) {
                this.setAttribute('hoverIconId', undefined);
            }
        });
    }
    updateHoverIconState(pickedIcon) {
        var _a, _b, _c, _d, _e;
        if (pickedIcon) {
            (_a = this._currentHoverIcon) === null || _a === void 0 ? void 0 : _a.setHoverState(false);
            this._currentHoverIcon = pickedIcon;
            this._currentHoverIcon.setHoverState(true);
            (_b = this.stage) === null || _b === void 0 ? void 0 : _b.setCursor(pickedIcon.attribute.cursor);
            (_c = this.stage) === null || _c === void 0 ? void 0 : _c.renderNextFrame();
        }
        else {
            this._currentHoverIcon.setHoverState(false);
            this._currentHoverIcon = null;
            (_d = this.stage) === null || _d === void 0 ? void 0 : _d.setCursor();
            (_e = this.stage) === null || _e === void 0 ? void 0 : _e.renderNextFrame();
        }
    }
    pickIcon(point) {
        const frameCache = this.getFrameCache();
        const { e: x, f: y } = this.globalTransMatrix;
        let pickIcon;
        frameCache.icons.forEach((icon, key) => {
            var _a, _b;
            const bounds = icon.AABBBounds.clone();
            bounds.translate(icon._marginArray[3], icon._marginArray[0]);
            if (bounds.containsPoint({ x: point.x - x, y: point.y - y })) {
                pickIcon = icon;
                pickIcon.globalX = ((_a = pickIcon.attribute.x) !== null && _a !== void 0 ? _a : 0) + x + icon._marginArray[3];
                pickIcon.globalY = ((_b = pickIcon.attribute.y) !== null && _b !== void 0 ? _b : 0) + y + icon._marginArray[0];
            }
        });
        return pickIcon;
    }
    getNoWorkAnimateAttr() {
        return RichText.NOWORK_ANIMATE_ATTR;
    }
}
RichText.NOWORK_ANIMATE_ATTR = Object.assign({ ellipsis: 1, wordBreak: 1, verticalDirection: 1, textAlign: 1, textBaseline: 1, textConfig: 1, layoutDirection: 1 }, NOWORK_ANIMATE_ATTR);
function createRichText(attributes) {
    return new RichText(attributes);
}

const PATH_UPDATE_TAG_KEY = ['path', 'customPath', ...GRAPHIC_UPDATE_TAG_KEY];
class Path extends Graphic {
    constructor(params) {
        super(params);
        this.type = 'path';
        this.numberType = PATH_NUMBER_TYPE;
    }
    get pathShape() {
        this.tryUpdateAABBBounds();
        return this.getParsedPathShape();
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const { path } = this.attribute;
        return path != null && path !== '';
    }
    getParsedPathShape() {
        const pathTheme = this.getGraphicTheme();
        if (!this.valid) {
            return pathTheme.path;
        }
        const attribute = this.attribute;
        if (attribute.path instanceof CustomPath2D) {
            return attribute.path;
        }
        if (isNil(this.cache)) {
            this.doUpdatePathShape();
        }
        if (this.cache instanceof CustomPath2D) {
            return this.cache;
        }
        return pathTheme.path;
    }
    getGraphicTheme() {
        return getTheme(this).path;
    }
    updateAABBBounds(attribute, pathTheme, aabbBounds) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
            const pathShape = this.getParsedPathShape();
            aabbBounds.union(pathShape.getBounds());
        }
        const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
        updateBoundsOfCommonOuterBorder(attribute, pathTheme, tb1);
        aabbBounds.union(tb1);
        tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1;
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        const { lineJoin = pathTheme.lineJoin } = attribute;
        application.graphicService.transformAABBBounds(attribute, aabbBounds, pathTheme, lineJoin === 'miter', this);
        return aabbBounds;
    }
    doUpdateAABBBounds(full) {
        this.doUpdatePathShape();
        return super.doUpdateAABBBounds(full);
    }
    doUpdatePathShape() {
        const attribute = this.attribute;
        if (isString(attribute.path, true)) {
            this.cache = new CustomPath2D().fromString(attribute.path);
        }
        else if (attribute.customPath) {
            this.cache = new CustomPath2D();
            attribute.customPath(this.cache, this);
        }
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, PATH_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, PATH_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        const x = 0;
        const y = 0;
        return new CustomPath2D().fromCustomPath2D(this.getParsedPathShape(), x, y);
    }
    clone() {
        return new Path(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Path.NOWORK_ANIMATE_ATTR;
    }
}
Path.NOWORK_ANIMATE_ATTR = Object.assign({ path: 1, customPath: 1 }, NOWORK_ANIMATE_ATTR);
function createPath(attributes) {
    return new Path(attributes);
}

const AREA_UPDATE_TAG_KEY = ['segments', 'points', 'curveType', 'curveTension', ...GRAPHIC_UPDATE_TAG_KEY];
class Area extends Graphic {
    constructor(params) {
        super(params);
        this.type = 'area';
        this.numberType = AREA_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        if (this.pathProxy) {
            return true;
        }
        const { points, segments } = this.attribute;
        if (segments) {
            if (segments.length === 0) {
                return false;
            }
            return true;
        }
        else if (points) {
            if (points.length === 0) {
                return false;
            }
            return true;
        }
        return false;
    }
    getGraphicTheme() {
        return getTheme(this).area;
    }
    updateAABBBounds(attribute, areaTheme, aabbBounds) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
            attribute.segments
                ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds)
                : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds);
        }
        application.graphicService.updateTempAABBBounds(aabbBounds);
        this.setWidthHeightWithoutTransform(aabbBounds);
        const { lineJoin = areaTheme.lineJoin } = attribute;
        application.graphicService.transformAABBBounds(attribute, aabbBounds, areaTheme, lineJoin === 'miter', this);
        return aabbBounds;
    }
    updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
        const { points = areaTheme.points } = attribute;
        const b = aabbBounds;
        points.forEach(p => {
            var _a, _b;
            b.add(p.x, p.y);
            b.add((_a = p.x1) !== null && _a !== void 0 ? _a : p.x, (_b = p.y1) !== null && _b !== void 0 ? _b : p.y);
        });
        return b;
    }
    updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
        const { segments = areaTheme.segments } = attribute;
        const b = aabbBounds;
        segments.forEach(s => {
            s.points.forEach(p => {
                var _a, _b;
                b.add(p.x, p.y);
                b.add((_a = p.x1) !== null && _a !== void 0 ? _a : p.x, (_b = p.y1) !== null && _b !== void 0 ? _b : p.y);
            });
        });
        return b;
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        if (key === 'points') {
            nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio);
        }
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, AREA_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, AREA_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        let path = super.toCustomPath();
        if (path) {
            return path;
        }
        path = new CustomPath2D();
        const attribute = this.attribute;
        const segments = attribute.segments;
        const parsePoints = (points) => {
            if (points && points.length) {
                let isFirst = true;
                const basePoints = [];
                points.forEach(point => {
                    var _a, _b;
                    if (point.defined === false) {
                        return;
                    }
                    if (isFirst) {
                        path.moveTo(point.x, point.y);
                    }
                    else {
                        path.lineTo(point.x, point.y);
                    }
                    basePoints.push({ x: (_a = point.x1) !== null && _a !== void 0 ? _a : point.x, y: (_b = point.y1) !== null && _b !== void 0 ? _b : point.y });
                    isFirst = false;
                });
                if (basePoints.length) {
                    for (let i = basePoints.length - 1; i >= 0; i--) {
                        path.lineTo(basePoints[i].x, basePoints[i].y);
                    }
                    path.closePath();
                }
            }
        };
        if (attribute.points) {
            parsePoints(attribute.points);
        }
        else if (segments && segments.length) {
            segments.forEach(seg => {
                parsePoints(seg.points);
            });
        }
        return path;
    }
    clone() {
        return new Area(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Area.NOWORK_ANIMATE_ATTR;
    }
}
Area.NOWORK_ANIMATE_ATTR = Object.assign({ segments: 1, curveType: 1 }, NOWORK_ANIMATE_ATTR);
function createArea(attributes) {
    return new Area(attributes);
}

const ARC_UPDATE_TAG_KEY = [
    'innerRadius',
    'outerRadius',
    'startAngle',
    'endAngle',
    'cornerRadius',
    'padAngle',
    'padRadius',
    'cap',
    ...GRAPHIC_UPDATE_TAG_KEY
];
class Arc extends Graphic {
    constructor(params) {
        super(params);
        this.type = 'arc';
        this.numberType = ARC_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const { startAngle, endAngle, outerRadius, innerRadius } = this.attribute;
        return (this._validNumber(startAngle) &&
            this._validNumber(endAngle) &&
            this._validNumber(outerRadius) &&
            this._validNumber(innerRadius));
    }
    getParsedCornerRadius() {
        const arcTheme = this.getGraphicTheme();
        const { cornerRadius = arcTheme.cornerRadius, innerPadding = arcTheme.innerPadding, outerPadding = arcTheme.outerPadding } = this.attribute;
        let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
        outerRadius += outerPadding;
        innerRadius -= innerPadding;
        if (cornerRadius === 0 || cornerRadius === '0%') {
            return 0;
        }
        const deltaRadius = Math.abs(outerRadius - innerRadius);
        const parseCR = (cornerRadius) => {
            return Math.min(isNumber$1(cornerRadius, true)
                ? cornerRadius
                : (deltaRadius * parseFloat(cornerRadius)) / 100, deltaRadius / 2);
        };
        if (isArray(cornerRadius)) {
            const crList = cornerRadius.map(cr => parseCR(cr) || 0);
            if (crList.length === 0) {
                return [crList[0], crList[0], crList[0], crList[0]];
            }
            else if (crList.length === 2) {
                return [crList[0], crList[1], crList[0], crList[1]];
            }
            else if (crList.length === 3) {
                crList.push(0);
            }
            return crList;
        }
        return parseCR(cornerRadius);
    }
    getParsedAngle() {
        const arcTheme = this.getGraphicTheme();
        let { startAngle = arcTheme.startAngle, endAngle = arcTheme.endAngle } = this.attribute;
        const { cap = arcTheme.cap } = this.attribute;
        const sign = endAngle - startAngle >= 0 ? 1 : -1;
        const deltaAngle = endAngle - startAngle;
        startAngle = clampAngleByRadian(startAngle);
        endAngle = startAngle + deltaAngle;
        if (cap && abs(deltaAngle) < pi2 - epsilon) {
            let startCap = 1;
            let endCap = 1;
            if (cap.length) {
                startCap = Number(cap[0]);
                endCap = Number(cap[1]);
            }
            let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
            const { outerPadding = arcTheme.outerPadding, innerPadding = arcTheme.innerPadding } = this.attribute;
            outerRadius += outerPadding;
            innerRadius -= innerPadding;
            const capWidth = Math.abs(outerRadius - innerRadius) / 2;
            const capAngle = capWidth / outerRadius;
            if (capWidth > epsilon && outerRadius > epsilon) {
                return {
                    startAngle: startAngle - sign * capAngle * startCap,
                    endAngle: endAngle + sign * capAngle * endCap,
                    sc: sign * capAngle * startCap,
                    ec: sign * capAngle * endCap
                };
            }
        }
        return {
            startAngle: startAngle,
            endAngle: endAngle
        };
    }
    getParsePadAngle(startAngle, endAngle) {
        const arcTheme = this.getGraphicTheme();
        const { innerPadding = arcTheme.innerPadding, outerPadding = arcTheme.outerPadding, padAngle = arcTheme.padAngle } = this.attribute;
        let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
        outerRadius += outerPadding;
        innerRadius -= innerPadding;
        const { padRadius = sqrt(outerRadius * outerRadius + innerRadius * innerRadius) } = this.attribute;
        const deltaAngle = abs(endAngle - startAngle);
        let outerStartAngle = startAngle;
        let outerEndAngle = endAngle;
        let innerStartAngle = startAngle;
        let innerEndAngle = endAngle;
        const halfPadAngle = padAngle / 2;
        let innerDeltaAngle = deltaAngle;
        let outerDeltaAngle = deltaAngle;
        if (halfPadAngle > epsilon && padRadius > epsilon) {
            const sign = endAngle > startAngle ? 1 : -1;
            let p0 = asin((Number(padRadius) / innerRadius) * sin(halfPadAngle));
            let p1 = asin((Number(padRadius) / outerRadius) * sin(halfPadAngle));
            if ((innerDeltaAngle -= p0 * 2) > epsilon) {
                p0 *= sign;
                innerStartAngle += p0;
                innerEndAngle -= p0;
            }
            else {
                innerDeltaAngle = 0;
                innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2;
            }
            if ((outerDeltaAngle -= p1 * 2) > epsilon) {
                p1 *= sign;
                outerStartAngle += p1;
                outerEndAngle -= p1;
            }
            else {
                outerDeltaAngle = 0;
                outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2;
            }
            return {
                outerStartAngle,
                outerEndAngle,
                innerStartAngle,
                innerEndAngle,
                innerDeltaAngle,
                outerDeltaAngle
            };
        }
        return {
            outerStartAngle,
            outerEndAngle,
            innerStartAngle,
            innerEndAngle,
            innerDeltaAngle,
            outerDeltaAngle
        };
    }
    getGraphicTheme() {
        return getTheme(this).arc;
    }
    updateAABBBounds(attribute, arcTheme, aabbBounds, full) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
            full
                ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds)
                : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds);
        }
        const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
        updateBoundsOfCommonOuterBorder(attribute, arcTheme, tb1);
        aabbBounds.union(tb1);
        tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        this.setWidthHeightWithoutTransform(aabbBounds);
        const { lineJoin = arcTheme.lineJoin } = attribute;
        application.graphicService.transformAABBBounds(attribute, aabbBounds, arcTheme, lineJoin === 'miter', this);
        return aabbBounds;
    }
    updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) {
        let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = attribute;
        const { outerPadding = arcTheme.outerPadding, innerPadding = arcTheme.innerPadding } = attribute;
        outerRadius += outerPadding;
        innerRadius -= innerPadding;
        if (outerRadius < innerRadius) {
            outerRadius = innerRadius;
        }
        aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius);
        return aabbBounds;
    }
    updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds) {
        let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = attribute;
        const { outerPadding = arcTheme.outerPadding, innerPadding = arcTheme.innerPadding } = attribute;
        outerRadius += outerPadding;
        innerRadius -= innerPadding;
        if (outerRadius < innerRadius) {
            const temp = outerRadius;
            outerRadius = innerRadius;
            innerRadius = temp;
        }
        let { endAngle = arcTheme.endAngle, startAngle = arcTheme.startAngle } = attribute;
        if (startAngle > endAngle) {
            const temp = startAngle;
            startAngle = endAngle;
            endAngle = temp;
        }
        if (outerRadius <= epsilon) {
            aabbBounds.set(0, 0, 0, 0);
        }
        else if (Math.abs(endAngle - startAngle) > pi2 - epsilon) {
            aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius);
        }
        else {
            circleBounds(startAngle, endAngle, outerRadius, aabbBounds);
            circleBounds(startAngle, endAngle, innerRadius, aabbBounds);
        }
        return aabbBounds;
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, ARC_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, ARC_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        var _a, _b, _c, _d;
        let path = super.toCustomPath();
        if (path) {
            return path;
        }
        const x = 0;
        const y = 0;
        const attribute = this.attribute;
        const { startAngle, endAngle } = this.getParsedAngle();
        let innerRadius = ((_a = attribute.innerRadius) !== null && _a !== void 0 ? _a : 0) - ((_b = attribute.innerPadding) !== null && _b !== void 0 ? _b : 0);
        let outerRadius = ((_c = attribute.outerRadius) !== null && _c !== void 0 ? _c : 0) - ((_d = attribute.outerPadding) !== null && _d !== void 0 ? _d : 0);
        const deltaAngle = abs(endAngle - startAngle);
        const clockwise = endAngle > startAngle;
        if (outerRadius < innerRadius) {
            const temp = outerRadius;
            outerRadius = innerRadius;
            innerRadius = temp;
        }
        path = new CustomPath2D();
        if (outerRadius <= epsilon) {
            path.moveTo(x, y);
        }
        else if (deltaAngle >= pi2 - epsilon) {
            path.moveTo(x + outerRadius * cos(startAngle), y + outerRadius * sin(startAngle));
            path.arc(x, y, outerRadius, startAngle, endAngle, !clockwise);
            if (innerRadius > epsilon) {
                path.moveTo(x + innerRadius * cos(endAngle), y + innerRadius * sin(endAngle));
                path.arc(x, y, innerRadius, endAngle, startAngle, clockwise);
            }
        }
        else {
            const xors = outerRadius * cos(startAngle);
            const yors = outerRadius * sin(startAngle);
            const xire = innerRadius * cos(endAngle);
            const yire = innerRadius * sin(endAngle);
            path.moveTo(x + xors, y + yors);
            path.arc(x, y, outerRadius, startAngle, endAngle, !clockwise);
            path.lineTo(x + xire, y + yire);
            path.arc(x, y, innerRadius, endAngle, startAngle, clockwise);
            path.closePath();
        }
        return path;
    }
    clone() {
        return new Arc(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Arc.NOWORK_ANIMATE_ATTR;
    }
}
Arc.NOWORK_ANIMATE_ATTR = Object.assign({ cap: 1 }, NOWORK_ANIMATE_ATTR);
function createArc(attributes) {
    return new Arc(attributes);
}

const STAR_UPDATE_TAG_KEY = ['width', 'height', 'spikes', 'thickness', ...GRAPHIC_UPDATE_TAG_KEY];
class Star extends Graphic {
    constructor(params) {
        super(params);
        this.type = 'star';
        this._cachedPoints = [];
        this.numberType = STAR_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const { width, height, spikes } = this.attribute;
        return ((width == null || width > 0) &&
            (height == null || height > 0) &&
            (spikes == null || (spikes >= 3 && Number.isInteger(spikes))));
    }
    getGraphicTheme() {
        return getTheme(this).star;
    }
    updateAABBBounds(attribute, rectTheme, aabbBounds) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
            const { width = 0, height = 0 } = attribute;
            if (isFinite(width) || isFinite(height)) {
                aabbBounds.set(0, 0, width, height);
            }
        }
        const { tb1, tb2 } = application.graphicService.updateTempAABBBounds(aabbBounds);
        aabbBounds.union(tb1);
        tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
        this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1;
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        application.graphicService.transformAABBBounds(attribute, aabbBounds, rectTheme, false, this);
        return aabbBounds;
    }
    getCachedPoints() {
        if (this.shouldUpdateShape()) {
            this._cachedPoints = this.getStarPoints(this.attribute, this.getGraphicTheme());
            this.clearUpdateShapeTag();
        }
        return this._cachedPoints;
    }
    getStarPoints(attribute, starTheme) {
        const { width = starTheme.width, height = starTheme.height, spikes = starTheme.spikes, thickness = starTheme.thickness } = attribute;
        const validSpikes = Math.max(3, Math.floor(spikes));
        const validThickness = Math.max(0, Math.min(1, thickness));
        const points = [];
        const outerRadius = Math.min(width, height) / 2;
        const innerRadius = outerRadius * (1 - validThickness);
        const centerX = width / 2;
        const centerY = height / 2;
        for (let i = 0; i < validSpikes * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = (Math.PI / validSpikes) * i;
            const scaleX = width / (outerRadius * 2);
            const scaleY = height / (outerRadius * 2);
            points.push({
                x: centerX + Math.sin(angle) * radius * scaleX,
                y: centerY - Math.cos(angle) * radius * scaleY
            });
        }
        this._cachedPoints = points;
        return points;
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        if (key === 'width' || key === 'height' || key === 'spikes' || key === 'thickness') {
            nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio;
        }
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, STAR_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, STAR_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        let path = super.toCustomPath();
        if (path) {
            return path;
        }
        const starTheme = this.getGraphicTheme();
        const points = this.getStarPoints(this.attribute, starTheme);
        path = new CustomPath2D();
        points.forEach((point, index) => {
            if (index === 0) {
                path.moveTo(point.x, point.y);
            }
            else {
                path.lineTo(point.x, point.y);
            }
        });
        path.closePath();
        return path;
    }
    clone() {
        return new Star(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Star.NOWORK_ANIMATE_ATTR;
    }
}
Star.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createStar(attributes) {
    return new Star(attributes);
}

class Arc3d extends Arc {
    constructor(params) {
        super(params);
        this.type = 'arc3d';
        this.numberType = ARC3D_NUMBER_TYPE;
    }
    updateAABBBounds(attribute, arcTheme, aabbBounds) {
        const stage = this.stage;
        if (!stage || !stage.camera) {
            return aabbBounds;
        }
        const { outerRadius = arcTheme.outerRadius, height = 0 } = attribute;
        const r = outerRadius + height;
        aabbBounds.setValue(-r, -r, r, r);
        application.graphicService.updateTempAABBBounds(aabbBounds);
        application.graphicService.transformAABBBounds(attribute, aabbBounds, arcTheme, false, this);
        return aabbBounds;
    }
    getNoWorkAnimateAttr() {
        return Arc3d.NOWORK_ANIMATE_ATTR;
    }
}
Arc3d.NOWORK_ANIMATE_ATTR = Object.assign({ cap: 1 }, NOWORK_ANIMATE_ATTR);
function createArc3d(attributes) {
    return new Arc3d(attributes);
}

const POLYGON_UPDATE_TAG_KEY = ['points', 'cornerRadius', ...GRAPHIC_UPDATE_TAG_KEY];
class Polygon extends Graphic {
    constructor(params) {
        super(params);
        this.type = 'polygon';
        this.numberType = POLYGON_NUMBER_TYPE;
    }
    isValid() {
        return super.isValid() && this._isValid();
    }
    _isValid() {
        const { points } = this.attribute;
        return points && points.length >= 2;
    }
    getGraphicTheme() {
        return getTheme(this).polygon;
    }
    updateAABBBounds(attribute, polygonTheme, aabbBounds) {
        if (!this.updatePathProxyAABBBounds(aabbBounds)) {
            this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds);
        }
        application.graphicService.updateTempAABBBounds(aabbBounds);
        this.widthWithoutTransform = aabbBounds.x2 - aabbBounds.x1;
        this.heightWithoutTransform = aabbBounds.y2 - aabbBounds.y1;
        const { lineJoin = polygonTheme.lineJoin } = attribute;
        application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, lineJoin === 'miter', this);
        return aabbBounds;
    }
    updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds) {
        const { points = polygonTheme.points } = attribute;
        points.forEach(p => {
            aabbBounds.add(p.x, p.y);
        });
        return aabbBounds;
    }
    _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
        if (key === 'points') {
            nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio);
        }
    }
    needUpdateTags(keys) {
        return super.needUpdateTags(keys, POLYGON_UPDATE_TAG_KEY);
    }
    needUpdateTag(key) {
        return super.needUpdateTag(key, POLYGON_UPDATE_TAG_KEY);
    }
    toCustomPath() {
        let path = super.toCustomPath();
        if (path) {
            return path;
        }
        const points = this.attribute.points;
        path = new CustomPath2D();
        points.forEach((point, index) => {
            if (index === 0) {
                path.moveTo(point.x, point.y);
            }
            else {
                path.lineTo(point.x, point.y);
            }
        });
        path.closePath();
        return path;
    }
    clone() {
        return new Polygon(Object.assign({}, this.attribute));
    }
    getNoWorkAnimateAttr() {
        return Polygon.NOWORK_ANIMATE_ATTR;
    }
}
Polygon.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createPolygon(attributes) {
    return new Polygon(attributes);
}

class Pyramid3d extends Polygon {
    constructor(params) {
        super(params);
        this.type = 'pyramid3d';
        this.numberType = PYRAMID3D_NUMBER_TYPE;
    }
    updateAABBBounds(attribute, polygonTheme, aabbBounds) {
        const stage = this.stage;
        if (!stage || !stage.camera) {
            return aabbBounds;
        }
        const faces = this.findFace();
        faces.vertices.forEach(v => {
            const x = v[0];
            const y = v[1];
            aabbBounds.add(x, y);
        });
        application.graphicService.updateTempAABBBounds(aabbBounds);
        application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, false, this);
        return aabbBounds;
    }
    findFace() {
        const { points } = this.attribute;
        const kList = points.map((p, i) => {
            const p1 = i === 3 ? points[0] : points[i + 1];
            const dx = p.x - p1.x;
            if (dx === 0) {
                return 0;
            }
            return (p.y - p1.y) / dx;
        });
        const pointsMap = points.map(p => ({ p, d: 0 }));
        let find = false;
        let maxD = 0;
        for (let i = 0; i < kList.length - 1; i++) {
            for (let j = i + 1; j < kList.length; j++) {
                if (kList[i] === kList[j]) {
                    find = true;
                    const d1 = PointService.distancePP(pointsMap[i].p, pointsMap[i + 1].p);
                    pointsMap[i].d = d1;
                    pointsMap[i + 1].d = d1;
                    maxD = max(maxD, d1);
                    const d2 = PointService.distancePP(pointsMap[j].p, pointsMap[j + 1].p);
                    pointsMap[j].d = d2;
                    pointsMap[j + 1].d = d2;
                    maxD = max(maxD, d2);
                }
                if (find) {
                    break;
                }
            }
            if (find) {
                break;
            }
        }
        for (let i = points.length - 1; i >= 0; i--) {
            const p = points[i];
            pointsMap.unshift({
                p,
                d: 0
            });
        }
        for (let i = 0; i < points.length; i++) {
            const delta = (maxD - pointsMap[i + points.length].d) / 2;
            pointsMap[i].d += delta;
            pointsMap[i + points.length].d += delta;
        }
        const faces = { polygons: [], vertices: [], edges: [] };
        pointsMap.forEach(p => {
            faces.vertices.push([p.p.x, p.p.y, p.d]);
        });
        faces.polygons.push({ polygon: [0, 4, 5, 1], normal: [0, -1, 0] });
        faces.polygons.push({ polygon: [7, 6, 2, 3], normal: [0, 1, 0] });
        faces.polygons.push({ polygon: [0, 4, 7, 3], normal: [-1, 0, 0] });
        faces.polygons.push({ polygon: [1, 5, 6, 2], normal: [1, 0, 0] });
        faces.polygons.push({ polygon: [0, 1, 2, 3], normal: [0, 0, -1] });
        faces.polygons.push({ polygon: [4, 5, 6, 7], normal: [0, 0, 1] });
        faces.edges = [
            [0, 1],
            [1, 2],
            [2, 3],
            [3, 0],
            [4, 5],
            [5, 6],
            [6, 7],
            [7, 4],
            [0, 4],
            [3, 7],
            [1, 5],
            [2, 6]
        ];
        return faces;
    }
    _isValid() {
        return super._isValid() && this.attribute.points.length === 4;
    }
    getNoWorkAnimateAttr() {
        return Pyramid3d.NOWORK_ANIMATE_ATTR;
    }
}
Pyramid3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createPyramid3d(attributes) {
    return new Pyramid3d(attributes);
}

class ShadowRoot extends Group {
    constructor(graphic) {
        super({ x: 0, y: 0 });
        this.type = 'shadowroot';
        this.shadowHost = graphic;
    }
    clearUpdateBoundTag() {
        super.clearUpdateBoundTag();
        if (this.shadowHost) {
            this.shadowHost.clearUpdateBoundTag();
        }
    }
    addUpdateBoundTag() {
        super.addUpdateBoundTag();
        if (this.shadowHost) {
            this.shadowHost.addUpdateBoundTag();
        }
    }
    addUpdateShapeAndBoundsTag() {
        super.addUpdateShapeAndBoundsTag();
        if (this.shadowHost) {
            this.shadowHost.addUpdateBoundTag();
        }
    }
    tryUpdateGlobalTransMatrix(clearTag = true) {
        if (this.shouldUpdateGlobalMatrix()) {
            const m = this.transMatrix;
            if (!this._globalTransMatrix) {
                this._globalTransMatrix = m.clone();
            }
            else {
                this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
            }
            this.doUpdateGlobalMatrix();
            clearTag && this.clearUpdateGlobalPositionTag();
        }
        return this._globalTransMatrix;
    }
    doUpdateGlobalMatrix() {
        if (this.shadowHost) {
            const parentMatrix = this.shadowHost.globalTransMatrix;
            this._globalTransMatrix.multiply(parentMatrix.a, parentMatrix.b, parentMatrix.c, parentMatrix.d, parentMatrix.e, parentMatrix.f);
        }
    }
    tryUpdateGlobalAABBBounds() {
        if (!this._globalAABBBounds) {
            this._globalAABBBounds = this._AABBBounds.clone();
        }
        else {
            this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2);
        }
        if (this.shadowHost) {
            this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix);
        }
        return this._globalAABBBounds;
    }
}
function createShadowRoot(graphic) {
    return new ShadowRoot(graphic);
}

class GraphicCreator {
    constructor() {
        this.store = new Map();
    }
    RegisterGraphicCreator(name, cb) {
        this.store.set(name, cb);
        this[name] = cb;
    }
    CreateGraphic(name, params) {
        const cb = this.store.get(name);
        if (!cb) {
            return null;
        }
        return cb(params);
    }
}
const graphicCreator = new GraphicCreator();

let text;
function getTextBounds(params) {
    if (!text) {
        text = graphicCreator.CreateGraphic('text', {});
    }
    text.initAttributes(params);
    return text.AABBBounds;
}
let richText;
function getRichTextBounds(params) {
    if (!richText) {
        richText = graphicCreator.CreateGraphic('richtext', {});
    }
    richText.setAttributes(params);
    return richText.AABBBounds;
}

class DefaultBaseBackgroundRenderContribution {
    constructor() {
        this.time = BaseRenderContributionTime.beforeFillStroke;
        this.useStyle = true;
        this.order = 0;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        var _a;
        const { background, backgroundOpacity = (_a = graphic.attribute.fillOpacity) !== null && _a !== void 0 ? _a : graphicAttribute.backgroundOpacity, opacity = graphicAttribute.opacity, backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit, backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio, backgroundScale = graphicAttribute.backgroundScale, backgroundOffsetX = graphicAttribute.backgroundOffsetX, backgroundOffsetY = graphicAttribute.backgroundOffsetY, backgroundClip = graphicAttribute.backgroundClip } = graphic.attribute;
        if (!background) {
            return;
        }
        if (graphic.backgroundImg && graphic.resources) {
            const res = graphic.resources.get(background);
            if (res.state !== 'success' || !res.data) {
                return;
            }
            context.save();
            if (graphic.parent && !graphic.transMatrix.onlyTranslate()) {
                const groupAttribute = getTheme(graphic.parent).group;
                const { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = graphic.parent.attribute;
                context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);
                context.translate(scrollX, scrollY);
            }
            backgroundClip && context.clip();
            const b = graphic.AABBBounds;
            context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute);
            context.globalAlpha = backgroundOpacity * opacity;
            this.doDrawImage(context, res.data, b, {
                backgroundMode,
                backgroundFit,
                backgroundKeepAspectRatio,
                backgroundScale,
                backgroundOffsetX,
                backgroundOffsetY
            });
            context.restore();
            if (!graphic.transMatrix.onlyTranslate()) {
                context.setTransformForCurrent();
            }
        }
        else {
            context.highPerformanceSave();
            context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute);
            context.globalAlpha = backgroundOpacity * opacity;
            context.fillStyle = background;
            context.fill();
            context.highPerformanceRestore();
        }
    }
    doDrawImage(context, data, b, params) {
        const { backgroundMode, backgroundFit, backgroundKeepAspectRatio, backgroundScale = 1, backgroundOffsetX = 0, backgroundOffsetY = 0 } = params;
        const targetW = b.width();
        const targetH = b.height();
        let w = targetW;
        let h = targetH;
        if (backgroundMode === 'no-repeat') {
            if (backgroundFit) {
                if (!backgroundKeepAspectRatio) {
                    context.drawImage(data, b.x1, b.y1, b.width(), b.height());
                }
                else {
                    const maxScale = Math.max(targetW / data.width, targetH / data.height);
                    context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, data.width * maxScale * backgroundScale, data.height * maxScale * backgroundScale);
                }
            }
            else {
                const resW = data.width * backgroundScale;
                const resH = data.height * backgroundScale;
                context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, resW, resH);
            }
        }
        else {
            if (backgroundFit && backgroundMode !== 'repeat' && (data.width || data.height)) {
                const resW = data.width;
                const resH = data.height;
                if (backgroundMode === 'repeat-x') {
                    const ratio = targetH / resH;
                    w = resW * ratio;
                    h = targetH;
                }
                else if (backgroundMode === 'repeat-y') {
                    const ratio = targetW / resW;
                    h = resH * ratio;
                    w = targetW;
                }
                const dpr = context.dpr;
                const canvas = canvasAllocate.allocate({ width: w, height: h, dpr });
                const ctx = canvas.getContext('2d');
                if (ctx) {
                    ctx.inuse = true;
                    ctx.clearMatrix();
                    ctx.setTransformForCurrent(true);
                    ctx.clearRect(0, 0, w, h);
                    ctx.drawImage(data, 0, 0, w, h);
                    data = canvas.nativeCanvas;
                }
                canvasAllocate.free(canvas);
            }
            const dpr = context.dpr;
            const pattern = context.createPattern(data, backgroundMode);
            pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0]));
            context.fillStyle = pattern;
            context.translate(b.x1, b.y1);
            context.fillRect(0, 0, targetW, targetH);
            context.translate(-b.x1, -b.y1);
        }
    }
}
const defaultBaseBackgroundRenderContribution = new DefaultBaseBackgroundRenderContribution();
let DefaultBaseInteractiveRenderContribution = class DefaultBaseInteractiveRenderContribution {
    constructor(subRenderContribitions) {
        this.subRenderContribitions = subRenderContribitions;
        this.time = BaseRenderContributionTime.afterFillStroke;
        this.useStyle = true;
        this.order = 0;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        if (!this._subRenderContribitions) {
            this._subRenderContribitions = this.subRenderContribitions.getContributions();
        }
        this._subRenderContribitions.forEach(c => {
            c.render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options);
        });
    }
};
DefaultBaseInteractiveRenderContribution = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(InteractiveSubRenderContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultBaseInteractiveRenderContribution);
class DefaultBaseClipRenderBeforeContribution {
    constructor() {
        this.time = BaseRenderContributionTime.beforeFillStroke;
        this.useStyle = true;
        this.order = 0;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        var _a, _b;
        const { clipConfig } = graphic.attribute;
        if (!clipConfig) {
            return;
        }
        const clipPath = graphic.getClipPath();
        if (!clipPath) {
            return;
        }
        const draw = !(fillCb || strokeCb);
        const b = graphic.AABBBounds;
        const width = (_a = graphic.attribute.width) !== null && _a !== void 0 ? _a : b.width();
        const height = (_b = graphic.attribute.height) !== null && _b !== void 0 ? _b : b.height();
        if (draw) {
            context.save();
        }
        context.beginPath();
        if (clipPath.draw(context, [width, height], x + width / 2, y + height / 2, 0) === false) {
            context.closePath();
        }
        if (fillCb) {
            fillCb(context, graphic.attribute, graphicAttribute, true);
        }
        if (draw) {
            context.clip();
        }
    }
}
const defaultBaseClipRenderBeforeContribution = new DefaultBaseClipRenderBeforeContribution();
class DefaultBaseClipRenderAfterContribution {
    constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke;
        this.useStyle = true;
        this.order = 0;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        const { clipConfig } = graphic.attribute;
        if (!clipConfig) {
            return;
        }
        const clipPath = graphic.getClipPath();
        if (!clipPath) {
            return;
        }
        if (!(fillCb || strokeCb)) {
            context.restore();
        }
    }
}
const defaultBaseClipRenderAfterContribution = new DefaultBaseClipRenderAfterContribution();

function formatRatio(ratio) {
    if (ratio <= 0.5) {
        return ratio * 4 - 1;
    }
    return -4 * ratio + 3;
}
function drawWave(ctx, ratio, boundsWidth, boundsHeight, textureOptions, offsetX, offsetY) {
    const { fill = 'orange', percent = 0.6, frequency = 4, opacity, phi = 0 } = textureOptions;
    let { amplitude = 10 } = textureOptions;
    amplitude = amplitude * formatRatio(ratio);
    const height = boundsHeight * (1 - percent);
    const width = boundsWidth;
    const step = Math.max(Math.round(width / 70), 2);
    ctx.beginPath();
    ctx.moveTo(0 + offsetX, boundsHeight + offsetY);
    ctx.lineTo(0 + offsetX, height + offsetY);
    const delta = (width / frequency) * ratio;
    const c = width / Math.PI / (frequency * 2);
    for (let i = 0; i < width; i += step) {
        const y = amplitude * Math.sin((i + delta + phi) / c + phi);
        ctx.lineTo(i + offsetX, height + y + offsetY);
    }
    ctx.lineTo(width + offsetX, boundsHeight + offsetY);
    ctx.closePath();
    ctx.fillStyle = fill;
    if (isFinite(opacity)) {
        ctx.globalAlpha = opacity;
    }
    ctx.fill();
}
class DefaultBaseTextureRenderContribution {
    constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke;
        this.useStyle = true;
        this.order = 10;
        this._tempSymbolGraphic = null;
    }
    createCommonPattern(size, padding, color, targetContext, cb) {
        const r = (size - padding * 2) / 2;
        const dpr = targetContext.dpr;
        const canvas = canvasAllocate.allocate({ width: size, height: size, dpr });
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            return null;
        }
        ctx.inuse = true;
        ctx.clearMatrix();
        ctx.setTransformForCurrent(true);
        ctx.clearRect(0, 0, size, size);
        cb(r, ctx);
        const pattern = targetContext.createPattern(canvas.nativeCanvas, 'repeat');
        pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0]));
        canvasAllocate.free(canvas);
        return pattern;
    }
    createCirclePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
            ctx.fillStyle = color;
            ctx.arc(r, r, r, 0, pi2);
            ctx.fill();
        });
    }
    createDiamondPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
            const x = size / 2;
            const y = x;
            ctx.fillStyle = color;
            ctx.moveTo(x, y - r);
            ctx.lineTo(r + x, y);
            ctx.lineTo(x, y + r);
            ctx.lineTo(x - r, y);
            ctx.closePath();
            ctx.fill();
        });
    }
    createRectPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
            const x = padding;
            const y = x;
            ctx.fillStyle = color;
            ctx.fillRect(x, y, r * 2, r * 2);
        });
    }
    createVerticalLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
            const x = padding;
            const y = 0;
            ctx.fillStyle = color;
            ctx.fillRect(x, y, r * 2, size);
        });
    }
    createHorizontalLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
            const x = 0;
            const y = padding;
            ctx.fillStyle = color;
            ctx.fillRect(x, y, size, r * 2);
        });
    }
    createBiasLRLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
            ctx.strokeStyle = color;
            ctx.lineWidth = r;
            ctx.moveTo(0, 0);
            ctx.lineTo(size, size);
            const dx = size / 2;
            const dy = -dx;
            ctx.moveTo(dx, dy);
            ctx.lineTo(dx + size, dy + size);
            ctx.moveTo(-dx, -dy);
            ctx.lineTo(-dx + size, -dy + size);
            ctx.stroke();
        });
    }
    createBiasRLLinePattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
            ctx.strokeStyle = color;
            ctx.lineWidth = r;
            ctx.moveTo(size, 0);
            ctx.lineTo(0, size);
            const dx = size / 2;
            const dy = dx;
            ctx.moveTo(size + dx, dy);
            ctx.lineTo(dx, dy + size);
            ctx.moveTo(size - dx, -dy);
            ctx.lineTo(-dx, -dy + size);
            ctx.stroke();
        });
    }
    createGridPattern(size, padding, color, targetContext) {
        return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
            const x = padding;
            const y = x;
            ctx.fillStyle = color;
            ctx.fillRect(x, y, r, r);
            ctx.fillRect(x + r, y + r, r, r);
        });
    }
    initTextureMap(ctx, stage) {
        this.textureMap = new Map();
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        if (!this.textureMap) {
            this.initTextureMap(context, graphic.stage);
        }
        const { texture = graphicAttribute.texture, textureColor = graphicAttribute.textureColor, textureSize = graphicAttribute.textureSize, texturePadding = graphicAttribute.texturePadding } = graphic.attribute;
        if (!texture) {
            return;
        }
        this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
    }
    drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding) {
        var _a;
        const { textureRatio = graphicAttribute.textureRatio, textureOptions = null } = graphic.attribute;
        let pattern = this.textureMap.get(texture);
        if (!pattern) {
            switch (texture) {
                case 'circle':
                    pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
                    break;
                case 'diamond':
                    pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
                    break;
                case 'rect':
                    pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
                    break;
                case 'vertical-line':
                    pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
                    break;
                case 'horizontal-line':
                    pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
                    break;
                case 'bias-lr':
                    pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
                    break;
                case 'bias-rl':
                    pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
                    break;
                case 'grid':
                    pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
                    break;
            }
        }
        if (textureOptions && textureOptions.dynamicTexture) {
            const { gridConfig = {}, useNewCanvas } = textureOptions;
            const b = graphic.AABBBounds;
            x = b.x1;
            y = b.y1;
            const originalContext = context;
            let newCanvas;
            if (useNewCanvas) {
                newCanvas = canvasAllocate.allocate({ width: b.width(), height: b.height(), dpr: context.dpr });
                const ctx = newCanvas.getContext('2d');
                ctx.clearRect(0, 0, b.width(), b.height());
                x = 0;
                y = 0;
                context = ctx;
            }
            originalContext.save();
            if (graphic.parent && !graphic.transMatrix.onlyTranslate()) {
                const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
                originalContext.setTransformFromMatrix(graphic.parent.globalTransMatrix);
                originalContext.translate(scrollX, scrollY, true);
            }
            originalContext.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute);
            originalContext.clip();
            const width = b.width();
            const height = b.height();
            const padding = texturePadding;
            const cellSize = textureSize;
            const gridColumns = gridConfig.columns ? gridConfig.columns : Math.ceil(width / cellSize);
            const gridRows = gridConfig.rows ? gridConfig.rows : Math.ceil(height / cellSize);
            const gutterColumn = gridConfig.gutterColumn ? gridConfig.gutterColumn : padding * 2;
            const gutterRow = gridConfig.gutterRow ? gridConfig.gutterRow : padding * 2;
            if (!this._tempSymbolGraphic) {
                this._tempSymbolGraphic = createSymbol({});
            }
            const sizeW = gridConfig.columns ? width / gridConfig.columns : cellSize;
            const sizeH = gridConfig.rows ? height / gridConfig.rows : cellSize;
            this._tempSymbolGraphic.setAttributes({
                size: [sizeW - gutterColumn, sizeH - gutterRow],
                symbolType: texture
            });
            const parsedPath = this._tempSymbolGraphic.getParsedPath();
            for (let i = 0; i < gridRows; i++) {
                for (let j = 0; j < gridColumns; j++) {
                    const _x = x + cellSize / 2 + j * cellSize;
                    const _y = y + cellSize / 2 + i * cellSize;
                    (_a = textureOptions.beforeDynamicTexture) === null || _a === void 0 ? void 0 : _a.call(textureOptions, context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height());
                    context.beginPath();
                    if (parsedPath.draw(context, Math.min(sizeW - gutterColumn, sizeH - gutterRow), _x, _y, 0) === false) {
                        context.closePath();
                    }
                    context.fillStyle = textureColor;
                    textureOptions.dynamicTexture(context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height());
                }
            }
            if (useNewCanvas) {
                originalContext.globalAlpha = 1;
                originalContext.drawImage(newCanvas.nativeCanvas, 0, 0, newCanvas.nativeCanvas.width, newCanvas.nativeCanvas.height, b.x1, b.y1, b.width() * originalContext.dpr, b.height() * originalContext.dpr);
            }
            originalContext.restore();
        }
        else if (pattern) {
            context.highPerformanceSave();
            context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute);
            context.fillStyle = pattern;
            context.fill();
            context.highPerformanceRestore();
        }
        else if (texture === 'wave') {
            context.save();
            context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute);
            context.clip();
            const b = graphic.AABBBounds;
            drawWave(context, textureRatio, b.width(), b.height(), Object.assign(Object.assign({}, (textureOptions || {})), { fill: textureColor }), x + b.x1 - x, y + b.y1 - y);
            context.restore();
        }
    }
}
const defaultBaseTextureRenderContribution = new DefaultBaseTextureRenderContribution();

class DefaultArcRenderContribution {
    constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke;
        this.useStyle = true;
        this.order = 0;
    }
    drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb) {
        const { outerBorder, innerBorder } = arc.attribute;
        const doOuterBorder = outerBorder && outerBorder.visible !== false;
        const doInnerBorder = innerBorder && innerBorder.visible !== false;
        if (!(doOuterBorder || doInnerBorder)) {
            return;
        }
        const { innerPadding = arcAttribute.innerPadding, outerPadding = arcAttribute.outerPadding, startAngle = arcAttribute.startAngle, endAngle = arcAttribute.endAngle, opacity = arcAttribute.opacity, x: originX = arcAttribute.x, y: originY = arcAttribute.y, scaleX = arcAttribute.scaleX, scaleY = arcAttribute.scaleY, keepStrokeScale = arcAttribute.keepStrokeScale } = arc.attribute;
        let { innerRadius = arcAttribute.innerRadius, outerRadius = arcAttribute.outerRadius } = arc.attribute;
        outerRadius += outerPadding;
        innerRadius -= innerPadding;
        const renderBorder = (borderStyle, key) => {
            const doStroke = !!(borderStyle && borderStyle.stroke);
            const { distance = arcAttribute[key].distance } = borderStyle;
            const d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr);
            const deltaAngle = distance / outerRadius;
            const sign = key === 'outerBorder' ? 1 : -1;
            arc.setAttributes({
                outerRadius: outerRadius + sign * d,
                innerRadius: innerRadius - sign * d,
                startAngle: startAngle - sign * deltaAngle,
                endAngle: endAngle + sign * deltaAngle
            });
            context.beginPath();
            drawArcPath$1(arc, context, x, y, outerRadius + sign * d, innerRadius - sign * d);
            context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute);
            if (strokeCb) {
                strokeCb(context, borderStyle, arcAttribute[key]);
            }
            else if (doStroke) {
                const lastOpacity = arcAttribute[key].opacity;
                arcAttribute[key].opacity = opacity;
                context.setStrokeStyle(arc, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, arcAttribute[key]);
                arcAttribute[key].opacity = lastOpacity;
                context.stroke();
            }
        };
        doOuterBorder && renderBorder(outerBorder, 'outerBorder');
        doInnerBorder && renderBorder(innerBorder, 'innerBorder');
        arc.setAttributes({ outerRadius: outerRadius, innerRadius: innerRadius, startAngle, endAngle });
    }
}
const defaultArcRenderContribution = new DefaultArcRenderContribution();
const defaultArcTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultArcBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultCircleRenderContribution {
    constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke;
        this.useStyle = true;
        this.order = 0;
    }
    drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb) {
        const { outerBorder, innerBorder } = circle.attribute;
        const doOuterBorder = outerBorder && outerBorder.visible !== false;
        const doInnerBorder = innerBorder && innerBorder.visible !== false;
        if (!(doOuterBorder || doInnerBorder)) {
            return;
        }
        const { radius = circleAttribute.radius, startAngle = circleAttribute.startAngle, endAngle = circleAttribute.endAngle, opacity = circleAttribute.opacity, x: originX = circleAttribute.x, y: originY = circleAttribute.y, scaleX = circleAttribute.scaleX, scaleY = circleAttribute.scaleY, keepStrokeScale = circleAttribute.keepStrokeScale } = circle.attribute;
        const renderBorder = (borderStyle, key) => {
            const doStroke = !!(borderStyle && borderStyle.stroke);
            const { distance = circleAttribute[key].distance } = borderStyle;
            const d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr);
            const sign = key === 'outerBorder' ? 1 : -1;
            context.beginPath();
            context.arc(x, y, radius + sign * d, startAngle, endAngle);
            context.closePath();
            context.setShadowBlendStyle && context.setShadowBlendStyle(circle, circle.attribute, circleAttribute);
            if (strokeCb) {
                strokeCb(context, borderStyle, circleAttribute[key]);
            }
            else if (doStroke) {
                const lastOpacity = circleAttribute[key].opacity;
                circleAttribute[key].opacity = opacity;
                context.setStrokeStyle(circle, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, circleAttribute[key]);
                circleAttribute[key].opacity = lastOpacity;
                context.stroke();
            }
        };
        doOuterBorder && renderBorder(outerBorder, 'outerBorder');
        doInnerBorder && renderBorder(innerBorder, 'innerBorder');
    }
}
const defaultCircleRenderContribution = new DefaultCircleRenderContribution();
const defaultCircleTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultCircleBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultGroupBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments);
        this.time = BaseRenderContributionTime.beforeFillStroke;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
        const { background, backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit, backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio, backgroundScale = graphicAttribute.backgroundScale, backgroundOffsetX = graphicAttribute.backgroundOffsetX, backgroundOffsetY = graphicAttribute.backgroundOffsetY } = graphic.attribute;
        if (!background) {
            return;
        }
        if (graphic.backgroundImg && graphic.resources) {
            const res = graphic.resources.get(background);
            if (res.state !== 'success' || !res.data) {
                return;
            }
            context.highPerformanceSave();
            context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);
            const b = graphic.AABBBounds;
            this.doDrawImage(context, res.data, b, {
                backgroundMode,
                backgroundFit,
                backgroundKeepAspectRatio,
                backgroundScale,
                backgroundOffsetX,
                backgroundOffsetY
            });
            context.highPerformanceRestore();
            context.setTransformForCurrent();
        }
        else {
            context.highPerformanceSave();
            context.fillStyle = background;
            context.fill();
            context.highPerformanceRestore();
        }
    }
}
const defaultGroupBackgroundRenderContribution = new DefaultGroupBackgroundRenderContribution();

const halfPi = pi / 2;
function createRectPath(path, x, y, width, height, rectCornerRadius, roundCorner = true, edgeCb) {
    if (Array.isArray(roundCorner)) {
        edgeCb = roundCorner;
        roundCorner = true;
    }
    if (width < 0) {
        x += width;
        width = -width;
    }
    if (height < 0) {
        y += height;
        height = -height;
    }
    let cornerRadius;
    if (isNumber$1(rectCornerRadius, true)) {
        rectCornerRadius = abs(rectCornerRadius);
        cornerRadius = [
            rectCornerRadius,
            rectCornerRadius,
            rectCornerRadius,
            rectCornerRadius
        ];
    }
    else if (Array.isArray(rectCornerRadius)) {
        const cornerRadiusArr = rectCornerRadius;
        let cr0;
        let cr1;
        switch (cornerRadiusArr.length) {
            case 0:
                cornerRadius = [0, 0, 0, 0];
                break;
            case 1:
                cr0 = abs(cornerRadiusArr[0]);
                cornerRadius = [cr0, cr0, cr0, cr0];
                break;
            case 2:
            case 3:
                cr0 = abs(cornerRadiusArr[0]);
                cr1 = abs(cornerRadiusArr[1]);
                cornerRadius = [cr0, cr1, cr0, cr1];
                break;
            default:
                cornerRadius = cornerRadiusArr;
                cornerRadius[0] = abs(cornerRadius[0]);
                cornerRadius[1] = abs(cornerRadius[1]);
                cornerRadius[2] = abs(cornerRadius[2]);
                cornerRadius[3] = abs(cornerRadius[3]);
                break;
        }
    }
    else {
        cornerRadius = [0, 0, 0, 0];
    }
    if (width < 0 || cornerRadius[0] + cornerRadius[1] + cornerRadius[2] + cornerRadius[3] < 1e-12) {
        return path.rect(x, y, width, height);
    }
    const [leftTop, rightTop, rightBottom, leftBottom] = [
        [x, y],
        [x + width, y],
        [x + width, y + height],
        [x, y + height]
    ];
    const maxCornerRadius = Math.min(width / 2, height / 2);
    const _cornerRadius = [
        Math.min(maxCornerRadius, cornerRadius[0]),
        Math.min(maxCornerRadius, cornerRadius[1]),
        Math.min(maxCornerRadius, cornerRadius[2]),
        Math.min(maxCornerRadius, cornerRadius[3])
    ];
    const leftTopPoint1 = [leftTop[0] + _cornerRadius[0], leftTop[1]];
    const leftTopPoint2 = [leftTop[0], leftTop[1] + _cornerRadius[0]];
    const rightTopPoint1 = [rightTop[0] - _cornerRadius[1], rightTop[1]];
    const rightTopPoint2 = [rightTop[0], rightTop[1] + _cornerRadius[1]];
    const rightBottomPoint1 = [rightBottom[0] - _cornerRadius[2], rightBottom[1]];
    const rightBottomPoint2 = [rightBottom[0], rightBottom[1] - _cornerRadius[2]];
    const leftBottomPoint1 = [leftBottom[0] + _cornerRadius[3], leftBottom[1]];
    const leftBottomPoint2 = [leftBottom[0], leftBottom[1] - _cornerRadius[3]];
    path.moveTo(leftTopPoint1[0], leftTopPoint1[1]);
    if (!roundCorner) {
        edgeCb && edgeCb[0]
            ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1])
            : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]);
        edgeCb && edgeCb[1]
            ? edgeCb[1](rightTopPoint1[0], rightTopPoint1[1], rightBottomPoint1[0], rightBottomPoint1[1])
            : path.lineTo(rightBottomPoint1[0], rightBottomPoint1[1]);
        edgeCb && edgeCb[2]
            ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1])
            : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]);
        edgeCb && edgeCb[2]
            ? edgeCb[2](leftBottomPoint1[0], leftBottomPoint1[1], leftTopPoint1[0], leftTopPoint1[1])
            : path.lineTo(leftTopPoint1[0], leftTopPoint1[1]);
    }
    else {
        edgeCb && edgeCb[0]
            ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1])
            : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]);
        if (!arrayEqual(rightTopPoint1, rightTopPoint2)) {
            edgeCb && edgeCb[0] && path.moveTo(rightTopPoint1[0], rightTopPoint1[1]);
            const centerX = rightTopPoint1[0];
            const centerY = rightTopPoint1[1] + _cornerRadius[1];
            path.arc(centerX, centerY, _cornerRadius[1], -halfPi, 0, false);
        }
        edgeCb && edgeCb[1]
            ? edgeCb[1](rightTopPoint2[0], rightTopPoint2[1], rightBottomPoint2[0], rightBottomPoint2[1])
            : path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]);
        if (!arrayEqual(rightBottomPoint1, rightBottomPoint2)) {
            const centerX = rightBottomPoint2[0] - _cornerRadius[2];
            const centerY = rightBottomPoint2[1];
            edgeCb && edgeCb[1] && path.moveTo(rightBottomPoint2[0], rightBottomPoint2[1]);
            path.arc(centerX, centerY, _cornerRadius[2], 0, halfPi, false);
        }
        edgeCb && edgeCb[2]
            ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1])
            : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]);
        if (!arrayEqual(leftBottomPoint1, leftBottomPoint2)) {
            const centerX = leftBottomPoint1[0];
            const centerY = leftBottomPoint1[1] - _cornerRadius[3];
            edgeCb && edgeCb[2] && path.moveTo(leftBottomPoint1[0], leftBottomPoint1[1]);
            path.arc(centerX, centerY, _cornerRadius[3], halfPi, pi, false);
        }
        edgeCb && edgeCb[3]
            ? edgeCb[3](leftBottomPoint2[0], leftBottomPoint2[1], leftTopPoint2[0], leftTopPoint2[1])
            : path.lineTo(leftTopPoint2[0], leftTopPoint2[1]);
        if (!arrayEqual(leftTopPoint1, leftTopPoint2)) {
            const centerX = leftTopPoint1[0];
            const centerY = leftTopPoint1[1] + _cornerRadius[0];
            edgeCb && edgeCb[3] && path.moveTo(leftTopPoint2[0], leftTopPoint2[1]);
            path.arc(centerX, centerY, _cornerRadius[0], pi, pi + halfPi, false);
        }
    }
    !edgeCb && path.closePath();
    return path;
}

class DefaultRectRenderContribution {
    constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke;
        this.useStyle = true;
        this.order = 0;
    }
    drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
        const { outerBorder, innerBorder } = rect.attribute;
        const doOuterBorder = outerBorder && outerBorder.visible !== false;
        const doInnerBorder = innerBorder && innerBorder.visible !== false;
        if (!(doOuterBorder || doInnerBorder)) {
            return;
        }
        const { cornerRadius = rectAttribute.cornerRadius, cornerType = rectAttribute.cornerType, opacity = rectAttribute.opacity, x: originX = rectAttribute.x, y: originY = rectAttribute.y, scaleX = rectAttribute.scaleX, scaleY = rectAttribute.scaleY, x1, y1, keepStrokeScale = rectAttribute.keepStrokeScale } = rect.attribute;
        let { width, height } = rect.attribute;
        width = (width !== null && width !== void 0 ? width : x1 - x) || 0;
        height = (height !== null && height !== void 0 ? height : y1 - y) || 0;
        const renderBorder = (borderStyle, key) => {
            const doStroke = !!(borderStyle && borderStyle.stroke);
            const sign = key === 'outerBorder' ? -1 : 1;
            const { distance = rectAttribute[key].distance } = borderStyle;
            const d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr);
            const nextX = x + sign * d;
            const nextY = y + sign * d;
            const dw = d * 2;
            if (cornerRadius === 0 || (isArray(cornerRadius) && cornerRadius.every(num => num === 0))) {
                context.beginPath();
                context.rect(nextX, nextY, width - sign * dw, height - sign * dw);
            }
            else {
                context.beginPath();
                createRectPath(context, nextX, nextY, width - sign * dw, height - sign * dw, cornerRadius, cornerType !== 'bevel');
            }
            context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute);
            if (strokeCb) {
                strokeCb(context, borderStyle, rectAttribute[key]);
            }
            else if (doStroke) {
                const lastOpacity = rectAttribute[key].opacity;
                rectAttribute[key].opacity = opacity;
                context.setStrokeStyle(rect, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, rectAttribute[key]);
                rectAttribute[key].opacity = lastOpacity;
                context.stroke();
            }
        };
        doOuterBorder && renderBorder(outerBorder, 'outerBorder');
        doInnerBorder && renderBorder(innerBorder, 'innerBorder');
    }
}
let SplitRectBeforeRenderContribution = class SplitRectBeforeRenderContribution {
    constructor() {
        this.time = BaseRenderContributionTime.beforeFillStroke;
        this.useStyle = true;
        this.order = 0;
    }
    drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
        const { stroke = groupAttribute.stroke } = group.attribute;
        if (Array.isArray(stroke) && stroke.some(s => s === false)) {
            doFillOrStroke.doStroke = false;
        }
    }
};
SplitRectBeforeRenderContribution = __decorate([
    injectable()
], SplitRectBeforeRenderContribution);
let SplitRectAfterRenderContribution = class SplitRectAfterRenderContribution {
    constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke;
        this.useStyle = true;
        this.order = 0;
    }
    drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
        const { x1, y1, x: originX = groupAttribute.x, y: originY = groupAttribute.y, stroke = groupAttribute.stroke, cornerRadius = groupAttribute.cornerRadius, cornerType = groupAttribute.cornerType } = rect.attribute;
        let { width, height } = rect.attribute;
        width = (width !== null && width !== void 0 ? width : x1 - originX) || 0;
        height = (height !== null && height !== void 0 ? height : y1 - originY) || 0;
        if (!(Array.isArray(stroke) && stroke.some(s => s === false))) {
            return;
        }
        context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute);
        if (!(cornerRadius === 0 || (isArray(cornerRadius) && cornerRadius.every(num => num === 0)))) {
            let lastStrokeI = 0;
            let lastStroke;
            createRectPath(context, x, y, width, height, cornerRadius, cornerType !== 'bevel', new Array(4).fill(0).map((_, i) => (x1, y1, x2, y2) => {
                if (stroke[i]) {
                    if (!(lastStrokeI === i - 1 && stroke[i] === lastStroke)) {
                        context.setStrokeStyle(rect, Object.assign(Object.assign({}, rect.attribute), { stroke: stroke[i] }), x, y, groupAttribute);
                        context.beginPath();
                        context.moveTo(x1, y1);
                        lastStroke = stroke[i];
                    }
                    lastStrokeI = i;
                    context.lineTo(x2, y2);
                    context.stroke();
                    if (i === 3) {
                        context.beginPath();
                    }
                }
            }));
            context.stroke();
            return;
        }
        context.beginPath();
        context.moveTo(x, y);
        if (stroke[0]) {
            context.lineTo(x + width, y);
        }
        else {
            context.moveTo(x + width, y);
        }
        if (stroke[1]) {
            context.lineTo(x + width, y + height);
        }
        else {
            context.moveTo(x + width, y + height);
        }
        if (stroke[2]) {
            context.lineTo(x, y + height);
        }
        else {
            context.moveTo(x, y + height);
        }
        if (stroke[3]) {
            const adjustY = stroke[0] ? y - context.lineWidth / 2 : y;
            context.lineTo(x, adjustY);
        }
        else {
            context.moveTo(x, y);
        }
        context.stroke();
    }
};
SplitRectAfterRenderContribution = __decorate([
    injectable()
], SplitRectAfterRenderContribution);
const defaultRectRenderContribution = new DefaultRectRenderContribution();
const defaultRectTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultRectBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultImageRenderContribution extends DefaultRectRenderContribution {
    constructor() {
        super(...arguments);
        this.time = BaseRenderContributionTime.afterFillStroke;
        this.useStyle = true;
        this.order = 0;
    }
    drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
        return super.drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
    }
}
const defaultImageRenderContribution = new DefaultImageRenderContribution();
const defaultImageBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultSymbolRenderContribution {
    constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke;
        this.useStyle = true;
        this.order = 0;
    }
    drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb) {
        const parsedPath = symbol.getParsedPath();
        if (!parsedPath) {
            return;
        }
        const { outerBorder, innerBorder } = symbol.attribute;
        const doOuterBorder = outerBorder && outerBorder.visible !== false;
        const doInnerBorder = innerBorder && innerBorder.visible !== false;
        if (!(doOuterBorder || doInnerBorder)) {
            return;
        }
        const { size = symbolAttribute.size, opacity = symbolAttribute.opacity, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX = symbolAttribute.scaleX, scaleY = symbolAttribute.scaleY, keepStrokeScale = symbolAttribute.keepStrokeScale } = symbol.attribute;
        const renderBorder = (borderStyle, key) => {
            const doStroke = !!(borderStyle && borderStyle.stroke);
            const { distance = symbolAttribute[key].distance } = borderStyle;
            const d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr);
            const sign = key === 'outerBorder' ? 1 : -1;
            context.beginPath();
            if (parsedPath.drawOffset(context, size, x, y, sign * d) === false) {
                context.closePath();
            }
            context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute);
            if (strokeCb) {
                strokeCb(context, borderStyle, symbolAttribute[key]);
            }
            else if (doStroke) {
                const lastOpacity = symbolAttribute[key].opacity;
                symbolAttribute[key].opacity = opacity;
                context.setStrokeStyle(symbol, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute[key]);
                symbolAttribute[key].opacity = lastOpacity;
                context.stroke();
            }
        };
        doOuterBorder && renderBorder(outerBorder, 'outerBorder');
        doInnerBorder && renderBorder(innerBorder, 'innerBorder');
    }
}
class DefaultSymbolClipRangeStrokeRenderContribution {
    constructor() {
        this.time = BaseRenderContributionTime.afterFillStroke;
        this.useStyle = true;
        this.order = 0;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        const { clipRange = graphicAttribute.clipRange, x: originX = graphicAttribute.x, y: originY = graphicAttribute.y, z = graphicAttribute.z, size = graphicAttribute.size, scaleX = graphicAttribute.scaleX, scaleY = graphicAttribute.scaleY } = graphic.attribute;
        const parsedPath = graphic.getParsedPath();
        if (!(parsedPath && clipRange < 1 && clipRange > 0)) {
            return;
        }
        const callback = (p, a) => {
            var _a, _b, _c, _d;
            if (graphic._parsedPath.svgCache) {
                const obj = Object.assign({}, a);
                obj.fill = (_a = a.fill) !== null && _a !== void 0 ? _a : graphic.attribute.fill;
                obj.opacity = (_b = a.opacity) !== null && _b !== void 0 ? _b : graphic.attribute.opacity;
                obj.fillOpacity = graphic.attribute.fillOpacity;
                obj.stroke = (_c = a.stroke) !== null && _c !== void 0 ? _c : graphic.attribute.stroke;
                obj.lineWidth = (_d = a.lineWidth) !== null && _d !== void 0 ? _d : graphic.attribute.lineWidth;
                a = obj;
            }
            if (a.stroke) {
                if (strokeCb) {
                    strokeCb(context, graphic.attribute, graphicAttribute);
                }
                else if (sVisible) {
                    context.setStrokeStyle(graphic, a, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute);
                    context.stroke();
                }
            }
        };
        context.beginPath();
        parsedPath.drawWithClipRange && parsedPath.drawWithClipRange(context, size, x, y, clipRange, z, callback);
        if (doStroke && !parsedPath.isSvg) {
            if (strokeCb) {
                strokeCb(context, graphic.attribute, graphicAttribute);
            }
            else if (sVisible) {
                context.setStrokeStyle(graphic, graphic.attribute, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute);
                context.stroke();
            }
        }
    }
}
const defaultSymbolRenderContribution = new DefaultSymbolRenderContribution();
const defaultSymbolClipRangeStrokeRenderContribution = new DefaultSymbolClipRangeStrokeRenderContribution();
const defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultSymbolBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

const defaultStarTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultStarBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultAreaTextureRenderContribution extends DefaultBaseTextureRenderContribution {
    constructor() {
        super(...arguments);
        this.time = BaseRenderContributionTime.afterFillStroke;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
        var _a, _b, _c, _d;
        if (!this.textureMap) {
            this.initTextureMap(context, graphic.stage);
        }
        const { attribute = graphic.attribute } = options || {};
        const { texture = (_a = graphic.attribute.texture) !== null && _a !== void 0 ? _a : getAttributeFromDefaultAttrList(graphicAttribute, 'texture'), textureColor = (_b = graphic.attribute.textureColor) !== null && _b !== void 0 ? _b : getAttributeFromDefaultAttrList(graphicAttribute, 'textureColor'), textureSize = (_c = graphic.attribute.textureSize) !== null && _c !== void 0 ? _c : getAttributeFromDefaultAttrList(graphicAttribute, 'textureSize'), texturePadding = (_d = graphic.attribute.texturePadding) !== null && _d !== void 0 ? _d : getAttributeFromDefaultAttrList(graphicAttribute, 'texturePadding') } = attribute;
        if (!texture) {
            return;
        }
        this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
    }
}

const result = { x: 0, y: 0, z: 0, lastModelMatrix: null };
class BaseRender {
    init(contributions) {
        if (contributions) {
            this._renderContribitions = contributions.getContributions();
        }
        if (!this._renderContribitions) {
            this._renderContribitions = [];
        }
        if (!this.builtinContributions) {
            this.builtinContributions = [];
        }
        this.builtinContributions.push(defaultBaseClipRenderBeforeContribution);
        this.builtinContributions.push(defaultBaseClipRenderAfterContribution);
        this.builtinContributions.forEach(item => this._renderContribitions.push(item));
        if (this._renderContribitions.length) {
            this._renderContribitions.sort((a, b) => b.order - a.order);
            this._beforeRenderContribitions = this._renderContribitions.filter(c => c.time === BaseRenderContributionTime.beforeFillStroke);
            this._afterRenderContribitions = this._renderContribitions.filter(c => c.time === BaseRenderContributionTime.afterFillStroke);
        }
    }
    reInit() {
        this.init(this.graphicRenderContributions);
    }
    beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params) {
        this._beforeRenderContribitions &&
            this._beforeRenderContribitions.forEach(c => {
                if (c.supportedAppName &&
                    graphic.stage &&
                    graphic.stage.params &&
                    graphic.stage.params.context &&
                    graphic.stage.params.context.appName) {
                    const names = Array.isArray(c.supportedAppName) ? c.supportedAppName : [c.supportedAppName];
                    if (!names.includes(graphic.stage.params.context.appName)) {
                        return;
                    }
                }
                c.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params);
            });
    }
    afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params) {
        this._afterRenderContribitions &&
            this._afterRenderContribitions.forEach(c => {
                if (c.supportedAppName &&
                    graphic.stage &&
                    graphic.stage.params &&
                    graphic.stage.params.context &&
                    graphic.stage.params.context.appName) {
                    const names = Array.isArray(c.supportedAppName) ? c.supportedAppName : [c.supportedAppName];
                    if (!names.includes(graphic.stage.params.context.appName)) {
                        return;
                    }
                }
                c.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params);
            });
    }
    drawPathProxy(graphic, context, x, y, drawContext, params, fillCb, strokeCb) {
        if (!graphic.pathProxy) {
            return false;
        }
        const themeAttributes = getTheme(graphic, params === null || params === void 0 ? void 0 : params.theme)[graphic.type.replace('3d', '')];
        const { fill = themeAttributes.fill, stroke = themeAttributes.stroke, opacity = themeAttributes.opacity, fillOpacity = themeAttributes.fillOpacity, lineWidth = themeAttributes.lineWidth, strokeOpacity = themeAttributes.strokeOpacity, visible = themeAttributes.visible, x: originX = themeAttributes.x, y: originY = themeAttributes.y } = graphic.attribute;
        const fVisible = fillVisible(opacity, fillOpacity, fill);
        const sVisible = strokeVisible(opacity, strokeOpacity);
        const doFill = runFill(fill);
        const doStroke = runStroke(stroke, lineWidth);
        if (!visible) {
            return true;
        }
        if (!(doFill || doStroke)) {
            return true;
        }
        if (!(fVisible || sVisible || fillCb || strokeCb)) {
            return true;
        }
        context.beginPath();
        const path = typeof graphic.pathProxy === 'function' ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
        renderCommandList(path.commandList, context, x, y);
        context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes);
        this.beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb);
        if (doStroke) {
            if (strokeCb) {
                strokeCb(context, graphic.attribute, themeAttributes);
            }
            else if (sVisible) {
                context.setStrokeStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes);
                context.stroke();
            }
        }
        if (doFill) {
            if (fillCb) {
                fillCb(context, graphic.attribute, themeAttributes);
            }
            else if (fVisible) {
                context.setCommonStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes);
                context.fill();
            }
        }
        this.afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb);
        return true;
    }
    valid(graphic, defaultAttribute, fillCb, strokeCb) {
        const { fill = defaultAttribute.fill, background, stroke = defaultAttribute.stroke, opacity = defaultAttribute.opacity, fillOpacity = defaultAttribute.fillOpacity, lineWidth = defaultAttribute.lineWidth, strokeOpacity = defaultAttribute.strokeOpacity, visible = defaultAttribute.visible } = graphic.attribute;
        const fVisible = fillVisible(opacity, fillOpacity, fill);
        const sVisible = strokeVisible(opacity, strokeOpacity);
        const doFill = runFill(fill, background);
        const doStroke = runStroke(stroke, lineWidth);
        if (!(graphic.valid && visible)) {
            return false;
        }
        if (!(doFill || doStroke)) {
            return false;
        }
        if (!(fVisible || sVisible || fillCb || strokeCb || background)) {
            return false;
        }
        return {
            fVisible,
            sVisible,
            doFill,
            doStroke
        };
    }
    transform(graphic, graphicAttribute, context, use3dMatrixIn3dMode = false) {
        const { x = graphicAttribute.x, y = graphicAttribute.y, z = graphicAttribute.z, scaleX = graphicAttribute.scaleX, scaleY = graphicAttribute.scaleY, angle = graphicAttribute.angle, postMatrix } = graphic.attribute;
        const lastModelMatrix = context.modelMatrix;
        const camera = context.camera;
        result.x = x;
        result.y = y;
        result.z = z;
        result.lastModelMatrix = lastModelMatrix;
        const shouldTransform3d = camera && (use3dMatrixIn3dMode || shouldUseMat4(graphic));
        const onlyTranslate = shouldTransform3d
            ? graphic.transMatrix.onlyTranslate() && !postMatrix
            : scaleX === 1 && scaleY === 1 && angle === 0 && !postMatrix;
        if (shouldTransform3d) {
            const nextModelMatrix = mat4Allocate.allocate();
            const modelMatrix = mat4Allocate.allocate();
            getModelMatrix(modelMatrix, graphic, graphicAttribute);
            if (lastModelMatrix) {
                multiplyMat4Mat4(nextModelMatrix, lastModelMatrix, modelMatrix);
            }
            else {
                multiplyMat4Mat4(nextModelMatrix, nextModelMatrix, modelMatrix);
            }
            result.x = 0;
            result.y = 0;
            result.z = 0;
            context.modelMatrix = nextModelMatrix;
            context.setTransform(1, 0, 0, 1, 0, 0, true);
            mat4Allocate.free(modelMatrix);
        }
        if (onlyTranslate && !lastModelMatrix) {
            const point = graphic.getOffsetXY(graphicAttribute);
            result.x += point.x;
            result.y += point.y;
            result.z = z;
            context.setTransformForCurrent();
        }
        else if (shouldTransform3d) {
            result.x = 0;
            result.y = 0;
            result.z = 0;
            context.setTransform(1, 0, 0, 1, 0, 0, true);
        }
        else {
            if (camera && context.project) {
                const point = graphic.getOffsetXY(graphicAttribute);
                result.x += point.x;
                result.y += point.y;
                this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle);
            }
            else {
                context.transformFromMatrix(graphic.transMatrix, true);
                result.x = 0;
                result.y = 0;
                result.z = 0;
            }
        }
        return result;
    }
    transformUseContext2d(graphic, graphicAttribute, z, context) {
        const camera = context.camera;
        this.camera = camera;
        if (camera) {
            const bounds = graphic.AABBBounds;
            const width = bounds.x2 - bounds.x1;
            const height = bounds.y2 - bounds.y1;
            const p1 = context.project(0, 0, z);
            const p2 = context.project(width, 0, z);
            const p3 = context.project(width, height, z);
            const _p1 = { x: 0, y: 0 };
            const _p2 = { x: width, y: 0 };
            const _p3 = { x: width, y: height };
            context.camera = null;
            const denom = 1.0 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y);
            const m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom;
            const m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom;
            const m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom;
            const m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom;
            const dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) +
                _p1.y * (_p2.x * p3.x - _p3.x * p2.x) +
                (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) *
                denom;
            const dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) +
                _p1.y * (_p2.x * p3.y - _p3.x * p2.y) +
                (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) *
                denom;
            context.setTransform(m11, m12, m21, m22, dx, dy, true);
        }
    }
    restoreTransformUseContext2d(graphic, graphicAttribute, z, context) {
        if (this.camera) {
            context.camera = this.camera;
        }
    }
    transformWithoutTranslate(context, x, y, z, scaleX, scaleY, angle) {
        const p = context.project(x, y, z);
        context.translate(p.x, p.y, false);
        context.scale(scaleX, scaleY, false);
        context.rotate(angle, false);
        context.translate(-p.x, -p.y, false);
        context.setTransformForCurrent();
    }
    _draw(graphic, defaultAttr, computed3dMatrix, drawContext, params, themeAttribute) {
        const { context } = drawContext;
        if (!context) {
            return;
        }
        const { renderable } = graphic.attribute;
        if (renderable === false) {
            return;
        }
        context.highPerformanceSave();
        const data = this.transform(graphic, defaultAttr, context, computed3dMatrix);
        const { x, y, z, lastModelMatrix } = data;
        this.z = z;
        if (this.drawPathProxy(graphic, context, x, y, drawContext, params)) {
            context.highPerformanceRestore();
            return;
        }
        this.drawShape(graphic, context, x, y, drawContext, params, null, null, themeAttribute);
        this.z = 0;
        if (context.modelMatrix !== lastModelMatrix) {
            mat4Allocate.free(context.modelMatrix);
        }
        context.modelMatrix = lastModelMatrix;
        context.highPerformanceRestore();
    }
}

let DefaultCanvasArcRender = class DefaultCanvasArcRender extends BaseRender {
    constructor(graphicRenderContributions) {
        super();
        this.graphicRenderContributions = graphicRenderContributions;
        this.numberType = ARC_NUMBER_TYPE;
        this.builtinContributions = [
            defaultArcRenderContribution,
            defaultArcBackgroundRenderContribution,
            defaultArcTextureRenderContribution
        ];
        this.init(graphicRenderContributions);
    }
    drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {
        const capAngle = _ea - _sa;
        const data = arc.getParsedAngle();
        const startAngle = data.startAngle;
        let endAngle = data.endAngle;
        endAngle = _ea;
        abs(endAngle - startAngle);
        const clockwise = endAngle > startAngle;
        let collapsedToLine = false;
        if (outerRadius < innerRadius) {
            const temp = outerRadius;
            outerRadius = innerRadius;
            innerRadius = temp;
        }
        const { outerDeltaAngle, xors, yors, xirs, yirs, limitedOcr, outerCornerRadiusStart, outerCornerRadiusEnd, maxOuterCornerRadius, xore, yore, xire, yire, limitedIcr, innerDeltaAngle, innerStartAngle, innerCornerRadiusStart, innerCornerRadiusEnd, maxInnerCornerRadius } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
        if (limitedOcr > epsilon) {
            const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr);
            const cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr);
            const t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise));
            const t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
            if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
                context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);
            }
            else {
                const a1 = endAngle - capAngle - 0.03;
                const a2 = atan2(t1.y11, t1.x11);
                context.arc(cx, cy, outerRadius, a1, a2, !clockwise);
                cornerRadiusEnd > 0 &&
                    context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
            }
        }
        else {
            context.moveTo(cx + xors, cy + yors);
        }
        if (!(innerRadius > epsilon) || innerDeltaAngle < 0.001) {
            context.lineTo(cx + xire, cy + yire);
            collapsedToLine = true;
        }
        else if (limitedIcr > epsilon) {
            const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr);
            const cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr);
            const t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise));
            const t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
            context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01);
            if (limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
                const arcEndAngle = atan2(t1.y01, t1.x01);
                context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);
            }
            else {
                cornerRadiusEnd > 0 &&
                    context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
                const a1 = atan2(t0.cy + t0.y11, t0.cx + t0.x11);
                const a2 = endAngle - capAngle - 0.03;
                context.arc(cx, cy, innerRadius, a1, a2, clockwise);
            }
        }
        else {
            context.lineTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
        }
        return collapsedToLine;
    }
    drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb, arcAttribute) {
        arcAttribute = arcAttribute !== null && arcAttribute !== void 0 ? arcAttribute : getTheme(arc, params === null || params === void 0 ? void 0 : params.theme).arc;
        const { fill = arcAttribute.fill, stroke = arcAttribute.stroke, x: originX = arcAttribute.x, y: originY = arcAttribute.y, fillStrokeOrder = arcAttribute.fillStrokeOrder } = arc.attribute;
        const data = this.valid(arc, arcAttribute, fillCb, strokeCb);
        if (!data) {
            return;
        }
        const { fVisible, sVisible, doFill, doStroke } = data;
        const { outerPadding = arcAttribute.outerPadding, innerPadding = arcAttribute.innerPadding, cap = arcAttribute.cap, forceShowCap = arcAttribute.forceShowCap } = arc.attribute;
        let { outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius } = arc.attribute;
        outerRadius += outerPadding;
        innerRadius -= innerPadding;
        let conicalOffset = 0;
        const tempChangeConicalColor = ((isBoolean(cap) && cap) || cap[0]) && fill.gradient === 'conical';
        if (tempChangeConicalColor) {
            const { sc, startAngle, endAngle } = arc.getParsedAngle();
            if (abs(endAngle - startAngle) < pi2 - epsilon) {
                conicalOffset = sc || 0;
                fill.startAngle -= conicalOffset;
                fill.endAngle -= conicalOffset;
            }
        }
        let beforeRenderContribitionsRuned = false;
        const { isFullStroke, stroke: arrayStroke } = parseStroke(stroke);
        if (doFill || isFullStroke) {
            context.beginPath();
            drawArcPath$1(arc, context, x, y, outerRadius, innerRadius);
            beforeRenderContribitionsRuned = true;
            context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute);
            this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
            if (!fillStrokeOrder) {
                this._runFill(arc, context, x, y, arcAttribute, doFill, fVisible, originX, originY, fillCb);
                this._runStroke(arc, context, x, y, arcAttribute, doStroke, isFullStroke, sVisible, strokeCb);
            }
            else {
                this._runStroke(arc, context, x, y, arcAttribute, doStroke, isFullStroke, sVisible, strokeCb);
                this._runFill(arc, context, x, y, arcAttribute, doFill, fVisible, originX, originY, fillCb);
            }
        }
        if (!isFullStroke && doStroke) {
            context.beginPath();
            drawArcPath$1(arc, context, x, y, outerRadius, innerRadius, arrayStroke);
            if (!beforeRenderContribitionsRuned) {
                this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
            }
            if (strokeCb) {
                strokeCb(context, arc.attribute, arcAttribute);
            }
            else if (sVisible) {
                context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute);
                context.stroke();
            }
        }
        if (((isBoolean(cap) && cap) || cap[1]) && forceShowCap) {
            const { startAngle: sa, endAngle: ea } = arc.getParsedAngle();
            const deltaAngle = abs(ea - sa);
            if (deltaAngle >= pi2 - epsilon) {
                context.beginPath();
                const capWidth = Math.abs(outerRadius - innerRadius) / 2;
                const capAngle = capWidth / outerRadius;
                const { endAngle = arcAttribute.endAngle, fill = arcAttribute.fill } = arc.attribute;
                const startAngle = endAngle;
                this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, startAngle, startAngle + capAngle);
                if (!beforeRenderContribitionsRuned) {
                    this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
                }
                const _runFill = () => {
                    if (doFill) {
                        const color = fill;
                        if (color.gradient === 'conical') {
                            const lastColor = getConicGradientAt(0, 0, endAngle, color);
                            if (fillCb) ;
                            else if (fillVisible) {
                                context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute);
                                context.fillStyle = lastColor;
                                context.fill();
                            }
                        }
                    }
                };
                const _runStroke = () => {
                    if (doStroke) {
                        if (strokeCb) ;
                        else if (sVisible) {
                            context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute);
                            context.stroke();
                        }
                    }
                };
                if (!fillStrokeOrder) {
                    _runFill();
                    _runStroke();
                }
                else {
                    _runFill();
                    _runStroke();
                }
            }
        }
        this.afterRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
        if (tempChangeConicalColor) {
            fill.startAngle += conicalOffset;
            fill.endAngle += conicalOffset;
        }
    }
    _runFill(arc, context, x, y, arcAttribute, doFill, fVisible, originX, originY, fillCb) {
        if (doFill) {
            if (fillCb) {
                fillCb(context, arc.attribute, arcAttribute);
            }
            else if (fVisible) {
                context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute);
                context.fill();
            }
        }
    }
    _runStroke(arc, context, x, y, arcAttribute, doStroke, isFullStroke, sVisible, strokeCb) {
        if (doStroke && isFullStroke) {
            if (strokeCb) ;
            else if (sVisible) {
                context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute);
                context.stroke();
            }
        }
    }
    draw(arc, renderService, drawContext, params) {
        const arcAttribute = getTheme(arc, params === null || params === void 0 ? void 0 : params.theme).arc;
        this._draw(arc, arcAttribute, false, drawContext, params, arcAttribute);
    }
};
DefaultCanvasArcRender = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(ArcRenderContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultCanvasArcRender);

let DefaultCanvasCircleRender = class DefaultCanvasCircleRender extends BaseRender {
    constructor(graphicRenderContributions) {
        super();
        this.graphicRenderContributions = graphicRenderContributions;
        this.numberType = CIRCLE_NUMBER_TYPE;
        this.builtinContributions = [
            defaultCircleRenderContribution,
            defaultCircleBackgroundRenderContribution,
            defaultCircleTextureRenderContribution
        ];
        this.init(graphicRenderContributions);
    }
    drawShape(circle, context, x, y, drawContext, params, fillCb, strokeCb) {
        const circleAttribute = getTheme(circle, params === null || params === void 0 ? void 0 : params.theme).circle;
        const { radius = circleAttribute.radius, startAngle = circleAttribute.startAngle, endAngle = circleAttribute.endAngle, x: originX = circleAttribute.x, y: originY = circleAttribute.y, fillStrokeOrder = circleAttribute.fillStrokeOrder } = circle.attribute;
        const data = this.valid(circle, circleAttribute, fillCb, strokeCb);
        if (!data) {
            return;
        }
        const { fVisible, sVisible, doFill, doStroke } = data;
        context.beginPath();
        context.arc(x, y, radius, startAngle, endAngle);
        context.closePath();
        context.setShadowBlendStyle && context.setShadowBlendStyle(circle, circle.attribute, circleAttribute);
        this.beforeRenderStep(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
        const _runFill = () => {
            if (doFill) {
                if (fillCb) {
                    fillCb(context, circle.attribute, circleAttribute);
                }
                else if (fVisible) {
                    context.setCommonStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute);
                    context.fill();
                }
            }
        };
        const _runStroke = () => {
            if (doStroke) {
                if (strokeCb) {
                    strokeCb(context, circle.attribute, circleAttribute);
                }
                else if (sVisible) {
                    context.setStrokeStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute);
                    context.stroke();
                }
            }
        };
        if (!fillStrokeOrder) {
            _runFill();
            _runStroke();
        }
        else {
            _runStroke();
            _runFill();
        }
        this.afterRenderStep(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
    }
    draw(circle, renderService, drawContext, params) {
        const circleAttribute = getTheme(circle, params === null || params === void 0 ? void 0 : params.theme).circle;
        this._draw(circle, circleAttribute, false, drawContext, params);
    }
};
DefaultCanvasCircleRender = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(CircleRenderContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultCanvasCircleRender);

function drawSegItem(ctx, curve, endPercent, params) {
    if (!curve.p1) {
        return;
    }
    const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params || {};
    if (endPercent === 1) {
        if (curve.p2 && curve.p3) {
            ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ);
        }
        else {
            ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ);
        }
    }
    else {
        if (curve.p2 && curve.p3) {
            const [curve1] = divideCubic(curve, endPercent);
            ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
        }
        else {
            const p = curve.getPointAt(endPercent);
            ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
        }
    }
}

function drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ) {
    var _a;
    let p0 = curve.p0;
    let newDefined0 = defined0;
    if (lastCurve && lastCurve.originP1 === lastCurve.originP2) {
        p0 = lastCurve.p0;
    }
    if (curve.defined) {
        if (!defined0) {
            path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ);
            newDefined0 = !defined0;
        }
    }
    else {
        const { originP1, originP2 } = curve;
        let validP;
        if (originP1 && originP1.defined !== false && !lastCurve) {
            validP = p0;
        }
        else if (originP1 && originP2.defined !== false) {
            validP = (_a = curve.p3) !== null && _a !== void 0 ? _a : curve.p1;
        }
        if (defined0) {
            newDefined0 = !defined0;
            const x = validP ? validP.x : curve.p0.x;
            const y = validP ? validP.y : curve.p0.y;
            path.moveTo(x + offsetX, y + offsetY, offsetZ);
        }
        else {
            if (validP) {
                newDefined0 = !defined0;
                path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ);
            }
        }
    }
    return newDefined0;
}
function drawSegments(path, segPath, percent, clipRangeByDimension, params) {
    const { offsetX = 0, offsetY = 0, offsetZ = 0, mode = 'none', drawConnect = false } = params || {};
    if (drawConnect && mode === 'none') {
        return;
    }
    if (!segPath) {
        return;
    }
    let needMoveTo = true;
    const { curves } = segPath;
    if (percent >= 1) {
        if (drawConnect) {
            let defined0 = true;
            let lastCurve;
            curves.forEach((curve, i) => {
                if (curve.originP1 === curve.originP2) {
                    lastCurve = curve;
                    return;
                }
                defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ);
                lastCurve = curve;
            });
        }
        else {
            curves.forEach(curve => {
                if (!curve.defined) {
                    needMoveTo = true;
                    return;
                }
                if (needMoveTo) {
                    path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);
                }
                drawSegItem(path, curve, 1, params);
                needMoveTo = false;
            });
        }
        return;
    }
    if (percent <= 0) {
        return;
    }
    let direction;
    if (clipRangeByDimension === 'x') {
        direction = Direction.ROW;
    }
    else if (clipRangeByDimension === 'y') {
        direction = Direction.COLUMN;
    }
    else if (clipRangeByDimension === 'auto') {
        direction = segPath.direction;
    }
    const totalLength = segPath.tryUpdateLength(direction);
    const totalDrawLength = percent * totalLength;
    let drawedLengthUntilLast = 0;
    let defined0 = true;
    let lastCurve = null;
    for (let i = 0, n = curves.length; i < n; i++) {
        const curve = curves[i];
        const curCurveLength = curve.getLength(direction);
        const _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
        drawedLengthUntilLast += curCurveLength;
        if (_p < 0) {
            break;
        }
        if (drawConnect) {
            if (curve.originP1 === curve.originP2) {
                lastCurve = curve;
                continue;
            }
            defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ);
            lastCurve = curve;
        }
        else {
            if (!curve.defined) {
                needMoveTo = true;
                continue;
            }
            if (needMoveTo) {
                path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);
            }
            drawSegItem(path, curve, min(_p, 1), params);
            needMoveTo = false;
        }
    }
}
function drawIncrementalSegments(path, lastSeg, segments, params) {
    const { offsetX = 0, offsetY = 0 } = params || {};
    const startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];
    path.moveTo(startP.x + offsetX, startP.y + offsetY);
    segments.points.forEach(p => {
        if (p.defined === false) {
            path.moveTo(p.x + offsetX, p.y + offsetY);
            return;
        }
        path.lineTo(p.x + offsetX, p.y + offsetY);
    });
}
function drawIncrementalAreaSegments(path, lastSeg, segments, params) {
    const { offsetX = 0, offsetY = 0 } = params || {};
    const { points } = segments;
    const definedPointsList = [];
    for (let i = 0; i < points.length; i++) {
        if (points[i].defined === false) ;
    }
    definedPointsList.push(points);
    definedPointsList.forEach((points, i) => {
        var _a, _b, _c, _d;
        const startP = lastSeg && i === 0 ? lastSeg.points[lastSeg.points.length - 1] : points[0];
        path.moveTo(startP.x + offsetX, startP.y + offsetY);
        points.forEach(p => {
            if (p.defined === false) {
                path.moveTo(p.x + offsetX, p.y + offsetY);
                return;
            }
            path.lineTo(p.x + offsetX, p.y + offsetY);
        });
        for (let i = points.length - 1; i >= 0; i--) {
            const p = points[i];
            path.lineTo((_a = p.x1) !== null && _a !== void 0 ? _a : p.x, (_b = p.y1) !== null && _b !== void 0 ? _b : p.y);
        }
        path.lineTo((_c = startP.x1) !== null && _c !== void 0 ? _c : startP.x, (_d = startP.y1) !== null && _d !== void 0 ? _d : startP.y);
        path.closePath();
    });
}

let DefaultCanvasLineRender = class DefaultCanvasLineRender extends BaseRender {
    constructor() {
        super(...arguments);
        this.numberType = LINE_NUMBER_TYPE;
    }
    draw(line, renderService, drawContext, params) {
        const lineAttribute = getTheme(line, params === null || params === void 0 ? void 0 : params.theme).line;
        this._draw(line, lineAttribute, false, drawContext, params);
    }
    drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
        var _a;
        if (!cache) {
            return;
        }
        context.beginPath();
        const z = (_a = this.z) !== null && _a !== void 0 ? _a : 0;
        drawSegments(context, cache, clipRange, clipRangeByDimension, {
            offsetX,
            offsetY,
            offsetZ: z
        });
        if (line.cache &&
            !isArray(line.cache) &&
            line.cache.curves.every(c => c.defined) &&
            line.attribute.curveType &&
            line.attribute.curveType.includes('Closed')) {
            context.closePath();
        }
        context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute);
        const { x: originX = 0, x: originY = 0 } = attribute;
        const ret = false;
        if (fill !== false) {
            if (fillCb) {
                fillCb(context, attribute, defaultAttribute);
            }
            else if (fillOpacity) {
                context.setCommonStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute);
                context.fill();
            }
        }
        if (stroke !== false) {
            if (strokeCb) {
                strokeCb(context, attribute, defaultAttribute);
            }
            else if (strokeOpacity) {
                context.setStrokeStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute);
                context.stroke();
            }
        }
        return !!ret;
    }
    drawLinearLineHighPerformance(line, context, fill, stroke, fillOpacity, strokeOpacity, offsetX, offsetY, lineAttribute, drawContext, params, fillCb, strokeCb) {
        var _a;
        context.beginPath();
        const z = (_a = this.z) !== null && _a !== void 0 ? _a : 0;
        const { points } = line.attribute;
        const startP = points[0];
        context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
        for (let i = 1; i < points.length; i++) {
            const p = points[i];
            context.lineTo(p.x + offsetX, p.y + offsetY, z);
        }
        context.setShadowBlendStyle && context.setShadowBlendStyle(line, line.attribute, lineAttribute);
        const { x: originX = 0, x: originY = 0 } = line.attribute;
        if (fill !== false) {
            if (fillCb) {
                fillCb(context, line.attribute, lineAttribute);
            }
            else if (fillOpacity) {
                context.setCommonStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute);
                context.fill();
            }
        }
        if (stroke !== false) {
            if (strokeCb) {
                strokeCb(context, line.attribute, lineAttribute);
            }
            else if (strokeOpacity) {
                context.setStrokeStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute);
                context.stroke();
            }
        }
    }
    drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
        const lineAttribute = getTheme(line, params === null || params === void 0 ? void 0 : params.theme).line;
        const { fill = lineAttribute.fill, stroke = lineAttribute.stroke, fillOpacity = lineAttribute.fillOpacity, strokeOpacity = lineAttribute.strokeOpacity, segments, points, closePath, curveTension = lineAttribute.curveTension, connectedType = lineAttribute.connectedType } = line.attribute;
        const data = this.valid(line, lineAttribute, fillCb, strokeCb);
        if (!data) {
            return;
        }
        let { curveType = lineAttribute.curveType } = line.attribute;
        if (closePath && curveType === 'linear') {
            curveType = 'linearClosed';
        }
        const { clipRange = lineAttribute.clipRange, clipRangeByDimension = lineAttribute.clipRangeByDimension } = line.attribute;
        if (clipRange === 1 && !segments && !points.some(p => p.defined === false) && curveType === 'linear') {
            return this.drawLinearLineHighPerformance(line, context, !!fill, !!stroke, fillOpacity, strokeOpacity, x, y, lineAttribute, drawContext, params, fillCb, strokeCb);
        }
        function parsePoint(points, connectedType) {
            if (connectedType === 'none') {
                return points;
            }
            return points.filter(p => p.defined !== false);
        }
        if (line.shouldUpdateShape()) {
            const { points, segments } = line.attribute;
            const _points = points;
            if (segments && segments.length) {
                let startPoint;
                let lastSeg;
                line.cache = segments
                    .map((seg, index) => {
                    if (seg.points.length <= 1) {
                        if (index === 0) {
                            seg.points[0] &&
                                (lastSeg = {
                                    endX: seg.points[0].x,
                                    endY: seg.points[0].y,
                                    curves: [{ defined: seg.points[0].defined !== false }]
                                });
                            return null;
                        }
                    }
                    if (index === 1) {
                        startPoint = {
                            x: lastSeg.endX,
                            y: lastSeg.endY,
                            defined: lastSeg.curves[lastSeg.curves.length - 1].defined
                        };
                    }
                    else if (index > 1) {
                        startPoint.x = lastSeg.endX;
                        startPoint.y = lastSeg.endY;
                        startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined;
                    }
                    const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
                        startPoint,
                        curveTension
                    });
                    lastSeg = data;
                    return data;
                })
                    .filter(item => !!item);
                if (curveType === 'linearClosed') {
                    let startP;
                    for (let i = 0; i < line.cache.length; i++) {
                        const cacheItem = line.cache[i];
                        for (let i = 0; i < cacheItem.curves.length; i++) {
                            if (cacheItem.curves[i].defined) {
                                startP = cacheItem.curves[i].p0;
                                break;
                            }
                        }
                        if (startP) {
                            break;
                        }
                    }
                    line.cache[line.cache.length - 1] && line.cache[line.cache.length - 1].lineTo(startP.x, startP.y, true);
                }
            }
            else if (points && points.length) {
                line.cache = calcLineCache(parsePoint(_points, connectedType), curveType, { curveTension });
            }
            else {
                line.cache = null;
                line.clearUpdateShapeTag();
                return;
            }
            line.clearUpdateShapeTag();
        }
        if (Array.isArray(line.cache)) {
            const segments = line.attribute.segments.filter(item => item.points.length);
            if (segments[0].points.length === 1) {
                segments.shift();
            }
            if (clipRange === 1) {
                let skip = false;
                line.cache.forEach((cache, index) => {
                    if (skip) {
                        return;
                    }
                    skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, segments[index], [lineAttribute, line.attribute], clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);
                });
            }
            else {
                const totalLength = line.cache.reduce((l, c) => l + c.getLength(), 0);
                const totalDrawLength = clipRange * totalLength;
                let drawedLengthUntilLast = 0;
                let skip = false;
                line.cache.forEach((cache, index) => {
                    if (skip) {
                        return;
                    }
                    const curSegLength = cache.getLength();
                    const _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
                    drawedLengthUntilLast += curSegLength;
                    if (_cr > 0) {
                        skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, segments[index], [lineAttribute, line.attribute], min(_cr, 1), clipRangeByDimension, x, y, line, fillCb, strokeCb);
                    }
                });
            }
        }
        else {
            this.drawSegmentItem(context, line.cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);
        }
    }
};
DefaultCanvasLineRender = __decorate([
    injectable()
], DefaultCanvasLineRender);

function drawAreaSegments(path, segPath, percent, params) {
    var _a;
    const { top, bottom } = segPath;
    if (top.curves.length !== bottom.curves.length) {
        return;
    }
    if (percent >= 1) {
        const topList = [];
        const bottomList = [];
        let lastDefined = true;
        for (let i = 0, n = top.curves.length; i < n; i++) {
            const topCurve = top.curves[i];
            if (lastDefined !== topCurve.defined) {
                if (lastDefined) {
                    drawAreaBlock(path, topList, bottomList, params);
                    topList.length = 0;
                    bottomList.length = 0;
                }
                else {
                    topList.push(topCurve);
                    bottomList.push(bottom.curves[n - i - 1]);
                }
                lastDefined = !lastDefined;
            }
            else {
                if (lastDefined) {
                    topList.push(topCurve);
                    bottomList.push(bottom.curves[n - i - 1]);
                }
            }
        }
        drawAreaBlock(path, topList, bottomList, params);
        return;
    }
    if (percent <= 0) {
        return;
    }
    let { direction } = params || {};
    const { curves: topCurves } = top;
    const endP = (_a = topCurves[topCurves.length - 1].p3) !== null && _a !== void 0 ? _a : topCurves[topCurves.length - 1].p1;
    const xTotalLength = abs(endP.x - topCurves[0].p0.x);
    const yTotalLength = abs(endP.y - topCurves[0].p0.y);
    direction = direction !== null && direction !== void 0 ? direction : (xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN);
    if (!Number.isFinite(xTotalLength)) {
        direction = Direction.COLUMN;
    }
    if (!Number.isFinite(yTotalLength)) {
        direction = Direction.ROW;
    }
    const totalLength = direction === Direction.ROW ? xTotalLength : yTotalLength;
    const totalDrawLength = percent * totalLength;
    let drawedLengthUntilLast = 0;
    let lastDefined = true;
    const topList = [];
    const bottomList = [];
    for (let i = 0, n = top.curves.length; i < n; i++) {
        const topCurve = top.curves[i];
        const curCurveLength = topCurve.getLength(direction);
        const percent = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
        if (percent < 0) {
            break;
        }
        drawedLengthUntilLast += curCurveLength;
        let tc = null;
        let bc = null;
        if (lastDefined !== topCurve.defined) {
            if (lastDefined) {
                drawAreaBlock(path, topList, bottomList, params);
                topList.length = 0;
                bottomList.length = 0;
            }
            else {
                tc = topCurve;
                bc = bottom.curves[n - i - 1];
            }
            lastDefined = !lastDefined;
        }
        else {
            if (lastDefined) {
                tc = topCurve;
                bc = bottom.curves[n - i - 1];
            }
        }
        if (tc && bc) {
            if (percent < 1) {
                if (tc.p2 && tc.p3) {
                    tc = divideCubic(tc, percent)[0];
                }
                else {
                    tc = divideLinear(tc, percent)[0];
                }
                if (bc.p2 && bc.p3) {
                    bc = divideCubic(bc, 1 - percent)[1];
                }
                else {
                    bc = divideLinear(bc, 1 - percent)[1];
                }
            }
            tc.defined = lastDefined;
            bc.defined = lastDefined;
            topList.push(tc);
            bottomList.push(bc);
        }
        tc = null;
        bc = null;
    }
    drawAreaBlock(path, topList, bottomList, params);
}
function drawAreaBlock(path, topList, bottomList, params) {
    const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params || {};
    let needMoveTo = true;
    topList.forEach(curve => {
        if (!curve.defined) {
            needMoveTo = true;
            return;
        }
        if (needMoveTo) {
            path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);
        }
        drawSegItem(path, curve, 1, params);
        needMoveTo = false;
    });
    needMoveTo = true;
    for (let i = bottomList.length - 1; i >= 0; i--) {
        const curve = bottomList[i];
        if (!curve.defined) {
            needMoveTo = true;
            continue;
        }
        if (needMoveTo) {
            path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ);
        }
        drawSegItem(path, curve, 1, params);
        needMoveTo = false;
    }
    path.closePath();
}

const defaultAreaTextureRenderContribution = new DefaultAreaTextureRenderContribution();
const defaultAreaBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

let DefaultCanvasAreaRender = class DefaultCanvasAreaRender extends BaseRender {
    constructor(graphicRenderContributions) {
        super();
        this.graphicRenderContributions = graphicRenderContributions;
        this.numberType = AREA_NUMBER_TYPE;
        this.builtinContributions = [defaultAreaTextureRenderContribution, defaultAreaBackgroundRenderContribution];
        this.init(graphicRenderContributions);
    }
    drawLinearAreaHighPerformance(area, context, fill, stroke, fillOpacity, strokeOpacity, offsetX, offsetY, areaAttribute, drawContext, params, fillCb, strokeCb) {
        var _a, _b, _c;
        const { points } = area.attribute;
        if (points.length < 2) {
            return;
        }
        context.beginPath();
        const z = (_a = this.z) !== null && _a !== void 0 ? _a : 0;
        const startP = points[0];
        context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
        for (let i = 1; i < points.length; i++) {
            const p = points[i];
            context.lineTo(p.x + offsetX, p.y + offsetY, z);
        }
        for (let i = points.length - 1; i >= 0; i--) {
            const p = points[i];
            context.lineTo(((_b = p.x1) !== null && _b !== void 0 ? _b : p.x) + offsetX, ((_c = p.y1) !== null && _c !== void 0 ? _c : p.y) + offsetY, z);
        }
        context.closePath();
        context.setShadowBlendStyle && context.setShadowBlendStyle(area, area.attribute, areaAttribute);
        this.beforeRenderStep(area, context, offsetX, offsetY, !!fillOpacity, false, fill, false, areaAttribute, drawContext, fillCb, null, { attribute: area.attribute });
        const { x: originX = 0, x: originY = 0 } = area.attribute;
        const _runFill = () => {
            if (fill !== false) {
                if (fillCb) {
                    fillCb(context, area.attribute, areaAttribute);
                }
                else if (fillOpacity) {
                    context.setCommonStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute);
                    context.fill();
                }
            }
        };
        const _runStroke = () => {
            var _a, _b;
            if (stroke) {
                const { stroke = areaAttribute && areaAttribute.stroke } = area.attribute;
                if (isArray(stroke) && (stroke[0] || stroke[2]) && stroke[1] === false) {
                    context.beginPath();
                    if (stroke[0]) {
                        context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
                        for (let i = 1; i < points.length; i++) {
                            const p = points[i];
                            context.lineTo(p.x + offsetX, p.y + offsetY, z);
                        }
                    }
                    else if (stroke[2]) {
                        const endP = points[points.length - 1];
                        context.moveTo(endP.x + offsetX, endP.y + offsetY, z);
                        for (let i = points.length - 2; i >= 0; i--) {
                            const p = points[i];
                            context.lineTo(((_a = p.x1) !== null && _a !== void 0 ? _a : p.x) + offsetX, ((_b = p.y1) !== null && _b !== void 0 ? _b : p.y) + offsetY, z);
                        }
                    }
                }
                if (strokeCb) {
                    strokeCb(context, area.attribute, areaAttribute);
                }
                else {
                    context.setStrokeStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute);
                    context.stroke();
                }
            }
        };
        _runFill();
        this.afterRenderStep(area, context, offsetX, offsetY, !!fillOpacity, false, fill, false, areaAttribute, drawContext, fillCb, null, { attribute: area.attribute });
        _runStroke();
    }
    drawShape(area, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a, _b, _c, _d, _e, _f;
        const areaAttribute = getTheme(area, params === null || params === void 0 ? void 0 : params.theme).area;
        const { fill = areaAttribute.fill, stroke = areaAttribute.stroke, fillOpacity = areaAttribute.fillOpacity, z = areaAttribute.z, strokeOpacity = areaAttribute.strokeOpacity, curveTension = areaAttribute.curveTension, connectedType = areaAttribute.connectedType } = area.attribute;
        const data = this.valid(area, areaAttribute, fillCb, strokeCb);
        if (!data) {
            return;
        }
        const { doFill } = data;
        const doStroke = data.doStroke && data.sVisible;
        const { clipRange = areaAttribute.clipRange, closePath, points, segments } = area.attribute;
        let { curveType = areaAttribute.curveType } = area.attribute;
        if (closePath && curveType === 'linear') {
            curveType = 'linearClosed';
        }
        function parsePoint(points, connectedType) {
            if (connectedType !== 'connect') {
                return points;
            }
            return points.filter(p => p.defined !== false);
        }
        if (clipRange === 1 && !segments && !points.some(p => p.defined === false) && curveType === 'linear') {
            return this.drawLinearAreaHighPerformance(area, context, !!fill, doStroke, fillOpacity, strokeOpacity, x, y, areaAttribute, drawContext, params, fillCb, strokeCb);
        }
        if (area.shouldUpdateShape()) {
            if (segments && segments.length) {
                let startPoint;
                let lastTopSeg;
                const topCaches = segments
                    .map((seg, index) => {
                    if (seg.points.length <= 1) {
                        if (index === 0) {
                            seg.points[0] && (lastTopSeg = { endX: seg.points[0].x, endY: seg.points[0].y });
                            return null;
                        }
                    }
                    if (index === 1) {
                        startPoint = { x: lastTopSeg.endX, y: lastTopSeg.endY };
                    }
                    else if (index > 1) {
                        startPoint.x = lastTopSeg.endX;
                        startPoint.y = lastTopSeg.endY;
                    }
                    const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
                        startPoint,
                        curveTension
                    });
                    lastTopSeg = data;
                    return data;
                })
                    .filter(item => !!item);
                let lastBottomSeg;
                const bottomCaches = [];
                for (let i = segments.length - 1; i >= 0; i--) {
                    const points = segments[i].points;
                    const bottomPoints = [];
                    for (let i = points.length - 1; i >= 0; i--) {
                        bottomPoints.push({
                            x: (_a = points[i].x1) !== null && _a !== void 0 ? _a : points[i].x,
                            y: (_b = points[i].y1) !== null && _b !== void 0 ? _b : points[i].y
                        });
                    }
                    if (i !== 0) {
                        const lastSegmentPoints = segments[i - 1].points;
                        const endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];
                        endPoint &&
                            bottomPoints.push({
                                x: (_c = endPoint.x1) !== null && _c !== void 0 ? _c : endPoint.x,
                                y: (_d = endPoint.y1) !== null && _d !== void 0 ? _d : endPoint.y
                            });
                    }
                    if (bottomPoints.length > 1) {
                        lastBottomSeg = calcLineCache(parsePoint(bottomPoints, connectedType), curveType === 'stepBefore' ? 'stepAfter' : curveType === 'stepAfter' ? 'stepBefore' : curveType, { curveTension });
                        bottomCaches.unshift(lastBottomSeg);
                    }
                }
                area.cacheArea = bottomCaches.map((item, index) => ({
                    top: topCaches[index],
                    bottom: item
                }));
            }
            else if (points && points.length) {
                const topPoints = parsePoint(points, connectedType);
                const bottomPoints = [];
                for (let i = topPoints.length - 1; i >= 0; i--) {
                    bottomPoints.push({
                        x: (_e = topPoints[i].x1) !== null && _e !== void 0 ? _e : topPoints[i].x,
                        y: (_f = topPoints[i].y1) !== null && _f !== void 0 ? _f : topPoints[i].y
                    });
                }
                const topCache = calcLineCache(topPoints, curveType, { curveTension });
                const bottomCache = calcLineCache(bottomPoints, curveType === 'stepBefore' ? 'stepAfter' : curveType === 'stepAfter' ? 'stepBefore' : curveType, { curveTension });
                area.cacheArea = { top: topCache, bottom: bottomCache };
            }
            else {
                area.cacheArea = null;
                area.clearUpdateShapeTag();
                return;
            }
            area.clearUpdateShapeTag();
        }
        if (Array.isArray(area.cacheArea)) {
            const segments = area.attribute.segments.filter(item => item.points.length);
            if (segments[0].points.length === 1) {
                segments.shift();
            }
            if (clipRange === 1) {
                let skip = false;
                area.cacheArea.forEach((cache, index) => {
                    if (skip) {
                        return;
                    }
                    skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments[index], [areaAttribute, area.attribute], clipRange, x, y, z, area, drawContext, fillCb, strokeCb);
                });
            }
            else {
                const totalLength = area.cacheArea.reduce((l, c) => l + c.top.getLength(), 0);
                const totalDrawLength = clipRange * totalLength;
                let drawedLengthUntilLast = 0;
                let skip = false;
                area.cacheArea.forEach((cache, index) => {
                    if (skip) {
                        return;
                    }
                    const curSegLength = cache.top.getLength();
                    const _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
                    drawedLengthUntilLast += curSegLength;
                    if (_cr > 0) {
                        skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments[index], [areaAttribute, area.attribute], min(_cr, 1), x, y, z, area, drawContext, fillCb, strokeCb);
                    }
                });
            }
        }
        else {
            this.drawSegmentItem(context, area.cacheArea, doFill, fillOpacity, doStroke, strokeOpacity, area.attribute, areaAttribute, clipRange, x, y, z, area, drawContext, fillCb, strokeCb);
        }
    }
    draw(area, renderService, drawContext, params) {
        const areaAttribute = getTheme(area, params === null || params === void 0 ? void 0 : params.theme).area;
        this._draw(area, areaAttribute, false, drawContext, params);
    }
    drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb) {
        return this._drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb);
    }
    _drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb) {
        if (!(cache &&
            cache.top &&
            cache.bottom &&
            cache.top.curves &&
            cache.top.curves.length &&
            cache.bottom.curves &&
            cache.bottom.curves.length)) {
            return;
        }
        context.beginPath();
        const ret = false;
        const { points, segments } = area.attribute;
        let direction = Direction.ROW;
        let endP;
        let startP;
        if (segments) {
            const endSeg = segments[segments.length - 1];
            const startSeg = segments[0];
            startP = startSeg.points[0];
            endP = endSeg.points[endSeg.points.length - 1];
        }
        else {
            startP = points[0];
            endP = points[points.length - 1];
        }
        const xTotalLength = abs(endP.x - startP.x);
        const yTotalLength = abs(endP.y - startP.y);
        if (endP.x1 == null) {
            direction = Direction.ROW;
        }
        else if (endP.y1 == null) {
            direction = Direction.COLUMN;
        }
        else if (!Number.isFinite(xTotalLength + yTotalLength)) {
            direction = Direction.ROW;
        }
        else {
            direction = xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN;
        }
        drawAreaSegments(context, cache, clipRange, {
            offsetX,
            offsetY,
            offsetZ,
            direction
        });
        this.beforeRenderStep(area, context, offsetX, offsetY, !!fillOpacity, false, fill, false, defaultAttribute, drawContext, fillCb, null, { attribute });
        context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute);
        const { x: originX = 0, x: originY = 0 } = attribute;
        const _runFill = () => {
            if (fill !== false) {
                if (fillCb) {
                    fillCb(context, attribute, defaultAttribute);
                }
                else if (fillOpacity) {
                    context.setCommonStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute);
                    context.fill();
                }
            }
        };
        const _runStroke = () => {
            if (stroke !== false) {
                if (strokeCb) {
                    strokeCb(context, attribute, defaultAttribute);
                }
                else {
                    const { stroke = defaultAttribute && defaultAttribute[1] && defaultAttribute[1].stroke } = attribute;
                    if (isArray(stroke) && (stroke[0] || stroke[2]) && stroke[1] === false) {
                        context.beginPath();
                        drawSegments(context, stroke[0] ? cache.top : cache.bottom, clipRange, direction === Direction.ROW ? 'x' : 'y', {
                            offsetX,
                            offsetY,
                            offsetZ
                        });
                    }
                    context.setStrokeStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute);
                    context.stroke();
                }
            }
        };
        _runFill();
        this.afterRenderStep(area, context, offsetX, offsetY, !!fillOpacity, false, fill, false, defaultAttribute, drawContext, fillCb, null, { attribute });
        _runStroke();
        return ret;
    }
};
DefaultCanvasAreaRender = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(AreaRenderContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultCanvasAreaRender);

const defaultPathTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultPathBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

let DefaultCanvasPathRender = class DefaultCanvasPathRender extends BaseRender {
    constructor(graphicRenderContributions) {
        super();
        this.graphicRenderContributions = graphicRenderContributions;
        this.numberType = PATH_NUMBER_TYPE;
        this.builtinContributions = [defaultPathBackgroundRenderContribution, defaultPathTextureRenderContribution];
        this.init(graphicRenderContributions);
    }
    drawShape(path, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a, _b, _c;
        const pathAttribute = (_a = this.tempTheme) !== null && _a !== void 0 ? _a : getTheme(path, params === null || params === void 0 ? void 0 : params.theme).path;
        const { x: originX = pathAttribute.x, y: originY = pathAttribute.y, fillStrokeOrder = pathAttribute.fillStrokeOrder } = path.attribute;
        const z = (_b = this.z) !== null && _b !== void 0 ? _b : 0;
        const data = this.valid(path, pathAttribute, fillCb, strokeCb);
        if (!data) {
            return;
        }
        const { fVisible, sVisible, doFill, doStroke } = data;
        context.beginPath();
        if (path.pathShape) {
            renderCommandList(path.pathShape.commandList, context, x, y, 1, 1, z);
        }
        else {
            const path2D = (_c = path.attribute.path) !== null && _c !== void 0 ? _c : pathAttribute.path;
            renderCommandList(path2D.commandList, context, x, y, 1, 1, z);
        }
        context.setShadowBlendStyle && context.setShadowBlendStyle(path, path.attribute, pathAttribute);
        this.beforeRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
        const _runStroke = () => {
            if (doStroke) {
                if (strokeCb) {
                    strokeCb(context, path.attribute, pathAttribute);
                }
                else if (sVisible) {
                    context.setStrokeStyle(path, path.attribute, originX - x, originY - y, pathAttribute);
                    context.stroke();
                }
            }
        };
        const _runFill = () => {
            if (doFill) {
                if (fillCb) {
                    fillCb(context, path.attribute, pathAttribute);
                }
                else if (fVisible) {
                    context.setCommonStyle(path, path.attribute, originX - x, originY - y, pathAttribute);
                    context.fill();
                }
            }
        };
        if (!fillStrokeOrder) {
            _runFill();
            _runStroke();
        }
        else {
            _runStroke();
            _runFill();
        }
        this.afterRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
    }
    draw(path, renderService, drawContext, params) {
        const pathAttribute = getTheme(path, params === null || params === void 0 ? void 0 : params.theme).path;
        this.tempTheme = pathAttribute;
        this._draw(path, pathAttribute, false, drawContext, params);
        this.tempTheme = null;
    }
};
DefaultCanvasPathRender = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(PathRenderContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultCanvasPathRender);

let DefaultCanvasRectRender = class DefaultCanvasRectRender extends BaseRender {
    constructor(graphicRenderContributions) {
        super();
        this.graphicRenderContributions = graphicRenderContributions;
        this.type = 'rect';
        this.numberType = RECT_NUMBER_TYPE;
        this.builtinContributions = [
            defaultRectRenderContribution,
            defaultRectBackgroundRenderContribution,
            defaultRectTextureRenderContribution
        ];
        this.init(graphicRenderContributions);
    }
    drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb, rectAttribute) {
        rectAttribute = rectAttribute !== null && rectAttribute !== void 0 ? rectAttribute : getTheme(rect, params === null || params === void 0 ? void 0 : params.theme).rect;
        const { fill = rectAttribute.fill, background, stroke = rectAttribute.stroke, cornerRadius = rectAttribute.cornerRadius, cornerType = rectAttribute.cornerType, opacity = rectAttribute.opacity, fillOpacity = rectAttribute.fillOpacity, lineWidth = rectAttribute.lineWidth, strokeOpacity = rectAttribute.strokeOpacity, visible = rectAttribute.visible, x1, y1, x: originX = rectAttribute.x, y: originY = rectAttribute.y, fillStrokeOrder = rectAttribute.fillStrokeOrder, drawStrokeWhenZeroWH = rectAttribute.drawStrokeWhenZeroWH } = rect.attribute;
        let { width, height } = rect.attribute;
        width = (width !== null && width !== void 0 ? width : x1 - originX) || 0;
        height = (height !== null && height !== void 0 ? height : y1 - originY) || 0;
        const fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill);
        const sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height, drawStrokeWhenZeroWH);
        const doFill = runFill(fill, background);
        const doStroke = runStroke(stroke, lineWidth);
        if (!(rect.valid && visible)) {
            return;
        }
        if (!(doFill || doStroke)) {
            return;
        }
        if (!(fVisible || sVisible || fillCb || strokeCb || background)) {
            return;
        }
        if (cornerRadius === 0 || (isArray(cornerRadius) && cornerRadius.every(num => num === 0))) {
            context.beginPath();
            context.rect(x, y, width, height);
        }
        else {
            context.beginPath();
            createRectPath(context, x, y, width, height, cornerRadius, cornerType !== 'bevel');
        }
        const doFillOrStroke = {
            doFill,
            doStroke
        };
        context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute);
        this.beforeRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
        if (!fillStrokeOrder) {
            this._runFill(rect, context, x, y, rectAttribute, doFillOrStroke, fVisible, originX, originY, fillCb);
            this._runStroke(rect, context, x, y, rectAttribute, doFillOrStroke, sVisible, originX, originY, strokeCb);
        }
        else {
            this._runStroke(rect, context, x, y, rectAttribute, doFillOrStroke, sVisible, originX, originY, strokeCb);
            this._runFill(rect, context, x, y, rectAttribute, doFillOrStroke, fVisible, originX, originY, fillCb);
        }
        this.afterRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
    }
    _runFill(rect, context, x, y, rectAttribute, doFillOrStroke, fVisible, originX, originY, fillCb) {
        if (doFillOrStroke.doFill) {
            if (fillCb) {
                fillCb(context, rect.attribute, rectAttribute);
            }
            else if (fVisible) {
                context.setCommonStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute);
                context.fill();
            }
        }
    }
    _runStroke(rect, context, x, y, rectAttribute, doFillOrStroke, sVisible, originX, originY, strokeCb) {
        if (doFillOrStroke.doStroke) {
            if (strokeCb) {
                strokeCb(context, rect.attribute, rectAttribute);
            }
            else if (sVisible) {
                context.setStrokeStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute);
                context.stroke();
            }
        }
    }
    draw(rect, renderService, drawContext, params) {
        const rectAttribute = getTheme(rect, params === null || params === void 0 ? void 0 : params.theme).rect;
        this._draw(rect, rectAttribute, false, drawContext, params, rectAttribute);
    }
};
DefaultCanvasRectRender = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(RectRenderContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultCanvasRectRender);

let DefaultCanvasSymbolRender = class DefaultCanvasSymbolRender extends BaseRender {
    constructor(graphicRenderContributions) {
        super();
        this.graphicRenderContributions = graphicRenderContributions;
        this.numberType = SYMBOL_NUMBER_TYPE;
        this.builtinContributions = [
            defaultSymbolRenderContribution,
            defaultSymbolBackgroundRenderContribution,
            defaultSymbolTextureRenderContribution,
            defaultSymbolClipRangeStrokeRenderContribution
        ];
        this.init(graphicRenderContributions);
    }
    drawShape(symbol, context, x, y, drawContext, params, fillCb, strokeCb, symbolAttribute) {
        var _a;
        symbolAttribute = symbolAttribute !== null && symbolAttribute !== void 0 ? symbolAttribute : getTheme(symbol, params === null || params === void 0 ? void 0 : params.theme).symbol;
        const { size = symbolAttribute.size, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX = symbolAttribute.scaleX, scaleY = symbolAttribute.scaleY, fillStrokeOrder = symbolAttribute.fillStrokeOrder, clipRange = symbolAttribute.clipRange } = symbol.attribute;
        const data = this.valid(symbol, symbolAttribute, fillCb, strokeCb);
        if (!data) {
            return;
        }
        const { fVisible, sVisible, doFill, doStroke } = data;
        const parsedPath = symbol.getParsedPath();
        if (!parsedPath) {
            return;
        }
        const { keepDirIn3d = symbolAttribute.keepDirIn3d } = symbol.attribute;
        const z = (_a = this.z) !== null && _a !== void 0 ? _a : 0;
        context.beginPath();
        const callback = (p, a) => {
            var _a, _b, _c, _d;
            if (symbol._parsedPath.svgCache) {
                const obj = Object.assign({}, a);
                obj.fill = (_a = a.fill) !== null && _a !== void 0 ? _a : symbol.attribute.fill;
                obj.opacity = (_b = a.opacity) !== null && _b !== void 0 ? _b : symbol.attribute.opacity;
                obj.fillOpacity = symbol.attribute.fillOpacity;
                obj.stroke = (_c = a.stroke) !== null && _c !== void 0 ? _c : symbol.attribute.stroke;
                obj.lineWidth = (_d = a.lineWidth) !== null && _d !== void 0 ? _d : symbol.attribute.lineWidth;
                a = obj;
            }
            const _runFill = () => {
                if (a.fill) {
                    if (fillCb) {
                        fillCb(context, symbol.attribute, symbolAttribute);
                    }
                    else {
                        context.setCommonStyle(symbol, a, originX - x, originY - y, symbolAttribute);
                        context.fill();
                    }
                }
            };
            const _runStroke = () => {
                if (a.stroke) {
                    if (strokeCb) {
                        strokeCb(context, symbol.attribute, symbolAttribute);
                    }
                    else if (sVisible && clipRange >= 1) {
                        context.setStrokeStyle(symbol, a, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute);
                        context.stroke();
                    }
                }
            };
            if (!fillStrokeOrder) {
                _runFill();
                _runStroke();
            }
            else {
                _runStroke();
                _runFill();
            }
        };
        let _x = x;
        let _y = y;
        let _z = z;
        const camera = context.camera;
        if (keepDirIn3d && camera && context.project) {
            const p = context.project(x, y, z);
            context.camera = null;
            isArray(size) ? [size[0] * scaleX, size[1] * scaleY] : size * scaleX;
            _x = p.x;
            _y = p.y;
            _z = undefined;
        }
        if (parsedPath.draw(context, size, _x, _y, _z, callback) === false) {
            context.closePath();
        }
        context.camera = camera;
        context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute);
        this.beforeRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
        if (!fillStrokeOrder) {
            this._runFill(symbol, context, x, y, symbolAttribute, doFill, fVisible, originX, originY, parsedPath, fillCb);
            this._runStroke(symbol, context, x, y, symbolAttribute, doStroke, sVisible, originX, originY, parsedPath, clipRange, scaleX, scaleY, strokeCb);
        }
        else {
            this._runStroke(symbol, context, x, y, symbolAttribute, doStroke, sVisible, originX, originY, parsedPath, clipRange, scaleX, scaleY, strokeCb);
            this._runFill(symbol, context, x, y, symbolAttribute, doFill, fVisible, originX, originY, parsedPath, fillCb);
        }
        this.afterRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
    }
    _runFill(symbol, context, x, y, symbolAttribute, doFill, fVisible, originX, originY, parsedPath, fillCb) {
        if (doFill && !parsedPath.isSvg) {
            if (fillCb) {
                fillCb(context, symbol.attribute, symbolAttribute);
            }
            else if (fVisible) {
                context.setCommonStyle(symbol, symbol.attribute, originX - x, originY - y, symbolAttribute);
                context.fill();
            }
        }
    }
    _runStroke(symbol, context, x, y, symbolAttribute, doStroke, sVisible, originX, originY, parsedPath, clipRange, scaleX, scaleY, strokeCb) {
        if (doStroke && !parsedPath.isSvg) {
            if (strokeCb) {
                strokeCb(context, symbol.attribute, symbolAttribute);
            }
            else if (sVisible && clipRange >= 1) {
                context.setStrokeStyle(symbol, symbol.attribute, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute);
                context.stroke();
            }
        }
    }
    draw(symbol, renderService, drawContext, params) {
        const symbolAttribute = getTheme(symbol, params === null || params === void 0 ? void 0 : params.theme).symbol;
        this._draw(symbol, symbolAttribute, false, drawContext, params);
    }
};
DefaultCanvasSymbolRender = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(SymbolRenderContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultCanvasSymbolRender);

class DefaultBoundsAllocate {
    constructor() {
        this.pools = [];
        for (let i = 0; i < 10; i++) {
            this.pools.push(new AABBBounds());
        }
    }
    allocate(x1, y1, x2, y2) {
        if (!this.pools.length) {
            return new AABBBounds().setValue(x1, y1, x2, y2);
        }
        const b = this.pools.pop();
        b.x1 = x1;
        b.y1 = y1;
        b.x2 = x2;
        b.y2 = y2;
        return b;
    }
    allocateByObj(b) {
        if (!this.pools.length) {
            return new AABBBounds(b);
        }
        const _b = this.pools.pop();
        _b.x1 = b.x1;
        _b.y1 = b.y1;
        _b.x2 = b.x2;
        _b.y2 = b.y2;
        return _b;
    }
    free(b) {
        this.pools.push(b);
    }
    get length() {
        return this.pools.length;
    }
    release(...params) {
        this.pools = [];
    }
}
const boundsAllocate = new DefaultBoundsAllocate();

class DefaultTextBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
    constructor() {
        super(...arguments);
        this.time = BaseRenderContributionTime.beforeFillStroke;
    }
    drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
        var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const { backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit, backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio } = graphic.attribute;
        let { background } = graphic.attribute;
        if (!background) {
            return;
        }
        let matrix;
        const save = () => {
            if (graphic.type === 'richtext') {
                matrix = context.currentMatrix.clone();
                context.restore();
                context.save();
                context.setTransformForCurrent();
            }
        };
        const restore = () => {
            if (graphic.type === 'richtext') {
                context.restore();
                context.save();
                matrix && context.setTransformFromMatrix(matrix, true, 1);
            }
        };
        save();
        let b;
        const shouldReCalBounds = isObject(background) && background.background;
        const onlyTranslate = graphic.transMatrix.onlyTranslate();
        if (shouldReCalBounds) {
            const _b = graphic.AABBBounds;
            const x = ((_a = background.x) !== null && _a !== void 0 ? _a : _b.x1) + ((_c = background.dx) !== null && _c !== void 0 ? _c : 0);
            const y = ((_d = background.y) !== null && _d !== void 0 ? _d : _b.y1) + ((_e = background.dy) !== null && _e !== void 0 ? _e : 0);
            const w = (_f = background.width) !== null && _f !== void 0 ? _f : _b.width();
            const h = (_g = background.height) !== null && _g !== void 0 ? _g : _b.height();
            b = boundsAllocate.allocate(x, y, x + w, y + h);
            background = background.background;
            if (!onlyTranslate) {
                const w = b.width();
                const h = b.height();
                b.set(((_h = background.x) !== null && _h !== void 0 ? _h : 0) + ((_j = background.dx) !== null && _j !== void 0 ? _j : 0), ((_k = background.y) !== null && _k !== void 0 ? _k : 0) + ((_l = background.dy) !== null && _l !== void 0 ? _l : 0), w, h);
            }
        }
        else {
            b = graphic.AABBBounds;
            if (!onlyTranslate) {
                b = getTextBounds(Object.assign(Object.assign({}, graphic.attribute), { angle: 0, scaleX: 1, scaleY: 1, x: 0, y: 0, dx: 0, dy: 0 })).clone();
            }
        }
        if (graphic.backgroundImg && graphic.resources) {
            const res = graphic.resources.get(background);
            if (res.state !== 'success' || !res.data) {
                restore();
                return;
            }
            context.highPerformanceSave();
            if (!onlyTranslate) ;
            else {
                context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);
            }
            context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute);
            this.doDrawImage(context, res.data, b, { backgroundMode, backgroundFit, backgroundKeepAspectRatio });
            context.highPerformanceRestore();
            context.setTransformForCurrent();
        }
        else {
            const { backgroundCornerRadius } = graphic.attribute;
            context.highPerformanceSave();
            context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute);
            context.fillStyle = background;
            if (backgroundCornerRadius) {
                createRectPath(context, b.x1, b.y1, b.width(), b.height(), backgroundCornerRadius, true);
                context.fill();
            }
            else {
                context.fillRect(b.x1, b.y1, b.width(), b.height());
            }
            context.highPerformanceRestore();
        }
        if (shouldReCalBounds) {
            boundsAllocate.free(b);
        }
        restore();
    }
}
const defaultTextBackgroundRenderContribution = new DefaultTextBackgroundRenderContribution();

let DefaultCanvasTextRender = class DefaultCanvasTextRender extends BaseRender {
    constructor(graphicRenderContributions) {
        super();
        this.graphicRenderContributions = graphicRenderContributions;
        this.numberType = TEXT_NUMBER_TYPE;
        this.builtinContributions = [defaultTextBackgroundRenderContribution];
        this.init(graphicRenderContributions);
    }
    drawShape(text, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a, _b, _c;
        const textAttribute = getTheme(text, params === null || params === void 0 ? void 0 : params.theme).text;
        const { text: str, underline = textAttribute.underline, lineThrough = textAttribute.lineThrough, keepDirIn3d = textAttribute.keepDirIn3d, direction = textAttribute.direction, fontSize = textAttribute.fontSize, verticalMode = textAttribute.verticalMode, x: originX = textAttribute.x, y: originY = textAttribute.y } = text.attribute;
        const lineHeight = (_a = calculateLineHeight(text.attribute.lineHeight, fontSize)) !== null && _a !== void 0 ? _a : fontSize;
        const data = this.valid(text, textAttribute, fillCb, strokeCb);
        if (!data) {
            return;
        }
        const { fVisible, sVisible, doFill, doStroke } = data;
        const transform3dMatrixToContextMatrix = !keepDirIn3d;
        const z = this.z || 0;
        context.beginPath();
        context.setShadowBlendStyle && context.setShadowBlendStyle(text, text.attribute, textAttribute);
        this.beforeRenderStep(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb);
        transform3dMatrixToContextMatrix && this.transformUseContext2d(text, textAttribute, z, context);
        const drawText = (t, offsetX, offsetY, direction) => {
            let _x = x + offsetX;
            const _y = y + offsetY;
            if (direction) {
                context.highPerformanceSave();
                _x += fontSize;
                const matrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0);
                matrix.rotateByCenter(Math.PI / 2, _x, _y);
                context.transformFromMatrix(matrix, true);
                matrixAllocate.free(matrix);
            }
            if (doStroke) {
                if (strokeCb) {
                    strokeCb(context, text.attribute, textAttribute);
                }
                else if (sVisible) {
                    context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute);
                    context.strokeText(t, _x, _y, z);
                }
            }
            if (doFill) {
                if (fillCb) {
                    fillCb(context, text.attribute, textAttribute);
                }
                else if (fVisible) {
                    context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute);
                    context.fillText(t, _x, _y, z);
                }
            }
            if (direction) {
                context.highPerformanceRestore();
                context.setTransformForCurrent();
            }
        };
        context.setTextStyleWithoutAlignBaseline(text.attribute, textAttribute, z);
        if (direction === 'horizontal') {
            const { multilineLayout } = text;
            if (!multilineLayout) {
                context.highPerformanceRestore();
                return;
            }
            const { xOffset, yOffset } = multilineLayout.bbox;
            if (doStroke) {
                if (strokeCb) {
                    strokeCb(context, text.attribute, textAttribute);
                }
                else if (sVisible) {
                    context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute);
                    multilineLayout.lines.forEach(line => {
                        context.strokeText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z);
                    });
                }
            }
            if (doFill) {
                if (fillCb) {
                    fillCb(context, text.attribute, textAttribute);
                }
                else if (fVisible) {
                    context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute);
                    multilineLayout.lines.forEach(line => {
                        context.fillText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z);
                        this.drawUnderLine(underline, lineThrough, text, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, line.descent, (line.descent - line.ascent) / 2, z, textAttribute, context, {
                            width: line.width
                        });
                    });
                }
            }
        }
        else {
            let { textAlign = textAttribute.textAlign, textBaseline = textAttribute.textBaseline } = text.attribute;
            if (!verticalMode) {
                const t = textAlign;
                textAlign = (_b = text.getBaselineMapAlign()[textBaseline]) !== null && _b !== void 0 ? _b : 'left';
                textBaseline = (_c = text.getAlignMapBaseline()[t]) !== null && _c !== void 0 ? _c : 'top';
            }
            text.tryUpdateAABBBounds();
            const cache = text.cache;
            const { verticalList } = cache;
            context.textAlign = 'left';
            context.textBaseline = 'top';
            const totalHeight = lineHeight * verticalList.length;
            let totalW = 0;
            verticalList.forEach(verticalData => {
                const _w = verticalData.reduce((a, b) => a + (b.width || 0), 0);
                totalW = max(_w, totalW);
            });
            let offsetY = 0;
            let offsetX = 0;
            if (textBaseline === 'bottom') {
                offsetX = -totalHeight;
            }
            else if (textBaseline === 'middle') {
                offsetX = -totalHeight / 2;
            }
            if (textAlign === 'center') {
                offsetY -= totalW / 2;
            }
            else if (textAlign === 'right') {
                offsetY -= totalW;
            }
            verticalList.forEach((verticalData, i) => {
                const currentW = verticalData.reduce((a, b) => a + (b.width || 0), 0);
                const dw = totalW - currentW;
                let currentOffsetY = offsetY;
                if (textAlign === 'center') {
                    currentOffsetY += dw / 2;
                }
                else if (textAlign === 'right') {
                    currentOffsetY += dw;
                }
                verticalData.forEach(item => {
                    const { text, width, direction } = item;
                    drawText(text, totalHeight - (i + 1) * lineHeight + offsetX, currentOffsetY, direction);
                    currentOffsetY += width;
                });
            });
        }
        transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text, textAttribute, z, context);
        this.afterRenderStep(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb);
    }
    draw(text, renderService, drawContext, params) {
        const textAttribute = getTheme(text, params === null || params === void 0 ? void 0 : params.theme).text;
        const { keepDirIn3d = textAttribute.keepDirIn3d } = text.attribute;
        const computed3dMatrix = !keepDirIn3d;
        this._draw(text, textAttribute, computed3dMatrix, drawContext, params);
    }
    drawUnderLine(underline, lineThrough, text, anchorX, anchorY, offsetUnderLineY, offsetThroughLineY, z, textAttribute, context, multiOption) {
        if (lineThrough + underline <= 0) {
            return;
        }
        const { textAlign = textAttribute.textAlign, fill = textAttribute.fill, opacity = textAttribute.opacity, underlineOffset = textAttribute.underlineOffset, underlineDash = textAttribute.underlineDash, fillOpacity = textAttribute.fillOpacity } = text.attribute;
        const isMulti = !isNil(multiOption);
        const w = isMulti ? multiOption.width : text.clipedWidth;
        const offsetX = isMulti ? 0 : textDrawOffsetX(textAlign, w);
        const attribute = { lineWidth: 0, stroke: fill, opacity, strokeOpacity: fillOpacity };
        if (underline) {
            attribute.lineWidth = underline;
            context.setStrokeStyle(text, attribute, anchorX, anchorY, textAttribute);
            underlineDash && context.setLineDash(underlineDash);
            context.beginPath();
            const dy = anchorY + offsetUnderLineY + underlineOffset;
            context.moveTo(anchorX + offsetX, dy, z);
            context.lineTo(anchorX + offsetX + w, dy, z);
            context.stroke();
        }
        if (lineThrough) {
            attribute.lineWidth = lineThrough;
            context.setStrokeStyle(text, attribute, anchorX, anchorY, textAttribute);
            context.beginPath();
            const dy = anchorY + offsetThroughLineY;
            context.moveTo(anchorX + offsetX, dy, z);
            context.lineTo(anchorX + offsetX + w, dy, z);
            context.stroke();
        }
    }
};
DefaultCanvasTextRender = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(TextRenderContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultCanvasTextRender);

let AbstractGraphicRender = class AbstractGraphicRender {
};
AbstractGraphicRender = __decorate([
    injectable()
], AbstractGraphicRender);

function drawPolygon(path, points, x, y) {
    if (!points || !points.length) {
        return;
    }
    path.moveTo(points[0].x + x, points[0].y + y);
    for (let i = 1; i < points.length; i++) {
        path.lineTo(points[i].x + x, points[i].y + y);
    }
}
function drawRoundedPolygon(path, points, x, y, cornerRadius, closePath = true) {
    var _a;
    if (points.length < 3) {
        drawPolygon(path, points, x, y);
        return;
    }
    let startI = 0;
    let endI = points.length - 1;
    if (!closePath) {
        startI += 1;
        endI -= 1;
        path.moveTo(points[0].x + x, points[0].y + y);
    }
    for (let i = startI; i <= endI; i++) {
        const p1 = points[i === 0 ? endI : (i - 1) % points.length];
        const angularPoint = points[i % points.length];
        const p2 = points[(i + 1) % points.length];
        const dx1 = angularPoint.x - p1.x;
        const dy1 = angularPoint.y - p1.y;
        const dx2 = angularPoint.x - p2.x;
        const dy2 = angularPoint.y - p2.y;
        const angle = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2;
        const tan = Math.abs(Math.tan(angle));
        let radius = Array.isArray(cornerRadius) ? (_a = cornerRadius[i % points.length]) !== null && _a !== void 0 ? _a : 0 : cornerRadius;
        let segment = radius / tan;
        const length1 = getLength(dx1, dy1);
        const length2 = getLength(dx2, dy2);
        const length = Math.min(length1, length2);
        if (segment > length) {
            segment = length;
            radius = length * tan;
        }
        const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1);
        const p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2);
        const dx = angularPoint.x * 2 - p1Cross.x - p2Cross.x;
        const dy = angularPoint.y * 2 - p1Cross.y - p2Cross.y;
        const L = getLength(dx, dy);
        const d = getLength(segment, radius);
        const circlePoint = getProportionPoint(angularPoint, d, L, dx, dy);
        let startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);
        const endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);
        let sweepAngle = endAngle - startAngle;
        if (sweepAngle < 0) {
            startAngle = endAngle;
            sweepAngle = -sweepAngle;
        }
        if (sweepAngle > Math.PI) {
            sweepAngle = sweepAngle - Math.PI;
        }
        if (i === 0) {
            path.moveTo(p1Cross.x + x, p1Cross.y + y);
        }
        else {
            path.lineTo(p1Cross.x + x, p1Cross.y + y);
        }
        if (sweepAngle) {
            path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius);
        }
        path.lineTo(p2Cross.x + x, p2Cross.y + y);
    }
    if (!closePath) {
        path.lineTo(points[endI + 1].x + x, points[endI + 1].y + y);
    }
}
function getLength(dx, dy) {
    return Math.sqrt(dx * dx + dy * dy);
}
function getProportionPoint(point, segment, length, dx, dy) {
    const factor = segment / length;
    return {
        x: point.x - dx * factor,
        y: point.y - dy * factor
    };
}

const defaultPolygonTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultPolygonBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

let DefaultCanvasPolygonRender = class DefaultCanvasPolygonRender extends BaseRender {
    constructor(graphicRenderContributions) {
        super();
        this.graphicRenderContributions = graphicRenderContributions;
        this.numberType = POLYGON_NUMBER_TYPE;
        this.builtinContributions = [defaultPolygonBackgroundRenderContribution, defaultPolygonTextureRenderContribution];
        this.init(graphicRenderContributions);
    }
    drawShape(polygon, context, x, y, drawContext, params, fillCb, strokeCb) {
        const polygonAttribute = getTheme(polygon, params === null || params === void 0 ? void 0 : params.theme).polygon;
        const { points = polygonAttribute.points, cornerRadius = polygonAttribute.cornerRadius, x: originX = polygonAttribute.x, y: originY = polygonAttribute.y, closePath = polygonAttribute.closePath, fillStrokeOrder = polygonAttribute.fillStrokeOrder } = polygon.attribute;
        const data = this.valid(polygon, polygonAttribute, fillCb, strokeCb);
        if (!data) {
            return;
        }
        const { fVisible, sVisible, doFill, doStroke } = data;
        context.beginPath();
        if (cornerRadius <= 0 || (isArray(cornerRadius) && cornerRadius.every(num => num === 0))) {
            drawPolygon(context.camera ? context : context.nativeContext, points, x, y);
        }
        else {
            drawRoundedPolygon(context.camera ? context : context.nativeContext, points, x, y, cornerRadius, closePath);
        }
        closePath && context.closePath();
        context.setShadowBlendStyle && context.setShadowBlendStyle(polygon, polygon.attribute, polygonAttribute);
        this.beforeRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
        const _runFill = () => {
            if (doFill) {
                if (fillCb) {
                    fillCb(context, polygon.attribute, polygonAttribute);
                }
                else if (fVisible) {
                    context.setCommonStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute);
                    context.fill();
                }
            }
        };
        const _runStroke = () => {
            if (doStroke) {
                if (strokeCb) {
                    strokeCb(context, polygon.attribute, polygonAttribute);
                }
                else if (sVisible) {
                    context.setStrokeStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute);
                    context.stroke();
                }
            }
        };
        if (!fillStrokeOrder) {
            _runFill();
            _runStroke();
        }
        else {
            _runStroke();
            _runFill();
        }
        this.afterRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
    }
    draw(polygon, renderService, drawContext, params) {
        const polygonAttribute = getTheme(polygon, params === null || params === void 0 ? void 0 : params.theme).polygon;
        this._draw(polygon, polygonAttribute, false, drawContext, params);
    }
};
DefaultCanvasPolygonRender = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(PolygonRenderContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultCanvasPolygonRender);

let DefaultCanvasGroupRender = class DefaultCanvasGroupRender {
    constructor(groupRenderContribitions) {
        this.groupRenderContribitions = groupRenderContribitions;
        this.numberType = GROUP_NUMBER_TYPE;
    }
    reInit() {
        this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [];
        this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution);
    }
    drawShape(group, context, x, y, drawContext, params, fillCb, strokeCb, groupAttribute) {
        const { clip, fill, stroke, background } = group.attribute;
        if (!(clip || fill || stroke || background)) {
            return;
        }
        groupAttribute = groupAttribute !== null && groupAttribute !== void 0 ? groupAttribute : getTheme(group, params === null || params === void 0 ? void 0 : params.theme).group;
        const { opacity = groupAttribute.opacity, width = groupAttribute.width, height = groupAttribute.height, fillOpacity = groupAttribute.fillOpacity, strokeOpacity = groupAttribute.strokeOpacity, cornerRadius = groupAttribute.cornerRadius, path = groupAttribute.path, lineWidth = groupAttribute.lineWidth, visible = groupAttribute.visible, fillStrokeOrder = groupAttribute.fillStrokeOrder, cornerType = groupAttribute.cornerType, x: originX = groupAttribute.x, y: originY = groupAttribute.y } = group.attribute;
        const fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill);
        const sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height);
        const doFill = runFill(fill, background);
        const doStroke = runStroke(stroke, lineWidth);
        if (!(group.valid && visible)) {
            return;
        }
        if (!clip) {
            if (!(doFill || doStroke)) {
                return;
            }
            if (!(fVisible || sVisible || fillCb || strokeCb || background)) {
                return;
            }
        }
        if (path && path.length && drawContext.drawContribution) {
            const disableFill = context.disableFill;
            const disableStroke = context.disableStroke;
            const disableBeginPath = context.disableBeginPath;
            context.disableFill = true;
            context.disableStroke = true;
            context.disableBeginPath = true;
            path.forEach(g => {
                const rc = drawContext.drawContribution.getRenderContribution(g);
                rc.draw(g, drawContext.renderService, drawContext, params);
            });
            context.disableFill = disableFill;
            context.disableStroke = disableStroke;
            context.disableBeginPath = disableBeginPath;
        }
        else if (cornerRadius === 0 || (isArray(cornerRadius) && cornerRadius.every(num => num === 0))) {
            context.beginPath();
            context.rect(x, y, width, height);
        }
        else {
            context.beginPath();
            createRectPath(context, x, y, width, height, cornerRadius, cornerType !== 'bevel');
        }
        if (!this._groupRenderContribitions) {
            this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [];
            this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution);
        }
        const doFillOrStroke = {
            doFill,
            doStroke
        };
        context.setShadowBlendStyle && context.setShadowBlendStyle(group, group.attribute, groupAttribute);
        this._groupRenderContribitions.forEach(c => {
            if (c.time === BaseRenderContributionTime.beforeFillStroke) {
                c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
            }
        });
        if (clip) {
            context.clip();
        }
        const _runFill = () => {
            if (doFillOrStroke.doFill) {
                if (fillCb) {
                    fillCb(context, group.attribute, groupAttribute);
                }
                else if (fVisible) {
                    context.setCommonStyle(group, group.attribute, originX - x, originY - y, groupAttribute);
                    context.fill();
                }
            }
        };
        const _runStroke = () => {
            if (doFillOrStroke.doStroke) {
                if (strokeCb) {
                    strokeCb(context, group.attribute, groupAttribute);
                }
                else if (sVisible) {
                    context.setStrokeStyle(group, group.attribute, originX - x, originY - y, groupAttribute);
                    context.stroke();
                }
            }
        };
        if (!fillStrokeOrder) {
            _runFill();
            _runStroke();
        }
        else {
            _runStroke();
            _runFill();
        }
        this._groupRenderContribitions.forEach(c => {
            if (c.time === BaseRenderContributionTime.afterFillStroke) {
                c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb);
            }
        });
    }
    draw(group, renderService, drawContext, params) {
        var _a, _b;
        const { context } = drawContext;
        if (!context) {
            return;
        }
        const { clip, baseOpacity = 1, drawMode } = group.attribute;
        const lastNativeContext = context.nativeContext;
        const lastNativeCanvas = context.canvas.nativeCanvas;
        if (drawMode > 0) {
            const { x, y, width, height } = group.attribute;
            const canvas = context.canvas;
            const newCanvas = application.global.createCanvas({ width: canvas.width, height: canvas.height, dpr: 1 });
            const newContext = newCanvas.getContext('2d');
            const transform = context.nativeContext.getTransform();
            newContext.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f);
            if (drawMode === 1) {
                newContext.save();
                newContext.clearRect(0, 0, canvas.width, canvas.height);
                newContext.beginPath();
                newContext.rect(x, y, width, height);
                newContext.clip();
                newContext.drawImage(canvas.nativeCanvas, 0, 0, canvas.width, canvas.height, 0, 0, canvas.displayWidth, canvas.displayHeight);
                newContext.restore();
            }
            context.nativeContext = newContext;
            canvas.nativeCanvas = newCanvas;
        }
        if (clip) {
            context.save();
        }
        else {
            context.highPerformanceSave();
        }
        const baseGlobalAlpha = context.baseGlobalAlpha;
        context.baseGlobalAlpha *= baseOpacity;
        const lastModelMatrix = context.modelMatrix;
        const camera = context.camera;
        if (camera) {
            const groupAttribute = getTheme(group, params === null || params === void 0 ? void 0 : params.theme).group;
            const nextModelMatrix = mat4Allocate.allocate();
            const modelMatrix = mat4Allocate.allocate();
            getModelMatrix(modelMatrix, group, groupAttribute);
            if (lastModelMatrix) {
                multiplyMat4Mat4(nextModelMatrix, lastModelMatrix, modelMatrix);
            }
            else {
                multiplyMat4Mat4(nextModelMatrix, nextModelMatrix, modelMatrix);
            }
            context.modelMatrix = nextModelMatrix;
            mat4Allocate.free(modelMatrix);
            context.setTransform(1, 0, 0, 1, 0, 0, true);
        }
        else {
            context.transformFromMatrix(group.transMatrix, true);
        }
        context.beginPath();
        if (params.skipDraw) {
            this.drawShape(group, context, 0, 0, drawContext, params, () => false, () => false);
        }
        else {
            this.drawShape(group, context, 0, 0, drawContext, null, null, null);
        }
        const { scrollX, scrollY } = group.attribute;
        if (scrollX || scrollY) {
            context.translate(scrollX, scrollY);
        }
        let p;
        if (params && params.renderInGroup) {
            p = params.renderInGroup((_a = params.renderInGroupParams) === null || _a === void 0 ? void 0 : _a.skipSort, group, drawContext, (_b = params.renderInGroupParams) === null || _b === void 0 ? void 0 : _b.nextM);
        }
        if (context.modelMatrix !== lastModelMatrix) {
            mat4Allocate.free(context.modelMatrix);
        }
        context.modelMatrix = lastModelMatrix;
        context.baseGlobalAlpha = baseGlobalAlpha;
        if (drawMode > 0) {
            const { x, y, width, height } = group.attribute;
            const newContext = context.nativeContext;
            const newCanvas = context.canvas.nativeCanvas;
            lastNativeContext.save();
            lastNativeContext.setTransform(context.dpr, 0, 0, context.dpr, 0, 0, true);
            if (drawMode === 1) {
                newContext.rect(x, y, width, height);
            }
            lastNativeContext.drawImage(newCanvas, 0, 0, newCanvas.width, newCanvas.height, 0, 0, context.canvas.displayWidth, context.canvas.displayHeight);
            const transform = newContext.getTransform();
            lastNativeContext.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f);
            context.nativeContext = lastNativeContext;
            context.canvas.nativeCanvas = lastNativeCanvas;
            lastNativeContext.restore();
        }
        if (p && p.then) {
            p.then(() => {
                if (clip) {
                    context.restore();
                }
                else {
                    context.highPerformanceRestore();
                }
            });
        }
        else {
            if (clip) {
                context.restore();
            }
            else {
                context.highPerformanceRestore();
            }
        }
    }
};
DefaultCanvasGroupRender = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(GroupRenderContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultCanvasGroupRender);

const repeatStr = ['', 'repeat-x', 'repeat-y', 'repeat'];
let DefaultCanvasImageRender = class DefaultCanvasImageRender extends BaseRender {
    constructor(graphicRenderContributions) {
        super();
        this.graphicRenderContributions = graphicRenderContributions;
        this.numberType = IMAGE_NUMBER_TYPE;
        this.builtinContributions = [defaultImageRenderContribution, defaultImageBackgroundRenderContribution];
        this.init(graphicRenderContributions);
    }
    drawShape(image, context, x, y, drawContext, params, fillCb, strokeCb) {
        const imageAttribute = getTheme(image).image;
        const { repeatX = imageAttribute.repeatX, repeatY = imageAttribute.repeatY, x: originX = imageAttribute.x, y: originY = imageAttribute.y, cornerRadius = imageAttribute.cornerRadius, fillStrokeOrder = imageAttribute.fillStrokeOrder, cornerType = imageAttribute.cornerType, image: url } = image.attribute;
        const data = this.valid(image, imageAttribute, fillCb);
        if (!data) {
            return;
        }
        const { fVisible, sVisible, doFill, doStroke } = data;
        if (!url || !image.resources) {
            return;
        }
        const res = image.resources.get(url);
        if (res.state !== 'success') {
            return;
        }
        const width = image.width;
        const height = image.height;
        context.beginPath();
        let needRestore = false;
        if (cornerRadius === 0 || (isArray(cornerRadius) && cornerRadius.every(num => num === 0))) {
            context.rect(x, y, width, height);
        }
        else {
            createRectPath(context, x, y, width, height, cornerRadius, cornerType !== 'bevel');
            needRestore = true;
        }
        context.setShadowBlendStyle && context.setShadowBlendStyle(image, image.attribute, imageAttribute);
        const _runFill = () => {
            if (doFill) {
                if (fillCb) {
                    fillCb(context, image.attribute, imageAttribute);
                }
                else if (fVisible) {
                    context.setCommonStyle(image, image.attribute, x, y, imageAttribute);
                    let repeat = 0;
                    if (repeatX === 'repeat') {
                        repeat |= 0b0001;
                    }
                    if (repeatY === 'repeat') {
                        repeat |= 0b0010;
                    }
                    if (repeat) {
                        const pattern = context.createPattern(res.data, repeatStr[repeat]);
                        context.fillStyle = pattern;
                        context.translate(x, y, true);
                        context.fillRect(0, 0, width, height);
                        context.translate(-x, -y, true);
                    }
                    else {
                        context.drawImage(res.data, x, y, width, height);
                    }
                }
            }
        };
        const _runStroke = () => {
            if (doStroke) {
                if (strokeCb) {
                    strokeCb(context, image.attribute, imageAttribute);
                }
                else if (sVisible) {
                    context.setStrokeStyle(image, image.attribute, originX - x, originY - y, imageAttribute);
                    context.stroke();
                }
            }
        };
        if (!fillStrokeOrder) {
            if (needRestore) {
                context.save();
                context.clip();
            }
            this.beforeRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb);
            _runFill();
            if (needRestore) {
                context.restore();
            }
            _runStroke();
        }
        else {
            _runStroke();
            if (needRestore) {
                context.save();
                context.clip();
            }
            this.beforeRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb);
            _runFill();
            if (needRestore) {
                context.restore();
            }
        }
        this.afterRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb);
    }
    draw(image, renderService, drawContext) {
        const { image: url } = image.attribute;
        if (!url || !image.resources) {
            return;
        }
        const res = image.resources.get(url);
        if (res.state === 'loading' && isString(url)) {
            ResourceLoader.improveImageLoading(url);
            return;
        }
        else if (res.state !== 'success') {
            return;
        }
        const { context } = renderService.drawParams;
        if (!context) {
            return;
        }
        const imageAttribute = getTheme(image).image;
        this._draw(image, imageAttribute, false, drawContext);
    }
};
DefaultCanvasImageRender = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(ImageRenderContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultCanvasImageRender);

const IncrementalDrawContribution = Symbol.for('IncrementalDrawContribution');
const ArcRender = Symbol.for('ArcRender');
const Arc3dRender = Symbol.for('Arc3dRender');
const AreaRender = Symbol.for('AreaRender');
const CircleRender = Symbol.for('CircleRender');
const GraphicRender = Symbol.for('GraphicRender');
const GroupRender = Symbol.for('GroupRender');
const LineRender = Symbol.for('LineRender');
const PathRender = Symbol.for('PathRender');
const PolygonRender = Symbol.for('PolygonRender');
const RectRender = Symbol.for('RectRender');
const Rect3DRender = Symbol.for('Rect3DRender');
const SymbolRender = Symbol.for('SymbolRender');
const TextRender = Symbol.for('TextRender');
const RichTextRender = Symbol.for('RichTextRender');
const Pyramid3dRender = Symbol.for('Pyramid3dRender');
const GlyphRender = Symbol.for('GlyphRender');
const ImageRender = Symbol.for('ImageRender');
const RenderSelector = Symbol.for('RenderSelector');
const DrawContribution = Symbol.for('DrawContribution');
const StarRender = Symbol.for('StarRender');

const draw3dItem = (context, graphic, callback, output) => {
    let isPie = false;
    let is3d = false;
    graphic.forEachChildren((c) => {
        isPie = c.numberType === ARC3D_NUMBER_TYPE;
        return !isPie;
    });
    graphic.forEachChildren((c) => {
        is3d = !!c.findFace;
        return !is3d;
    });
    let result;
    if (isPie) {
        const children = graphic.getChildren();
        const sortedChildren = [...children];
        sortedChildren.sort((a, b) => {
            var _a, _b, _c, _d;
            let angle1 = ((_b = (_a = a.attribute.startAngle) !== null && _a !== void 0 ? _a : 0 + a.attribute.endAngle) !== null && _b !== void 0 ? _b : 0) / 2;
            let angle2 = ((_d = (_c = b.attribute.startAngle) !== null && _c !== void 0 ? _c : 0 + b.attribute.endAngle) !== null && _d !== void 0 ? _d : 0) / 2;
            while (angle1 < 0) {
                angle1 += pi2;
            }
            while (angle2 < 0) {
                angle2 += pi2;
            }
            return angle2 - angle1;
        });
        sortedChildren.forEach(c => {
            c._next = null;
            c._prev = null;
        });
        graphic.removeAllChild();
        graphic.update();
        sortedChildren.forEach(c => {
            graphic.appendChild(c);
        });
        output.hack_pieFace = 'outside';
        result = callback(isPie, is3d);
        if (!result || !result.graphic) {
            output.hack_pieFace = 'inside';
            result = callback(isPie, is3d);
        }
        if (!result || !result.graphic) {
            output.hack_pieFace = 'top';
            result = callback(isPie, is3d);
        }
        graphic.removeAllChild();
        children.forEach(c => {
            c._next = null;
            c._prev = null;
        });
        children.forEach(c => {
            graphic.appendChild(c);
        });
    }
    else if (is3d) {
        const children = graphic.getChildren();
        const zChildren = children.map(g => {
            const face3d = g.findFace();
            const vertices = face3d.vertices;
            const viewdVerticesZ = vertices.map(v => {
                var _a;
                return context.view(v[0], v[1], (_a = v[2] + g.attribute.z) !== null && _a !== void 0 ? _a : 0)[2];
            });
            const ave_z = viewdVerticesZ.reduce((a, b) => a + b, 0);
            return {
                ave_z,
                g
            };
        });
        zChildren.sort((a, b) => b.ave_z - a.ave_z);
        graphic.removeAllChild();
        zChildren.forEach(i => {
            i.g._next = null;
            i.g._prev = null;
        });
        graphic.update();
        zChildren.forEach(i => {
            graphic.add(i.g);
        });
        result = callback(isPie, is3d);
        graphic.removeAllChild();
        children.forEach(g => {
            g._next = null;
            g._prev = null;
        });
        graphic.update();
        children.forEach(g => {
            graphic.add(g);
        });
    }
    else {
        result = callback(isPie, is3d);
    }
    return result;
};

const DrawItemInterceptor = Symbol.for('DrawItemInterceptor');
const tempDirtyBounds = new AABBBounds();
const tempBackupDirtyBounds = new AABBBounds();
class ShadowRootDrawItemInterceptorContribution {
    constructor() {
        this.order = 1;
    }
    afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (graphic.attribute.shadowRootIdx == null &&
            graphic.shadowRoot &&
            graphic.shadowRoot.attribute.shadowRootIdx < 0) {
            return false;
        }
        if (graphic.attribute.shadowRootIdx > 0 ||
            !graphic.attribute.shadowRootIdx ||
            (graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx > 0)) {
            this.drawItem(graphic, renderService, drawContext, drawContribution, params);
        }
        return false;
    }
    beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (graphic.attribute.shadowRootIdx == null &&
            graphic.shadowRoot &&
            graphic.shadowRoot.attribute.shadowRootIdx > 0) {
            return false;
        }
        if (graphic.attribute.shadowRootIdx < 0 || (graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx < 0)) {
            this.drawItem(graphic, renderService, drawContext, drawContribution, params);
        }
        return false;
    }
    drawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.shadowRoot) {
            return false;
        }
        const { context } = drawContext;
        context.highPerformanceSave();
        context.transformFromMatrix(graphic.transMatrix, true);
        if (drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
            tempDirtyBounds.copy(drawContribution.dirtyBounds);
            tempBackupDirtyBounds.copy(drawContribution.backupDirtyBounds);
            const m = graphic.globalTransMatrix.getInverse();
            drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m);
            drawContribution.backupDirtyBounds.copy(drawContribution.dirtyBounds);
        }
        drawContribution.renderGroup(graphic.shadowRoot, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0));
        context.highPerformanceRestore();
        if (drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
            drawContribution.dirtyBounds.copy(tempDirtyBounds);
            drawContribution.backupDirtyBounds.copy(tempBackupDirtyBounds);
        }
        return true;
    }
}
class DebugDrawItemInterceptorContribution {
    constructor() {
        this.order = 1;
    }
    afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (graphic.attribute._debug_bounds) {
            this.drawItem(graphic, renderService, drawContext, drawContribution, params);
        }
        return false;
    }
    drawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.attribute._debug_bounds) {
            return false;
        }
        const { context } = drawContext;
        context.highPerformanceSave();
        graphic.parent && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);
        graphic.glyphHost &&
            graphic.glyphHost.parent &&
            context.setTransformFromMatrix(graphic.glyphHost.parent.globalTransMatrix, true);
        const b = graphic.AABBBounds;
        if (graphic.attribute._debug_bounds !== true) {
            graphic.attribute._debug_bounds(context, graphic);
        }
        context.strokeRect(b.x1, b.y1, b.width(), b.height());
        context.highPerformanceRestore();
        return true;
    }
}
let CommonDrawItemInterceptorContribution = class CommonDrawItemInterceptorContribution {
    constructor() {
        this.order = 1;
        this.interceptors = [
            new ShadowRootDrawItemInterceptorContribution(),
            new Canvas3DDrawItemInterceptor(),
            new InteractiveDrawItemInterceptorContribution(),
            new DebugDrawItemInterceptorContribution()
        ];
    }
    afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if ((!graphic.in3dMode || drawContext.in3dInterceptor) &&
            !graphic.shadowRoot &&
            !graphic.attribute._debug_bounds &&
            !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) {
            return false;
        }
        for (let i = 0; i < this.interceptors.length; i++) {
            if (this.interceptors[i].afterDrawItem &&
                this.interceptors[i].afterDrawItem(graphic, renderService, drawContext, drawContribution, params)) {
                return true;
            }
        }
        return false;
    }
    beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if ((!graphic.in3dMode || drawContext.in3dInterceptor) &&
            !graphic.shadowRoot &&
            !graphic.attribute._debug_bounds &&
            !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) {
            return false;
        }
        for (let i = 0; i < this.interceptors.length; i++) {
            if (this.interceptors[i].beforeDrawItem &&
                this.interceptors[i].beforeDrawItem(graphic, renderService, drawContext, drawContribution, params)) {
                return true;
            }
        }
        return false;
    }
};
CommonDrawItemInterceptorContribution = __decorate([
    injectable(),
    __metadata("design:paramtypes", [])
], CommonDrawItemInterceptorContribution);
class InteractiveDrawItemInterceptorContribution {
    constructor() {
        this.order = 1;
    }
    beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (this.processing) {
            return false;
        }
        if (graphic.baseGraphic) {
            return this.beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params);
        }
        return this.beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params);
    }
    beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params) {
        let interactiveGraphic = graphic.interactiveGraphic;
        if (graphic.attribute.globalZIndex) {
            if (!interactiveGraphic) {
                interactiveGraphic = graphic.clone();
                graphic.interactiveGraphic = interactiveGraphic;
                interactiveGraphic.baseGraphic = graphic;
            }
            interactiveGraphic.setAttributes({
                globalZIndex: 0,
                zIndex: graphic.attribute.globalZIndex
            }, false, { skipUpdateCallback: true });
            drawContext.stage.tryInitInteractiveLayer();
            const interactiveLayer = drawContext.stage.getLayer('_builtin_interactive');
            if (interactiveLayer) {
                const shadowRoot = this.getShadowRoot(interactiveLayer);
                shadowRoot.add(interactiveGraphic);
            }
            return true;
        }
        else if (interactiveGraphic) {
            drawContext.stage.tryInitInteractiveLayer();
            const interactiveLayer = drawContext.stage.getLayer('_builtin_interactive');
            if (interactiveLayer) {
                const shadowRoot = this.getShadowRoot(interactiveLayer);
                shadowRoot.removeChild(interactiveGraphic);
            }
            graphic.interactiveGraphic = null;
            interactiveGraphic.baseGraphic = null;
        }
        return false;
    }
    beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params) {
        const baseGraphic = graphic.baseGraphic;
        let intree = !!baseGraphic.stage;
        let _g = baseGraphic.parent;
        while (intree && _g) {
            if (_g.stage === _g) {
                break;
            }
            intree = !!_g.stage;
            _g = _g.parent;
        }
        if (!intree) {
            const interactiveLayer = drawContext.stage.getLayer('_builtin_interactive');
            if (interactiveLayer) {
                const shadowRoot = this.getShadowRoot(interactiveLayer);
                shadowRoot.removeChild(graphic);
            }
            return true;
        }
        if (baseGraphic) {
            this.processing = true;
            const { context } = drawContext;
            context.highPerformanceSave();
            context.setTransformFromMatrix(baseGraphic.parent.globalTransMatrix, true);
            baseGraphic.isContainer
                ? drawContribution.renderGroup(baseGraphic, drawContext, baseGraphic.parent.globalTransMatrix)
                : drawContribution.renderItem(baseGraphic, drawContext);
            context.highPerformanceRestore();
            this.processing = false;
            return true;
        }
        return false;
    }
    getShadowRoot(interactiveLayer) {
        var _a;
        let group = interactiveLayer.getElementById('_interactive_group');
        if (!group) {
            group = graphicCreator.CreateGraphic('group', {});
            group.id = '_interactive_group';
            interactiveLayer.add(group);
        }
        return (_a = group.shadowRoot) !== null && _a !== void 0 ? _a : group.attachShadow();
    }
}
class Canvas3DDrawItemInterceptor {
    constructor() {
        this.order = 1;
    }
    beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
        if (!graphic.in3dMode || drawContext.in3dInterceptor) {
            return false;
        }
        drawContext.in3dInterceptor = true;
        const { context, stage } = renderService.drawParams;
        context.canvas;
        context.save();
        this.initCanvasCtx(context);
        context.camera = stage.camera;
        const m = context.currentMatrix;
        m.a /= context.dpr;
        m.b /= context.dpr;
        m.c /= context.dpr;
        m.d /= context.dpr;
        m.e /= context.dpr;
        m.f /= context.dpr;
        const matrix = mat4Allocate.allocate();
        mat3Tomat4(matrix, m);
        const lastModelMatrix = context.modelMatrix;
        if (lastModelMatrix) {
            if (matrix) {
                const m = mat4Allocate.allocate();
                context.modelMatrix = multiplyMat4Mat4(m, lastModelMatrix, matrix);
            }
        }
        else {
            context.modelMatrix = matrix;
        }
        context.setTransform(1, 0, 0, 1, 0, 0, true);
        if (graphic.isContainer) {
            draw3dItem(context, graphic, (isPie, is3d) => {
                return drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix, !isPie && is3d);
            }, drawContext);
        }
        else {
            drawContribution.renderItem(graphic, drawContext);
        }
        context.camera = null;
        context.restore();
        if (context.modelMatrix !== lastModelMatrix) {
            mat4Allocate.free(context.modelMatrix);
        }
        context.modelMatrix = lastModelMatrix;
        drawContext.in3dInterceptor = false;
        return true;
    }
    initCanvasCtx(context) {
        context.setTransformForCurrent();
    }
}

const RenderService = Symbol.for('RenderService');
const BeforeRenderConstribution = Symbol.for('BeforeRenderConstribution');
let DefaultRenderService = class DefaultRenderService {
    constructor(drawContribution) {
        this.drawContribution = drawContribution;
    }
    prepare(updateBounds) {
        if (!updateBounds) {
            return;
        }
        this.renderTreeRoots.forEach(g => {
            this._prepare(g, updateBounds);
        });
        return;
    }
    _prepare(g, updateBounds) {
        g.forEachChildren(g => {
            this._prepare(g, updateBounds);
        });
        g.update({ bounds: updateBounds, trans: true });
    }
    prepareRenderList() {
        return;
    }
    beforeDraw(params) {
        return;
    }
    draw(params) {
        this.drawContribution.draw(this, Object.assign({}, this.drawParams));
    }
    afterDraw(params) {
        this.drawContribution.afterDraw && this.drawContribution.afterDraw(this, Object.assign({}, this.drawParams));
        return;
    }
    reInit() {
        this.drawContribution.reInit();
    }
    render(groups, params) {
        this.renderTreeRoots = groups;
        this.drawParams = params;
        const updateBounds = params.updateBounds;
        this.prepare(updateBounds);
        this.prepareRenderList();
        this.beforeDraw(params);
        this.draw(params);
        this.afterDraw(params);
        this.drawParams = null;
    }
};
DefaultRenderService = __decorate([
    injectable(),
    __param(0, inject(DrawContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultRenderService);

var renderModule$1 = new ContainerModule(bind => {
    bind(RenderService).to(DefaultRenderService);
});

const GraphicPicker = Symbol.for('GraphicPicker');
const PickerService = Symbol.for('PickerService');
const BoundsPicker = Symbol.for('BoundsPicker');
const GlobalPickerService = Symbol.for('GlobalPickerService');
const PickItemInterceptor = Symbol.for('PickItemInterceptor');
const PickServiceInterceptor = Symbol.for('PickServiceInterceptor');

let ShadowPickServiceInterceptorContribution = class ShadowPickServiceInterceptorContribution {
    constructor() {
        this.order = 1;
    }
    afterPickItem(result, pickerService, point, pickParams, params) {
        if (result.graphic) {
            let g = result.graphic;
            while (g.parent) {
                g = g.parent;
            }
            if (g.shadowHost) {
                result.params = {
                    shadowTarget: result.graphic
                };
                result.graphic = g.shadowHost;
            }
        }
        return result;
    }
};
ShadowPickServiceInterceptorContribution = __decorate([
    injectable()
], ShadowPickServiceInterceptorContribution);
let ShadowRootPickItemInterceptorContribution = class ShadowRootPickItemInterceptorContribution {
    constructor() {
        this.order = 1;
    }
    afterPickItem(graphic, pickerService, point, pickParams, params) {
        if (graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx) {
            return this._pickItem(graphic, pickerService, point, pickParams, params);
        }
        return null;
    }
    beforePickItem(graphic, pickerService, point, pickParams, params) {
        if (graphic.attribute.shadowRootIdx < 0) {
            return this._pickItem(graphic, pickerService, point, pickParams, params);
        }
        return null;
    }
    _pickItem(graphic, pickerService, point, pickParams, params) {
        var _a;
        if (!graphic.shadowRoot) {
            return null;
        }
        const { parentMatrix } = params || {};
        if (!parentMatrix) {
            return null;
        }
        const context = pickerService.pickContext;
        context.highPerformanceSave();
        const theme = (_a = getTheme(graphic)) === null || _a === void 0 ? void 0 : _a[graphic.type];
        const { shadowPickMode = theme === null || theme === void 0 ? void 0 : theme.shadowPickMode } = graphic.attribute;
        const g = graphic.shadowRoot;
        const currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix);
        const newPoint = new Point(currentGroupMatrix.a * point.x + currentGroupMatrix.c * point.y + currentGroupMatrix.e, currentGroupMatrix.b * point.x + currentGroupMatrix.d * point.y + currentGroupMatrix.f);
        const result = pickerService.pickGroup(g, newPoint, currentGroupMatrix, pickParams);
        context.highPerformanceRestore();
        if (!result.graphic && result.group && shadowPickMode === 'full') {
            result.graphic = result.group;
        }
        return result;
    }
};
ShadowRootPickItemInterceptorContribution = __decorate([
    injectable()
], ShadowRootPickItemInterceptorContribution);
let InteractivePickItemInterceptorContribution = class InteractivePickItemInterceptorContribution {
    constructor() {
        this.order = 1;
    }
    beforePickItem(graphic, pickerService, point, pickParams, params) {
        const originGraphic = graphic.baseGraphic;
        if (originGraphic && originGraphic.parent) {
            const newPoint = new Point(point.x, point.y);
            const context = pickerService.pickContext;
            context.highPerformanceSave();
            const parentMatrix = originGraphic.parent.globalTransMatrix;
            parentMatrix.transformPoint(newPoint, newPoint);
            const result = originGraphic.isContainer
                ? pickerService.pickGroup(originGraphic, newPoint.clone(), parentMatrix, pickParams)
                : pickerService.pickItem(originGraphic, newPoint.clone(), parentMatrix, pickParams);
            context.highPerformanceRestore();
            return result;
        }
        return null;
    }
};
InteractivePickItemInterceptorContribution = __decorate([
    injectable()
], InteractivePickItemInterceptorContribution);
let Canvas3DPickItemInterceptor = class Canvas3DPickItemInterceptor {
    constructor() {
        this.order = 1;
    }
    beforePickItem(graphic, pickerService, point, pickParams, params) {
        if (!graphic.in3dMode || pickParams.in3dInterceptor) {
            return null;
        }
        const context = pickerService.pickContext;
        const stage = graphic.stage;
        if (!(context && stage)) {
            return null;
        }
        pickParams.in3dInterceptor = true;
        context.save();
        this.initCanvasCtx(context);
        context.camera = stage.camera;
        if (graphic.isContainer) {
            const result = draw3dItem(context, graphic, () => {
                return pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams);
            }, pickParams);
            context.camera = null;
            pickParams.in3dInterceptor = false;
            context.restore();
            return result;
        }
        context.restore();
        return null;
    }
    initCanvasCtx(context) {
        context.setTransformForCurrent();
    }
};
Canvas3DPickItemInterceptor = __decorate([
    injectable()
], Canvas3DPickItemInterceptor);

var pickModule = new ContainerModule((bind, unbind, isBound) => {
    if (!isBound(PickerService)) {
        bind(GlobalPickerService).toSelf();
        bind(PickerService).toService(GlobalPickerService);
    }
    bind(Canvas3DPickItemInterceptor).toSelf().inSingletonScope();
    bind(PickItemInterceptor).toService(Canvas3DPickItemInterceptor);
    bind(ShadowRootPickItemInterceptorContribution).toSelf().inSingletonScope();
    bind(PickItemInterceptor).toService(ShadowRootPickItemInterceptorContribution);
    bind(InteractivePickItemInterceptorContribution).toSelf().inSingletonScope();
    bind(PickItemInterceptor).toService(InteractivePickItemInterceptorContribution);
    bindContributionProvider(bind, PickItemInterceptor);
    bind(ShadowPickServiceInterceptorContribution).toSelf().inSingletonScope();
    bind(PickServiceInterceptor).toService(ShadowPickServiceInterceptorContribution);
    bindContributionProvider(bind, PickServiceInterceptor);
});

var graphicModule = new ContainerModule(bind => {
    bind(GraphicService).to(DefaultGraphicService);
    bind(GraphicCreator$1).toConstantValue(graphicCreator);
});

const AutoEnablePlugins = Symbol.for('AutoEnablePlugins');
const PluginService = Symbol.for('PluginService');

let DefaultPluginService = class DefaultPluginService {
    constructor(autoEnablePlugins) {
        this.autoEnablePlugins = autoEnablePlugins;
        this.onStartupFinishedPlugin = [];
        this.onRegisterPlugin = [];
        this.actived = false;
    }
    active(stage, params) {
        this.stage = stage;
        this.actived = true;
        const { pluginList } = params;
        if (pluginList && container.isBound(AutoEnablePlugins)) {
            this.autoEnablePlugins.getContributions().forEach(p => {
                if (pluginList.includes(p.name)) {
                    this.register(p);
                }
            });
        }
    }
    findPluginsByName(name) {
        const arr = [];
        this.onStartupFinishedPlugin.forEach(plugin => {
            if (plugin.name === name) {
                arr.push(plugin);
            }
        });
        this.onRegisterPlugin.forEach(plugin => {
            if (plugin.name === name) {
                arr.push(plugin);
            }
        });
        return arr;
    }
    register(plugin) {
        if (plugin.activeEvent === 'onStartupFinished') {
            this.onStartupFinishedPlugin.push(plugin);
        }
        else if (plugin.activeEvent === 'onRegister') {
            this.onRegisterPlugin.push(plugin);
            plugin.activate(this);
        }
    }
    unRegister(plugin) {
        if (plugin.activeEvent === 'onStartupFinished') {
            this.onStartupFinishedPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1);
        }
        else if (plugin.activeEvent === 'onRegister') {
            this.onRegisterPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1);
        }
        plugin.deactivate(this);
    }
    release(...params) {
        this.onStartupFinishedPlugin.forEach(plugin => {
            plugin.deactivate(this);
        });
        this.onStartupFinishedPlugin = [];
        this.onRegisterPlugin.forEach(plugin => {
            plugin.deactivate(this);
        });
        this.onRegisterPlugin = [];
    }
};
DefaultPluginService = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(AutoEnablePlugins)),
    __metadata("design:paramtypes", [Object])
], DefaultPluginService);

var pluginModule = new ContainerModule(bind => {
    bind(PluginService).to(DefaultPluginService);
    bindContributionProviderNoSingletonScope(bind, AutoEnablePlugins);
});

var envModules = new ContainerModule(bind => {
    bindContributionProvider(bind, EnvContribution);
});

var textMeasureModules = new ContainerModule(bind => {
    bind(TextMeasureContribution).to(DefaultTextMeasureContribution).inSingletonScope();
    bindContributionProvider(bind, TextMeasureContribution);
});

let CanvasLayerHandlerContribution = class CanvasLayerHandlerContribution {
    constructor() {
        this.type = 'static';
        this.offscreen = false;
        this.global = application.global;
    }
    setDpr(dpr) {
        this.canvas.dpr = dpr;
        return;
    }
    init(layer, window, params) {
        this.layer = layer;
        this.window = window;
        if (params.main) {
            this.main = true;
            this.context = window.getContext();
            this.canvas = this.context.getCanvas();
        }
        else {
            this.main = false;
            let nativeCanvas;
            if (params.canvasId) {
                nativeCanvas = this.global.getElementById(params.canvasId);
            }
            if (!nativeCanvas) {
                nativeCanvas = this.global.createCanvas({
                    width: window.width,
                    height: window.height
                });
            }
            if (nativeCanvas.style) {
                nativeCanvas.style['pointer-events'] = 'none';
            }
            const windowContext = window.getContext();
            const windowCanvas = windowContext.getCanvas().nativeCanvas;
            const canvas = wrapCanvas({
                nativeCanvas,
                width: window.width,
                height: window.height,
                dpr: window.dpr,
                id: params.canvasId,
                canvasControled: true,
                container: window.getContainer(),
                x: windowCanvas.offsetLeft,
                y: windowCanvas.offsetTop
            });
            canvas.applyPosition();
            this.canvas = canvas;
            this.context = canvas.getContext();
        }
    }
    resize(w, h) {
        this.canvas.resize(w, h);
        return;
    }
    resizeView(w, h) {
        return;
    }
    render(group, params, userParams) {
        var _a;
        if (!this.main) {
            const windowContext = this.window.getContext();
            const windowCanvas = windowContext.getCanvas().nativeCanvas;
            if (windowCanvas && (this.canvas.x !== windowCanvas.offsetLeft || this.canvas.y !== windowCanvas.offsetTop)) {
                this.canvas.x = windowCanvas.offsetLeft;
                this.canvas.y = windowCanvas.offsetTop;
                this.canvas.applyPosition();
            }
        }
        params.renderService.render(group, Object.assign(Object.assign({ context: this.context, clear: (_a = params.background) !== null && _a !== void 0 ? _a : '#ffffff' }, params), userParams));
    }
    merge(layerHandlers) {
        layerHandlers.forEach(l => {
            const ctx = l.getContext();
            const canvas = ctx.canvas.nativeCanvas;
            this.context.drawImage(canvas, 0, 0);
        });
    }
    prepare(dirtyBounds, params) {
        return;
    }
    drawTo(target, group, params) {
        var _a;
        const context = target.getContext();
        params.renderService.render(group, Object.assign(Object.assign({ context }, params), { clear: params.clear ? (_a = params.background) !== null && _a !== void 0 ? _a : '#fff' : undefined }));
        return;
    }
    getContext() {
        return this.context;
    }
    release() {
        this.canvas.release();
    }
};
CanvasLayerHandlerContribution = __decorate([
    injectable(),
    __metadata("design:paramtypes", [])
], CanvasLayerHandlerContribution);

var layerHandlerModules = new ContainerModule(bind => {
    bind(CanvasLayerHandlerContribution).toSelf();
    bind(StaticLayerHandlerContribution).toService(CanvasLayerHandlerContribution);
});

function load$1(container) {
    container.load(envModules);
    container.load(textMeasureModules);
    container.load(layerHandlerModules);
}

function parseChildMap(graphic, defaultZIndex, reverse) {
    const childMap = {};
    const zIdxArray = [];
    graphic.forEachChildren((item) => {
        const { zIndex = defaultZIndex } = item.attribute;
        if (childMap[zIndex]) {
            childMap[zIndex].push(item);
        }
        else {
            childMap[zIndex] = [item];
            zIdxArray.push(zIndex);
        }
    }, reverse);
    zIdxArray.sort((a, b) => (reverse ? b - a : a - b));
    return { childMap, zIdxArray };
}
function foreach(graphic, defaultZIndex, cb, reverse = false, sort3d = false) {
    let needSort = false;
    if (sort3d) {
        needSort = true;
    }
    else {
        let lastZIndex;
        graphic.forEachChildren((item, i) => {
            const { zIndex = defaultZIndex } = item.attribute;
            if (i === 0) {
                lastZIndex = zIndex;
            }
            else if (lastZIndex !== zIndex) {
                needSort = true;
                return true;
            }
            return false;
        }, reverse);
    }
    if (needSort) {
        const { childMap, zIdxArray } = parseChildMap(graphic, defaultZIndex, reverse);
        let skip = false;
        for (let i = 0; i < zIdxArray.length; i++) {
            if (skip) {
                break;
            }
            const idx = zIdxArray[i];
            const children = childMap[idx];
            if (sort3d) {
                children.sort((a, b) => {
                    var _a, _b;
                    return (reverse ? -1 : 1) * (((_a = b.attribute.z) !== null && _a !== void 0 ? _a : 0) - ((_b = a.attribute.z) !== null && _b !== void 0 ? _b : 0));
                });
            }
            for (let i = 0; i < children.length; i++) {
                if (cb(children[i], i)) {
                    skip = true;
                    break;
                }
            }
        }
    }
    else {
        graphic.forEachChildren(cb, reverse);
    }
}
function foreachAsync(graphic, defaultZIndex, cb, reverse = false) {
    return __awaiter(this, void 0, void 0, function* () {
        yield graphic.forEachChildrenAsync(cb, reverse);
    });
}
function findNextGraphic(graphic, id, defaultZIndex, reverse = false) {
    let needSort = false;
    let lastZIndex;
    graphic.forEachChildren((item, i) => {
        const { zIndex = defaultZIndex } = item.attribute;
        if (i === 0) ;
        else if (lastZIndex !== zIndex) {
            needSort = true;
            return true;
        }
        return false;
    }, reverse);
    let result = null;
    let next = false;
    if (needSort) {
        const { childMap, zIdxArray } = parseChildMap(graphic, defaultZIndex, reverse);
        let skip = false;
        for (let i = 0; i < zIdxArray.length; i++) {
            if (skip) {
                break;
            }
            const idx = zIdxArray[i];
            const children = childMap[idx];
            for (let i = 0; i < children.length; i++) {
                if (next) {
                    skip = true;
                    result = children[i];
                    break;
                }
                if (children[i]._uid === id) {
                    next = true;
                    continue;
                }
            }
        }
    }
    else {
        graphic.forEachChildren(item => {
            if (next) {
                result = item;
                return true;
            }
            if (item._uid === id) {
                next = true;
            }
            return false;
        }, reverse);
    }
    return result;
}

let DefaultDrawContribution = class DefaultDrawContribution {
    constructor(contributions, drawItemInterceptorContributions) {
        this.contributions = contributions;
        this.drawItemInterceptorContributions = drawItemInterceptorContributions;
        this._renderInGroup = (skipSort, group, drawContext, nextM) => {
            var _a;
            skipSort
                ? group.forEachChildren((item) => {
                    if (drawContext.break) {
                        return;
                    }
                    if (item.isContainer) {
                        this.renderGroup(item, drawContext, nextM);
                    }
                    else {
                        this.renderItem(item, drawContext);
                    }
                })
                : foreach(group, DefaultAttribute.zIndex, (item) => {
                    if (drawContext.break) {
                        return;
                    }
                    if (item.isContainer) {
                        this.renderGroup(item, drawContext, nextM);
                    }
                    else {
                        this.renderItem(item, drawContext);
                    }
                }, false, !!((_a = drawContext.context) === null || _a === void 0 ? void 0 : _a.camera));
        };
        this.currentRenderMap = new Map();
        this.defaultRenderMap = new Map();
        this.styleRenderMap = new Map();
        this.dirtyBounds = new Bounds();
        this.backupDirtyBounds = new Bounds();
        this.global = application.global;
        this.layerService = application.layerService;
        if (!isArray(this.contributions)) {
            this.contributions = [this.contributions];
        }
        this.init();
    }
    reInit() {
        this.init();
        this.contributions.forEach(item => {
            item.reInit();
        });
    }
    init() {
        this.contributions.forEach(item => {
            if (item.style) {
                const map = this.styleRenderMap.get(item.style) || new Map();
                map.set(item.numberType, item);
                this.styleRenderMap.set(item.style, map);
            }
            else {
                this.defaultRenderMap.set(item.numberType, item);
            }
        });
        this.InterceptorContributions = this.drawItemInterceptorContributions
            .getContributions()
            .sort((a, b) => a.order - b.order);
    }
    prepareForDraw(renderService, drawContext) {
        if (drawContext.updateBounds) {
            this.useDirtyBounds = true;
        }
        else {
            this.useDirtyBounds = !drawContext.stage.params.optimize.disableCheckGraphicWidthOutRange;
        }
    }
    draw(renderService, drawContext) {
        var _a;
        this.prepareForDraw(renderService, drawContext);
        drawContext.drawContribution = this;
        this.currentRenderMap = this.styleRenderMap.get(drawContext.renderStyle) || this.defaultRenderMap;
        this.currentRenderService = renderService;
        const { context, stage, viewBox, transMatrix } = drawContext;
        if (!context) {
            return;
        }
        const dirtyBounds = this.dirtyBounds.setValue(0, 0, viewBox.width(), viewBox.height());
        if (stage.dirtyBounds && !stage.dirtyBounds.empty()) {
            const b = getRectIntersect(dirtyBounds, stage.dirtyBounds, false);
            dirtyBounds.x1 = Math.floor(b.x1);
            dirtyBounds.y1 = Math.floor(b.y1);
            dirtyBounds.x2 = Math.ceil(b.x2);
            dirtyBounds.y2 = Math.ceil(b.y2);
        }
        const d = context.dpr % 1;
        if (d || d !== 0.5) {
            dirtyBounds.x1 = Math.floor(dirtyBounds.x1 * context.dpr) / context.dpr;
            dirtyBounds.y1 = Math.floor(dirtyBounds.y1 * context.dpr) / context.dpr;
            dirtyBounds.x2 = Math.ceil(dirtyBounds.x2 * context.dpr) / context.dpr;
            dirtyBounds.y2 = Math.ceil(dirtyBounds.y2 * context.dpr) / context.dpr;
        }
        this.backupDirtyBounds.copy(dirtyBounds);
        context.reset(false);
        context.save();
        context.setClearMatrix(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f);
        context.clearMatrix(false);
        context.translate(viewBox.x1, viewBox.y1, true);
        context.beginPath();
        context.rect(dirtyBounds.x1, dirtyBounds.y1, dirtyBounds.width(), dirtyBounds.height());
        context.clip();
        if (stage.camera) {
            this.dirtyBounds.setValue(-Infinity, -Infinity, Infinity, Infinity);
            this.backupDirtyBounds.setValue(-Infinity, -Infinity, Infinity, Infinity);
        }
        this.clearScreen(renderService, context, drawContext);
        if ((_a = renderService.drawParams) === null || _a === void 0 ? void 0 : _a.stage) {
            renderService.drawParams.stage.hooks.afterClearScreen.call(renderService.drawParams);
        }
        renderService.renderTreeRoots
            .sort((a, b) => {
            var _a, _b;
            return ((_a = a.attribute.zIndex) !== null && _a !== void 0 ? _a : DefaultAttribute.zIndex) - ((_b = b.attribute.zIndex) !== null && _b !== void 0 ? _b : DefaultAttribute.zIndex);
        })
            .forEach(group => {
            group.isContainer
                ? this.renderGroup(group, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0))
                : this.renderItem(group, drawContext);
        });
        context.restore();
        context.draw();
    }
    doRegister() {
        throw new Error('暂不支持');
    }
    _findNextGraphic(group) {
        let parent = group.parent;
        let id = group._uid;
        while (parent) {
            const g = findNextGraphic(parent, id, DefaultAttribute.zIndex);
            if (g) {
                return g;
            }
            id = parent._uid;
            parent = parent.parent;
        }
        return null;
    }
    renderGroup(group, drawContext, parentMatrix, skipSort) {
        if (drawContext.break || group.attribute.visibleAll === false) {
            return;
        }
        if (group.incremental && (drawContext.startAtId == null || drawContext.startAtId === group._uid)) {
            drawContext.break = true;
            this._increaseRender(group, drawContext);
            return;
        }
        if (this.useDirtyBounds &&
            !isRectIntersect(group.AABBBounds, this.dirtyBounds, false) &&
            group.attribute.boundsMode !== 'empty') {
            return;
        }
        let nextM = parentMatrix;
        let tempBounds;
        if (this.useDirtyBounds) {
            tempBounds = boundsAllocate.allocateByObj(this.dirtyBounds);
            const gm = group.transMatrix;
            nextM = matrixAllocate.allocateByObj(parentMatrix).multiply(gm.a, gm.b, gm.c, gm.d, gm.e, gm.f);
            this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(nextM.getInverse());
        }
        drawContext.isGroupScroll = !!(group.attribute.scrollX || group.attribute.scrollY);
        this.renderItem(group, drawContext, {
            renderInGroupParams: {
                skipSort,
                nextM
            },
            renderInGroup: this._renderInGroup
        });
        if (this.useDirtyBounds) {
            this.dirtyBounds.copy(tempBounds);
            boundsAllocate.free(tempBounds);
            matrixAllocate.free(nextM);
        }
    }
    _increaseRender(group, drawContext) {
        const { layer, stage } = drawContext;
        const { subLayers } = layer;
        let incrementalLayer = subLayers.get(group._uid);
        if (!incrementalLayer) {
            incrementalLayer = {
                layer: this.layerService.createLayer(stage),
                zIndex: subLayers.size,
                group
            };
            subLayers.set(group._uid, incrementalLayer);
        }
        const incrementalContext = incrementalLayer.layer.getNativeHandler().getContext();
        const idc = incrementalLayer.drawContribution || container.get(IncrementalDrawContribution);
        idc.dirtyBounds.setValue(-Infinity, -Infinity, Infinity, Infinity);
        idc.backupDirtyBounds.setValue(-Infinity, -Infinity, Infinity, Infinity);
        idc.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), { drawContribution: idc, clear: 'transparent', layer: incrementalLayer.layer, context: incrementalContext, startAtId: group._uid, break: false }));
        incrementalLayer.drawContribution = idc;
        const nextGraphic = this._findNextGraphic(group);
        if (nextGraphic) {
            if (nextGraphic.isContainer && nextGraphic.incremental) {
                this._increaseRender(nextGraphic, drawContext);
            }
            else {
                let afterLayer = subLayers.get(nextGraphic._uid);
                if (!afterLayer) {
                    afterLayer = {
                        layer: this.layerService.createLayer(stage),
                        zIndex: subLayers.size
                    };
                    subLayers.set(nextGraphic._uid, afterLayer);
                }
                const afterContext = afterLayer.layer.getNativeHandler().getContext();
                this.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), { drawContribution: idc, clear: 'transparent', layer: afterLayer.layer, context: afterContext, startAtId: nextGraphic._uid, break: false }));
            }
        }
    }
    getRenderContribution(graphic) {
        let renderer;
        if (!renderer) {
            renderer = this.selectRenderByNumberType(graphic.numberType, graphic);
        }
        if (!renderer) {
            renderer = this.selectRenderByType(graphic.type);
        }
        return renderer;
    }
    renderItem(graphic, drawContext, params) {
        if (this.InterceptorContributions.length) {
            for (let i = 0; i < this.InterceptorContributions.length; i++) {
                const drawContribution = this.InterceptorContributions[i];
                if (drawContribution.beforeDrawItem &&
                    drawContribution.beforeDrawItem(graphic, this.currentRenderService, drawContext, this, params)) {
                    return;
                }
            }
        }
        const renderer = this.getRenderContribution(graphic);
        if (!renderer) {
            return;
        }
        let retrans = false;
        let tempBounds;
        if (drawContext.isGroupScroll) {
            const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
            retrans = true;
            if (!this.scrollMatrix) {
                this.scrollMatrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0);
            }
            this.scrollMatrix.translate(-scrollX, -scrollY);
        }
        if (retrans) {
            tempBounds = this.dirtyBounds.clone().transformWithMatrix(this.scrollMatrix);
        }
        if (this.useDirtyBounds &&
            !(graphic.isContainer ||
                graphic.attribute.boundsMode === 'empty' ||
                isRectIntersect(graphic.AABBBounds, tempBounds !== null && tempBounds !== void 0 ? tempBounds : this.dirtyBounds, false))) {
            if (retrans && graphic.parent) {
                const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
                this.scrollMatrix && this.scrollMatrix.translate(scrollX, scrollY);
            }
            return;
        }
        const skipDraw = drawContext.startAtId != null && graphic._uid !== drawContext.startAtId;
        if (graphic._uid === drawContext.startAtId) {
            drawContext.startAtId = null;
        }
        params && (params.skipDraw = skipDraw);
        if (skipDraw) {
            graphic.isContainer && renderer.draw(graphic, this.currentRenderService, drawContext, params);
        }
        else {
            renderer.draw(graphic, this.currentRenderService, drawContext, params);
        }
        if (retrans && graphic.parent) {
            const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
            this.scrollMatrix && this.scrollMatrix.translate(scrollX, scrollY);
        }
        if (this.InterceptorContributions.length) {
            for (let i = 0; i < this.InterceptorContributions.length; i++) {
                const drawContribution = this.InterceptorContributions[i];
                if (drawContribution.afterDrawItem) {
                    if (drawContribution.afterDrawItem(graphic, this.currentRenderService, drawContext, this)) {
                        return;
                    }
                }
            }
        }
    }
    selectRenderByType(type) {
        Logger.getInstance().warn('未知错误，不应该走到这里');
        return null;
    }
    selectRenderByNumberType(type, graphic) {
        let data;
        if (graphic.attribute.renderStyle) {
            const currentRenderMap = this.styleRenderMap.get(graphic.attribute.renderStyle);
            data = currentRenderMap && currentRenderMap.get(type);
        }
        return data || this.currentRenderMap.get(type) || this.defaultRenderMap.get(type);
    }
    clearScreen(renderService, context, drawContext) {
        var _a, _b, _c;
        const { clear, viewBox } = drawContext;
        const x = 0;
        const y = 0;
        const width = viewBox.width();
        const height = viewBox.height();
        if (clear) {
            context.clearRect(x, y, width, height);
            if ((_a = renderService.drawParams) === null || _a === void 0 ? void 0 : _a.stage) {
                renderService.drawParams.stage.hooks.afterClearRect.call(renderService.drawParams);
            }
            const stage = (_b = renderService.drawParams) === null || _b === void 0 ? void 0 : _b.stage;
            stage && (context.globalAlpha = (_c = stage.attribute.opacity) !== null && _c !== void 0 ? _c : 1);
            if (stage && stage.backgroundImg && stage.resources) {
                const res = stage.resources.get(clear);
                if (res && res.state === 'success' && res.data) {
                    context.drawImage(res.data, x, y, width, height);
                }
            }
            else {
                context.fillStyle = createColor(context, clear, {
                    AABBBounds: { x1: x, y1: y, x2: x + width, y2: y + height }
                }, 0, 0);
                context.fillRect(x, y, width, height);
            }
        }
    }
    afterDraw(renderService, drawParams) {
        return;
    }
};
DefaultDrawContribution = __decorate([
    injectable(),
    __param(0, multiInject(GraphicRender)),
    __param(1, inject(ContributionProvider)),
    __param(1, named(DrawItemInterceptor)),
    __metadata("design:paramtypes", [Array, Object])
], DefaultDrawContribution);

let DefaultIncrementalCanvasLineRender = class DefaultIncrementalCanvasLineRender extends DefaultCanvasLineRender {
    constructor() {
        super(...arguments);
        this.numberType = LINE_NUMBER_TYPE;
    }
    drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
        if (line.incremental && drawContext.multiGraphicOptions) {
            const { startAtIdx, length } = drawContext.multiGraphicOptions;
            const { segments = [] } = line.attribute;
            if (startAtIdx > segments.length) {
                return;
            }
            const lineAttribute = getTheme(line).line;
            const { fill = lineAttribute.fill, stroke = lineAttribute.stroke, opacity = lineAttribute.opacity, fillOpacity = lineAttribute.fillOpacity, strokeOpacity = lineAttribute.strokeOpacity, lineWidth = lineAttribute.lineWidth, visible = lineAttribute.visible } = line.attribute;
            const fVisible = fillVisible(opacity, fillOpacity, fill);
            const sVisible = strokeVisible(opacity, strokeOpacity);
            const doFill = runFill(fill);
            const doStroke = runStroke(stroke, lineWidth);
            if (!(line.valid && visible)) {
                return;
            }
            if (!(doFill || doStroke)) {
                return;
            }
            if (!(fVisible || sVisible || fillCb || strokeCb)) {
                return;
            }
            const { context } = drawContext;
            for (let i = startAtIdx; i < startAtIdx + length; i++) {
                this.drawIncreaseSegment(line, context, segments[i - 1], segments[i], line.attribute.segments[i], [lineAttribute, line.attribute], x, y);
            }
        }
        else {
            super.drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb);
        }
    }
    drawIncreaseSegment(line, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
        if (!seg) {
            return;
        }
        context.beginPath();
        drawIncrementalSegments(context.nativeContext, lastSeg, seg, { offsetX, offsetY });
        context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute);
        context.setStrokeStyle(line, attribute, offsetX, offsetY, defaultAttribute);
        context.stroke();
    }
};
DefaultIncrementalCanvasLineRender = __decorate([
    injectable()
], DefaultIncrementalCanvasLineRender);

let DefaultIncrementalCanvasAreaRender = class DefaultIncrementalCanvasAreaRender extends DefaultCanvasAreaRender {
    constructor() {
        super(...arguments);
        this.numberType = AREA_NUMBER_TYPE;
    }
    drawShape(area, context, x, y, drawContext, params, fillCb) {
        if (area.incremental && drawContext.multiGraphicOptions) {
            const { startAtIdx, length } = drawContext.multiGraphicOptions;
            const { segments = [] } = area.attribute;
            if (startAtIdx > segments.length) {
                return;
            }
            const areaAttribute = getTheme(area).area;
            const { fill = areaAttribute.fill, fillOpacity = areaAttribute.fillOpacity, opacity = areaAttribute.opacity, visible = areaAttribute.visible } = area.attribute;
            const fVisible = fillVisible(opacity, fillOpacity, fill);
            const doFill = runFill(fill);
            if (!(area.valid && visible)) {
                return;
            }
            if (!doFill) {
                return;
            }
            if (!(fVisible || fillCb)) {
                return;
            }
            for (let i = startAtIdx; i < startAtIdx + length; i++) {
                this.drawIncreaseSegment(area, context, segments[i - 1], segments[i], area.attribute.segments[i], [areaAttribute, area.attribute], x, y);
            }
        }
        else {
            super.drawShape(area, context, x, y, drawContext, params, fillCb);
        }
    }
    drawIncreaseSegment(area, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
        if (!seg) {
            return;
        }
        context.beginPath();
        drawIncrementalAreaSegments(context.camera ? context : context.nativeContext, lastSeg, seg, {
            offsetX,
            offsetY
        });
        context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute);
        context.setCommonStyle(area, attribute, offsetX, offsetY, defaultAttribute);
        context.fill();
    }
};
DefaultIncrementalCanvasAreaRender = __decorate([
    injectable()
], DefaultIncrementalCanvasAreaRender);

var STATUS;
(function (STATUS) {
    STATUS[STATUS["NORMAL"] = 0] = "NORMAL";
    STATUS[STATUS["STOP"] = 1] = "STOP";
})(STATUS || (STATUS = {}));
let DefaultIncrementalDrawContribution = class DefaultIncrementalDrawContribution extends DefaultDrawContribution {
    constructor(contributions, lineRender, areaRender, drawItemInterceptorContributions) {
        super(contributions, drawItemInterceptorContributions);
        this.contributions = contributions;
        this.lineRender = lineRender;
        this.areaRender = areaRender;
        this.drawItemInterceptorContributions = drawItemInterceptorContributions;
        this.rendering = false;
        this.currFrameStartAt = 0;
        this.currentIdx = 0;
        this.status = STATUS.NORMAL;
        this.checkingForDrawPromise = null;
        this.hooks = {
            completeDraw: new SyncHook([])
        };
        this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender);
        this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
    }
    draw(renderService, drawContext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.checkingForDrawPromise) {
                return;
            }
            this.lastRenderService = renderService;
            this.lastDrawContext = drawContext;
            this.checkingForDrawPromise = this.checkForDraw(drawContext);
            const skipDraw = yield this.checkingForDrawPromise;
            this.checkingForDrawPromise = null;
            if (skipDraw) {
                return;
            }
            this.currentRenderService = renderService;
            const { context, viewBox } = drawContext;
            if (!context) {
                return;
            }
            context.inuse = true;
            context.clearMatrix();
            context.setTransformForCurrent(true);
            context.save();
            drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext);
            context.translate(viewBox.x1, viewBox.y1, true);
            context.save();
            renderService.renderTreeRoots
                .sort((a, b) => {
                var _a, _b;
                return ((_a = a.attribute.zIndex) !== null && _a !== void 0 ? _a : DefaultAttribute.zIndex) - ((_b = b.attribute.zIndex) !== null && _b !== void 0 ? _b : DefaultAttribute.zIndex);
            })
                .forEach(group => {
                this.renderGroup(group, drawContext);
            });
            this.hooks.completeDraw.tap('top-draw', () => {
                context.restore();
                context.restore();
                context.draw();
                context.inuse = false;
                this.rendering = false;
            });
        });
    }
    _increaseRender(group, drawContext) {
        return __awaiter(this, void 0, void 0, function* () {
            this.rendering = true;
            yield this._renderIncrementalGroup(group, drawContext);
            return;
        });
    }
    _renderIncrementalGroup(group, drawContext) {
        return __awaiter(this, void 0, void 0, function* () {
            this.count = group.count;
            yield new Promise(resolve => {
                this.renderItem(group, drawContext, {
                    drawingCb: () => __awaiter(this, void 0, void 0, function* () {
                        if (group.count === 2) {
                            const graphic = group.getChildAt(0);
                            if (graphic.incremental && graphic.attribute.segments) {
                                if (!graphic.incrementalAt) {
                                    graphic.incrementalAt = 0;
                                }
                                while (graphic.incrementalAt < graphic.attribute.segments.length) {
                                    drawContext.multiGraphicOptions = {
                                        startAtIdx: graphic.incrementalAt,
                                        length: graphic.incremental
                                    };
                                    this.renderItem(graphic, drawContext);
                                    graphic.incrementalAt += graphic.incremental;
                                    yield this.waitToNextFrame();
                                }
                            }
                            else {
                                this.renderItem(graphic, drawContext);
                            }
                            resolve(false);
                            return;
                        }
                        yield foreachAsync(group, DefaultAttribute.zIndex, (item, i) => {
                            if (this.status === STATUS.STOP) {
                                return true;
                            }
                            if (item.isContainer) {
                                return false;
                            }
                            if (i < this.currentIdx) {
                                return false;
                            }
                            const frameTail = this.currFrameStartAt + group.incremental;
                            if (i < frameTail) {
                                this.currentIdx = i + 1;
                                this.renderItem(item, drawContext);
                            }
                            if (i === frameTail - 1) {
                                this.currFrameStartAt = this.currentIdx;
                                return this.waitToNextFrame();
                            }
                            return false;
                        });
                        resolve(false);
                    })
                });
            });
            this.hooks.completeDraw.call();
        });
    }
    waitToNextFrame() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                this.global.getRequestAnimationFrame()(() => {
                    resolve(false);
                });
            });
        });
    }
    checkForDraw(drawContext) {
        return __awaiter(this, void 0, void 0, function* () {
            let skip = this.rendering;
            if (drawContext.restartIncremental) {
                skip = false;
                yield this.forceStop();
                this.resetToInit();
            }
            return skip;
        });
    }
    forceStop() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.rendering) {
                this.status = STATUS.STOP;
                yield new Promise(resolve => {
                    this.hooks.completeDraw.tap('stopCb', () => {
                        this.status = STATUS.NORMAL;
                        this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter(item => {
                            return item.name !== 'stopCb';
                        });
                        resolve(false);
                    });
                });
            }
        });
    }
    resetToInit() {
        this.currFrameStartAt = 0;
        this.currentIdx = 0;
    }
    renderGroup(group, drawContext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (drawContext.break || group.attribute.visibleAll === false) {
                return;
            }
            if (group.incremental && drawContext.startAtId === group._uid) {
                yield this._increaseRender(group, drawContext);
                drawContext.break = true;
                return;
            }
            yield new Promise(resolve => {
                this.renderItem(group, drawContext, {
                    drawingCb: () => __awaiter(this, void 0, void 0, function* () {
                        yield foreachAsync(group, DefaultAttribute.zIndex, (item) => __awaiter(this, void 0, void 0, function* () {
                            if (drawContext.break) {
                                return;
                            }
                            if (item.isContainer) {
                                yield this.renderGroup(item, drawContext);
                            }
                            else {
                                return;
                            }
                        }));
                        resolve(false);
                    })
                });
            });
        });
    }
};
DefaultIncrementalDrawContribution = __decorate([
    injectable(),
    __param(0, multiInject(GraphicRender)),
    __param(1, inject(DefaultIncrementalCanvasLineRender)),
    __param(2, inject(DefaultIncrementalCanvasAreaRender)),
    __param(3, inject(ContributionProvider)),
    __param(3, named(DrawItemInterceptor)),
    __metadata("design:paramtypes", [Array, Object, Object, Object])
], DefaultIncrementalDrawContribution);

var renderModule = new ContainerModule(bind => {
    bind(DefaultBaseBackgroundRenderContribution).toSelf().inSingletonScope();
    bind(DefaultBaseTextureRenderContribution).toSelf().inSingletonScope();
    bind(DrawContribution).to(DefaultDrawContribution);
    bind(IncrementalDrawContribution).to(DefaultIncrementalDrawContribution);
    bind(GroupRender).to(DefaultCanvasGroupRender).inSingletonScope();
    bind(GraphicRender).toService(GroupRender);
    bindContributionProvider(bind, GroupRenderContribution);
    bind(DefaultBaseInteractiveRenderContribution).toSelf().inSingletonScope();
    bindContributionProvider(bind, InteractiveSubRenderContribution);
    bindContributionProvider(bind, GraphicRender);
    bind(CommonDrawItemInterceptorContribution).toSelf().inSingletonScope();
    bind(DrawItemInterceptor).toService(CommonDrawItemInterceptorContribution);
    bindContributionProvider(bind, DrawItemInterceptor);
});

function load(container) {
    container.load(renderModule);
}

function preLoadAllModule() {
    if (preLoadAllModule.__loaded) {
        return;
    }
    preLoadAllModule.__loaded = true;
    container.load(coreModule);
    container.load(graphicModule);
    container.load(renderModule$1);
    container.load(pickModule);
    container.load(pluginModule);
    load$1(container);
    load(container);
}
preLoadAllModule.__loaded = false;
preLoadAllModule();
const vglobal = container.get(VGlobal);
application.global = vglobal;
const graphicUtil = container.get(GraphicUtil);
application.graphicUtil = graphicUtil;
const transformUtil = container.get(TransformUtil);
application.transformUtil = transformUtil;
const graphicService = container.get(GraphicService);
application.graphicService = graphicService;
const renderService = container.get(RenderService);
application.renderService = renderService;
const layerService = container.get(LayerService);
application.layerService = layerService;

class AutoRenderPlugin {
    constructor() {
        this.name = 'AutoRenderPlugin';
        this.activeEvent = 'onRegister';
        this._uid = Generator.GenAutoIncrementId();
        this.key = this.name + this._uid;
        this.handleChange = (graphic) => {
            if (graphic.glyphHost) {
                graphic = graphic.glyphHost;
            }
            if (graphic.stage === this.pluginService.stage && graphic.stage != null) {
                graphic.stage.renderNextFrame();
            }
        };
    }
    activate(context) {
        this.pluginService = context;
        const stage = this.pluginService.stage;
        if (!stage) {
            return;
        }
        stage.graphicService.hooks.onAttributeUpdate.tap(this.key, this.handleChange);
        stage.graphicService.hooks.onSetStage.tap(this.key, this.handleChange);
        stage.graphicService.hooks.onRemove.tap(this.key, this.handleChange);
    }
    deactivate(context) {
        const filterByName = (taps) => {
            return taps.filter(item => {
                return item.name !== this.key;
            });
        };
        const stage = this.pluginService.stage;
        if (!stage) {
            return;
        }
        stage.graphicService.hooks.onAttributeUpdate.taps = filterByName(stage.graphicService.hooks.onAttributeUpdate.taps);
        stage.graphicService.hooks.onSetStage.taps = filterByName(stage.graphicService.hooks.onSetStage.taps);
        stage.graphicService.hooks.onRemove.taps = filterByName(stage.graphicService.hooks.onRemove.taps);
    }
}

class AutoRefreshPlugin {
    constructor() {
        this.name = 'AutoRefreshPlugin';
        this.activeEvent = 'onRegister';
        this._uid = Generator.GenAutoIncrementId();
        this.key = this.name + this._uid;
        this.handleChange = (graphic) => {
            if (graphic.glyphHost) {
                graphic = graphic.glyphHost;
            }
            if (graphic.stage === this.pluginService.stage && graphic.stage != null) {
                graphic.stage.renderNextFrame();
            }
        };
    }
    activate(context) {
        this.pluginService = context;
        this.dpr = application.global.devicePixelRatio;
        this.refresh();
    }
    refresh() {
        if (!this._refreshByMediaQuery()) {
            this._refreshByRaf();
        }
    }
    _refreshByRaf() {
        const raf = application.global.getRequestAnimationFrame();
        this.rafId = raf(() => {
            if (application.global.devicePixelRatio !== this.dpr) {
                this.dpr = application.global.devicePixelRatio;
                this.pluginService.stage.setDpr(this.dpr, true);
            }
            this.refresh();
        });
    }
    _refreshByMediaQuery() {
        try {
            const mqString = `(resolution: ${window.devicePixelRatio}dppx)`;
            const updatePixelRatio = () => {
                if (window.devicePixelRatio !== this.dpr) {
                    this.dpr = window.devicePixelRatio;
                    this.pluginService.stage.setDpr(this.dpr, true);
                }
            };
            const dom = matchMedia(mqString);
            dom && dom.addEventListener('change', updatePixelRatio);
            if (!this.autoRefreshCbs) {
                this.autoRefreshCbs = [];
            }
            this.autoRefreshCbs.push(() => {
                dom && dom.removeEventListener('change', updatePixelRatio);
            });
        }
        catch (err) {
            return false;
        }
        return true;
    }
    deactivate(context) {
        var _a;
        const craf = application.global.getCancelAnimationFrame();
        craf && this.rafId && craf(this.rafId);
        (_a = this.autoRefreshCbs) === null || _a === void 0 ? void 0 : _a.forEach(cb => {
            cb();
        });
        this.autoRefreshCbs = undefined;
    }
}

class IncrementalAutoRenderPlugin {
    constructor() {
        this.name = 'IncrementalAutoRenderPlugin';
        this.activeEvent = 'onRegister';
        this.nextFrameRenderGroupSet = new Set();
        this.willNextFrameRender = false;
        this.nextUserParams = {};
        this._uid = Generator.GenAutoIncrementId();
        this.key = this.name + this._uid;
    }
    activate(context) {
        this.pluginService = context;
        const stage = this.pluginService.stage;
        if (!stage) {
            return;
        }
        stage.graphicService.hooks.onAddIncremental.tap(this.key, (graphic, group, stage) => {
            if (graphic.glyphHost) {
                graphic = graphic.glyphHost;
            }
            if (graphic.stage === context.stage && graphic.stage != null) {
                this.nextUserParams.startAtId = group._uid;
                this.renderNextFrame(group);
            }
        });
        stage.graphicService.hooks.onClearIncremental.tap(this.key, (group, stage) => {
            if (group.stage === context.stage && group.stage != null) {
                this.nextUserParams.startAtId = group._uid;
                this.nextUserParams.restartIncremental = true;
                this.renderNextFrame(group);
            }
        });
    }
    deactivate(context) {
        const stage = this.pluginService.stage;
        if (!stage) {
            return;
        }
        stage.graphicService.hooks.onAddIncremental.taps = stage.graphicService.hooks.onAddIncremental.taps.filter(item => {
            return item.name !== this.key;
        });
        stage.graphicService.hooks.onClearIncremental.taps = stage.graphicService.hooks.onClearIncremental.taps.filter(item => {
            return item.name !== this.key;
        });
    }
    renderNextFrame(group) {
        this.nextFrameRenderGroupSet.add(group);
        if (!this.willNextFrameRender) {
            this.willNextFrameRender = true;
            application.global.getRequestAnimationFrame()(() => {
                this._doRenderInThisFrame();
                this.willNextFrameRender = false;
            });
        }
    }
    _doRenderInThisFrame() {
        const stage = this.pluginService.stage;
        if (this.nextFrameRenderGroupSet.size) {
            this.nextFrameRenderGroupSet.forEach(group => {
                const layer = group.layer;
                if (!layer || !group.layer.subLayers) {
                    return;
                }
                const subLayer = group.layer.subLayers.get(group._uid);
                if (!subLayer || !subLayer.drawContribution) {
                    return;
                }
                subLayer.drawContribution.draw(stage.renderService, Object.assign({ stage,
                    layer, viewBox: stage.window.getViewBox(), transMatrix: stage.window.getViewBoxTransform(), clear: 'transparent', renderService: stage.renderService, updateBounds: false, startAtId: group._uid, context: subLayer.layer.getNativeHandler().getContext() }, this.nextUserParams));
            });
            this.nextUserParams = {};
            this.nextFrameRenderGroupSet.clear();
        }
    }
}

const globalBounds = new AABBBounds();
class DirtyBoundsPlugin {
    constructor() {
        this.name = 'DirtyBoundsPlugin';
        this.activeEvent = 'onRegister';
        this._uid = Generator.GenAutoIncrementId();
        this.key = this.name + this._uid;
    }
    activate(context) {
        this.pluginService = context;
        context.stage.hooks.afterRender.tap(this.key, stage => {
            if (!(stage && stage === this.pluginService.stage)) {
                return;
            }
            stage.dirtyBounds.clear();
        });
        const stage = this.pluginService.stage;
        if (!stage) {
            return;
        }
        stage.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
            if (graphic.glyphHost) {
                graphic = graphic.glyphHost;
            }
            if (!(stage && stage === this.pluginService.stage && stage.renderCount)) {
                return;
            }
            if (graphic.isContainer && !graphic.shouldSelfChangeUpdateAABBBounds()) {
                return;
            }
            if (willUpdate) {
                globalBounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2);
                stage.dirty(globalBounds, graphic.parent && graphic.parent.globalTransMatrix);
            }
        });
        stage.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params, selfChange) => {
            if (!(stage && stage === this.pluginService.stage && stage.renderCount)) {
                return;
            }
            if (graphic.isContainer && !selfChange) {
                return;
            }
            stage.dirty(params.globalAABBBounds);
        });
        stage.graphicService.hooks.clearAABBBounds.tap(this.key, (graphic, stage, bounds) => {
            if (!(stage && stage === this.pluginService.stage && stage.renderCount)) {
                return;
            }
            if (stage) {
                stage.dirty(bounds);
            }
        });
        stage.graphicService.hooks.onRemove.tap(this.key, (graphic) => {
            const stage = graphic.stage;
            if (!(stage && stage === this.pluginService.stage && stage.renderCount)) {
                return;
            }
            if (stage) {
                stage.dirty(graphic.globalAABBBounds);
            }
        });
    }
    deactivate(context) {
        const stage = this.pluginService.stage;
        if (!stage) {
            return;
        }
        stage.graphicService.hooks.beforeUpdateAABBBounds.taps =
            stage.graphicService.hooks.beforeUpdateAABBBounds.taps.filter(item => {
                return item.name !== this.key;
            });
        stage.graphicService.hooks.afterUpdateAABBBounds.taps =
            stage.graphicService.hooks.afterUpdateAABBBounds.taps.filter(item => {
                return item.name !== this.key;
            });
        stage.graphicService.hooks.clearAABBBounds.taps = stage.graphicService.hooks.clearAABBBounds.taps.filter(item => {
            return item.name !== this.key;
        });
        stage.hooks.afterRender.taps = stage.hooks.afterRender.taps.filter(item => {
            return item.name !== this.key;
        });
        stage.graphicService.hooks.onRemove.taps = stage.graphicService.hooks.onRemove.taps.filter(item => {
            return item.name !== this.key;
        });
    }
}

let _isBrowserEnv;
function initIsBrowserEnv() {
    if (_isBrowserEnv != null) {
        return;
    }
    try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        _isBrowserEnv = !!(window &&
            !!canvas.getBoundingClientRect &&
            !!requestAnimationFrame &&
            !!window.devicePixelRatio &&
            ctx &&
            !!ctx.isPointInPath &&
            !!ctx.isPointInStroke);
        if (_isBrowserEnv) {
            _isBrowserEnv = !!document.createElement;
        }
    }
    catch (err) {
        _isBrowserEnv = false;
    }
}
function isBrowserEnv() {
    initIsBrowserEnv();
    const env = application.global && application.global.env;
    return env ? env === 'browser' : _isBrowserEnv;
}
function isNodeEnv() {
    initIsBrowserEnv();
    const env = application.global && application.global.env;
    return env ? env === 'node' : !_isBrowserEnv;
}
function getCurrentEnv() {
    return isBrowserEnv() ? 'browser' : 'node';
}

class Factory {
    static registerPlugin(pluginKey, pluginClass) {
        Factory._pluginClasses[pluginKey] = pluginClass;
    }
    static getPlugin(pluginKey) {
        return Factory._pluginClasses[pluginKey];
    }
}
Factory._pluginClasses = {};

const DefaultConfig = {
    WIDTH: 500,
    HEIGHT: 500,
    X: 0,
    Y: 0,
    BACKGROUND: 'white'
};
class Stage extends Group {
    set viewBox(b) {
        this.window.setViewBox(b);
    }
    get viewBox() {
        return this.window.getViewBox();
    }
    get x() {
        return this.window.getViewBox().x1;
    }
    set x(x) {
        const b = this.window.getViewBox();
        b.translate(x - b.x1, 0);
        this.window.setViewBox(b);
    }
    get y() {
        return this.window.getViewBox().y1;
    }
    set y(y) {
        const b = this.window.getViewBox();
        b.translate(0, y - b.y1);
        this.window.setViewBox(b);
    }
    get width() {
        return this.window.width;
    }
    set width(w) {
        this.resize(w, this.height);
    }
    get viewWidth() {
        return this.window.getViewBox().width();
    }
    set viewWidth(w) {
        this.resizeView(w, this.viewHeight);
    }
    get viewHeight() {
        return this.window.getViewBox().height();
    }
    set viewHeight(h) {
        this.resizeView(this.viewWidth, h);
    }
    get height() {
        return this.window.height;
    }
    set height(h) {
        this.resize(this.width, h);
    }
    get dpr() {
        return this.window.dpr;
    }
    set dpr(r) {
        this.setDpr(r);
    }
    get background() {
        var _a;
        return (_a = this._background) !== null && _a !== void 0 ? _a : DefaultConfig.BACKGROUND;
    }
    set background(b) {
        this._background = b;
    }
    get defaultLayer() {
        return this.at(0);
    }
    get eventSystem() {
        return this._eventSystem;
    }
    get ticker() {
        return this._ticker;
    }
    set ticker(ticker) {
        ticker.bindStage(this);
        if (this._ticker) {
            this._ticker.removeListener('tick', this.afterTickCb);
        }
        ticker.addTimeline(this.timeline);
        this._ticker = ticker;
        this._ticker.on('tick', this.afterTickCb);
    }
    constructor(params = {}) {
        var _a, _b;
        super({});
        this.tickedBeforeRender = true;
        this._onVisibleChange = (visible) => {
            if (this._skipRender < 0) {
                return;
            }
            if (visible) {
                if (this.dirtyBounds) {
                    const b = this.window.getViewBox();
                    this.dirtyBounds.setValue(b.x1, b.y1, b.width(), b.height());
                }
                if (this._skipRender > 1) {
                    this.renderNextFrame();
                }
                this._skipRender = 0;
            }
            else {
                this._skipRender = 1;
            }
        };
        this.beforeRender = (stage) => {
            this._beforeRenderList.forEach(cb => cb(stage));
        };
        this.afterClearScreen = (drawParams) => {
            this._afterClearScreen && this._afterClearScreen(drawParams);
        };
        this.afterClearRect = (drawParams) => {
            this._afterClearRect && this._afterClearRect(drawParams);
        };
        this.afterRender = (stage) => {
            this.renderCount++;
            this._afterRenderList.forEach(cb => cb(stage));
            this._afterNextRenderCbs && this._afterNextRenderCbs.forEach(cb => cb(stage));
            this._afterNextRenderCbs = null;
            this.tickedBeforeRender = false;
        };
        this.afterTickCb = () => {
            this.tickedBeforeRender = true;
            this.state !== 'rendering' && this.renderNextFrame();
        };
        this.params = params;
        this.theme = new Theme();
        this.hooks = {
            beforeRender: new SyncHook(['stage']),
            afterRender: new SyncHook(['stage']),
            afterClearScreen: new SyncHook(['stage']),
            afterClearRect: new SyncHook(['stage'])
        };
        this.global = application.global;
        if (!this.global.env && isBrowserEnv()) {
            this.global.setEnv('browser');
        }
        this.window = container.get(VWindow);
        this.renderService = container.get(RenderService);
        this.pluginService = container.get(PluginService);
        this.layerService = container.get(LayerService);
        this.graphicService = container.get(GraphicService);
        this.pluginService.active(this, params);
        this._beforeRenderList = [];
        this._afterRenderList = [];
        this.window.create({
            width: params.width,
            height: params.height,
            viewBox: params.viewBox,
            container: params.container,
            dpr: params.dpr || this.global.devicePixelRatio,
            canvasControled: params.canvasControled !== false,
            title: params.title || '',
            canvas: params.canvas
        });
        this.state = 'normal';
        this.renderCount = 0;
        this.tryInitEventSystem();
        this._background = (_a = params.background) !== null && _a !== void 0 ? _a : DefaultConfig.BACKGROUND;
        this.appendChild(this.layerService.createLayer(this, { main: true }));
        this.nextFrameRenderLayerSet = new Set();
        this.willNextFrameRender = false;
        this.stage = this;
        this.renderStyle = params.renderStyle;
        if (params.autoRender) {
            this.enableAutoRender();
        }
        if (params.autoRefresh) {
            this.enableAutoRefresh();
        }
        if (params.disableDirtyBounds === false) {
            this.enableDirtyBounds();
        }
        if (params.enableHtmlAttribute) {
            this.enableHtmlAttribute(params.enableHtmlAttribute);
        }
        if (params.ReactDOM) {
            this.enableReactAttribute(params.ReactDOM);
        }
        params.enableLayout && this.enableLayout();
        this.hooks.beforeRender.tap('constructor', this.beforeRender);
        this.hooks.afterRender.tap('constructor', this.afterRender);
        if (params.beforeRender) {
            this._beforeRenderList.push(params.beforeRender);
        }
        if (params.afterRender) {
            this._afterRenderList.push(params.afterRender);
        }
        this.hooks.afterClearScreen.tap('constructor', this.afterClearScreen);
        this.hooks.afterClearRect.tap('constructor', this.afterClearRect);
        this._afterClearScreen = params.afterClearScreen;
        this._afterClearRect = params.afterClearRect;
        this.supportInteractiveLayer = params.interactiveLayer !== false;
        if (!params.optimize) {
            params.optimize = {
                tickRenderMode: 'effect'
            };
        }
        this.optmize(params.optimize);
        if (params.background && isString(this._background) && this._background.includes('/')) {
            this.setAttributes({ background: this._background });
        }
        this.initAnimate(params);
        this.rafId = (_b = params.rafId) !== null && _b !== void 0 ? _b : Math.floor(Math.random() * 6);
    }
    initAnimate(params) {
        var _a;
        if (this.createTicker && this.createTimeline) {
            this._ticker = params.ticker || this.createTicker(this);
            this._ticker.bindStage(this);
            if (((_a = this.params.optimize) === null || _a === void 0 ? void 0 : _a.tickRenderMode) === 'performance') {
                this._ticker.setFPS(30);
            }
            this.timeline = this.createTimeline();
            this._ticker.addTimeline(this.timeline);
            this._ticker.on('tick', this.afterTickCb);
        }
    }
    startAnimate() {
        if (this._ticker && this.timeline) {
            this._ticker.start();
            this.timeline.resume();
        }
    }
    pauseRender(sr = -1) {
        this._skipRender = sr;
    }
    resumeRender() {
        this._skipRender = 0;
    }
    tryInitEventSystem() {
        if (this.global.supportEvent && !this._eventSystem) {
            this._eventSystem = new EventSystem(Object.assign({ targetElement: this.window, resolution: this.window.dpr || this.global.devicePixelRatio, rootNode: this, global: this.global, supportsPointerEvents: this.params.supportsPointerEvents, supportsTouchEvents: this.params.supportsTouchEvents }, this.params.event));
        }
    }
    preventRender(prevent) {
        if (prevent) {
            this._skipRender = -Infinity;
        }
        else {
            if (this.params.optimize.skipRenderWithOutRange !== false) {
                this._skipRender = this.window.isVisible() ? 0 : 1;
            }
            else {
                this._skipRender = 0;
            }
        }
    }
    optmize(params) {
        this.optmizeRender(params.skipRenderWithOutRange);
        this.params.optimize = params;
    }
    optmizeRender(skipRenderWithOutRange = false) {
        if (!skipRenderWithOutRange) {
            return;
        }
        this._skipRender = this._skipRender < 0 ? this._skipRender : this.window.isVisible() ? 0 : 1;
        this.window.onVisibleChange(this._onVisibleChange);
    }
    getTimeline() {
        return this.timeline;
    }
    get3dOptions(options) {
        const { center = { x: this.width / 2, y: this.height / 2, z: 0, dx: 0, dy: 0, dz: 0 }, light = {}, alpha = 0, beta = 0, camera, fieldRatio = 1, fieldDepth } = options;
        return Object.assign(Object.assign({}, options), { center,
            light,
            alpha,
            beta,
            camera,
            fieldRatio,
            fieldDepth });
    }
    set3dOptions(options) {
        var _a, _b, _d, _e, _f, _g;
        this.option3d = options;
        const options3d = this.get3dOptions(options);
        const { light, center, camera, alpha, beta, fieldRatio, fieldDepth } = options3d;
        const { dir = [1, 1, -1], color = 'white', ambient } = light;
        const centerX = ((_a = center.x) !== null && _a !== void 0 ? _a : this.width / 2) + ((_b = center.dx) !== null && _b !== void 0 ? _b : 0);
        const centerY = ((_d = center.y) !== null && _d !== void 0 ? _d : this.height / 2) + ((_e = center.dy) !== null && _e !== void 0 ? _e : 0);
        const centerZ = ((_f = center.z) !== null && _f !== void 0 ? _f : 0) + ((_g = center.dz) !== null && _g !== void 0 ? _g : 0);
        const centerVec3 = [centerX, centerY, centerZ];
        const z = 1;
        let cameraX = 0;
        let cameraY = 0;
        let cameraZ = 0;
        if (!camera) {
            cameraX = Math.sin(alpha) + centerX;
            cameraY = Math.sin(beta) + centerY;
            cameraZ = Math.cos(alpha) * Math.cos(beta) * z;
        }
        const DirectionalLight = Factory.getPlugin('DirectionalLight');
        if (DirectionalLight) {
            this.light = new DirectionalLight(dir, color, ambient);
        }
        const cameraParams = {
            left: 0,
            right: this.width,
            top: 0,
            bottom: this.height,
            fieldRatio: fieldRatio,
            fieldDepth,
            viewParams: {
                pos: [cameraX, cameraY, cameraZ],
                center: centerVec3,
                up: [0, 1, 0]
            }
        };
        if (this.camera) {
            this.camera.params = cameraParams;
        }
        else {
            const OrthoCamera = Factory.getPlugin('OrthoCamera');
            if (OrthoCamera) {
                this.camera = new OrthoCamera(cameraParams);
            }
        }
        if (options.enableView3dTransform) {
            this.enableView3dTransform();
        }
    }
    setBeforeRender(cb) {
        this._beforeRenderList.push(cb);
    }
    removeBeforeRender(cb) {
        this._beforeRenderList = this._beforeRenderList.filter(c => c !== cb);
    }
    setAfterRender(cb) {
        this._afterRenderList.push(cb);
    }
    removeAfterRender(cb) {
        this._afterRenderList = this._afterRenderList.filter(c => c !== cb);
    }
    afterNextRender(cb) {
        if (!this._afterNextRenderCbs) {
            this._afterNextRenderCbs = [];
        }
        this._afterNextRenderCbs.push(cb);
    }
    enableView3dTransform() {
        if (this.view3dTranform) {
            return;
        }
        this.view3dTranform = true;
        const ViewTransform3dPlugin = Factory.getPlugin('ViewTransform3dPlugin');
        if (ViewTransform3dPlugin) {
            this.pluginService.register(new ViewTransform3dPlugin());
        }
    }
    disableView3dTranform() {
        if (!this.view3dTranform) {
            return;
        }
        this.view3dTranform = false;
        this.pluginService.findPluginsByName('ViewTransform3dPlugin').forEach(plugin => {
            this.pluginService.unRegister(plugin);
        });
    }
    enableAutoRender() {
        if (this.autoRender) {
            return;
        }
        this.autoRender = true;
        this.pluginService.register(new AutoRenderPlugin());
    }
    disableAutoRender() {
        if (!this.autoRender) {
            return;
        }
        this.autoRender = false;
        this.pluginService.findPluginsByName('AutoRenderPlugin').forEach(plugin => {
            this.pluginService.unRegister(plugin);
        });
    }
    enableAutoRefresh() {
        if (this.autoRefresh) {
            return;
        }
        this.autoRefresh = true;
        this.pluginService.register(new AutoRefreshPlugin());
    }
    disableAutoRefresh() {
        if (!this.autoRefresh) {
            return;
        }
        this.autoRefresh = false;
        this.pluginService.findPluginsByName('AutoRefreshPlugin').forEach(plugin => {
            this.pluginService.unRegister(plugin);
        });
    }
    enableIncrementalAutoRender() {
        if (this.increaseAutoRender) {
            return;
        }
        this.increaseAutoRender = true;
        this.pluginService.register(new IncrementalAutoRenderPlugin());
    }
    disableIncrementalAutoRender() {
        if (!this.increaseAutoRender) {
            return;
        }
        this.increaseAutoRender = false;
        this.pluginService.findPluginsByName('IncrementalAutoRenderPlugin').forEach(plugin => {
            this.pluginService.unRegister(plugin);
        });
    }
    enableDirtyBounds() {
        if (this.dirtyBounds) {
            return;
        }
        this.dirtyBounds = new Bounds();
        let plugin = this.pluginService.findPluginsByName('DirtyBoundsPlugin')[0];
        if (!plugin) {
            plugin = new DirtyBoundsPlugin();
            this.pluginService.register(plugin);
        }
        else {
            plugin.activate(this.pluginService);
        }
    }
    disableDirtyBounds() {
        if (!this.dirtyBounds) {
            return;
        }
        this.dirtyBounds = null;
        this.pluginService.findPluginsByName('DirtyBoundsPlugin').forEach(plugin => {
            this.pluginService.unRegister(plugin);
        });
    }
    enableLayout() {
        if (this._enableLayout) {
            return;
        }
        this._enableLayout = true;
        const FlexLayoutPlugin = Factory.getPlugin('FlexLayoutPlugin');
        if (FlexLayoutPlugin) {
            this.pluginService.register(new FlexLayoutPlugin());
        }
    }
    disableLayout() {
        if (!this._enableLayout) {
            return;
        }
        this._enableLayout = false;
        this.pluginService.findPluginsByName('FlexLayoutPlugin').forEach(plugin => {
            this.pluginService.unRegister(plugin);
        });
    }
    enableHtmlAttribute(container) {
        if (this.htmlAttribute) {
            return;
        }
        const HtmlAttributePlugin = Factory.getPlugin('HtmlAttributePlugin');
        if (HtmlAttributePlugin) {
            this.htmlAttribute = container;
            this.pluginService.register(new HtmlAttributePlugin());
        }
    }
    disableHtmlAttribute() {
        if (!this.htmlAttribute) {
            return;
        }
        this.htmlAttribute = false;
        this.pluginService.findPluginsByName('HtmlAttributePlugin').forEach(plugin => {
            this.pluginService.unRegister(plugin);
        });
    }
    enableReactAttribute(container) {
        if (this.reactAttribute) {
            return;
        }
        const ReactAttributePlugin = Factory.getPlugin('ReactAttributePlugin');
        if (ReactAttributePlugin) {
            this.reactAttribute = container;
            this.pluginService.register(new ReactAttributePlugin());
        }
    }
    disableReactAttribute() {
        if (!this.reactAttribute) {
            return;
        }
        this.reactAttribute = false;
        this.pluginService.findPluginsByName('ReactAttributePlugin').forEach(plugin => {
            this.pluginService.unRegister(plugin);
        });
    }
    getPluginsByName(name) {
        return this.pluginService.findPluginsByName(name);
    }
    tryUpdateAABBBounds() {
        const viewBox = this.window.getViewBox();
        this._AABBBounds.setValue(viewBox.x1, viewBox.y1, viewBox.x2, viewBox.y2);
        return this._AABBBounds;
    }
    combineLayer(ILayer1, ILayer2) {
        throw new Error('暂不支持');
    }
    createLayer(canvasId, layerMode) {
        if (this.releaseStatus === 'released') {
            return;
        }
        const layer = this.layerService.createLayer(this, {
            main: false,
            layerMode,
            canvasId
        });
        this.appendChild(layer);
        return layer;
    }
    sortLayer(cb) {
        const children = this.children;
        children.sort(cb);
        this.removeAllChild();
        children.forEach(c => {
            this.appendChild(c);
        });
    }
    removeLayer(ILayerId) {
        return this.removeChild(this.findChildByUid(ILayerId));
    }
    tryInitInteractiveLayer() {
        if (this.releaseStatus === 'released') {
            return;
        }
        if (this.supportInteractiveLayer && !this.interactiveLayer) {
            this.interactiveLayer = this.createLayer();
            this.interactiveLayer.name = '_builtin_interactive';
            this.interactiveLayer.attribute.pickable = false;
            this.nextFrameRenderLayerSet.add(this.interactiveLayer);
        }
    }
    clearViewBox(color) {
        this.window.clearViewBox(color);
    }
    render(layers, params) {
        if (this.releaseStatus === 'released') {
            return;
        }
        this.startAnimate();
        const state = this.state;
        this.state = 'rendering';
        this.layerService.prepareStageLayer(this);
        if (!this._skipRender) {
            this.lastRenderparams = params;
            this.hooks.beforeRender.call(this);
            if (!this._skipRender) {
                this.renderLayerList(this.children);
                this.combineLayersToWindow();
                this.nextFrameRenderLayerSet.clear();
            }
            this.hooks.afterRender.call(this);
        }
        this.state = state;
        this._skipRender && this._skipRender++;
    }
    combineLayersToWindow() {
        if (this.global.env === 'harmony') {
            const ctx = this.window.getContext().nativeContext;
            this.forEachChildren((layer, i) => {
                if (i > 0) {
                    const image = layer
                        .getNativeHandler()
                        .getContext()
                        .canvas.nativeCanvas.nativeCanvas._c.transferToImageBitmap();
                    ctx.transferFromImageBitmap(image);
                }
            });
        }
        return;
    }
    renderNextFrame(layers, force) {
        if (this.nextFrameRenderLayerSet.size !== this.childrenCount) {
            (layers || this).forEach((layer) => {
                this.nextFrameRenderLayerSet.add(layer);
            });
        }
        if (!this.willNextFrameRender) {
            this.willNextFrameRender = true;
            this.global.getSpecifiedRequestAnimationFrame(this.rafId)(() => {
                this._doRenderInThisFrame(), (this.willNextFrameRender = false);
            });
        }
    }
    _doRenderInThisFrame() {
        if (this.releaseStatus === 'released') {
            return;
        }
        this.startAnimate();
        const state = this.state;
        this.state = 'rendering';
        this.layerService.prepareStageLayer(this);
        if (this.nextFrameRenderLayerSet.size && !this._skipRender) {
            this.hooks.beforeRender.call(this);
            if (!this._skipRender) {
                this.renderLayerList(Array.from(this.nextFrameRenderLayerSet.values()), this.lastRenderparams || {});
                this.combineLayersToWindow();
                this.nextFrameRenderLayerSet.clear();
            }
            this.hooks.afterRender.call(this);
        }
        this.state = state;
        this._skipRender && this._skipRender++;
    }
    renderLayerList(layerList, params) {
        const list = [];
        for (let i = 0; i < layerList.length; i++) {
            let l = layerList[i];
            if (l.layerMode === 'virtual') {
                l = l.getNativeHandler().mainHandler.layer;
            }
            if (!list.includes(l)) {
                list.push(l);
            }
        }
        list.forEach(layer => {
            if (layer.renderCount > this.renderCount) {
                return;
            }
            layer.renderCount = this.renderCount + 1;
            if (layer === this.interactiveLayer) {
                this.dirtyBounds && this.dirtyBounds.clear();
            }
            layer.render({
                renderService: this.renderService,
                background: layer === this.defaultLayer ? this.background : undefined,
                updateBounds: !!(this.dirtyBounds && !this.dirtyBounds.empty()),
                viewBox: this.window.getViewBox(),
                transMatrix: this.window.getViewBoxTransform()
            }, Object.assign({ renderStyle: this.renderStyle }, params));
        });
        if (this.interactiveLayer && !layerList.includes(this.interactiveLayer)) {
            this.dirtyBounds && this.dirtyBounds.clear();
            this.interactiveLayer.render({
                renderService: this.renderService,
                updateBounds: !!(this.dirtyBounds && !this.dirtyBounds.empty()),
                viewBox: this.window.getViewBox(),
                transMatrix: this.window.getViewBoxTransform()
            }, Object.assign({ renderStyle: this.renderStyle }, params));
        }
    }
    resizeWindow(w, h, rerender = true) {
        this.window.resize(w, h);
        rerender && this.render();
    }
    resize(w, h, rerender = true) {
        if (this.releaseStatus === 'released') {
            return;
        }
        if (!this.window.hasSubView()) {
            this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h);
        }
        this.window.resize(w, h);
        this.forEachChildren(c => {
            c.resize(w, h);
        });
        this.camera && this.option3d && this.set3dOptions(this.option3d);
        rerender && this.render();
    }
    resizeView(w, h, rerender = true) {
        if (this.releaseStatus === 'released') {
            return;
        }
        this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h);
        this.forEachChildren(c => {
            c.resizeView(w, h);
        });
        this.camera && (this.camera.params = Object.assign(Object.assign({}, this.camera.params), { right: this.width, bottom: this.height }));
        rerender && this.render();
    }
    setViewBox(x, y, w, h, rerender) {
        let isRerender = true;
        if (typeof x === 'object') {
            this.viewBox.setValue(x.x1, x.y1, x.x2, x.y2);
            if (y === false) {
                isRerender = false;
            }
        }
        else {
            this.viewBox.setValue(x, y, x + w, y + h);
            if (rerender === false) {
                isRerender = false;
            }
        }
        this.forEachChildren(c => {
            c.resizeView(this.viewBox.width(), this.viewBox.height());
        });
        isRerender && this.render();
    }
    setDpr(dpr, rerender = true) {
        this.forEachChildren(c => {
            c.setDpr(dpr);
        });
        rerender && this.render();
    }
    setOrigin(x, y) {
        throw new Error('暂不支持');
    }
    export(type) {
        throw new Error('暂不支持');
    }
    pick(x, y) {
        if (this.releaseStatus === 'released') {
            return;
        }
        const result = this.getPickerService().pick(this.children, new Point(x, y), {
            bounds: this.AABBBounds
        });
        if ((result === null || result === void 0 ? void 0 : result.graphic) || (result === null || result === void 0 ? void 0 : result.group)) {
            return result;
        }
        return false;
    }
    setToFrame(t) {
        throw new Error('暂不支持');
    }
    release() {
        var _a, _b;
        super.release();
        this.hooks.beforeRender.unTap('constructor', this.beforeRender);
        this.hooks.afterRender.unTap('constructor', this.afterRender);
        this.eventSystem && this.eventSystem.release();
        this.layerService.releaseStage(this);
        this.pluginService.release();
        this.forEach(layer => {
            layer.release();
        });
        if (this.interactiveLayer) {
            this.interactiveLayer.forEachChildren((item) => {
                item.setStage && item.setStage(null, null);
                this.interactiveLayer.removeChild(item);
            });
            this.interactiveLayer.release();
        }
        this.window.release();
        (_a = this._ticker) === null || _a === void 0 ? void 0 : _a.remTimeline(this === null || this === void 0 ? void 0 : this.timeline);
        (_b = this._ticker) === null || _b === void 0 ? void 0 : _b.removeListener('tick', this.afterTickCb);
        this.renderService.renderTreeRoots = [];
    }
    setStage(stage) {
        return;
    }
    dirty(b, matrix) {
        if (this.releaseStatus === 'released') {
            return;
        }
        if (matrix) {
            b.transformWithMatrix(matrix);
        }
        if (this.dirtyBounds.empty()) {
            this.dirtyBounds.setValue(b.x1, b.y1, b.x2, b.y2);
        }
        this.dirtyBounds.union(b);
    }
    getLayer(name) {
        const layer = this.children.filter(layer => layer.name === name);
        return layer[0];
    }
    renderTo(window) {
        if (this.releaseStatus === 'released') {
            return;
        }
        this.forEachChildren((layer, i) => {
            layer.drawTo(window, {
                renderService: this.renderService,
                viewBox: window.getViewBox(),
                transMatrix: window.getViewBoxTransform(),
                background: layer === this.defaultLayer ? this.background : undefined,
                clear: i === 0,
                updateBounds: !!(this.dirtyBounds && !this.dirtyBounds.empty())
            });
        });
    }
    renderToNewWindow(fullImage = true, viewBox) {
        if (this.releaseStatus === 'released') {
            return;
        }
        const window = container.get(VWindow);
        const x1 = viewBox ? -viewBox.x1 : 0;
        const y1 = viewBox ? -viewBox.y1 : 0;
        const x2 = viewBox ? viewBox.x2 : this.viewWidth;
        const y2 = viewBox ? viewBox.y2 : this.viewHeight;
        const width = viewBox ? viewBox.width() : this.viewWidth;
        const height = viewBox ? viewBox.height() : this.viewHeight;
        if (fullImage) {
            window.create({
                viewBox: { x1, y1, x2, y2 },
                width,
                height,
                dpr: this.window.dpr,
                canvasControled: true,
                offscreen: true,
                title: ''
            });
        }
        else {
            window.create({
                viewBox: { x1, y1, x2, y2 },
                width,
                height,
                dpr: this.window.dpr,
                canvasControled: true,
                offscreen: true,
                title: ''
            });
        }
        this.renderTo(window);
        return window;
    }
    toCanvas(fullImage = true, viewBox) {
        if (this.releaseStatus === 'released') {
            return;
        }
        const window = this.renderToNewWindow(fullImage, viewBox);
        const c = window.getNativeHandler();
        if (c.nativeCanvas) {
            return c.nativeCanvas;
        }
        return null;
    }
    setCursor(mode) {
        this._cursor = mode;
        this.eventSystem.setCursor(mode, 'ignore');
    }
    getCursor() {
        return this._cursor;
    }
    eventPointTransform(e) {
        const point = this.global.mapToCanvasPoint(e, this.window);
        return this.stage.window.pointTransform(point.x, point.y);
    }
    pauseTriggerEvent() {
        this._eventSystem && this._eventSystem.pauseTriggerEvent();
    }
    resumeTriggerEvent() {
        this._eventSystem && this._eventSystem.resumeTriggerEvent();
    }
    getPickerService() {
        if (!this.pickerService) {
            this.pickerService = container.get(PickerService);
        }
        return this.pickerService;
    }
    reInit() {
        this.renderService.reInit();
        this.pickerService.reInit();
    }
}

function createStage(params) {
    return new Stage(params);
}

let BaseEnvContribution = class BaseEnvContribution {
    configure(service, ...p) {
        if (service.env === this.type) {
            service.setActiveEnvContribution(this);
        }
    }
    getNativeAABBBounds(dom) {
        return new AABBBounds();
    }
    removeDom(dom) {
        return false;
    }
    createDom(params) {
        return null;
    }
    updateDom(dom, params) {
        return false;
    }
    getDynamicCanvasCount() {
        return 999;
    }
    getStaticCanvasCount() {
        return 999;
    }
    getElementById(str) {
        return document.getElementById(str);
    }
    getRootElement() {
        return document.body;
    }
    loadJson(url) {
        const jsonPromise = fetch(url).then(data => data.json());
        jsonPromise
            .then(json => {
            return {
                data: json,
                state: 'success'
            };
        })
            .catch(() => {
            return {
                data: null,
                state: 'fail'
            };
        });
        return jsonPromise;
    }
    loadArrayBuffer(url) {
        const arrayBufferPromise = fetch(url).then(data => data.arrayBuffer());
        return arrayBufferPromise
            .then((arrayBuffer) => {
            return {
                data: arrayBuffer,
                loadState: 'success'
            };
        })
            .catch(() => {
            return {
                data: null,
                loadState: 'fail'
            };
        });
    }
    loadBlob(url) {
        const blobPromise = fetch(url).then(data => data.blob());
        return blobPromise
            .then((blob) => {
            return {
                data: blob,
                loadState: 'success'
            };
        })
            .catch(() => {
            return {
                data: null,
                loadState: 'fail'
            };
        });
    }
    getElementTop(dom, baseWindow) {
        return 0;
    }
    getElementLeft(dom, baseWindow) {
        return 0;
    }
    getElementTopLeft(dom, baseWindow) {
        return { top: 0, left: 0 };
    }
    loadFont(font, source, descriptors) {
        return __awaiter(this, void 0, void 0, function* () {
            return { loadState: 'fail' };
        });
    }
    isMacOS() {
        return false;
    }
    copyToClipBoard(text) {
        return Promise.resolve(null);
    }
};
BaseEnvContribution = __decorate([
    injectable()
], BaseEnvContribution);

let BaseWindowHandlerContribution = class BaseWindowHandlerContribution {
    constructor() {
        this._uid = Generator.GenAutoIncrementId();
        this.viewBox = new AABBBounds();
        this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    }
    onChange(cb) {
        this._onChangeCb = cb;
    }
    configure(window, global) {
        if (global.env === this.type) {
            window.setWindowHandler(this);
        }
    }
    release(...params) {
        this.releaseWindow();
    }
    isVisible(bbox) {
        return true;
    }
    onVisibleChange(cb) {
        return;
    }
    getTopLeft(baseWindow) {
        return {
            top: 0,
            left: 0
        };
    }
    setViewBox(vb) {
        this.viewBox.setValue(vb.x1, vb.y1, vb.x2, vb.y2);
    }
    getViewBox() {
        return this.viewBox;
    }
    setViewBoxTransform(a, b, c, d, e, f) {
        this.modelMatrix.setValue(a, b, c, d, e, f);
    }
    getViewBoxTransform() {
        return this.modelMatrix;
    }
};
BaseWindowHandlerContribution = __decorate([
    injectable(),
    __metadata("design:paramtypes", [])
], BaseWindowHandlerContribution);

class DirectionalLight {
    constructor(dir, color, ambient = 0.8) {
        this.dir = dir;
        this.color = color;
        this.colorRgb = ColorStore.Get(color, ColorType.Color1);
        this.ambient = ambient;
        const length = sqrt(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);
        this.formatedDir = [dir[0] / length, dir[1] / length, dir[2] / length];
    }
    computeColor(normal, color) {
        const lightDir = this.formatedDir;
        const brightness = min(max((normal[0] * lightDir[0] + normal[1] * lightDir[1] + normal[2] * lightDir[2]) * (1 - this.ambient / 2), 0) +
            this.ambient, 1);
        let colorArray;
        if (isString(color)) {
            colorArray = ColorStore.Get(color, ColorType.Color1);
        }
        else {
            colorArray = color;
        }
        const lightColorArray = this.colorRgb;
        return `rgb(${lightColorArray[0] * colorArray[0] * brightness}, ${lightColorArray[1] * colorArray[1] * brightness}, ${lightColorArray[2] * colorArray[2] * brightness})`;
    }
}
const registerDirectionalLight = () => {
    Factory.registerPlugin('DirectionalLight', DirectionalLight);
};

class OrthoCamera {
    set params(params) {
        this._params = Object.assign({}, params);
        this._projectionMatrixCached = this.forceGetProjectionMatrix();
        this._viewMatrixCached = this.forceGetViewMatrix();
    }
    get params() {
        return Object.assign({}, this._params);
    }
    constructor(params) {
        this.params = params;
    }
    getViewMatrix() {
        if (!this._viewMatrixCached) {
            this._viewMatrixCached = mat4Allocate.allocate();
        }
        return this._viewMatrixCached;
    }
    forceGetViewMatrix() {
        if (!this._viewMatrixCached) {
            this._viewMatrixCached = mat4Allocate.allocate();
        }
        const { pos, center, up } = this.params.viewParams;
        lookAt(this._viewMatrixCached, pos, center, up);
        if (!this._vp) {
            this._vp = mat4Allocate.allocate();
        }
        this._vp = multiplyMat4Mat4(this._vp, this.getProjectionMatrix(), this.getViewMatrix());
        return this._viewMatrixCached;
    }
    getProjectionMatrix() {
        if (!this._projectionMatrixCached) {
            this._projectionMatrixCached = mat4Allocate.allocate();
        }
        return this._projectionMatrixCached;
    }
    forceGetProjectionMatrix() {
        if (!this._projectionMatrixCached) {
            this._projectionMatrixCached = mat4Allocate.allocate();
        }
        const { left, top, right, bottom } = this._params;
        ortho(this._projectionMatrixCached, left, right, bottom, top, 0.0, -2000000.0);
        if (!this._vp) {
            this._vp = mat4Allocate.allocate();
        }
        this._vp = multiplyMat4Mat4(this._vp, this.getProjectionMatrix(), this.getViewMatrix());
        return this._projectionMatrixCached;
    }
    getField() {
        const { fieldRatio = 0.8, fieldDepth, left, right } = this._params;
        return (fieldDepth !== null && fieldDepth !== void 0 ? fieldDepth : right - left) * fieldRatio;
    }
    getProjectionScale(z) {
        const field = this.getField();
        return field / (field + z);
    }
    view(x, y, z) {
        const outP = [0, 0, 0];
        transformMat4(outP, [x, y, z], this._viewMatrixCached);
        return outP;
    }
    vp(x, y, z) {
        const outP = [0, 0, 0];
        const { pos } = this._params.viewParams;
        transformMat4(outP, [x, y, z], this._viewMatrixCached);
        x = outP[0];
        y = outP[1];
        z = outP[2];
        const sizeProjection = this.getProjectionScale(z);
        const xProject = x * sizeProjection + pos[0];
        const yProject = y * sizeProjection + pos[1];
        return {
            x: xProject,
            y: yProject
        };
    }
}
const registerOrthoCamera = () => {
    Factory.registerPlugin('OrthoCamera', OrthoCamera);
};

let DefaultPickService = class DefaultPickService {
    constructor(pickItemInterceptorContributions, pickServiceInterceptorContributions) {
        this.pickItemInterceptorContributions = pickItemInterceptorContributions;
        this.pickServiceInterceptorContributions = pickServiceInterceptorContributions;
        this.type = 'default';
        this.global = application.global;
    }
    reInit() {
        this._init();
    }
    _init() {
        this.InterceptorContributions = this.pickItemInterceptorContributions
            .getContributions()
            .sort((a, b) => a.order - b.order);
        this.pickerServiceInterceptorContributions = this.pickServiceInterceptorContributions
            .getContributions()
            .sort((a, b) => a.order - b.order);
    }
    pick(graphics, point, params) {
        let result = {
            graphic: null,
            group: null
        };
        params.pickerService = this;
        const w = params.bounds.width();
        const h = params.bounds.height();
        if (!new AABBBounds().setValue(0, 0, w, h).containsPoint(point)) {
            return result;
        }
        if (this.pickContext) {
            this.pickContext.inuse = true;
        }
        params.pickContext = this.pickContext;
        this.pickContext && this.pickContext.clearMatrix(true, 1);
        const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
        let group;
        for (let i = graphics.length - 1; i >= 0; i--) {
            if (graphics[i].isContainer) {
                result = this.pickGroup(graphics[i], point, parentMatrix, params);
            }
            else {
                result = this.pickItem(graphics[i], point, parentMatrix, params);
            }
            if (result.graphic) {
                break;
            }
            if (!group) {
                group = result.group;
            }
        }
        if (!result.graphic) {
            result.group = group;
        }
        if (this.pickContext) {
            this.pickContext.inuse = false;
        }
        if (this.pickerServiceInterceptorContributions.length) {
            for (let i = 0; i < this.pickerServiceInterceptorContributions.length; i++) {
                const drawContribution = this.pickerServiceInterceptorContributions[i];
                if (drawContribution.afterPickItem) {
                    result = drawContribution.afterPickItem(result, this, point, params, { parentMatrix });
                }
            }
        }
        return result;
    }
    containsPoint(graphic, point, params) {
        var _a;
        return !!((_a = this.pickItem(graphic, point, null, params !== null && params !== void 0 ? params : { pickContext: this.pickContext, pickerService: this })) === null || _a === void 0 ? void 0 : _a.graphic);
    }
    pickGroup(group, point, parentMatrix, params) {
        let result = {
            group: null,
            graphic: null
        };
        if (group.attribute.visibleAll === false) {
            return result;
        }
        const context = params.pickContext;
        const lastMatrix = context.modelMatrix;
        if (context.camera) {
            const m = group.transMatrix;
            const matrix = mat4Allocate.allocate();
            mat3Tomat4(matrix, m);
            if (lastMatrix) {
                if (matrix) {
                    const m = mat4Allocate.allocate();
                    context.modelMatrix = multiplyMat4Mat4(m, lastMatrix, matrix);
                    mat4Allocate.free(matrix);
                }
            }
            else {
                mat3Tomat4(matrix, group.globalTransMatrix);
                context.modelMatrix = matrix;
            }
        }
        if (this.InterceptorContributions.length) {
            for (let i = 0; i < this.InterceptorContributions.length; i++) {
                const drawContribution = this.InterceptorContributions[i];
                if (drawContribution.beforePickItem) {
                    const result = drawContribution.beforePickItem(group, this, point, params, { parentMatrix });
                    if (result) {
                        if (context.modelMatrix !== lastMatrix) {
                            mat4Allocate.free(context.modelMatrix);
                        }
                        context.modelMatrix = lastMatrix;
                        return result;
                    }
                }
            }
        }
        const transMatrix = group.transMatrix;
        const currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix);
        const newPoint = new Point(point.x, point.y);
        currentGroupMatrix.transformPoint(newPoint, newPoint);
        const insideGroup = group.AABBBounds.containsPoint(newPoint);
        if (!insideGroup && !group.stage.camera) {
            return result;
        }
        const pickedItem = this.pickItem(group, newPoint.clone(), parentMatrix, params);
        if (pickedItem && pickedItem.graphic) {
            result.graphic = pickedItem.graphic;
            result.params = pickedItem.params;
        }
        const groupPicked = group.attribute.pickable !== false && insideGroup;
        currentGroupMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f);
        if (group.attribute.childrenPickable !== false && !(pickedItem && pickedItem.graphic)) {
            foreach(group, DefaultAttribute.zIndex, (graphic) => {
                if (graphic.isContainer) {
                    const newPoint = new Point(point.x, point.y);
                    const theme = getTheme(group).group;
                    const { scrollX = theme.scrollX, scrollY = theme.scrollY } = group.attribute;
                    newPoint.x -= scrollX;
                    newPoint.y -= scrollY;
                    result = this.pickGroup(graphic, newPoint, currentGroupMatrix, params);
                }
                else {
                    const newPoint = new Point(point.x, point.y);
                    currentGroupMatrix.transformPoint(newPoint, newPoint);
                    const theme = getTheme(group).group;
                    const { scrollX = theme.scrollX, scrollY = theme.scrollY } = group.attribute;
                    newPoint.x -= scrollX;
                    newPoint.y -= scrollY;
                    const pickedItem = this.pickItem(graphic, newPoint, parentMatrix, params);
                    if (pickedItem && pickedItem.graphic) {
                        result.graphic = pickedItem.graphic;
                        result.params = pickedItem.params;
                    }
                }
                return !!result.graphic || !!result.group;
            }, true, !!context.camera);
        }
        if (context.modelMatrix !== lastMatrix) {
            mat4Allocate.free(context.modelMatrix);
        }
        context.modelMatrix = lastMatrix;
        if (!result.graphic && !result.group && groupPicked && !group.stage.camera) {
            result.group = group;
        }
        matrixAllocate.free(currentGroupMatrix);
        return result;
    }
    selectPicker(graphic) {
        const picker = this.pickerMap.get(graphic.numberType);
        if (!picker) {
            return null;
        }
        return picker;
    }
};
DefaultPickService = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(PickItemInterceptor)),
    __param(1, inject(ContributionProvider)),
    __param(1, named(PickServiceInterceptor)),
    __metadata("design:paramtypes", [Object, Object])
], DefaultPickService);

let DefaultGlobalPickerService = class DefaultGlobalPickerService {
    constructor() {
        this.global = application.global;
        this.global.hooks.onSetEnv.tap('global-picker-service', (lastEnv, env, global) => {
            this.configure(global, env);
        });
        this.configure(this.global, this.global.env);
    }
    reInit() {
        return;
    }
    configure(global, env) {
    }
    pick(graphics, point, params) {
        let result = {
            graphic: null,
            group: null
        };
        const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
        let group;
        for (let i = 0; i < graphics.length; i++) {
            if (graphics[i].isContainer) {
                result = this.pickGroup(graphics[i], point, parentMatrix, params);
            }
            else {
                const data = this.pickItem(graphics[i], point, parentMatrix, params);
                if (data) {
                    result.graphic = data.graphic;
                    result.params = data.params;
                }
            }
            if (result.graphic) {
                break;
            }
            if (!group) {
                group = result.group;
            }
        }
        if (!result.graphic) {
            result.group = group;
        }
        if (result.graphic) {
            let g = result.graphic;
            while (g.parent) {
                g = g.parent;
            }
            if (g.shadowHost) {
                result.params = {
                    shadowTarget: result.graphic
                };
                result.graphic = g.shadowHost;
            }
        }
        return result;
    }
    containsPoint(graphic, point, params) {
        return !!this.pickItem(graphic, point, null, params);
    }
    pickGroup(group, point, parentMatrix, params) {
        let result = {
            group: null,
            graphic: null
        };
        if (group.attribute.visibleAll === false) {
            return result;
        }
        const transMatrix = group.transMatrix;
        const newPoint = new Point(point.x, point.y);
        parentMatrix.transformPoint(newPoint, newPoint);
        const insideGroup = group.AABBBounds.containsPoint(newPoint);
        if (!insideGroup) {
            return result;
        }
        const groupPicked = group.attribute.pickable !== false && insideGroup;
        parentMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f);
        if (group.attribute.childrenPickable !== false) {
            group.forEachChildren((graphic) => {
                if (graphic.isContainer) {
                    result = this.pickGroup(graphic, point, parentMatrix, params);
                }
                else {
                    const newPoint = new Point(point.x, point.y);
                    parentMatrix.transformPoint(newPoint, newPoint);
                    const data = this.pickItem(graphic, newPoint, parentMatrix, params);
                    if (data) {
                        result.graphic = data.graphic;
                        result.params = data.params;
                    }
                }
                return !!result.graphic || !!result.group;
            });
        }
        if (!result.graphic && !result.group && groupPicked) {
            result.group = group;
        }
        return result;
    }
    pickItem(graphic, point, parentMatrix, params) {
        if (graphic.attribute.pickable === false) {
            return null;
        }
        if (graphic.AABBBounds.containsPoint(point)) {
            return {
                graphic: graphic
            };
        }
        return null;
    }
};
DefaultGlobalPickerService = __decorate([
    injectable(),
    __metadata("design:paramtypes", [])
], DefaultGlobalPickerService);

function simplifyRadialDist(points, sqTolerance) {
    let lastX = points[0].x;
    let lastY = points[0].y;
    let deltaX;
    let deltaY;
    const newPoints = [points[0]];
    for (let i = 1, len = points.length; i < len; i++) {
        deltaX = points[i].x - lastX;
        deltaY = points[i].y - lastY;
        if (deltaX * deltaX + deltaY * deltaY > sqTolerance) {
            lastX = points[i].x;
            lastY = points[i].y;
            newPoints.push(points[i]);
        }
    }
    if (points[points.length - 1].x !== lastX || points[points.length - 1].y !== lastY) {
        newPoints.push(points[points.length - 1]);
    }
    return newPoints;
}
function flatten_simplify(points, tolerance, highestQuality) {
    if (points.length <= 10) {
        return points;
    }
    const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    return points;
}

function diff(oldAttrs, newAttrs, getAttr) {
    const diffObj = {};
    for (const key in newAttrs) {
        if (!(key in oldAttrs) || !isEqual(oldAttrs[key], newAttrs[key])) {
            diffObj[key] = newAttrs[key];
        }
    }
    if (getAttr) {
        for (const key in oldAttrs) {
            if (!(key in newAttrs)) {
                const value = getAttr(key);
                if (value !== undefined) {
                    diffObj[key] = value;
                }
            }
        }
    }
    return diffObj;
}

function cubicSubdivide(p0, p1, p2, p3, t, out) {
    const p01 = (p1 - p0) * t + p0;
    const p12 = (p2 - p1) * t + p1;
    const p23 = (p3 - p2) * t + p2;
    const p012 = (p12 - p01) * t + p01;
    const p123 = (p23 - p12) * t + p12;
    const p0123 = (p123 - p012) * t + p012;
    out[0] = p0;
    out[1] = p01;
    out[2] = p012;
    out[3] = p0123;
    out[4] = p0123;
    out[5] = p123;
    out[6] = p23;
    out[7] = p3;
}
function alignSubpath(subpath1, subpath2) {
    const len1 = subpath1.length;
    const len2 = subpath2.length;
    if (len1 === len2) {
        return [subpath1, subpath2];
    }
    const tmpSegX = [];
    const tmpSegY = [];
    const shorterPath = len1 < len2 ? subpath1 : subpath2;
    const shorterLen = Math.min(len1, len2);
    const diff = Math.abs(len2 - len1) / 6;
    const shorterBezierCount = (shorterLen - 2) / 6;
    const eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount);
    const newSubpath = [shorterPath[0], shorterPath[1]];
    let remained = diff;
    for (let i = 2; i < shorterLen; i += 6) {
        let x0 = shorterPath[i - 2];
        let y0 = shorterPath[i - 1];
        let x1 = shorterPath[i];
        let y1 = shorterPath[i + 1];
        let x2 = shorterPath[i + 2];
        let y2 = shorterPath[i + 3];
        const x3 = shorterPath[i + 4];
        const y3 = shorterPath[i + 5];
        if (remained <= 0) {
            newSubpath.push(x1, y1, x2, y2, x3, y3);
            continue;
        }
        const actualSubDivCount = Math.min(remained, eachCurveSubDivCount) + 1;
        for (let k = 1; k <= actualSubDivCount; k++) {
            const p = k / actualSubDivCount;
            cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);
            cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);
            x0 = tmpSegX[3];
            y0 = tmpSegY[3];
            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);
            x1 = tmpSegX[5];
            y1 = tmpSegY[5];
            x2 = tmpSegX[6];
            y2 = tmpSegY[6];
        }
        remained -= actualSubDivCount - 1;
    }
    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
}
function createSubpath(lastSubpath, otherSubpath) {
    const prevSubPath = lastSubpath || otherSubpath;
    const len = prevSubPath.length;
    const lastX = prevSubPath[len - 2];
    const lastY = prevSubPath[len - 1];
    const newSubpath = [];
    for (let i = 0; i < otherSubpath.length; i += 2) {
        newSubpath[i] = lastX;
        newSubpath[i + 1] = lastY;
    }
    return newSubpath;
}
function reverseSubpath(array) {
    const newArr = [];
    const len = array.length;
    for (let i = 0; i < len; i += 2) {
        newArr[i] = array[len - i - 2];
        newArr[i + 1] = array[len - i - 1];
    }
    return newArr;
}
function centroidOfSubpath(array) {
    let signedArea = 0;
    let cx = 0;
    let cy = 0;
    const len = array.length;
    for (let i = 0, j = len - 2; i < len; j = i, i += 2) {
        const x0 = array[j];
        const y0 = array[j + 1];
        const x1 = array[i];
        const y1 = array[i + 1];
        const a = x0 * y1 - x1 * y0;
        signedArea += a;
        cx += (x0 + x1) * a;
        cy += (y0 + y1) * a;
    }
    if (signedArea === 0) {
        return [array[0] || 0, array[1] || 0, 0];
    }
    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];
}
function findBestRotationOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
    const bezierCount = (fromSubBeziers.length - 2) / 6;
    let bestScore = Infinity;
    let bestOffset = 0;
    const len = fromSubBeziers.length;
    const len2 = len - 2;
    for (let offset = 0; offset < bezierCount; offset++) {
        const cursorOffset = offset * 6;
        let score = 0;
        for (let k = 0; k < len; k += 2) {
            const idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2) + 2;
            const x0 = fromSubBeziers[idx] - fromCp[0];
            const y0 = fromSubBeziers[idx + 1] - fromCp[1];
            const x1 = toSubBeziers[k] - toCp[0];
            const y1 = toSubBeziers[k + 1] - toCp[1];
            const dx = x1 - x0;
            const dy = y1 - y0;
            score += dx * dx + dy * dy;
        }
        if (score < bestScore) {
            bestScore = score;
            bestOffset = offset;
        }
    }
    return bestOffset;
}
function findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {
    const result = [];
    let fromNeedsReverse;
    for (let i = 0; i < fromArr.length; i++) {
        let fromSubpathBezier = fromArr[i];
        const toSubpathBezier = toArr[i];
        const fromCp = centroidOfSubpath(fromSubpathBezier);
        const toCp = centroidOfSubpath(toSubpathBezier);
        if (fromNeedsReverse == null) {
            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;
        }
        const newFromSubpathBezier = [];
        const newToSubpathBezier = [];
        let bestAngle = 0;
        let bestScore = Infinity;
        const tmpArr = [];
        const len = fromSubpathBezier.length;
        if (fromNeedsReverse) {
            fromSubpathBezier = reverseSubpath(fromSubpathBezier);
        }
        const offset = findBestRotationOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;
        const len2 = len - 2;
        for (let k = 0; k < len2; k += 2) {
            const idx = ((offset + k) % len2) + 2;
            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];
            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
        }
        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];
        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];
        if (searchAngleIteration > 0) {
            const step = searchAngleRange / searchAngleIteration;
            for (let angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
                const sa = Math.sin(angle);
                const ca = Math.cos(angle);
                let score = 0;
                for (let k = 0; k < fromSubpathBezier.length; k += 2) {
                    const x0 = newFromSubpathBezier[k];
                    const y0 = newFromSubpathBezier[k + 1];
                    const x1 = toSubpathBezier[k] - toCp[0];
                    const y1 = toSubpathBezier[k + 1] - toCp[1];
                    const newX1 = x1 * ca - y1 * sa;
                    const newY1 = x1 * sa + y1 * ca;
                    tmpArr[k] = newX1;
                    tmpArr[k + 1] = newY1;
                    const dx = newX1 - x0;
                    const dy = newY1 - y0;
                    score += dx * dx + dy * dy;
                }
                if (score < bestScore) {
                    bestScore = score;
                    bestAngle = angle;
                    for (let m = 0; m < tmpArr.length; m++) {
                        newToSubpathBezier[m] = tmpArr[m];
                    }
                }
            }
        }
        else {
            for (let i = 0; i < len; i += 2) {
                newToSubpathBezier[i] = toSubpathBezier[i] - toCp[0];
                newToSubpathBezier[i + 1] = toSubpathBezier[i + 1] - toCp[1];
            }
        }
        result.push({
            from: newFromSubpathBezier,
            to: newToSubpathBezier,
            fromCp,
            toCp,
            rotation: -bestAngle
        });
    }
    return result;
}
function alignBezierCurves(array1, array2) {
    let lastSubpath1;
    let lastSubpath2;
    const newArray1 = [];
    const newArray2 = [];
    for (let i = 0; i < Math.max(array1.length, array2.length); i++) {
        const subpath1 = array1[i];
        const subpath2 = array2[i];
        let newSubpath1;
        let newSubpath2;
        if (!subpath1) {
            newSubpath1 = createSubpath(lastSubpath1, subpath2);
            newSubpath2 = subpath2;
        }
        else if (!subpath2) {
            newSubpath2 = createSubpath(lastSubpath2, subpath1);
            newSubpath1 = subpath1;
        }
        else {
            [newSubpath1, newSubpath2] = alignSubpath(subpath1, subpath2);
            lastSubpath1 = newSubpath1;
            lastSubpath2 = newSubpath2;
        }
        newArray1.push(newSubpath1);
        newArray2.push(newSubpath2);
    }
    return [newArray1, newArray2];
}
function pathToBezierCurves(path) {
    const tempPath = new CustomPath2D();
    const svgPathString = path.toString();
    if (!svgPathString) {
        return [];
    }
    tempPath.fromString(svgPathString);
    const curves = tempPath.tryBuildCurves();
    if (!curves || curves.length === 0) {
        return [];
    }
    const bezierSubpaths = [];
    let currentSubpath = null;
    currentSubpath = [];
    let firstX = 0;
    let firstY = 0;
    let lastX = 0;
    let lastY = 0;
    let isSubpathStart = true;
    for (let i = 0; i < curves.length; i++) {
        const curve = curves[i];
        if (isSubpathStart) {
            firstX = curve.p0.x;
            firstY = curve.p0.y;
            lastX = firstX;
            lastY = firstY;
            currentSubpath = [firstX, firstY];
            bezierSubpaths.push(currentSubpath);
            isSubpathStart = false;
        }
        if (curve.p1 && curve.p2 && curve.p3) {
            currentSubpath.push(curve.p1.x, curve.p1.y, curve.p2.x, curve.p2.y, curve.p3.x, curve.p3.y);
            lastX = curve.p3.x;
            lastY = curve.p3.y;
        }
        else if (curve.p1 && curve.p2) {
            const x1 = curve.p1.x;
            const y1 = curve.p1.y;
            const x2 = curve.p2.x;
            const y2 = curve.p2.y;
            currentSubpath.push(lastX + (2 / 3) * (x1 - lastX), lastY + (2 / 3) * (y1 - lastY), x2 + (2 / 3) * (x1 - x2), y2 + (2 / 3) * (y1 - y2), x2, y2);
            lastX = x2;
            lastY = y2;
        }
        else if (curve.p1) {
            const endX = curve.p1.x;
            const endY = curve.p1.y;
            if (!(Math.abs(lastX - endX) < 1e-10 && Math.abs(lastY - endY) < 1e-10)) {
                currentSubpath.push(lastX, lastY, endX, endY, endX, endY);
            }
            lastX = endX;
            lastY = endY;
        }
        if (i === curves.length - 1) ;
        if (i < curves.length - 1) {
            const nextCurve = curves[i + 1];
            if (Math.abs(lastX - nextCurve.p0.x) > 1e-10 || Math.abs(lastY - nextCurve.p0.y) > 1e-10) {
                isSubpathStart = true;
            }
        }
    }
    const validSubpaths = bezierSubpaths.filter(subpath => subpath.length > 2);
    return validSubpaths.length === 1 ? [validSubpaths[0]] : validSubpaths;
}
function applyTransformOnBezierCurves(bezierCurves, martrix) {
    for (let i = 0; i < bezierCurves.length; i++) {
        const subPath = bezierCurves[i];
        for (let k = 0; k < subPath.length; k += 2) {
            const x = subPath[k];
            const y = subPath[k + 1];
            const res = { x, y };
            martrix.transformPoint({ x, y }, res);
            subPath[k] = res.x;
            subPath[k + 1] = res.y;
        }
    }
}
function bezierCurversToPath(bezierCurves) {
    const path = new CustomPath2D();
    for (let i = 0; i < bezierCurves.length; i++) {
        const subPath = bezierCurves[i];
        if (subPath.length > 2) {
            path.moveTo(subPath[0], subPath[1]);
            for (let k = 2; k < subPath.length; k += 6) {
                path.bezierCurveTo(subPath[k], subPath[k + 1], subPath[k + 2], subPath[k + 3], subPath[k + 4], subPath[k + 5]);
            }
        }
    }
    return path;
}

function splitToGrids(width, height, count) {
    const ratio = width / height;
    let rowCount;
    let columnCount;
    if (width >= height) {
        columnCount = Math.ceil(Math.sqrt(count * ratio));
        rowCount = Math.floor(count / columnCount);
        if (rowCount === 0) {
            rowCount = 1;
            columnCount = count;
        }
    }
    else {
        rowCount = Math.ceil(Math.sqrt(count / ratio));
        columnCount = Math.floor(count / rowCount);
        if (columnCount === 0) {
            columnCount = 1;
            rowCount = count;
        }
    }
    const grids = [];
    for (let i = 0; i < rowCount; i++) {
        grids.push(columnCount);
    }
    const sumCount = rowCount * columnCount;
    const remained = count - sumCount;
    if (remained > 0) {
        for (let i = 0; i < remained; i += columnCount) {
            if (i + columnCount < remained) {
                grids.push(columnCount);
            }
            else {
                grids.push(remained - i);
            }
        }
    }
    return grids;
}
const splitRect = (rect, count) => {
    const { width, height } = normalizeRectAttributes(rect.attribute);
    const x = 0;
    const y = 0;
    const grids = splitToGrids(width, height, count);
    const res = [];
    const gridHeight = height / grids.length;
    for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
        const columnCount = grids[i];
        const gridWidth = width / columnCount;
        for (let j = 0; j < columnCount; j++) {
            res.push({
                x: x + j * gridWidth,
                y: y + i * gridHeight,
                width: gridWidth,
                height: gridHeight
            });
        }
    }
    return res;
};
const splitArc = (arc, count) => {
    const angles = arc.getParsedAngle();
    const startAngle = angles.startAngle;
    const endAngle = angles.endAngle;
    const innerRadius = arc.getComputedAttribute('innerRadius');
    const outerRadius = arc.getComputedAttribute('outerRadius');
    const angleDelta = Math.abs(startAngle - endAngle);
    const radiusDelta = Math.abs(outerRadius - innerRadius);
    const grids = splitToGrids((angleDelta * (innerRadius + outerRadius)) / 2, radiusDelta, count);
    const res = [];
    const gridRadius = radiusDelta / grids.length;
    const radiusSign = outerRadius >= innerRadius ? 1 : -1;
    const angleSign = endAngle >= startAngle ? 1 : -1;
    for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
        const columnCount = grids[i];
        const gridAngle = angleDelta / columnCount;
        for (let j = 0; j < columnCount; j++) {
            res.push({
                innerRadius: outerRadius - gridRadius * i * radiusSign,
                outerRadius: outerRadius - gridRadius * (i + 1) * radiusSign,
                startAngle: startAngle + gridAngle * j * angleSign,
                endAngle: startAngle + gridAngle * (j + 1) * angleSign
            });
        }
    }
    return res;
};
const splitCircle = (arc, count) => {
    const startAngle = arc.getComputedAttribute('startAngle');
    const endAngle = arc.getComputedAttribute('endAngle');
    const radius = arc.getComputedAttribute('radius');
    const angleDelta = Math.abs(startAngle - endAngle);
    const grids = splitToGrids(angleDelta * radius, radius, count);
    const res = [];
    const gridAngle = angleDelta / grids[0];
    const gridRadius = radius / grids.length;
    const angleSign = endAngle >= startAngle ? 1 : -1;
    for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
        for (let j = 0, columnCount = grids[i]; j < columnCount; j++) {
            res.push({
                innerRadius: gridRadius * i,
                outerRadius: gridRadius * (i + 1),
                startAngle: startAngle + gridAngle * j * angleSign,
                endAngle: startAngle + gridAngle * (j + 1) * angleSign
            });
        }
    }
    return res;
};
const samplingPoints = (points, count) => {
    const validatePoints = points.filter(point => point.defined !== false && isNumber$1(point.x) && isNumber$1(point.y));
    if (validatePoints.length === 0) {
        return [];
    }
    if (validatePoints.length === 1) {
        return new Array(count).fill(0).map(i => validatePoints[0]);
    }
    const res = [];
    if (count <= validatePoints.length) {
        const step = validatePoints.length / count;
        let i = 0;
        let cur = 0;
        while (i < count) {
            res.push(validatePoints[Math.floor(cur)]);
            cur += step;
            i++;
        }
        return res;
    }
    const insertCount = count - validatePoints.length;
    const insertStep = insertCount / (validatePoints.length - 1);
    const insetRatio = 1 / (insertStep + 1);
    let curCount = 0;
    for (let i = 0, len = points.length; i < len; i++) {
        res.push(points[i]);
        if (i < len - 1) {
            let cur = insetRatio;
            const xCur = points[i].x;
            const yCur = points[i].y;
            const xNext = points[i + 1].x;
            const yNext = points[i + 1].y;
            while (cur < 1 && curCount < insertCount) {
                res.push({
                    x: xCur + (xNext - xCur) * cur,
                    y: yCur + (yNext - yCur) * cur
                });
                cur += insetRatio;
                curCount += 1;
            }
        }
    }
    return res;
};
const splitArea = (area, count) => {
    var _a, _b;
    const attribute = area.attribute;
    let points = attribute.points;
    const segements = attribute.segments;
    if (!points) {
        points = segements.reduce((res, seg) => {
            var _a;
            return res.concat((_a = seg.points) !== null && _a !== void 0 ? _a : []);
        }, []);
    }
    const validatePoints = points.filter(point => point.defined !== false && isNumber$1(point.x) && isNumber$1(point.y));
    if (!validatePoints.length) {
        return [];
    }
    const allPoints = [];
    validatePoints.forEach(point => {
        allPoints.push({ x: point.x, y: point.y });
    });
    for (let i = validatePoints.length - 1; i >= 0; i--) {
        const point = validatePoints[i];
        allPoints.push({ x: (_a = point.x1) !== null && _a !== void 0 ? _a : point.x, y: (_b = point.y1) !== null && _b !== void 0 ? _b : point.y });
    }
    const res = [];
    recursiveCallBinarySplit(allPoints, count, res);
    return res;
};
const splitLine = (line, count) => {
    const attribute = line.attribute;
    const points = attribute.points;
    if (points) {
        return samplingPoints(points, count);
    }
    else if (attribute.segments) {
        const segs = attribute.segments;
        const allPoints = segs.reduce((res, seg) => {
            var _a;
            return res.concat((_a = seg.points) !== null && _a !== void 0 ? _a : []);
        }, []);
        return samplingPoints(allPoints, count);
    }
    return [];
};
function crossProduct(dir1, dir2) {
    return dir1[0] * dir2[1] - dir1[1] * dir2[0];
}
const clonePoints = (points) => {
    return points.map(p => ({ x: p.x, y: p.y }));
};
const splitPolygonByLine = (points, p0, p1) => {
    const len = points.length;
    const intersections = [];
    for (let i = 0; i < len; i++) {
        const cur = points[i];
        const next = i === len - 1 ? points[0] : points[i + 1];
        const res = getIntersectPoint([p0.x, p0.y], [p1.x, p1.y], [cur.x, cur.y], [next.x, next.y]);
        if (res && typeof res !== 'boolean') {
            intersections.push({
                dot: crossProduct([res[0] - p0.x, res[1] - p0.x], [p1.x - p0.x, p1.y - p0.x]),
                point: { x: res[0], y: res[1] },
                edgeIndex: i
            });
        }
    }
    if (intersections.length < 2) {
        return [clonePoints(points), clonePoints(points)];
    }
    intersections.sort((a, b) => a.dot - b.dot);
    let is0 = intersections[0];
    let is1 = intersections[intersections.length - 1];
    if (is0.edgeIndex > is1.edgeIndex) {
        [is0, is1] = [is1, is0];
    }
    const newP0 = is0.point;
    const newP1 = is1.point;
    const newPointsA = [{ x: newP0.x, y: newP0.y }];
    for (let i = is0.edgeIndex + 1; i <= is1.edgeIndex; i++) {
        newPointsA.push({ x: points[i].x, y: points[i].y });
    }
    newPointsA.push({ x: newP1.x, y: newP1.y });
    const newPointsB = [{ x: newP1.x, y: newP1.y }];
    for (let i = is1.edgeIndex + 1, maxIndex = is0.edgeIndex + len; i <= maxIndex; i++) {
        const p = points[i % len];
        newPointsB.push({ x: p.x, y: p.y });
    }
    newPointsB.push({ x: newP0.x, y: newP0.y });
    return [newPointsA, newPointsB];
};
const binarySplitPolygon = (points) => {
    const box = new Bounds();
    points.forEach(point => {
        box.add(point.x, point.y);
    });
    const width = box.width();
    const height = box.height();
    if (width >= height) {
        const midX = box.x1 + width / 2;
        return splitPolygonByLine(points, {
            x: midX,
            y: box.y1
        }, {
            x: midX,
            y: box.y2
        });
    }
    const midY = box.y1 + height / 2;
    return splitPolygonByLine(points, {
        x: box.x1,
        y: midY
    }, {
        x: box.x2,
        y: midY
    });
};
const recursiveCallBinarySplit = (points, count, out) => {
    if (count === 1) {
        out.push({ points });
    }
    else {
        const half = Math.floor(count / 2);
        const res = binarySplitPolygon(points);
        recursiveCallBinarySplit(res[0], half, out);
        recursiveCallBinarySplit(res[1], count - half, out);
    }
};
const splitPolygon = (polygon, count) => {
    const points = polygon.attribute.points;
    if (!points || !points.length) {
        return [];
    }
    if (count === 1) {
        return [{ points: clonePoints(points) }];
    }
    const res = [];
    recursiveCallBinarySplit(points, count, res);
    return res;
};
const splitPath = (path, count) => {
    const pathShape = path.getParsedPathShape();
    const bezierCurves = pathToBezierCurves(pathShape);
    if (!bezierCurves.length || count < 0) {
        return [];
    }
    const subPathCnt = bezierCurves.length;
    if (bezierCurves.length >= count) {
        const res = [];
        const stepCount = Math.floor(bezierCurves.length / count);
        for (let i = 0; i < count; i++) {
            const curves = bezierCurves.slice(i * stepCount, i === count - 1 ? subPathCnt : (i + 1) * stepCount);
            res.push({ path: bezierCurversToPath(curves) });
        }
        return res;
    }
    const res = [];
    const stepCount = Math.floor(count / subPathCnt);
    let remain = count;
    for (let c = 0; c < subPathCnt; c++) {
        const points = [];
        for (let i = 2, len = bezierCurves[c].length; i < len; i += 2) {
            points.push({ x: bezierCurves[0][i], y: bezierCurves[0][i + 1] });
        }
        recursiveCallBinarySplit(points, c === subPathCnt - 1 ? remain : stepCount, res);
        remain -= stepCount;
    }
    return res;
};

function isIdentityMatrix(matrix) {
    return matrix.a === 1 && matrix.b === 0 && matrix.c === 0 && matrix.d === 1 && matrix.e === 0 && matrix.f === 0;
}
function createEventTransformer(containerElement, getMatrix, getRect, transformPoint) {
    return (event) => {
        if (!(event instanceof MouseEvent) && !(event instanceof TouchEvent) && !(event instanceof PointerEvent)) {
            return event;
        }
        const transformMatrix = getMatrix();
        if (isIdentityMatrix(transformMatrix)) {
            return event;
        }
        const containerRect = getRect();
        const transformedEvent = new event.constructor(event.type, event);
        Object.defineProperties(transformedEvent, {
            target: { value: event.target },
            currentTarget: { value: event.currentTarget }
        });
        if (event instanceof MouseEvent || event instanceof PointerEvent) {
            transformPoint(event.clientX, event.clientY, transformMatrix, containerRect, transformedEvent);
        }
        else if (event instanceof TouchEvent) {
            if (event.touches.length > 0) {
                const touch = transformedEvent.touches[0];
                transformPoint(touch.clientX, touch.clientY, transformMatrix, containerRect, touch);
            }
            if (event.changedTouches.length > 0) {
                const touch = transformedEvent.changedTouches[0];
                transformPoint(touch.clientX, touch.clientY, transformMatrix, containerRect, touch);
            }
        }
        return transformedEvent;
    };
}
function createCanvasEventTransformer(canvasElement, getMatrix, getRect, transformPoint) {
    return createEventTransformer(canvasElement.parentElement || canvasElement, getMatrix, getRect, transformPoint);
}
function registerWindowEventTransformer(window, container, getMatrix, getRect, transformPoint) {
    const transformer = createEventTransformer(container, getMatrix, getRect, transformPoint);
    window.setEventListenerTransformer(transformer);
}
function registerGlobalEventTransformer(global, container, getMatrix, getRect, transformPoint) {
    const transformer = createEventTransformer(container, getMatrix, getRect, transformPoint);
    global.setEventListenerTransformer(transformer);
}
function transformPointForCanvas(clientX, clientY, matrix, rect, transformedEvent) {
    const transformedPoint = { x: clientX, y: clientY };
    matrix.transformPoint(transformedPoint, transformedPoint);
    Object.defineProperties(transformedEvent, {
        _canvasX: { value: transformedPoint.x },
        _canvasY: { value: transformedPoint.y }
    });
    return;
}
function mapToCanvasPointForCanvas(nativeEvent) {
    var _a;
    if (isNumber(nativeEvent._canvasX) && isNumber(nativeEvent._canvasY)) {
        return {
            x: nativeEvent._canvasX,
            y: nativeEvent._canvasY
        };
    }
    else if (nativeEvent.changedTouches) {
        const data = (_a = nativeEvent.changedTouches[0]) !== null && _a !== void 0 ? _a : {};
        return {
            x: data._canvasX,
            y: data._canvasY
        };
    }
    const x = nativeEvent._canvasX || 0;
    const y = nativeEvent._canvasY || 0;
    return {
        x,
        y
    };
}

function getDefaultCharacterConfig(attribute) {
    const { fill = 'black', stroke = false, fontWeight = 'normal', lineHeight, fontFamily = 'Arial', textAlign } = attribute;
    let { fontSize = 12 } = attribute;
    if (!isFinite(fontSize)) {
        fontSize = 12;
    }
    return {
        fill,
        stroke,
        fontSize,
        fontWeight,
        fontFamily,
        lineHeight,
        textAlign
    };
}
function findConfigIndexByCursorIdx(textConfig, cursorIndex) {
    var _a;
    if (cursorIndex < 0) {
        return 0;
    }
    const intCursorIndex = Math.round(cursorIndex);
    let tempCursorIndex = intCursorIndex;
    let lineBreak = ((_a = textConfig === null || textConfig === void 0 ? void 0 : textConfig[0]) === null || _a === void 0 ? void 0 : _a.text) === '\n';
    let configIdx = 0;
    for (configIdx = 0; configIdx < textConfig.length && tempCursorIndex >= 0; configIdx++) {
        const c = textConfig[configIdx];
        if (c.text === '\n') {
            tempCursorIndex -= Number(lineBreak);
            lineBreak = true;
        }
        else {
            tempCursorIndex--;
            lineBreak = false;
        }
    }
    if (tempCursorIndex >= 0) {
        return textConfig.length;
    }
    configIdx -= 1;
    if (cursorIndex > intCursorIndex && !lineBreak) {
        configIdx += 1;
    }
    return configIdx;
}
function findCursorIdxByConfigIndex(textConfig, configIndex) {
    var _a, _b, _c, _d;
    let cursorIndex = 0;
    if (configIndex < 0) {
        return -0.1;
    }
    let lastLineBreak = ((_a = textConfig === null || textConfig === void 0 ? void 0 : textConfig[0]) === null || _a === void 0 ? void 0 : _a.text) === '\n';
    for (let i = 0; i <= configIndex && i < textConfig.length; i++) {
        const c = textConfig[i];
        if (c.text === '\n') {
            cursorIndex += Number(lastLineBreak);
            lastLineBreak = true;
        }
        else {
            cursorIndex++;
            lastLineBreak = false;
        }
    }
    cursorIndex = Math.max(cursorIndex - 1, 0);
    if (configIndex > textConfig.length - 1) {
        if (((_b = textConfig[textConfig.length - 1]) === null || _b === void 0 ? void 0 : _b.text) === '\n') {
            return cursorIndex + 0.9;
        }
        return cursorIndex + 0.1;
    }
    const lineBreak = ((_c = textConfig[configIndex]) === null || _c === void 0 ? void 0 : _c.text) === '\n';
    if (configIndex >= textConfig.length - 1 && lineBreak) {
        return cursorIndex + 1 - 0.1;
    }
    const singleLineBreak = lineBreak && ((_d = textConfig[configIndex - 1]) === null || _d === void 0 ? void 0 : _d.text) !== '\n';
    cursorIndex -= 0.1;
    if (singleLineBreak) {
        cursorIndex += 0.2;
    }
    return cursorIndex;
}
class EditModule {
    constructor(container) {
        this.handleFocusIn = () => {
        };
        this.handleFocusOut = () => {
        };
        this.handleKeyDown = (e) => {
            if (!this.currRt) {
                return;
            }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                this.handleInput({ data: null, type: 'Backspace' });
            }
        };
        this.handleCompositionStart = () => {
            if (!this.currRt) {
                return;
            }
            this.isComposing = true;
            const { textConfig = [] } = this.currRt.attribute;
            this.composingConfigIdx = this.cursorIndex < 0 ? 0 : findConfigIndexByCursorIdx(textConfig, this.cursorIndex);
            if (this.cursorIndex < 0) {
                const config = textConfig[0];
                textConfig.unshift(Object.assign(Object.assign(Object.assign({ fill: 'black' }, getDefaultCharacterConfig(this.currRt.attribute)), config), { text: '' }));
            }
            else {
                const configIdx = this.composingConfigIdx;
                const lastConfig = textConfig[configIdx] || textConfig[configIdx - 1];
                textConfig.splice(configIdx, 0, Object.assign(Object.assign(Object.assign({ fill: 'black' }, getDefaultCharacterConfig(this.currRt.attribute)), lastConfig), { text: '' }));
            }
        };
        this.handleCompositionEnd = () => {
            this.isComposing = false;
            const text = this.parseCompositionStr(this.composingConfigIdx);
            this.composingConfigIdx = -1;
            this.onChangeCbList.forEach(cb => {
                cb(text, this.isComposing, this.cursorIndex, this.currRt);
            });
        };
        this.handleInput = (ev) => {
            if (!this.currRt) {
                return;
            }
            if (ev.inputType === 'historyUndo') {
                return;
            }
            const _a = this.currRt.attribute, { textConfig = [] } = _a, rest = __rest(_a, ["textConfig"]);
            if (ev.type === 'Backspace' && !textConfig.length) {
                return;
            }
            let str = ev.data;
            if (!this.isComposing && ev.type !== 'Backspace' && !str) {
                str = '\n';
            }
            if (this.selectionStartCursorIdx > this.cursorIndex) {
                [this.cursorIndex, this.selectionStartCursorIdx] = [this.selectionStartCursorIdx, this.cursorIndex];
            }
            const startIdx = findConfigIndexByCursorIdx(textConfig, this.selectionStartCursorIdx);
            const endIdx = findConfigIndexByCursorIdx(textConfig, this.cursorIndex);
            const lastConfigIdx = this.isComposing ? this.composingConfigIdx : Math.max(startIdx - 1, 0);
            let lastConfig = textConfig[lastConfigIdx];
            if (!lastConfig) {
                lastConfig = getDefaultCharacterConfig(rest);
            }
            let nextConfig = lastConfig;
            if (startIdx !== endIdx) {
                textConfig.splice(startIdx, endIdx - startIdx);
                if (this.isComposing) {
                    this.composingConfigIdx = startIdx;
                }
            }
            let nextConfigIdx = startIdx;
            if (ev.type === 'Backspace' && !this.isComposing) {
                if (startIdx === endIdx) {
                    if (startIdx <= 0) {
                        return;
                    }
                    textConfig.splice(startIdx - 1, 1);
                    nextConfigIdx = Math.max(startIdx - 1, 0);
                }
            }
            else {
                if (!this.isComposing) {
                    nextConfig = Object.assign(Object.assign({ fill: 'black' }, lastConfig), { text: '' });
                    textConfig.splice(startIdx, 0, nextConfig);
                    nextConfigIdx++;
                }
                nextConfig.text = str;
                nextConfig.isComposing = this.isComposing;
            }
            this.currRt.setAttributes({ textConfig });
            let cursorIndex = this.cursorIndex;
            if (str && str.length > 1 && !this.isComposing) {
                this.parseCompositionStr(nextConfigIdx - 1);
                cursorIndex = this.cursorIndex;
            }
            else {
                cursorIndex = findCursorIdxByConfigIndex(textConfig, nextConfigIdx);
                if (!this.isComposing) {
                    this.cursorIndex = cursorIndex;
                }
                else {
                    this.cursorIndex = this.selectionStartCursorIdx;
                }
            }
            if (!this.isComposing) {
                this.onChangeCbList.forEach(cb => {
                    cb(str, this.isComposing, cursorIndex, this.currRt);
                });
            }
            else {
                this.onInputCbList.forEach(cb => {
                    cb(str, this.isComposing, cursorIndex, this.currRt);
                });
            }
        };
        this.container = container !== null && container !== void 0 ? container : document.body;
        const textAreaDom = document.createElement('textarea');
        textAreaDom.autocomplete = 'off';
        textAreaDom.spellcheck = false;
        textAreaDom.innerText = '';
        this.applyStyle(textAreaDom);
        this.container.append(textAreaDom);
        this.textAreaDom = textAreaDom;
        this.isComposing = false;
        this.composingConfigIdx = -1;
        this.onInputCbList = [];
        this.onChangeCbList = [];
        this.onFocusInList = [];
        this.onFocusOutList = [];
    }
    onInput(cb) {
        this.onInputCbList.push(cb);
    }
    onChange(cb) {
        this.onChangeCbList.push(cb);
    }
    onFocusIn(cb) {
        this.onFocusInList.push(cb);
    }
    onFocusOut(cb) {
        this.onFocusOutList.push(cb);
    }
    applyStyle(textAreaDom) {
        textAreaDom.setAttribute('style', `width: 100px; height: 30px; left: 0; top: 0; position: absolute; z-index: -1; outline: none; resize: none; border: none; overflow: hidden; color: transparent; user-select: none; caret-color: transparent;background-color: transparent;opacity: 0;pointer-events: none;`);
        textAreaDom.addEventListener('input', this.handleInput);
        textAreaDom.addEventListener('compositionstart', this.handleCompositionStart);
        textAreaDom.addEventListener('compositionend', this.handleCompositionEnd);
        textAreaDom.addEventListener('focusin', this.handleFocusIn);
        textAreaDom.addEventListener('focusout', this.handleFocusOut);
        application.global.addEventListener('keydown', this.handleKeyDown);
    }
    parseCompositionStr(configIdx) {
        var _a;
        if (!this.currRt) {
            return '';
        }
        const { textConfig = [] } = this.currRt.attribute;
        const lastConfig = (_a = textConfig[configIdx]) !== null && _a !== void 0 ? _a : {};
        textConfig.splice(configIdx, 1);
        const text = lastConfig.text;
        const textList = text ? Array.from(text.toString()) : [];
        for (let i = 0; i < textList.length; i++) {
            textConfig.splice(i + configIdx, 0, Object.assign(Object.assign({ fill: 'black' }, lastConfig), { isComposing: false, text: textList[i] }));
        }
        this.currRt.setAttributes({ textConfig });
        const nextConfigIdx = configIdx + textList.length;
        this.cursorIndex = findCursorIdxByConfigIndex(textConfig, nextConfigIdx);
        return text;
    }
    moveTo(x, y, rt, cursorIndex, selectionStartCursorIdx) {
        this.textAreaDom.style.left = `${x}px`;
        this.textAreaDom.style.top = `${y}px`;
        setTimeout(() => {
            this.textAreaDom.focus();
            this.textAreaDom.setSelectionRange(0, 0);
        });
        this.currRt = rt;
        this.cursorIndex = cursorIndex;
        this.selectionStartCursorIdx = selectionStartCursorIdx;
    }
    release() {
        this.textAreaDom.removeEventListener('input', this.handleInput);
        this.textAreaDom.removeEventListener('compositionstart', this.handleCompositionStart);
        this.textAreaDom.removeEventListener('compositionend', this.handleCompositionEnd);
        this.textAreaDom.addEventListener('focusin', this.handleFocusOut);
        this.textAreaDom.addEventListener('focusout', this.handleFocusOut);
        application.global.removeEventListener('keydown', this.handleKeyDown);
    }
}

class Selection {
    constructor(selectionStartCursorIdx, curCursorIdx, rt) {
        this.curCursorIdx = curCursorIdx;
        this.selectionStartCursorIdx = selectionStartCursorIdx;
        this.rt = rt;
    }
    isEmpty() {
        return this.selectionStartCursorIdx === this.curCursorIdx;
    }
    getSelectionPureText() {
        const minCursorIdx = Math.min(this.selectionStartCursorIdx, this.curCursorIdx);
        const maxCursorIdx = Math.max(this.selectionStartCursorIdx, this.curCursorIdx);
        if (minCursorIdx === maxCursorIdx) {
            return '';
        }
        const config = this.rt.attribute.textConfig;
        const startIdx = findConfigIndexByCursorIdx(config, Math.ceil(minCursorIdx));
        const endIdx = findConfigIndexByCursorIdx(config, Math.floor(maxCursorIdx));
        let str = '';
        for (let i = startIdx; i <= endIdx; i++) {
            str += config[i].text;
        }
        return str;
    }
    hasFormat(key) {
        return this.getFormat(key) != null;
    }
    _getFormat(key, cursorIdx) {
        var _a;
        if (!this.rt) {
            return null;
        }
        let idx = Math.round(cursorIdx);
        const config = this.rt.attribute.textConfig;
        if (!config.length) {
            return null;
        }
        for (let i = 0; i < config.length; i++) {
            if (config[i].text !== '\n') {
                idx--;
                if (idx < 0) {
                    return config[i][key];
                }
            }
        }
        return (_a = config[Math.min(idx, config.length - 1)][key]) !== null && _a !== void 0 ? _a : this.rt.attribute[key];
    }
    getFormat(key, supportOutAttr = false) {
        return this.getAllFormat(key, supportOutAttr)[0];
    }
    getAllFormat(key, supportOutAttr = false) {
        var _a, _b, _c, _d;
        const valSet = new Set();
        const minCursorIdx = Math.min(this.selectionStartCursorIdx, this.curCursorIdx);
        const maxCursorIdx = Math.max(this.selectionStartCursorIdx, this.curCursorIdx);
        if (minCursorIdx === maxCursorIdx) {
            return supportOutAttr
                ? [(_a = this._getFormat(key, minCursorIdx)) !== null && _a !== void 0 ? _a : ((_b = this.rt) === null || _b === void 0 ? void 0 : _b.attribute)[key]]
                : [this._getFormat(key, minCursorIdx)];
        }
        for (let i = Math.ceil(minCursorIdx); i <= Math.floor(maxCursorIdx); i++) {
            const val = supportOutAttr
                ? (_c = this._getFormat(key, i)) !== null && _c !== void 0 ? _c : ((_d = this.rt) === null || _d === void 0 ? void 0 : _d.attribute)[key]
                : this._getFormat(key, i);
            val && valSet.add(val);
        }
        return Array.from(valSet.values());
    }
}
const FORMAT_TEXT_COMMAND = 'FORMAT_TEXT_COMMAND';
const FORMAT_ALL_TEXT_COMMAND = 'FORMAT_ALL_TEXT_COMMAND';
const FORMAT_ELEMENT_COMMAND = 'FORMAT_ELEMENT_COMMAND';
class RichTextEditPlugin {
    static tryUpdateRichtext(richtext) {
        const cache = richtext.getFrameCache();
        if (!RichText.AllSingleCharacter(cache)) {
            const tc = RichText.TransformTextConfig2SingleCharacter(richtext.attribute.textConfig);
            richtext.setAttributes({ textConfig: tc });
            richtext.doUpdateFrameCache(tc);
        }
    }
    static CreateSelection(rt) {
        if (!rt) {
            return null;
        }
        const { textConfig = [] } = rt.attribute;
        return new Selection(0, textConfig.length - 1, rt);
    }
    constructor() {
        this.name = 'RichTextEditPlugin';
        this.activeEvent = 'onRegister';
        this._uid = Generator.GenAutoIncrementId();
        this.key = this.name + this._uid;
        this.editing = false;
        this.focusing = false;
        this.pointerDown = false;
        this.formatTextCommandCb = (payload, p) => {
            const rt = p.currRt;
            if (!rt) {
                return;
            }
            const selectionData = p.getSelection();
            if (!selectionData) {
                return;
            }
            const { selectionStartCursorIdx, curCursorIdx } = selectionData;
            const minCursorIdx = Math.min(selectionStartCursorIdx, curCursorIdx);
            const maxCursorIdx = Math.max(selectionStartCursorIdx, curCursorIdx);
            const minConfigIdx = findConfigIndexByCursorIdx(rt.attribute.textConfig, minCursorIdx);
            const maxConfigIdx = findConfigIndexByCursorIdx(rt.attribute.textConfig, maxCursorIdx);
            const config = rt.attribute.textConfig.slice(minConfigIdx, maxConfigIdx);
            this._formatTextCommand(payload, config, rt);
        };
        this.formatAllTextCommandCb = (payload, p) => {
            const rt = p.currRt;
            if (!rt) {
                return;
            }
            const config = rt.attribute.textConfig;
            this._formatTextCommand(payload, config, rt);
        };
        this.handleKeyDown = (e) => {
            if (!(this.currRt && this.editing)) {
                return;
            }
            if (this.copyToClipboard(e)) {
                return;
            }
            if (this.fullSelectionKeyHandler(e)) {
                return;
            }
            if (this.directKeyHandler(e)) {
                return;
            }
        };
        this.handleInput = (text, isComposing, cursorIdx, rt) => {
            if (!this.currRt) {
                return;
            }
            this.tryShowShadowPlaceholder();
            this.tryShowInputBounds();
            this.hideSelection();
            this.updateCbs.forEach(cb => cb('input', this));
        };
        this.handleChange = (text, isComposing, cursorIdx, rt) => {
            if (!this.currRt) {
                return;
            }
            this.tryShowShadowPlaceholder();
            this.tryShowInputBounds();
            this.curCursorIdx = cursorIdx;
            this.selectionStartCursorIdx = cursorIdx;
            const p = this.computedCursorPosByCursorIdx(cursorIdx, rt);
            this.setCursorAndTextArea(p.x, p.y1, p.y2, rt);
            this.hideSelection();
            this.updateCbs.forEach(cb => cb('change', this));
        };
        this.handleFocusIn = () => {
            throw new Error('不会走到这里 handleFocusIn');
        };
        this.handleFocusOut = () => {
            throw new Error('不会走到这里 handleFocusOut');
        };
        this.handleMove = (e) => {
            if (this.currRt && !this.currRt.attribute.editable) {
                this.deFocus(true);
            }
            if (!this.isEditableRichtext(e)) {
                this.handleLeave();
                return;
            }
            this.handleEnter();
            e.target.once('pointerleave', this.handleLeave, { capture: true });
            this.tryShowSelection(e, false);
        };
        this.handleEnter = () => {
            this.editing = true;
            this.pluginService.stage.setCursor('text');
        };
        this.handleLeave = () => {
            this.editing = false;
            this.pluginService.stage.setCursor('default');
        };
        this.handlePointerDown = (e) => {
            if (!this.editing || !this.isEditableRichtext(e)) {
                this.deFocus(true);
            }
            else {
                this.onFocus(e);
            }
            this.triggerRender();
            this.pointerDown = true;
            this.updateCbs.forEach(cb => cb(this.editing ? 'onfocus' : 'defocus', this));
        };
        this.handlePointerUp = (e) => {
            this.pointerDown = false;
        };
        this.handleDBLClick = (e) => {
            if (!this.editing) {
                return;
            }
            this.tryShowSelection(e, true);
        };
        this.commandCbs = new Map();
        this.commandCbs.set(FORMAT_TEXT_COMMAND, [this.formatTextCommandCb]);
        this.commandCbs.set(FORMAT_ALL_TEXT_COMMAND, [this.formatAllTextCommandCb]);
        this.updateCbs = [];
        this.deltaX = 0;
        this.deltaY = 0;
    }
    _formatTextCommand(payload, config, rt) {
        if (payload === 'bold') {
            config.forEach((item) => (item.fontWeight = 'bold'));
        }
        else if (payload === 'italic') {
            config.forEach((item) => (item.fontStyle = 'italic'));
        }
        else if (payload === 'underline') {
            config.forEach((item) => (item.underline = true));
        }
        else if (payload === 'lineThrough') {
            config.forEach((item) => (item.lineThrough = true));
        }
        else if (isObject(payload)) {
            config.forEach((item) => merge(item, payload));
        }
        rt.setAttributes(rt.attribute);
        const cache = rt.getFrameCache();
        if (!cache) {
            return;
        }
        this.selectionRangeByCursorIdx(this.selectionStartCursorIdx, this.curCursorIdx, cache);
        this.tryShowInputBounds();
    }
    dispatchCommand(command, payload) {
        const cbs = this.commandCbs.get(command);
        cbs && cbs.forEach(cb => cb(payload, this));
        this.updateCbs.forEach(cb => cb('dispatch', this));
    }
    registerCommand(command, cb) {
        const cbs = this.commandCbs.get(command) || [];
        cbs.push(cb);
    }
    removeCommand(command, cb) {
        const cbs = this.commandCbs.get(command) || [];
        const idx = cbs.indexOf(cb);
        if (idx > -1) {
            cbs.splice(idx, 1);
        }
    }
    registerUpdateListener(cb) {
        const cbs = this.updateCbs || [];
        cbs.push(cb);
    }
    removeUpdateListener(cb) {
        const cbs = this.updateCbs || [];
        const idx = cbs.indexOf(cb);
        if (idx > -1) {
            cbs.splice(idx, 1);
        }
    }
    activate(context) {
        this.pluginService = context;
        this.editModule = new EditModule();
        context.stage.on('pointermove', this.handleMove, { capture: true });
        context.stage.on('pointerdown', this.handlePointerDown, { capture: true });
        context.stage.on('pointerup', this.handlePointerUp, { capture: true });
        context.stage.on('pointerleave', this.handlePointerUp, { capture: true });
        context.stage.on('dblclick', this.handleDBLClick, { capture: true });
        application.global.addEventListener('keydown', this.handleKeyDown);
        this.editModule.onInput(this.handleInput);
        this.editModule.onChange(this.handleChange);
        this.editModule.onFocusOut(this.handleFocusOut);
        this.timeline = this.createTimeline && this.createTimeline();
        this.ticker = this.createTicker && this.createTicker(context.stage);
    }
    copyToClipboard(e) {
        if ((application.global.isMacOS() && e.metaKey && e.key === 'c') ||
            (!application.global.isMacOS() && e.ctrlKey && e.key === 'c')) {
            const selection = this.getSelection();
            const text = selection.getSelectionPureText();
            application.global.copyToClipBoard(text);
            e.preventDefault();
            return true;
        }
        return false;
    }
    selectionRange(startIdx, endIdx) {
        const currRt = this.currRt;
        if (!currRt) {
            return;
        }
        const cache = currRt.getFrameCache();
        if (!cache) {
            return;
        }
        const { lines } = cache;
        const totalCursorCount = lines.reduce((total, line) => total + line.paragraphs.length, 0) - 1;
        if (startIdx > endIdx) {
            [startIdx, endIdx] = [endIdx, startIdx];
        }
        startIdx = Math.min(Math.max(startIdx, -0.1), totalCursorCount + 0.1);
        endIdx = Math.min(Math.max(endIdx, -0.1), totalCursorCount + 0.1);
        this.selectionRangeByCursorIdx(startIdx, endIdx, cache);
    }
    selectionRangeByCursorIdx(startCursorIdx, endCursorIdx, cache) {
        this.curCursorIdx = endCursorIdx;
        this.selectionStartCursorIdx = startCursorIdx;
        const { x, y1, y2 } = this.computedCursorPosByCursorIdx(this.selectionStartCursorIdx, this.currRt);
        this.startCursorPos = { x, y: (y1 + y2) / 2 };
        const pos = this.computedCursorPosByCursorIdx(this.curCursorIdx, this.currRt);
        this.setCursorAndTextArea(pos.x, pos.y1, pos.y2, this.currRt);
        this._tryShowSelection(pos, cache);
    }
    fullSelection() {
        const currRt = this.currRt;
        if (!currRt) {
            return;
        }
        const cache = currRt.getFrameCache();
        if (!cache) {
            return;
        }
        const { lines } = cache;
        if (!(lines.length && lines[0].paragraphs.length)) {
            return;
        }
        const totalCursorCount = lines.reduce((total, line) => total + line.paragraphs.length, 0) - 1;
        this.selectionRange(-0.1, totalCursorCount + 0.1);
    }
    fullSelectionKeyHandler(e) {
        if ((application.global.isMacOS() && e.metaKey && e.key === 'a') ||
            (!application.global.isMacOS() && e.ctrlKey && e.key === 'a')) {
            this.fullSelection();
            e.preventDefault();
            return true;
        }
        return false;
    }
    directKeyHandler(e) {
        if (!(e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
            return false;
        }
        const cache = this.currRt.getFrameCache();
        if (!cache) {
            return false;
        }
        let x = 0;
        let y = 0;
        if (e.key === 'ArrowUp') {
            y = -1;
        }
        else if (e.key === 'ArrowDown') {
            y = 1;
        }
        else if (e.key === 'ArrowLeft') {
            x = -1;
        }
        else if (e.key === 'ArrowRight') {
            x = 1;
        }
        const { lineInfo, columnInfo } = this.getColumnByIndex(cache, Math.round(this.curCursorIdx));
        const { lines } = cache;
        const totalCursorCount = lines.reduce((total, line) => total + line.paragraphs.length, 0) - 1;
        if (x) {
            if (x > 0 &&
                columnInfo === lineInfo.paragraphs[lineInfo.paragraphs.length - 2] &&
                this.curCursorIdx < Math.round(this.curCursorIdx)) {
                this.curCursorIdx = this.curCursorIdx + 0.2;
            }
            else if (x > 0 &&
                columnInfo === lineInfo.paragraphs[lineInfo.paragraphs.length - 1] &&
                this.curCursorIdx > Math.round(this.curCursorIdx)) {
                this.curCursorIdx = this.curCursorIdx + 1 - 0.2;
            }
            else if (x < 0 && columnInfo === lineInfo.paragraphs[0] && this.curCursorIdx > Math.round(this.curCursorIdx)) {
                this.curCursorIdx = this.curCursorIdx - 0.2;
            }
            else if (x < 0 && columnInfo === lineInfo.paragraphs[0] && this.curCursorIdx < Math.round(this.curCursorIdx)) {
                this.curCursorIdx = this.curCursorIdx - 1 + 0.2;
            }
            else {
                this.curCursorIdx += x;
            }
            if (this.curCursorIdx < -0.1) {
                this.curCursorIdx = -0.1;
            }
            else if (this.curCursorIdx > totalCursorCount + 0.1) {
                this.curCursorIdx = totalCursorCount + 0.1;
            }
            this.selectionStartCursorIdx = this.curCursorIdx;
            const pos = this.computedCursorPosByCursorIdx(this.curCursorIdx, this.currRt);
            this.setCursorAndTextArea(pos.x, pos.y1, pos.y2, this.currRt);
            this.hideSelection();
        }
        if (y) {
            if (y > 0 && lineInfo === cache.lines[cache.lines.length - 1]) {
                return;
            }
            if (y < 0 && lineInfo === cache.lines[0]) {
                return;
            }
            const lineIdx = cache.lines.findIndex(item => item === lineInfo) + y;
            if (lineIdx < 0 || lineIdx >= cache.lines.length) {
                return;
            }
            const pos = this.computedCursorPosByCursorIdx(this.curCursorIdx, this.currRt);
            const posX = pos.x;
            let posY = (pos.y1 + pos.y2) / 2;
            posY += y * lineInfo.height;
            const nextLineInfo = cache.lines[lineIdx];
            const { columnInfo, delta } = this.getColumnAndIndexByLinePoint(nextLineInfo, { x: posX, y: posY });
            if (!columnInfo) {
                return;
            }
            let cursorIdx = this.getColumnIndex(cache, columnInfo) + delta;
            const data = this.computedCursorPosByCursorIdx(cursorIdx, this.currRt);
            if (cursorIdx < -0.1) {
                cursorIdx = -0.1;
            }
            else if (cursorIdx > totalCursorCount + 0.1) {
                cursorIdx = totalCursorCount + 0.1;
            }
            this.curCursorIdx = cursorIdx;
            this.selectionStartCursorIdx = cursorIdx;
            this.setCursorAndTextArea(data.x, data.y1, data.y2, this.currRt);
        }
        return true;
    }
    tryShowShadowPlaceholder() {
        if (!this.currRt) {
            return;
        }
        const shadowRoot = this.currRt.shadowRoot;
        if (shadowRoot) {
            const placeholder = shadowRoot.getElementsByType('richtext')[0];
            placeholder && shadowRoot.removeChild(placeholder);
        }
        const { textConfig, editOptions = {} } = this.currRt.attribute;
        if (textConfig && textConfig.length) {
            return;
        }
        if (!(editOptions && editOptions.placeholder)) {
            return;
        }
        const { placeholder, placeholderColor = 'rgba(0, 0, 0, 0.6)', placeholderFontFamily, placeholderFontSize } = editOptions;
        const shadow = this.getShadow(this.currRt);
        const textConfigItem = Object.assign(Object.assign({}, getDefaultCharacterConfig(this.currRt.attribute)), { text: placeholder });
        if (placeholderColor) {
            textConfigItem.fill = placeholderColor;
        }
        if (placeholderFontFamily) {
            textConfigItem.fontFamily = placeholderFontFamily;
        }
        if (placeholderFontSize) {
            textConfigItem.fontSize = placeholderFontSize;
        }
        this.shadowPlaceHolder = createRichText(Object.assign(Object.assign({}, this.currRt.attribute), { x: 0, y: 0, dx: -this.deltaX, dy: -this.deltaY, angle: 0, textConfig: [textConfigItem] }));
        shadow.add(this.shadowPlaceHolder);
    }
    getRichTextAABBBounds(rt) {
        const { attribute } = rt;
        if (!attribute.textConfig.length) {
            return getRichTextBounds(Object.assign(Object.assign({}, this.shadowPlaceHolder.attribute), { x: attribute.x, y: attribute.y, textAlign: attribute.textAlign, boundsMode: 'accurate' }));
        }
        return rt.AABBBounds;
    }
    tryShowInputBounds() {
        var _a, _b;
        if (!(this.currRt && this.focusing)) {
            return;
        }
        const { editOptions = {} } = this.currRt.attribute;
        const { boundsStrokeWhenInput } = editOptions;
        if (!editOptions || !boundsStrokeWhenInput) {
            return;
        }
        this.offsetShadowRoot();
        const b = this.getRichTextAABBBounds(this.currRt);
        const height = b.height();
        const width = b.width();
        this.shadowBounds = this.shadowBounds || createRect({});
        this.shadowBounds.setAttributes({
            x: 0,
            y: 0,
            scaleX: 1 / ((_a = this.currRt.attribute.scaleX) !== null && _a !== void 0 ? _a : 1),
            scaleY: 1 / ((_b = this.currRt.attribute.scaleY) !== null && _b !== void 0 ? _b : 1),
            width,
            height,
            fill: false,
            stroke: boundsStrokeWhenInput,
            lineWidth: 1,
            zIndex: -1
        });
        const shadow = this.getShadow(this.currRt);
        this.addEditLineOrBgOrBounds(this.shadowBounds, shadow);
        this.offsetLineBgAndShadowBounds();
    }
    trySyncPlaceholderToTextConfig() {
        if (!this.currRt) {
            return;
        }
        const { textConfig, editOptions } = this.currRt.attribute;
        if (textConfig && textConfig.length) {
            return;
        }
        if (!(editOptions && editOptions.placeholder && editOptions.syncPlaceholderToTextConfig)) {
            return;
        }
        const { placeholder } = editOptions;
        this.currRt.setAttributes({
            textConfig: [
                Object.assign({ text: placeholder }, getDefaultCharacterConfig(this.currRt.attribute))
            ]
        });
    }
    deactivate(context) {
        context.stage.off('pointermove', this.handleMove, { capture: true });
        context.stage.off('pointerdown', this.handlePointerDown, { capture: true });
        context.stage.off('pointerup', this.handlePointerUp, { capture: true });
        context.stage.off('pointerleave', this.handlePointerUp, { capture: true });
        context.stage.off('dblclick', this.handleDBLClick, { capture: true });
        application.global.addEventListener('keydown', this.handleKeyDown);
    }
    stopPropagation(e) {
        e.stopPropagation();
    }
    addEditLineOrBgOrBounds(graphic, shadowRoot) {
        let group = shadowRoot.getElementById('emptyBoundsContainer');
        if (!group) {
            group = createGroup({ x: 0, y: 0, width: 0, height: 0, boundsMode: 'empty' });
            group.id = 'emptyBoundsContainer';
            shadowRoot.add(group);
        }
        group.add(graphic);
    }
    removeEditLineOrBgOrBounds(graphic, shadowRoot) {
        const group = shadowRoot.getElementById('emptyBoundsContainer');
        if (!group) {
            return;
        }
        group.removeChild(graphic);
    }
    onFocus(e, data) {
        this.updateCbs && this.updateCbs.forEach(cb => cb('beforeOnfocus', this));
        this.deFocus(false);
        this.focusing = true;
        this.editing = true;
        const target = e.target;
        if (!(target && target.type === 'richtext')) {
            return;
        }
        this.currRt = target;
        RichTextEditPlugin.tryUpdateRichtext(target);
        const shadowRoot = this.getShadow(target);
        const cache = target.getFrameCache();
        if (!cache) {
            return;
        }
        const { editOptions = {} } = this.currRt.attribute;
        if (editOptions.stopPropagation) {
            target.addEventListener('*', this.stopPropagation);
        }
        this.offsetShadowRoot(target);
        if (!this.editLine) {
            const line = createLine({ x: 0, y: 0, lineWidth: 1, stroke: 'black' });
            this.addAnimateToLine(line);
            this.editLine = line;
            this.ticker && this.ticker.start(true);
            const g = createGroup({ x: 0, y: 0, width: 0, height: 0 });
            this.editBg = g;
            this.addEditLineOrBgOrBounds(this.editLine, shadowRoot);
            this.addEditLineOrBgOrBounds(this.editBg, shadowRoot);
        }
        data = data || this.computedCursorPosByEvent(e, cache);
        if (data) {
            const { x, y1, y2, cursorIndex } = data;
            this.startCursorPos = { x, y: (y1 + y2) / 2 };
            this.curCursorIdx = cursorIndex;
            this.selectionStartCursorIdx = cursorIndex;
            this.setCursorAndTextArea(x, y1, y2, target);
        }
        else {
            const x = 0;
            const y1 = 0;
            const y2 = getRichTextBounds(Object.assign(Object.assign({}, target.attribute), { textConfig: [{ text: 'a' }], scaleX: 1, scaleY: 1 })).height();
            this.startCursorPos = { x, y: (y1 + y2) / 2 };
            this.curCursorIdx = -0.1;
            this.selectionStartCursorIdx = -0.1;
            this.setCursorAndTextArea(x, y1, y2, target);
        }
        this.tryShowShadowPlaceholder();
        this.tryShowInputBounds();
        this.currRt.addUpdateBoundTag();
    }
    offsetShadowRoot(rt) {
        rt = rt || this.currRt;
        if (!rt) {
            return;
        }
        const shadowRoot = this.getShadow(rt);
        if (!shadowRoot) {
            return;
        }
        const cache = rt.getFrameCache();
        if (!cache) {
            return;
        }
        this.computeGlobalDelta(cache);
        shadowRoot.setAttributes({ shadowRootIdx: 1, pickable: false, x: this.deltaX, y: this.deltaY });
        this.shadowPlaceHolder && this.shadowPlaceHolder.setAttributes({ dx: -this.deltaX, dy: -this.deltaY });
    }
    offsetLineBgAndShadowBounds() {
        const rt = this.currRt;
        const { textBaseline } = rt.attribute;
        let dy = 0;
        let attr = rt.attribute;
        let b;
        if (textBaseline === 'middle' || textBaseline === 'bottom') {
            if (!attr.textConfig.length) {
                attr = Object.assign(Object.assign({}, attr), { textConfig: [{ text: 'a' }] });
            }
            b = getRichTextBounds(Object.assign(Object.assign({}, attr), { scaleX: 1, scaleY: 1 }));
        }
        if (textBaseline === 'middle') {
            dy = -b.height() / 2;
        }
        else if (textBaseline === 'bottom') {
            dy = -b.height();
        }
        this.editLine && this.editLine.setAttributes({ dy });
        this.editBg && this.editBg.setAttributes({ dy });
        if (this.shadowBounds) {
            this.shadowBounds.setAttributes({ dy });
        }
    }
    deFocus(trulyDeFocus = false) {
        this.editing = false;
        this.updateCbs && this.updateCbs.forEach(cb => cb('beforeDefocus', this, { trulyDeFocus }));
        const currRt = this.currRt;
        if (!currRt) {
            return;
        }
        const { editOptions = {} } = currRt.attribute;
        if (editOptions.stopPropagation) {
            currRt.removeEventListener('*', this.stopPropagation);
        }
        if (trulyDeFocus) {
            this.trySyncPlaceholderToTextConfig();
            currRt.detachShadow();
        }
        this.currRt = null;
        this.editModule.currRt = null;
        const shadowRoot = this.getShadow(currRt);
        if (this.editLine) {
            this.removeEditLineOrBgOrBounds(this.editLine, shadowRoot);
            this.editLine.release();
            this.editLine = null;
            this.removeEditLineOrBgOrBounds(this.editBg, shadowRoot);
            this.editBg.release();
            this.editBg = null;
        }
        if (trulyDeFocus) {
            if (this.shadowBounds) {
                this.removeEditLineOrBgOrBounds(this.shadowBounds, shadowRoot);
                this.shadowBounds.release();
                this.shadowBounds = null;
            }
            if (this.shadowPlaceHolder) {
                this.shadowPlaceHolder.parent && this.shadowPlaceHolder.parent.removeChild(this.shadowPlaceHolder);
                this.shadowPlaceHolder.release();
                this.shadowPlaceHolder = null;
            }
        }
        this.focusing = false;
        currRt.removeEventListener('pointerleave', this.handleLeave);
    }
    addAnimateToLine(line) {
        if (!line.animate) {
            return;
        }
        line.setAttributes({ opacity: 1 });
        line.animates &&
            line.animates.forEach(animate => {
                animate.stop();
                animate.release();
            });
        const animate = line.animate({
            timeline: this.timeline
        });
        animate.to({ opacity: 1 }, 10, 'linear').wait(700).to({ opacity: 0 }, 10, 'linear').wait(700).loop(Infinity);
    }
    tryShowSelection(e, dblclick) {
        const cache = e.target.getFrameCache();
        if (!(cache && this.editBg && this.startCursorPos)) {
            return;
        }
        if (!dblclick) {
            if (this.pointerDown) {
                const currCursorData = this.computedCursorPosByEvent(e, cache);
                if (!currCursorData) {
                    return;
                }
                this.curCursorIdx = currCursorData.cursorIndex;
                this._tryShowSelection(currCursorData, cache);
            }
        }
        else {
            const currCursorData = this.computedCursorPosByEvent(e, cache);
            if (!currCursorData) {
                return;
            }
            const lineInfo = currCursorData.lineInfo;
            const columnIndex = lineInfo.paragraphs.findIndex(item => item === currCursorData.columnInfo);
            if (columnIndex < 0) {
                return;
            }
            const str = lineInfo.paragraphs.reduce((str, item) => {
                return str + item.text;
            }, '');
            let idx = 0;
            for (let i = 0; i < cache.lines.length; i++) {
                const line = cache.lines[i];
                if (line === lineInfo) {
                    break;
                }
                idx += line.paragraphs.length;
            }
            const { startIdx, endIdx } = getWordStartEndIdx(str, columnIndex);
            this.selectionRange(idx + startIdx - 0.1, idx + endIdx - 0.1);
        }
    }
    _tryShowSelection(currCursorData, cache) {
        let startCursorPos = this.startCursorPos;
        let endCursorPos = {
            x: currCursorData.x,
            y: (currCursorData.y1 + currCursorData.y2) / 2
        };
        let line0Info = this.getLineByPoint(cache, startCursorPos);
        let line1Info = this.getLineByPoint(cache, endCursorPos);
        if (startCursorPos.y > endCursorPos.y ||
            (startCursorPos.y === endCursorPos.y && startCursorPos.x > endCursorPos.x)) {
            [startCursorPos, endCursorPos] = [endCursorPos, startCursorPos];
            [line1Info, line0Info] = [line0Info, line1Info];
        }
        this.hideSelection();
        if (line0Info === line1Info) {
            this.editBg.setAttributes({
                x: startCursorPos.x,
                y: line0Info.top,
                width: endCursorPos.x - startCursorPos.x,
                height: line0Info.height,
                fill: '#336df4',
                fillOpacity: 0.2
            });
        }
        else {
            this.editBg.setAttributes({ x: 0, y: line0Info.top, width: 0, height: 0 });
            const startIdx = cache.lines.findIndex(item => item === line0Info);
            const endIdx = cache.lines.findIndex(item => item === line1Info);
            let y = 0;
            for (let i = startIdx; i <= endIdx; i++) {
                const line = cache.lines[i];
                if (i === startIdx) {
                    const p = line.paragraphs[line.paragraphs.length - 1];
                    this.editBg.add(createRect({
                        x: startCursorPos.x,
                        y,
                        width: p.left + p.width - startCursorPos.x,
                        height: line.height,
                        fill: '#336df4',
                        fillOpacity: 0.2
                    }));
                }
                else if (i === endIdx) {
                    const p = line.paragraphs[0];
                    this.editBg.add(createRect({
                        x: p.left,
                        y,
                        width: endCursorPos.x - p.left,
                        height: line.height,
                        fill: '#336df4',
                        fillOpacity: 0.2
                    }));
                }
                else {
                    const p0 = line.paragraphs[0];
                    const p1 = line.paragraphs[line.paragraphs.length - 1];
                    this.editBg.add(createRect({
                        x: p0.left,
                        y,
                        width: p1.left + p1.width - p0.left,
                        height: line.height,
                        fill: '#336df4',
                        fillOpacity: 0.2
                    }));
                }
                y += line.height;
            }
        }
        this.setCursorAndTextArea(currCursorData.x, currCursorData.y1, currCursorData.y2, this.currRt);
        this.triggerRender();
        this.updateCbs.forEach(cb => cb('selection', this));
    }
    hideSelection() {
        if (this.editBg) {
            this.editBg.removeAllChild();
            this.editBg.setAttributes({ fill: 'transparent' });
        }
    }
    getShadow(rt) {
        const sr = rt.shadowRoot || rt.attachShadow();
        sr.setAttributes({ width: 0, height: 0 });
        return sr;
    }
    getLineByPoint(cache, p1) {
        let lineInfo = cache.lines[0];
        for (let i = 0; i < cache.lines.length; i++) {
            if (lineInfo.top <= p1.y && lineInfo.top + lineInfo.height >= p1.y) {
                break;
            }
            lineInfo = cache.lines[i + 1];
        }
        return lineInfo;
    }
    getColumnAndIndexByLinePoint(lineInfo, p1) {
        let columnInfo = lineInfo.paragraphs[0];
        let delta = 0;
        if (lineInfo.paragraphs.length) {
            const start = lineInfo.paragraphs[0];
            const end = lineInfo.paragraphs[lineInfo.paragraphs.length - 1];
            if (p1.x <= start.left) {
                delta = -0.1;
                columnInfo = start;
            }
            else if (p1.x >= end.left + end.width) {
                delta = 0.1;
                columnInfo = end;
            }
        }
        if (!delta) {
            for (let i = 0; i < lineInfo.paragraphs.length; i++) {
                columnInfo = lineInfo.paragraphs[i];
                if (columnInfo.left <= p1.x && columnInfo.left + columnInfo.width >= p1.x) {
                    if (p1.x > columnInfo.left + columnInfo.width / 2) {
                        delta = 0.1;
                    }
                    else {
                        delta = -0.1;
                    }
                    break;
                }
            }
        }
        return {
            columnInfo,
            delta
        };
    }
    getColumnIndex(cache, cInfo) {
        let inputIndex = -1;
        for (let i = 0; i < cache.lines.length; i++) {
            const line = cache.lines[i];
            for (let j = 0; j < line.paragraphs.length; j++) {
                inputIndex++;
                if (cInfo === line.paragraphs[j]) {
                    return inputIndex;
                }
            }
        }
        return -1;
    }
    isRichtext(e) {
        return !!(e.target && e.target.type === 'richtext');
    }
    isEditableRichtext(e) {
        return this.isRichtext(e) && !!e.target.attribute.editable;
    }
    triggerRender() {
        this.pluginService.stage.renderNextFrame();
    }
    computeGlobalDelta(cache) {
        this.deltaX = 0;
        this.deltaY = 0;
        if (cache.lines.length === 0 && this.shadowPlaceHolder) {
            cache = this.shadowPlaceHolder.getFrameCache();
        }
        const height = cache.height;
        const actualHeight = cache.actualHeight;
        const width = cache.lines.reduce((w, item) => Math.max(w, item.actualWidth), 0);
        if (cache.globalAlign === 'center') {
            this.deltaX = -width / 2;
        }
        else if (cache.globalAlign === 'right') {
            this.deltaX = -width;
        }
        if (cache.verticalDirection === 'middle') {
            this.deltaY = height / 2 - actualHeight / 2;
        }
        else if (cache.verticalDirection === 'bottom') {
            this.deltaY = height - actualHeight;
        }
    }
    getEventPosition(e) {
        const p = this.pluginService.stage.eventPointTransform(e);
        const p1 = { x: 0, y: 0 };
        e.target.globalTransMatrix.transformPoint(p, p1);
        p1.x -= this.deltaX;
        p1.y -= this.deltaY;
        const rt = this.currRt;
        const { textBaseline } = rt.attribute;
        let dy = 0;
        if (textBaseline === 'middle') {
            const b = getRichTextBounds(Object.assign(Object.assign({}, rt.attribute), { scaleX: 1, scaleY: 1 }));
            dy = b.height() / 2;
        }
        else if (textBaseline === 'bottom') {
            const b = getRichTextBounds(Object.assign(Object.assign({}, rt.attribute), { scaleX: 1, scaleY: 1 }));
            dy = b.height();
        }
        p1.y += dy;
        return p1;
    }
    setCursorAndTextArea(x, y1, y2, rt) {
        this.editLine.setAttributes({
            points: [
                { x, y: y1 },
                { x, y: y2 }
            ]
        });
        this.addAnimateToLine(this.editLine);
        const out = { x: 0, y: 0 };
        rt.globalTransMatrix.getInverse().transformPoint({ x, y: y1 }, out);
        const { left, top } = this.pluginService.stage.window.getBoundingClientRect();
        out.x += left;
        out.y += top;
        this.offsetLineBgAndShadowBounds();
        this.offsetShadowRoot();
        this.editModule.moveTo(out.x, out.y, rt, this.curCursorIdx, this.selectionStartCursorIdx);
    }
    computedCursorPosByEvent(e, cache) {
        const p1 = this.getEventPosition(e);
        const lineInfo = this.getLineByPoint(cache, p1);
        if (!lineInfo) {
            return;
        }
        const { columnInfo, delta } = this.getColumnAndIndexByLinePoint(lineInfo, p1);
        if (!columnInfo) {
            return;
        }
        const y1 = lineInfo.top;
        const y2 = lineInfo.top + lineInfo.height;
        let cursorIndex = this.getColumnIndex(cache, columnInfo);
        cursorIndex += delta;
        const x = columnInfo.left + (delta > 0 ? columnInfo.width : 0);
        return {
            x,
            y1,
            y2,
            cursorIndex,
            lineInfo,
            columnInfo
        };
    }
    computedCursorPosByCursorIdx(cursorIdx, rt) {
        var _a, _b, _c;
        const idx = Math.round(cursorIdx);
        const leftRight = cursorIdx - idx;
        const cache = rt.getFrameCache();
        const column = this.getColumnByIndex(cache, idx);
        const height = (_a = rt.attribute.fontSize) !== null && _a !== void 0 ? _a : (_c = (_b = rt.attribute.textConfig) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.fontSize;
        if (!column) {
            if (!cache.lines.length) {
                const b = getRichTextBounds(Object.assign(Object.assign({}, rt.attribute), { textConfig: [{ text: 'a' }] }));
                return {
                    x: 0,
                    y1: 0,
                    y2: b.height()
                };
            }
            return {
                x: 0,
                y1: 0,
                y2: height
            };
        }
        const { lineInfo, columnInfo } = column;
        const y1 = lineInfo.top;
        const y2 = lineInfo.top + lineInfo.height;
        const x = columnInfo.left + (leftRight < 0 ? 0 : columnInfo.width);
        return { x, y1, y2, lineInfo, columnInfo };
    }
    getColumnByIndex(cache, index) {
        for (let i = 0, inputIndex = 0; i < cache.lines.length; i++) {
            const lineInfo = cache.lines[i];
            for (let j = 0; j < lineInfo.paragraphs.length; j++) {
                const columnInfo = lineInfo.paragraphs[j];
                if (inputIndex === index) {
                    return {
                        lineInfo,
                        columnInfo
                    };
                }
                inputIndex++;
            }
        }
        return null;
    }
    release() {
        this.deactivate(this.pluginService);
        this.editModule.release();
    }
    getSelection(defaultAll = false) {
        if (!this.currRt) {
            return null;
        }
        if (this.selectionStartCursorIdx != null &&
            this.curCursorIdx != null) {
            return new Selection(this.selectionStartCursorIdx, this.curCursorIdx, this.currRt);
        }
        else if (defaultAll) {
            return RichTextEditPlugin.CreateSelection(this.currRt);
        }
        return null;
    }
    forceFocus(params) {
        const { target, e, cursorIndex } = params;
        if (!target) {
            return;
        }
        this.currRt = target;
        if (e) {
            this._forceFocusByEvent(e);
        }
        else {
            this._forceFocusByCursorIndex(cursorIndex !== null && cursorIndex !== void 0 ? cursorIndex : -0.1);
        }
    }
    _forceFocusByEvent(e) {
        this.handleEnter();
        this.handlePointerDown(e);
        this.handlePointerUp(e);
    }
    _forceFocusByCursorIndex(cursorIndex) {
        const richtext = this.currRt;
        if (!richtext) {
            return;
        }
        let x = 0;
        let y1 = 0;
        let y2 = 2;
        let lineInfo = null;
        let columnInfo = null;
        const data = this.computedCursorPosByCursorIdx(cursorIndex, richtext);
        x = data.x;
        y1 = data.y1;
        y2 = data.y2;
        lineInfo = data.lineInfo;
        columnInfo = data.columnInfo;
        this.onFocus({ target: this.currRt }, {
            x,
            y1,
            y2,
            cursorIndex,
            lineInfo,
            columnInfo
        });
    }
}

class DefaultGraphicAllocate {
    constructor() {
        this.pools = [];
    }
    free(d) {
        this.pools.push(d);
    }
    get length() {
        return this.pools.length;
    }
    release(...params) {
        this.pools = [];
    }
}
class DefaultRectAllocate extends DefaultGraphicAllocate {
    allocate(attribute) {
        if (!this.pools.length) {
            return application.graphicService.creator.rect(attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(attribute);
        return g;
    }
    allocateByObj(rect) {
        if (!this.pools.length) {
            return application.graphicService.creator.rect(rect.attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(rect.attribute);
        return g;
    }
}
const defaultRectAllocate = new DefaultRectAllocate();
class DefaultArcAllocate extends DefaultGraphicAllocate {
    allocate(attribute) {
        if (!this.pools.length) {
            return application.graphicService.creator.arc(attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(attribute);
        return g;
    }
    allocateByObj(arc) {
        if (!this.pools.length) {
            return application.graphicService.creator.arc(arc.attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(arc.attribute);
        return g;
    }
}
const defaultArcAllocate = new DefaultArcAllocate();
class DefaultAreaAllocate extends DefaultGraphicAllocate {
    allocate(attribute) {
        if (!this.pools.length) {
            return application.graphicService.creator.area(attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(attribute);
        return g;
    }
    allocateByObj(area) {
        if (!this.pools.length) {
            return application.graphicService.creator.area(area.attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(area.attribute);
        return g;
    }
}
const defaultAreaAllocate = new DefaultAreaAllocate();
class DefaultCircleAllocate extends DefaultGraphicAllocate {
    allocate(attribute) {
        if (!this.pools.length) {
            return application.graphicService.creator.circle(attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(attribute);
        return g;
    }
    allocateByObj(area) {
        if (!this.pools.length) {
            return application.graphicService.creator.circle(area.attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(area.attribute);
        return g;
    }
}
const defaultCircleAllocate = new DefaultCircleAllocate();
class DefaultLineAllocate extends DefaultGraphicAllocate {
    allocate(attribute) {
        if (!this.pools.length) {
            return application.graphicService.creator.line(attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(attribute);
        return g;
    }
    allocateByObj(line) {
        if (!this.pools.length) {
            return application.graphicService.creator.line(line.attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(line.attribute);
        return g;
    }
}
const defaultLineAllocate = new DefaultLineAllocate();
class DefaultPathAllocate extends DefaultGraphicAllocate {
    allocate(attribute) {
        if (!this.pools.length) {
            return application.graphicService.creator.path(attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(attribute);
        return g;
    }
    allocateByObj(path) {
        if (!this.pools.length) {
            return application.graphicService.creator.path(path.attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(path.attribute);
        return g;
    }
}
const defaultPathAllocate = new DefaultPathAllocate();
class DefaultSymbolAllocate extends DefaultGraphicAllocate {
    allocate(attribute) {
        if (!this.pools.length) {
            return application.graphicService.creator.symbol(attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(attribute);
        return g;
    }
    allocateByObj(symbol) {
        if (!this.pools.length) {
            return application.graphicService.creator.symbol(symbol.attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(symbol.attribute);
        return g;
    }
}
const defaultSymbolAllocate = new DefaultSymbolAllocate();
class DefaultTextAllocate extends DefaultGraphicAllocate {
    allocate(attribute) {
        if (!this.pools.length) {
            return application.graphicService.creator.text(attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(attribute);
        return g;
    }
    allocateByObj(text) {
        if (!this.pools.length) {
            return application.graphicService.creator.text(text.attribute);
        }
        const g = this.pools.pop();
        g.initAttributes(text.attribute);
        return g;
    }
}
const defaultTextAllocate = new DefaultTextAllocate();
class DefaultGraphicMemoryManager {
    constructor() {
        this.map = {
            text: defaultTextAllocate,
            symbol: defaultSymbolAllocate
        };
    }
    gc(g) {
        if (g.isContainer) {
            g.forEachChildren(i => this.gc(i));
        }
        else {
            this.gcItem(g);
        }
    }
    gcItem(g) {
        const allocate = this.map[g.type];
        if (allocate) {
            allocate.free(g);
        }
    }
}
const defaultGraphicMemoryManager = new DefaultGraphicMemoryManager();

let loadArcModule = false;
const arcModule = new ContainerModule(bind => {
    if (loadArcModule) {
        return;
    }
    loadArcModule = true;
    bind(DefaultCanvasArcRender).toSelf().inSingletonScope();
    bind(ArcRender).to(DefaultCanvasArcRender).inSingletonScope();
    bind(GraphicRender).toService(ArcRender);
    bind(ArcRenderContribution).toService(DefaultBaseInteractiveRenderContribution);
    bindContributionProvider(bind, ArcRenderContribution);
});

let loadRectModule = false;
const rectModule = new ContainerModule(bind => {
    if (loadRectModule) {
        return;
    }
    loadRectModule = true;
    bind(DefaultCanvasRectRender).toSelf().inSingletonScope();
    bind(RectRender).to(DefaultCanvasRectRender).inSingletonScope();
    bind(GraphicRender).toService(RectRender);
    bind(SplitRectAfterRenderContribution).toSelf();
    bind(SplitRectBeforeRenderContribution).toSelf();
    bind(RectRenderContribution).toService(SplitRectAfterRenderContribution);
    bind(RectRenderContribution).toService(SplitRectBeforeRenderContribution);
    bind(RectRenderContribution).toService(DefaultBaseInteractiveRenderContribution);
    bindContributionProvider(bind, RectRenderContribution);
});

let loadLineModule = false;
const lineModule = new ContainerModule(bind => {
    if (loadLineModule) {
        return;
    }
    loadLineModule = true;
    bind(DefaultCanvasLineRender).toSelf().inSingletonScope();
    bind(DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope();
    bind(LineRender).to(DefaultCanvasLineRender).inSingletonScope();
    bind(GraphicRender).toService(LineRender);
});

let loadAreaModule = false;
const areaModule = new ContainerModule(bind => {
    if (loadAreaModule) {
        return;
    }
    loadAreaModule = true;
    bind(DefaultCanvasAreaRender).toSelf().inSingletonScope();
    bind(AreaRender).to(DefaultCanvasAreaRender).inSingletonScope();
    bind(GraphicRender).toService(AreaRender);
    bind(AreaRenderContribution).toService(DefaultBaseInteractiveRenderContribution);
    bindContributionProvider(bind, AreaRenderContribution);
    bind(DefaultIncrementalCanvasAreaRender).toSelf().inSingletonScope();
});

let loadSymbolModule = false;
const symbolModule = new ContainerModule(bind => {
    if (loadSymbolModule) {
        return;
    }
    loadSymbolModule = true;
    bind(DefaultCanvasSymbolRender).toSelf().inSingletonScope();
    bind(SymbolRender).to(DefaultCanvasSymbolRender).inSingletonScope();
    bind(GraphicRender).toService(SymbolRender);
    bind(SymbolRenderContribution).toService(DefaultBaseInteractiveRenderContribution);
    bindContributionProvider(bind, SymbolRenderContribution);
});

let loadCircleModule = false;
const circleModule = new ContainerModule(bind => {
    if (loadCircleModule) {
        return;
    }
    loadCircleModule = true;
    bind(DefaultCanvasCircleRender).toSelf().inSingletonScope();
    bind(CircleRender).to(DefaultCanvasCircleRender).inSingletonScope();
    bind(GraphicRender).toService(CircleRender);
    bind(CircleRenderContribution).toService(DefaultBaseInteractiveRenderContribution);
    bindContributionProvider(bind, CircleRenderContribution);
});

let loadTextModule = false;
const textModule = new ContainerModule(bind => {
    if (loadTextModule) {
        return;
    }
    loadTextModule = true;
    bind(TextRender).to(DefaultCanvasTextRender).inSingletonScope();
    bind(GraphicRender).toService(TextRender);
    bind(TextRenderContribution).toService(DefaultBaseInteractiveRenderContribution);
    bindContributionProvider(bind, TextRenderContribution);
});

let loadPathModule = false;
const pathModule = new ContainerModule(bind => {
    if (loadPathModule) {
        return;
    }
    loadPathModule = true;
    bind(DefaultCanvasPathRender).toSelf().inSingletonScope();
    bind(PathRender).to(DefaultCanvasPathRender).inSingletonScope();
    bind(GraphicRender).toService(PathRender);
    bind(PathRenderContribution).toService(DefaultBaseInteractiveRenderContribution);
    bindContributionProvider(bind, PathRenderContribution);
});

let loadPolygonModule = false;
const polygonModule = new ContainerModule(bind => {
    if (loadPolygonModule) {
        return;
    }
    loadPolygonModule = true;
    bind(PolygonRender).to(DefaultCanvasPolygonRender).inSingletonScope();
    bind(GraphicRender).toService(PolygonRender);
    bind(PolygonRenderContribution).toService(DefaultBaseInteractiveRenderContribution);
    bindContributionProvider(bind, PolygonRenderContribution);
});

let DefaultCanvasStarRender = class DefaultCanvasStarRender extends BaseRender {
    constructor(starRenderContribitions) {
        super();
        this.starRenderContribitions = starRenderContribitions;
        this.numberType = STAR_NUMBER_TYPE;
        this.builtinContributions = [defaultStarBackgroundRenderContribution, defaultStarTextureRenderContribution];
        this.init(starRenderContribitions);
    }
    drawShape(star, context, x, y, drawContext, params, fillCb, strokeCb) {
        const starAttribute = getTheme(star, params === null || params === void 0 ? void 0 : params.theme).star;
        const { x: originX = starAttribute.x, y: originY = starAttribute.y, fillStrokeOrder = starAttribute.fillStrokeOrder } = star.attribute;
        const data = this.valid(star, starAttribute, fillCb, strokeCb);
        if (!data) {
            return;
        }
        const { fVisible, sVisible, doFill, doStroke } = data;
        const points = star.getCachedPoints();
        context.beginPath();
        if (points && points.length) {
            points.forEach((point, index) => {
                if (index === 0) {
                    context.moveTo(x + point.x, y + point.y);
                }
                else {
                    context.lineTo(x + point.x, y + point.y);
                }
            });
        }
        context.closePath();
        context.setShadowBlendStyle && context.setShadowBlendStyle(star, star.attribute, starAttribute);
        this.beforeRenderStep(star, context, x, y, doFill, doStroke, fVisible, sVisible, starAttribute, drawContext, fillCb, strokeCb);
        const _runFill = () => {
            if (doFill) {
                if (fillCb) {
                    fillCb(context, star.attribute, starAttribute);
                }
                else if (fVisible) {
                    context.setCommonStyle(star, star.attribute, originX - x, originY - y, starAttribute);
                    context.fill();
                }
            }
        };
        const _runStroke = () => {
            if (doStroke) {
                if (strokeCb) {
                    strokeCb(context, star.attribute, starAttribute);
                }
                else if (sVisible) {
                    context.setStrokeStyle(star, star.attribute, originX - x, originY - y, starAttribute);
                    context.stroke();
                }
            }
        };
        if (!fillStrokeOrder) {
            _runFill();
            _runStroke();
        }
        else {
            _runStroke();
            _runFill();
        }
        this.afterRenderStep(star, context, x, y, doFill, doStroke, fVisible, sVisible, starAttribute, drawContext, fillCb, strokeCb);
    }
    draw(star, renderService, drawContext, params) {
        const starAttribute = getTheme(star, params === null || params === void 0 ? void 0 : params.theme).star;
        this._draw(star, starAttribute, false, drawContext, params);
    }
};
DefaultCanvasStarRender = __decorate([
    injectable(),
    __param(0, inject(ContributionProvider)),
    __param(0, named(StarRenderContribution)),
    __metadata("design:paramtypes", [Object])
], DefaultCanvasStarRender);

let loadStarModule = false;
const starModule = new ContainerModule(bind => {
    if (loadStarModule) {
        return;
    }
    loadStarModule = true;
    bind(StarRender).to(DefaultCanvasStarRender).inSingletonScope();
    bind(GraphicRender).toService(StarRender);
});

let DefaultCanvasGlyphRender = class DefaultCanvasGlyphRender {
    constructor() {
        this.numberType = GLYPH_NUMBER_TYPE;
    }
    reInit() {
        return;
    }
    drawShape(glyph, context, x, y, drawContext, params, fillCb, strokeCb) {
        if (!drawContext.drawContribution) {
            return;
        }
        glyph.getSubGraphic().forEach(item => {
            const renderer = drawContext.drawContribution.getRenderContribution(item);
            if (renderer && renderer.drawShape) {
                renderer.drawShape(item, context, x, y, drawContext, params, fillCb, strokeCb);
            }
        });
    }
    draw(glyph, renderService, drawContext, params) {
        const { context } = drawContext;
        if (!context) {
            return;
        }
        context.highPerformanceSave();
        if (!drawContext.drawContribution) {
            return;
        }
        const glyphTheme = getTheme(glyph);
        const subGraphic = glyph.getSubGraphic();
        subGraphic.length &&
            subGraphic.forEach(g => {
                drawContext.drawContribution.renderItem(g, drawContext, { theme: glyphTheme });
            });
        context.highPerformanceRestore();
    }
};
DefaultCanvasGlyphRender = __decorate([
    injectable()
], DefaultCanvasGlyphRender);

let loadGlyphModule = false;
const glyphModule = new ContainerModule(bind => {
    if (loadGlyphModule) {
        return;
    }
    loadGlyphModule = true;
    bind(GlyphRender).to(DefaultCanvasGlyphRender).inSingletonScope();
    bind(GraphicRender).toService(GlyphRender);
});

let DefaultCanvasRichTextRender = class DefaultCanvasRichTextRender extends BaseRender {
    constructor() {
        super();
        this.numberType = RICHTEXT_NUMBER_TYPE;
        this.builtinContributions = [defaultTextBackgroundRenderContribution];
        this.init();
    }
    drawShape(richtext, context, x, y, drawContext) {
        const richtextAttribute = getTheme(richtext).richtext;
        const { strokeOpacity = richtextAttribute.strokeOpacity, opacity = richtextAttribute.opacity, fillOpacity = richtextAttribute.fillOpacity, visible = richtextAttribute.visible } = richtext.attribute;
        if (!(richtext.valid && visible)) {
            return;
        }
        const fVisible = fillVisible(opacity, fillOpacity, true);
        const sVisible = fillVisible(opacity, strokeOpacity, true);
        if (!fVisible) {
            return;
        }
        context.setShadowBlendStyle && context.setShadowBlendStyle(richtext, richtext.attribute, richtextAttribute);
        context.translate(x, y);
        this.beforeRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
        const frame = richtext.getFrameCache();
        frame.draw(context, this.drawIcon);
        this.afterRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
    }
    drawIcon(icon, context, x, y, baseline) {
        var _a;
        const richtextIconAttribute = getTheme(icon).richtextIcon;
        const { width = richtextIconAttribute.width, height = richtextIconAttribute.height, opacity = richtextIconAttribute.opacity, image: url, backgroundFill = richtextIconAttribute.backgroundFill, backgroundFillOpacity = richtextIconAttribute.backgroundFillOpacity, backgroundStroke = richtextIconAttribute.backgroundStroke, backgroundStrokeOpacity = richtextIconAttribute.backgroundStrokeOpacity, backgroundRadius = richtextIconAttribute.backgroundRadius, margin } = icon.attribute;
        const { backgroundWidth = width, backgroundHeight = height } = icon.attribute;
        if (margin) {
            x += icon._marginArray[3];
            y += icon._marginArray[0];
        }
        if (icon._hovered) {
            const expandX = (backgroundWidth - width) / 2;
            const expandY = (backgroundHeight - height) / 2;
            if (backgroundRadius === 0) {
                context.beginPath();
                context.rect(x - expandX, y - expandY, backgroundWidth, backgroundHeight);
            }
            else {
                context.beginPath();
                createRectPath(context, x - expandX, y - expandY, backgroundWidth, backgroundHeight, backgroundRadius, true);
            }
            if (backgroundFill) {
                context.globalAlpha = backgroundFillOpacity;
                context.fillStyle = backgroundFill;
                context.fill();
            }
            if (backgroundStroke) {
                context.globalAlpha = backgroundStrokeOpacity;
                context.strokeStyle = backgroundStroke;
                context.stroke();
            }
        }
        const res = url && ((_a = icon === null || icon === void 0 ? void 0 : icon.resources) === null || _a === void 0 ? void 0 : _a.get(url));
        if (!res || res.state !== 'success') {
            return;
        }
        context.globalAlpha = opacity;
        context.drawImage(res.data, x, y, width, height);
    }
    draw(richtext, renderService, drawContext) {
        const richtextAttribute = getTheme(richtext).richtext;
        this._draw(richtext, richtextAttribute, false, drawContext);
    }
};
DefaultCanvasRichTextRender = __decorate([
    injectable(),
    __metadata("design:paramtypes", [])
], DefaultCanvasRichTextRender);

let loadRichtextModule = false;
const richtextModule = new ContainerModule(bind => {
    if (loadRichtextModule) {
        return;
    }
    loadRichtextModule = true;
    bind(RichTextRender).to(DefaultCanvasRichTextRender).inSingletonScope();
    bind(GraphicRender).toService(RichTextRender);
});

let loadImageModule = false;
const imageModule = new ContainerModule(bind => {
    if (loadImageModule) {
        return;
    }
    loadImageModule = true;
    bind(ImageRender).to(DefaultCanvasImageRender).inSingletonScope();
    bind(GraphicRender).toService(ImageRender);
    bind(ImageRenderContribution).toService(DefaultBaseInteractiveRenderContribution);
    bindContributionProvider(bind, ImageRenderContribution);
});

class Base3dRender extends BaseRender {
    stroke(x, y, z, face3d, context) {
        const vertices = face3d.vertices;
        face3d.edges.forEach(edge => {
            const p1 = vertices[edge[0]];
            const v1 = {
                x: x + p1[0],
                y: y + p1[1],
                z: z + p1[2]
            };
            const p2 = vertices[edge[1]];
            const v2 = {
                x: x + p2[0],
                y: y + p2[1],
                z: z + p2[2]
            };
            context.beginPath();
            context.moveTo(v1.x, v1.y, v1.z);
            context.lineTo(v2.x, v2.y, v2.z);
            context.stroke();
        });
    }
    fill(x, y, z, face3d, faces, fillColor, context, light, graphic3d, graphic3dAttribute, fillCb) {
        const rgbArray = ColorStore.Get(fillColor, ColorType.Color255);
        const vertices = face3d.vertices;
        const viewdVerticesZ = vertices.map(v => {
            return context.view(v[0], v[1], v[2])[2];
        });
        const sortFace = [];
        face3d.polygons.forEach((p, i) => {
            if (faces && !faces[i]) {
                return;
            }
            sortFace.push({
                faceIdx: i,
                polygon: p
            });
            const { polygon } = p;
            const z1 = viewdVerticesZ[polygon[0]];
            const z2 = viewdVerticesZ[polygon[1]];
            const z3 = viewdVerticesZ[polygon[2]];
            const z4 = viewdVerticesZ[polygon[3]];
            p.ave_z = z1 + z2 + z3 + z4;
        });
        sortFace.sort((a, b) => b.polygon.ave_z - a.polygon.ave_z);
        sortFace.forEach(item => {
            const { polygon, normal } = item.polygon;
            const p1 = vertices[polygon[0]];
            const p2 = vertices[polygon[1]];
            const p3 = vertices[polygon[2]];
            const p4 = vertices[polygon[3]];
            const v1 = {
                x: x + p1[0],
                y: y + p1[1],
                z: z + p1[2]
            };
            const v2 = {
                x: x + p2[0],
                y: y + p2[1],
                z: z + p2[2]
            };
            const v3 = {
                x: x + p3[0],
                y: y + p3[1],
                z: z + p3[2]
            };
            const v4 = {
                x: x + p4[0],
                y: y + p4[1],
                z: z + p4[2]
            };
            context.beginPath();
            context.moveTo(v1.x, v1.y, v1.z);
            context.lineTo(v2.x, v2.y, v2.z);
            context.lineTo(v3.x, v3.y, v3.z);
            context.lineTo(v4.x, v4.y, v4.z);
            context.closePath();
            if (fillCb) {
                fillCb(context, graphic3d && graphic3d.attribute, graphic3dAttribute);
            }
            else {
                context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor;
                context.fill();
            }
        });
    }
}

let DefaultCanvasRect3dRender = class DefaultCanvasRect3dRender extends Base3dRender {
    constructor() {
        super(...arguments);
        this.type = 'rect3d';
        this.numberType = RECT3D_NUMBER_TYPE;
    }
    drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a, _b;
        const rectAttribute = getTheme(rect, params === null || params === void 0 ? void 0 : params.theme).rect;
        const { fill = rectAttribute.fill, stroke = rectAttribute.stroke, x1, y1, x: originX, y: originY, opacity = rectAttribute.opacity, fillOpacity = rectAttribute.fillOpacity, lineWidth = rectAttribute.lineWidth, strokeOpacity = rectAttribute.strokeOpacity, visible = rectAttribute.visible, drawStrokeWhenZeroWH = (_a = rectAttribute.drawStrokeWhenZeroWH) !== null && _a !== void 0 ? _a : false } = rect.attribute;
        let { width, height } = rect.attribute;
        width = (width !== null && width !== void 0 ? width : x1 - originX) || 0;
        height = (height !== null && height !== void 0 ? height : y1 - originY) || 0;
        const z = (_b = this.z) !== null && _b !== void 0 ? _b : 0;
        const fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill);
        const sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height, drawStrokeWhenZeroWH);
        const doFill = runFill(fill);
        const doStroke = runStroke(stroke, lineWidth);
        if (!(rect.valid && visible)) {
            return;
        }
        if (!(doFill || doStroke)) {
            return;
        }
        if (!(fVisible || sVisible || fillCb || strokeCb)) {
            return;
        }
        const { light } = drawContext.stage || {};
        const face3d = rect.findFace();
        if (fill !== false) {
            context.setCommonStyle(rect, rect.attribute, x, y, rectAttribute);
            let fc = fill;
            if (typeof fc !== 'string') {
                fc = 'black';
            }
            this.fill(x, y, z, face3d, null, fc, context, light, null, null, fillCb);
        }
        if (stroke !== false) {
            context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute);
            this.stroke(x, y, z, face3d, context);
        }
    }
    draw(rect, renderService, drawContext) {
        const rectAttribute = getTheme(rect).rect;
        this._draw(rect, rectAttribute, false, drawContext);
    }
};
DefaultCanvasRect3dRender = __decorate([
    injectable()
], DefaultCanvasRect3dRender);

let loadRect3dModule = false;
const rect3dModule = new ContainerModule(bind => {
    if (loadRect3dModule) {
        return;
    }
    loadRect3dModule = true;
    bind(Rect3DRender).to(DefaultCanvasRect3dRender).inSingletonScope();
    bind(GraphicRender).toService(Rect3DRender);
});

function drawArcPath(arc, context, cx, cy, z, outerRadius, innerRadius) {
    const { startAngle, endAngle } = arc.getParsedAngle();
    const deltaAngle = abs(endAngle - startAngle);
    const clockwise = endAngle > startAngle;
    let collapsedToLine = false;
    if (outerRadius < innerRadius) {
        const temp = outerRadius;
        outerRadius = innerRadius;
        innerRadius = temp;
    }
    if (outerRadius <= epsilon) {
        context.moveTo(cx, cy, z);
    }
    else if (deltaAngle >= pi2 - epsilon) {
        context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle), z);
        context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z);
        if (innerRadius > epsilon) {
            context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle), z);
            context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z);
        }
    }
    else {
        const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle);
        const xors = outerRadius * cos(outerStartAngle);
        const yors = outerRadius * sin(outerStartAngle);
        const xire = innerRadius * cos(innerEndAngle);
        const yire = innerRadius * sin(innerEndAngle);
        if (outerDeltaAngle < 0.001) {
            collapsedToLine = true;
        }
        else {
            context.moveTo(cx + xors, cy + yors, z);
            context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z);
        }
        if (!(innerRadius > epsilon) || innerDeltaAngle < 0.001) {
            context.lineTo(cx + xire, cy + yire, z);
            collapsedToLine = true;
        }
        else {
            context.lineTo(cx + xire, cy + yire, z);
            context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z);
        }
    }
    context.closePath();
    return collapsedToLine;
}
function drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {
    const { startAngle, endAngle } = arc.getParsedAngle();
    const deltaAngle = abs(endAngle - startAngle);
    const clockwise = endAngle > startAngle;
    let collapsedToLine = false;
    if (radius <= epsilon) {
        context.moveTo(cx, cy, z1);
    }
    else if (deltaAngle >= pi2 - epsilon) {
        context.moveTo(cx + radius * cos(startAngle), cy + radius * sin(startAngle), z1);
        context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1);
        context.lineTo(cx + radius * cos(endAngle), cy + radius * sin(endAngle), z2);
        context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2);
    }
    else {
        const { innerouterDeltaAngle, innerouterStartAngle, innerouterEndAngle } = getParsePadAngle(startAngle, endAngle);
        const xors = radius * cos(innerouterStartAngle);
        const yors = radius * sin(innerouterStartAngle);
        const xore = radius * cos(innerouterEndAngle);
        const yore = radius * sin(innerouterEndAngle);
        if (innerouterDeltaAngle < 0.001) {
            collapsedToLine = true;
        }
        else {
            context.moveTo(cx + xors, cy + yors, z1);
            context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1);
            context.lineTo(cx + xore, cy + yore, z2);
            context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2);
        }
    }
    context.closePath();
    return collapsedToLine;
}
let DefaultCanvasArc3DRender = class DefaultCanvasArc3DRender extends BaseRender {
    constructor() {
        super(...arguments);
        this.numberType = ARC3D_NUMBER_TYPE;
    }
    drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        const arcAttribute = getTheme(arc, params === null || params === void 0 ? void 0 : params.theme).arc;
        const { fill = arcAttribute.fill } = arc.attribute;
        const data = this.valid(arc, arcAttribute, fillCb, strokeCb);
        if (!data) {
            return;
        }
        const { fVisible, sVisible, doFill, doStroke } = data;
        const z = (_a = this.z) !== null && _a !== void 0 ? _a : 0;
        const { outerPadding = arcAttribute.outerPadding, innerPadding = arcAttribute.innerPadding, height = 10 } = arc.attribute;
        let { outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius } = arc.attribute;
        outerRadius += outerPadding;
        innerRadius -= innerPadding;
        const rgbArray = ColorStore.Get(fill, ColorType.Color255);
        const { light } = drawContext.stage || {};
        const face = drawContext.hack_pieFace;
        const z_face = {
            top: z,
            bottom: z + height
        };
        const n_face = {
            top: [0, 1, 0],
            bottom: [0, -1, 0],
            outside: [1, 0, -1],
            inside: [1, 0, -1]
        };
        if (face === 'bottom' || face === 'top') {
            context.beginPath();
            drawArcPath(arc, context, x, y, z_face[face], outerRadius, innerRadius);
            context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute);
            if (doFill) {
                if (fillCb) {
                    fillCb(context, arc.attribute, arcAttribute);
                }
                else if (fVisible) {
                    context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute);
                    context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill;
                    context.fill();
                }
            }
            if (doStroke) {
                if (strokeCb) {
                    strokeCb(context, arc.attribute, arcAttribute);
                }
                else if (sVisible) {
                    context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute);
                    context.stroke();
                }
            }
        }
        else if (face === 'outside' || face === 'inside') {
            if (face === 'inside') {
                context.save();
                context.beginPath();
                context.arc(x, y, innerRadius, 0, pi2, true, z_face.top);
                context.clip();
            }
            context.beginPath();
            drawInnerOuterArcPath(arc, context, x, y, z_face.top, z_face.bottom, face === 'outside' ? outerRadius : innerRadius, (startAngle, endAngle) => {
                const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle);
                if (face === 'outside') {
                    return {
                        innerouterDeltaAngle: outerDeltaAngle,
                        innerouterEndAngle: outerEndAngle,
                        innerouterStartAngle: outerStartAngle
                    };
                }
                return {
                    innerouterDeltaAngle: innerDeltaAngle,
                    innerouterEndAngle: innerEndAngle,
                    innerouterStartAngle: innerStartAngle
                };
            });
            context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute);
            if (doFill) {
                if (fillCb) {
                    fillCb(context, arc.attribute, arcAttribute);
                }
                else if (fVisible) {
                    context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute);
                    context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill;
                    context.fill();
                }
            }
            if (doStroke) {
                if (strokeCb) {
                    strokeCb(context, arc.attribute, arcAttribute);
                }
                else if (sVisible) {
                    context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute);
                    context.stroke();
                }
            }
            if (face === 'inside') {
                context.restore();
            }
        }
    }
    draw(arc, renderService, drawContext, params) {
        const arcAttribute = getTheme(arc, params === null || params === void 0 ? void 0 : params.theme).arc;
        this._draw(arc, arcAttribute, false, drawContext, params);
    }
};
DefaultCanvasArc3DRender = __decorate([
    injectable()
], DefaultCanvasArc3DRender);

let loadArc3dModule = false;
const arc3dModule = new ContainerModule(bind => {
    if (loadArc3dModule) {
        return;
    }
    loadArc3dModule = true;
    bind(Arc3dRender).to(DefaultCanvasArc3DRender).inSingletonScope();
    bind(GraphicRender).toService(Arc3dRender);
});

let DefaultCanvasPyramid3dRender = class DefaultCanvasPyramid3dRender extends Base3dRender {
    constructor() {
        super(...arguments);
        this.type = 'pyramid3d';
        this.numberType = PYRAMID3D_NUMBER_TYPE;
    }
    drawShape(pyramid3d, context, x, y, drawContext, params, fillCb, strokeCb) {
        var _a;
        const pyramidAttribute = getTheme(pyramid3d, params === null || params === void 0 ? void 0 : params.theme).polygon;
        const { fill = pyramidAttribute.fill, stroke = pyramidAttribute.stroke, face = [true, true, true, true, true, true] } = pyramid3d.attribute;
        const z = (_a = this.z) !== null && _a !== void 0 ? _a : 0;
        const data = this.valid(pyramid3d, pyramidAttribute, fillCb, strokeCb);
        if (!data) {
            return;
        }
        const { light } = drawContext.stage || {};
        const face3d = pyramid3d.findFace();
        if (fill !== false) {
            context.setCommonStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute);
            let fc = fill;
            if (typeof fc !== 'string') {
                fc = 'black';
            }
            this.fill(x, y, z, face3d, face, fc, context, light, pyramid3d, pyramidAttribute, fillCb);
        }
        if (stroke !== false) {
            context.setStrokeStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute);
            this.stroke(x, y, z, face3d, context);
        }
    }
    draw(pyramid3d, renderService, drawContext) {
        const pyramid3dAttribute = getTheme(pyramid3d).polygon;
        this._draw(pyramid3d, pyramid3dAttribute, false, drawContext);
    }
};
DefaultCanvasPyramid3dRender = __decorate([
    injectable()
], DefaultCanvasPyramid3dRender);

let loadPyramid3dModule = false;
const pyramid3dModule = new ContainerModule(bind => {
    if (loadPyramid3dModule) {
        return;
    }
    loadPyramid3dModule = true;
    bind(Pyramid3dRender).to(DefaultCanvasPyramid3dRender).inSingletonScope();
    bind(GraphicRender).toService(Pyramid3dRender);
});

function registerArcGraphic() {
    graphicCreator.RegisterGraphicCreator('arc', createArc);
}

function registerArc3dGraphic() {
    graphicCreator.RegisterGraphicCreator('arc3d', createArc3d);
}

function registerAreaGraphic() {
    graphicCreator.RegisterGraphicCreator('area', createArea);
}

function registerCircleGraphic() {
    graphicCreator.RegisterGraphicCreator('circle', createCircle);
}

function registerGlyphGraphic() {
    graphicCreator.RegisterGraphicCreator('glyph', createGlyph);
}

function registerGroupGraphic() {
    graphicCreator.RegisterGraphicCreator('group', createGroup);
}

function registerImageGraphic() {
    graphicCreator.RegisterGraphicCreator('image', createImage);
}

function registerLineGraphic() {
    graphicCreator.RegisterGraphicCreator('line', createLine);
}

function registerPathGraphic() {
    graphicCreator.RegisterGraphicCreator('path', createPath);
}

function registerPolygonGraphic() {
    graphicCreator.RegisterGraphicCreator('polygon', createPolygon);
}

function registerStarGraphic() {
    graphicCreator.RegisterGraphicCreator('star', createStar);
}

function registerPyramid3dGraphic() {
    graphicCreator.RegisterGraphicCreator('pyramid3d', createPyramid3d);
}

function registerRectGraphic() {
    graphicCreator.RegisterGraphicCreator('rect', createRect);
}

function registerRect3dGraphic() {
    graphicCreator.RegisterGraphicCreator('rect3d', createRect3d);
}

function registerRichtextGraphic() {
    graphicCreator.RegisterGraphicCreator('richtext', createRichText);
}

function registerSymbolGraphic() {
    graphicCreator.RegisterGraphicCreator('symbol', createSymbol);
}

function registerTextGraphic() {
    graphicCreator.RegisterGraphicCreator('text', createText);
}

function registerShadowRootGraphic() {
    graphicCreator.RegisterGraphicCreator('shadowRoot', createShadowRoot);
}

function registerWrapTextGraphic() {
    graphicCreator.RegisterGraphicCreator('wrapText', createWrapText);
}

class HtmlAttributePlugin {
    constructor() {
        this.name = 'HtmlAttributePlugin';
        this.activeEvent = 'onRegister';
        this._uid = Generator.GenAutoIncrementId();
        this.key = this.name + this._uid;
        this.htmlMap = {};
        this.renderId = 0;
        this.onWheel = (ev) => {
            try {
                const newEvent = new ev.constructor(ev.type, ev);
                const canvas = this.pluginService.stage.window.getContext().getCanvas().nativeCanvas;
                canvas.dispatchEvent(newEvent);
            }
            catch (err) {
                return;
            }
        };
    }
    activate(context) {
        this.pluginService = context;
        context.stage.hooks.afterRender.tap(this.key, stage => {
            if (!(stage && stage === this.pluginService.stage)) {
                return;
            }
            this.drawHTML([...context.stage.getChildren()]);
        });
    }
    deactivate(context) {
        context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter(item => {
            return item.name !== this.key;
        });
        this.release();
    }
    getWrapContainer(stage, userContainer, domParams) {
        let nativeContainer;
        if (userContainer) {
            if (typeof userContainer === 'string') {
                nativeContainer = application.global.getElementById(userContainer);
            }
            else {
                nativeContainer = userContainer;
            }
        }
        else {
            nativeContainer = stage.window.getContainer();
        }
        return {
            wrapContainer: application.global.createDom(Object.assign({ tagName: 'div', parent: nativeContainer }, domParams)),
            nativeContainer
        };
    }
    parseDefaultStyleFromGraphic(graphic) {
        const attrs = graphic.type === 'text' && graphic.attribute ? graphic.attribute : getTheme(graphic).text;
        return textAttributesToStyle(attrs);
    }
    getTransformOfText(graphic) {
        const textTheme = getTheme(graphic).text;
        const { textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline } = graphic.attribute;
        const matrix = graphic.globalTransMatrix;
        const cssAttrs = matrix.toTransformAttrs();
        const { rotateDeg, scaleX, scaleY } = cssAttrs;
        const translateMap = {
            left: '0',
            start: '0',
            end: '-100%',
            center: '-50%',
            right: '-100%',
            top: '0',
            middle: '-50%',
            bottom: '-100%',
            alphabetic: '-79%'
        };
        const originMap = {
            left: '0',
            start: '0',
            end: '100%',
            center: '50%',
            right: '100%',
            top: '0',
            middle: '50%',
            bottom: '100%',
            alphabetic: '79%'
        };
        return {
            textAlign,
            transform: `translate(${translateMap[textAlign]},${translateMap[textBaseline]}) rotate(${rotateDeg}deg) scaleX(${scaleX}) scaleY(${scaleY})`,
            transformOrigin: `${originMap[textAlign]} ${originMap[textBaseline]}`
        };
    }
    updateStyleOfWrapContainer(graphic, stage, wrapContainer, nativeContainer, options) {
        const { pointerEvents, penetrateEventList = [] } = options;
        let calculateStyle = this.parseDefaultStyleFromGraphic(graphic);
        calculateStyle.display = graphic.attribute.visible !== false ? 'block' : 'none';
        calculateStyle.pointerEvents = pointerEvents === true ? 'all' : pointerEvents ? pointerEvents : 'none';
        if (calculateStyle.pointerEvents !== 'none') {
            this.removeWrapContainerEventListener(wrapContainer);
            penetrateEventList.forEach(event => {
                if (event === 'wheel') {
                    wrapContainer.addEventListener('wheel', this.onWheel);
                }
            });
        }
        if (!wrapContainer.style.position) {
            wrapContainer.style.position = 'absolute';
            nativeContainer.style.position = 'relative';
        }
        let left = 0;
        let top = 0;
        const b = graphic.globalAABBBounds;
        let anchorType = options.anchorType;
        if (isNil(anchorType)) {
            anchorType = graphic.type === 'text' ? 'position' : 'boundsLeftTop';
        }
        if (anchorType === 'boundsLeftTop') {
            anchorType = 'top-left';
        }
        if (anchorType === 'position' || b.empty()) {
            const matrix = graphic.globalTransMatrix;
            left = matrix.e;
            top = matrix.f;
        }
        else {
            const anchor = calculateAnchorOfBounds(b, anchorType);
            left = anchor.x;
            top = anchor.y;
        }
        const containerTL = application.global.getElementTopLeft(nativeContainer, false);
        const windowTL = stage.window.getTopLeft(false);
        const viewBox = stage.viewBox;
        const offsetX = left + windowTL.left - containerTL.left + viewBox.x1;
        const offsetTop = top + windowTL.top - containerTL.top + viewBox.y1;
        calculateStyle.left = `${offsetX}px`;
        calculateStyle.top = `${offsetTop}px`;
        if (graphic.type === 'text' && anchorType === 'position') {
            calculateStyle = Object.assign(Object.assign({}, calculateStyle), this.getTransformOfText(graphic));
        }
        if (isFunction(options.style)) {
            const userStyle = options.style({ top: offsetTop, left: offsetX, width: b.width(), height: b.height() }, graphic, wrapContainer);
            if (userStyle) {
                calculateStyle = Object.assign(Object.assign({}, calculateStyle), userStyle);
            }
        }
        else if (isObject(options.style)) {
            calculateStyle = Object.assign(Object.assign({}, calculateStyle), options.style);
        }
        else if (isString(options.style) && options.style) {
            calculateStyle = Object.assign(Object.assign({}, calculateStyle), styleStringToObject(options.style));
        }
        application.global.updateDom(wrapContainer, {
            width: options.width,
            height: options.height,
            style: calculateStyle
        });
    }
    clearCacheContainer() {
        if (this.htmlMap) {
            Object.keys(this.htmlMap).forEach(key => {
                if (this.htmlMap[key] && this.htmlMap[key].renderId !== this.renderId) {
                    this.removeElement(key);
                }
            });
        }
        this.renderId += 1;
    }
    drawHTML(layers) {
        if (application.global.env === 'browser') {
            layers
                .sort((a, b) => {
                var _a, _b;
                return ((_a = a.attribute.zIndex) !== null && _a !== void 0 ? _a : DefaultAttribute.zIndex) - ((_b = b.attribute.zIndex) !== null && _b !== void 0 ? _b : DefaultAttribute.zIndex);
            })
                .forEach(group => {
                this.renderGroupHTML(group);
            });
            this.clearCacheContainer();
        }
    }
    renderGroupHTML(group) {
        this.renderGraphicHTML(group);
        group.forEachChildren((g) => {
            if (g.isContainer) {
                this.renderGroupHTML(g);
            }
            else {
                this.renderGraphicHTML(g);
            }
        });
    }
    removeElement(id) {
        if (!this.htmlMap || !this.htmlMap[id]) {
            return;
        }
        const { wrapContainer } = this.htmlMap[id];
        if (wrapContainer) {
            application.global.removeDom(wrapContainer);
        }
        this.htmlMap[id] = null;
    }
    removeWrapContainerEventListener(wrapContainer) {
        wrapContainer.removeEventListener('wheel', this.onWheel);
    }
    renderGraphicHTML(graphic) {
        var _a;
        const { html } = graphic.attribute;
        if (!html) {
            return;
        }
        const stage = graphic.stage;
        if (!stage) {
            return;
        }
        const { dom, container } = html;
        if (!dom) {
            return;
        }
        const id = isNil(html.id) ? `${(_a = graphic.id) !== null && _a !== void 0 ? _a : graphic._uid}_react` : html.id;
        if (this.htmlMap && this.htmlMap[id] && container && container !== this.htmlMap[id].container) {
            this.removeElement(id);
        }
        if (!this.htmlMap || !this.htmlMap[id]) {
            const { wrapContainer, nativeContainer } = this.getWrapContainer(stage, container);
            if (wrapContainer) {
                if (typeof dom === 'string') {
                    wrapContainer.innerHTML = dom;
                }
                else {
                    wrapContainer.appendChild(dom);
                }
                if (!this.htmlMap) {
                    this.htmlMap = {};
                }
                this.htmlMap[id] = { wrapContainer, nativeContainer, container, renderId: this.renderId };
            }
        }
        else {
            if (typeof dom === 'string') {
                this.htmlMap[id].wrapContainer.innerHTML = dom;
            }
            else {
                if (dom !== this.htmlMap[id].wrapContainer.firstChild) {
                    this.htmlMap[id].wrapContainer.removeChild(this.htmlMap[id].wrapContainer.firstChild);
                    this.htmlMap[id].wrapContainer.appendChild(dom);
                }
            }
        }
        if (!this.htmlMap || !this.htmlMap[id]) {
            return;
        }
        const { wrapContainer, nativeContainer } = this.htmlMap[id];
        this.updateStyleOfWrapContainer(graphic, stage, wrapContainer, nativeContainer, html);
        this.htmlMap[id].renderId = this.renderId;
    }
    release() {
        if (application.global.env === 'browser') {
            this.removeAllDom(this.pluginService.stage.defaultLayer);
        }
    }
    removeAllDom(g) {
        if (this.htmlMap) {
            Object.keys(this.htmlMap).forEach(key => {
                this.removeElement(key);
            });
            this.htmlMap = null;
        }
    }
}
const registerHtmlAttributePlugin = () => {
    Factory.registerPlugin('HtmlAttributePlugin', HtmlAttributePlugin);
};

class ReactAttributePlugin extends HtmlAttributePlugin {
    constructor() {
        super(...arguments);
        this.name = 'ReactAttributePlugin';
        this.activeEvent = 'onRegister';
        this._uid = Generator.GenAutoIncrementId();
        this.key = this.name + this._uid;
        this.htmlMap = {};
    }
    removeElement(id) {
        if (!this.htmlMap || !this.htmlMap[id]) {
            return;
        }
        const { root, wrapContainer, unmount } = this.htmlMap[id];
        if (root) {
            const raf = application.global.getRequestAnimationFrame();
            raf(() => {
                root.unmount();
            });
        }
        else if (unmount) {
            unmount();
        }
        wrapContainer && application.global.removeDom(wrapContainer);
        this.htmlMap[id] = null;
    }
    renderGraphicHTML(graphic) {
        var _a;
        const { react } = graphic.attribute;
        if (!react) {
            return;
        }
        const stage = graphic.stage;
        if (!stage) {
            return;
        }
        const ReactDOM = stage.params.ReactDOM;
        const { element, container } = react;
        if (!(element && ReactDOM && (ReactDOM.createRoot || ReactDOM.render))) {
            return;
        }
        const id = isNil(react.id) ? `${(_a = graphic.id) !== null && _a !== void 0 ? _a : graphic._uid}_react` : react.id;
        if (this.htmlMap && this.htmlMap[id] && container && container !== this.htmlMap[id].container) {
            this.removeElement(id);
        }
        if (!this.htmlMap || !this.htmlMap[id]) {
            const { wrapContainer, nativeContainer } = this.getWrapContainer(stage, container);
            if (wrapContainer) {
                if (!this.htmlMap) {
                    this.htmlMap = {};
                }
                if (ReactDOM.createRoot) {
                    const root = ReactDOM.createRoot(wrapContainer);
                    root.render(element);
                    this.htmlMap[id] = { root, wrapContainer, nativeContainer, container, renderId: this.renderId };
                }
                else {
                    ReactDOM.render(element, wrapContainer);
                    this.htmlMap[id] = {
                        wrapContainer,
                        nativeContainer,
                        container,
                        renderId: this.renderId,
                        unmount: () => {
                            ReactDOM.unmountComponentAtNode(wrapContainer);
                        }
                    };
                }
            }
        }
        else {
            if (ReactDOM.createRoot) {
                this.htmlMap[id].root.render(element);
            }
            else {
                ReactDOM.render(element, this.htmlMap[id].wrapContainer);
            }
        }
        if (!this.htmlMap || !this.htmlMap[id]) {
            return;
        }
        const { wrapContainer, nativeContainer } = this.htmlMap[id];
        this.updateStyleOfWrapContainer(graphic, stage, wrapContainer, nativeContainer, react);
        this.htmlMap[id].renderId = this.renderId;
    }
}
const registerReactAttributePlugin = () => {
    Factory.registerPlugin('ReactAttributePlugin', ReactAttributePlugin);
};

class ViewTransform3dPlugin {
    constructor() {
        this.name = 'ViewTransform3dPlugin';
        this.activeEvent = 'onRegister';
        this._uid = Generator.GenAutoIncrementId();
        this.key = this.name + this._uid;
        this.onMouseDown = (e) => {
            if (!this.option3d) {
                this.option3d = this.pluginService.stage.option3d;
            }
            if (!this.option3d) {
                return;
            }
            this.mousedown = true;
            this.pageX = e.page.x;
            this.pageY = e.page.y;
        };
        this.onMouseUp = (e) => {
            if (!this.option3d) {
                this.option3d = this.pluginService.stage.option3d;
            }
            if (!this.option3d) {
                return;
            }
            this.mousedown = false;
        };
        this.onMouseMove = (e) => {
            var _a, _b;
            const stage = this.pluginService.stage;
            if (!this.option3d) {
                this.option3d = stage.option3d;
            }
            if (!this.option3d) {
                return;
            }
            if (this.mousedown) {
                if (!this.pageX || !this.pageY) {
                    this.pageX = e.page.x;
                    this.pageY = e.page.y;
                }
                else {
                    const deltaX = e.page.x - this.pageX;
                    const deltaY = e.page.y - this.pageY;
                    this.pageX = e.page.x;
                    this.pageY = e.page.y;
                    const angle1 = deltaX / 100;
                    const angle2 = deltaY / 100;
                    this.option3d.alpha = ((_a = this.option3d.alpha) !== null && _a !== void 0 ? _a : 0) + angle1;
                    this.option3d.beta = ((_b = this.option3d.beta) !== null && _b !== void 0 ? _b : 0) + angle2;
                    stage.set3dOptions(this.option3d);
                    stage.renderNextFrame();
                }
            }
        };
    }
    activate(context) {
        this.pluginService = context;
        const stage = context.stage;
        this.option3d = stage.option3d;
        stage.addEventListener('mousedown', this.onMouseDown);
        stage.addEventListener('mouseup', this.onMouseUp);
        stage.addEventListener('mousemove', this.onMouseMove);
    }
    deactivate(context) {
        const stage = context.stage;
        stage.removeEventListener('mousedown', this.onMouseDown);
        stage.removeEventListener('mouseup', this.onMouseUp);
        stage.removeEventListener('mousemove', this.onMouseMove);
    }
}
const registerViewTransform3dPlugin = () => {
    Factory.registerPlugin('ViewTransform3dPlugin', ViewTransform3dPlugin);
};

const _tempBounds = new AABBBounds();
class FlexLayoutPlugin {
    constructor() {
        this.name = 'FlexLayoutPlugin';
        this.activeEvent = 'onRegister';
        this.id = Generator.GenAutoIncrementId();
        this.key = this.name + this.id;
        this.tempBounds = new AABBBounds();
    }
    pauseLayout(p) {
        this.pause = p;
    }
    tryLayoutChildren(graphic) {
        if (graphic.firstChild) {
            this.tryLayout(graphic.firstChild);
        }
    }
    tryLayout(graphic, force = true) {
        if (this.pause) {
            return;
        }
        const p = graphic.parent;
        if (!(force || (p && graphic.needUpdateLayout()))) {
            return;
        }
        const theme = getTheme(p).group;
        const { display = theme.display } = p.attribute;
        if (display !== 'flex') {
            return;
        }
        const { flexDirection = theme.flexDirection, flexWrap = theme.flexWrap, alignItems = theme.alignItems, clip = theme.clip } = p.attribute;
        const { alignContent = alignItems !== null && alignItems !== void 0 ? alignItems : theme.alignContent } = p.attribute;
        let { width, height, justifyContent = theme.justifyContent } = p.attribute;
        const children = p.getChildren();
        if (width == null || height == null) {
            let childrenWidth = 0;
            let childrenHeight = 0;
            let boundsLegal = 0;
            children.forEach((child) => {
                const bounds = this.getAABBBounds(child);
                if (bounds.empty()) {
                    return;
                }
                if (flexDirection === 'column' || flexDirection === 'column-reverse') {
                    childrenHeight += bounds.height();
                    childrenWidth = Math.max(childrenWidth, bounds.width());
                }
                else {
                    childrenWidth += bounds.width();
                    childrenHeight = Math.max(childrenHeight, bounds.height());
                }
                boundsLegal += bounds.x1;
                boundsLegal += bounds.y1;
                boundsLegal += bounds.x2;
                boundsLegal += bounds.y2;
            });
            if (!isFinite(boundsLegal)) {
                return;
            }
            width = childrenWidth;
            height = childrenHeight;
        }
        if (p.attribute.width == null) {
            p.attribute.width = width;
        }
        else {
            width = p.attribute.width;
        }
        if (p.attribute.height == null) {
            p.attribute.height = height;
        }
        else {
            height = p.attribute.height;
        }
        this.tempBounds.copy(p._AABBBounds);
        const result = {
            main: { len: width, field: 'x' },
            cross: { len: height, field: 'y' }
        };
        const main = result.main;
        const cross = result.cross;
        if (flexDirection === 'column' || flexDirection === 'column-reverse') {
            main.len = height;
            cross.len = width;
            main.field = 'y';
            cross.field = 'x';
        }
        if (flexDirection === 'row-reverse' || flexDirection === 'column-reverse') {
            if (justifyContent === 'flex-start') {
                justifyContent = 'flex-end';
            }
            else if (justifyContent === 'flex-end') {
                justifyContent = 'flex-start';
            }
            else {
                children.reverse();
            }
        }
        let mainLen = 0;
        let crossLen = 0;
        const mianLenArray = [];
        children.forEach((c) => {
            const b = this.getAABBBounds(c);
            if (b.empty()) {
                return;
            }
            const ml = main.field === 'x' ? b.width() : b.height();
            const cl = cross.field === 'x' ? b.width() : b.height();
            mianLenArray.push({ mainLen: ml, crossLen: cl });
            mainLen += ml;
            crossLen = Math.max(crossLen, cl);
        });
        const mainList = [];
        if (mainLen > main.len && flexWrap === 'wrap') {
            let tempMainL = 0;
            let tempCrossL = 0;
            mianLenArray.forEach(({ mainLen, crossLen }, i) => {
                if (tempMainL + mainLen > main.len) {
                    if (tempMainL === 0) {
                        mainList.push({ idx: i, mainLen: tempMainL + mainLen, crossLen });
                        tempMainL = 0;
                        tempCrossL = 0;
                    }
                    else {
                        mainList.push({ idx: i - 1, mainLen: tempMainL, crossLen: tempCrossL });
                        tempMainL = mainLen;
                        tempCrossL = crossLen;
                    }
                }
                else {
                    tempMainL += mainLen;
                    tempCrossL = Math.max(tempCrossL, crossLen);
                }
            });
            mainList.push({ idx: mianLenArray.length - 1, mainLen: tempMainL, crossLen: tempCrossL });
        }
        else {
            mainList.push({ idx: mianLenArray.length - 1, mainLen: mainLen, crossLen });
        }
        let lastIdx = 0;
        mainList.forEach(s => {
            this.layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, s);
            lastIdx = s.idx + 1;
        });
        crossLen = mainList.reduce((a, b) => a + b.crossLen, 0);
        if (mainList.length === 1) {
            const anchorPosMap = {
                'flex-start': 0,
                'flex-end': cross.len,
                center: cross.len / 2
            };
            this.layoutCross(children, alignItems, cross, anchorPosMap, mianLenArray, mainList[0], 0);
        }
        else {
            if (alignContent === 'flex-start') {
                lastIdx = 0;
                let anchorPos = 0;
                mainList.forEach((s, i) => {
                    const anchorPosMap = {
                        'flex-start': anchorPos,
                        'flex-end': anchorPos + s.crossLen,
                        center: anchorPos + s.crossLen / 2
                    };
                    this.layoutCross(children, 'flex-start', cross, anchorPosMap, mianLenArray, mainList[i], lastIdx);
                    lastIdx = s.idx + 1;
                    anchorPos += s.crossLen;
                });
            }
            else if (alignContent === 'center') {
                lastIdx = 0;
                const padding = Math.max(0, (cross.len - crossLen) / 2);
                let anchorPos = padding;
                mainList.forEach((s, i) => {
                    const anchorPosMap = {
                        'flex-start': anchorPos,
                        'flex-end': anchorPos + s.crossLen,
                        center: anchorPos + s.crossLen / 2
                    };
                    this.layoutCross(children, 'center', cross, anchorPosMap, mianLenArray, mainList[i], lastIdx);
                    lastIdx = s.idx + 1;
                    anchorPos += s.crossLen;
                });
            }
            else if (alignContent === 'space-around') {
                lastIdx = 0;
                const padding = Math.max(0, (cross.len - crossLen) / mainList.length / 2);
                let anchorPos = padding;
                mainList.forEach((s, i) => {
                    const anchorPosMap = {
                        'flex-start': anchorPos,
                        'flex-end': anchorPos + s.crossLen,
                        center: anchorPos + s.crossLen / 2
                    };
                    this.layoutCross(children, 'flex-start', cross, anchorPosMap, mianLenArray, mainList[i], lastIdx);
                    lastIdx = s.idx + 1;
                    anchorPos += s.crossLen + padding * 2;
                });
            }
            else if (alignContent === 'space-between') {
                lastIdx = 0;
                const padding = Math.max(0, (cross.len - crossLen) / (mainList.length * 2 - 2));
                let anchorPos = 0;
                mainList.forEach((s, i) => {
                    const anchorPosMap = {
                        'flex-start': anchorPos,
                        'flex-end': anchorPos + s.crossLen,
                        center: anchorPos + s.crossLen / 2
                    };
                    this.layoutCross(children, 'flex-start', cross, anchorPosMap, mianLenArray, mainList[i], lastIdx);
                    lastIdx = s.idx + 1;
                    anchorPos += s.crossLen + padding * 2;
                });
            }
        }
        children.forEach((child, idx) => {
            child.addUpdateBoundTag();
            child.addUpdatePositionTag();
            child.clearUpdateLayoutTag();
        });
        p.addUpdateLayoutTag();
        const b = this.getAABBBounds(p);
        if (!clip && !this.tempBounds.equals(b)) {
            this.tryLayout(p, false);
        }
    }
    getAABBBounds(graphic) {
        this.skipBoundsTrigger = true;
        const b = graphic.AABBBounds;
        this.skipBoundsTrigger = false;
        return b;
    }
    updateChildPos(posBaseLeftTop, lastP, lastBP) {
        return posBaseLeftTop + (lastP !== null && lastP !== void 0 ? lastP : 0) - lastBP;
    }
    layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, currSeg) {
        if (justifyContent === 'flex-start') {
            let pos = 0;
            for (let i = lastIdx; i <= currSeg.idx; i++) {
                const posBaseLeftTop = pos + getPadding(children[i], main.field);
                const b = this.getAABBBounds(children[i]);
                !b.empty() &&
                    (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`]));
                pos += mianLenArray[i].mainLen;
            }
        }
        else if (justifyContent === 'flex-end') {
            let pos = main.len;
            for (let i = currSeg.idx; i >= lastIdx; i--) {
                pos -= mianLenArray[i].mainLen;
                const posBaseLeftTop = pos + getPadding(children[i], main.field);
                const b = this.getAABBBounds(children[i]);
                !b.empty() &&
                    (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`]));
            }
        }
        else if (justifyContent === 'space-around') {
            if (currSeg.mainLen >= main.len) {
                let pos = 0;
                for (let i = lastIdx; i <= currSeg.idx; i++) {
                    const posBaseLeftTop = pos + getPadding(children[i], main.field);
                    const b = this.getAABBBounds(children[i]);
                    !b.empty() &&
                        (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`]));
                    pos += mianLenArray[i].mainLen;
                }
            }
            else {
                const size = currSeg.idx - lastIdx + 1;
                const padding = (main.len - currSeg.mainLen) / size / 2;
                let pos = padding;
                for (let i = lastIdx; i <= currSeg.idx; i++) {
                    const posBaseLeftTop = pos + getPadding(children[i], main.field);
                    const b = this.getAABBBounds(children[i]);
                    !b.empty() &&
                        (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`]));
                    pos += mianLenArray[i].mainLen + padding * 2;
                }
            }
        }
        else if (justifyContent === 'space-between') {
            if (currSeg.mainLen >= main.len) {
                let pos = 0;
                for (let i = lastIdx; i <= currSeg.idx; i++) {
                    const posBaseLeftTop = pos + getPadding(children[i], main.field);
                    const b = this.getAABBBounds(children[i]);
                    !b.empty() &&
                        (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`]));
                    pos += mianLenArray[i].mainLen;
                }
            }
            else {
                const size = currSeg.idx - lastIdx + 1;
                const padding = (main.len - currSeg.mainLen) / (size * 2 - 2);
                let pos = 0;
                for (let i = lastIdx; i <= currSeg.idx; i++) {
                    const posBaseLeftTop = pos + getPadding(children[i], main.field);
                    const b = this.getAABBBounds(children[i]);
                    !b.empty() &&
                        (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`]));
                    pos += mianLenArray[i].mainLen + padding * 2;
                }
            }
        }
        else if (justifyContent === 'center') {
            let pos = (main.len - currSeg.mainLen) / 2;
            for (let i = lastIdx; i <= currSeg.idx; i++) {
                const posBaseLeftTop = pos + getPadding(children[i], main.field);
                const b = this.getAABBBounds(children[i]);
                !b.empty() &&
                    (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`]));
                pos += mianLenArray[i].mainLen;
            }
        }
    }
    layoutCross(children, alignItem, cross, anchorPosMap, lenArray, currSeg, lastIdx) {
        var _a;
        for (let i = lastIdx; i <= currSeg.idx; i++) {
            const child = children[i];
            let { alignSelf } = child.attribute;
            if (!alignSelf || alignSelf === 'auto') {
                alignSelf = alignItem;
            }
            const b = this.getAABBBounds(child);
            const anchorPos = (_a = anchorPosMap[alignSelf]) !== null && _a !== void 0 ? _a : anchorPosMap['flex-start'];
            if (alignSelf === 'flex-end') {
                !b.empty() &&
                    (child.attribute[cross.field] = this.updateChildPos(anchorPos - lenArray[i].crossLen + getPadding(child, cross.field), child.attribute[cross.field], b[`${cross.field}1`]));
            }
            else if (alignSelf === 'center') {
                !b.empty() &&
                    (child.attribute[cross.field] = this.updateChildPos(anchorPos - lenArray[i].crossLen / 2 + getPadding(child, cross.field), child.attribute[cross.field], b[`${cross.field}1`]));
            }
            else {
                !b.empty() &&
                    (child.attribute[cross.field] = this.updateChildPos(anchorPos + getPadding(child, cross.field), child.attribute[cross.field], b[`${cross.field}1`]));
            }
        }
    }
    activate(context) {
        this.pluginService = context;
        const stage = this.pluginService.stage;
        if (!stage) {
            return;
        }
        stage.graphicService.hooks.onAttributeUpdate.tap(this.key, graphic => {
            if (graphic.glyphHost) {
                graphic = graphic.glyphHost;
            }
            if (!(graphic.stage && graphic.stage === this.pluginService.stage)) {
                return;
            }
            this.tryLayout(graphic, false);
        });
        stage.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
            if (graphic.glyphHost) {
                graphic = graphic.glyphHost;
            }
            if (!(stage && stage === this.pluginService.stage)) {
                return;
            }
            if (!graphic.isContainer || this.skipBoundsTrigger) {
                return;
            }
            _tempBounds.copy(bounds);
        });
        stage.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params, selfChange) => {
            if (!(stage && stage === this.pluginService.stage)) {
                return;
            }
            if (!graphic.isContainer || this.skipBoundsTrigger) {
                return;
            }
            if (!_tempBounds.equals(bounds)) {
                this.tryLayout(graphic, false);
            }
        });
        stage.graphicService.hooks.onSetStage.tap(this.key, graphic => {
            if (graphic.glyphHost) {
                graphic = graphic.glyphHost;
            }
            this.tryLayout(graphic, false);
        });
    }
    deactivate(context) {
        const stage = this.pluginService.stage;
        if (!stage) {
            return;
        }
        stage.graphicService.hooks.onAttributeUpdate.taps = stage.graphicService.hooks.onAttributeUpdate.taps.filter(item => {
            return item.name !== this.key;
        });
        stage.graphicService.hooks.beforeUpdateAABBBounds.taps =
            stage.graphicService.hooks.beforeUpdateAABBBounds.taps.filter(item => {
                return item.name !== this.key;
            });
        stage.graphicService.hooks.afterUpdateAABBBounds.taps =
            stage.graphicService.hooks.afterUpdateAABBBounds.taps.filter(item => {
                return item.name !== this.key;
            });
        stage.graphicService.hooks.onSetStage.taps = stage.graphicService.hooks.onSetStage.taps.filter(item => {
            return item.name !== this.key;
        });
    }
}
function getPadding(graphic, field) {
    return 0;
}
const registerFlexLayoutPlugin = () => {
    Factory.registerPlugin('FlexLayoutPlugin', FlexLayoutPlugin);
};

export { ARC3D_NUMBER_TYPE, ARC_NUMBER_TYPE, AREA_NUMBER_TYPE, AbstractGraphicRender, AnimateMode, AnimateStatus, AnimateStepType, Application, Arc, Arc3d, Arc3dRender, ArcRender, ArcRenderContribution, Area, AreaRender, AreaRenderContribution, AttributeUpdateType, AutoEnablePlugins, BaseCanvas, BaseEnvContribution, BaseRender, BaseRenderContributionTime, BaseWindowHandlerContribution, Basis, BeforeRenderConstribution, BoundsContext, BoundsPicker, CIRCLE_NUMBER_TYPE, Canvas3DDrawItemInterceptor, Canvas3DPickItemInterceptor, CanvasFactory, CanvasTextLayout, Circle, CircleRender, CircleRenderContribution, ColorInterpolate, ColorStore, ColorType, CommonDrawItemInterceptorContribution, CommonRenderContribution, Container, ContainerModule, Context2dFactory, ContributionProvider, ContributionStore, CubicBezierCurve, CurveContext, CurveTypeEnum, CustomEvent, CustomPath2D, CustomSymbolClass, DEFAULT_TEXT_FONT_FAMILY, DebugDrawItemInterceptorContribution, DefaultArcAllocate, DefaultArcAttribute, DefaultArcRenderContribution, DefaultAreaAllocate, DefaultAreaAttribute, DefaultAreaTextureRenderContribution, DefaultAttribute, DefaultBaseBackgroundRenderContribution, DefaultBaseClipRenderAfterContribution, DefaultBaseClipRenderBeforeContribution, DefaultBaseInteractiveRenderContribution, DefaultBaseTextureRenderContribution, DefaultCanvasAllocate, DefaultCanvasArcRender, DefaultCanvasAreaRender, DefaultCanvasCircleRender, DefaultCanvasGroupRender, DefaultCanvasImageRender, DefaultCanvasLineRender, DefaultCanvasPathRender, DefaultCanvasPolygonRender, DefaultCanvasRectRender, DefaultCanvasSymbolRender, DefaultCanvasTextRender, DefaultCircleAllocate, DefaultCircleAttribute, DefaultCircleRenderContribution, DefaultConnectAttribute, DefaultDebugAttribute, DefaultFillStyle, DefaultGlobal, DefaultGlobalPickerService, DefaultGlyphAttribute, DefaultGraphicAllocate, DefaultGraphicMemoryManager, DefaultGraphicService, DefaultGraphicUtil, DefaultGroupAttribute, DefaultGroupBackgroundRenderContribution, DefaultImageAttribute, DefaultImageRenderContribution, DefaultLayerService, DefaultLayout, DefaultLineAllocate, DefaultLineAttribute, DefaultMat4Allocate, DefaultMatrixAllocate, DefaultPathAllocate, DefaultPathAttribute, DefaultPickService, DefaultPickStyle, DefaultPolygonAttribute, DefaultRect3dAttribute, DefaultRectAllocate, DefaultRectAttribute, DefaultRectRenderContribution, DefaultRenderService, DefaultRichTextAttribute, DefaultRichTextIconAttribute, DefaultStarAttribute, DefaultStrokeStyle, DefaultStyle, DefaultSymbolAllocate, DefaultSymbolAttribute, DefaultSymbolClipRangeStrokeRenderContribution, DefaultSymbolRenderContribution, DefaultTextAllocate, DefaultTextAttribute, DefaultTextMeasureContribution, DefaultTextStyle, DefaultTransform, DefaultTransformUtil, DefaultWindow, Direction, DirectionalLight, DrawContribution, DrawItemInterceptor, DynamicLayerHandlerContribution, Edge, EditModule, EmptyContext2d, EnvContribution, EventManager, EventSystem, EventTarget, FORMAT_ALL_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, FORMAT_TEXT_COMMAND, Factory, FederatedEvent, FederatedMouseEvent, FederatedPointerEvent, FederatedWheelEvent, FlexLayoutPlugin, GLYPH_NUMBER_TYPE, GRAPHIC_UPDATE_TAG_KEY, GROUP_NUMBER_TYPE, Generator, GlobalPickerService, Glyph, GlyphRender, GradientParser, Graphic, GraphicCreator$1 as GraphicCreator, GraphicPicker, GraphicRender, GraphicService, GraphicUtil, Group, GroupRender, GroupRenderContribution, GroupUpdateAABBBoundsMode, HtmlAttributePlugin, IContainPointMode, IMAGE_NUMBER_TYPE, Image, ImageRender, ImageRenderContribution, IncrementalDrawContribution, InteractiveDrawItemInterceptorContribution, InteractivePickItemInterceptorContribution, InteractiveSubRenderContribution, LINE_NUMBER_TYPE, Layer, LayerService, Line$1 as Line, LineRender, Linear, LinearClosed, Mat4Allocate, MatrixAllocate, MeasureModeEnum, MonotoneX, MonotoneY, NOWORK_ANIMATE_ATTR, Node, OrthoCamera, PATH_NUMBER_TYPE, POLYGON_NUMBER_TYPE, PURE_STYLE_KEY, PYRAMID3D_NUMBER_TYPE, Path, PathRender, PathRenderContribution, PerformanceRAF, PickItemInterceptor, PickServiceInterceptor, PickerService, PluginService, Polygon, PolygonRender, PolygonRenderContribution, Pyramid3d, Pyramid3dRender, RECT3D_NUMBER_TYPE, RECT_NUMBER_TYPE, RICHTEXT_NUMBER_TYPE, RafBasedSTO, ReactAttributePlugin, Rect, Rect3DRender, Rect3d, RectRender, RectRenderContribution, ReflectSegContext, RenderSelector, RenderService, ResourceLoader, RichText, RichTextEditPlugin, RichTextRender, STAR_NUMBER_TYPE, STATUS$1 as STATUS, SVG_ATTRIBUTE_MAP, SVG_ATTRIBUTE_MAP_KEYS, SVG_PARSE_ATTRIBUTE_MAP, SVG_PARSE_ATTRIBUTE_MAP_KEYS, SYMBOL_NUMBER_TYPE, SegContext, ShadowPickServiceInterceptorContribution, ShadowRoot, ShadowRootDrawItemInterceptorContribution, ShadowRootPickItemInterceptorContribution, SplitRectAfterRenderContribution, SplitRectBeforeRenderContribution, Stage, Star, StarRender, StarRenderContribution, StaticLayerHandlerContribution, Step, StepClosed, Symbol$1 as Symbol, SymbolRender, SymbolRenderContribution, TEXT_NUMBER_TYPE, Text, TextDirection, TextMeasureContribution, TextRender, TextRenderContribution, Theme, TransformUtil, UpdateTag, VGlobal, VWindow, ViewTransform3dPlugin, VirtualLayerHandlerContribution, WILDCARD, WindowHandlerContribution, WrapText, XMLParser, _calculateLineHeight, _interpolateColor, addArcToBezierPath, addAttributeToPrototype, alignBezierCurves, alignSubpath, application, applyTransformOnBezierCurves, arc3dModule, arcModule, areaModule, bezier, bezierCurversToPath, binarySplitPolygon, bindContributionProvider, bindContributionProviderNoSingletonScope, boundStroke, builtInSymbolStrMap, builtinSymbols, builtinSymbolsMap, calcLineCache, calculateArcCornerRadius, calculateLineHeight, canvasAllocate, centroidOfSubpath, circleBounds, circleModule, clock, colorEqual, colorStringInterpolationToStr, container, cornerTangents, createArc, createArc3d, createArea, createCanvasEventTransformer, createCircle, createColor, createConicalGradient, createEventTransformer, createGlyph, createGroup, createImage, createLine, createMat4, createPath, createPolygon, createPyramid3d, createRect, createRect3d, createRectPath, createRichText, createShadowRoot, createStage, createStar, createSymbol, createText, createWrapText, cubicCalc, cubicLength, cubicPointAt, cubicSubdivide, defaultArcAllocate, defaultArcBackgroundRenderContribution, defaultArcRenderContribution, defaultArcTextureRenderContribution, defaultAreaAllocate, defaultBaseBackgroundRenderContribution, defaultBaseClipRenderAfterContribution, defaultBaseClipRenderBeforeContribution, defaultBaseTextureRenderContribution, defaultCircleAllocate, defaultCircleBackgroundRenderContribution, defaultCircleRenderContribution, defaultCircleTextureRenderContribution, defaultGraphicMemoryManager, defaultGroupBackgroundRenderContribution, defaultImageBackgroundRenderContribution, defaultImageRenderContribution, defaultLineAllocate, defaultPathAllocate, defaultRectAllocate, defaultRectBackgroundRenderContribution, defaultRectRenderContribution, defaultRectTextureRenderContribution, defaultStarBackgroundRenderContribution, defaultStarTextureRenderContribution, defaultSymbolAllocate, defaultSymbolBackgroundRenderContribution, defaultSymbolClipRangeStrokeRenderContribution, defaultSymbolRenderContribution, defaultSymbolTextureRenderContribution, defaultTextAllocate, diff, divideCubic, drawArc, drawArcPath$1 as drawArcPath, drawAreaSegments, drawIncrementalAreaSegments, drawIncrementalSegments, drawSegments, enumCommandMap, fillVisible, findBestMorphingRotation, findConfigIndexByCursorIdx, findCursorIdxByConfigIndex, findNextGraphic, flatten_simplify, foreach, foreachAsync, genBasisSegments, genBasisTypeSegments, genLinearClosedSegments, genLinearClosedTypeSegments, genLinearSegments, genLinearTypeSegments, genMonotoneXSegments, genMonotoneXTypeSegments, genMonotoneYSegments, genMonotoneYTypeSegments, genNumberType, genStepClosedSegments, genStepSegments, genStepTypeSegments, getAttributeFromDefaultAttrList, getConicGradientAt, getCurrentEnv, getDefaultCharacterConfig, getExtraModelMatrix, getModelMatrix, getRichTextBounds, getScaledStroke, getTextBounds, getTheme, getThemeFromGroup, globalTheme, glyphModule, graphicCreator, graphicService, graphicUtil, identityMat4, imageModule, incrementalAddTo, inject, injectable, interpolateColor, interpolateGradientConicalColor, interpolateGradientLinearColor, interpolateGradientRadialColor, interpolatePureColorArray, interpolatePureColorArrayToStr, intersect, isBrowserEnv, isNodeEnv, isSvg, isXML, layerService, lineModule, lookAt, mapToCanvasPointForCanvas, mat3Tomat4, mat4Allocate, matrixAllocate, multiInject, multiplyMat4Mat3, multiplyMat4Mat4, named, newThemeObj, ortho, parsePadding, parseStroke, parseSvgPath, pathModule, pathToBezierCurves, point$3 as point, pointEqual, pointInterpolation, pointInterpolationHighPerformance, pointsEqual, pointsInterpolation, polygonModule, preLoadAllModule, pyramid3dModule, quadCalc, quadLength, quadPointAt, rafBasedSto, rect3dModule, rectFillVisible, rectModule, rectStrokeVisible, recursiveCallBinarySplit, registerArc3dGraphic, registerArcGraphic, registerAreaGraphic, registerCircleGraphic, registerDirectionalLight, registerFlexLayoutPlugin, registerGlobalEventTransformer, registerGlyphGraphic, registerGroupGraphic, registerHtmlAttributePlugin, registerImageGraphic, registerLineGraphic, registerOrthoCamera, registerPathGraphic, registerPolygonGraphic, registerPyramid3dGraphic, registerReactAttributePlugin, registerRect3dGraphic, registerRectGraphic, registerRichtextGraphic, registerShadowRootGraphic, registerStarGraphic, registerSymbolGraphic, registerTextGraphic, registerViewTransform3dPlugin, registerWindowEventTransformer, registerWrapTextGraphic, renderCommandList, renderService, rewriteProto, richtextModule, rotateX, rotateY, rotateZ, runFill, runStroke, scaleMat4, segments, shouldUseMat4, snapLength, splitArc, splitArea, splitCircle, splitLine, splitPath, splitPolygon, splitRect, splitToGrids, starModule, strCommandMap, strokeVisible, symbolModule, textAttributesToStyle, textDrawOffsetX, textDrawOffsetY, textLayoutOffsetY, textModule, transformMat4, transformPointForCanvas, transformUtil, translate, verticalLayout, vglobal, waitForAllSubLayers, wrapCanvas, wrapContext, xul };
